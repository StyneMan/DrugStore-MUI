function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$8 = Symbol.for("react.element"), n$a = Symbol.for("react.portal"), p$a = Symbol.for("react.fragment"), q$8 = Symbol.for("react.strict_mode"), r$6 = Symbol.for("react.profiler"), t$7 = Symbol.for("react.provider"), u$9 = Symbol.for("react.context"), v$8 = Symbol.for("react.forward_ref"), w$6 = Symbol.for("react.suspense"), x$5 = Symbol.for("react.memo"), y$4 = Symbol.for("react.lazy"), z$6 = Symbol.iterator;
function A$7(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$6 && a2[z$6] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$4 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$3 = Object.assign, D$5 = {};
function E$5(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$5;
  this.updater = e2 || B$4;
}
E$5.prototype.isReactComponent = {};
E$5.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$5.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$5() {
}
F$5.prototype = E$5.prototype;
function G$5(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$5;
  this.updater = e2 || B$4;
}
var H$5 = G$5.prototype = new F$5();
H$5.constructor = G$5;
C$3(H$5, E$5.prototype);
H$5.isPureReactComponent = true;
var I$5 = Array.isArray, J$3 = Object.prototype.hasOwnProperty, K$4 = { current: null }, L$5 = { key: true, ref: true, __self: true, __source: true };
function M$5(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$3.call(b2, d2) && !L$5.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$8, type: a2, key: k2, ref: h2, props: c2, _owner: K$4.current };
}
function N$4(a2, b2) {
  return { $$typeof: l$8, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$5(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$8;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$5 = /\/+/g;
function Q$5(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$4(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$8:
          case n$a:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$5(h2, 0) : d2, I$5(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$5, "$&/") + "/"), R$4(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$5(c2) && (c2 = N$4(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$5, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$5(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$5(k2, g2);
      h2 += R$4(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$7(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$5(k2, g2++), h2 += R$4(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$5(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$4(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$5(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$6 = { current: null }, V$5 = { transition: null }, W$6 = { ReactCurrentDispatcher: U$6, ReactCurrentBatchConfig: V$5, ReactCurrentOwner: K$4 };
react_production_min.Children = { map: S$5, forEach: function(a2, b2, e2) {
  S$5(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$5(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$5(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$5(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$5;
react_production_min.Fragment = p$a;
react_production_min.Profiler = r$6;
react_production_min.PureComponent = G$5;
react_production_min.StrictMode = q$8;
react_production_min.Suspense = w$6;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$6;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$4.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$3.call(b2, f2) && !L$5.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$8, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$9, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$7, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$5;
react_production_min.createFactory = function(a2) {
  var b2 = M$5.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$8, render: a2 };
};
react_production_min.isValidElement = O$5;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$4, _payload: { _status: -1, _result: a2 }, _init: T$5 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$5, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$5.transition;
  V$5.transition = {};
  try {
    a2();
  } finally {
    V$5.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$6.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$6.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$6.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$6.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$6.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$6.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$6.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$6.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$6.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$6.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$6.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$6.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$6.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$6.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$7 = reactExports, k$6 = Symbol.for("react.element"), l$7 = Symbol.for("react.fragment"), m$8 = Object.prototype.hasOwnProperty, n$9 = f$7.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$9 = { key: true, ref: true, __self: true, __source: true };
function q$7(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$8.call(a2, b2) && !p$9.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$6, type: c2, key: e2, ref: h2, props: d2, _owner: n$9.current };
}
reactJsxRuntime_production_min.Fragment = l$7;
reactJsxRuntime_production_min.jsx = q$7;
reactJsxRuntime_production_min.jsxs = q$7;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports2) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports2.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports2.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t3 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B3 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t3); null !== b2; ) {
      if (null === b2.callback)
        k2(t3);
      else if (b2.startTime <= a2)
        k2(t3), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t3);
    }
  }
  function H4(a2) {
    B3 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t3);
        null !== b2 && K2(H4, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B3 && (B3 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports2.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t3);
        null !== m2 && K2(H4, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports2.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports2.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports2.unstable_now());
    }, b2);
  }
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports2.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports2.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = function() {
  };
  exports2.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports2.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports2.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t3, a2), null === h2(r2) && a2 === h2(t3) && (B3 ? (E2(L2), L2 = -1) : B3 = true, K2(H4, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports2.unstable_shouldYield = M2;
  exports2.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$8(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$7(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$5 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$5[a2] = new v$7(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$5[b2] = new v$7(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$5[a2] = new v$7(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$5[a2] = new v$7(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$5[a2] = new v$7(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$5[a2] = new v$7(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$5[a2] = new v$7(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$5[a2] = new v$7(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$5[a2] = new v$7(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$5[b2] = new v$7(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$5[b2] = new v$7(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$5[b2] = new v$7(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$5[a2] = new v$7(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$5.xlinkHref = new v$7("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$5[a2] = new v$7(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$5.hasOwnProperty(b2) ? z$5[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$6 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$6({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$8(91));
  return A$6({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$8(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$8(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$6({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$8(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$8(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$8(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$8(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$8(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$8(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$8(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$8(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$8(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$8(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$8(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$8(190));
  }
  if (3 !== c2.tag)
    throw Error(p$8(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$3 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc$1 = null;
function mc(a2) {
  if (lc$1 && "function" === typeof lc$1.onCommitFiberRoot)
    try {
      lc$1.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$2 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 1, fd$1(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 4, fd$1(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
function fd$1(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$6(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$6({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$6({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$6({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$6({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$6({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$6({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$6({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$6({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$6({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$6({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$6({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$6({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$2 = ia && "CompositionEvent" in window, be$3 = null;
ia && "documentMode" in document && (be$3 = document.documentMode);
var ce$2 = ia && "TextEvent" in window && !be$3, de$3 = ia && (!ae$2 || be$3 && 8 < be$3 && 11 >= be$3), ee$3 = String.fromCharCode(32), fe$3 = false;
function ge$3(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$3(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$2 = false;
function je$1(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$3(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$3 = true;
      return ee$3;
    case "textInput":
      return a2 = b2.data, a2 === ee$3 && fe$3 ? null : a2;
    default:
      return null;
  }
}
function ke$1(a2, b2) {
  if (ie$2)
    return "compositionend" === a2 || !ae$2 && ge$3(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$2 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$3 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$3 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$2(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$3[a2.type] : "textarea" === b2 ? true : false;
}
function ne$3(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$3(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$3 = null, qe$1 = null;
function re$3(a2) {
  se$3(a2, 0);
}
function te$2(a2) {
  var b2 = ue$3(a2);
  if (Wa(b2))
    return a2;
}
function ve$3(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$2 = false;
if (ia) {
  var xe$2;
  if (ia) {
    var ye$3 = "oninput" in document;
    if (!ye$3) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye$3 = "function" === typeof ze$1.oninput;
    }
    xe$2 = ye$3;
  } else
    xe$2 = false;
  we$2 = xe$2 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$2() {
  pe$3 && (pe$3.detachEvent("onpropertychange", Be$1), qe$1 = pe$3 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$2(qe$1)) {
    var b2 = [];
    ne$3(b2, qe$1, a2, xb(a2));
    Jb(re$3, b2);
  }
}
function Ce$1(a2, b2, c2) {
  "focusin" === a2 ? (Ae$2(), pe$3 = b2, qe$1 = c2, pe$3.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$2();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$2(qe$1);
}
function Ee$2(a2, b2) {
  if ("click" === a2)
    return te$2(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$2(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$2(a2, b2) {
  if (He$1(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He$1(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke$1(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le$2(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$2(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$2(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe$1(a2) {
  var b2 = Me$1(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$2(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$2(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke$1(c2, f2);
        var g2 = Ke$1(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$2 = null, Se$2 = null, Te$2 = false;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$2 || null == Qe$1 || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne$2(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$2 && Ie$2(Se$2, d2) || (Se$2 = d2, d2 = oe$3(Re$2, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
function Ve$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a2] = b2[c2];
  return a2;
}
var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$3(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$4(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd$1;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t3 = 0 !== (b2 & 4), J2 = !t3 && "scroll" === a2, x2 = t3 ? null !== h3 ? h3 + "Capture" : null : h3;
        t3 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t3.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t3.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t3 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t3 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t3 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$3(k3);
            u2 = null == n2 ? h3 : ue$3(n2);
            h3 = new t3(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t3 = new t3(x2, w2 + "enter", n2, c2, e3), t3.target = u2, t3.relatedTarget = J2, F2 = t3);
            J2 = F2;
            if (k3 && n2)
              b: {
                t3 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t3; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t3 = vf(t3), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t3 === x2 || null !== x2 && t3 === x2.alternate)
                    break b;
                  t3 = vf(t3);
                  x2 = vf(x2);
                }
                t3 = null;
              }
            else
              t3 = null;
            null !== k3 && wf(g3, h3, k3, t3, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t3, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$3(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$3;
        else if (me$2(h3))
          if (we$2)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$1;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$2);
        if (na && (na = na(a2, d3))) {
          ne$3(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue$3(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$2(xa) || "true" === xa.contentEditable)
            Qe$1 = xa, Re$2 = d3, Se$2 = null;
          break;
        case "focusout":
          Se$2 = Re$2 = Qe$1 = null;
          break;
        case "mousedown":
          Te$2 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$2 = false;
          Ue$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e3);
      }
      var $a;
      if (ae$2)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$2 ? ge$3(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$3 && "ko" !== c2.locale && (ie$2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$2 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = true)), xa = oe$3(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$3(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$2 ? je$1(a2, c2) : ke$1(a2, c2))
        d3 = oe$3(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se$3(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$3(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$8(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$3(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$8(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$4(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$4(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$4 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$4(Wf);
  E$4(H$4);
}
function ag(a2, b2, c2) {
  if (H$4.current !== Vf)
    throw Error(p$8(168));
  G$4(H$4, b2);
  G$4(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$8(108, Ra(a2) || "Unknown", e2));
  return A$6({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$4.current;
  G$4(H$4, a2);
  G$4(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$8(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$4(Wf), E$4(H$4), G$4(H$4, a2)) : E$4(Wf);
  G$4(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$2;
    try {
      var c2 = eg;
      for (C$2 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$2 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$4 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$4) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$8(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$4 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$8(418));
      a2.flags = a2.flags & -4097 | 2;
      I$4 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$4)
    return Fg(a2), I$4 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$8(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$8(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$4 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$6({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$4(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$8(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$3 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t3 = h2;
          r2 = b2;
          y2 = c2;
          switch (t3.tag) {
            case 1:
              n2 = t3.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t3.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$6({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$8(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$6({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$4(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$4(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$4(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$2(c2, d2) || !Ie$2(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$4.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$4.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$8(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$8(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$8(284));
    if (!c2._owner)
      throw Error(p$8(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$8(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$4 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$4 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$4 && tg(e3, w2);
    return l3;
  }
  function t3(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$8(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$8(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t4 = r2(e3, m3, n3.value, k3);
      if (null === t4) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t4.alternate && b2(e3, m3);
      g3 = f2(t4, g3, w2);
      null === u2 ? l3 = t4 : u2.sibling = t4;
      u2 = t4;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$4 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$4 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$4 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t3(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$8(174));
  return a2;
}
function Ih(a2, b2) {
  G$4(Gh, b2);
  G$4(Fh, a2);
  G$4(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$4(Eh);
  G$4(Eh, b2);
}
function Jh() {
  E$4(Eh);
  E$4(Fh);
  E$4(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$4(Fh, a2), G$4(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$4(Eh), E$4(Fh));
}
var M$4 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$3 = null, O$4 = null, P$4 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$4() {
  throw Error(p$8(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N$3 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$8(301));
      f2 += 1;
      P$4 = O$4 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$4 && null !== O$4.next;
  Rh = 0;
  P$4 = O$4 = N$3 = null;
  Sh = false;
  if (b2)
    throw Error(p$8(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$4 ? N$3.memoizedState = P$4 = a2 : P$4 = P$4.next = a2;
  return P$4;
}
function di() {
  if (null === O$4) {
    var a2 = N$3.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$4.next;
  var b2 = null === P$4 ? N$3.memoizedState : P$4.next;
  if (null !== b2)
    P$4 = b2, O$4 = a2;
  else {
    if (null === a2)
      throw Error(p$8(310));
    O$4 = a2;
    a2 = { memoizedState: O$4.memoizedState, baseState: O$4.baseState, baseQueue: O$4.baseQueue, queue: O$4.queue, next: null };
    null === P$4 ? N$3.memoizedState = P$4 = a2 : P$4 = P$4.next = a2;
  }
  return P$4;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$8(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$4, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$3.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He$1(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N$3.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$8(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$1(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N$3, d2 = di(), e2 = b2(), f2 = !He$1(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$4 && P$4.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R$3)
      throw Error(p$8(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$3.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$3.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$1(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N$3, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$3.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$3.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N$3.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$4) {
    var g2 = O$4.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N$3.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$1(c2, b2) || (c2 = yc(), N$3.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C$2;
  C$2 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$2 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L$4();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He$1(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L$4(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$3 || null !== b2 && b2 === N$3;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$4, useContext: Q$4, useEffect: Q$4, useImperativeHandle: Q$4, useInsertionEffect: Q$4, useLayoutEffect: Q$4, useMemo: Q$4, useReducer: Q$4, useRef: Q$4, useState: Q$4, useDebugValue: Q$4, useDeferredValue: Q$4, useTransition: Q$4, useMutableSource: Q$4, useSyncExternalStore: Q$4, useId: Q$4, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$3, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$3, e2 = ci();
  if (I$4) {
    if (void 0 === c2)
      throw Error(p$8(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$3)
      throw Error(p$8(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R$3.identifierPrefix;
  if (I$4) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O$4.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O$4 ? b2.memoizedState = a2 : Di(b2, O$4.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$4 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$2;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$2(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$4(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$4(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$4(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$4(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$4.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$4 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$4.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$4.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$4.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$4(M$4, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$8(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$8(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$3;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$8(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$4 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$4.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$4(M$4, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$8(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$4(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$4(M$4, M$4.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$4(M$4, M$4.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$4(M$4, M$4.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$4(M$4, M$4.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$6({}, e2, { value: void 0 });
        d2 = A$6({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$4("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$4)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$4(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$4(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$4(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$4(Wf);
      E$4(H$4);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$4(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$8(166));
          S$4(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$4("cancel", d2);
              D$4("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$4("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$4(lf[e2], d2);
              break;
            case "source":
              D$4("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$4(
                "error",
                d2
              );
              D$4("load", d2);
              break;
            case "details":
              D$4("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$4("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$4("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$4("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$4("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$4("cancel", a2);
                D$4("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$4("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$4(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$4("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$4(
                  "error",
                  a2
                );
                D$4("load", a2);
                e2 = d2;
                break;
              case "details":
                D$4("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$4("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$6({}, d2, { value: void 0 });
                D$4("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$4("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$4("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$4(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$8(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$4(b2);
      return null;
    case 13:
      E$4(M$4);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$4 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$8(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$8(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$4(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$4.current & 1) ? 0 === T$4 && (T$4 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$4(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$4(b2), null;
    case 10:
      return Rg(b2.type._context), S$4(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$4(b2), null;
    case 19:
      E$4(M$4);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$4(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$4 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$4(M$4, M$4.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$3() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$4)
              return S$4(b2), null;
          } else
            2 * B$3() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$3(), b2.sibling = null, c2 = M$4.current, G$4(M$4, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$4(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$4(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$4(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$8(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$4(Wf), E$4(H$4), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$4(M$4);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$8(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$4(M$4), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$5 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$4 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$5(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$5(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$1();
  if (Ne$2(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$4 = b2; null !== V$4; )
    if (b2 = V$4, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$4 = a2;
    else
      for (; null !== V$4; ) {
        b2 = V$4;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t3 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t3 : Lg(b2.type, t3), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$8(163));
            }
        } catch (F2) {
          W$5(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$4 = a2;
          break;
        }
        V$4 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$4 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc$1 && "function" === typeof lc$1.onCommitFiberUnmount)
    try {
      lc$1.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$5 || Mj(c2, b2);
    case 6:
      var d2 = X$4, e2 = Yj;
      X$4 = null;
      Zj(a2, b2, c2);
      X$4 = d2;
      Yj = e2;
      null !== X$4 && (Yj ? (a2 = X$4, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$4.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$4 && (Yj ? (a2 = X$4, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$4, c2.stateNode));
      break;
    case 4:
      d2 = X$4;
      e2 = Yj;
      X$4 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$4 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$5 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$5 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$5(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$5 = (d2 = U$5) || null !== c2.memoizedState, Zj(a2, b2, c2), U$5 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$4 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$4 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$4 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$4)
          throw Error(p$8(160));
        ak(f2, g2, e2);
        X$4 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$5(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t3) {
          W$5(a2, a2.return, t3);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t3) {
          W$5(a2, a2.return, t3);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t3) {
          W$5(a2, a2.return, t3);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t3) {
            W$5(a2, a2.return, t3);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$8(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t3) {
          W$5(a2, a2.return, t3);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t3) {
          W$5(a2, a2.return, t3);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$3()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$5 = (l2 = U$5) || m2, dk(b2, a2), U$5 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$4 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$4 = m2; null !== V$4; ) {
              r2 = V$4;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t3) {
                      W$5(d2, c2, t3);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$4 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t3) {
                  W$5(a2, a2.return, t3);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t3) {
                  W$5(a2, a2.return, t3);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$8(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$8(161));
      }
    } catch (k2) {
      W$5(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$4 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$4; ) {
    var e2 = V$4, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$5;
        h2 = Kj;
        var l2 = U$5;
        Kj = g2;
        if ((U$5 = k2) && !l2)
          for (V$4 = e2; null !== V$4; )
            g2 = V$4, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$4 = k2) : kk(e2);
        for (; null !== f2; )
          V$4 = f2, jk(f2), f2 = f2.sibling;
        V$4 = e2;
        Kj = h2;
        U$5 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$4 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$5 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$5)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$8(163));
          }
        U$5 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$5(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$4 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$4 = c2;
      break;
    }
    V$4 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    if (b2 === a2) {
      V$4 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$4 = c2;
      break;
    }
    V$4 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$5(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$5(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$5(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$5(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$5(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$4 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$4 = h2;
      break;
    }
    V$4 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$3 = 0, R$3 = null, Y$3 = null, Z$5 = 0, gj = 0, fj = Uf(0), T$4 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$4() {
  return 0 !== (K$3 & 6) ? B$3() : -1 !== Bk ? Bk : Bk = B$3();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$3 & 2) && 0 !== Z$5)
    return Z$5 & -Z$5;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$2;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$8(185));
  Ac(a2, c2, d2);
  if (0 === (K$3 & 2) || a2 !== R$3)
    a2 === R$3 && (0 === (K$3 & 2) && (rk |= c2), 4 === T$4 && Dk(a2, Z$5)), Ek(a2, d2), 1 === c2 && 0 === K$3 && 0 === (b2.mode & 1) && (Hj = B$3() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$3 ? Z$5 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$3 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$3 & 6))
    throw Error(p$8(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$3 ? Z$5 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$3;
    K$3 |= 2;
    var f2 = Kk();
    if (R$3 !== a2 || Z$5 !== b2)
      vk = null, Hj = B$3() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$3 = e2;
    null !== Y$3 ? b2 = 0 : (R$3 = null, Z$5 = 0, b2 = T$4);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$3()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$3()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$8(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$3(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$4();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$3() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$8(329));
      }
    }
  }
  Ek(a2, B$3());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$1(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$3 & 6))
    throw Error(p$8(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$3()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$3()), c2;
  if (6 === c2)
    throw Error(p$8(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$3());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$3;
  K$3 |= 1;
  try {
    return a2(b2);
  } finally {
    K$3 = c2, 0 === K$3 && (Hj = B$3() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$3 & 6) && Ik();
  var b2 = K$3;
  K$3 |= 1;
  var c2 = pk.transition, d2 = C$2;
  try {
    if (pk.transition = null, C$2 = 1, a2)
      return a2();
  } finally {
    C$2 = d2, pk.transition = c2, K$3 = b2, 0 === (K$3 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$4(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$3)
    for (c2 = Y$3.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$4(Wf);
          E$4(H$4);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$4(M$4);
          break;
        case 19:
          E$4(M$4);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$3 = a2;
  Y$3 = a2 = wh(a2.current, null);
  Z$5 = gj = b2;
  T$4 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$3;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N$3.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$4 = O$4 = N$3 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$4 = 1;
        qk = b2;
        Y$3 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$5;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t3 = /* @__PURE__ */ new Set();
              t3.add(k2);
              b2.updateQueue = t3;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$8(426));
          }
        } else if (I$4 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$4 && (T$4 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$3 === c2 && null !== c2 && (Y$3 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$4 || 3 === T$4 || 2 === T$4)
    T$4 = 4;
  null === R$3 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$3, Z$5);
}
function Jk(a2, b2) {
  var c2 = K$3;
  K$3 |= 2;
  var d2 = Kk();
  if (R$3 !== a2 || Z$5 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$3 = c2;
  nk.current = d2;
  if (null !== Y$3)
    throw Error(p$8(261));
  R$3 = null;
  Z$5 = 0;
  return T$4;
}
function Uk() {
  for (; null !== Y$3; )
    Vk(Y$3);
}
function Mk() {
  for (; null !== Y$3 && !cc(); )
    Vk(Y$3);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$3 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$3 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$3 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$4 = 6;
        Y$3 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$3 = b2;
      return;
    }
    Y$3 = b2 = a2;
  } while (null !== b2);
  0 === T$4 && (T$4 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$2, e2 = pk.transition;
  try {
    pk.transition = null, C$2 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$2 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$3 & 6))
    throw Error(p$8(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$8(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$3 && (Y$3 = R$3 = null, Z$5 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$2;
    C$2 = 1;
    var h2 = K$3;
    K$3 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe$1(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$3 = h2;
    C$2 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B$3());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$2;
    try {
      pk.transition = null;
      C$2 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$3 & 6))
          throw Error(p$8(331));
        var e2 = K$3;
        K$3 |= 4;
        for (V$4 = a2.current; null !== V$4; ) {
          var f2 = V$4, g2 = f2.child;
          if (0 !== (V$4.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$4 = l2; null !== V$4; ) {
                  var m2 = V$4;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$4 = q2;
                  else
                    for (; null !== V$4; ) {
                      m2 = V$4;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$4 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$4 = r2;
                        break;
                      }
                      V$4 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t3 = n2.child;
                if (null !== t3) {
                  n2.child = null;
                  do {
                    var J2 = t3.sibling;
                    t3.sibling = null;
                    t3 = J2;
                  } while (null !== t3);
                }
              }
              V$4 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$4 = g2;
          else
            b:
              for (; null !== V$4; ) {
                f2 = V$4;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$4 = x2;
                  break b;
                }
                V$4 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$4 = w2; null !== V$4; ) {
          g2 = V$4;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$4 = u2;
          else
            b:
              for (g2 = w2; null !== V$4; ) {
                h2 = V$4;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$5(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$4 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$4 = F2;
                  break b;
                }
                V$4 = h2.return;
              }
        }
        K$3 = e2;
        jg();
        if (lc$1 && "function" === typeof lc$1.onPostCommitFiberRoot)
          try {
            lc$1.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$2 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$4();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$5(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$4();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$4();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$3 === a2 && (Z$5 & c2) === c2 && (4 === T$4 || 3 === T$4 && (Z$5 & 130023424) === Z$5 && 500 > B$3() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$4();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$8(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$4 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$4.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$4 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$8(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$8(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$8(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$8(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$4 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$4(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He$1(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$8(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$8(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$8(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$8(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$8(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl$1(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$4();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L$4(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$8(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl$1(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$3()), 0 === (K$3 & 6) && (Hj = B$3() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$4();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$4();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$4();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$2;
};
Ic = function(a2, b2) {
  var c2 = C$2;
  try {
    return C$2 = a2, b2();
  } finally {
    C$2 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$8(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$3, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc$1 = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$8(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$8(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$8(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$8(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$8(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$8(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl$1(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$8(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$8(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$8(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$8(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$7 = reactDomExports;
{
  client.createRoot = m$7.createRoot;
  client.hydrateRoot = m$7.hydrateRoot;
}
/**
 * @remix-run/router v1.9.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
var Action$1;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action$1 || (Action$1 = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning$1(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location2, index2) {
  return {
    usr: location2.state,
    key: location2.key,
    idx: index2
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location2 = _extends$4({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location2;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action$1.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$4({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action$1.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push2(to, state) {
    action = Action$1.Push;
    let location2 = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location2, to);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location2, index2);
    let url = history.createHref(location2);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to, state) {
    action = Action$1.Replace;
    let location2 = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location2, to);
    index2 = getIndex();
    let historyState = getHistoryState(location2, index2);
    let url = history.createHref(location2);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn3) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn3;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push: push2,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    matches = matchRouteBranch(
      branches[i2],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end2 = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning$1(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning$1(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning$1(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$4({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (isPathRelative || toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.16.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect$3(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$3(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
function useOutlet(context) {
  let outlet = reactExports.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$3({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location2),
        navigationType: Action$1.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error || state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null;
    let errorElement = null;
    if (dataRouterState) {
      errorElement = match2.route.errorElement || defaultErrorElement;
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$3(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends$3({
        fromRouteId: id2
      }, options));
    }
  }, [router, id2]);
  return navigate;
}
function Navigate(_ref4) {
  let {
    to,
    replace: replace2,
    state,
    relative
  } = _ref4;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(to, getPathContributingMatches(matches).map((match2) => match2.pathnameBase), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path);
  reactExports.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace: replace2,
    state,
    relative
  }), [navigate, jsonPath, relative, replace2, state]);
  return null;
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
  invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action$1.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location: location2
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location2);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.16.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
const common = {
  black: "#000",
  white: "#fff"
};
const common$1 = common;
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const red$1 = red;
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const purple$1 = purple;
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const blue$1 = blue;
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const lightBlue$1 = lightBlue;
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const green$1 = green;
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const orange$1 = orange;
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const grey$1 = grey;
function chainPropTypes(propType1, propType2) {
  {
    return () => null;
  }
}
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function isPlainObject$5(item) {
  return item !== null && typeof item === "object" && item.constructor === Object;
}
function deepClone$2(source) {
  if (!isPlainObject$5(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone$2(source[key]);
  });
  return output;
}
function deepmerge$1(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends$2({}, target) : target;
  if (isPlainObject$5(target) && isPlainObject$5(source)) {
    Object.keys(source).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isPlainObject$5(source[key]) && key in target && isPlainObject$5(target[key])) {
        output[key] = deepmerge$1(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject$5(source[key]) ? deepClone$2(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
function formatMuiErrorMessage(code) {
  let url = "https://mui.com/production-error/?code=" + code;
  for (let i2 = 1; i2 < arguments.length; i2 += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i2]);
  }
  return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
var reactIs_production_min$1 = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$5 = Symbol.for("react.element"), c$5 = Symbol.for("react.portal"), d$5 = Symbol.for("react.fragment"), e$5 = Symbol.for("react.strict_mode"), f$6 = Symbol.for("react.profiler"), g$5 = Symbol.for("react.provider"), h$8 = Symbol.for("react.context"), k$5 = Symbol.for("react.server_context"), l$6 = Symbol.for("react.forward_ref"), m$6 = Symbol.for("react.suspense"), n$8 = Symbol.for("react.suspense_list"), p$7 = Symbol.for("react.memo"), q$6 = Symbol.for("react.lazy"), t$6 = Symbol.for("react.offscreen"), u$8;
u$8 = Symbol.for("react.module.reference");
function v$6(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r2 = a2.$$typeof;
    switch (r2) {
      case b$5:
        switch (a2 = a2.type, a2) {
          case d$5:
          case f$6:
          case e$5:
          case m$6:
          case n$8:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$5:
              case h$8:
              case l$6:
              case q$6:
              case p$7:
              case g$5:
                return a2;
              default:
                return r2;
            }
        }
      case c$5:
        return r2;
    }
  }
}
reactIs_production_min$1.ContextConsumer = h$8;
reactIs_production_min$1.ContextProvider = g$5;
reactIs_production_min$1.Element = b$5;
reactIs_production_min$1.ForwardRef = l$6;
reactIs_production_min$1.Fragment = d$5;
reactIs_production_min$1.Lazy = q$6;
reactIs_production_min$1.Memo = p$7;
reactIs_production_min$1.Portal = c$5;
reactIs_production_min$1.Profiler = f$6;
reactIs_production_min$1.StrictMode = e$5;
reactIs_production_min$1.Suspense = m$6;
reactIs_production_min$1.SuspenseList = n$8;
reactIs_production_min$1.isAsyncMode = function() {
  return false;
};
reactIs_production_min$1.isConcurrentMode = function() {
  return false;
};
reactIs_production_min$1.isContextConsumer = function(a2) {
  return v$6(a2) === h$8;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return v$6(a2) === g$5;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$5;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return v$6(a2) === l$6;
};
reactIs_production_min$1.isFragment = function(a2) {
  return v$6(a2) === d$5;
};
reactIs_production_min$1.isLazy = function(a2) {
  return v$6(a2) === q$6;
};
reactIs_production_min$1.isMemo = function(a2) {
  return v$6(a2) === p$7;
};
reactIs_production_min$1.isPortal = function(a2) {
  return v$6(a2) === c$5;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return v$6(a2) === f$6;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return v$6(a2) === e$5;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return v$6(a2) === m$6;
};
reactIs_production_min$1.isSuspenseList = function(a2) {
  return v$6(a2) === n$8;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d$5 || a2 === f$6 || a2 === e$5 || a2 === m$6 || a2 === n$8 || a2 === t$6 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$6 || a2.$$typeof === p$7 || a2.$$typeof === g$5 || a2.$$typeof === h$8 || a2.$$typeof === l$6 || a2.$$typeof === u$8 || void 0 !== a2.getModuleId) ? true : false;
};
reactIs_production_min$1.typeOf = v$6;
const refType = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
const refType$1 = refType;
function capitalize$1(string2) {
  if (typeof string2 !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function debounce$1(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function deprecatedPropType(validator2, reason) {
  {
    return () => null;
  }
}
function isMuiElement(element, muiNames) {
  var _muiName, _element$type;
  return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    (_muiName = element.type.muiName) != null ? _muiName : (_element$type = element.type) == null || (_element$type = _element$type._payload) == null || (_element$type = _element$type.value) == null ? void 0 : _element$type.muiName
  ) !== -1;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function requirePropFactory(componentNameInError, Component) {
  {
    return () => null;
  }
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
const useEnhancedEffect$1 = useEnhancedEffect;
let globalId$1 = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId$1 += 1;
      setDefaultId(`mui-${globalId$1}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId = React$1["useId".toString()];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function unsupportedProp(props, propName, componentName, location2, propFullName) {
  {
    return null;
  }
}
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue2] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue2(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function useEventCallback$1(fn3) {
  const ref = reactExports.useRef(fn3);
  useEnhancedEffect$1(() => {
    ref.current = fn3;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, ref.current)(...args)
  )).current;
}
function useForkRef(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
let hadFocusVisibleRecentlyTimeout;
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  const {
    type: type2,
    tagName
  } = node2;
  if (tagName === "INPUT" && inputTypesWhitelist[type2] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  const ref = reactExports.useCallback((node2) => {
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = reactExports.useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}
function getScrollbarSize(doc) {
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
let cachedType;
function detectScrollType() {
  if (cachedType) {
    return cachedType;
  }
  const dummy = document.createElement("div");
  const container = document.createElement("div");
  container.style.width = "10px";
  container.style.height = "1px";
  dummy.appendChild(container);
  dummy.dir = "rtl";
  dummy.style.fontSize = "14px";
  dummy.style.width = "4px";
  dummy.style.height = "1px";
  dummy.style.position = "absolute";
  dummy.style.top = "-1000px";
  dummy.style.overflow = "scroll";
  document.body.appendChild(dummy);
  cachedType = "reverse";
  if (dummy.scrollLeft > 0) {
    cachedType = "default";
  } else {
    dummy.scrollLeft = 1;
    if (dummy.scrollLeft === 0) {
      cachedType = "negative";
    }
  }
  document.body.removeChild(dummy);
  return cachedType;
}
function getNormalizedScrollLeft(element, direction2) {
  const scrollLeft = element.scrollLeft;
  if (direction2 !== "rtl") {
    return scrollLeft;
  }
  const type2 = detectScrollType();
  switch (type2) {
    case "negative":
      return element.scrollWidth - element.clientWidth + scrollLeft;
    case "reverse":
      return element.scrollWidth - element.clientWidth - scrollLeft;
    default:
      return scrollLeft;
  }
}
const usePreviousProps = (value) => {
  const ref = reactExports.useRef({});
  reactExports.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
};
const usePreviousProps$1 = usePreviousProps;
const visuallyHidden = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: -1,
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
const visuallyHidden$1 = visuallyHidden;
function resolveProps(defaultProps2, props) {
  const output = _extends$2({}, props);
  Object.keys(defaultProps2).forEach((propName) => {
    if (propName.toString().match(/^(components|slots)$/)) {
      output[propName] = _extends$2({}, defaultProps2[propName], output[propName]);
    } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
      const defaultSlotProps = defaultProps2[propName] || {};
      const slotProps = props[propName];
      output[propName] = {};
      if (!slotProps || !Object.keys(slotProps)) {
        output[propName] = defaultSlotProps;
      } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
        output[propName] = slotProps;
      } else {
        output[propName] = _extends$2({}, slotProps);
        Object.keys(defaultSlotProps).forEach((slotPropName) => {
          output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
        });
      }
    } else if (output[propName] === void 0) {
      output[propName] = defaultProps2[propName];
    }
  });
  return output;
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  Object.keys(slots).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          const utilityClass = getUtilityClass(key);
          if (utilityClass !== "") {
            acc.push(utilityClass);
          }
          if (classes && classes[key]) {
            acc.push(classes[key]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const ClassNameGenerator$1 = ClassNameGenerator;
const globalStateClassesMapping = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
const THEME_ID = "$$material";
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function memoize$2(fn3) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0)
      cache2[arg] = fn3(arg);
    return cache2[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$2(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from$1 = String.fromCharCode;
var assign = Object.assign;
function hash$2(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$1(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array2) {
  return array2.push(value), value;
}
function combine(array2, callback) {
  return array2.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position$1 = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type2, props, children, length2) {
  return { value, root: root2, parent, type: type2, props, children, line, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position$1 > 0 ? charat(characters, --position$1) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position$1 < length ? charat(characters, position$1++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position$1);
}
function caret() {
  return position$1;
}
function slice$2(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim$1(slice$2(position$1 - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice$2(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position$1;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position$1;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice$2(index2, position$1 - 1) + "*" + from$1(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice$2(index2, position$1);
}
function compile(value) {
  return dealloc(parse$1("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$1(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference2 = ruleset(characters2, root2, parent, index2, offset2, rules, points, type2, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$1(characters2, root2, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$1(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type2, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$1(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset2, rules, points, type2, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim$1(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root2, parent, offset2 === 0 ? RULESET : type2, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from$1(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$1(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify$1(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware$1(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice$2(begin, position$1);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position$1 - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from$1(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$2(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize$1([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize$1([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize$1([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$1, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware$1(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$1(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$4 = "function" === typeof Symbol && Symbol.for, c$4 = b$4 ? Symbol.for("react.element") : 60103, d$4 = b$4 ? Symbol.for("react.portal") : 60106, e$4 = b$4 ? Symbol.for("react.fragment") : 60107, f$5 = b$4 ? Symbol.for("react.strict_mode") : 60108, g$4 = b$4 ? Symbol.for("react.profiler") : 60114, h$7 = b$4 ? Symbol.for("react.provider") : 60109, k$4 = b$4 ? Symbol.for("react.context") : 60110, l$5 = b$4 ? Symbol.for("react.async_mode") : 60111, m$5 = b$4 ? Symbol.for("react.concurrent_mode") : 60111, n$7 = b$4 ? Symbol.for("react.forward_ref") : 60112, p$6 = b$4 ? Symbol.for("react.suspense") : 60113, q$5 = b$4 ? Symbol.for("react.suspense_list") : 60120, r$5 = b$4 ? Symbol.for("react.memo") : 60115, t$5 = b$4 ? Symbol.for("react.lazy") : 60116, v$5 = b$4 ? Symbol.for("react.block") : 60121, w$5 = b$4 ? Symbol.for("react.fundamental") : 60117, x$4 = b$4 ? Symbol.for("react.responder") : 60118, y$3 = b$4 ? Symbol.for("react.scope") : 60119;
function z$4(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$4:
        switch (a2 = a2.type, a2) {
          case l$5:
          case m$5:
          case e$4:
          case g$4:
          case f$5:
          case p$6:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$4:
              case n$7:
              case t$5:
              case r$5:
              case h$7:
                return a2;
              default:
                return u2;
            }
        }
      case d$4:
        return u2;
    }
  }
}
function A$5(a2) {
  return z$4(a2) === m$5;
}
reactIs_production_min.AsyncMode = l$5;
reactIs_production_min.ConcurrentMode = m$5;
reactIs_production_min.ContextConsumer = k$4;
reactIs_production_min.ContextProvider = h$7;
reactIs_production_min.Element = c$4;
reactIs_production_min.ForwardRef = n$7;
reactIs_production_min.Fragment = e$4;
reactIs_production_min.Lazy = t$5;
reactIs_production_min.Memo = r$5;
reactIs_production_min.Portal = d$4;
reactIs_production_min.Profiler = g$4;
reactIs_production_min.StrictMode = f$5;
reactIs_production_min.Suspense = p$6;
reactIs_production_min.isAsyncMode = function(a2) {
  return A$5(a2) || z$4(a2) === l$5;
};
reactIs_production_min.isConcurrentMode = A$5;
reactIs_production_min.isContextConsumer = function(a2) {
  return z$4(a2) === k$4;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z$4(a2) === h$7;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$4;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z$4(a2) === n$7;
};
reactIs_production_min.isFragment = function(a2) {
  return z$4(a2) === e$4;
};
reactIs_production_min.isLazy = function(a2) {
  return z$4(a2) === t$5;
};
reactIs_production_min.isMemo = function(a2) {
  return z$4(a2) === r$5;
};
reactIs_production_min.isPortal = function(a2) {
  return z$4(a2) === d$4;
};
reactIs_production_min.isProfiler = function(a2) {
  return z$4(a2) === g$4;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z$4(a2) === f$5;
};
reactIs_production_min.isSuspense = function(a2) {
  return z$4(a2) === p$6;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$4 || a2 === m$5 || a2 === g$4 || a2 === f$5 || a2 === p$6 || a2 === q$5 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$5 || a2.$$typeof === r$5 || a2.$$typeof === h$7 || a2.$$typeof === k$4 || a2.$$typeof === n$7 || a2.$$typeof === w$5 || a2.$$typeof === x$4 || a2.$$typeof === y$3 || a2.$$typeof === v$5);
};
reactIs_production_min.typeOf = z$4;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag2) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag2) {
  registerStyles(cache2, serialized, isStringTag2);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$2(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string2 += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      styles2 += strings[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache2 = reactExports.useContext(EmotionCacheContext);
    return func(props, cache2, ref);
  });
};
var ThemeContext$2 = /* @__PURE__ */ reactExports.createContext({});
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext$2));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString3() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion = function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i2 = 1;
      for (; i2 < len; i2++) {
        styles2.push(args[i2], args[0][i2]);
      }
    }
    var Styled = withEmotionCache(function(props, cache2, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext$2);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
      className += cache2.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
        cache: cache2,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled(nextTag, _extends$2({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
function isEmpty$5(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$2(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$5(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
/**
 * @mui/styled-engine v5.14.11
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$4(tag, options) {
  const stylesFactory = newStyled(tag, options);
  return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};
const _excluded$2z = ["values", "unit", "step"];
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends$2({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose$1(breakpoints, _excluded$2z);
  const sortedValues = sortBreakpointsValues(values2);
  const keys3 = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start2, end2) {
    const endIndex = keys3.indexOf(end2);
    return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys3[endIndex]] === "number" ? values2[keys3[endIndex]] : end2) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys3.indexOf(key) + 1 < keys3.length) {
      return between(key, keys3[keys3.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys3.indexOf(key);
    if (keyIndex === 0) {
      return up(keys3[1]);
    }
    if (keyIndex === keys3.length - 1) {
      return down(keys3[keyIndex]);
    }
    return between(key, keys3[keys3.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return _extends$2({
    keys: keys3,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
const shape = {
  borderRadius: 4
};
const shape$1 = shape;
function merge$5(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge$1(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme2 = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge$1(prev2, next2), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i2) => {
      if (i2 < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys3 = Object.keys(base);
  if (keys3.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys3.reduce((acc, breakpoint, i2) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i2] != null ? breakpointValues[i2] : breakpointValues[previous];
      previous = i2;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue$1(themeMapping, transform2, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform2) {
    value = transform2(value, userValue, themeMapping);
  }
  return value;
}
function style$2(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform: transform2
  } = options;
  const fn3 = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme2 = props.theme;
    const themeMapping = getPath(theme2, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform2, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn3.propTypes = {};
  fn3.filterProps = [prop];
  return fn3;
}
function memoize$1(fn3) {
  const cache2 = {};
  return (arg) => {
    if (cache2[arg] === void 0) {
      cache2[arg] = fn3(arg);
    }
    return cache2[arg];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize$1((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a2, b2] = prop.split("");
  const property = properties[a2];
  const direction2 = directions[b2] || "";
  return Array.isArray(direction2) ? direction2.map((dir) => property + dir) : [property + direction2];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme2, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme2, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing * abs2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing[abs2];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme2) {
  return createUnaryUnit(theme2, "spacing", 8);
}
function getValue$2(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs2 = Math.abs(propValue);
  const transformed = transformer(abs2);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue$2(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys3, prop, transformer) {
  if (keys3.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$1(props, keys3) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys3, prop, transformer)).reduce(merge$5, {});
}
function margin(props) {
  return style$1(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style$1(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform2 = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform2(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose$2(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn3 = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge$5(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn3.propTypes = {};
  fn3.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn3;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
const border = style$2({
  prop: "border",
  themeKey: "borders",
  transform: borderTransform
});
const borderTop = style$2({
  prop: "borderTop",
  themeKey: "borders",
  transform: borderTransform
});
const borderRight = style$2({
  prop: "borderRight",
  themeKey: "borders",
  transform: borderTransform
});
const borderBottom = style$2({
  prop: "borderBottom",
  themeKey: "borders",
  transform: borderTransform
});
const borderLeft = style$2({
  prop: "borderLeft",
  themeKey: "borders",
  transform: borderTransform
});
const borderColor = style$2({
  prop: "borderColor",
  themeKey: "palette"
});
const borderTopColor$1 = style$2({
  prop: "borderTopColor",
  themeKey: "palette"
});
const borderRightColor$1 = style$2({
  prop: "borderRightColor",
  themeKey: "palette"
});
const borderBottomColor$1 = style$2({
  prop: "borderBottomColor",
  themeKey: "palette"
});
const borderLeftColor$1 = style$2({
  prop: "borderLeftColor",
  themeKey: "palette"
});
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue$2(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose$2(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor$1, borderRightColor$1, borderBottomColor$1, borderLeftColor$1, borderRadius);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue$2(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue$2(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue$2(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$2({
  prop: "gridColumn"
});
const gridRow = style$2({
  prop: "gridRow"
});
const gridAutoFlow = style$2({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$2({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$2({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$2({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$2({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$2({
  prop: "gridTemplateAreas"
});
const gridArea = style$2({
  prop: "gridArea"
});
compose$2(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color$2 = style$2({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$2({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor$1 = style$2({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose$2(color$2, bgcolor, backgroundColor$1);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$2({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _props$theme, _props$theme2;
      const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$2({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$2({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$2({
  prop: "minHeight",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$2({
  prop: "boxSizing"
});
compose$2(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
const defaultSxConfig$1 = defaultSxConfig;
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys3, object2) => keys3.concat(Object.keys(object2)), []);
  const union = new Set(allKeys);
  return objects.every((object2) => union.size === Object.keys(object2).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme2, config2) {
    const props = {
      [prop]: val,
      theme: theme2
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform: transform2,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme2, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform2, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme: theme2 = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = (_theme$unstable_sxCon = theme2.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme2);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme2.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme2);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge$5(css2, getThemeValue(styleKey, value, theme2, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme: theme2
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme: theme2
                });
              } else {
                css2 = merge$5(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge$5(css2, getThemeValue(styleKey, value, theme2, config2));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const styleFunctionSx$1 = styleFunctionSx;
const _excluded$2y = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$2y);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge$1({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends$2({
      mode: "light"
    }, paletteInput),
    spacing,
    shape: _extends$2({}, shape$1, shapeInput)
  }, other);
  muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$2({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$3(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext$2);
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$2(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$3(defaultTheme2);
}
function GlobalStyles$1({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$2(defaultTheme2);
  const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: globalStyles
  });
}
const _excluded$2x = ["sx"];
const splitProps = (props) => {
  var _props$theme$unstable, _props$theme;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig$1;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp(props) {
  const {
    sx: inSx
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2x);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject$5(result)) {
        return systemProps;
      }
      return _extends$2({}, systemProps, result);
    };
  } else {
    finalSx = _extends$2({}, systemProps, inSx);
  }
  return _extends$2({}, otherProps, {
    sx: finalSx
  });
}
function r$4(e2) {
  var t3, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t3 = 0; t3 < e2.length; t3++)
        e2[t3] && (f2 = r$4(e2[t3])) && (n2 && (n2 += " "), n2 += f2);
    else
      for (t3 in e2)
        e2[t3] && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
function clsx() {
  for (var e2, t3, f2 = 0, n2 = ""; f2 < arguments.length; )
    (e2 = arguments[f2++]) && (t3 = r$4(e2)) && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
const _excluded$2w = ["className", "component"];
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$4("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx$1);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
    const theme2 = useTheme$2(defaultTheme2);
    const _extendSxProp = extendSxProp(inProps), {
      className,
      component = "div"
    } = _extendSxProp, other = _objectWithoutPropertiesLoose$1(_extendSxProp, _excluded$2w);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, _extends$2({
      as: component,
      ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme2[themeId] || theme2 : theme2
    }, other));
  });
  return Box2;
}
const Box$2 = createBox();
const Box$3 = Box$2;
const _excluded$2v = ["variant"];
function isEmpty$4(string2) {
  return string2.length === 0;
}
function propsToClassKey(props) {
  const {
    variant
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2v);
  let classKey = variant || "";
  Object.keys(other).sort().forEach((key) => {
    if (key === "color") {
      classKey += isEmpty$4(classKey) ? props[key] : capitalize$1(props[key]);
    } else {
      classKey += `${isEmpty$4(classKey) ? key : capitalize$1(key)}${capitalize$1(props[key].toString())}`;
    }
  });
  return classKey;
}
const _excluded$2u = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function isEmpty$3(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
const getStyleOverrides = (name, theme2) => {
  if (theme2.components && theme2.components[name] && theme2.components[name].styleOverrides) {
    return theme2.components[name].styleOverrides;
  }
  return null;
};
const getVariantStyles = (name, theme2) => {
  let variants = [];
  if (theme2 && theme2.components && theme2.components[name] && theme2.components[name].variants) {
    variants = theme2.components[name].variants;
  }
  const variantsStyles = {};
  variants.forEach((definition) => {
    const key = propsToClassKey(definition.props);
    variantsStyles[key] = definition.style;
  });
  return variantsStyles;
};
const variantsResolver = (props, styles2, theme2, name) => {
  var _theme$components;
  const {
    ownerState = {}
  } = props;
  const variantsStyles = [];
  const themeVariants = theme2 == null || (_theme$components = theme2.components) == null || (_theme$components = _theme$components[name]) == null ? void 0 : _theme$components.variants;
  if (themeVariants) {
    themeVariants.forEach((themeVariant) => {
      let isMatch = true;
      Object.keys(themeVariant.props).forEach((key) => {
        if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
          isMatch = false;
        }
      });
      if (isMatch) {
        variantsStyles.push(styles2[propsToClassKey(themeVariant.props)]);
      }
    });
  }
  return variantsStyles;
};
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const systemDefaultTheme = createTheme$1();
const lowercaseFirstLetter = (string2) => {
  if (!string2) {
    return string2;
  }
  return string2.charAt(0).toLowerCase() + string2.slice(1);
};
function resolveTheme({
  defaultTheme: defaultTheme2,
  theme: theme2,
  themeId
}) {
  return isEmpty$3(theme2) ? defaultTheme2 : theme2[themeId] || theme2;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (props, styles2) => styles2[slot];
}
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  const systemSx = (props) => {
    return styleFunctionSx$1(_extends$2({}, props, {
      theme: resolveTheme(_extends$2({}, props, {
        defaultTheme: defaultTheme2,
        themeId
      }))
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
    } = inputOptions, options = _objectWithoutPropertiesLoose$1(inputOptions, _excluded$2u);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$4(tag, _extends$2({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const muiStyledResolver = (styleArg2, ...expressions) => {
      const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
        return typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg ? (props) => {
          return stylesArg(_extends$2({}, props, {
            theme: resolveTheme(_extends$2({}, props, {
              defaultTheme: defaultTheme2,
              themeId
            }))
          }));
        } : stylesArg;
      }) : [];
      let transformedStyleArg = styleArg2;
      if (componentName && overridesResolver2) {
        expressionsWithDefaultTheme.push((props) => {
          const theme2 = resolveTheme(_extends$2({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          const styleOverrides = getStyleOverrides(componentName, theme2);
          if (styleOverrides) {
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends$2({}, props, {
                theme: theme2
              })) : slotStyle;
            });
            return overridesResolver2(props, resolvedStyleOverrides);
          }
          return null;
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme2 = resolveTheme(_extends$2({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          return variantsResolver(props, getVariantStyles(componentName, theme2), theme2, componentName);
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg2) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg2, ...placeholders];
        transformedStyleArg.raw = [...styleArg2.raw, ...placeholders];
      } else if (typeof styleArg2 === "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
      // component stays as a function. This condition makes sure that we do not interpolate functions
      // which are basically components used as a selectors.
      styleArg2.__emotion_real !== styleArg2) {
        transformedStyleArg = (props) => styleArg2(_extends$2({}, props, {
          theme: resolveTheme(_extends$2({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }))
        }));
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
const styled$2 = createStyled2();
const styled$3 = styled$2;
function getThemeProps(params) {
  const {
    theme: theme2,
    name,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name] || !theme2.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme2.components[name].defaultProps, props);
}
function useThemeProps$1({
  props,
  name,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme2 = useTheme$2(defaultTheme2);
  if (themeId) {
    theme2 = theme2[themeId] || theme2;
  }
  const mergedProps = getThemeProps({
    theme: theme2,
    name,
    props
  });
  return mergedProps;
}
function clamp$3(value, min2 = 0, max2 = 1) {
  return Math.min(Math.max(min2, value), max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re2);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n2) => n2 + n2);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index2) => {
    return index2 < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type2 = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type2) === -1) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type2 === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type: type2,
    values: values2,
    colorSpace
  };
}
function recomposeColor(color2) {
  const {
    type: type2,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type2.indexOf("rgb") !== -1) {
    values2 = values2.map((n2, i2) => i2 < 3 ? parseInt(n2, 10) : n2);
  } else if (type2.indexOf("hsl") !== -1) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type2.indexOf("color") !== -1) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type2}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h2 = values2[0];
  const s2 = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a2 = s2 * Math.min(l2, 1 - l2);
  const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type2 = "rgb";
  const rgb2 = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type2 += "a";
    rgb2.push(values2[3]);
  }
  return recomposeColor({
    type: type2,
    values: rgb2
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb2 = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb2 = rgb2.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb2[0] + 0.7152 * rgb2[1] + 0.0722 * rgb2[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clamp$3(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clamp$3(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clamp$3(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.indexOf("rgb") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (255 - color2.values[i2]) * coefficient;
    }
  } else if (color2.type.indexOf("color") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (1 - color2.values[i2]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
const ThemeContext = /* @__PURE__ */ reactExports.createContext(null);
const ThemeContext$1 = ThemeContext;
function useTheme$1() {
  const theme2 = reactExports.useContext(ThemeContext$1);
  return theme2;
}
const hasSymbol = typeof Symbol === "function" && Symbol.for;
const nested = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === "function") {
    const mergedTheme = localTheme(outerTheme);
    return mergedTheme;
  }
  return _extends$2({}, outerTheme, localTheme);
}
function ThemeProvider$2(props) {
  const {
    children,
    theme: localTheme
  } = props;
  const outerTheme = useTheme$1();
  const theme2 = reactExports.useMemo(() => {
    const output = outerTheme === null ? localTheme : mergeOuterLocalTheme(outerTheme, localTheme);
    if (output != null) {
      output[nested] = outerTheme !== null;
    }
    return output;
  }, [localTheme, outerTheme]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
    value: theme2,
    children
  });
}
const EMPTY_THEME = {};
function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
  return reactExports.useMemo(() => {
    const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
    if (typeof localTheme === "function") {
      const mergedTheme = localTheme(resolvedTheme);
      const result = themeId ? _extends$2({}, upperTheme, {
        [themeId]: mergedTheme
      }) : mergedTheme;
      if (isPrivate) {
        return () => result;
      }
      return result;
    }
    return themeId ? _extends$2({}, upperTheme, {
      [themeId]: localTheme
    }) : _extends$2({}, upperTheme, localTheme);
  }, [themeId, upperTheme, localTheme, isPrivate]);
}
function ThemeProvider$1(props) {
  const {
    children,
    theme: localTheme,
    themeId
  } = props;
  const upperTheme = useTheme$3(EMPTY_THEME);
  const upperPrivateTheme = useTheme$1() || EMPTY_THEME;
  const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
  const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$2, {
    theme: privateTheme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContext$2.Provider, {
      value: engineTheme,
      children
    })
  });
}
const _excluded$2t = ["component", "direction", "spacing", "divider", "children", "className", "useFlexGap"];
const defaultTheme$3 = createTheme$1();
const defaultCreateStyledComponent = styled$3("div", {
  name: "MuiStack",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
});
function useThemePropsDefault(props) {
  return useThemeProps$1({
    props,
    name: "MuiStack",
    defaultTheme: defaultTheme$3
  });
}
function joinChildren(children, separator) {
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output, child, index2) => {
    output.push(child);
    if (index2 < childrenArray.length - 1) {
      output.push(/* @__PURE__ */ reactExports.cloneElement(separator, {
        key: `separator-${index2}`
      }));
    }
    return output;
  }, []);
}
const getSideFromDirection = (direction2) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction2];
};
const style = ({
  ownerState,
  theme: theme2
}) => {
  let styles2 = _extends$2({
    display: "flex",
    flexDirection: "column"
  }, handleBreakpoints({
    theme: theme2
  }, resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme2.breakpoints.values
  }), (propValue) => ({
    flexDirection: propValue
  })));
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme2);
    const base = Object.keys(theme2.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index2, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index2 > 0 ? directionValues[breakpoints[index2 - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      if (ownerState.useFlexGap) {
        return {
          gap: getValue$2(transformer, propValue)
        };
      }
      return {
        // The useFlexGap={false} implement relies on each child to give up control of the margin.
        // We need to reset the margin to avoid double spacing.
        "& > :not(style):not(style)": {
          margin: 0
        },
        "& > :not(style) ~ :not(style)": {
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue$2(transformer, propValue)
        }
      };
    };
    styles2 = deepmerge$1(styles2, handleBreakpoints({
      theme: theme2
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme2.breakpoints, styles2);
  return styles2;
};
function createStack(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiStack"
  } = options;
  const useUtilityClasses2 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
  };
  const StackRoot = createStyledComponent(style);
  const Stack2 = /* @__PURE__ */ reactExports.forwardRef(function Grid3(inProps, ref) {
    const themeProps = useThemeProps2(inProps);
    const props = extendSxProp(themeProps);
    const {
      component = "div",
      direction: direction2 = "column",
      spacing = 0,
      divider,
      children,
      className,
      useFlexGap = false
    } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2t);
    const ownerState = {
      direction: direction2,
      spacing,
      useFlexGap
    };
    const classes = useUtilityClasses2();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StackRoot, _extends$2({
      as: component,
      ownerState,
      ref,
      className: clsx(classes.root, className)
    }, other, {
      children: divider ? joinChildren(children, divider) : children
    }));
  });
  return Stack2;
}
function createMixins(breakpoints, mixins) {
  return _extends$2({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
const _excluded$2s = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$1.white,
    default: common$1.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common$1.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common$1.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction2, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction2]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction2] = intent[shade];
    } else if (direction2 === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction2 === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue$1[200],
      light: blue$1[50],
      dark: blue$1[400]
    };
  }
  return {
    main: blue$1[700],
    light: blue$1[400],
    dark: blue$1[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple$1[200],
      light: purple$1[50],
      dark: purple$1[400]
    };
  }
  return {
    main: purple$1[500],
    light: purple$1[300],
    dark: purple$1[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red$1[500],
      light: red$1[300],
      dark: red$1[700]
    };
  }
  return {
    main: red$1[700],
    light: red$1[400],
    dark: red$1[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue$1[400],
      light: lightBlue$1[300],
      dark: lightBlue$1[700]
    };
  }
  return {
    main: lightBlue$1[700],
    light: lightBlue$1[500],
    dark: lightBlue$1[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green$1[400],
      light: green$1[300],
      dark: green$1[700]
    };
  }
  return {
    main: green$1[800],
    light: green$1[500],
    dark: green$1[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange$1[400],
      light: orange$1[300],
      dark: orange$1[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange$1[500],
    dark: orange$1[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette, other = _objectWithoutPropertiesLoose$1(palette, _excluded$2s);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning2 = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = _extends$2({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge$1(_extends$2({
    // A collection of common colors.
    common: _extends$2({}, common$1),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey: grey$1,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}
const _excluded$2r = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round$2(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const _ref = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily: fontFamily2 = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize: fontSize2 = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded$2r);
  const coef = fontSize2 / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight2, size, lineHeight2, letterSpacing2, casing) => _extends$2({
    fontFamily: fontFamily2,
    fontWeight: fontWeight2,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: lineHeight2
  }, fontFamily2 === defaultFontFamily ? {
    letterSpacing: `${round$2(letterSpacing2 / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge$1(_extends$2({
    htmlFontSize,
    pxToRem,
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const shadows$1 = shadows;
const _excluded$2q = ["duration", "easing", "delay"];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration$1 = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends$2({}, easing, inputTransitions.easing);
  const mergedDuration = _extends$2({}, duration$1, inputTransitions.duration);
  const create2 = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options;
    _objectWithoutPropertiesLoose$1(options, _excluded$2q);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return _extends$2({
    getAutoHeightDuration,
    create: create2
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex$1 = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
const zIndex$2 = zIndex$1;
const _excluded$2p = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$2p);
  if (options.vars) {
    throw new Error(formatMuiErrorMessage(18));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge$1(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows$1.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends$2({}, zIndex$2)
  });
  muiTheme = deepmerge$1(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$2({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function getUnit(input) {
  return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || "";
}
function toUnitless(length2) {
  return parseFloat(length2);
}
const defaultTheme$1 = createTheme();
const defaultTheme$2 = defaultTheme$1;
function useTheme() {
  const theme2 = useTheme$2(defaultTheme$2);
  return theme2[THEME_ID] || theme2;
}
function useThemeProps({
  props,
  name
}) {
  return useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme$2,
    themeId: THEME_ID
  });
}
const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
const slotShouldForwardProp = shouldForwardProp;
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$2,
  rootShouldForwardProp
});
const styled$1 = styled;
const _excluded$2o = ["theme"];
function ThemeProvider(_ref) {
  let {
    theme: themeInput
  } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$2o);
  const scopedTheme = themeInput[THEME_ID];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider$1, _extends$2({}, props, {
    themeId: scopedTheme ? THEME_ID : void 0,
    theme: scopedTheme || themeInput
  }));
}
const getOverlayAlpha = (elevation) => {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return (alphaValue / 100).toFixed(2);
};
const getOverlayAlpha$1 = getOverlayAlpha;
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$2n = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$1S = (ownerState) => {
  const {
    color: color2,
    fontSize: fontSize2,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize$1(color2)}`, `fontSize${capitalize$1(fontSize2)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled$1("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize$1(ownerState.color)}`], styles2[`fontSize${capitalize$1(ownerState.fontSize)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // e.g. heroicons uses fill="none" and stroke="currentColor"
    fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (_theme$transitions = theme2.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
      duration: (_theme$transitions2 = theme2.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((_theme$typography = theme2.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
      medium: ((_theme$typography2 = theme2.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
      large: ((_theme$typography3 = theme2.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
    }[ownerState.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (_palette$ownerState$c = (_palette = (theme2.vars || theme2).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme2.vars || theme2).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
      disabled: (_palette3 = (theme2.vars || theme2).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
      inherit: void 0
    }[ownerState.color]
  };
});
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize: fontSize2 = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2n);
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = _extends$2({}, props, {
    color: color2,
    component,
    fontSize: fontSize2,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$1S(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$2({
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, more, other, hasSvgAsChild && children.props, {
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
SvgIcon.muiName = "SvgIcon";
const SvgIcon$1 = SvgIcon;
function createSvgIcon$1(path, displayName) {
  function Component(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon$1, _extends$2({
      "data-testid": `${displayName}Icon`,
      ref
    }, props, {
      children: path
    }));
  }
  Component.muiName = SvgIcon$1.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
const unstable_ClassNameGenerator = {
  configure: (generator) => {
    ClassNameGenerator$1.configure(generator);
  }
};
const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  capitalize: capitalize$1,
  createChainedFunction,
  createSvgIcon: createSvgIcon$1,
  debounce: debounce$1,
  deprecatedPropType,
  isMuiElement,
  ownerDocument,
  ownerWindow,
  requirePropFactory,
  setRef,
  unstable_ClassNameGenerator,
  unstable_useEnhancedEffect: useEnhancedEffect$1,
  unstable_useId: useId,
  unsupportedProp,
  useControlled,
  useEventCallback: useEventCallback$1,
  useForkRef,
  useIsFocusVisible
}, Symbol.toStringTag, { value: "Module" }));
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$1(subClass, superClass);
}
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
const config$1 = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Transition3, _React$Component);
  function Transition3(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition3.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition3.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2)
            forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config$1.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config$1.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition3;
}(React.Component);
Transition$1.contextType = TransitionGroupContext;
Transition$1.propTypes = {};
function noop$6() {
}
Transition$1.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$6,
  onEntering: noop$6,
  onEntered: noop$6,
  onExit: noop$6,
  onExiting: noop$6,
  onExited: noop$6
};
Transition$1.UNMOUNTED = UNMOUNTED;
Transition$1.EXITED = EXITED;
Transition$1.ENTERING = ENTERING;
Transition$1.ENTERED = ENTERED;
Transition$1.EXITING = EXITING;
const Transition$2 = Transition$1;
var _addClass = function addClass$1(node2, classes) {
  return node2 && classes && classes.split(" ").forEach(function(c2) {
    return addClass(node2, c2);
  });
};
var removeClass = function removeClass2(node2, classes) {
  return node2 && classes && classes.split(" ").forEach(function(c2) {
    return removeClass$1(node2, c2);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node2, "exit");
      _this.addClass(node2, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type2 = appearing ? "appear" : "enter";
      _this.addClass(node2, type2, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type2 = appearing ? "appear" : "enter";
      _this.removeClasses(node2, type2);
      _this.addClass(node2, type2, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument4[0];
      _this.removeClasses(node2, "appear");
      _this.removeClasses(node2, "enter");
      _this.addClass(node2, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument5[0];
      _this.addClass(node2, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument6[0];
      _this.removeClasses(node2, "exit");
      _this.addClass(node2, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type2) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix2 = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix2 + type2 : classNames[type2];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type2 + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type2 + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node2, type2, phase) {
    var className = this.getClassNames(type2)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type2 === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node2)
        forceReflow(node2);
    }
    if (className) {
      this.appliedClasses[type2][phase] = className;
      _addClass(node2, className);
    }
  };
  _proto.removeClasses = function removeClasses(node2, type2) {
    var _this$appliedClasses$ = this.appliedClasses[type2], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type2] = {};
    if (baseClassName) {
      removeClass(node2, baseClassName);
    }
    if (activeClassName) {
      removeClass(node2, activeClassName);
    }
    if (doneClassName) {
      removeClass(node2, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose$1(_this$props, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition$2, _extends$2({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
const CSSTransition$1 = CSSTransition;
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    reactExports.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends$2({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup;
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
    easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$2m = ["className", "component", "elevation", "square", "variant"];
const useUtilityClasses$1R = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled$1("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends$2({
    backgroundColor: (theme2.vars || theme2).palette.background.paper,
    color: (theme2.vars || theme2).palette.text.primary,
    transition: theme2.transitions.create("box-shadow")
  }, !ownerState.square && {
    borderRadius: theme2.shape.borderRadius
  }, ownerState.variant === "outlined" && {
    border: `1px solid ${(theme2.vars || theme2).palette.divider}`
  }, ownerState.variant === "elevation" && _extends$2({
    boxShadow: (theme2.vars || theme2).shadows[ownerState.elevation]
  }, !theme2.vars && theme2.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))})`
  }, theme2.vars && {
    backgroundImage: (_theme$vars$overlays = theme2.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPaper"
  });
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2m);
  const ownerState = _extends$2({}, props, {
    component,
    elevation,
    square,
    variant
  });
  const classes = useUtilityClasses$1R(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$2({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other));
});
const MuiPaper = Paper;
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const touchRippleClasses$1 = touchRippleClasses;
const _excluded$2l = ["center", "classes", "className"];
let _$7 = (t3) => t3, _t$5, _t2$2, _t3$2, _t4$2;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes(_t$5 || (_t$5 = _$7`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
const exitKeyframe = keyframes(_t2$2 || (_t2$2 = _$7`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
const pulsateKeyframe = keyframes(_t3$2 || (_t3$2 = _$7`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
const TouchRippleRoot = styled$1("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled$1(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4$2 || (_t4$2 = _$7`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
  theme: theme2
}) => theme2.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut);
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2l);
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = reactExports.useRef(0);
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  reactExports.useEffect(() => {
    return () => {
      if (startTimer.current) {
        clearTimeout(startTimer.current);
      }
    };
  }, []);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses$1.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses$1.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses$1.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses$1.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses$1.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses$1.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes]);
  const start2 = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event != null && event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.current = setTimeout(() => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        }, DELAY_RIPPLE);
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit]);
  const pulsate = reactExports.useCallback(() => {
    start2({}, {
      pulsate: true
    });
  }, [start2]);
  const stop = reactExports.useCallback((event, cb2) => {
    clearTimeout(startTimer.current);
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.current = setTimeout(() => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, []);
  reactExports.useImperativeHandle(ref, () => ({
    pulsate,
    start: start2,
    stop
  }), [pulsate, start2, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$2({
    className: clsx(touchRippleClasses$1.root, classes.root, className),
    ref: container
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
const TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const buttonBaseClasses$1 = buttonBaseClasses;
const _excluded$2k = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
const useUtilityClasses$1Q = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled$1("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses$1.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type: type2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2k);
  const buttonRef = reactExports.useRef(null);
  const rippleRef = reactExports.useRef(null);
  const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback$1((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  const handleTouchMove = useRippleHandler("stop", onTouchMove);
  const handleBlur = useRippleHandler("stop", (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback$1((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const keydownRef = reactExports.useRef(false);
  const handleKeyDown2 = useEventCallback$1((event) => {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback$1((event) => {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type2 === void 0 ? "button" : type2;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
  const ownerState = _extends$2({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses$1Q(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$2({
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type: type2
  }, buttonProps, other, {
    children: [children, enableTouchRipple ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple$1, _extends$2({
        ref: handleRippleRef,
        center: centerRipple
      }, TouchRippleProps))
    ) : null]
  }));
});
const ButtonBase$1 = ButtonBase;
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
const iconButtonClasses$1 = iconButtonClasses;
const _excluded$2j = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
const useUtilityClasses$1P = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize$1(color2)}`, edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size)}`]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled$1(ButtonBase$1, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme2.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  // Explicitly set the default value to solve a bug on IE11.
  color: (theme2.vars || theme2).palette.action.active,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  })
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.action.active, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}), ({
  theme: theme2,
  ownerState
}) => {
  var _palette;
  const palette = (_palette = (theme2.vars || theme2).palette) == null ? void 0 : _palette[ownerState.color];
  return _extends$2({}, ownerState.color === "inherit" && {
    color: "inherit"
  }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends$2({
    color: palette == null ? void 0 : palette.main
  }, !ownerState.disableRipple && {
    "&:hover": _extends$2({}, palette && {
      backgroundColor: theme2.vars ? `rgba(${palette.mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(palette.main, theme2.palette.action.hoverOpacity)
    }, {
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    })
  }), ownerState.size === "small" && {
    padding: 5,
    fontSize: theme2.typography.pxToRem(18)
  }, ownerState.size === "large" && {
    padding: 12,
    fontSize: theme2.typography.pxToRem(28)
  }, {
    [`&.${iconButtonClasses$1.disabled}`]: {
      backgroundColor: "transparent",
      color: (theme2.vars || theme2).palette.action.disabled
    }
  });
});
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size = "medium"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2j);
  const ownerState = _extends$2({}, props, {
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    size
  });
  const classes = useUtilityClasses$1P(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, _extends$2({
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    ref,
    ownerState
  }, other, {
    children
  }));
});
const IconButton$1 = IconButton;
const ClearIcon$1 = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const _excluded$2i = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
const useUtilityClasses$1O = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize$1(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled$1("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize$1(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  margin: 0
}, ownerState.variant === "inherit" && {
  // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
  font: "inherit"
}, ownerState.variant !== "inherit" && theme2.typography[ownerState.variant], ownerState.align !== "inherit" && {
  textAlign: ownerState.align
}, ownerState.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, ownerState.gutterBottom && {
  marginBottom: "0.35em"
}, ownerState.paragraph && {
  marginBottom: 16
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const colorTransformations = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
};
const transformDeprecatedColors = (color2) => {
  return colorTransformations[color2] || color2;
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiTypography"
  });
  const color2 = transformDeprecatedColors(themeProps.color);
  const props = extendSxProp(_extends$2({}, themeProps, {
    color: color2
  }));
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2i);
  const ownerState = _extends$2({}, props, {
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  });
  const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$1O(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, _extends$2({
    as: Component,
    ref,
    ownerState,
    className: clsx(classes.root, className)
  }, other));
});
const Typography$1 = Typography;
function getAppBarUtilityClass(slot) {
  return generateUtilityClass("MuiAppBar", slot);
}
generateUtilityClasses("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent"]);
const _excluded$2h = ["className", "color", "enableColorOnDark", "position"];
const useUtilityClasses$1N = (ownerState) => {
  const {
    color: color2,
    position: position2,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, `position${capitalize$1(position2)}`]
  };
  return composeClasses(slots, getAppBarUtilityClass, classes);
};
const joinVars = (var1, var2) => var1 ? `${var1 == null ? void 0 : var1.replace(")", "")}, ${var2})` : var2;
const AppBarRoot = styled$1(MuiPaper, {
  name: "MuiAppBar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`position${capitalize$1(ownerState.position)}`], styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const backgroundColorDefault = theme2.palette.mode === "light" ? theme2.palette.grey[100] : theme2.palette.grey[900];
  return _extends$2({
    display: "flex",
    flexDirection: "column",
    width: "100%",
    boxSizing: "border-box",
    // Prevent padding issue with the Modal and fixed positioned AppBar.
    flexShrink: 0
  }, ownerState.position === "fixed" && {
    position: "fixed",
    zIndex: (theme2.vars || theme2).zIndex.appBar,
    top: 0,
    left: "auto",
    right: 0,
    "@media print": {
      // Prevent the app bar to be visible on each printed page.
      position: "absolute"
    }
  }, ownerState.position === "absolute" && {
    position: "absolute",
    zIndex: (theme2.vars || theme2).zIndex.appBar,
    top: 0,
    left: "auto",
    right: 0
  }, ownerState.position === "sticky" && {
    // ⚠️ sticky is not supported by IE11.
    position: "sticky",
    zIndex: (theme2.vars || theme2).zIndex.appBar,
    top: 0,
    left: "auto",
    right: 0
  }, ownerState.position === "static" && {
    position: "static"
  }, ownerState.position === "relative" && {
    position: "relative"
  }, !theme2.vars && _extends$2({}, ownerState.color === "default" && {
    backgroundColor: backgroundColorDefault,
    color: theme2.palette.getContrastText(backgroundColorDefault)
  }, ownerState.color && ownerState.color !== "default" && ownerState.color !== "inherit" && ownerState.color !== "transparent" && {
    backgroundColor: theme2.palette[ownerState.color].main,
    color: theme2.palette[ownerState.color].contrastText
  }, ownerState.color === "inherit" && {
    color: "inherit"
  }, theme2.palette.mode === "dark" && !ownerState.enableColorOnDark && {
    backgroundColor: null,
    color: null
  }, ownerState.color === "transparent" && _extends$2({
    backgroundColor: "transparent",
    color: "inherit"
  }, theme2.palette.mode === "dark" && {
    backgroundImage: "none"
  })), theme2.vars && _extends$2({}, ownerState.color === "default" && {
    "--AppBar-background": ownerState.enableColorOnDark ? theme2.vars.palette.AppBar.defaultBg : joinVars(theme2.vars.palette.AppBar.darkBg, theme2.vars.palette.AppBar.defaultBg),
    "--AppBar-color": ownerState.enableColorOnDark ? theme2.vars.palette.text.primary : joinVars(theme2.vars.palette.AppBar.darkColor, theme2.vars.palette.text.primary)
  }, ownerState.color && !ownerState.color.match(/^(default|inherit|transparent)$/) && {
    "--AppBar-background": ownerState.enableColorOnDark ? theme2.vars.palette[ownerState.color].main : joinVars(theme2.vars.palette.AppBar.darkBg, theme2.vars.palette[ownerState.color].main),
    "--AppBar-color": ownerState.enableColorOnDark ? theme2.vars.palette[ownerState.color].contrastText : joinVars(theme2.vars.palette.AppBar.darkColor, theme2.vars.palette[ownerState.color].contrastText)
  }, {
    backgroundColor: "var(--AppBar-background)",
    color: ownerState.color === "inherit" ? "inherit" : "var(--AppBar-color)"
  }, ownerState.color === "transparent" && {
    backgroundImage: "none",
    backgroundColor: "transparent",
    color: "inherit"
  }));
});
const AppBar = /* @__PURE__ */ reactExports.forwardRef(function AppBar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiAppBar"
  });
  const {
    className,
    color: color2 = "primary",
    enableColorOnDark = false,
    position: position2 = "fixed"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2h);
  const ownerState = _extends$2({}, props, {
    color: color2,
    position: position2,
    enableColorOnDark
  });
  const classes = useUtilityClasses$1N(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AppBarRoot, _extends$2({
    square: true,
    component: "header",
    ownerState,
    elevation: 4,
    className: clsx(classes.root, className, position2 === "fixed" && "mui-fixed"),
    ref
  }, other));
});
const AppBar$1 = AppBar;
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return _extends$2({}, otherProps, {
    ownerState: _extends$2({}, otherProps.ownerState, ownerState)
  });
}
function areArraysEqual(array1, array2, itemComparer = (a2, b2) => a2 === b2) {
  return array1.length === array2.length && array1.every((value, index2) => itemComparer(value, array2[index2]));
}
const defaultContextValue = {
  disableDefaultClasses: false
};
const ClassNameConfiguratorContext = /* @__PURE__ */ reactExports.createContext(defaultContextValue);
function useClassNamesOverride(generateUtilityClass2) {
  const {
    disableDefaultClasses
  } = reactExports.useContext(ClassNameConfiguratorContext);
  return (slot) => {
    if (disableDefaultClasses) {
      return "";
    }
    return generateUtilityClass2(slot);
  };
}
function extractEventHandlers(object2, excludeKeys = []) {
  if (object2 === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object2).filter((prop) => prop.match(/^on[A-Z]/) && typeof object2[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object2[prop];
  });
  return result;
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function omitEventHandlers(object2) {
  if (object2 === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object2).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object2[prop] === "function")).forEach((prop) => {
    result[prop] = object2[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
    const mergedStyle2 = _extends$2({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends$2({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends$2({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends$2({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends$2({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
const _excluded$2g = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = parameters, rest = _objectWithoutPropertiesLoose$1(parameters, _excluded$2g);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends$2({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState(elementType, _extends$2({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}
function useBadge(parameters) {
  const {
    badgeContent: badgeContentProp,
    invisible: invisibleProp = false,
    max: maxProp = 99,
    showZero = false
  } = parameters;
  const prevProps = usePreviousProps$1({
    badgeContent: badgeContentProp,
    max: maxProp
  });
  let invisible = invisibleProp;
  if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
    invisible = true;
  }
  const {
    badgeContent,
    max: max2 = maxProp
  } = invisible ? prevProps : parameters;
  const displayValue = badgeContent && Number(badgeContent) > max2 ? `${max2}+` : badgeContent;
  return {
    badgeContent,
    invisible,
    max: max2,
    displayValue
  };
}
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
function clickedRootScrollbar$1(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = "onClick",
    onClickAway,
    touchEvent = "onTouchEnd"
  } = props;
  const movedRef = reactExports.useRef(false);
  const nodeRef = reactExports.useRef(null);
  const activatedRef = reactExports.useRef(false);
  const syntheticEventRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef(
    // @ts-expect-error TODO upstream fix
    children.ref,
    nodeRef
  );
  const handleClickAway = useEventCallback$1((event) => {
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar$1(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      insideDOM = !doc.documentElement.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      ) || nodeRef.current.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      );
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  const createHandleSynthetic = (handlerName) => (event) => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  reactExports.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  reactExports.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(children, childrenProps)
  });
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root2) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i2) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i2,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a2, b2) => a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex).map((a2) => a2.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled: isEnabled2 = defaultIsEnabled,
    open: open2
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open2]);
  reactExports.useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open2]);
  reactExports.useEffect(() => {
    if (!open2 || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled2() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled2() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        var _lastKeydown$current, _lastKeydown$current2;
        const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled2, open2, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open2 ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open2 ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument2 = node2.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node2;
}
function isElement(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement$2(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement$2(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement$2(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max$1 = Math.max;
var min = Math.min;
var round$1 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$2(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y2,
    right: x2 + width2,
    bottom: y2 + height2,
    left: x2,
    x: x2,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function contains$1(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement$2(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$2(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$2(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max2) {
  return max$1(min$1, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys3) {
  return keys3.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding2, state) {
  padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding2;
  return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains$1(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y2 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x2 * dpr) / dpr || 0,
    y: round$1(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }, getWindow(popper2)) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html.clientWidth;
  var height2 = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height2 = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow2 = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow2 + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement$2(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$2(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding: padding2,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow2 = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding: padding2
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow2[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow2[mainVariationSide] <= 0, overflow2[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow2, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow2.top - rect.height - preventedOffsets.y,
    right: overflow2.right - rect.width + preventedOffsets.x,
    bottom: overflow2.bottom - rect.height + preventedOffsets.y,
    left: overflow2.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow2) {
  return [top, right, bottom, left].some(function(side) {
    return overflow2[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance2 = _ref[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow2 = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding: padding2,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow2[mainSide];
    var max2 = offset2 - overflow2[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max$1(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow2[_mainSide];
    var _max = _offset - overflow2[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement$2(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$2(offsetParent);
  var offsetParentIsScaled = isHTMLElement$2(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$2(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn3());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
  useEnhancedEffect$1(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect$1(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
  });
});
function getPopperUtilityClass(slot) {
  return generateUtilityClass("MuiPopper", slot);
}
generateUtilityClasses("MuiPopper", ["root"]);
const _excluded$2f = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps", "ownerState"], _excluded2$i = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition", "slotProps", "slots"];
function flipPlacement(placement, direction2) {
  if (direction2 === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function resolveAnchorEl$1(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
function isHTMLElement$1(element) {
  return element.nodeType !== void 0;
}
const useUtilityClasses$1M = () => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, useClassNamesOverride(getPopperUtilityClass));
};
const defaultPopperOptions = {};
const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(function PopperTooltip2(props, forwardedRef) {
  var _slots$root;
  const {
    anchorEl,
    children,
    direction: direction2,
    disablePortal,
    modifiers,
    open: open2,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    slotProps = {},
    slots = {},
    TransitionProps
    // @ts-ignore internal logic
    // prevent from spreading to DOM, it can come from the parent component e.g. Select.
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2f);
  const tooltipRef = reactExports.useRef(null);
  const ownRef = useForkRef(tooltipRef, forwardedRef);
  const popperRef = reactExports.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = reactExports.useRef(handlePopperRef);
  useEnhancedEffect$1(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction2);
  const [placement, setPlacement] = reactExports.useState(rtlPlacement);
  const [resolvedAnchorElement, setResolvedAnchorElement] = reactExports.useState(resolveAnchorEl$1(anchorEl));
  reactExports.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  reactExports.useEffect(() => {
    if (anchorEl) {
      setResolvedAnchorElement(resolveAnchorEl$1(anchorEl));
    }
  }, [anchorEl]);
  useEnhancedEffect$1(() => {
    if (!resolvedAnchorElement || !open2) {
      return void 0;
    }
    const handlePopperUpdate = (data) => {
      setPlacement(data.placement);
    };
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, _extends$2({
      placement: rtlPlacement
    }, popperOptions, {
      modifiers: popperModifiers
    }));
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [resolvedAnchorElement, disablePortal, modifiers, open2, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses$1M();
  const Root = (_slots$root = slots.root) != null ? _slots$root : "div";
  const rootProps = useSlotProps({
    elementType: Root,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: props,
    className: classes.root
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$2({}, rootProps, {
    children: typeof children === "function" ? children(childProps) : children
  }));
});
const Popper$1 = /* @__PURE__ */ reactExports.forwardRef(function Popper(props, forwardedRef) {
  const {
    anchorEl,
    children,
    container: containerProp,
    direction: direction2 = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open: open2,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style: style2,
    transition = false,
    slotProps = {},
    slots = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded2$i);
  const [exited, setExited] = reactExports.useState(true);
  const handleEnter = () => {
    setExited(false);
  };
  const handleExited = () => {
    setExited(true);
  };
  if (!keepMounted && !open2 && (!transition || exited)) {
    return null;
  }
  let container;
  if (containerProp) {
    container = containerProp;
  } else if (anchorEl) {
    const resolvedAnchorEl = resolveAnchorEl$1(anchorEl);
    container = resolvedAnchorEl && isHTMLElement$1(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
  }
  const display2 = !open2 && keepMounted && (!transition || exited) ? "none" : void 0;
  const transitionProps = transition ? {
    in: open2,
    onEnter: handleEnter,
    onExited: handleExited
  } : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    disablePortal,
    container,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperTooltip, _extends$2({
      anchorEl,
      direction: direction2,
      disablePortal,
      modifiers,
      ref: forwardedRef,
      open: transition ? !exited : open2,
      placement,
      popperOptions,
      popperRef,
      slotProps,
      slots
    }, other, {
      style: _extends$2({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: display2
      }, style2),
      TransitionProps: transitionProps,
      children
    }))
  });
});
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index2) => {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el: el2,
      property
    }) => {
      if (value) {
        el2.style.setProperty(property, value);
      } else {
        el2.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const defaultManager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager = defaultManager,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open: open2,
    rootRef
  } = parameters;
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open2);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback$1(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback$1((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open2 && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp, manager]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open2) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open2, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.key !== "Escape" || !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = _extends$2({}, propsEventHandlers, otherHandlers);
    return _extends$2({
      role: "presentation"
    }, externalEventHandlers, {
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    });
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return _extends$2({
      "aria-hidden": true
    }, externalEventHandlers, {
      onClick: createHandleBackdropClick(externalEventHandlers),
      open: open2
    });
  };
  const getTransitionProps2 = () => {
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function asc(a2, b2) {
  return a2 - b2;
}
function clamp$2(value, min2, max2) {
  if (value == null) {
    return min2;
  }
  return Math.min(Math.max(min2, value), max2);
}
function findClosest(values2, currentValue) {
  var _values$reduce;
  const {
    index: closestIndex
  } = (_values$reduce = values2.reduce((acc, value, index2) => {
    const distance2 = Math.abs(currentValue - value);
    if (acc === null || distance2 < acc.distance || distance2 === acc.distance) {
      return {
        distance: distance2,
        index: index2
      };
    }
    return acc;
  }, null)) != null ? _values$reduce : {};
  return closestIndex;
}
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    const touchEvent = event;
    for (let i2 = 0; i2 < touchEvent.changedTouches.length; i2 += 1) {
      const touch = touchEvent.changedTouches[i2];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min2, max2) {
  return (value - min2) * 100 / (max2 - min2);
}
function percentToValue(percent, min2, max2) {
  return (max2 - min2) * percent + min2;
}
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min2) {
  const nearest = Math.round((value - min2) / step) * step + min2;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values: values2,
  newValue,
  index: index2
}) {
  const output = values2.slice();
  output[index2] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _sliderRef$current, _doc$activeElement;
  const doc = ownerDocument(sliderRef.current);
  if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null || (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute("data-index")) !== activeIndex) {
    var _sliderRef$current2;
    (_sliderRef$current2 = sliderRef.current) == null || _sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === "number" && typeof oldValue === "number") {
    return newValue === oldValue;
  }
  if (typeof newValue === "object" && typeof oldValue === "object") {
    return areArraysEqual(newValue, oldValue);
  }
  return false;
}
const axisProps = {
  horizontal: {
    offset: (percent) => ({
      left: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  "horizontal-reverse": {
    offset: (percent) => ({
      right: `${percent}%`
    }),
    leap: (percent) => ({
      width: `${percent}%`
    })
  },
  vertical: {
    offset: (percent) => ({
      bottom: `${percent}%`
    }),
    leap: (percent) => ({
      height: `${percent}%`
    })
  }
};
const Identity$1 = (x2) => x2;
let cachedSupportsTouchActionNone;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
function useSlider(parameters) {
  const {
    "aria-labelledby": ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = "horizontal",
    rootRef: ref,
    scale = Identity$1,
    step = 1,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = reactExports.useRef();
  const [active, setActive] = reactExports.useState(-1);
  const [open2, setOpen] = reactExports.useState(-1);
  const [dragging, setDragging] = reactExports.useState(false);
  const moveCount = reactExports.useRef(0);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : min2,
    name: "Slider"
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    const nativeEvent = event.nativeEvent || event;
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, "target", {
      writable: true,
      value: {
        value,
        name
      }
    });
    onChange(clonedEvent, value, thumbIndex);
  });
  const range = Array.isArray(valueDerived);
  let values2 = range ? valueDerived.slice().sort(asc) : [valueDerived];
  values2 = values2.map((value) => clamp$2(value, min2, max2));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max2 - min2) / step) + 1)].map((_2, index2) => ({
    value: min2 + step * index2
  })) : marksProp || [];
  const marksValues = marks.map((mark) => mark.value);
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusedThumbIndex, setFocusedThumbIndex] = reactExports.useState(-1);
  const sliderRef = reactExports.useRef();
  const handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
  const handleRef = useForkRef(ref, handleFocusRef);
  const createHandleHiddenInputFocus = (otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusedThumbIndex(index2);
    }
    setOpen(index2);
    otherHandlers == null || (_otherHandlers$onFocu = otherHandlers.onFocus) == null || _otherHandlers$onFocu.call(otherHandlers, event);
  };
  const createHandleHiddenInputBlur = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    otherHandlers == null || (_otherHandlers$onBlur = otherHandlers.onBlur) == null || _otherHandlers$onBlur.call(otherHandlers, event);
  };
  useEnhancedEffect$1(() => {
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      var _document$activeEleme;
      (_document$activeEleme = document.activeElement) == null || _document$activeEleme.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = (otherHandlers) => (event) => {
    var _otherHandlers$onChan;
    (_otherHandlers$onChan = otherHandlers.onChange) == null || _otherHandlers$onChan.call(otherHandlers, event);
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    const value = values2[index2];
    const marksIndex = marksValues.indexOf(value);
    let newValue = event.target.valueAsNumber;
    if (marks && step == null) {
      const maxMarksValue = marksValues[marksValues.length - 1];
      if (newValue > maxMarksValue) {
        newValue = maxMarksValue;
      } else if (newValue < marksValues[0]) {
        newValue = marksValues[0];
      } else {
        newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
      }
    }
    newValue = clamp$2(newValue, min2, max2);
    if (range) {
      if (disableSwap) {
        newValue = clamp$2(newValue, values2[index2 - 1] || -Infinity, values2[index2 + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: index2
      });
      let activeIndex = index2;
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index2);
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(event, newValue, index2);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, newValue);
    }
  };
  const previousIndex = reactExports.useRef();
  let axis = orientation;
  if (isRtl && orientation === "horizontal") {
    axis += "-reverse";
  }
  const getFingerNewValue = ({
    finger,
    move = false
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width: width2,
      height: height2,
      bottom: bottom2,
      left: left2
    } = slider.getBoundingClientRect();
    let percent;
    if (axis.indexOf("vertical") === 0) {
      percent = (bottom2 - finger.y) / height2;
    } else {
      percent = (finger.x - left2) / width2;
    }
    if (axis.indexOf("-reverse") !== -1) {
      percent = 1 - percent;
    }
    let newValue;
    newValue = percentToValue(percent, min2, max2);
    if (step) {
      newValue = roundValueToStep(newValue, step, min2);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp$2(newValue, min2, max2);
    let activeIndex = 0;
    if (range) {
      if (!move) {
        activeIndex = findClosest(values2, newValue);
      } else {
        activeIndex = previousIndex.current;
      }
      if (disableSwap) {
        newValue = clamp$2(newValue, values2[activeIndex - 1] || -Infinity, values2[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: activeIndex
      });
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  };
  const handleTouchMove = useEventCallback$1((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;
    if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange && !areValuesEqual(newValue, valueDerived)) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback$1((nativeEvent) => {
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true
    });
    setActive(-1);
    if (nativeEvent.type === "touchend") {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, newValue);
    }
    touchId.current = void 0;
    stopListening();
  });
  const handleTouchStart = useEventCallback$1((nativeEvent) => {
    if (disabled) {
      return;
    }
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("touchmove", handleTouchMove);
    doc.addEventListener("touchend", handleTouchEnd);
  });
  const stopListening = reactExports.useCallback(() => {
    const doc = ownerDocument(sliderRef.current);
    doc.removeEventListener("mousemove", handleTouchMove);
    doc.removeEventListener("mouseup", handleTouchEnd);
    doc.removeEventListener("touchmove", handleTouchMove);
    doc.removeEventListener("touchend", handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  reactExports.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener("touchstart", handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      slider.removeEventListener("touchstart", handleTouchStart, {
        passive: doesSupportTouchActionNone()
      });
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  reactExports.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    (_otherHandlers$onMous = otherHandlers.onMouseDown) == null || _otherHandlers$onMous.call(otherHandlers, event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange && !areValuesEqual(newValue, valueDerived)) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener("mousemove", handleTouchMove);
    doc.addEventListener("mouseup", handleTouchEnd);
  };
  const trackOffset = valueToPercent(range ? values2[0] : min2, min2, max2);
  const trackLeap = valueToPercent(values2[values2.length - 1], min2, max2) - trackOffset;
  const getRootProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(otherHandlers || {})
    };
    const mergedEventHandlers = _extends$2({}, otherHandlers, ownEventHandlers);
    return _extends$2({
      ref: handleRef
    }, mergedEventHandlers);
  };
  const createHandleMouseOver = (otherHandlers) => (event) => {
    var _otherHandlers$onMous2;
    (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null || _otherHandlers$onMous2.call(otherHandlers, event);
    const index2 = Number(event.currentTarget.getAttribute("data-index"));
    setOpen(index2);
  };
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    var _otherHandlers$onMous3;
    (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null || _otherHandlers$onMous3.call(otherHandlers, event);
    setOpen(-1);
  };
  const getThumbProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(otherHandlers || {}),
      onMouseLeave: createHandleMouseLeave(otherHandlers || {})
    };
    return _extends$2({}, otherHandlers, ownEventHandlers);
  };
  const getThumbStyle = (index2) => {
    return {
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: active !== -1 && active !== index2 ? "none" : void 0
    };
  };
  const getHiddenInputProps = (otherHandlers = {}) => {
    var _parameters$step;
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(otherHandlers || {}),
      onFocus: createHandleHiddenInputFocus(otherHandlers || {}),
      onBlur: createHandleHiddenInputBlur(otherHandlers || {})
    };
    const mergedEventHandlers = _extends$2({}, otherHandlers, ownEventHandlers);
    return _extends$2({
      tabIndex,
      "aria-labelledby": ariaLabelledby,
      "aria-orientation": orientation,
      "aria-valuemax": scale(max2),
      "aria-valuemin": scale(min2),
      name,
      type: "range",
      min: parameters.min,
      max: parameters.max,
      step: parameters.step === null && parameters.marks ? "any" : (_parameters$step = parameters.step) != null ? _parameters$step : void 0,
      disabled
    }, mergedEventHandlers, {
      style: _extends$2({}, visuallyHidden$1, {
        direction: isRtl ? "rtl" : "ltr",
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: "100%",
        height: "100%"
      })
    });
  };
  return {
    active,
    axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open: open2,
    range,
    rootRef: handleRef,
    trackLeap,
    trackOffset,
    values: values2,
    getThumbStyle
  };
}
const _excluded$2e = ["onChange", "maxRows", "minRows", "style", "value"];
function getStyleValue(value) {
  return parseInt(value, 10) || 0;
}
const styles$3 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isEmpty$2(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflow;
}
const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
  const {
    onChange,
    maxRows,
    minRows = 1,
    style: style2,
    value
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2e);
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef(null);
  const handleRef = useForkRef(forwardedRef, inputRef);
  const shadowRef = reactExports.useRef(null);
  const renders = reactExports.useRef(0);
  const [state, setState] = reactExports.useState({
    outerHeightStyle: 0
  });
  const getUpdatedState = reactExports.useCallback(() => {
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    const computedStyle = containerWindow.getComputedStyle(input);
    if (computedStyle.width === "0px") {
      return {
        outerHeightStyle: 0
      };
    }
    const inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || "x";
    if (inputShallow.value.slice(-1) === "\n") {
      inputShallow.value += " ";
    }
    const boxSizing2 = computedStyle.boxSizing;
    const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
    const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
    const innerHeight = inputShallow.scrollHeight;
    inputShallow.value = "x";
    const singleRowHeight = inputShallow.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
    const overflow2 = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflow: overflow2
    };
  }, [maxRows, minRows, props.placeholder]);
  const updateState = (prevState, newState) => {
    const {
      outerHeightStyle,
      overflow: overflow2
    } = newState;
    if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow2)) {
      renders.current += 1;
      return {
        overflow: overflow2,
        outerHeightStyle
      };
    }
    return prevState;
  };
  const syncHeight = reactExports.useCallback(() => {
    const newState = getUpdatedState();
    if (isEmpty$2(newState)) {
      return;
    }
    setState((prevState) => updateState(prevState, newState));
  }, [getUpdatedState]);
  useEnhancedEffect$1(() => {
    const syncHeightWithFlushSync = () => {
      const newState = getUpdatedState();
      if (isEmpty$2(newState)) {
        return;
      }
      reactDomExports.flushSync(() => {
        setState((prevState) => updateState(prevState, newState));
      });
    };
    const handleResize = () => {
      renders.current = 0;
      syncHeightWithFlushSync();
    };
    let rAF2;
    const debounceHandleResize = debounce$1(handleResize);
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    containerWindow.addEventListener("resize", debounceHandleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(input);
    }
    return () => {
      debounceHandleResize.clear();
      cancelAnimationFrame(rAF2);
      containerWindow.removeEventListener("resize", debounceHandleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [getUpdatedState]);
  useEnhancedEffect$1(() => {
    syncHeight();
  });
  reactExports.useEffect(() => {
    renders.current = 0;
  }, [value]);
  const handleChange = (event) => {
    renders.current = 0;
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", _extends$2({
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: _extends$2({
        height: state.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: state.overflow ? "hidden" : void 0
      }, style2)
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: _extends$2({}, styles$3.shadow, style2, {
        paddingTop: 0,
        paddingBottom: 0
      })
    })]
  });
});
function stripDiacritics(string2) {
  return typeof string2.normalize !== "undefined" ? string2.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string2;
}
function createFilterOptions(config2 = {}) {
  const {
    ignoreAccents = true,
    ignoreCase = true,
    limit,
    matchFrom = "any",
    stringify: stringify2,
    trim: trim2 = false
  } = config2;
  return (options, {
    inputValue,
    getOptionLabel
  }) => {
    let input = trim2 ? inputValue.trim() : inputValue;
    if (ignoreCase) {
      input = input.toLowerCase();
    }
    if (ignoreAccents) {
      input = stripDiacritics(input);
    }
    const filteredOptions = !input ? options : options.filter((option) => {
      let candidate = (stringify2 || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
function findIndex$1(array2, comp) {
  for (let i2 = 0; i2 < array2.length; i2 += 1) {
    if (comp(array2[i2])) {
      return i2;
    }
  }
  return -1;
}
const defaultFilterOptions = createFilterOptions();
const pageSize = 5;
const defaultIsActiveElementInListbox = (listboxRef) => {
  var _listboxRef$current$p;
  return listboxRef.current !== null && ((_listboxRef$current$p = listboxRef.current.parentElement) == null ? void 0 : _listboxRef$current$p.contains(document.activeElement));
};
function useAutocomplete(props) {
  const {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_isActiveElementInListbox = defaultIsActiveElementInListbox,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_classNamePrefix = "Mui",
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    componentName = "useAutocomplete",
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled: disabledProp,
    disabledItemsFocusable = false,
    disableListWrap = false,
    filterOptions = defaultFilterOptions,
    filterSelectedOptions = false,
    freeSolo = false,
    getOptionDisabled,
    getOptionLabel: getOptionLabelProp = (option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    },
    groupBy: groupBy2,
    handleHomeEndKeys = !props.freeSolo,
    id: idProp,
    includeInputInList = false,
    inputValue: inputValueProp,
    isOptionEqualToValue = (option, value2) => option === value2,
    multiple = false,
    onChange,
    onClose,
    onHighlightChange,
    onInputChange,
    onOpen,
    open: openProp,
    openOnFocus = false,
    options,
    readOnly = false,
    selectOnFocus = !props.freeSolo,
    value: valueProp
  } = props;
  const id2 = useId(idProp);
  let getOptionLabel = getOptionLabelProp;
  getOptionLabel = (option) => {
    const optionLabel = getOptionLabelProp(option);
    if (typeof optionLabel !== "string") {
      return String(optionLabel);
    }
    return optionLabel;
  };
  const ignoreFocus = reactExports.useRef(false);
  const firstFocus = reactExports.useRef(true);
  const inputRef = reactExports.useRef(null);
  const listboxRef = reactExports.useRef(null);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const [focusedTag, setFocusedTag] = reactExports.useState(-1);
  const defaultHighlighted = autoHighlight ? 0 : -1;
  const highlightedIndexRef = reactExports.useRef(defaultHighlighted);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: componentName
  });
  const [inputValue, setInputValueState] = useControlled({
    controlled: inputValueProp,
    default: "",
    name: componentName,
    state: "inputValue"
  });
  const [focused, setFocused] = reactExports.useState(false);
  const resetInputValue = reactExports.useCallback((event, newValue) => {
    const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
    if (!isOptionSelected && !clearOnBlur) {
      return;
    }
    let newInputValue;
    if (multiple) {
      newInputValue = "";
    } else if (newValue == null) {
      newInputValue = "";
    } else {
      const optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === "string" ? optionLabel : "";
    }
    if (inputValue === newInputValue) {
      return;
    }
    setInputValueState(newInputValue);
    if (onInputChange) {
      onInputChange(event, newInputValue, "reset");
    }
  }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
  const [open2, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: componentName,
    state: "open"
  });
  const [inputPristine, setInputPristine] = reactExports.useState(true);
  const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
  const popupOpen = open2 && !readOnly;
  const filteredOptions = popupOpen ? filterOptions(
    options.filter((option) => {
      if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
        return false;
      }
      return true;
    }),
    // we use the empty string to manipulate `filterOptions` to not filter any options
    // i.e. the filter predicate always returns true
    {
      inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
      getOptionLabel
    }
  ) : [];
  const previousProps = usePreviousProps$1({
    filteredOptions,
    value,
    inputValue
  });
  reactExports.useEffect(() => {
    const valueChange = value !== previousProps.value;
    if (focused && !valueChange) {
      return;
    }
    if (freeSolo && !valueChange) {
      return;
    }
    resetInputValue(null, value);
  }, [value, resetInputValue, focused, previousProps.value, freeSolo]);
  const listboxAvailable = open2 && filteredOptions.length > 0 && !readOnly;
  const focusTag = useEventCallback$1((tagToFocus) => {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
    }
  });
  reactExports.useEffect(() => {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);
  function validOptionIndex(index2, direction2) {
    if (!listboxRef.current || index2 === -1) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      if (direction2 === "next" && nextFocus === filteredOptions.length || direction2 === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
      const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
      if (option && !option.hasAttribute("tabindex") || nextFocusDisabled) {
        nextFocus += direction2 === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const setHighlightedIndex = useEventCallback$1(({
    event,
    index: index2,
    reason = "auto"
  }) => {
    highlightedIndexRef.current = index2;
    if (index2 === -1) {
      inputRef.current.removeAttribute("aria-activedescendant");
    } else {
      inputRef.current.setAttribute("aria-activedescendant", `${id2}-option-${index2}`);
    }
    if (onHighlightChange) {
      onHighlightChange(event, index2 === -1 ? null : filteredOptions[index2], reason);
    }
    if (!listboxRef.current) {
      return;
    }
    const prev2 = listboxRef.current.querySelector(`[role="option"].${unstable_classNamePrefix}-focused`);
    if (prev2) {
      prev2.classList.remove(`${unstable_classNamePrefix}-focused`);
      prev2.classList.remove(`${unstable_classNamePrefix}-focusVisible`);
    }
    let listboxNode = listboxRef.current;
    if (listboxRef.current.getAttribute("role") !== "listbox") {
      listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
    }
    if (!listboxNode) {
      return;
    }
    if (index2 === -1) {
      listboxNode.scrollTop = 0;
      return;
    }
    const option = listboxRef.current.querySelector(`[data-option-index="${index2}"]`);
    if (!option) {
      return;
    }
    option.classList.add(`${unstable_classNamePrefix}-focused`);
    if (reason === "keyboard") {
      option.classList.add(`${unstable_classNamePrefix}-focusVisible`);
    }
    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse" && reason !== "touch") {
      const element = option;
      const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      const elementBottom = element.offsetTop + element.offsetHeight;
      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element.offsetTop - element.offsetHeight * (groupBy2 ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy2 ? 1.3 : 0);
      }
    }
  });
  const changeHighlightedIndex = useEventCallback$1(({
    event,
    diff,
    direction: direction2 = "next",
    reason = "auto"
  }) => {
    if (!popupOpen) {
      return;
    }
    const getNextIndex = () => {
      const maxIndex = filteredOptions.length - 1;
      if (diff === "reset") {
        return defaultHighlighted;
      }
      if (diff === "start") {
        return 0;
      }
      if (diff === "end") {
        return maxIndex;
      }
      const newIndex = highlightedIndexRef.current + diff;
      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
          return 0;
        }
        return maxIndex;
      }
      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap || Math.abs(diff) > 1) {
          return maxIndex;
        }
        return 0;
      }
      return newIndex;
    };
    const nextIndex = validOptionIndex(getNextIndex(), direction2);
    setHighlightedIndex({
      index: nextIndex,
      reason,
      event
    });
    if (autoComplete && diff !== "reset") {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue;
      } else {
        const option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option;
        const index2 = option.toLowerCase().indexOf(inputValue.toLowerCase());
        if (index2 === 0 && inputValue.length > 0) {
          inputRef.current.setSelectionRange(inputValue.length, option.length);
        }
      }
    }
  });
  const checkHighlightedOptionExists = () => {
    const isSameValue = (value1, value2) => {
      const label1 = value1 ? getOptionLabel(value1) : "";
      const label2 = value2 ? getOptionLabel(value2) : "";
      return label1 === label2;
    };
    if (highlightedIndexRef.current !== -1 && previousProps.filteredOptions && previousProps.filteredOptions.length !== filteredOptions.length && previousProps.inputValue === inputValue && (multiple ? value.length === previousProps.value.length && previousProps.value.every((val, i2) => getOptionLabel(value[i2]) === getOptionLabel(val)) : isSameValue(previousProps.value, value))) {
      const previousHighlightedOption = previousProps.filteredOptions[highlightedIndexRef.current];
      if (previousHighlightedOption) {
        const previousHighlightedOptionExists = filteredOptions.some((option) => {
          return getOptionLabel(option) === getOptionLabel(previousHighlightedOption);
        });
        if (previousHighlightedOptionExists) {
          return true;
        }
      }
    }
    return false;
  };
  const syncHighlightedIndex = reactExports.useCallback(() => {
    if (!popupOpen) {
      return;
    }
    if (checkHighlightedOptionExists()) {
      return;
    }
    const valueItem = multiple ? value[0] : value;
    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: "reset"
      });
      return;
    }
    if (!listboxRef.current) {
      return;
    }
    if (valueItem != null) {
      const currentOption = filteredOptions[highlightedIndexRef.current];
      if (multiple && currentOption && findIndex$1(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
        return;
      }
      const itemIndex = findIndex$1(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: "reset"
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }
      return;
    }
    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    }
    setHighlightedIndex({
      index: highlightedIndexRef.current
    });
  }, [
    // Only sync the highlighted index when the option switch between empty and not
    filteredOptions.length,
    // Don't sync the highlighted index with the value when multiple
    // eslint-disable-next-line react-hooks/exhaustive-deps
    multiple ? false : value,
    filterSelectedOptions,
    changeHighlightedIndex,
    setHighlightedIndex,
    popupOpen,
    inputValue,
    multiple
  ]);
  const handleListboxRef = useEventCallback$1((node2) => {
    setRef(listboxRef, node2);
    if (!node2) {
      return;
    }
    syncHighlightedIndex();
  });
  reactExports.useEffect(() => {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);
  const handleOpen = (event) => {
    if (open2) {
      return;
    }
    setOpenState(true);
    setInputPristine(true);
    if (onOpen) {
      onOpen(event);
    }
  };
  const handleClose = (event, reason) => {
    if (!open2) {
      return;
    }
    setOpenState(false);
    if (onClose) {
      onClose(event, reason);
    }
  };
  const handleValue = (event, newValue, reason, details) => {
    if (multiple) {
      if (value.length === newValue.length && value.every((val, i2) => val === newValue[i2])) {
        return;
      }
    } else if (value === newValue) {
      return;
    }
    if (onChange) {
      onChange(event, newValue, reason, details);
    }
    setValueState(newValue);
  };
  const isTouch = reactExports.useRef(false);
  const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
    let reason = reasonProp;
    let newValue = option;
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = findIndex$1(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin !== "freeSolo") {
        newValue.splice(itemIndex, 1);
        reason = "removeOption";
      }
    }
    resetInputValue(event, newValue);
    handleValue(event, newValue, reason, {
      option
    });
    if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
      handleClose(event, reason);
    }
    if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
      inputRef.current.blur();
    }
  };
  function validTagIndex(index2, direction2) {
    if (index2 === -1) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      if (direction2 === "next" && nextFocus === value.length || direction2 === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
      if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
        nextFocus += direction2 === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const handleFocusTag = (event, direction2) => {
    if (!multiple) {
      return;
    }
    if (inputValue === "") {
      handleClose(event, "toggleInput");
    }
    let nextTag = focusedTag;
    if (focusedTag === -1) {
      if (inputValue === "" && direction2 === "previous") {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction2 === "next" ? 1 : -1;
      if (nextTag < 0) {
        nextTag = 0;
      }
      if (nextTag === value.length) {
        nextTag = -1;
      }
    }
    nextTag = validTagIndex(nextTag, direction2);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  };
  const handleClear = (event) => {
    ignoreFocus.current = true;
    setInputValueState("");
    if (onInputChange) {
      onInputChange(event, "", "clear");
    }
    handleValue(event, multiple ? [] : null, "clear");
  };
  const handleKeyDown2 = (other) => (event) => {
    if (other.onKeyDown) {
      other.onKeyDown(event);
    }
    if (event.defaultMuiPrevented) {
      return;
    }
    if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
    if (event.which !== 229) {
      switch (event.key) {
        case "Home":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "start",
              direction: "next",
              reason: "keyboard",
              event
            });
          }
          break;
        case "End":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "end",
              direction: "previous",
              reason: "keyboard",
              event
            });
          }
          break;
        case "PageUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "PageDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowLeft":
          handleFocusTag(event, "previous");
          break;
        case "ArrowRight":
          handleFocusTag(event, "next");
          break;
        case "Enter":
          if (highlightedIndexRef.current !== -1 && popupOpen) {
            const option = filteredOptions[highlightedIndexRef.current];
            const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            event.preventDefault();
            if (disabled) {
              return;
            }
            selectNewValue(event, option, "selectOption");
            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
            if (multiple) {
              event.preventDefault();
            }
            selectNewValue(event, inputValue, "createOption", "freeSolo");
          }
          break;
        case "Escape":
          if (popupOpen) {
            event.preventDefault();
            event.stopPropagation();
            handleClose(event, "escape");
          } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
            event.preventDefault();
            event.stopPropagation();
            handleClear(event);
          }
          break;
        case "Backspace":
          if (multiple && !readOnly && inputValue === "" && value.length > 0) {
            const index2 = focusedTag === -1 ? value.length - 1 : focusedTag;
            const newValue = value.slice();
            newValue.splice(index2, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index2]
            });
          }
          break;
        case "Delete":
          if (multiple && !readOnly && inputValue === "" && value.length > 0 && focusedTag !== -1) {
            const index2 = focusedTag;
            const newValue = value.slice();
            newValue.splice(index2, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index2]
            });
          }
          break;
      }
    }
  };
  const handleFocus = (event) => {
    setFocused(true);
    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  };
  const handleBlur = (event) => {
    if (unstable_isActiveElementInListbox(listboxRef)) {
      inputRef.current.focus();
      return;
    }
    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;
    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
    } else if (autoSelect && freeSolo && inputValue !== "") {
      selectNewValue(event, inputValue, "blur", "freeSolo");
    } else if (clearOnBlur) {
      resetInputValue(event, value);
    }
    handleClose(event, "blur");
  };
  const handleInputChange = (event) => {
    const newValue = event.target.value;
    if (inputValue !== newValue) {
      setInputValueState(newValue);
      setInputPristine(false);
      if (onInputChange) {
        onInputChange(event, newValue, "input");
      }
    }
    if (newValue === "") {
      if (!disableClearable && !multiple) {
        handleValue(event, null, "clear");
      }
    } else {
      handleOpen(event);
    }
  };
  const handleOptionMouseMove = (event) => {
    const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
    if (highlightedIndexRef.current !== index2) {
      setHighlightedIndex({
        event,
        index: index2,
        reason: "mouse"
      });
    }
  };
  const handleOptionTouchStart = (event) => {
    setHighlightedIndex({
      event,
      index: Number(event.currentTarget.getAttribute("data-option-index")),
      reason: "touch"
    });
    isTouch.current = true;
  };
  const handleOptionClick = (event) => {
    const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
    selectNewValue(event, filteredOptions[index2], "selectOption");
    isTouch.current = false;
  };
  const handleTagDelete = (index2) => (event) => {
    const newValue = value.slice();
    newValue.splice(index2, 1);
    handleValue(event, newValue, "removeOption", {
      option: value[index2]
    });
  };
  const handlePopupIndicator = (event) => {
    if (open2) {
      handleClose(event, "toggleInput");
    } else {
      handleOpen(event);
    }
  };
  const handleMouseDown = (event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    if (event.target.getAttribute("id") !== id2) {
      event.preventDefault();
    }
  };
  const handleClick = (event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    inputRef.current.focus();
    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }
    firstFocus.current = false;
  };
  const handleInputMouseDown = (event) => {
    if (!disabledProp && (inputValue === "" || !open2)) {
      handlePopupIndicator(event);
    }
  };
  let dirty = freeSolo && inputValue.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  let groupedOptions = filteredOptions;
  if (groupBy2) {
    groupedOptions = filteredOptions.reduce((acc, option, index2) => {
      const group = groupBy2(option);
      if (acc.length > 0 && acc[acc.length - 1].group === group) {
        acc[acc.length - 1].options.push(option);
      } else {
        acc.push({
          key: index2,
          index: index2,
          group,
          options: [option]
        });
      }
      return acc;
    }, []);
  }
  if (disabledProp && focused) {
    handleBlur();
  }
  return {
    getRootProps: (other = {}) => _extends$2({
      "aria-owns": listboxAvailable ? `${id2}-listbox` : null
    }, other, {
      onKeyDown: handleKeyDown2(other),
      onMouseDown: handleMouseDown,
      onClick: handleClick
    }),
    getInputLabelProps: () => ({
      id: `${id2}-label`,
      htmlFor: id2
    }),
    getInputProps: () => ({
      id: id2,
      value: inputValue,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onChange: handleInputChange,
      onMouseDown: handleInputMouseDown,
      // if open then this is handled imperatively so don't let react override
      // only have an opinion about this when closed
      "aria-activedescendant": popupOpen ? "" : null,
      "aria-autocomplete": autoComplete ? "both" : "list",
      "aria-controls": listboxAvailable ? `${id2}-listbox` : void 0,
      "aria-expanded": listboxAvailable,
      // Disable browser's suggestion that might overlap with the popup.
      // Handle autocomplete but not autofill.
      autoComplete: "off",
      ref: inputRef,
      autoCapitalize: "none",
      spellCheck: "false",
      role: "combobox",
      disabled: disabledProp
    }),
    getClearProps: () => ({
      tabIndex: -1,
      onClick: handleClear
    }),
    getPopupIndicatorProps: () => ({
      tabIndex: -1,
      onClick: handlePopupIndicator
    }),
    getTagProps: ({
      index: index2
    }) => _extends$2({
      key: index2,
      "data-tag-index": index2,
      tabIndex: -1
    }, !readOnly && {
      onDelete: handleTagDelete(index2)
    }),
    getListboxProps: () => ({
      role: "listbox",
      id: `${id2}-listbox`,
      "aria-labelledby": `${id2}-label`,
      ref: handleListboxRef,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }),
    getOptionProps: ({
      index: index2,
      option
    }) => {
      const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
      const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: getOptionLabel(option),
        tabIndex: -1,
        role: "option",
        id: `${id2}-option-${index2}`,
        onMouseMove: handleOptionMouseMove,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        "data-option-index": index2,
        "aria-disabled": disabled,
        "aria-selected": selected
      };
    },
    id: id2,
    inputValue,
    value,
    dirty,
    expanded: popupOpen && anchorEl,
    popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl,
    setAnchorEl,
    focusedTag,
    groupedOptions
  };
}
const _excluded$2d = ["anchorEl", "component", "components", "componentsProps", "container", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "transition", "slots", "slotProps"];
const PopperRoot = styled$1(Popper$1, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const Popper2 = /* @__PURE__ */ reactExports.forwardRef(function Popper3(inProps, ref) {
  var _slots$root;
  const theme2 = useTheme$3();
  const props = useThemeProps({
    props: inProps,
    name: "MuiPopper"
  });
  const {
    anchorEl,
    component,
    components,
    componentsProps,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open: open2,
    placement,
    popperOptions,
    popperRef,
    transition,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2d);
  const RootComponent = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components == null ? void 0 : components.Root;
  const otherProps = _extends$2({
    anchorEl,
    container,
    disablePortal,
    keepMounted,
    modifiers,
    open: open2,
    placement,
    popperOptions,
    popperRef,
    transition
  }, other);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperRoot, _extends$2({
    as: component,
    direction: theme2 == null ? void 0 : theme2.direction,
    slots: {
      root: RootComponent
    },
    slotProps: slotProps != null ? slotProps : componentsProps
  }, otherProps, {
    ref
  }));
});
const MuiPopper = Popper2;
function getListSubheaderUtilityClass(slot) {
  return generateUtilityClass("MuiListSubheader", slot);
}
generateUtilityClasses("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
const _excluded$2c = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
const useUtilityClasses$1L = (ownerState) => {
  const {
    classes,
    color: color2,
    disableGutters,
    inset,
    disableSticky
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "default" && `color${capitalize$1(color2)}`, !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"]
  };
  return composeClasses(slots, getListSubheaderUtilityClass, classes);
};
const ListSubheaderRoot = styled$1("li", {
  name: "MuiListSubheader",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], !ownerState.disableGutters && styles2.gutters, ownerState.inset && styles2.inset, !ownerState.disableSticky && styles2.sticky];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  boxSizing: "border-box",
  lineHeight: "48px",
  listStyle: "none",
  color: (theme2.vars || theme2).palette.text.secondary,
  fontFamily: theme2.typography.fontFamily,
  fontWeight: theme2.typography.fontWeightMedium,
  fontSize: theme2.typography.pxToRem(14)
}, ownerState.color === "primary" && {
  color: (theme2.vars || theme2).palette.primary.main
}, ownerState.color === "inherit" && {
  color: "inherit"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.inset && {
  paddingLeft: 72
}, !ownerState.disableSticky && {
  position: "sticky",
  top: 0,
  zIndex: 1,
  backgroundColor: (theme2.vars || theme2).palette.background.paper
}));
const ListSubheader = /* @__PURE__ */ reactExports.forwardRef(function ListSubheader2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListSubheader"
  });
  const {
    className,
    color: color2 = "default",
    component = "li",
    disableGutters = false,
    disableSticky = false,
    inset = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2c);
  const ownerState = _extends$2({}, props, {
    color: color2,
    component,
    disableGutters,
    disableSticky,
    inset
  });
  const classes = useUtilityClasses$1L(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListSubheaderRoot, _extends$2({
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other));
});
ListSubheader.muiSkipListHighlight = true;
const ListSubheader$1 = ListSubheader;
const CancelIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}), "Cancel");
function getChipUtilityClass(slot) {
  return generateUtilityClass("MuiChip", slot);
}
const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
const chipClasses$1 = chipClasses;
const _excluded$2b = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant", "tabIndex", "skipFocusWhenDisabled"];
const useUtilityClasses$1K = (ownerState) => {
  const {
    classes,
    disabled,
    size,
    color: color2,
    iconColor,
    onDelete,
    clickable,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, disabled && "disabled", `size${capitalize$1(size)}`, `color${capitalize$1(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize$1(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize$1(color2)}`, `${variant}${capitalize$1(color2)}`],
    label: ["label", `label${capitalize$1(size)}`],
    avatar: ["avatar", `avatar${capitalize$1(size)}`, `avatarColor${capitalize$1(color2)}`],
    icon: ["icon", `icon${capitalize$1(size)}`, `iconColor${capitalize$1(iconColor)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${capitalize$1(size)}`, `deleteIconColor${capitalize$1(color2)}`, `deleteIcon${capitalize$1(variant)}Color${capitalize$1(color2)}`]
  };
  return composeClasses(slots, getChipUtilityClass, classes);
};
const ChipRoot = styled$1("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      color: color2,
      iconColor,
      clickable,
      onDelete,
      size,
      variant
    } = ownerState;
    return [{
      [`& .${chipClasses$1.avatar}`]: styles2.avatar
    }, {
      [`& .${chipClasses$1.avatar}`]: styles2[`avatar${capitalize$1(size)}`]
    }, {
      [`& .${chipClasses$1.avatar}`]: styles2[`avatarColor${capitalize$1(color2)}`]
    }, {
      [`& .${chipClasses$1.icon}`]: styles2.icon
    }, {
      [`& .${chipClasses$1.icon}`]: styles2[`icon${capitalize$1(size)}`]
    }, {
      [`& .${chipClasses$1.icon}`]: styles2[`iconColor${capitalize$1(iconColor)}`]
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2.deleteIcon
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize$1(size)}`]
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIconColor${capitalize$1(color2)}`]
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize$1(variant)}Color${capitalize$1(color2)}`]
    }, styles2.root, styles2[`size${capitalize$1(size)}`], styles2[`color${capitalize$1(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize$1(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize$1(color2)}`], styles2[variant], styles2[`${variant}${capitalize$1(color2)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const textColor = theme2.palette.mode === "light" ? theme2.palette.grey[700] : theme2.palette.grey[300];
  return _extends$2({
    maxWidth: "100%",
    fontFamily: theme2.typography.fontFamily,
    fontSize: theme2.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    color: (theme2.vars || theme2).palette.text.primary,
    backgroundColor: (theme2.vars || theme2).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: theme2.transitions.create(["background-color", "box-shadow"]),
    // reset cursor explicitly in case ButtonBase is used
    cursor: "unset",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${chipClasses$1.disabled}`]: {
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${chipClasses$1.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: theme2.vars ? theme2.vars.palette.Chip.defaultAvatarColor : textColor,
      fontSize: theme2.typography.pxToRem(12)
    },
    [`& .${chipClasses$1.avatarColorPrimary}`]: {
      color: (theme2.vars || theme2).palette.primary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    },
    [`& .${chipClasses$1.avatarColorSecondary}`]: {
      color: (theme2.vars || theme2).palette.secondary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.secondary.dark
    },
    [`& .${chipClasses$1.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: theme2.typography.pxToRem(10)
    },
    [`& .${chipClasses$1.icon}`]: _extends$2({
      marginLeft: 5,
      marginRight: -6
    }, ownerState.size === "small" && {
      fontSize: 18,
      marginLeft: 4,
      marginRight: -4
    }, ownerState.iconColor === ownerState.color && _extends$2({
      color: theme2.vars ? theme2.vars.palette.Chip.defaultIconColor : textColor
    }, ownerState.color !== "default" && {
      color: "inherit"
    })),
    [`& .${chipClasses$1.deleteIcon}`]: _extends$2({
      WebkitTapHighlightColor: "transparent",
      color: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / 0.26)` : alpha(theme2.palette.text.primary, 0.26),
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / 0.4)` : alpha(theme2.palette.text.primary, 0.4)
      }
    }, ownerState.size === "small" && {
      fontSize: 16,
      marginRight: 4,
      marginLeft: -4
    }, ownerState.color !== "default" && {
      color: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha(theme2.palette[ownerState.color].contrastText, 0.7),
      "&:hover, &:active": {
        color: (theme2.vars || theme2).palette[ownerState.color].contrastText
      }
    })
  }, ownerState.size === "small" && {
    height: 24
  }, ownerState.color !== "default" && {
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main,
    color: (theme2.vars || theme2).palette[ownerState.color].contrastText
  }, ownerState.onDelete && {
    [`&.${chipClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.selectedChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.action.selected, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  }, ownerState.onDelete && ownerState.color !== "default" && {
    [`&.${chipClasses$1.focusVisible}`]: {
      backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark
    }
  });
}, ({
  theme: theme2,
  ownerState
}) => _extends$2({}, ownerState.clickable && {
  userSelect: "none",
  WebkitTapHighlightColor: "transparent",
  cursor: "pointer",
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.selectedChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.action.selected, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity)
  },
  [`&.${chipClasses$1.focusVisible}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.selectedChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.action.selected, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
  },
  "&:active": {
    boxShadow: (theme2.vars || theme2).shadows[1]
  }
}, ownerState.clickable && ownerState.color !== "default" && {
  [`&:hover, &.${chipClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark
  }
}), ({
  theme: theme2,
  ownerState
}) => _extends$2({}, ownerState.variant === "outlined" && {
  backgroundColor: "transparent",
  border: theme2.vars ? `1px solid ${theme2.vars.palette.Chip.defaultBorder}` : `1px solid ${theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[700]}`,
  [`&.${chipClasses$1.clickable}:hover`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.hover
  },
  [`&.${chipClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`& .${chipClasses$1.avatar}`]: {
    marginLeft: 4
  },
  [`& .${chipClasses$1.avatarSmall}`]: {
    marginLeft: 2
  },
  [`& .${chipClasses$1.icon}`]: {
    marginLeft: 4
  },
  [`& .${chipClasses$1.iconSmall}`]: {
    marginLeft: 2
  },
  [`& .${chipClasses$1.deleteIcon}`]: {
    marginRight: 5
  },
  [`& .${chipClasses$1.deleteIconSmall}`]: {
    marginRight: 3
  }
}, ownerState.variant === "outlined" && ownerState.color !== "default" && {
  color: (theme2.vars || theme2).palette[ownerState.color].main,
  border: `1px solid ${theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme2.palette[ownerState.color].main, 0.7)}`,
  [`&.${chipClasses$1.clickable}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity)
  },
  [`&.${chipClasses$1.focusVisible}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.focusOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.focusOpacity)
  },
  [`& .${chipClasses$1.deleteIcon}`]: {
    color: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme2.palette[ownerState.color].main, 0.7),
    "&:hover, &:active": {
      color: (theme2.vars || theme2).palette[ownerState.color].main
    }
  }
}));
const ChipLabel = styled$1("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      size
    } = ownerState;
    return [styles2.label, styles2[`label${capitalize$1(size)}`]];
  }
})(({
  ownerState
}) => _extends$2({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap"
}, ownerState.size === "small" && {
  paddingLeft: 8,
  paddingRight: 8
}));
function isDeleteKeyboardEvent(keyboardEvent) {
  return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
}
const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChip"
  });
  const {
    avatar: avatarProp,
    className,
    clickable: clickableProp,
    color: color2 = "default",
    component: ComponentProp,
    deleteIcon: deleteIconProp,
    disabled = false,
    icon: iconProp,
    label,
    onClick,
    onDelete,
    onKeyDown,
    onKeyUp,
    size = "medium",
    variant = "filled",
    tabIndex,
    skipFocusWhenDisabled = false
    // TODO v6: Rename to `focusableWhenDisabled`.
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2b);
  const chipRef = reactExports.useRef(null);
  const handleRef = useForkRef(chipRef, ref);
  const handleDeleteIconClick = (event) => {
    event.stopPropagation();
    if (onDelete) {
      onDelete(event);
    }
  };
  const handleKeyDown2 = (event) => {
    if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleKeyUp = (event) => {
    if (event.currentTarget === event.target) {
      if (onDelete && isDeleteKeyboardEvent(event)) {
        onDelete(event);
      } else if (event.key === "Escape" && chipRef.current) {
        chipRef.current.blur();
      }
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  };
  const clickable = clickableProp !== false && onClick ? true : clickableProp;
  const component = clickable || onDelete ? ButtonBase$1 : ComponentProp || "div";
  const ownerState = _extends$2({}, props, {
    component,
    disabled,
    size,
    color: color2,
    iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
    onDelete: !!onDelete,
    clickable,
    variant
  });
  const classes = useUtilityClasses$1K(ownerState);
  const moreProps = component === ButtonBase$1 ? _extends$2({
    component: ComponentProp || "div",
    focusVisibleClassName: classes.focusVisible
  }, onDelete && {
    disableRipple: true
  }) : {};
  let deleteIcon = null;
  if (onDelete) {
    deleteIcon = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
      className: clsx(deleteIconProp.props.className, classes.deleteIcon),
      onClick: handleDeleteIconClick
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CancelIcon, {
      className: clsx(classes.deleteIcon),
      onClick: handleDeleteIconClick
    });
  }
  let avatar = null;
  if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
    avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
      className: clsx(classes.avatar, avatarProp.props.className)
    });
  }
  let icon = null;
  if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
    icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
      className: clsx(classes.icon, iconProp.props.className)
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ChipRoot, _extends$2({
    as: component,
    className: clsx(classes.root, className),
    disabled: clickable && disabled ? true : void 0,
    onClick,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    ref: handleRef,
    tabIndex: skipFocusWhenDisabled && disabled ? -1 : tabIndex,
    ownerState
  }, moreProps, other, {
    children: [avatar || icon, /* @__PURE__ */ jsxRuntimeExports.jsx(ChipLabel, {
      className: clsx(classes.label),
      ownerState,
      children: label
    }), deleteIcon]
  }));
});
const Chip$1 = Chip;
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state) => {
    acc[state] = props[state];
    if (muiFormControl) {
      if (typeof props[state] === "undefined") {
        acc[state] = muiFormControl[state];
      }
    }
    return acc;
  }, {});
}
const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
const FormControlContext$1 = FormControlContext;
function useFormControl() {
  return reactExports.useContext(FormControlContext$1);
}
function GlobalStyles(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends$2({}, props, {
    defaultTheme: defaultTheme$2,
    themeId: THEME_ID
  }));
}
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function isAdornedStart(obj) {
  return obj.startAdornment;
}
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass("MuiInputBase", slot);
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
const inputBaseClasses$1 = inputBaseClasses;
const _excluded$2a = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
const rootOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
};
const inputOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
};
const useUtilityClasses$1J = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size,
    startAdornment,
    type: type2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size && size !== "medium" && `size${capitalize$1(size)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type2 === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes);
};
const InputBaseRoot = styled$1("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$2({}, theme2.typography.body1, {
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled,
    cursor: "default"
  }
}, ownerState.multiline && _extends$2({
  padding: "4px 0 5px"
}, ownerState.size === "small" && {
  paddingTop: 1
}), ownerState.fullWidth && {
  width: "100%"
}));
const InputBaseComponent = styled$1("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => {
  const light2 = theme2.palette.mode === "light";
  const placeholder = _extends$2({
    color: "currentColor"
  }, theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  }, {
    transition: theme2.transitions.create("opacity", {
      duration: theme2.transitions.duration.shorter
    })
  });
  const placeholderHidden = {
    opacity: "0 !important"
  };
  const placeholderVisible = theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return _extends$2({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    // Fix IE11 width issue
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    // Firefox 19+
    "&:-ms-input-placeholder": placeholder,
    // IE11
    "&::-ms-input-placeholder": placeholder,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      // Firefox 19+
      "&:-ms-input-placeholder": placeholderHidden,
      // IE11
      "&::-ms-input-placeholder": placeholderHidden,
      // Edge
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      // Firefox 19+
      "&:focus:-ms-input-placeholder": placeholderVisible,
      // IE11
      "&:focus::-ms-input-placeholder": placeholderVisible
      // Edge
    },
    [`&.${inputBaseClasses$1.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme2.vars || theme2).palette.text.disabled
      // Fix opacity Safari bug
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, ownerState.size === "small" && {
    paddingTop: 1
  }, ownerState.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, ownerState.type === "search" && {
    // Improve type search style.
    MozAppearance: "textfield"
  });
});
const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
});
const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
  var _slotProps$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiInputBase"
  });
  const {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    fullWidth = false,
    id: id2,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onClick,
    onFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows: rows2,
    slotProps = {},
    slots = {},
    startAdornment,
    type: type2 = "text",
    value: valueProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2a);
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef();
  const handleInputRefWarning = reactExports.useCallback((instance) => {
  }, []);
  const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = reactExports.useState(false);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  reactExports.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = reactExports.useCallback((obj) => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect$1(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = (event) => {
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  const handleChange = (event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(formatMuiErrorMessage(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }
    if (onChange) {
      onChange(event, ...args);
    }
  };
  reactExports.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  const handleClick = (event) => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === "input") {
    if (rows2) {
      inputProps = _extends$2({
        type: void 0,
        minRows: rows2,
        maxRows: rows2
      }, inputProps);
    } else {
      inputProps = _extends$2({
        type: void 0,
        maxRows,
        minRows
      }, inputProps);
    }
    InputComponent = TextareaAutosize;
  }
  const handleAutoFill = (event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = _extends$2({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type: type2
  });
  const classes = useUtilityClasses$1J(ownerState);
  const Root = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input3 = slots.input || components.Input || InputBaseComponent;
  inputProps = _extends$2({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$2({}, rootProps, !isHostComponent(Root) && {
      ownerState: _extends$2({}, ownerState, rootProps.ownerState)
    }, {
      ref,
      onClick: handleClick
    }, other, {
      className: clsx(classes.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
      children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input3, _extends$2({
          ownerState,
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id: id2,
          onAnimationStart: handleAutoFill,
          name,
          placeholder,
          readOnly,
          required: fcs.required,
          rows: rows2,
          value,
          onKeyDown,
          onKeyUp,
          type: type2
        }, inputProps, !isHostComponent(Input3) && {
          as: InputComponent,
          ownerState: _extends$2({}, ownerState, inputProps.ownerState)
        }, {
          ref: handleInputRef,
          className: clsx(classes.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        }))
      }), endAdornment, renderSuffix ? renderSuffix(_extends$2({}, fcs, {
        startAdornment
      })) : null]
    }))]
  });
});
const InputBase$1 = InputBase;
function getInputUtilityClass(slot) {
  return generateUtilityClass("MuiInput", slot);
}
const inputClasses = _extends$2({}, inputBaseClasses$1, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
const inputClasses$1 = inputClasses;
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass("MuiOutlinedInput", slot);
}
const outlinedInputClasses = _extends$2({}, inputBaseClasses$1, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
const outlinedInputClasses$1 = outlinedInputClasses;
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass("MuiFilledInput", slot);
}
const filledInputClasses = _extends$2({}, inputBaseClasses$1, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
const filledInputClasses$1 = filledInputClasses;
const ArrowDropDownIcon$1 = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
function getAutocompleteUtilityClass(slot) {
  return generateUtilityClass("MuiAutocomplete", slot);
}
const autocompleteClasses = generateUtilityClasses("MuiAutocomplete", ["root", "expanded", "fullWidth", "focused", "focusVisible", "tag", "tagSizeSmall", "tagSizeMedium", "hasPopupIcon", "hasClearIcon", "inputRoot", "input", "inputFocused", "endAdornment", "clearIndicator", "popupIndicator", "popupIndicatorOpen", "popper", "popperDisablePortal", "paper", "listbox", "loading", "noOptions", "option", "groupLabel", "groupUl"]);
const autocompleteClasses$1 = autocompleteClasses;
var _ClearIcon, _ArrowDropDownIcon;
const _excluded$29 = ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "className", "clearIcon", "clearOnBlur", "clearOnEscape", "clearText", "closeText", "componentsProps", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionLabel", "isOptionEqualToValue", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "readOnly", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "slotProps", "value"], _excluded2$h = ["ref"];
const useUtilityClasses$1I = (ownerState) => {
  const {
    classes,
    disablePortal,
    expanded,
    focused,
    fullWidth,
    hasClearIcon,
    hasPopupIcon,
    inputFocused,
    popupOpen,
    size
  } = ownerState;
  const slots = {
    root: ["root", expanded && "expanded", focused && "focused", fullWidth && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
    inputRoot: ["inputRoot"],
    input: ["input", inputFocused && "inputFocused"],
    tag: ["tag", `tagSize${capitalize$1(size)}`],
    endAdornment: ["endAdornment"],
    clearIndicator: ["clearIndicator"],
    popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
    popper: ["popper", disablePortal && "popperDisablePortal"],
    paper: ["paper"],
    listbox: ["listbox"],
    loading: ["loading"],
    noOptions: ["noOptions"],
    option: ["option"],
    groupLabel: ["groupLabel"],
    groupUl: ["groupUl"]
  };
  return composeClasses(slots, getAutocompleteUtilityClass, classes);
};
const AutocompleteRoot = styled$1("div", {
  name: "MuiAutocomplete",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      fullWidth,
      hasClearIcon,
      hasPopupIcon,
      inputFocused,
      size
    } = ownerState;
    return [{
      [`& .${autocompleteClasses$1.tag}`]: styles2.tag
    }, {
      [`& .${autocompleteClasses$1.tag}`]: styles2[`tagSize${capitalize$1(size)}`]
    }, {
      [`& .${autocompleteClasses$1.inputRoot}`]: styles2.inputRoot
    }, {
      [`& .${autocompleteClasses$1.input}`]: styles2.input
    }, {
      [`& .${autocompleteClasses$1.input}`]: inputFocused && styles2.inputFocused
    }, styles2.root, fullWidth && styles2.fullWidth, hasPopupIcon && styles2.hasPopupIcon, hasClearIcon && styles2.hasClearIcon];
  }
})(({
  ownerState
}) => _extends$2({
  [`&.${autocompleteClasses$1.focused} .${autocompleteClasses$1.clearIndicator}`]: {
    visibility: "visible"
  },
  /* Avoid double tap issue on iOS */
  "@media (pointer: fine)": {
    [`&:hover .${autocompleteClasses$1.clearIndicator}`]: {
      visibility: "visible"
    }
  }
}, ownerState.fullWidth && {
  width: "100%"
}, {
  [`& .${autocompleteClasses$1.tag}`]: _extends$2({
    margin: 3,
    maxWidth: "calc(100% - 6px)"
  }, ownerState.size === "small" && {
    margin: 2,
    maxWidth: "calc(100% - 4px)"
  }),
  [`& .${autocompleteClasses$1.inputRoot}`]: {
    flexWrap: "wrap",
    [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 26 + 4
    },
    [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 52 + 4
    },
    [`& .${autocompleteClasses$1.input}`]: {
      width: 0,
      minWidth: 30
    }
  },
  [`& .${inputClasses$1.root}`]: {
    paddingBottom: 1,
    "& .MuiInput-input": {
      padding: "4px 4px 4px 0px"
    }
  },
  [`& .${inputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
    [`& .${inputClasses$1.input}`]: {
      padding: "2px 4px 3px 0"
    }
  },
  [`& .${outlinedInputClasses$1.root}`]: {
    padding: 9,
    [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${autocompleteClasses$1.input}`]: {
      padding: "7.5px 4px 7.5px 5px"
    },
    [`& .${autocompleteClasses$1.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${outlinedInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
    // Don't specify paddingRight, as it overrides the default value set when there is only
    // one of the popup or clear icon as the specificity is equal so the latter one wins
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 6,
    [`& .${autocompleteClasses$1.input}`]: {
      padding: "2.5px 4px 2.5px 8px"
    }
  },
  [`& .${filledInputClasses$1.root}`]: {
    paddingTop: 19,
    paddingLeft: 8,
    [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${filledInputClasses$1.input}`]: {
      padding: "7px 4px"
    },
    [`& .${autocompleteClasses$1.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
    paddingBottom: 1,
    [`& .${filledInputClasses$1.input}`]: {
      padding: "2.5px 4px"
    }
  },
  [`& .${inputBaseClasses$1.hiddenLabel}`]: {
    paddingTop: 8
  },
  [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.hiddenLabel}`]: {
    paddingTop: 0,
    paddingBottom: 0,
    [`& .${autocompleteClasses$1.input}`]: {
      paddingTop: 16,
      paddingBottom: 17
    }
  },
  [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.hiddenLabel}.${inputBaseClasses$1.sizeSmall}`]: {
    [`& .${autocompleteClasses$1.input}`]: {
      paddingTop: 8,
      paddingBottom: 9
    }
  },
  [`& .${autocompleteClasses$1.input}`]: _extends$2({
    flexGrow: 1,
    textOverflow: "ellipsis",
    opacity: 0
  }, ownerState.inputFocused && {
    opacity: 1
  })
}));
const AutocompleteEndAdornment = styled$1("div", {
  name: "MuiAutocomplete",
  slot: "EndAdornment",
  overridesResolver: (props, styles2) => styles2.endAdornment
})({
  // We use a position absolute to support wrapping tags.
  position: "absolute",
  right: 0,
  top: "calc(50% - 14px)"
  // Center vertically
});
const AutocompleteClearIndicator = styled$1(IconButton$1, {
  name: "MuiAutocomplete",
  slot: "ClearIndicator",
  overridesResolver: (props, styles2) => styles2.clearIndicator
})({
  marginRight: -2,
  padding: 4,
  visibility: "hidden"
});
const AutocompletePopupIndicator = styled$1(IconButton$1, {
  name: "MuiAutocomplete",
  slot: "PopupIndicator",
  overridesResolver: ({
    ownerState
  }, styles2) => _extends$2({}, styles2.popupIndicator, ownerState.popupOpen && styles2.popupIndicatorOpen)
})(({
  ownerState
}) => _extends$2({
  padding: 2,
  marginRight: -2
}, ownerState.popupOpen && {
  transform: "rotate(180deg)"
}));
const AutocompletePopper = styled$1(MuiPopper, {
  name: "MuiAutocomplete",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${autocompleteClasses$1.option}`]: styles2.option
    }, styles2.popper, ownerState.disablePortal && styles2.popperDisablePortal];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  zIndex: (theme2.vars || theme2).zIndex.modal
}, ownerState.disablePortal && {
  position: "absolute"
}));
const AutocompletePaper = styled$1(MuiPaper, {
  name: "MuiAutocomplete",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})(({
  theme: theme2
}) => _extends$2({}, theme2.typography.body1, {
  overflow: "auto"
}));
const AutocompleteLoading = styled$1("div", {
  name: "MuiAutocomplete",
  slot: "Loading",
  overridesResolver: (props, styles2) => styles2.loading
})(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteNoOptions = styled$1("div", {
  name: "MuiAutocomplete",
  slot: "NoOptions",
  overridesResolver: (props, styles2) => styles2.noOptions
})(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteListbox = styled$1("div", {
  name: "MuiAutocomplete",
  slot: "Listbox",
  overridesResolver: (props, styles2) => styles2.listbox
})(({
  theme: theme2
}) => ({
  listStyle: "none",
  margin: 0,
  padding: "8px 0",
  maxHeight: "40vh",
  overflow: "auto",
  position: "relative",
  [`& .${autocompleteClasses$1.option}`]: {
    minHeight: 48,
    display: "flex",
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "center",
    cursor: "pointer",
    paddingTop: 6,
    boxSizing: "border-box",
    outline: "0",
    WebkitTapHighlightColor: "transparent",
    paddingBottom: 6,
    paddingLeft: 16,
    paddingRight: 16,
    [theme2.breakpoints.up("sm")]: {
      minHeight: "auto"
    },
    [`&.${autocompleteClasses$1.focused}`]: {
      backgroundColor: (theme2.vars || theme2).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    '&[aria-disabled="true"]': {
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`&.${autocompleteClasses$1.focusVisible}`]: {
      backgroundColor: (theme2.vars || theme2).palette.action.focus
    },
    '&[aria-selected="true"]': {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
      [`&.${autocompleteClasses$1.focused}`]: {
        backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme2.vars || theme2).palette.action.selected
        }
      },
      [`&.${autocompleteClasses$1.focusVisible}`]: {
        backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
      }
    }
  }
}));
const AutocompleteGroupLabel = styled$1(ListSubheader$1, {
  name: "MuiAutocomplete",
  slot: "GroupLabel",
  overridesResolver: (props, styles2) => styles2.groupLabel
})(({
  theme: theme2
}) => ({
  backgroundColor: (theme2.vars || theme2).palette.background.paper,
  top: -8
}));
const AutocompleteGroupUl = styled$1("ul", {
  name: "MuiAutocomplete",
  slot: "GroupUl",
  overridesResolver: (props, styles2) => styles2.groupUl
})({
  padding: 0,
  [`& .${autocompleteClasses$1.option}`]: {
    paddingLeft: 24
  }
});
const Autocomplete = /* @__PURE__ */ reactExports.forwardRef(function Autocomplete2(inProps, ref) {
  var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
  const props = useThemeProps({
    props: inProps,
    name: "MuiAutocomplete"
  });
  const {
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    ChipProps,
    className,
    clearIcon = _ClearIcon || (_ClearIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ClearIcon$1, {
      fontSize: "small"
    })),
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    clearText = "Clear",
    closeText = "Close",
    componentsProps = {},
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled = false,
    disabledItemsFocusable = false,
    disableListWrap = false,
    disablePortal = false,
    filterSelectedOptions = false,
    forcePopupIcon = "auto",
    freeSolo = false,
    fullWidth = false,
    getLimitTagsText = (more) => `+${more}`,
    getOptionLabel: getOptionLabelProp,
    groupBy: groupBy2,
    handleHomeEndKeys = !props.freeSolo,
    includeInputInList = false,
    limitTags = -1,
    ListboxComponent = "ul",
    ListboxProps,
    loading = false,
    loadingText = "Loading…",
    multiple = false,
    noOptionsText = "No options",
    openOnFocus = false,
    openText = "Open",
    PaperComponent = MuiPaper,
    PopperComponent = MuiPopper,
    popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDownIcon$1, {})),
    readOnly = false,
    renderGroup: renderGroupProp,
    renderInput,
    renderOption: renderOptionProp,
    renderTags,
    selectOnFocus = !props.freeSolo,
    size = "medium",
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$29);
  const {
    getRootProps,
    getInputProps,
    getInputLabelProps,
    getPopupIndicatorProps,
    getClearProps,
    getTagProps,
    getListboxProps,
    getOptionProps,
    value,
    dirty,
    expanded,
    id: id2,
    popupOpen,
    focused,
    focusedTag,
    anchorEl,
    setAnchorEl,
    inputValue,
    groupedOptions
  } = useAutocomplete(_extends$2({}, props, {
    componentName: "Autocomplete"
  }));
  const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
  const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
  const {
    onMouseDown: handleInputMouseDown
  } = getInputProps();
  const {
    ref: externalListboxRef
  } = ListboxProps != null ? ListboxProps : {};
  const _getListboxProps = getListboxProps(), {
    ref: listboxRef
  } = _getListboxProps, otherListboxProps = _objectWithoutPropertiesLoose$1(_getListboxProps, _excluded2$h);
  const combinedListboxRef = useForkRef(listboxRef, externalListboxRef);
  const defaultGetOptionLabel2 = (option) => {
    var _option$label;
    return (_option$label = option.label) != null ? _option$label : option;
  };
  const getOptionLabel = getOptionLabelProp || defaultGetOptionLabel2;
  const ownerState = _extends$2({}, props, {
    disablePortal,
    expanded,
    focused,
    fullWidth,
    getOptionLabel,
    hasClearIcon,
    hasPopupIcon,
    inputFocused: focusedTag === -1,
    popupOpen,
    size
  });
  const classes = useUtilityClasses$1I(ownerState);
  let startAdornment;
  if (multiple && value.length > 0) {
    const getCustomizedTagProps = (params) => _extends$2({
      className: classes.tag,
      disabled
    }, getTagProps(params));
    if (renderTags) {
      startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
    } else {
      startAdornment = value.map((option, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$1, _extends$2({
        label: getOptionLabel(option),
        size
      }, getCustomizedTagProps({
        index: index2
      }), ChipProps)));
    }
  }
  if (limitTags > -1 && Array.isArray(startAdornment)) {
    const more = startAdornment.length - limitTags;
    if (!focused && more > 0) {
      startAdornment = startAdornment.splice(0, limitTags);
      startAdornment.push(/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.tag,
        children: getLimitTagsText(more)
      }, startAdornment.length));
    }
  }
  const defaultRenderGroup = (params) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupLabel, {
      className: classes.groupLabel,
      ownerState,
      component: "div",
      children: params.group
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteGroupUl, {
      className: classes.groupUl,
      ownerState,
      children: params.children
    })]
  }, params.key);
  const renderGroup = renderGroupProp || defaultRenderGroup;
  const defaultRenderOption = (props2, option) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", _extends$2({}, props2, {
    children: getOptionLabel(option)
  }));
  const renderOption = renderOptionProp || defaultRenderOption;
  const renderListOption = (option, index2) => {
    const optionProps = getOptionProps({
      option,
      index: index2
    });
    return renderOption(_extends$2({}, optionProps, {
      className: classes.option
    }), option, {
      selected: optionProps["aria-selected"],
      index: index2,
      inputValue
    }, ownerState);
  };
  const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
  const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
  const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
  const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteRoot, _extends$2({
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, getRootProps(other), {
      children: renderInput({
        id: id2,
        disabled,
        fullWidth: true,
        size: size === "small" ? "small" : void 0,
        InputLabelProps: getInputLabelProps(),
        InputProps: _extends$2({
          ref: setAnchorEl,
          className: classes.inputRoot,
          startAdornment,
          onClick: (event) => {
            if (event.target === event.currentTarget) {
              handleInputMouseDown(event);
            }
          }
        }, (hasClearIcon || hasPopupIcon) && {
          endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompleteEndAdornment, {
            className: classes.endAdornment,
            ownerState,
            children: [hasClearIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteClearIndicator, _extends$2({}, getClearProps(), {
              "aria-label": clearText,
              title: clearText,
              ownerState
            }, clearIndicatorSlotProps, {
              className: clsx(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
              children: clearIcon
            })) : null, hasPopupIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopupIndicator, _extends$2({}, getPopupIndicatorProps(), {
              disabled,
              "aria-label": popupOpen ? closeText : openText,
              title: popupOpen ? closeText : openText,
              ownerState
            }, popupIndicatorSlotProps, {
              className: clsx(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
              children: popupIcon
            })) : null]
          })
        }),
        inputProps: _extends$2({
          className: classes.input,
          disabled,
          readOnly
        }, getInputProps())
      })
    })), anchorEl ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompletePopper, _extends$2({
      as: PopperComponent,
      disablePortal,
      style: {
        width: anchorEl ? anchorEl.clientWidth : null
      },
      ownerState,
      role: "presentation",
      anchorEl,
      open: popupOpen
    }, popperSlotProps, {
      className: clsx(classes.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AutocompletePaper, _extends$2({
        ownerState,
        as: PaperComponent
      }, paperSlotProps, {
        className: clsx(classes.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
        children: [loading && groupedOptions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteLoading, {
          className: classes.loading,
          ownerState,
          children: loadingText
        }) : null, groupedOptions.length === 0 && !freeSolo && !loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteNoOptions, {
          className: classes.noOptions,
          ownerState,
          role: "presentation",
          onMouseDown: (event) => {
            event.preventDefault();
          },
          children: noOptionsText
        }) : null, groupedOptions.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AutocompleteListbox, _extends$2({
          as: ListboxComponent,
          className: classes.listbox,
          ownerState
        }, otherListboxProps, ListboxProps, {
          ref: combinedListboxRef,
          children: groupedOptions.map((option, index2) => {
            if (groupBy2) {
              return renderGroup({
                key: option.key,
                group: option.group,
                children: option.options.map((option2, index22) => renderListOption(option2, option.index + index22))
              });
            }
            return renderListOption(option, index2);
          })
        })) : null]
      }))
    })) : null]
  });
});
const Autocomplete$1 = Autocomplete;
const Person = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}), "Person");
function getAvatarUtilityClass(slot) {
  return generateUtilityClass("MuiAvatar", slot);
}
generateUtilityClasses("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const _excluded$28 = ["alt", "children", "className", "component", "imgProps", "sizes", "src", "srcSet", "variant"];
const useUtilityClasses$1H = (ownerState) => {
  const {
    classes,
    variant,
    colorDefault
  } = ownerState;
  const slots = {
    root: ["root", variant, colorDefault && "colorDefault"],
    img: ["img"],
    fallback: ["fallback"]
  };
  return composeClasses(slots, getAvatarUtilityClass, classes);
};
const AvatarRoot = styled$1("div", {
  name: "MuiAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.colorDefault && styles2.colorDefault];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  position: "relative",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  width: 40,
  height: 40,
  fontFamily: theme2.typography.fontFamily,
  fontSize: theme2.typography.pxToRem(20),
  lineHeight: 1,
  borderRadius: "50%",
  overflow: "hidden",
  userSelect: "none"
}, ownerState.variant === "rounded" && {
  borderRadius: (theme2.vars || theme2).shape.borderRadius
}, ownerState.variant === "square" && {
  borderRadius: 0
}, ownerState.colorDefault && _extends$2({
  color: (theme2.vars || theme2).palette.background.default
}, theme2.vars ? {
  backgroundColor: theme2.vars.palette.Avatar.defaultBg
} : {
  backgroundColor: theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[600]
})));
const AvatarImg = styled$1("img", {
  name: "MuiAvatar",
  slot: "Img",
  overridesResolver: (props, styles2) => styles2.img
})({
  width: "100%",
  height: "100%",
  textAlign: "center",
  // Handle non-square image. The property isn't supported by IE11.
  objectFit: "cover",
  // Hide alt text.
  color: "transparent",
  // Hide the image broken icon, only works on Chrome.
  textIndent: 1e4
});
const AvatarFallback = styled$1(Person, {
  name: "MuiAvatar",
  slot: "Fallback",
  overridesResolver: (props, styles2) => styles2.fallback
})({
  width: "75%",
  height: "75%"
});
function useLoaded({
  crossOrigin,
  referrerPolicy,
  src: src2,
  srcSet
}) {
  const [loaded, setLoaded] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!src2 && !srcSet) {
      return void 0;
    }
    setLoaded(false);
    let active = true;
    const image2 = new Image();
    image2.onload = () => {
      if (!active) {
        return;
      }
      setLoaded("loaded");
    };
    image2.onerror = () => {
      if (!active) {
        return;
      }
      setLoaded("error");
    };
    image2.crossOrigin = crossOrigin;
    image2.referrerPolicy = referrerPolicy;
    image2.src = src2;
    if (srcSet) {
      image2.srcset = srcSet;
    }
    return () => {
      active = false;
    };
  }, [crossOrigin, referrerPolicy, src2, srcSet]);
  return loaded;
}
const Avatar = /* @__PURE__ */ reactExports.forwardRef(function Avatar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiAvatar"
  });
  const {
    alt,
    children: childrenProp,
    className,
    component = "div",
    imgProps,
    sizes,
    src: src2,
    srcSet,
    variant = "circular"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$28);
  let children = null;
  const loaded = useLoaded(_extends$2({}, imgProps, {
    src: src2,
    srcSet
  }));
  const hasImg = src2 || srcSet;
  const hasImgNotFailing = hasImg && loaded !== "error";
  const ownerState = _extends$2({}, props, {
    colorDefault: !hasImgNotFailing,
    component,
    variant
  });
  const classes = useUtilityClasses$1H(ownerState);
  if (hasImgNotFailing) {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarImg, _extends$2({
      alt,
      srcSet,
      src: src2,
      sizes,
      ownerState,
      className: classes.img
    }, imgProps));
  } else if (childrenProp != null) {
    children = childrenProp;
  } else if (hasImg && alt) {
    children = alt[0];
  } else {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, {
      ownerState,
      className: classes.fallback
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarRoot, _extends$2({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other, {
    children
  }));
});
const Avatar$1 = Avatar;
const _excluded$27 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$2 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
  const theme2 = useTheme();
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$27);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$2({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$2({
        style: _extends$2({
          opacity: 0,
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$2[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
const Fade$1 = Fade;
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$26 = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
const useUtilityClasses$1G = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled$1("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})(({
  ownerState
}) => _extends$2({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, ownerState.invisible && {
  backgroundColor: "transparent"
}));
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
  var _slotProps$root, _ref, _slots$root;
  const props = useThemeProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    components = {},
    componentsProps = {},
    invisible = false,
    open: open2,
    slotProps = {},
    slots = {},
    TransitionComponent = Fade$1,
    transitionDuration
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$26);
  const ownerState = _extends$2({}, props, {
    component,
    invisible
  });
  const classes = useUtilityClasses$1G(ownerState);
  const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$2({
    in: open2,
    timeout: transitionDuration
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$2({
      "aria-hidden": true
    }, rootSlotProps, {
      as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
      className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
      ownerState: _extends$2({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
      classes,
      ref,
      children
    }))
  }));
});
const Backdrop$1 = Backdrop;
function getBadgeUtilityClass(slot) {
  return generateUtilityClass("MuiBadge", slot);
}
const badgeClasses = generateUtilityClasses("MuiBadge", [
  "root",
  "badge",
  "dot",
  "standard",
  "anchorOriginTopRight",
  "anchorOriginBottomRight",
  "anchorOriginTopLeft",
  "anchorOriginBottomLeft",
  "invisible",
  "colorError",
  "colorInfo",
  "colorPrimary",
  "colorSecondary",
  "colorSuccess",
  "colorWarning",
  "overlapRectangular",
  "overlapCircular",
  // TODO: v6 remove the overlap value from these class keys
  "anchorOriginTopLeftCircular",
  "anchorOriginTopLeftRectangular",
  "anchorOriginTopRightCircular",
  "anchorOriginTopRightRectangular",
  "anchorOriginBottomLeftCircular",
  "anchorOriginBottomLeftRectangular",
  "anchorOriginBottomRightCircular",
  "anchorOriginBottomRightRectangular"
]);
const badgeClasses$1 = badgeClasses;
const _excluded$25 = ["anchorOrigin", "className", "classes", "component", "components", "componentsProps", "children", "overlap", "color", "invisible", "max", "badgeContent", "slots", "slotProps", "showZero", "variant"];
const RADIUS_STANDARD = 10;
const RADIUS_DOT = 4;
const useUtilityClasses$1F = (ownerState) => {
  const {
    color: color2,
    anchorOrigin,
    invisible,
    overlap,
    variant,
    classes = {}
  } = ownerState;
  const slots = {
    root: ["root"],
    badge: ["badge", variant, invisible && "invisible", `anchorOrigin${capitalize$1(anchorOrigin.vertical)}${capitalize$1(anchorOrigin.horizontal)}`, `anchorOrigin${capitalize$1(anchorOrigin.vertical)}${capitalize$1(anchorOrigin.horizontal)}${capitalize$1(overlap)}`, `overlap${capitalize$1(overlap)}`, color2 !== "default" && `color${capitalize$1(color2)}`]
  };
  return composeClasses(slots, getBadgeUtilityClass, classes);
};
const BadgeRoot = styled$1("span", {
  name: "MuiBadge",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  position: "relative",
  display: "inline-flex",
  // For correct alignment with the text.
  verticalAlign: "middle",
  flexShrink: 0
});
const BadgeBadge = styled$1("span", {
  name: "MuiBadge",
  slot: "Badge",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.badge, styles2[ownerState.variant], styles2[`anchorOrigin${capitalize$1(ownerState.anchorOrigin.vertical)}${capitalize$1(ownerState.anchorOrigin.horizontal)}${capitalize$1(ownerState.overlap)}`], ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`], ownerState.invisible && styles2.invisible];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "center",
  alignContent: "center",
  alignItems: "center",
  position: "absolute",
  boxSizing: "border-box",
  fontFamily: theme2.typography.fontFamily,
  fontWeight: theme2.typography.fontWeightMedium,
  fontSize: theme2.typography.pxToRem(12),
  minWidth: RADIUS_STANDARD * 2,
  lineHeight: 1,
  padding: "0 6px",
  height: RADIUS_STANDARD * 2,
  borderRadius: RADIUS_STANDARD,
  zIndex: 1,
  // Render the badge on top of potential ripples.
  transition: theme2.transitions.create("transform", {
    easing: theme2.transitions.easing.easeInOut,
    duration: theme2.transitions.duration.enteringScreen
  })
}, ownerState.color !== "default" && {
  backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main,
  color: (theme2.vars || theme2).palette[ownerState.color].contrastText
}, ownerState.variant === "dot" && {
  borderRadius: RADIUS_DOT,
  height: RADIUS_DOT * 2,
  minWidth: RADIUS_DOT * 2,
  padding: 0
}, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular" && {
  top: 0,
  right: 0,
  transform: "scale(1) translate(50%, -50%)",
  transformOrigin: "100% 0%",
  [`&.${badgeClasses$1.invisible}`]: {
    transform: "scale(0) translate(50%, -50%)"
  }
}, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular" && {
  bottom: 0,
  right: 0,
  transform: "scale(1) translate(50%, 50%)",
  transformOrigin: "100% 100%",
  [`&.${badgeClasses$1.invisible}`]: {
    transform: "scale(0) translate(50%, 50%)"
  }
}, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular" && {
  top: 0,
  left: 0,
  transform: "scale(1) translate(-50%, -50%)",
  transformOrigin: "0% 0%",
  [`&.${badgeClasses$1.invisible}`]: {
    transform: "scale(0) translate(-50%, -50%)"
  }
}, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular" && {
  bottom: 0,
  left: 0,
  transform: "scale(1) translate(-50%, 50%)",
  transformOrigin: "0% 100%",
  [`&.${badgeClasses$1.invisible}`]: {
    transform: "scale(0) translate(-50%, 50%)"
  }
}, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular" && {
  top: "14%",
  right: "14%",
  transform: "scale(1) translate(50%, -50%)",
  transformOrigin: "100% 0%",
  [`&.${badgeClasses$1.invisible}`]: {
    transform: "scale(0) translate(50%, -50%)"
  }
}, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular" && {
  bottom: "14%",
  right: "14%",
  transform: "scale(1) translate(50%, 50%)",
  transformOrigin: "100% 100%",
  [`&.${badgeClasses$1.invisible}`]: {
    transform: "scale(0) translate(50%, 50%)"
  }
}, ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular" && {
  top: "14%",
  left: "14%",
  transform: "scale(1) translate(-50%, -50%)",
  transformOrigin: "0% 0%",
  [`&.${badgeClasses$1.invisible}`]: {
    transform: "scale(0) translate(-50%, -50%)"
  }
}, ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular" && {
  bottom: "14%",
  left: "14%",
  transform: "scale(1) translate(-50%, 50%)",
  transformOrigin: "0% 100%",
  [`&.${badgeClasses$1.invisible}`]: {
    transform: "scale(0) translate(-50%, 50%)"
  }
}, ownerState.invisible && {
  transition: theme2.transitions.create("transform", {
    easing: theme2.transitions.easing.easeInOut,
    duration: theme2.transitions.duration.leavingScreen
  })
}));
const Badge = /* @__PURE__ */ reactExports.forwardRef(function Badge2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$badge, _slotProps$root, _slotProps$badge;
  const props = useThemeProps({
    props: inProps,
    name: "MuiBadge"
  });
  const {
    anchorOrigin: anchorOriginProp = {
      vertical: "top",
      horizontal: "right"
    },
    className,
    component,
    components = {},
    componentsProps = {},
    children,
    overlap: overlapProp = "rectangular",
    color: colorProp = "default",
    invisible: invisibleProp = false,
    max: maxProp = 99,
    badgeContent: badgeContentProp,
    slots,
    slotProps,
    showZero = false,
    variant: variantProp = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$25);
  const {
    badgeContent,
    invisible: invisibleFromHook,
    max: max2,
    displayValue: displayValueFromHook
  } = useBadge({
    max: maxProp,
    invisible: invisibleProp,
    badgeContent: badgeContentProp,
    showZero
  });
  const prevProps = usePreviousProps$1({
    anchorOrigin: anchorOriginProp,
    color: colorProp,
    overlap: overlapProp,
    variant: variantProp,
    badgeContent: badgeContentProp
  });
  const invisible = invisibleFromHook || badgeContent == null && variantProp !== "dot";
  const {
    color: color2 = colorProp,
    overlap = overlapProp,
    anchorOrigin = anchorOriginProp,
    variant = variantProp
  } = invisible ? prevProps : props;
  const displayValue = variant !== "dot" ? displayValueFromHook : void 0;
  const ownerState = _extends$2({}, props, {
    badgeContent,
    invisible,
    max: max2,
    displayValue,
    showZero,
    anchorOrigin,
    color: color2,
    overlap,
    variant
  });
  const classes = useUtilityClasses$1F(ownerState);
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : BadgeRoot;
  const BadgeSlot = (_ref2 = (_slots$badge = slots == null ? void 0 : slots.badge) != null ? _slots$badge : components.Badge) != null ? _ref2 : BadgeBadge;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const badgeSlotProps = (_slotProps$badge = slotProps == null ? void 0 : slotProps.badge) != null ? _slotProps$badge : componentsProps.badge;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: clsx(rootSlotProps == null ? void 0 : rootSlotProps.className, classes.root, className)
  });
  const badgeProps = useSlotProps({
    elementType: BadgeSlot,
    externalSlotProps: badgeSlotProps,
    ownerState,
    className: clsx(classes.badge, badgeSlotProps == null ? void 0 : badgeSlotProps.className)
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$2({}, rootProps, {
    children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(BadgeSlot, _extends$2({}, badgeProps, {
      children: displayValue
    }))]
  }));
});
const Badge$1 = Badge;
const defaultTheme = createTheme();
const Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: "MuiBox-root",
  generateClassName: ClassNameGenerator$1.generate
});
const Box$1 = Box;
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
const buttonClasses$1 = buttonClasses;
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupContext$1 = ButtonGroupContext;
const ButtonGroupButtonContext = /* @__PURE__ */ reactExports.createContext(void 0);
const ButtonGroupButtonContext$1 = ButtonGroupButtonContext;
const _excluded$24 = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
const useUtilityClasses$1E = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, `${variant}${capitalize$1(color2)}`, `size${capitalize$1(size)}`, `${variant}Size${capitalize$1(size)}`, color2 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
    label: ["label"],
    startIcon: ["startIcon", `iconSize${capitalize$1(size)}`],
    endIcon: ["endIcon", `iconSize${capitalize$1(size)}`]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return _extends$2({}, classes, composedClasses);
};
const commonIconStyles = (ownerState) => _extends$2({}, ownerState.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, ownerState.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, ownerState.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
});
const ButtonRoot = styled$1(ButtonBase$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize$1(ownerState.color)}`], styles2[`size${capitalize$1(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize$1(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  const inheritContainedBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey[300] : theme2.palette.grey[800];
  const inheritContainedHoverBackgroundColor = theme2.palette.mode === "light" ? theme2.palette.grey.A100 : theme2.palette.grey[700];
  return _extends$2({}, theme2.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme2.transitions.duration.short
    }),
    "&:hover": _extends$2({
      textDecoration: "none",
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.text.primary, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      border: `1px solid ${(theme2.vars || theme2).palette[ownerState.color].main}`,
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "contained" && {
      backgroundColor: theme2.vars ? theme2.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
      boxShadow: (theme2.vars || theme2).shadows[4],
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        boxShadow: (theme2.vars || theme2).shadows[2],
        backgroundColor: (theme2.vars || theme2).palette.grey[300]
      }
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main
      }
    }),
    "&:active": _extends$2({}, ownerState.variant === "contained" && {
      boxShadow: (theme2.vars || theme2).shadows[8]
    }),
    [`&.${buttonClasses$1.focusVisible}`]: _extends$2({}, ownerState.variant === "contained" && {
      boxShadow: (theme2.vars || theme2).shadows[6]
    }),
    [`&.${buttonClasses$1.disabled}`]: _extends$2({
      color: (theme2.vars || theme2).palette.action.disabled
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme2.vars || theme2).palette.action.disabledBackground}`
    }, ownerState.variant === "contained" && {
      color: (theme2.vars || theme2).palette.action.disabled,
      boxShadow: (theme2.vars || theme2).shadows[0],
      backgroundColor: (theme2.vars || theme2).palette.action.disabledBackground
    })
  }, ownerState.variant === "text" && {
    padding: "6px 8px"
  }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  }, ownerState.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].main,
    border: theme2.vars ? `1px solid rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme2.palette[ownerState.color].main, 0.5)}`
  }, ownerState.variant === "contained" && {
    color: theme2.vars ? (
      // this is safe because grey does not change between default light/dark mode
      theme2.vars.palette.text.primary
    ) : (_theme$palette$getCon = (_theme$palette = theme2.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme2.palette.grey[300]),
    backgroundColor: theme2.vars ? theme2.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
    boxShadow: (theme2.vars || theme2).shadows[2]
  }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].contrastText,
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main
  }, ownerState.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, ownerState.size === "small" && ownerState.variant === "text" && {
    padding: "4px 5px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "text" && {
    padding: "8px 11px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "contained" && {
    padding: "4px 10px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "contained" && {
    padding: "8px 22px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState
}) => ownerState.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${buttonClasses$1.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${buttonClasses$1.disabled}`]: {
    boxShadow: "none"
  }
});
const ButtonStartIcon = styled$1("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$2({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, ownerState.size === "small" && {
  marginLeft: -2
}, commonIconStyles(ownerState)));
const ButtonEndIcon = styled$1("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, styles2[`iconSize${capitalize$1(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$2({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, ownerState.size === "small" && {
  marginRight: -2
}, commonIconStyles(ownerState)));
const Button = /* @__PURE__ */ reactExports.forwardRef(function Button2(inProps, ref) {
  const contextProps = reactExports.useContext(ButtonGroupContext$1);
  const buttonGroupButtonContextPositionClassName = reactExports.useContext(ButtonGroupButtonContext$1);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useThemeProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    size = "medium",
    startIcon: startIconProp,
    type: type2,
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$24);
  const ownerState = _extends$2({}, props, {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size,
    type: type2,
    variant
  });
  const classes = useUtilityClasses$1E(ownerState);
  const startIcon = startIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp
  });
  const endIcon = endIconProp && /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp
  });
  const positionClassName = buttonGroupButtonContextPositionClassName || "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonRoot, _extends$2({
    ownerState,
    className: clsx(contextProps.className, classes.root, className, positionClassName),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref,
    type: type2
  }, other, {
    classes,
    children: [startIcon, children, endIcon]
  }));
});
const Button$1 = Button;
function getCardUtilityClass(slot) {
  return generateUtilityClass("MuiCard", slot);
}
generateUtilityClasses("MuiCard", ["root"]);
const _excluded$23 = ["className", "raised"];
const useUtilityClasses$1D = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardUtilityClass, classes);
};
const CardRoot = styled$1(MuiPaper, {
  name: "MuiCard",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(() => {
  return {
    overflow: "hidden"
  };
});
const Card = /* @__PURE__ */ reactExports.forwardRef(function Card2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCard"
  });
  const {
    className,
    raised = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$23);
  const ownerState = _extends$2({}, props, {
    raised
  });
  const classes = useUtilityClasses$1D(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CardRoot, _extends$2({
    className: clsx(classes.root, className),
    elevation: raised ? 8 : void 0,
    ref,
    ownerState
  }, other));
});
const Card$1 = Card;
function getCardActionAreaUtilityClass(slot) {
  return generateUtilityClass("MuiCardActionArea", slot);
}
const cardActionAreaClasses = generateUtilityClasses("MuiCardActionArea", ["root", "focusVisible", "focusHighlight"]);
const cardActionAreaClasses$1 = cardActionAreaClasses;
const _excluded$22 = ["children", "className", "focusVisibleClassName"];
const useUtilityClasses$1C = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    focusHighlight: ["focusHighlight"]
  };
  return composeClasses(slots, getCardActionAreaUtilityClass, classes);
};
const CardActionAreaRoot = styled$1(ButtonBase$1, {
  name: "MuiCardActionArea",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => ({
  display: "block",
  textAlign: "inherit",
  borderRadius: "inherit",
  // for Safari to work https://github.com/mui/material-ui/issues/36285.
  width: "100%",
  [`&:hover .${cardActionAreaClasses$1.focusHighlight}`]: {
    opacity: (theme2.vars || theme2).palette.action.hoverOpacity,
    "@media (hover: none)": {
      opacity: 0
    }
  },
  [`&.${cardActionAreaClasses$1.focusVisible} .${cardActionAreaClasses$1.focusHighlight}`]: {
    opacity: (theme2.vars || theme2).palette.action.focusOpacity
  }
}));
const CardActionAreaFocusHighlight = styled$1("span", {
  name: "MuiCardActionArea",
  slot: "FocusHighlight",
  overridesResolver: (props, styles2) => styles2.focusHighlight
})(({
  theme: theme2
}) => ({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit",
  opacity: 0,
  backgroundColor: "currentcolor",
  transition: theme2.transitions.create("opacity", {
    duration: theme2.transitions.duration.short
  })
}));
const CardActionArea = /* @__PURE__ */ reactExports.forwardRef(function CardActionArea2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCardActionArea"
  });
  const {
    children,
    className,
    focusVisibleClassName
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$22);
  const ownerState = props;
  const classes = useUtilityClasses$1C(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(CardActionAreaRoot, _extends$2({
    className: clsx(classes.root, className),
    focusVisibleClassName: clsx(focusVisibleClassName, classes.focusVisible),
    ref,
    ownerState
  }, other, {
    children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(CardActionAreaFocusHighlight, {
      className: classes.focusHighlight,
      ownerState
    })]
  }));
});
const CardActionArea$1 = CardActionArea;
function getSwitchBaseUtilityClass(slot) {
  return generateUtilityClass("PrivateSwitchBase", slot);
}
generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const _excluded$21 = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"];
const useUtilityClasses$1B = (ownerState) => {
  const {
    classes,
    checked,
    disabled,
    edge
  } = ownerState;
  const slots = {
    root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize$1(edge)}`],
    input: ["input"]
  };
  return composeClasses(slots, getSwitchBaseUtilityClass, classes);
};
const SwitchBaseRoot = styled$1(ButtonBase$1)(({
  ownerState
}) => _extends$2({
  padding: 9,
  borderRadius: "50%"
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}));
const SwitchBaseInput = styled$1("input")({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
});
const SwitchBase = /* @__PURE__ */ reactExports.forwardRef(function SwitchBase2(props, ref) {
  const {
    autoFocus,
    checked: checkedProp,
    checkedIcon,
    className,
    defaultChecked,
    disabled: disabledProp,
    disableFocusRipple = false,
    edge = false,
    icon,
    id: id2,
    inputProps,
    inputRef,
    name,
    onBlur,
    onChange,
    onFocus,
    readOnly,
    required = false,
    tabIndex,
    type: type2,
    value
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$21);
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "SwitchBase",
    state: "checked"
  });
  const muiFormControl = useFormControl();
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    }
  };
  const handleInputChange = (event) => {
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    const newChecked = event.target.checked;
    setCheckedState(newChecked);
    if (onChange) {
      onChange(event, newChecked);
    }
  };
  let disabled = disabledProp;
  if (muiFormControl) {
    if (typeof disabled === "undefined") {
      disabled = muiFormControl.disabled;
    }
  }
  const hasLabelFor = type2 === "checkbox" || type2 === "radio";
  const ownerState = _extends$2({}, props, {
    checked,
    disabled,
    disableFocusRipple,
    edge
  });
  const classes = useUtilityClasses$1B(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchBaseRoot, _extends$2({
    component: "span",
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    tabIndex: null,
    role: void 0,
    onFocus: handleFocus,
    onBlur: handleBlur,
    ownerState,
    ref
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchBaseInput, _extends$2({
      autoFocus,
      checked: checkedProp,
      defaultChecked,
      className: classes.input,
      disabled,
      id: hasLabelFor ? id2 : void 0,
      name,
      onChange: handleInputChange,
      readOnly,
      ref: inputRef,
      required,
      ownerState,
      tabIndex,
      type: type2
    }, type2 === "checkbox" && value === void 0 ? {} : {
      value
    }, inputProps)), checked ? checkedIcon : icon]
  }));
});
const SwitchBase$1 = SwitchBase;
const CheckBoxOutlineBlankIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank");
const CheckBoxIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckBox");
const IndeterminateCheckBoxIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), "IndeterminateCheckBox");
function getCheckboxUtilityClass(slot) {
  return generateUtilityClass("MuiCheckbox", slot);
}
const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]);
const checkboxClasses$1 = checkboxClasses;
const _excluded$20 = ["checkedIcon", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size", "className"];
const useUtilityClasses$1A = (ownerState) => {
  const {
    classes,
    indeterminate,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", indeterminate && "indeterminate", `color${capitalize$1(color2)}`, `size${capitalize$1(size)}`]
  };
  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);
  return _extends$2({}, classes, composedClasses);
};
const CheckboxRoot = styled$1(SwitchBase$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.indeterminate && styles2.indeterminate, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  color: (theme2.vars || theme2).palette.text.secondary
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${ownerState.color === "default" ? theme2.vars.palette.action.activeChannel : theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === "default" ? theme2.palette.action.active : theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.color !== "default" && {
  [`&.${checkboxClasses$1.checked}, &.${checkboxClasses$1.indeterminate}`]: {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  },
  [`&.${checkboxClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  }
}));
const defaultCheckedIcon$1 = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxIcon, {});
const defaultIcon$1 = /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {});
const defaultIndeterminateIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {});
const Checkbox = /* @__PURE__ */ reactExports.forwardRef(function Checkbox2(inProps, ref) {
  var _icon$props$fontSize, _indeterminateIcon$pr;
  const props = useThemeProps({
    props: inProps,
    name: "MuiCheckbox"
  });
  const {
    checkedIcon = defaultCheckedIcon$1,
    color: color2 = "primary",
    icon: iconProp = defaultIcon$1,
    indeterminate = false,
    indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
    inputProps,
    size = "medium",
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$20);
  const icon = indeterminate ? indeterminateIconProp : iconProp;
  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
  const ownerState = _extends$2({}, props, {
    color: color2,
    indeterminate,
    size
  });
  const classes = useUtilityClasses$1A(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxRoot, _extends$2({
    type: "checkbox",
    inputProps: _extends$2({
      "data-indeterminate": indeterminate
    }, inputProps),
    icon: /* @__PURE__ */ reactExports.cloneElement(icon, {
      fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size
    }),
    checkedIcon: /* @__PURE__ */ reactExports.cloneElement(indeterminateIcon, {
      fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size
    }),
    ownerState,
    ref,
    className: clsx(classes.root, className)
  }, other, {
    classes
  }));
});
const MUICheckbox = Checkbox;
function getCircularProgressUtilityClass(slot) {
  return generateUtilityClass("MuiCircularProgress", slot);
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const _excluded$1$ = ["className", "color", "disableShrink", "size", "style", "thickness", "value", "variant"];
let _$6 = (t3) => t3, _t$4, _t2$1, _t3$1, _t4$1;
const SIZE = 44;
const circularRotateKeyframe = keyframes(_t$4 || (_t$4 = _$6`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`));
const circularDashKeyframe = keyframes(_t2$1 || (_t2$1 = _$6`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`));
const useUtilityClasses$1z = (ownerState) => {
  const {
    classes,
    variant,
    color: color2,
    disableShrink
  } = ownerState;
  const slots = {
    root: ["root", variant, `color${capitalize$1(color2)}`],
    svg: ["svg"],
    circle: ["circle", `circle${capitalize$1(variant)}`, disableShrink && "circleDisableShrink"]
  };
  return composeClasses(slots, getCircularProgressUtilityClass, classes);
};
const CircularProgressRoot = styled$1("span", {
  name: "MuiCircularProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$2({
  display: "inline-block"
}, ownerState.variant === "determinate" && {
  transition: theme2.transitions.create("transform")
}, ownerState.color !== "inherit" && {
  color: (theme2.vars || theme2).palette[ownerState.color].main
}), ({
  ownerState
}) => ownerState.variant === "indeterminate" && css(_t3$1 || (_t3$1 = _$6`
      animation: ${0} 1.4s linear infinite;
    `), circularRotateKeyframe));
const CircularProgressSVG = styled$1("svg", {
  name: "MuiCircularProgress",
  slot: "Svg",
  overridesResolver: (props, styles2) => styles2.svg
})({
  display: "block"
  // Keeps the progress centered
});
const CircularProgressCircle = styled$1("circle", {
  name: "MuiCircularProgress",
  slot: "Circle",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.circle, styles2[`circle${capitalize$1(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$2({
  stroke: "currentColor"
}, ownerState.variant === "determinate" && {
  transition: theme2.transitions.create("stroke-dashoffset")
}, ownerState.variant === "indeterminate" && {
  // Some default value that looks fine waiting for the animation to kicks in.
  strokeDasharray: "80px, 200px",
  strokeDashoffset: 0
  // Add the unit to fix a Edge 16 and below bug.
}), ({
  ownerState
}) => ownerState.variant === "indeterminate" && !ownerState.disableShrink && css(_t4$1 || (_t4$1 = _$6`
      animation: ${0} 1.4s ease-in-out infinite;
    `), circularDashKeyframe));
const CircularProgress = /* @__PURE__ */ reactExports.forwardRef(function CircularProgress2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCircularProgress"
  });
  const {
    className,
    color: color2 = "primary",
    disableShrink = false,
    size = 40,
    style: style2,
    thickness = 3.6,
    value = 0,
    variant = "indeterminate"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1$);
  const ownerState = _extends$2({}, props, {
    color: color2,
    disableShrink,
    size,
    thickness,
    value,
    variant
  });
  const classes = useUtilityClasses$1z(ownerState);
  const circleStyle = {};
  const rootStyle = {};
  const rootProps = {};
  if (variant === "determinate") {
    const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
    circleStyle.strokeDasharray = circumference.toFixed(3);
    rootProps["aria-valuenow"] = Math.round(value);
    circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
    rootStyle.transform = "rotate(-90deg)";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressRoot, _extends$2({
    className: clsx(classes.root, className),
    style: _extends$2({
      width: size,
      height: size
    }, rootStyle, style2),
    ownerState,
    ref,
    role: "progressbar"
  }, rootProps, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressSVG, {
      className: classes.svg,
      ownerState,
      viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgressCircle, {
        className: classes.circle,
        style: circleStyle,
        ownerState,
        cx: SIZE,
        cy: SIZE,
        r: (SIZE - thickness) / 2,
        fill: "none",
        strokeWidth: thickness
      })
    })
  }));
});
const CircularProgress$1 = CircularProgress;
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$1_ = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"];
const useUtilityClasses$1y = (ownerState) => {
  const {
    open: open2,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open2 && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
const ModalRoot = styled$1("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  position: "fixed",
  zIndex: (theme2.vars || theme2).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ownerState.open && ownerState.exited && {
  visibility: "hidden"
}));
const ModalBackdrop = styled$1(Backdrop$1, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
  const props = useThemeProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    open: open2,
    slotProps,
    slots
    // eslint-disable-next-line react/prop-types
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1_);
  const propsWithDefaults = _extends$2({}, props, {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  });
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal(_extends$2({}, propsWithDefaults, {
    rootRef: ref
  }));
  const ownerState = _extends$2({}, propsWithDefaults, {
    exited
  });
  const classes = useUtilityClasses$1y(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
  const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    getSlotProps: getRootProps,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
  });
  const backdropProps = useSlotProps({
    elementType: BackdropSlot,
    externalSlotProps: backdropSlotProps,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps(_extends$2({}, otherHandlers, {
        onClick: (e2) => {
          if (onBackdropClick) {
            onBackdropClick(e2);
          }
          if (otherHandlers != null && otherHandlers.onClick) {
            otherHandlers.onClick(e2);
          }
        }
      }));
    },
    className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
    ownerState
  });
  if (!keepMounted && !open2 && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$2({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends$2({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open: open2,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    }))
  });
});
const Modal$1 = Modal;
function getDialogUtilityClass(slot) {
  return generateUtilityClass("MuiDialog", slot);
}
const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
const dialogClasses$1 = dialogClasses;
const DialogContext = /* @__PURE__ */ reactExports.createContext({});
const DialogContext$1 = DialogContext;
const _excluded$1Z = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
const DialogBackdrop = styled$1(Backdrop$1, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (props, styles2) => styles2.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$1x = (ownerState) => {
  const {
    classes,
    scroll,
    maxWidth: maxWidth2,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container", `scroll${capitalize$1(scroll)}`],
    paper: ["paper", `paperScroll${capitalize$1(scroll)}`, `paperWidth${capitalize$1(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
  };
  return composeClasses(slots, getDialogUtilityClass, classes);
};
const DialogRoot = styled$1(Modal$1, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
});
const DialogContainer = styled$1("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.container, styles2[`scroll${capitalize$1(ownerState.scroll)}`]];
  }
})(({
  ownerState
}) => _extends$2({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, ownerState.scroll === "paper" && {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, ownerState.scroll === "body" && {
  overflowY: "auto",
  overflowX: "hidden",
  textAlign: "center",
  "&:after": {
    content: '""',
    display: "inline-block",
    verticalAlign: "middle",
    height: "100%",
    width: "0"
  }
}));
const DialogPaper = styled$1(MuiPaper, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`scrollPaper${capitalize$1(ownerState.scroll)}`], styles2[`paperWidth${capitalize$1(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  // Fix IE11 issue, to remove at some point.
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  }
}, ownerState.scroll === "paper" && {
  display: "flex",
  flexDirection: "column",
  maxHeight: "calc(100% - 64px)"
}, ownerState.scroll === "body" && {
  display: "inline-block",
  verticalAlign: "middle",
  textAlign: "left"
  // 'initial' doesn't work on IE11
}, !ownerState.maxWidth && {
  maxWidth: "calc(100% - 64px)"
}, ownerState.maxWidth === "xs" && {
  maxWidth: theme2.breakpoints.unit === "px" ? Math.max(theme2.breakpoints.values.xs, 444) : `max(${theme2.breakpoints.values.xs}${theme2.breakpoints.unit}, 444px)`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme2.breakpoints.down(Math.max(theme2.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
  maxWidth: `${theme2.breakpoints.values[ownerState.maxWidth]}${theme2.breakpoints.unit}`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme2.breakpoints.down(theme2.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.fullWidth && {
  width: "calc(100% - 64px)"
}, ownerState.fullScreen && {
  margin: 0,
  width: "100%",
  maxWidth: "100%",
  height: "100%",
  maxHeight: "none",
  borderRadius: 0,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    margin: 0,
    maxWidth: "100%"
  }
}));
const Dialog = /* @__PURE__ */ reactExports.forwardRef(function Dialog2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDialog"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledbyProp,
    BackdropComponent,
    BackdropProps,
    children,
    className,
    disableEscapeKeyDown = false,
    fullScreen = false,
    fullWidth = false,
    maxWidth: maxWidth2 = "sm",
    onBackdropClick,
    onClose,
    open: open2,
    PaperComponent = MuiPaper,
    PaperProps = {},
    scroll = "paper",
    TransitionComponent = Fade$1,
    transitionDuration = defaultTransitionDuration,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1Z);
  const ownerState = _extends$2({}, props, {
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth: maxWidth2,
    scroll
  });
  const classes = useUtilityClasses$1x(ownerState);
  const backdropClick = reactExports.useRef();
  const handleMouseDown = (event) => {
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleBackdropClick = (event) => {
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const ariaLabelledby = useId(ariaLabelledbyProp);
  const dialogContextValue = reactExports.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogRoot, _extends$2({
    className: clsx(classes.root, className),
    closeAfterTransition: true,
    components: {
      Backdrop: DialogBackdrop
    },
    componentsProps: {
      backdrop: _extends$2({
        transitionDuration,
        as: BackdropComponent
      }, BackdropProps)
    },
    disableEscapeKeyDown,
    onClose,
    open: open2,
    ref,
    onClick: handleBackdropClick,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$2({
      appear: true,
      in: open2,
      timeout: transitionDuration,
      role: "presentation"
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContainer, {
        className: clsx(classes.container),
        onMouseDown: handleMouseDown,
        ownerState,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPaper, _extends$2({
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby
        }, PaperProps, {
          className: clsx(classes.paper, PaperProps.className),
          ownerState,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext$1.Provider, {
            value: dialogContextValue,
            children
          })
        }))
      })
    }))
  }));
});
const MuiDialog = Dialog;
function getDialogActionsUtilityClass(slot) {
  return generateUtilityClass("MuiDialogActions", slot);
}
generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);
const _excluded$1Y = ["className", "disableSpacing"];
const useUtilityClasses$1w = (ownerState) => {
  const {
    classes,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ["root", !disableSpacing && "spacing"]
  };
  return composeClasses(slots, getDialogActionsUtilityClass, classes);
};
const DialogActionsRoot = styled$1("div", {
  name: "MuiDialogActions",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
  }
})(({
  ownerState
}) => _extends$2({
  display: "flex",
  alignItems: "center",
  padding: 8,
  justifyContent: "flex-end",
  flex: "0 0 auto"
}, !ownerState.disableSpacing && {
  "& > :not(:first-of-type)": {
    marginLeft: 8
  }
}));
const DialogActions = /* @__PURE__ */ reactExports.forwardRef(function DialogActions2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDialogActions"
  });
  const {
    className,
    disableSpacing = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1Y);
  const ownerState = _extends$2({}, props, {
    disableSpacing
  });
  const classes = useUtilityClasses$1w(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActionsRoot, _extends$2({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const DialogActions$1 = DialogActions;
function getDialogContentUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContent", slot);
}
generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);
const dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"]);
const dialogTitleClasses$1 = dialogTitleClasses;
const _excluded$1X = ["className", "dividers"];
const useUtilityClasses$1v = (ownerState) => {
  const {
    classes,
    dividers
  } = ownerState;
  const slots = {
    root: ["root", dividers && "dividers"]
  };
  return composeClasses(slots, getDialogContentUtilityClass, classes);
};
const DialogContentRoot = styled$1("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dividers && styles2.dividers];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px"
}, ownerState.dividers ? {
  padding: "16px 24px",
  borderTop: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`
} : {
  [`.${dialogTitleClasses$1.root} + &`]: {
    paddingTop: 0
  }
}));
const DialogContent = /* @__PURE__ */ reactExports.forwardRef(function DialogContent2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDialogContent"
  });
  const {
    className,
    dividers = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1X);
  const ownerState = _extends$2({}, props, {
    dividers
  });
  const classes = useUtilityClasses$1v(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentRoot, _extends$2({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const DialogContent$1 = DialogContent;
function getDividerUtilityClass(slot) {
  return generateUtilityClass("MuiDivider", slot);
}
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const dividerClasses$1 = dividerClasses;
const _excluded$1W = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"];
const useUtilityClasses$1u = (ownerState) => {
  const {
    absolute,
    children,
    classes,
    flexItem,
    light: light2,
    orientation,
    textAlign: textAlign2,
    variant
  } = ownerState;
  const slots = {
    root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign2 === "right" && orientation !== "vertical" && "textAlignRight", textAlign2 === "left" && orientation !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
  };
  return composeClasses(slots, getDividerUtilityClass, classes);
};
const DividerRoot = styled$1("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (theme2.vars || theme2).palette.divider,
  borderBottomWidth: "thin"
}, ownerState.absolute && {
  position: "absolute",
  bottom: 0,
  left: 0,
  width: "100%"
}, ownerState.light && {
  borderColor: theme2.vars ? `rgba(${theme2.vars.palette.dividerChannel} / 0.08)` : alpha(theme2.palette.divider, 0.08)
}, ownerState.variant === "inset" && {
  marginLeft: 72
}, ownerState.variant === "middle" && ownerState.orientation === "horizontal" && {
  marginLeft: theme2.spacing(2),
  marginRight: theme2.spacing(2)
}, ownerState.variant === "middle" && ownerState.orientation === "vertical" && {
  marginTop: theme2.spacing(1),
  marginBottom: theme2.spacing(1)
}, ownerState.orientation === "vertical" && {
  height: "100%",
  borderBottomWidth: 0,
  borderRightWidth: "thin"
}, ownerState.flexItem && {
  alignSelf: "stretch",
  height: "auto"
}), ({
  ownerState
}) => _extends$2({}, ownerState.children && {
  display: "flex",
  whiteSpace: "nowrap",
  textAlign: "center",
  border: 0,
  "&::before, &::after": {
    content: '""',
    alignSelf: "center"
  }
}), ({
  theme: theme2,
  ownerState
}) => _extends$2({}, ownerState.children && ownerState.orientation !== "vertical" && {
  "&::before, &::after": {
    width: "100%",
    borderTop: `thin solid ${(theme2.vars || theme2).palette.divider}`
  }
}), ({
  theme: theme2,
  ownerState
}) => _extends$2({}, ownerState.children && ownerState.orientation === "vertical" && {
  flexDirection: "column",
  "&::before, &::after": {
    height: "100%",
    borderLeft: `thin solid ${(theme2.vars || theme2).palette.divider}`
  }
}), ({
  ownerState
}) => _extends$2({}, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && {
  "&::before": {
    width: "90%"
  },
  "&::after": {
    width: "10%"
  }
}, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && {
  "&::before": {
    width: "10%"
  },
  "&::after": {
    width: "90%"
  }
}));
const DividerWrapper = styled$1("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  display: "inline-block",
  paddingLeft: `calc(${theme2.spacing(1)} * 1.2)`,
  paddingRight: `calc(${theme2.spacing(1)} * 1.2)`
}, ownerState.orientation === "vertical" && {
  paddingTop: `calc(${theme2.spacing(1)} * 1.2)`,
  paddingBottom: `calc(${theme2.spacing(1)} * 1.2)`
}));
const Divider = /* @__PURE__ */ reactExports.forwardRef(function Divider2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDivider"
  });
  const {
    absolute = false,
    children,
    className,
    component = children ? "div" : "hr",
    flexItem = false,
    light: light2 = false,
    orientation = "horizontal",
    role = component !== "hr" ? "separator" : void 0,
    textAlign: textAlign2 = "center",
    variant = "fullWidth"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1W);
  const ownerState = _extends$2({}, props, {
    absolute,
    component,
    flexItem,
    light: light2,
    orientation,
    role,
    textAlign: textAlign2,
    variant
  });
  const classes = useUtilityClasses$1u(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DividerRoot, _extends$2({
    as: component,
    className: clsx(classes.root, className),
    role,
    ref,
    ownerState
  }, other, {
    children: children ? /* @__PURE__ */ jsxRuntimeExports.jsx(DividerWrapper, {
      className: classes.wrapper,
      ownerState,
      children
    }) : null
  }));
});
Divider.muiSkipListHighlight = true;
const Divider$1 = Divider;
const _excluded$1V = ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getTranslateValue(direction2, node2, resolvedContainer) {
  const rect = node2.getBoundingClientRect();
  const containerRect = resolvedContainer && resolvedContainer.getBoundingClientRect();
  const containerWindow = ownerWindow(node2);
  let transform2;
  if (node2.fakeTransform) {
    transform2 = node2.fakeTransform;
  } else {
    const computedStyle = containerWindow.getComputedStyle(node2);
    transform2 = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
  }
  let offsetX = 0;
  let offsetY = 0;
  if (transform2 && transform2 !== "none" && typeof transform2 === "string") {
    const transformValues = transform2.split("(")[1].split(")")[0].split(",");
    offsetX = parseInt(transformValues[4], 10);
    offsetY = parseInt(transformValues[5], 10);
  }
  if (direction2 === "left") {
    if (containerRect) {
      return `translateX(${containerRect.right + offsetX - rect.left}px)`;
    }
    return `translateX(${containerWindow.innerWidth + offsetX - rect.left}px)`;
  }
  if (direction2 === "right") {
    if (containerRect) {
      return `translateX(-${rect.right - containerRect.left - offsetX}px)`;
    }
    return `translateX(-${rect.left + rect.width - offsetX}px)`;
  }
  if (direction2 === "up") {
    if (containerRect) {
      return `translateY(${containerRect.bottom + offsetY - rect.top}px)`;
    }
    return `translateY(${containerWindow.innerHeight + offsetY - rect.top}px)`;
  }
  if (containerRect) {
    return `translateY(-${rect.top - containerRect.top + rect.height - offsetY}px)`;
  }
  return `translateY(-${rect.top + rect.height - offsetY}px)`;
}
function resolveContainer(containerPropProp) {
  return typeof containerPropProp === "function" ? containerPropProp() : containerPropProp;
}
function setTranslateValue(direction2, node2, containerProp) {
  const resolvedContainer = resolveContainer(containerProp);
  const transform2 = getTranslateValue(direction2, node2, resolvedContainer);
  if (transform2) {
    node2.style.webkitTransform = transform2;
    node2.style.transform = transform2;
  }
}
const Slide = /* @__PURE__ */ reactExports.forwardRef(function Slide2(props, ref) {
  const theme2 = useTheme();
  const defaultEasing = {
    enter: theme2.transitions.easing.easeOut,
    exit: theme2.transitions.easing.sharp
  };
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    container: containerProp,
    direction: direction2 = "down",
    easing: easingProp = defaultEasing,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1V);
  const childrenRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, childrenRef, ref);
  const normalizedTransitionCallback = (callback) => (isAppearing) => {
    if (callback) {
      if (isAppearing === void 0) {
        callback(childrenRef.current);
      } else {
        callback(childrenRef.current, isAppearing);
      }
    }
  };
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    setTranslateValue(direction2, node2, containerProp);
    reflow(node2);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
    const transitionProps = getTransitionProps({
      timeout,
      style: style2,
      easing: easingProp
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("-webkit-transform", _extends$2({}, transitionProps));
    node2.style.transition = theme2.transitions.create("transform", _extends$2({}, transitionProps));
    node2.style.webkitTransform = "none";
    node2.style.transform = "none";
    if (onEntering) {
      onEntering(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      timeout,
      style: style2,
      easing: easingProp
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("-webkit-transform", transitionProps);
    node2.style.transition = theme2.transitions.create("transform", transitionProps);
    setTranslateValue(direction2, node2, containerProp);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback((node2) => {
    node2.style.webkitTransition = "";
    node2.style.transition = "";
    if (onExited) {
      onExited(node2);
    }
  });
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(childrenRef.current, next2);
    }
  };
  const updatePosition = reactExports.useCallback(() => {
    if (childrenRef.current) {
      setTranslateValue(direction2, childrenRef.current, containerProp);
    }
  }, [direction2, containerProp]);
  reactExports.useEffect(() => {
    if (inProp || direction2 === "down" || direction2 === "right") {
      return void 0;
    }
    const handleResize = debounce$1(() => {
      if (childrenRef.current) {
        setTranslateValue(direction2, childrenRef.current, containerProp);
      }
    });
    const containerWindow = ownerWindow(childrenRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [direction2, inProp, containerProp]);
  reactExports.useEffect(() => {
    if (!inProp) {
      updatePosition();
    }
  }, [inProp, updatePosition]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$2({
    nodeRef: childrenRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    appear,
    in: inProp,
    timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$2({
        ref: handleRef,
        style: _extends$2({
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, style2, children.props.style)
      }, childProps));
    }
  }));
});
const Slide$1 = Slide;
function getDrawerUtilityClass(slot) {
  return generateUtilityClass("MuiDrawer", slot);
}
generateUtilityClasses("MuiDrawer", ["root", "docked", "paper", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const _excluded$1U = ["BackdropProps"], _excluded2$g = ["anchor", "BackdropProps", "children", "className", "elevation", "hideBackdrop", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"];
const overridesResolver$5 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, (ownerState.variant === "permanent" || ownerState.variant === "persistent") && styles2.docked, styles2.modal];
};
const useUtilityClasses$1t = (ownerState) => {
  const {
    classes,
    anchor,
    variant
  } = ownerState;
  const slots = {
    root: ["root"],
    docked: [(variant === "permanent" || variant === "persistent") && "docked"],
    modal: ["modal"],
    paper: ["paper", `paperAnchor${capitalize$1(anchor)}`, variant !== "temporary" && `paperAnchorDocked${capitalize$1(anchor)}`]
  };
  return composeClasses(slots, getDrawerUtilityClass, classes);
};
const DrawerRoot = styled$1(Modal$1, {
  name: "MuiDrawer",
  slot: "Root",
  overridesResolver: overridesResolver$5
})(({
  theme: theme2
}) => ({
  zIndex: (theme2.vars || theme2).zIndex.drawer
}));
const DrawerDockedRoot = styled$1("div", {
  shouldForwardProp: rootShouldForwardProp,
  name: "MuiDrawer",
  slot: "Docked",
  skipVariantsResolver: false,
  overridesResolver: overridesResolver$5
})({
  flex: "0 0 auto"
});
const DrawerPaper = styled$1(MuiPaper, {
  name: "MuiDrawer",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`paperAnchor${capitalize$1(ownerState.anchor)}`], ownerState.variant !== "temporary" && styles2[`paperAnchorDocked${capitalize$1(ownerState.anchor)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  overflowY: "auto",
  display: "flex",
  flexDirection: "column",
  height: "100%",
  flex: "1 0 auto",
  zIndex: (theme2.vars || theme2).zIndex.drawer,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  // temporary style
  position: "fixed",
  top: 0,
  // We disable the focus ring for mouse, touch and keyboard users.
  // At some point, it would be better to keep it for keyboard users.
  // :focus-ring CSS pseudo-class will help.
  outline: 0
}, ownerState.anchor === "left" && {
  left: 0
}, ownerState.anchor === "top" && {
  top: 0,
  left: 0,
  right: 0,
  height: "auto",
  maxHeight: "100%"
}, ownerState.anchor === "right" && {
  right: 0
}, ownerState.anchor === "bottom" && {
  top: "auto",
  left: 0,
  bottom: 0,
  right: 0,
  height: "auto",
  maxHeight: "100%"
}, ownerState.anchor === "left" && ownerState.variant !== "temporary" && {
  borderRight: `1px solid ${(theme2.vars || theme2).palette.divider}`
}, ownerState.anchor === "top" && ownerState.variant !== "temporary" && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`
}, ownerState.anchor === "right" && ownerState.variant !== "temporary" && {
  borderLeft: `1px solid ${(theme2.vars || theme2).palette.divider}`
}, ownerState.anchor === "bottom" && ownerState.variant !== "temporary" && {
  borderTop: `1px solid ${(theme2.vars || theme2).palette.divider}`
}));
const oppositeDirection = {
  left: "right",
  right: "left",
  top: "down",
  bottom: "up"
};
function isHorizontal(anchor) {
  return ["left", "right"].indexOf(anchor) !== -1;
}
function getAnchor(theme2, anchor) {
  return theme2.direction === "rtl" && isHorizontal(anchor) ? oppositeDirection[anchor] : anchor;
}
const Drawer = /* @__PURE__ */ reactExports.forwardRef(function Drawer2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDrawer"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    anchor: anchorProp = "left",
    BackdropProps,
    children,
    className,
    elevation = 16,
    hideBackdrop = false,
    ModalProps: {
      BackdropProps: BackdropPropsProp
    } = {},
    onClose,
    open: open2 = false,
    PaperProps = {},
    SlideProps,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Slide$1,
    transitionDuration = defaultTransitionDuration,
    variant = "temporary"
  } = props, ModalProps = _objectWithoutPropertiesLoose$1(props.ModalProps, _excluded$1U), other = _objectWithoutPropertiesLoose$1(props, _excluded2$g);
  const mounted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    mounted.current = true;
  }, []);
  const anchorInvariant = getAnchor(theme2, anchorProp);
  const anchor = anchorProp;
  const ownerState = _extends$2({}, props, {
    anchor,
    elevation,
    open: open2,
    variant
  }, other);
  const classes = useUtilityClasses$1t(ownerState);
  const drawer = /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerPaper, _extends$2({
    elevation: variant === "temporary" ? elevation : 0,
    square: true
  }, PaperProps, {
    className: clsx(classes.paper, PaperProps.className),
    ownerState,
    children
  }));
  if (variant === "permanent") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerDockedRoot, _extends$2({
      className: clsx(classes.root, classes.docked, className),
      ownerState,
      ref
    }, other, {
      children: drawer
    }));
  }
  const slidingDrawer = /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$2({
    in: open2,
    direction: oppositeDirection[anchorInvariant],
    timeout: transitionDuration,
    appear: mounted.current
  }, SlideProps, {
    children: drawer
  }));
  if (variant === "persistent") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerDockedRoot, _extends$2({
      className: clsx(classes.root, classes.docked, className),
      ownerState,
      ref
    }, other, {
      children: slidingDrawer
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerRoot, _extends$2({
    BackdropProps: _extends$2({}, BackdropProps, BackdropPropsProp, {
      transitionDuration
    }),
    className: clsx(classes.root, classes.modal, className),
    open: open2,
    ownerState,
    onClose,
    hideBackdrop,
    ref
  }, other, ModalProps, {
    children: slidingDrawer
  }));
});
const Drawer$1 = Drawer;
const _excluded$1T = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$1s = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
  return _extends$2({}, classes, composedClasses);
};
const FilledInputRoot = styled$1(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _palette;
  const light2 = theme2.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return _extends$2({
    position: "relative",
    backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme2.vars || theme2).shape.borderRadius,
    borderTopRightRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create("background-color", {
      duration: theme2.transitions.duration.shorter,
      easing: theme2.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses$1.focused}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses$1.disabled}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.disabledBg : disabledBackground
    }
  }, !ownerState.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(_palette = (theme2.vars || theme2).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme2.transitions.create("transform", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${filledInputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${filledInputClasses$1.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (theme2.vars || theme2).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})` : bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme2.transitions.create("border-bottom-color", {
        duration: theme2.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${filledInputClasses$1.disabled}, .${filledInputClasses$1.error}):before`]: {
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.text.primary}`
    },
    [`&.${filledInputClasses$1.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  }, ownerState.startAdornment && {
    paddingLeft: 12
  }, ownerState.endAdornment && {
    paddingRight: 12
  }, ownerState.multiline && _extends$2({
    padding: "25px 12px 8px"
  }, ownerState.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }));
});
const FilledInputInput = styled$1(InputBaseComponent, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}, theme2.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  paddingTop: 21,
  paddingBottom: 4
}, ownerState.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, ownerState.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}, ownerState.hiddenLabel && ownerState.size === "small" && {
  paddingTop: 8,
  paddingBottom: 9
}));
const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiFilledInput"
  });
  const {
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    // declare here to prevent spreading to DOM
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type: type2 = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1T);
  const ownerState = _extends$2({}, props, {
    fullWidth,
    inputComponent,
    multiline,
    type: type2
  });
  const classes = useUtilityClasses$1s(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge$1(slotProps != null ? slotProps : componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$2({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type: type2
  }, other, {
    classes
  }));
});
FilledInput.muiName = "Input";
const FilledInput$1 = FilledInput;
function getFormControlUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControl", slot);
}
generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const _excluded$1S = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
const useUtilityClasses$1r = (ownerState) => {
  const {
    classes,
    margin: margin2,
    fullWidth
  } = ownerState;
  const slots = {
    root: ["root", margin2 !== "none" && `margin${capitalize$1(margin2)}`, fullWidth && "fullWidth"]
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes);
};
const FormControlRoot = styled$1("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return _extends$2({}, styles2.root, styles2[`margin${capitalize$1(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
  }
})(({
  ownerState
}) => _extends$2({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top"
}, ownerState.margin === "normal" && {
  marginTop: 16,
  marginBottom: 8
}, ownerState.margin === "dense" && {
  marginTop: 8,
  marginBottom: 4
}, ownerState.fullWidth && {
  width: "100%"
}));
const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormControl"
  });
  const {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    error = false,
    focused: visuallyFocused,
    fullWidth = false,
    hiddenLabel = false,
    margin: margin2 = "none",
    required = false,
    size = "medium",
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1S);
  const ownerState = _extends$2({}, props, {
    color: color2,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin: margin2,
    required,
    size,
    variant
  });
  const classes = useUtilityClasses$1r(ownerState);
  const [adornedStart, setAdornedStart] = reactExports.useState(() => {
    let initialAdornedStart = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  });
  const [filled, setFilled] = reactExports.useState(() => {
    let initialFilled = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        if (isFilled(child.props, true) || isFilled(child.props.inputProps, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  });
  const [focusedState, setFocused] = reactExports.useState(false);
  if (disabled && focusedState) {
    setFocused(false);
  }
  const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
  let registerEffect;
  const childContext = reactExports.useMemo(() => {
    return {
      adornedStart,
      setAdornedStart,
      color: color2,
      disabled,
      error,
      filled,
      focused,
      fullWidth,
      hiddenLabel,
      size,
      onBlur: () => {
        setFocused(false);
      },
      onEmpty: () => {
        setFilled(false);
      },
      onFilled: () => {
        setFilled(true);
      },
      onFocus: () => {
        setFocused(true);
      },
      registerEffect,
      required,
      variant
    };
  }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size, variant]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlRoot, _extends$2({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other, {
      children
    }))
  });
});
const FormControl$1 = FormControl;
const Stack$1 = createStack({
  createStyledComponent: styled$1("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  }),
  useThemeProps: (inProps) => useThemeProps({
    props: inProps,
    name: "MuiStack"
  })
});
const Stack$2 = Stack$1;
function getFormControlLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControlLabel", slot);
}
const formControlLabelClasses = generateUtilityClasses("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]);
const formControlLabelClasses$1 = formControlLabelClasses;
const _excluded$1R = ["checked", "className", "componentsProps", "control", "disabled", "disableTypography", "inputRef", "label", "labelPlacement", "name", "onChange", "required", "slotProps", "value"];
const useUtilityClasses$1q = (ownerState) => {
  const {
    classes,
    disabled,
    labelPlacement,
    error,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", `labelPlacement${capitalize$1(labelPlacement)}`, error && "error", required && "required"],
    label: ["label", disabled && "disabled"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormControlLabelUtilityClasses, classes);
};
const FormControlLabelRoot = styled$1("label", {
  name: "MuiFormControlLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formControlLabelClasses$1.label}`]: styles2.label
    }, styles2.root, styles2[`labelPlacement${capitalize$1(ownerState.labelPlacement)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  display: "inline-flex",
  alignItems: "center",
  cursor: "pointer",
  // For correct alignment with the text.
  verticalAlign: "middle",
  WebkitTapHighlightColor: "transparent",
  marginLeft: -11,
  marginRight: 16,
  // used for row presentation of radio/checkbox
  [`&.${formControlLabelClasses$1.disabled}`]: {
    cursor: "default"
  }
}, ownerState.labelPlacement === "start" && {
  flexDirection: "row-reverse",
  marginLeft: 16,
  // used for row presentation of radio/checkbox
  marginRight: -11
}, ownerState.labelPlacement === "top" && {
  flexDirection: "column-reverse",
  marginLeft: 16
}, ownerState.labelPlacement === "bottom" && {
  flexDirection: "column",
  marginLeft: 16
}, {
  [`& .${formControlLabelClasses$1.label}`]: {
    [`&.${formControlLabelClasses$1.disabled}`]: {
      color: (theme2.vars || theme2).palette.text.disabled
    }
  }
}));
const AsteriskComponent$1 = styled$1("span", {
  name: "MuiFormControlLabel",
  slot: "Asterisk",
  overridesResolver: (props, styles2) => styles2.asterisk
})(({
  theme: theme2
}) => ({
  [`&.${formControlLabelClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const FormControlLabel = /* @__PURE__ */ reactExports.forwardRef(function FormControlLabel2(inProps, ref) {
  var _ref, _slotProps$typography;
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormControlLabel"
  });
  const {
    className,
    componentsProps = {},
    control,
    disabled: disabledProp,
    disableTypography,
    label: labelProp,
    labelPlacement = "end",
    required: requiredProp,
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1R);
  const muiFormControl = useFormControl();
  const disabled = (_ref = disabledProp != null ? disabledProp : control.props.disabled) != null ? _ref : muiFormControl == null ? void 0 : muiFormControl.disabled;
  const required = requiredProp != null ? requiredProp : control.props.required;
  const controlProps = {
    disabled,
    required
  };
  ["checked", "name", "onChange", "value", "inputRef"].forEach((key) => {
    if (typeof control.props[key] === "undefined" && typeof props[key] !== "undefined") {
      controlProps[key] = props[key];
    }
  });
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  });
  const ownerState = _extends$2({}, props, {
    disabled,
    labelPlacement,
    required,
    error: fcs.error
  });
  const classes = useUtilityClasses$1q(ownerState);
  const typographySlotProps = (_slotProps$typography = slotProps.typography) != null ? _slotProps$typography : componentsProps.typography;
  let label = labelProp;
  if (label != null && label.type !== Typography$1 && !disableTypography) {
    label = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, _extends$2({
      component: "span"
    }, typographySlotProps, {
      className: clsx(classes.label, typographySlotProps == null ? void 0 : typographySlotProps.className),
      children: label
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControlLabelRoot, _extends$2({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other, {
    children: [/* @__PURE__ */ reactExports.cloneElement(control, controlProps), required ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack$2, {
      direction: "row",
      alignItems: "center",
      children: [label, /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent$1, {
        ownerState,
        "aria-hidden": true,
        className: classes.asterisk,
        children: [" ", "*"]
      })]
    }) : label]
  }));
});
const FormControlLabel$1 = FormControlLabel;
function getFormGroupUtilityClass(slot) {
  return generateUtilityClass("MuiFormGroup", slot);
}
generateUtilityClasses("MuiFormGroup", ["root", "row", "error"]);
const _excluded$1Q = ["className", "row"];
const useUtilityClasses$1p = (ownerState) => {
  const {
    classes,
    row,
    error
  } = ownerState;
  const slots = {
    root: ["root", row && "row", error && "error"]
  };
  return composeClasses(slots, getFormGroupUtilityClass, classes);
};
const FormGroupRoot = styled$1("div", {
  name: "MuiFormGroup",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.row && styles2.row];
  }
})(({
  ownerState
}) => _extends$2({
  display: "flex",
  flexDirection: "column",
  flexWrap: "wrap"
}, ownerState.row && {
  flexDirection: "row"
}));
const FormGroup = /* @__PURE__ */ reactExports.forwardRef(function FormGroup2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormGroup"
  });
  const {
    className,
    row = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1Q);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  });
  const ownerState = _extends$2({}, props, {
    row,
    error: fcs.error
  });
  const classes = useUtilityClasses$1p(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormGroupRoot, _extends$2({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const FormGroup$1 = FormGroup;
function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass("MuiFormHelperText", slot);
}
const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
const formHelperTextClasses$1 = formHelperTextClasses;
var _span$3;
const _excluded$1P = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
const useUtilityClasses$1o = (ownerState) => {
  const {
    classes,
    contained,
    size,
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", error && "error", size && `size${capitalize$1(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
};
const FormHelperTextRoot = styled$1("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.size && styles2[`size${capitalize$1(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.caption, {
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formHelperTextClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}, ownerState.size === "small" && {
  marginTop: 4
}, ownerState.contained && {
  marginLeft: 14,
  marginRight: 14
}));
const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormHelperText"
  });
  const {
    children,
    className,
    component = "p"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1P);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  });
  const ownerState = _extends$2({}, props, {
    component,
    contained: fcs.variant === "filled" || fcs.variant === "outlined",
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$1o(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperTextRoot, _extends$2({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other, {
    children: children === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      _span$3 || (_span$3 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: "notranslate",
        children: "​"
      }))
    ) : children
  }));
});
const FormHelperText$1 = FormHelperText;
function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormLabel", slot);
}
const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
const formLabelClasses$1 = formLabelClasses;
const _excluded$1O = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
const useUtilityClasses$1n = (ownerState) => {
  const {
    classes,
    color: color2,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes);
};
const FormLabelRoot = styled$1("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return _extends$2({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.body1, {
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  [`&.${formLabelClasses$1.focused}`]: {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  },
  [`&.${formLabelClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formLabelClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const AsteriskComponent = styled$1("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (props, styles2) => styles2.asterisk
})(({
  theme: theme2
}) => ({
  [`&.${formLabelClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormLabel"
  });
  const {
    children,
    className,
    component = "label"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1O);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  });
  const ownerState = _extends$2({}, props, {
    color: fcs.color || "primary",
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$1n(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(FormLabelRoot, _extends$2({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other, {
    children: [children, fcs.required && /* @__PURE__ */ jsxRuntimeExports.jsxs(AsteriskComponent, {
      ownerState,
      "aria-hidden": true,
      className: classes.asterisk,
      children: [" ", "*"]
    })]
  }));
});
const FormLabel$1 = FormLabel;
const GridContext = /* @__PURE__ */ reactExports.createContext();
const GridContext$1 = GridContext;
function getGridUtilityClass(slot) {
  return generateUtilityClass("MuiGrid", slot);
}
const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"];
const WRAPS = ["nowrap", "wrap-reverse", "wrap"];
const GRID_SIZES = ["auto", true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
const gridClasses$1 = generateUtilityClasses("MuiGrid", [
  "root",
  "container",
  "item",
  "zeroMinWidth",
  // spacings
  ...SPACINGS.map((spacing) => `spacing-xs-${spacing}`),
  // direction values
  ...DIRECTIONS.map((direction2) => `direction-xs-${direction2}`),
  // wrap values
  ...WRAPS.map((wrap) => `wrap-xs-${wrap}`),
  // grid sizes for all breakpoints
  ...GRID_SIZES.map((size) => `grid-xs-${size}`),
  ...GRID_SIZES.map((size) => `grid-sm-${size}`),
  ...GRID_SIZES.map((size) => `grid-md-${size}`),
  ...GRID_SIZES.map((size) => `grid-lg-${size}`),
  ...GRID_SIZES.map((size) => `grid-xl-${size}`)
]);
const _excluded$1N = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
function getOffset(val) {
  const parse2 = parseFloat(val);
  return `${parse2}${String(val).replace(String(parse2), "") || "px"}`;
}
function generateGrid({
  theme: theme2,
  ownerState
}) {
  let size;
  return theme2.breakpoints.keys.reduce((globalStyles, breakpoint) => {
    let styles2 = {};
    if (ownerState[breakpoint]) {
      size = ownerState[breakpoint];
    }
    if (!size) {
      return globalStyles;
    }
    if (size === true) {
      styles2 = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    } else if (size === "auto") {
      styles2 = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    } else {
      const columnsBreakpointValues = resolveBreakpointValues({
        values: ownerState.columns,
        breakpoints: theme2.breakpoints.values
      });
      const columnValue = typeof columnsBreakpointValues === "object" ? columnsBreakpointValues[breakpoint] : columnsBreakpointValues;
      if (columnValue === void 0 || columnValue === null) {
        return globalStyles;
      }
      const width2 = `${Math.round(size / columnValue * 1e8) / 1e6}%`;
      let more = {};
      if (ownerState.container && ownerState.item && ownerState.columnSpacing !== 0) {
        const themeSpacing = theme2.spacing(ownerState.columnSpacing);
        if (themeSpacing !== "0px") {
          const fullWidth = `calc(${width2} + ${getOffset(themeSpacing)})`;
          more = {
            flexBasis: fullWidth,
            maxWidth: fullWidth
          };
        }
      }
      styles2 = _extends$2({
        flexBasis: width2,
        flexGrow: 0,
        maxWidth: width2
      }, more);
    }
    if (theme2.breakpoints.values[breakpoint] === 0) {
      Object.assign(globalStyles, styles2);
    } else {
      globalStyles[theme2.breakpoints.up(breakpoint)] = styles2;
    }
    return globalStyles;
  }, {});
}
function generateDirection({
  theme: theme2,
  ownerState
}) {
  const directionValues = resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme2.breakpoints.values
  });
  return handleBreakpoints({
    theme: theme2
  }, directionValues, (propValue) => {
    const output = {
      flexDirection: propValue
    };
    if (propValue.indexOf("column") === 0) {
      output[`& > .${gridClasses$1.item}`] = {
        maxWidth: "none"
      };
    }
    return output;
  });
}
function extractZeroValueBreakpointKeys({
  breakpoints,
  values: values2
}) {
  let nonZeroKey = "";
  Object.keys(values2).forEach((key) => {
    if (nonZeroKey !== "") {
      return;
    }
    if (values2[key] !== 0) {
      nonZeroKey = key;
    }
  });
  const sortedBreakpointKeysByValue = Object.keys(breakpoints).sort((a2, b2) => {
    return breakpoints[a2] - breakpoints[b2];
  });
  return sortedBreakpointKeysByValue.slice(0, sortedBreakpointKeysByValue.indexOf(nonZeroKey));
}
function generateRowGap({
  theme: theme2,
  ownerState
}) {
  const {
    container,
    rowSpacing
  } = ownerState;
  let styles2 = {};
  if (container && rowSpacing !== 0) {
    const rowSpacingValues = resolveBreakpointValues({
      values: rowSpacing,
      breakpoints: theme2.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof rowSpacingValues === "object") {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme2.breakpoints.values,
        values: rowSpacingValues
      });
    }
    styles2 = handleBreakpoints({
      theme: theme2
    }, rowSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK;
      const themeSpacing = theme2.spacing(propValue);
      if (themeSpacing !== "0px") {
        return {
          marginTop: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses$1.item}`]: {
            paddingTop: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK.includes(breakpoint)) {
        return {};
      }
      return {
        marginTop: 0,
        [`& > .${gridClasses$1.item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return styles2;
}
function generateColumnGap({
  theme: theme2,
  ownerState
}) {
  const {
    container,
    columnSpacing
  } = ownerState;
  let styles2 = {};
  if (container && columnSpacing !== 0) {
    const columnSpacingValues = resolveBreakpointValues({
      values: columnSpacing,
      breakpoints: theme2.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof columnSpacingValues === "object") {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme2.breakpoints.values,
        values: columnSpacingValues
      });
    }
    styles2 = handleBreakpoints({
      theme: theme2
    }, columnSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK2;
      const themeSpacing = theme2.spacing(propValue);
      if (themeSpacing !== "0px") {
        return {
          width: `calc(100% + ${getOffset(themeSpacing)})`,
          marginLeft: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses$1.item}`]: {
            paddingLeft: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK2 = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK2.includes(breakpoint)) {
        return {};
      }
      return {
        width: "100%",
        marginLeft: 0,
        [`& > .${gridClasses$1.item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return styles2;
}
function resolveSpacingStyles(spacing, breakpoints, styles2 = {}) {
  if (!spacing || spacing <= 0) {
    return [];
  }
  if (typeof spacing === "string" && !Number.isNaN(Number(spacing)) || typeof spacing === "number") {
    return [styles2[`spacing-xs-${String(spacing)}`]];
  }
  const spacingStyles = [];
  breakpoints.forEach((breakpoint) => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      spacingStyles.push(styles2[`spacing-${breakpoint}-${String(value)}`]);
    }
  });
  return spacingStyles;
}
const GridRoot$1 = styled$1("div", {
  name: "MuiGrid",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      container,
      direction: direction2,
      item,
      spacing,
      wrap,
      zeroMinWidth,
      breakpoints
    } = ownerState;
    let spacingStyles = [];
    if (container) {
      spacingStyles = resolveSpacingStyles(spacing, breakpoints, styles2);
    }
    const breakpointsStyles = [];
    breakpoints.forEach((breakpoint) => {
      const value = ownerState[breakpoint];
      if (value) {
        breakpointsStyles.push(styles2[`grid-${breakpoint}-${String(value)}`]);
      }
    });
    return [styles2.root, container && styles2.container, item && styles2.item, zeroMinWidth && styles2.zeroMinWidth, ...spacingStyles, direction2 !== "row" && styles2[`direction-xs-${String(direction2)}`], wrap !== "wrap" && styles2[`wrap-xs-${String(wrap)}`], ...breakpointsStyles];
  }
})(({
  ownerState
}) => _extends$2({
  boxSizing: "border-box"
}, ownerState.container && {
  display: "flex",
  flexWrap: "wrap",
  width: "100%"
}, ownerState.item && {
  margin: 0
  // For instance, it's useful when used with a `figure` element.
}, ownerState.zeroMinWidth && {
  minWidth: 0
}, ownerState.wrap !== "wrap" && {
  flexWrap: ownerState.wrap
}), generateDirection, generateRowGap, generateColumnGap, generateGrid);
function resolveSpacingClasses(spacing, breakpoints) {
  if (!spacing || spacing <= 0) {
    return [];
  }
  if (typeof spacing === "string" && !Number.isNaN(Number(spacing)) || typeof spacing === "number") {
    return [`spacing-xs-${String(spacing)}`];
  }
  const classes = [];
  breakpoints.forEach((breakpoint) => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      const className = `spacing-${breakpoint}-${String(value)}`;
      classes.push(className);
    }
  });
  return classes;
}
const useUtilityClasses$1m = (ownerState) => {
  const {
    classes,
    container,
    direction: direction2,
    item,
    spacing,
    wrap,
    zeroMinWidth,
    breakpoints
  } = ownerState;
  let spacingClasses = [];
  if (container) {
    spacingClasses = resolveSpacingClasses(spacing, breakpoints);
  }
  const breakpointsClasses = [];
  breakpoints.forEach((breakpoint) => {
    const value = ownerState[breakpoint];
    if (value) {
      breakpointsClasses.push(`grid-${breakpoint}-${String(value)}`);
    }
  });
  const slots = {
    root: ["root", container && "container", item && "item", zeroMinWidth && "zeroMinWidth", ...spacingClasses, direction2 !== "row" && `direction-xs-${String(direction2)}`, wrap !== "wrap" && `wrap-xs-${String(wrap)}`, ...breakpointsClasses]
  };
  return composeClasses(slots, getGridUtilityClass, classes);
};
const Grid = /* @__PURE__ */ reactExports.forwardRef(function Grid2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiGrid"
  });
  const {
    breakpoints
  } = useTheme();
  const props = extendSxProp(themeProps);
  const {
    className,
    columns: columnsProp,
    columnSpacing: columnSpacingProp,
    component = "div",
    container = false,
    direction: direction2 = "row",
    item = false,
    rowSpacing: rowSpacingProp,
    spacing = 0,
    wrap = "wrap",
    zeroMinWidth = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1N);
  const rowSpacing = rowSpacingProp || spacing;
  const columnSpacing = columnSpacingProp || spacing;
  const columnsContext = reactExports.useContext(GridContext$1);
  const columns = container ? columnsProp || 12 : columnsContext;
  const breakpointsValues = {};
  const otherFiltered = _extends$2({}, other);
  breakpoints.keys.forEach((breakpoint) => {
    if (other[breakpoint] != null) {
      breakpointsValues[breakpoint] = other[breakpoint];
      delete otherFiltered[breakpoint];
    }
  });
  const ownerState = _extends$2({}, props, {
    columns,
    container,
    direction: direction2,
    item,
    rowSpacing,
    columnSpacing,
    wrap,
    zeroMinWidth,
    spacing
  }, breakpointsValues, {
    breakpoints: breakpoints.keys
  });
  const classes = useUtilityClasses$1m(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridContext$1.Provider, {
    value: columns,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridRoot$1, _extends$2({
      ownerState,
      className: clsx(classes.root, className),
      as: component,
      ref
    }, otherFiltered))
  });
});
const Grid$1 = Grid;
const _excluded$1M = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles$1 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1M);
  const timer = reactExports.useRef();
  const autoTimeout = reactExports.useRef();
  const theme2 = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay : delay || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.current = setTimeout(next2, autoTimeout.current || 0);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(timer.current);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$2({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$2({
        style: _extends$2({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$1[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
Grow.muiSupportAuto = true;
const Grow$1 = Grow;
function useMediaQueryOld(query, defaultMatches, matchMedia2, ssrMatchMedia, noSsr) {
  const [match2, setMatch] = reactExports.useState(() => {
    if (noSsr && matchMedia2) {
      return matchMedia2(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }
    return defaultMatches;
  });
  useEnhancedEffect$1(() => {
    let active = true;
    if (!matchMedia2) {
      return void 0;
    }
    const queryList = matchMedia2(query);
    const updateMatch = () => {
      if (active) {
        setMatch(queryList.matches);
      }
    };
    updateMatch();
    queryList.addListener(updateMatch);
    return () => {
      active = false;
      queryList.removeListener(updateMatch);
    };
  }, [query, matchMedia2]);
  return match2;
}
const maybeReactUseSyncExternalStore = React$1["useSyncExternalStore"];
function useMediaQueryNew(query, defaultMatches, matchMedia2, ssrMatchMedia, noSsr) {
  const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
  const getServerSnapshot = reactExports.useMemo(() => {
    if (noSsr && matchMedia2) {
      return () => matchMedia2(query).matches;
    }
    if (ssrMatchMedia !== null) {
      const {
        matches
      } = ssrMatchMedia(query);
      return () => matches;
    }
    return getDefaultSnapshot;
  }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia2]);
  const [getSnapshot, subscribe] = reactExports.useMemo(() => {
    if (matchMedia2 === null) {
      return [getDefaultSnapshot, () => () => {
      }];
    }
    const mediaQueryList = matchMedia2(query);
    return [() => mediaQueryList.matches, (notify) => {
      mediaQueryList.addListener(notify);
      return () => {
        mediaQueryList.removeListener(notify);
      };
    }];
  }, [getDefaultSnapshot, matchMedia2, query]);
  const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  return match2;
}
function useMediaQuery(queryInput, options = {}) {
  const theme2 = useTheme$3();
  const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
  const {
    defaultMatches = false,
    matchMedia: matchMedia2 = supportMatchMedia ? window.matchMedia : null,
    ssrMatchMedia = null,
    noSsr = false
  } = getThemeProps({
    name: "MuiUseMediaQuery",
    props: options,
    theme: theme2
  });
  let query = typeof queryInput === "function" ? queryInput(theme2) : queryInput;
  query = query.replace(/^@media( ?)/m, "");
  const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
  const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia2, ssrMatchMedia, noSsr);
  return match2;
}
const _excluded$1L = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$1l = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
  return _extends$2({}, classes, composedClasses);
};
const InputRoot = styled$1(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const light2 = theme2.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme2.vars) {
    bottomLineColor = `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})`;
  }
  return _extends$2({
    position: "relative"
  }, ownerState.formControl && {
    "label + &": {
      marginTop: 16
    }
  }, !ownerState.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(theme2.vars || theme2).palette[ownerState.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme2.transitions.create("transform", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${inputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${inputClasses$1.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (theme2.vars || theme2).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme2.transitions.create("border-bottom-color", {
        duration: theme2.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${inputClasses$1.disabled}, .${inputClasses$1.error}):before`]: {
      borderBottom: `2px solid ${(theme2.vars || theme2).palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        borderBottom: `1px solid ${bottomLineColor}`
      }
    },
    [`&.${inputClasses$1.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  });
});
const InputInput = styled$1(InputBaseComponent, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({});
const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiInput"
  });
  const {
    disableUnderline,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type: type2 = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1L);
  const classes = useUtilityClasses$1l(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge$1(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$2({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type: type2
  }, other, {
    classes
  }));
});
Input.muiName = "Input";
const Input$1 = Input;
function getInputAdornmentUtilityClass(slot) {
  return generateUtilityClass("MuiInputAdornment", slot);
}
const inputAdornmentClasses = generateUtilityClasses("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
const inputAdornmentClasses$1 = inputAdornmentClasses;
var _span$2;
const _excluded$1K = ["children", "className", "component", "disablePointerEvents", "disableTypography", "position", "variant"];
const overridesResolver$4 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, styles2[`position${capitalize$1(ownerState.position)}`], ownerState.disablePointerEvents === true && styles2.disablePointerEvents, styles2[ownerState.variant]];
};
const useUtilityClasses$1k = (ownerState) => {
  const {
    classes,
    disablePointerEvents,
    hiddenLabel,
    position: position2,
    size,
    variant
  } = ownerState;
  const slots = {
    root: ["root", disablePointerEvents && "disablePointerEvents", position2 && `position${capitalize$1(position2)}`, variant, hiddenLabel && "hiddenLabel", size && `size${capitalize$1(size)}`]
  };
  return composeClasses(slots, getInputAdornmentUtilityClass, classes);
};
const InputAdornmentRoot = styled$1("div", {
  name: "MuiInputAdornment",
  slot: "Root",
  overridesResolver: overridesResolver$4
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  display: "flex",
  height: "0.01em",
  // Fix IE11 flexbox alignment. To remove at some point.
  maxHeight: "2em",
  alignItems: "center",
  whiteSpace: "nowrap",
  color: (theme2.vars || theme2).palette.action.active
}, ownerState.variant === "filled" && {
  // Styles applied to the root element if `variant="filled"`.
  [`&.${inputAdornmentClasses$1.positionStart}&:not(.${inputAdornmentClasses$1.hiddenLabel})`]: {
    marginTop: 16
  }
}, ownerState.position === "start" && {
  // Styles applied to the root element if `position="start"`.
  marginRight: 8
}, ownerState.position === "end" && {
  // Styles applied to the root element if `position="end"`.
  marginLeft: 8
}, ownerState.disablePointerEvents === true && {
  // Styles applied to the root element if `disablePointerEvents={true}`.
  pointerEvents: "none"
}));
const InputAdornment = /* @__PURE__ */ reactExports.forwardRef(function InputAdornment2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiInputAdornment"
  });
  const {
    children,
    className,
    component = "div",
    disablePointerEvents = false,
    disableTypography = false,
    position: position2,
    variant: variantProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1K);
  const muiFormControl = useFormControl() || {};
  let variant = variantProp;
  if (variantProp && muiFormControl.variant)
    ;
  if (muiFormControl && !variant) {
    variant = muiFormControl.variant;
  }
  const ownerState = _extends$2({}, props, {
    hiddenLabel: muiFormControl.hiddenLabel,
    size: muiFormControl.size,
    disablePointerEvents,
    position: position2,
    variant
  });
  const classes = useUtilityClasses$1k(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
    value: null,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornmentRoot, _extends$2({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other, {
      children: typeof children === "string" && !disableTypography ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
        color: "text.secondary",
        children
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [position2 === "start" ? (
          /* notranslate needed while Google Translate will not fix zero-width space issue */
          _span$2 || (_span$2 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            className: "notranslate",
            children: "​"
          }))
        ) : null, children]
      })
    }))
  });
});
const InputAdornment$1 = InputAdornment;
function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiInputLabel", slot);
}
generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const _excluded$1J = ["disableAnimation", "margin", "shrink", "variant", "className"];
const useUtilityClasses$1j = (ownerState) => {
  const {
    classes,
    formControl,
    size,
    shrink,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink && "shrink", size && size !== "normal" && `size${capitalize$1(size)}`, variant],
    asterisk: [required && "asterisk"]
  };
  const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
  return _extends$2({}, classes, composedClasses);
};
const InputLabelRoot = styled$1(FormLabel$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses$1.asterisk}`]: styles2.asterisk
    }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, styles2[ownerState.variant]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%"
}, ownerState.formControl && {
  position: "absolute",
  left: 0,
  top: 0,
  // slight alteration to spec spacing to match visual spec result
  transform: "translate(0, 20px) scale(1)"
}, ownerState.size === "small" && {
  // Compensation for the `Input.inputSizeSmall` style.
  transform: "translate(0, 17px) scale(1)"
}, ownerState.shrink && {
  transform: "translate(0, -1.5px) scale(0.75)",
  transformOrigin: "top left",
  maxWidth: "133%"
}, !ownerState.disableAnimation && {
  transition: theme2.transitions.create(["color", "transform", "max-width"], {
    duration: theme2.transitions.duration.shorter,
    easing: theme2.transitions.easing.easeOut
  })
}, ownerState.variant === "filled" && _extends$2({
  // Chrome's autofill feature gives the input field a yellow background.
  // Since the input field is behind the label in the HTML tree,
  // the input field is drawn last and hides the label with an opaque background color.
  // zIndex: 1 will raise the label above opaque background-colors of input.
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(12px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 13px) scale(1)"
}, ownerState.shrink && _extends$2({
  userSelect: "none",
  pointerEvents: "auto",
  transform: "translate(12px, 7px) scale(0.75)",
  maxWidth: "calc(133% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 4px) scale(0.75)"
})), ownerState.variant === "outlined" && _extends$2({
  // see comment above on filled.zIndex
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(14px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(14px, 9px) scale(1)"
}, ownerState.shrink && {
  userSelect: "none",
  pointerEvents: "auto",
  // Theoretically, we should have (8+5)*2/0.75 = 34px
  // but it feels a better when it bleeds a bit on the left, so 32px.
  maxWidth: "calc(133% - 32px)",
  transform: "translate(14px, -9px) scale(0.75)"
})));
const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref) {
  const props = useThemeProps({
    name: "MuiInputLabel",
    props: inProps
  });
  const {
    disableAnimation = false,
    shrink: shrinkProp,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1J);
  const muiFormControl = useFormControl();
  let shrink = shrinkProp;
  if (typeof shrink === "undefined" && muiFormControl) {
    shrink = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["size", "variant", "required"]
  });
  const ownerState = _extends$2({}, props, {
    disableAnimation,
    formControl: muiFormControl,
    shrink,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required
  });
  const classes = useUtilityClasses$1j(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputLabelRoot, _extends$2({
    "data-shrink": shrink,
    ownerState,
    ref,
    className: clsx(classes.root, className)
  }, other, {
    classes
  }));
});
const MUIInputLabel = InputLabel;
const ListContext = /* @__PURE__ */ reactExports.createContext({});
const ListContext$1 = ListContext;
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const _excluded$1I = ["children", "className", "component", "dense", "disablePadding", "subheader"];
const useUtilityClasses$1i = (ownerState) => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots, getListUtilityClass, classes);
};
const ListRoot = styled$1("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})(({
  ownerState
}) => _extends$2({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !ownerState.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.subheader && {
  paddingTop: 0
}));
const List = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiList"
  });
  const {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1I);
  const context = reactExports.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = _extends$2({}, props, {
    component,
    dense,
    disablePadding
  });
  const classes = useUtilityClasses$1i(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$2({
      as: component,
      className: clsx(classes.root, className),
      ref,
      ownerState
    }, other, {
      children: [subheader, children]
    }))
  });
});
const List$1 = List;
function getListItemUtilityClass(slot) {
  return generateUtilityClass("MuiListItem", slot);
}
const listItemClasses = generateUtilityClasses("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]);
const listItemClasses$1 = listItemClasses;
function getListItemButtonUtilityClass(slot) {
  return generateUtilityClass("MuiListItemButton", slot);
}
const listItemButtonClasses = generateUtilityClasses("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
const listItemButtonClasses$1 = listItemButtonClasses;
const _excluded$1H = ["alignItems", "autoFocus", "component", "children", "dense", "disableGutters", "divider", "focusVisibleClassName", "selected", "className"];
const overridesResolver$3 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$1h = (ownerState) => {
  const {
    alignItems,
    classes,
    dense,
    disabled,
    disableGutters,
    divider,
    selected
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", divider && "divider", disabled && "disabled", alignItems === "flex-start" && "alignItemsFlexStart", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getListItemButtonUtilityClass, classes);
  return _extends$2({}, classes, composedClasses);
};
const ListItemButtonRoot = styled$1(ButtonBase$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiListItemButton",
  slot: "Root",
  overridesResolver: overridesResolver$3
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  display: "flex",
  flexGrow: 1,
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minWidth: 0,
  boxSizing: "border-box",
  textAlign: "left",
  paddingTop: 8,
  paddingBottom: 8,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  }),
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${listItemButtonClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${listItemButtonClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${listItemButtonClasses$1.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  },
  [`&.${listItemButtonClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${listItemButtonClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  }
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, ownerState.alignItems === "flex-start" && {
  alignItems: "flex-start"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.dense && {
  paddingTop: 4,
  paddingBottom: 4
}));
const ListItemButton = /* @__PURE__ */ reactExports.forwardRef(function ListItemButton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItemButton"
  });
  const {
    alignItems = "center",
    autoFocus = false,
    component = "div",
    children,
    dense = false,
    disableGutters = false,
    divider = false,
    focusVisibleClassName,
    selected = false,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1H);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems,
    disableGutters
  }), [alignItems, context.dense, dense, disableGutters]);
  const listItemRef = reactExports.useRef(null);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      if (listItemRef.current) {
        listItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$2({}, props, {
    alignItems,
    dense: childContext.dense,
    disableGutters,
    divider,
    selected
  });
  const classes = useUtilityClasses$1h(ownerState);
  const handleRef = useForkRef(listItemRef, ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemButtonRoot, _extends$2({
      ref: handleRef,
      href: other.href || other.to,
      component: (other.href || other.to) && component === "div" ? "button" : component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      ownerState,
      className: clsx(classes.root, className)
    }, other, {
      classes,
      children
    }))
  });
});
const ListItemButton$1 = ListItemButton;
function getListItemSecondaryActionClassesUtilityClass(slot) {
  return generateUtilityClass("MuiListItemSecondaryAction", slot);
}
generateUtilityClasses("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const _excluded$1G = ["className"];
const useUtilityClasses$1g = (ownerState) => {
  const {
    disableGutters,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);
};
const ListItemSecondaryActionRoot = styled$1("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
  }
})(({
  ownerState
}) => _extends$2({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)"
}, ownerState.disableGutters && {
  right: 0
}));
const ListItemSecondaryAction = /* @__PURE__ */ reactExports.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItemSecondaryAction"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1G);
  const context = reactExports.useContext(ListContext$1);
  const ownerState = _extends$2({}, props, {
    disableGutters: context.disableGutters
  });
  const classes = useUtilityClasses$1g(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, _extends$2({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
const ListItemSecondaryAction$1 = ListItemSecondaryAction;
const _excluded$1F = ["className"], _excluded2$f = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"];
const overridesResolver$2 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.button && styles2.button, ownerState.hasSecondaryAction && styles2.secondaryAction];
};
const useUtilityClasses$1f = (ownerState) => {
  const {
    alignItems,
    button,
    classes,
    dense,
    disabled,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction,
    selected
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", disabled && "disabled", button && "button", alignItems === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction", selected && "selected"],
    container: ["container"]
  };
  return composeClasses(slots, getListItemUtilityClass, classes);
};
const ListItemRoot = styled$1("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: overridesResolver$2
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left"
}, !ownerState.disablePadding && _extends$2({
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.dense && {
  paddingTop: 4,
  paddingBottom: 4
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, !!ownerState.secondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
}), !!ownerState.secondaryAction && {
  [`& > .${listItemButtonClasses$1.root}`]: {
    paddingRight: 48
  }
}, {
  [`&.${listItemClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${listItemClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${listItemClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${listItemClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  }
}, ownerState.alignItems === "flex-start" && {
  alignItems: "flex-start"
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, ownerState.button && {
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  }),
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${listItemClasses$1.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  }
}, ownerState.hasSecondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
}));
const ListItemContainer = styled$1("li", {
  name: "MuiListItem",
  slot: "Container",
  overridesResolver: (props, styles2) => styles2.container
})({
  position: "relative"
});
const ListItem = /* @__PURE__ */ reactExports.forwardRef(function ListItem2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItem"
  });
  const {
    alignItems = "center",
    autoFocus = false,
    button = false,
    children: childrenProp,
    className,
    component: componentProp,
    components = {},
    componentsProps = {},
    ContainerComponent = "li",
    ContainerProps: {
      className: ContainerClassName
    } = {},
    dense = false,
    disabled = false,
    disableGutters = false,
    disablePadding = false,
    divider = false,
    focusVisibleClassName,
    secondaryAction,
    selected = false,
    slotProps = {},
    slots = {}
  } = props, ContainerProps = _objectWithoutPropertiesLoose$1(props.ContainerProps, _excluded$1F), other = _objectWithoutPropertiesLoose$1(props, _excluded2$f);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems,
    disableGutters
  }), [alignItems, context.dense, dense, disableGutters]);
  const listItemRef = reactExports.useRef(null);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      if (listItemRef.current) {
        listItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const children = reactExports.Children.toArray(childrenProp);
  const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
  const ownerState = _extends$2({}, props, {
    alignItems,
    autoFocus,
    button,
    dense: childContext.dense,
    disabled,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction,
    selected
  });
  const classes = useUtilityClasses$1f(ownerState);
  const handleRef = useForkRef(listItemRef, ref);
  const Root = slots.root || components.Root || ListItemRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const componentProps = _extends$2({
    className: clsx(classes.root, rootProps.className, className),
    disabled
  }, other);
  let Component = componentProp || "li";
  if (button) {
    componentProps.component = componentProp || "div";
    componentProps.focusVisibleClassName = clsx(listItemClasses$1.focusVisible, focusVisibleClassName);
    Component = ButtonBase$1;
  }
  if (hasSecondaryAction) {
    Component = !componentProps.component && !componentProp ? "div" : Component;
    if (ContainerComponent === "li") {
      if (Component === "li") {
        Component = "div";
      } else if (componentProps.component === "li") {
        componentProps.component = "div";
      }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemContainer, _extends$2({
        as: ContainerComponent,
        className: clsx(classes.container, ContainerClassName),
        ref: handleRef,
        ownerState
      }, ContainerProps, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Root, _extends$2({}, rootProps, !isHostComponent(Root) && {
          as: Component,
          ownerState: _extends$2({}, ownerState, rootProps.ownerState)
        }, componentProps, {
          children
        })), children.pop()]
      }))
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$2({}, rootProps, {
      as: Component,
      ref: handleRef
    }, !isHostComponent(Root) && {
      ownerState: _extends$2({}, ownerState, rootProps.ownerState)
    }, componentProps, {
      children: [children, secondaryAction && /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemSecondaryAction$1, {
        children: secondaryAction
      })]
    }))
  });
});
const ListItem$1 = ListItem;
function getListItemIconUtilityClass(slot) {
  return generateUtilityClass("MuiListItemIcon", slot);
}
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const listItemIconClasses$1 = listItemIconClasses;
const _excluded$1E = ["className"];
const useUtilityClasses$1e = (ownerState) => {
  const {
    alignItems,
    classes
  } = ownerState;
  const slots = {
    root: ["root", alignItems === "flex-start" && "alignItemsFlexStart"]
  };
  return composeClasses(slots, getListItemIconUtilityClass, classes);
};
const ListItemIconRoot = styled$1("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  minWidth: 56,
  color: (theme2.vars || theme2).palette.action.active,
  flexShrink: 0,
  display: "inline-flex"
}, ownerState.alignItems === "flex-start" && {
  marginTop: 8
}));
const ListItemIcon = /* @__PURE__ */ reactExports.forwardRef(function ListItemIcon2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItemIcon"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1E);
  const context = reactExports.useContext(ListContext$1);
  const ownerState = _extends$2({}, props, {
    alignItems: context.alignItems
  });
  const classes = useUtilityClasses$1e(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIconRoot, _extends$2({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const ListItemIcon$1 = ListItemIcon;
function getListItemTextUtilityClass(slot) {
  return generateUtilityClass("MuiListItemText", slot);
}
const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
const listItemTextClasses$1 = listItemTextClasses;
const _excluded$1D = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"];
const useUtilityClasses$1d = (ownerState) => {
  const {
    classes,
    inset,
    primary,
    secondary,
    dense
  } = ownerState;
  const slots = {
    root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  };
  return composeClasses(slots, getListItemTextUtilityClass, classes);
};
const ListItemTextRoot = styled$1("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${listItemTextClasses$1.primary}`]: styles2.primary
    }, {
      [`& .${listItemTextClasses$1.secondary}`]: styles2.secondary
    }, styles2.root, ownerState.inset && styles2.inset, ownerState.primary && ownerState.secondary && styles2.multiline, ownerState.dense && styles2.dense];
  }
})(({
  ownerState
}) => _extends$2({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4
}, ownerState.primary && ownerState.secondary && {
  marginTop: 6,
  marginBottom: 6
}, ownerState.inset && {
  paddingLeft: 56
}));
const ListItemText = /* @__PURE__ */ reactExports.forwardRef(function ListItemText2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItemText"
  });
  const {
    children,
    className,
    disableTypography = false,
    inset = false,
    primary: primaryProp,
    primaryTypographyProps,
    secondary: secondaryProp,
    secondaryTypographyProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1D);
  const {
    dense
  } = reactExports.useContext(ListContext$1);
  let primary = primaryProp != null ? primaryProp : children;
  let secondary = secondaryProp;
  const ownerState = _extends$2({}, props, {
    disableTypography,
    inset,
    primary: !!primary,
    secondary: !!secondary,
    dense
  });
  const classes = useUtilityClasses$1d(ownerState);
  if (primary != null && primary.type !== Typography$1 && !disableTypography) {
    primary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, _extends$2({
      variant: dense ? "body2" : "body1",
      className: classes.primary,
      component: primaryTypographyProps != null && primaryTypographyProps.variant ? void 0 : "span",
      display: "block"
    }, primaryTypographyProps, {
      children: primary
    }));
  }
  if (secondary != null && secondary.type !== Typography$1 && !disableTypography) {
    secondary = /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, _extends$2({
      variant: "body2",
      className: classes.secondary,
      color: "text.secondary",
      display: "block"
    }, secondaryTypographyProps, {
      children: secondary
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ListItemTextRoot, _extends$2({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other, {
    children: [primary, secondary]
  }));
});
const ListItemText$1 = ListItemText;
const _excluded$1C = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem$1(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem$1(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.indexOf(textCriteria.keys.join("")) === 0;
}
function moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1C);
  const listRef = reactExports.useRef(null);
  const textCriteriaRef = reactExports.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useImperativeHandle(actions, () => ({
    adjustStyleForScrollbar: (containerElement, theme2) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
        listRef.current.style[theme2.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown2 = (event) => {
    const list = listRef.current;
    const key = event.key;
    const currentFocus = ownerDocument(list).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus$1(list, currentFocus, false, disabledItemsFocusable, nextItem$1, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef(listRef, ref);
  let activeItemIndex = -1;
  reactExports.Children.forEach(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      if (activeItemIndex === index2) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
    if (activeItemIndex === index2 && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = reactExports.Children.map(children, (child, index2) => {
    if (index2 === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, _extends$2({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown2,
    tabIndex: autoFocus ? 0 : -1
  }, other, {
    children: items
  }));
});
const MenuList$1 = MenuList;
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const _excluded$1B = ["onEntering"], _excluded2$e = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"], _excluded3$4 = ["slotProps"];
function getOffsetTop(rect, vertical) {
  let offset2 = 0;
  if (typeof vertical === "number") {
    offset2 = vertical;
  } else if (vertical === "center") {
    offset2 = rect.height / 2;
  } else if (vertical === "bottom") {
    offset2 = rect.height;
  }
  return offset2;
}
function getOffsetLeft(rect, horizontal) {
  let offset2 = 0;
  if (typeof horizontal === "number") {
    offset2 = horizontal;
  } else if (horizontal === "center") {
    offset2 = rect.width / 2;
  } else if (horizontal === "right") {
    offset2 = rect.width;
  }
  return offset2;
}
function getTransformOriginValue(transformOrigin2) {
  return [transformOrigin2.horizontal, transformOrigin2.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$1c = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled$1(Modal$1, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const PopoverPaper = styled$1(MuiPaper, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
  var _slotProps$paper, _slots$root, _slots$paper;
  const props = useThemeProps({
    props: inProps,
    name: "MuiPopover"
  });
  const {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open: open2,
    PaperProps: PaperPropsProp = {},
    slots,
    slotProps,
    transformOrigin: transformOrigin2 = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent = Grow$1,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps: {
      onEntering
    } = {},
    disableScrollLock = false
  } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$1B), other = _objectWithoutPropertiesLoose$1(props, _excluded2$e);
  const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
  const paperRef = reactExports.useRef();
  const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
  const ownerState = _extends$2({}, props, {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    externalPaperSlotProps,
    transformOrigin: transformOrigin2,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  });
  const classes = useUtilityClasses$1c(ownerState);
  const getAnchorOffset = reactExports.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = reactExports.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin2.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin2.horizontal)
    };
  }, [transformOrigin2.horizontal, transformOrigin2.vertical]);
  const getPositioningStyle = reactExports.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top2 = anchorOffset.top - elemTransformOrigin.vertical;
    let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom2 = top2 + elemRect.height;
    const right2 = left2 + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top2 < marginThreshold) {
      const diff = top2 - marginThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom2 > heightThreshold) {
      const diff = bottom2 - heightThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left2 < marginThreshold) {
      const diff = left2 - marginThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right2 > widthThreshold) {
      const diff = right2 - widthThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top2)}px`,
      left: `${Math.round(left2)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = reactExports.useState(open2);
  const setPositioningStyles = reactExports.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  reactExports.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = (element, isAppearing) => {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  reactExports.useEffect(() => {
    if (open2) {
      setPositioningStyles();
    }
  });
  reactExports.useImperativeHandle(action, () => open2 ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open2, setPositioningStyles]);
  reactExports.useEffect(() => {
    if (!open2) {
      return void 0;
    }
    const handleResize = debounce$1(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(anchorEl);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open2, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
  const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
  const paperProps = useSlotProps({
    elementType: PaperSlot,
    externalSlotProps: _extends$2({}, externalPaperSlotProps, {
      style: isPositioned ? externalPaperSlotProps.style : _extends$2({}, externalPaperSlotProps.style, {
        opacity: 0
      })
    }),
    additionalProps: {
      elevation,
      ref: handlePaperRef
    },
    ownerState,
    className: clsx(classes.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
  });
  const _useSlotProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
    externalForwardedProps: other,
    additionalProps: {
      ref,
      slotProps: {
        backdrop: {
          invisible: true
        }
      },
      container,
      open: open2
    },
    ownerState,
    className: clsx(classes.root, className)
  }), {
    slotProps: rootSlotPropsProp
  } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded3$4);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends$2({}, rootProps, !isHostComponent(RootSlot) && {
    slotProps: rootSlotPropsProp,
    disableScrollLock
  }, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$2({
      appear: true,
      in: open2,
      onEntering: handleEntering,
      onExited: handleExited,
      timeout: transitionDuration
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends$2({}, paperProps, {
        children
      }))
    }))
  }));
});
const Popover$1 = Popover;
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const _excluded$1A = ["onEntering"], _excluded2$d = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$1b = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled$1(Popover$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const MenuPaper = styled$1(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled$1(MenuList$1, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (props, styles2) => styles2.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref) {
  var _slots$paper, _slotProps$paper;
  const props = useThemeProps({
    props: inProps,
    name: "MuiMenu"
  });
  const {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open: open2,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering
    } = {},
    variant = "selectedMenu",
    slots = {},
    slotProps = {}
  } = props, TransitionProps = _objectWithoutPropertiesLoose$1(props.TransitionProps, _excluded$1A), other = _objectWithoutPropertiesLoose$1(props, _excluded2$d);
  const theme2 = useTheme();
  const isRtl = theme2.direction === "rtl";
  const ownerState = _extends$2({}, props, {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  });
  const classes = useUtilityClasses$1b(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open2;
  const menuListActionsRef = reactExports.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, theme2);
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  reactExports.Children.map(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
  const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
  const rootSlotProps = useSlotProps({
    elementType: slots.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes.root, className]
  });
  const paperSlotProps = useSlotProps({
    elementType: PaperSlot,
    externalSlotProps: paperExternalSlotProps,
    ownerState,
    className: classes.paper
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$2({
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: {
      paper: PaperSlot,
      root: slots.root
    },
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps
    },
    open: open2,
    ref,
    transitionDuration,
    TransitionProps: _extends$2({
      onEntering: handleEntering
    }, TransitionProps),
    ownerState
  }, other, {
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$2({
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant
    }, MenuListProps, {
      className: clsx(classes.list, MenuListProps.className),
      children
    }))
  }));
});
const Menu$1 = Menu;
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const menuItemClasses$1 = menuItemClasses;
const _excluded$1z = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
const overridesResolver$1 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$1a = (ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
  return _extends$2({}, classes, composedClasses);
};
const MenuItemRoot = styled$1(ButtonBase$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver: overridesResolver$1
})(({
  theme: theme2,
  ownerState
}) => _extends$2({}, theme2.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${menuItemClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses$1.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${menuItemClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses$1.root}`]: {
    marginTop: theme2.spacing(1),
    marginBottom: theme2.spacing(1)
  },
  [`& + .${dividerClasses$1.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses$1.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses$1.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses$1.root}`]: {
    minWidth: 36
  }
}, !ownerState.dense && {
  [theme2.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, ownerState.dense && _extends$2({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, theme2.typography.body2, {
  [`& .${listItemIconClasses$1.root} svg`]: {
    fontSize: "1.25rem"
  }
})));
const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1z);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = reactExports.useRef(null);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$2({}, props, {
    dense: childContext.dense,
    divider,
    disableGutters
  });
  const classes = useUtilityClasses$1a(props);
  const handleRef = useForkRef(menuItemRef, ref);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$2({
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      className: clsx(classes.root, className)
    }, other, {
      ownerState,
      classes
    }))
  });
});
const MenuItem$1 = MenuItem;
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiNativeSelect", slot);
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const nativeSelectClasses$1 = nativeSelectClasses;
const _excluded$1y = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
const useUtilityClasses$19 = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open: open2,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize$1(variant)}`, open2 && "iconOpen", disabled && "disabled"]
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes);
};
const nativeSelectSelectStyles = ({
  ownerState,
  theme: theme2
}) => _extends$2({
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  borderRadius: 0,
  // Reset
  cursor: "pointer",
  "&:focus": _extends$2({}, theme2.vars ? {
    backgroundColor: `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.05)`
  } : {
    backgroundColor: theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
  }, {
    borderRadius: 0
    // Reset Chrome style
  }),
  // Remove IE11 arrow
  "&::-ms-expand": {
    display: "none"
  },
  [`&.${nativeSelectClasses$1.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (theme2.vars || theme2).palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  "&&&": {
    paddingRight: 24,
    minWidth: 16
    // So it doesn't collapse.
  }
}, ownerState.variant === "filled" && {
  "&&&": {
    paddingRight: 32
  }
}, ownerState.variant === "outlined" && {
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  "&:focus": {
    borderRadius: (theme2.vars || theme2).shape.borderRadius
    // Reset the reset for Chrome style
  },
  "&&&": {
    paddingRight: 32
  }
});
const NativeSelectSelect = styled$1("select", {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
      [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple
    }];
  }
})(nativeSelectSelectStyles);
const nativeSelectIconStyles = ({
  ownerState,
  theme: theme2
}) => _extends$2({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  top: "calc(50% - .5em)",
  // Center vertically, height is 1em
  pointerEvents: "none",
  // Don't block pointer events on the select under the icon.
  color: (theme2.vars || theme2).palette.action.active,
  [`&.${nativeSelectClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  }
}, ownerState.open && {
  transform: "rotate(180deg)"
}, ownerState.variant === "filled" && {
  right: 7
}, ownerState.variant === "outlined" && {
  right: 7
});
const NativeSelectIcon = styled$1("svg", {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
  const {
    className,
    disabled,
    error,
    IconComponent,
    inputRef,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1y);
  const ownerState = _extends$2({}, props, {
    disabled,
    variant,
    error
  });
  const classes = useUtilityClasses$19(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, _extends$2({
      ownerState,
      className: clsx(classes.select, className),
      disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes.icon
    })]
  });
});
const NativeSelectInput$1 = NativeSelectInput;
var _span$1;
const _excluded$1x = ["children", "classes", "className", "label", "notched"];
const NotchedOutlineRoot$1 = styled$1("fieldset")({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
});
const NotchedOutlineLegend = styled$1("legend")(({
  ownerState,
  theme: theme2
}) => _extends$2({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden"
}, !ownerState.withLabel && {
  padding: 0,
  lineHeight: "11px",
  // sync with `height` in `legend` styles
  transition: theme2.transitions.create("width", {
    duration: 150,
    easing: theme2.transitions.easing.easeOut
  })
}, ownerState.withLabel && _extends$2({
  display: "block",
  // Fix conflict with normalize.css and sanitize.css
  padding: 0,
  height: 11,
  // sync with `lineHeight` in `legend` styles
  fontSize: "0.75em",
  visibility: "hidden",
  maxWidth: 0.01,
  transition: theme2.transitions.create("max-width", {
    duration: 50,
    easing: theme2.transitions.easing.easeOut
  }),
  whiteSpace: "nowrap",
  "& > span": {
    paddingLeft: 5,
    paddingRight: 5,
    display: "inline-block",
    opacity: 0,
    visibility: "visible"
  }
}, ownerState.notched && {
  maxWidth: "100%",
  transition: theme2.transitions.create("max-width", {
    duration: 100,
    easing: theme2.transitions.easing.easeOut,
    delay: 50
  })
})));
function NotchedOutline(props) {
  const {
    className,
    label,
    notched
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1x);
  const withLabel = label != null && label !== "";
  const ownerState = _extends$2({}, props, {
    notched,
    withLabel
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends$2({
    "aria-hidden": true,
    className,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      )
    })
  }));
}
const _excluded$1w = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
const useUtilityClasses$18 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
  return _extends$2({}, classes, composedClasses);
};
const OutlinedInputRoot = styled$1(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return _extends$2({
    position: "relative",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
        borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      }
    },
    [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette[ownerState.color].main,
      borderWidth: 2
    },
    [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.error.main
    },
    [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.action.disabled
    }
  }, ownerState.startAdornment && {
    paddingLeft: 14
  }, ownerState.endAdornment && {
    paddingRight: 14
  }, ownerState.multiline && _extends$2({
    padding: "16.5px 14px"
  }, ownerState.size === "small" && {
    padding: "8.5px 14px"
  }));
});
const NotchedOutlineRoot = styled$1(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (props, styles2) => styles2.notchedOutline
})(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
  };
});
const OutlinedInputInput = styled$1(InputBaseComponent, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  padding: "16.5px 14px"
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}, theme2.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  padding: "8.5px 14px"
}, ownerState.multiline && {
  padding: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}));
const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
  const props = useThemeProps({
    props: inProps,
    name: "MuiOutlinedInput"
  });
  const {
    components = {},
    fullWidth = false,
    inputComponent = "input",
    label,
    multiline = false,
    notched,
    slots = {},
    type: type2 = "text"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1w);
  const classes = useUtilityClasses$18(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  });
  const ownerState = _extends$2({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type: type2
  });
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$2({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
      ownerState,
      className: classes.notchedOutline,
      label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, " ", "*"]
      })) : label,
      notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type: type2
  }, other, {
    classes: _extends$2({}, classes, {
      notchedOutline: null
    })
  }));
});
OutlinedInput.muiName = "Input";
const OutlinedInput$1 = OutlinedInput;
const FirstPageIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage");
const LastPageIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage");
const RadioButtonUncheckedIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "RadioButtonUnchecked");
const RadioButtonCheckedIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
}), "RadioButtonChecked");
const RadioButtonIconRoot = styled$1("span")({
  position: "relative",
  display: "flex"
});
const RadioButtonIconBackground = styled$1(RadioButtonUncheckedIcon)({
  // Scale applied to prevent dot misalignment in Safari
  transform: "scale(1)"
});
const RadioButtonIconDot = styled$1(RadioButtonCheckedIcon)(({
  theme: theme2,
  ownerState
}) => _extends$2({
  left: 0,
  position: "absolute",
  transform: "scale(0)",
  transition: theme2.transitions.create("transform", {
    easing: theme2.transitions.easing.easeIn,
    duration: theme2.transitions.duration.shortest
  })
}, ownerState.checked && {
  transform: "scale(1)",
  transition: theme2.transitions.create("transform", {
    easing: theme2.transitions.easing.easeOut,
    duration: theme2.transitions.duration.shortest
  })
}));
function RadioButtonIcon(props) {
  const {
    checked = false,
    classes = {},
    fontSize: fontSize2
  } = props;
  const ownerState = _extends$2({}, props, {
    checked
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioButtonIconRoot, {
    className: classes.root,
    ownerState,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RadioButtonIconBackground, {
      fontSize: fontSize2,
      className: classes.background,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(RadioButtonIconDot, {
      fontSize: fontSize2,
      className: classes.dot,
      ownerState
    })]
  });
}
const RadioGroupContext = /* @__PURE__ */ reactExports.createContext(void 0);
const RadioGroupContext$1 = RadioGroupContext;
function useRadioGroup() {
  return reactExports.useContext(RadioGroupContext$1);
}
function getRadioUtilityClass(slot) {
  return generateUtilityClass("MuiRadio", slot);
}
const radioClasses = generateUtilityClasses("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]);
const radioClasses$1 = radioClasses;
const _excluded$1v = ["checked", "checkedIcon", "color", "icon", "name", "onChange", "size", "className"];
const useUtilityClasses$17 = (ownerState) => {
  const {
    classes,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize$1(color2)}`, size !== "medium" && `size${capitalize$1(size)}`]
  };
  return _extends$2({}, classes, composeClasses(slots, getRadioUtilityClass, classes));
};
const RadioRoot = styled$1(SwitchBase$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiRadio",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  color: (theme2.vars || theme2).palette.text.secondary
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${ownerState.color === "default" ? theme2.vars.palette.action.activeChannel : theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === "default" ? theme2.palette.action.active : theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.color !== "default" && {
  [`&.${radioClasses$1.checked}`]: {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  }
}, {
  [`&.${radioClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  }
}));
function areEqualValues$1(a2, b2) {
  if (typeof b2 === "object" && b2 !== null) {
    return a2 === b2;
  }
  return String(a2) === String(b2);
}
const defaultCheckedIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(RadioButtonIcon, {
  checked: true
});
const defaultIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(RadioButtonIcon, {});
const Radio = /* @__PURE__ */ reactExports.forwardRef(function Radio2(inProps, ref) {
  var _defaultIcon$props$fo, _defaultCheckedIcon$p;
  const props = useThemeProps({
    props: inProps,
    name: "MuiRadio"
  });
  const {
    checked: checkedProp,
    checkedIcon = defaultCheckedIcon,
    color: color2 = "primary",
    icon = defaultIcon,
    name: nameProp,
    onChange: onChangeProp,
    size = "medium",
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1v);
  const ownerState = _extends$2({}, props, {
    color: color2,
    size
  });
  const classes = useUtilityClasses$17(ownerState);
  const radioGroup = useRadioGroup();
  let checked = checkedProp;
  const onChange = createChainedFunction(onChangeProp, radioGroup && radioGroup.onChange);
  let name = nameProp;
  if (radioGroup) {
    if (typeof checked === "undefined") {
      checked = areEqualValues$1(radioGroup.value, props.value);
    }
    if (typeof name === "undefined") {
      name = radioGroup.name;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioRoot, _extends$2({
    type: "radio",
    icon: /* @__PURE__ */ reactExports.cloneElement(icon, {
      fontSize: (_defaultIcon$props$fo = defaultIcon.props.fontSize) != null ? _defaultIcon$props$fo : size
    }),
    checkedIcon: /* @__PURE__ */ reactExports.cloneElement(checkedIcon, {
      fontSize: (_defaultCheckedIcon$p = defaultCheckedIcon.props.fontSize) != null ? _defaultCheckedIcon$p : size
    }),
    ownerState,
    classes,
    name,
    checked,
    onChange,
    ref,
    className: clsx(classes.root, className)
  }, other));
});
const Radio$1 = Radio;
const _excluded$1u = ["actions", "children", "defaultValue", "name", "onChange", "value"];
const RadioGroup = /* @__PURE__ */ reactExports.forwardRef(function RadioGroup2(props, ref) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions,
    children,
    defaultValue,
    name: nameProp,
    onChange,
    value: valueProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1u);
  const rootRef = reactExports.useRef(null);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "RadioGroup"
  });
  reactExports.useImperativeHandle(actions, () => ({
    focus: () => {
      let input = rootRef.current.querySelector("input:not(:disabled):checked");
      if (!input) {
        input = rootRef.current.querySelector("input:not(:disabled)");
      }
      if (input) {
        input.focus();
      }
    }
  }), []);
  const handleRef = useForkRef(ref, rootRef);
  const name = useId(nameProp);
  const contextValue = reactExports.useMemo(() => ({
    name,
    onChange(event) {
      setValueState(event.target.value);
      if (onChange) {
        onChange(event, event.target.value);
      }
    },
    value
  }), [name, onChange, setValueState, value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupContext$1.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormGroup$1, _extends$2({
      role: "radiogroup",
      ref: handleRef
    }, other, {
      children
    }))
  });
});
const RadioGroup$1 = RadioGroup;
function getSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiSelect", slot);
}
const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const selectClasses$1 = selectClasses;
var _span;
const _excluded$1t = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
const SelectSelect = styled$1("div", {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [
      // Win specificity over the input base
      {
        [`&.${selectClasses$1.select}`]: styles2.select
      },
      {
        [`&.${selectClasses$1.select}`]: styles2[ownerState.variant]
      },
      {
        [`&.${selectClasses$1.error}`]: styles2.error
      },
      {
        [`&.${selectClasses$1.multiple}`]: styles2.multiple
      }
    ];
  }
})(nativeSelectSelectStyles, {
  // Win specificity over the input base
  [`&.${selectClasses$1.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
});
const SelectIcon = styled$1("svg", {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize$1(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const SelectNativeInput = styled$1("input", {
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (props, styles2) => styles2.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a2, b2) {
  if (typeof b2 === "object" && b2 !== null) {
    return a2 === b2;
  }
  return String(a2) === String(b2);
}
function isEmpty$1(display2) {
  return display2 == null || typeof display2 === "string" && !display2.trim();
}
const useUtilityClasses$16 = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open: open2,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize$1(variant)}`, open2 && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
};
const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
  var _MenuProps$slotProps;
  const {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    error = false,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    value: valueProp,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1t);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  });
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  });
  const inputRef = reactExports.useRef(null);
  const displayRef = reactExports.useRef(null);
  const [displayNode, setDisplayNode] = reactExports.useState(null);
  const {
    current: isOpenControlled
  } = reactExports.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
  const handleRef = useForkRef(ref, inputRefProp);
  const handleDisplayRef = reactExports.useCallback((node2) => {
    displayRef.current = node2;
    if (node2) {
      setDisplayNode(node2);
    }
  }, []);
  const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
  reactExports.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  reactExports.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      displayRef.current.focus();
    }
  }, [displayNode, autoWidth]);
  reactExports.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useEffect(() => {
    if (!labelId) {
      return void 0;
    }
    const label = ownerDocument(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };
      label.addEventListener("click", handler);
      return () => {
        label.removeEventListener("click", handler);
      };
    }
    return void 0;
  }, [labelId]);
  const update2 = (open3, event) => {
    if (open3) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      setOpenState(open3);
    }
  };
  const handleMouseDown = (event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    displayRef.current.focus();
    update2(true, event);
  };
  const handleClose = (event) => {
    update2(false, event);
  };
  const childrenArray = reactExports.Children.toArray(children);
  const handleChange = (event) => {
    const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
    if (child === void 0) {
      return;
    }
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  };
  const handleItemClick = (child) => (event) => {
    let newValue;
    if (!event.currentTarget.hasAttribute("tabindex")) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value: newValue,
            name
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update2(false, event);
    }
  };
  const handleKeyDown2 = (event) => {
    if (!readOnly) {
      const validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ];
      if (validKeys.indexOf(event.key) !== -1) {
        event.preventDefault();
        update2(true, event);
      }
    }
  };
  const open2 = displayNode !== null && openState;
  const handleBlur = (event) => {
    if (!open2 && onBlur) {
      Object.defineProperty(event, "target", {
        writable: true,
        value: {
          value,
          name
        }
      });
      onBlur(event);
    }
  };
  delete other["aria-invalid"];
  let display2;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display2 = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage(2));
      }
      selected = value.some((v2) => areEqualValues(v2, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        if (event.key === " ") {
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: "option",
      selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display2 = null;
      } else {
        display2 = displayMultiple.reduce((output, child, index2) => {
          output.push(child);
          if (index2 < displayMultiple.length - 1) {
            output.push(", ");
          }
          return output;
        }, []);
      }
    } else {
      display2 = displaySingle;
    }
  }
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = anchorElement.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
  const ownerState = _extends$2({}, props, {
    variant,
    value,
    open: open2,
    error
  });
  const classes = useUtilityClasses$16(ownerState);
  const paperProps = _extends$2({}, MenuProps.PaperProps, (_MenuProps$slotProps = MenuProps.slotProps) == null ? void 0 : _MenuProps$slotProps.paper);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, _extends$2({
      ref: handleDisplayRef,
      tabIndex,
      role: "button",
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open2 ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      onKeyDown: handleKeyDown2,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus
    }, SelectDisplayProps, {
      ownerState,
      className: clsx(SelectDisplayProps.className, classes.select, className),
      id: buttonId,
      children: isEmpty$1(display2) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      ) : display2
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, _extends$2({
      "aria-invalid": error,
      value: Array.isArray(value) ? value.join(",") : value,
      name,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes.nativeInput,
      autoFocus,
      ownerState
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, _extends$2({
      id: `menu-${name || ""}`,
      anchorEl: anchorElement,
      open: open2,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, MenuProps, {
      MenuListProps: _extends$2({
        "aria-labelledby": labelId,
        role: "listbox",
        "aria-multiselectable": multiple ? "true" : void 0,
        disableListWrap: true
      }, MenuProps.MenuListProps),
      slotProps: {
        paper: _extends$2({}, paperProps, {
          style: _extends$2({
            minWidth: menuMinWidth
          }, paperProps != null ? paperProps.style : null)
        })
      },
      children: items
    }))]
  });
});
const SelectInput$1 = SelectInput;
const _excluded$1s = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], _excluded2$c = ["root"];
const useUtilityClasses$15 = (ownerState) => {
  const {
    classes
  } = ownerState;
  return classes;
};
const styledRootConfig = {
  name: "MuiSelect",
  overridesResolver: (props, styles2) => styles2.root,
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
  slot: "Root"
};
const StyledInput = styled$1(Input$1, styledRootConfig)("");
const StyledOutlinedInput = styled$1(OutlinedInput$1, styledRootConfig)("");
const StyledFilledInput = styled$1(FilledInput$1, styledRootConfig)("");
const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
  const props = useThemeProps({
    name: "MuiSelect",
    props: inProps
  });
  const {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = false,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon$1,
    id: id2,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open: open2,
    renderValue,
    SelectDisplayProps,
    variant: variantProp = "outlined"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1s);
  const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "error"]
  });
  const variant = fcs.variant || variantProp;
  const ownerState = _extends$2({}, props, {
    variant,
    classes: classesProp
  });
  const classes = useUtilityClasses$15(ownerState);
  const restOfClasses = _objectWithoutPropertiesLoose$1(classes, _excluded2$c);
  const InputComponent = input || {
    standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
      ownerState
    }),
    outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
      label,
      ownerState
    }),
    filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
      ownerState
    })
  }[variant];
  const inputComponentRef = useForkRef(ref, InputComponent.ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, _extends$2({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: _extends$2({
        children,
        error: fcs.error,
        IconComponent,
        variant,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple
      }, native ? {
        id: id2
      } : {
        autoWidth,
        defaultOpen,
        displayEmpty,
        labelId,
        MenuProps,
        onClose,
        onOpen,
        open: open2,
        renderValue,
        SelectDisplayProps: _extends$2({
          id: id2
        }, SelectDisplayProps)
      }, inputProps, {
        classes: inputProps ? deepmerge$1(restOfClasses, inputProps.classes) : restOfClasses
      }, input ? input.props.inputProps : {})
    }, multiple && native && variant === "outlined" ? {
      notched: true
    } : {}, {
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className, classes.root)
    }, !input && {
      variant
    }, other))
  });
});
Select.muiName = "Select";
const Select$1 = Select;
function getSkeletonUtilityClass(slot) {
  return generateUtilityClass("MuiSkeleton", slot);
}
generateUtilityClasses("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
const _excluded$1r = ["animation", "className", "component", "height", "style", "variant", "width"];
let _$5 = (t3) => t3, _t$3, _t2, _t3, _t4;
const useUtilityClasses$14 = (ownerState) => {
  const {
    classes,
    variant,
    animation,
    hasChildren,
    width: width2,
    height: height2
  } = ownerState;
  const slots = {
    root: ["root", variant, animation, hasChildren && "withChildren", hasChildren && !width2 && "fitContent", hasChildren && !height2 && "heightAuto"]
  };
  return composeClasses(slots, getSkeletonUtilityClass, classes);
};
const pulseKeyframe = keyframes(_t$3 || (_t$3 = _$5`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`));
const waveKeyframe = keyframes(_t2 || (_t2 = _$5`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`));
const SkeletonRoot = styled$1("span", {
  name: "MuiSkeleton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.animation !== false && styles2[ownerState.animation], ownerState.hasChildren && styles2.withChildren, ownerState.hasChildren && !ownerState.width && styles2.fitContent, ownerState.hasChildren && !ownerState.height && styles2.heightAuto];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const radiusUnit = getUnit(theme2.shape.borderRadius) || "px";
  const radiusValue = toUnitless(theme2.shape.borderRadius);
  return _extends$2({
    display: "block",
    // Create a "on paper" color with sufficient contrast retaining the color
    backgroundColor: theme2.vars ? theme2.vars.palette.Skeleton.bg : alpha(theme2.palette.text.primary, theme2.palette.mode === "light" ? 0.11 : 0.13),
    height: "1.2em"
  }, ownerState.variant === "text" && {
    marginTop: 0,
    marginBottom: 0,
    height: "auto",
    transformOrigin: "0 55%",
    transform: "scale(1, 0.60)",
    borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
    "&:empty:before": {
      content: '"\\00a0"'
    }
  }, ownerState.variant === "circular" && {
    borderRadius: "50%"
  }, ownerState.variant === "rounded" && {
    borderRadius: (theme2.vars || theme2).shape.borderRadius
  }, ownerState.hasChildren && {
    "& > *": {
      visibility: "hidden"
    }
  }, ownerState.hasChildren && !ownerState.width && {
    maxWidth: "fit-content"
  }, ownerState.hasChildren && !ownerState.height && {
    height: "auto"
  });
}, ({
  ownerState
}) => ownerState.animation === "pulse" && css(_t3 || (_t3 = _$5`
      animation: ${0} 2s ease-in-out 0.5s infinite;
    `), pulseKeyframe), ({
  ownerState,
  theme: theme2
}) => ownerState.animation === "wave" && css(_t4 || (_t4 = _$5`
      position: relative;
      overflow: hidden;

      /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
      -webkit-mask-image: -webkit-radial-gradient(white, black);

      &::after {
        animation: ${0} 2s linear 0.5s infinite;
        background: linear-gradient(
          90deg,
          transparent,
          ${0},
          transparent
        );
        content: '';
        position: absolute;
        transform: translateX(-100%); /* Avoid flash during server-side hydration */
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
      }
    `), waveKeyframe, (theme2.vars || theme2).palette.action.hover));
const Skeleton = /* @__PURE__ */ reactExports.forwardRef(function Skeleton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSkeleton"
  });
  const {
    animation = "pulse",
    className,
    component = "span",
    height: height2,
    style: style2,
    variant = "text",
    width: width2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1r);
  const ownerState = _extends$2({}, props, {
    animation,
    component,
    variant,
    hasChildren: Boolean(other.children)
  });
  const classes = useUtilityClasses$14(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonRoot, _extends$2({
    as: component,
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    style: _extends$2({
      width: width2,
      height: height2
    }, style2)
  }));
});
const Skeleton$1 = Skeleton;
const shouldSpreadAdditionalProps = (Slot) => {
  return !Slot || !isHostComponent(Slot);
};
const shouldSpreadAdditionalProps$1 = shouldSpreadAdditionalProps;
function getSliderUtilityClass(slot) {
  return generateUtilityClass("MuiSlider", slot);
}
const sliderClasses = generateUtilityClasses("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]);
const sliderClasses$1 = sliderClasses;
const useValueLabelClasses = (props) => {
  const {
    open: open2
  } = props;
  const utilityClasses = {
    offset: clsx(open2 && sliderClasses$1.valueLabelOpen),
    circle: sliderClasses$1.valueLabelCircle,
    label: sliderClasses$1.valueLabelLabel
  };
  return utilityClasses;
};
function SliderValueLabel$1(props) {
  const {
    children,
    className,
    value
  } = props;
  const classes = useValueLabelClasses(props);
  if (!children) {
    return null;
  }
  return /* @__PURE__ */ reactExports.cloneElement(children, {
    className: clsx(children.props.className)
  }, /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [children.props.children, /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: clsx(classes.offset, className),
      "aria-hidden": true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: classes.circle,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
const _excluded$1q = ["aria-label", "aria-valuetext", "aria-labelledby", "component", "components", "componentsProps", "color", "classes", "className", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "size", "step", "scale", "slotProps", "slots", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat"];
function Identity(x2) {
  return x2;
}
const SliderRoot = styled$1("span", {
  name: "MuiSlider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize$1(ownerState.color)}`], ownerState.size !== "medium" && styles2[`size${capitalize$1(ownerState.size)}`], ownerState.marked && styles2.marked, ownerState.orientation === "vertical" && styles2.vertical, ownerState.track === "inverted" && styles2.trackInverted, ownerState.track === false && styles2.trackFalse];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  borderRadius: 12,
  boxSizing: "content-box",
  display: "inline-block",
  position: "relative",
  cursor: "pointer",
  touchAction: "none",
  color: (theme2.vars || theme2).palette[ownerState.color].main,
  WebkitTapHighlightColor: "transparent"
}, ownerState.orientation === "horizontal" && _extends$2({
  height: 4,
  width: "100%",
  padding: "13px 0",
  // The primary input mechanism of the device includes a pointing device of limited accuracy.
  "@media (pointer: coarse)": {
    // Reach 42px touch target, about ~8mm on screen.
    padding: "20px 0"
  }
}, ownerState.size === "small" && {
  height: 2
}, ownerState.marked && {
  marginBottom: 20
}), ownerState.orientation === "vertical" && _extends$2({
  height: "100%",
  width: 4,
  padding: "0 13px",
  // The primary input mechanism of the device includes a pointing device of limited accuracy.
  "@media (pointer: coarse)": {
    // Reach 42px touch target, about ~8mm on screen.
    padding: "0 20px"
  }
}, ownerState.size === "small" && {
  width: 2
}, ownerState.marked && {
  marginRight: 44
}), {
  "@media print": {
    colorAdjust: "exact"
  },
  [`&.${sliderClasses$1.disabled}`]: {
    pointerEvents: "none",
    cursor: "default",
    color: (theme2.vars || theme2).palette.grey[400]
  },
  [`&.${sliderClasses$1.dragging}`]: {
    [`& .${sliderClasses$1.thumb}, & .${sliderClasses$1.track}`]: {
      transition: "none"
    }
  }
}));
const SliderRail = styled$1("span", {
  name: "MuiSlider",
  slot: "Rail",
  overridesResolver: (props, styles2) => styles2.rail
})(({
  ownerState
}) => _extends$2({
  display: "block",
  position: "absolute",
  borderRadius: "inherit",
  backgroundColor: "currentColor",
  opacity: 0.38
}, ownerState.orientation === "horizontal" && {
  width: "100%",
  height: "inherit",
  top: "50%",
  transform: "translateY(-50%)"
}, ownerState.orientation === "vertical" && {
  height: "100%",
  width: "inherit",
  left: "50%",
  transform: "translateX(-50%)"
}, ownerState.track === "inverted" && {
  opacity: 1
}));
const SliderTrack = styled$1("span", {
  name: "MuiSlider",
  slot: "Track",
  overridesResolver: (props, styles2) => styles2.track
})(({
  theme: theme2,
  ownerState
}) => {
  const color2 = (
    // Same logic as the LinearProgress track color
    theme2.palette.mode === "light" ? lighten(theme2.palette[ownerState.color].main, 0.62) : darken(theme2.palette[ownerState.color].main, 0.5)
  );
  return _extends$2({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: theme2.transitions.create(["left", "width", "bottom", "height"], {
      duration: theme2.transitions.duration.shortest
    })
  }, ownerState.size === "small" && {
    border: "none"
  }, ownerState.orientation === "horizontal" && {
    height: "inherit",
    top: "50%",
    transform: "translateY(-50%)"
  }, ownerState.orientation === "vertical" && {
    width: "inherit",
    left: "50%",
    transform: "translateX(-50%)"
  }, ownerState.track === false && {
    display: "none"
  }, ownerState.track === "inverted" && {
    backgroundColor: theme2.vars ? theme2.vars.palette.Slider[`${ownerState.color}Track`] : color2,
    borderColor: theme2.vars ? theme2.vars.palette.Slider[`${ownerState.color}Track`] : color2
  });
});
const SliderThumb = styled$1("span", {
  name: "MuiSlider",
  slot: "Thumb",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.thumb, styles2[`thumbColor${capitalize$1(ownerState.color)}`], ownerState.size !== "medium" && styles2[`thumbSize${capitalize$1(ownerState.size)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  position: "absolute",
  width: 20,
  height: 20,
  boxSizing: "border-box",
  borderRadius: "50%",
  outline: 0,
  backgroundColor: "currentColor",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  transition: theme2.transitions.create(["box-shadow", "left", "bottom"], {
    duration: theme2.transitions.duration.shortest
  })
}, ownerState.size === "small" && {
  width: 12,
  height: 12
}, ownerState.orientation === "horizontal" && {
  top: "50%",
  transform: "translate(-50%, -50%)"
}, ownerState.orientation === "vertical" && {
  left: "50%",
  transform: "translate(-50%, 50%)"
}, {
  "&:before": _extends$2({
    position: "absolute",
    content: '""',
    borderRadius: "inherit",
    width: "100%",
    height: "100%",
    boxShadow: (theme2.vars || theme2).shadows[2]
  }, ownerState.size === "small" && {
    boxShadow: "none"
  }),
  "&::after": {
    position: "absolute",
    content: '""',
    borderRadius: "50%",
    // 42px is the hit target
    width: 42,
    height: 42,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)"
  },
  [`&:hover, &.${sliderClasses$1.focusVisible}`]: {
    boxShadow: `0px 0px 0px 8px ${theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.16)` : alpha(theme2.palette[ownerState.color].main, 0.16)}`,
    "@media (hover: none)": {
      boxShadow: "none"
    }
  },
  [`&.${sliderClasses$1.active}`]: {
    boxShadow: `0px 0px 0px 14px ${theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.16)` : alpha(theme2.palette[ownerState.color].main, 0.16)}`
  },
  [`&.${sliderClasses$1.disabled}`]: {
    "&:hover": {
      boxShadow: "none"
    }
  }
}));
const SliderValueLabel = styled$1(SliderValueLabel$1, {
  name: "MuiSlider",
  slot: "ValueLabel",
  overridesResolver: (props, styles2) => styles2.valueLabel
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  [`&.${sliderClasses$1.valueLabelOpen}`]: {
    transform: `${ownerState.orientation === "vertical" ? "translateY(-50%)" : "translateY(-100%)"} scale(1)`
  },
  zIndex: 1,
  whiteSpace: "nowrap"
}, theme2.typography.body2, {
  fontWeight: 500,
  transition: theme2.transitions.create(["transform"], {
    duration: theme2.transitions.duration.shortest
  }),
  transform: `${ownerState.orientation === "vertical" ? "translateY(-50%)" : "translateY(-100%)"} scale(0)`,
  position: "absolute",
  backgroundColor: (theme2.vars || theme2).palette.grey[600],
  borderRadius: 2,
  color: (theme2.vars || theme2).palette.common.white,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  padding: "0.25rem 0.75rem"
}, ownerState.orientation === "horizontal" && {
  top: "-10px",
  transformOrigin: "bottom center",
  "&:before": {
    position: "absolute",
    content: '""',
    width: 8,
    height: 8,
    transform: "translate(-50%, 50%) rotate(45deg)",
    backgroundColor: "inherit",
    bottom: 0,
    left: "50%"
  }
}, ownerState.orientation === "vertical" && {
  right: ownerState.size === "small" ? "20px" : "30px",
  top: "50%",
  transformOrigin: "right center",
  "&:before": {
    position: "absolute",
    content: '""',
    width: 8,
    height: 8,
    transform: "translate(-50%, -50%) rotate(45deg)",
    backgroundColor: "inherit",
    right: -8,
    top: "50%"
  }
}, ownerState.size === "small" && {
  fontSize: theme2.typography.pxToRem(12),
  padding: "0.25rem 0.5rem"
}));
const SliderMark = styled$1("span", {
  name: "MuiSlider",
  slot: "Mark",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markActive",
  overridesResolver: (props, styles2) => {
    const {
      markActive
    } = props;
    return [styles2.mark, markActive && styles2.markActive];
  }
})(({
  theme: theme2,
  ownerState,
  markActive
}) => _extends$2({
  position: "absolute",
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: "currentColor"
}, ownerState.orientation === "horizontal" && {
  top: "50%",
  transform: "translate(-1px, -50%)"
}, ownerState.orientation === "vertical" && {
  left: "50%",
  transform: "translate(-50%, 1px)"
}, markActive && {
  backgroundColor: (theme2.vars || theme2).palette.background.paper,
  opacity: 0.8
}));
const SliderMarkLabel = styled$1("span", {
  name: "MuiSlider",
  slot: "MarkLabel",
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "markLabelActive",
  overridesResolver: (props, styles2) => styles2.markLabel
})(({
  theme: theme2,
  ownerState,
  markLabelActive
}) => _extends$2({}, theme2.typography.body2, {
  color: (theme2.vars || theme2).palette.text.secondary,
  position: "absolute",
  whiteSpace: "nowrap"
}, ownerState.orientation === "horizontal" && {
  top: 30,
  transform: "translateX(-50%)",
  "@media (pointer: coarse)": {
    top: 40
  }
}, ownerState.orientation === "vertical" && {
  left: 36,
  transform: "translateY(50%)",
  "@media (pointer: coarse)": {
    left: 44
  }
}, markLabelActive && {
  color: (theme2.vars || theme2).palette.text.primary
}));
const useUtilityClasses$13 = (ownerState) => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes,
    color: color2,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse", color2 && `color${capitalize$1(color2)}`, size && `size${capitalize$1(size)}`],
    rail: ["rail"],
    track: ["track"],
    mark: ["mark"],
    markActive: ["markActive"],
    markLabel: ["markLabel"],
    markLabelActive: ["markLabelActive"],
    valueLabel: ["valueLabel"],
    thumb: ["thumb", disabled && "disabled", size && `thumbSize${capitalize$1(size)}`, color2 && `thumbColor${capitalize$1(color2)}`],
    active: ["active"],
    disabled: ["disabled"],
    focusVisible: ["focusVisible"]
  };
  return composeClasses(slots, getSliderUtilityClass, classes);
};
const Forward = ({
  children
}) => children;
const Slider = /* @__PURE__ */ reactExports.forwardRef(function Slider2(inputProps, ref) {
  var _ref, _slots$root, _ref2, _slots$rail, _ref3, _slots$track, _ref4, _slots$thumb, _ref5, _slots$valueLabel, _ref6, _slots$mark, _ref7, _slots$markLabel, _ref8, _slots$input, _slotProps$root, _slotProps$rail, _slotProps$track, _slotProps$thumb, _slotProps$valueLabel, _slotProps$mark, _slotProps$markLabel, _slotProps$input;
  const props = useThemeProps({
    props: inputProps,
    name: "MuiSlider"
  });
  const theme2 = useTheme();
  const isRtl = theme2.direction === "rtl";
  const {
    "aria-label": ariaLabel,
    "aria-valuetext": ariaValuetext,
    "aria-labelledby": ariaLabelledby,
    // eslint-disable-next-line react/prop-types
    component = "span",
    components = {},
    componentsProps = {},
    color: color2 = "primary",
    classes: classesProp,
    className,
    disableSwap = false,
    disabled = false,
    getAriaLabel,
    getAriaValueText,
    marks: marksProp = false,
    max: max2 = 100,
    min: min2 = 0,
    orientation = "horizontal",
    size = "medium",
    step = 1,
    scale = Identity,
    slotProps,
    slots,
    track = "normal",
    valueLabelDisplay = "off",
    valueLabelFormat = Identity
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1q);
  const ownerState = _extends$2({}, props, {
    isRtl,
    max: max2,
    min: min2,
    classes: classesProp,
    disabled,
    disableSwap,
    orientation,
    marks: marksProp,
    color: color2,
    size,
    step,
    scale,
    track,
    valueLabelDisplay,
    valueLabelFormat
  });
  const {
    axisProps: axisProps2,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open: open2,
    active,
    axis,
    focusedThumbIndex,
    range,
    dragging,
    marks,
    values: values2,
    trackOffset,
    trackLeap,
    getThumbStyle
  } = useSlider(_extends$2({}, ownerState, {
    rootRef: ref
  }));
  ownerState.marked = marks.length > 0 && marks.some((mark) => mark.label);
  ownerState.dragging = dragging;
  ownerState.focusedThumbIndex = focusedThumbIndex;
  const classes = useUtilityClasses$13(ownerState);
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : SliderRoot;
  const RailSlot = (_ref2 = (_slots$rail = slots == null ? void 0 : slots.rail) != null ? _slots$rail : components.Rail) != null ? _ref2 : SliderRail;
  const TrackSlot = (_ref3 = (_slots$track = slots == null ? void 0 : slots.track) != null ? _slots$track : components.Track) != null ? _ref3 : SliderTrack;
  const ThumbSlot = (_ref4 = (_slots$thumb = slots == null ? void 0 : slots.thumb) != null ? _slots$thumb : components.Thumb) != null ? _ref4 : SliderThumb;
  const ValueLabelSlot = (_ref5 = (_slots$valueLabel = slots == null ? void 0 : slots.valueLabel) != null ? _slots$valueLabel : components.ValueLabel) != null ? _ref5 : SliderValueLabel;
  const MarkSlot = (_ref6 = (_slots$mark = slots == null ? void 0 : slots.mark) != null ? _slots$mark : components.Mark) != null ? _ref6 : SliderMark;
  const MarkLabelSlot = (_ref7 = (_slots$markLabel = slots == null ? void 0 : slots.markLabel) != null ? _slots$markLabel : components.MarkLabel) != null ? _ref7 : SliderMarkLabel;
  const InputSlot = (_ref8 = (_slots$input = slots == null ? void 0 : slots.input) != null ? _slots$input : components.Input) != null ? _ref8 : "input";
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const railSlotProps = (_slotProps$rail = slotProps == null ? void 0 : slotProps.rail) != null ? _slotProps$rail : componentsProps.rail;
  const trackSlotProps = (_slotProps$track = slotProps == null ? void 0 : slotProps.track) != null ? _slotProps$track : componentsProps.track;
  const thumbSlotProps = (_slotProps$thumb = slotProps == null ? void 0 : slotProps.thumb) != null ? _slotProps$thumb : componentsProps.thumb;
  const valueLabelSlotProps = (_slotProps$valueLabel = slotProps == null ? void 0 : slotProps.valueLabel) != null ? _slotProps$valueLabel : componentsProps.valueLabel;
  const markSlotProps = (_slotProps$mark = slotProps == null ? void 0 : slotProps.mark) != null ? _slotProps$mark : componentsProps.mark;
  const markLabelSlotProps = (_slotProps$markLabel = slotProps == null ? void 0 : slotProps.markLabel) != null ? _slotProps$markLabel : componentsProps.markLabel;
  const inputSlotProps = (_slotProps$input = slotProps == null ? void 0 : slotProps.input) != null ? _slotProps$input : componentsProps.input;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    getSlotProps: getRootProps,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: _extends$2({}, shouldSpreadAdditionalProps$1(RootSlot) && {
      as: component
    }),
    ownerState: _extends$2({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
    className: [classes.root, className]
  });
  const railProps = useSlotProps({
    elementType: RailSlot,
    externalSlotProps: railSlotProps,
    ownerState,
    className: classes.rail
  });
  const trackProps = useSlotProps({
    elementType: TrackSlot,
    externalSlotProps: trackSlotProps,
    additionalProps: {
      style: _extends$2({}, axisProps2[axis].offset(trackOffset), axisProps2[axis].leap(trackLeap))
    },
    ownerState: _extends$2({}, ownerState, trackSlotProps == null ? void 0 : trackSlotProps.ownerState),
    className: classes.track
  });
  const thumbProps = useSlotProps({
    elementType: ThumbSlot,
    getSlotProps: getThumbProps,
    externalSlotProps: thumbSlotProps,
    ownerState: _extends$2({}, ownerState, thumbSlotProps == null ? void 0 : thumbSlotProps.ownerState),
    className: classes.thumb
  });
  const valueLabelProps = useSlotProps({
    elementType: ValueLabelSlot,
    externalSlotProps: valueLabelSlotProps,
    ownerState: _extends$2({}, ownerState, valueLabelSlotProps == null ? void 0 : valueLabelSlotProps.ownerState),
    className: classes.valueLabel
  });
  const markProps = useSlotProps({
    elementType: MarkSlot,
    externalSlotProps: markSlotProps,
    ownerState,
    className: classes.mark
  });
  const markLabelProps = useSlotProps({
    elementType: MarkLabelSlot,
    externalSlotProps: markLabelSlotProps,
    ownerState,
    className: classes.markLabel
  });
  const inputSliderProps = useSlotProps({
    elementType: InputSlot,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: inputSlotProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$2({}, rootProps, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RailSlot, _extends$2({}, railProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(TrackSlot, _extends$2({}, trackProps)), marks.filter((mark) => mark.value >= min2 && mark.value <= max2).map((mark, index2) => {
      const percent = valueToPercent(mark.value, min2, max2);
      const style2 = axisProps2[axis].offset(percent);
      let markActive;
      if (track === false) {
        markActive = values2.indexOf(mark.value) !== -1;
      } else {
        markActive = track === "normal" && (range ? mark.value >= values2[0] && mark.value <= values2[values2.length - 1] : mark.value <= values2[0]) || track === "inverted" && (range ? mark.value <= values2[0] || mark.value >= values2[values2.length - 1] : mark.value >= values2[0]);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(MarkSlot, _extends$2({
          "data-index": index2
        }, markProps, !isHostComponent(MarkSlot) && {
          markActive
        }, {
          style: _extends$2({}, style2, markProps.style),
          className: clsx(markProps.className, markActive && classes.markActive)
        })), mark.label != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(MarkLabelSlot, _extends$2({
          "aria-hidden": true,
          "data-index": index2
        }, markLabelProps, !isHostComponent(MarkLabelSlot) && {
          markLabelActive: markActive
        }, {
          style: _extends$2({}, style2, markLabelProps.style),
          className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        })) : null]
      }, index2);
    }), values2.map((value, index2) => {
      const percent = valueToPercent(value, min2, max2);
      const style2 = axisProps2[axis].offset(percent);
      const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabelSlot;
      return (
        /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
        /* @__PURE__ */ jsxRuntimeExports.jsx(ValueLabelComponent, _extends$2({}, !isHostComponent(ValueLabelComponent) && {
          valueLabelFormat,
          valueLabelDisplay,
          value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index2) : valueLabelFormat,
          index: index2,
          open: open2 === index2 || active === index2 || valueLabelDisplay === "on",
          disabled
        }, valueLabelProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThumbSlot, _extends$2({
            "data-index": index2
          }, thumbProps, {
            className: clsx(classes.thumb, thumbProps.className, active === index2 && classes.active, focusedThumbIndex === index2 && classes.focusVisible),
            style: _extends$2({}, style2, getThumbStyle(index2), thumbProps.style),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(InputSlot, _extends$2({
              "data-index": index2,
              "aria-label": getAriaLabel ? getAriaLabel(index2) : ariaLabel,
              "aria-valuenow": scale(value),
              "aria-labelledby": ariaLabelledby,
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index2) : ariaValuetext,
              value: values2[index2]
            }, inputSliderProps))
          }))
        }), index2)
      );
    })]
  }));
});
const Slider$1 = Slider;
function getTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiTooltip", slot);
}
const tooltipClasses = generateUtilityClasses("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
const tooltipClasses$1 = tooltipClasses;
const _excluded$1p = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "slotProps", "slots", "title", "TransitionComponent", "TransitionProps"];
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const useUtilityClasses$12 = (ownerState) => {
  const {
    classes,
    disableInteractive,
    arrow: arrow2,
    touch,
    placement
  } = ownerState;
  const slots = {
    popper: ["popper", !disableInteractive && "popperInteractive", arrow2 && "popperArrow"],
    tooltip: ["tooltip", arrow2 && "tooltipArrow", touch && "touch", `tooltipPlacement${capitalize$1(placement.split("-")[0])}`],
    arrow: ["arrow"]
  };
  return composeClasses(slots, getTooltipUtilityClass, classes);
};
const TooltipPopper = styled$1(MuiPopper, {
  name: "MuiTooltip",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.popper, !ownerState.disableInteractive && styles2.popperInteractive, ownerState.arrow && styles2.popperArrow, !ownerState.open && styles2.popperClose];
  }
})(({
  theme: theme2,
  ownerState,
  open: open2
}) => _extends$2({
  zIndex: (theme2.vars || theme2).zIndex.tooltip,
  pointerEvents: "none"
}, !ownerState.disableInteractive && {
  pointerEvents: "auto"
}, !open2 && {
  pointerEvents: "none"
}, ownerState.arrow && {
  [`&[data-popper-placement*="bottom"] .${tooltipClasses$1.arrow}`]: {
    top: 0,
    marginTop: "-0.71em",
    "&::before": {
      transformOrigin: "0 100%"
    }
  },
  [`&[data-popper-placement*="top"] .${tooltipClasses$1.arrow}`]: {
    bottom: 0,
    marginBottom: "-0.71em",
    "&::before": {
      transformOrigin: "100% 0"
    }
  },
  [`&[data-popper-placement*="right"] .${tooltipClasses$1.arrow}`]: _extends$2({}, !ownerState.isRtl ? {
    left: 0,
    marginLeft: "-0.71em"
  } : {
    right: 0,
    marginRight: "-0.71em"
  }, {
    height: "1em",
    width: "0.71em",
    "&::before": {
      transformOrigin: "100% 100%"
    }
  }),
  [`&[data-popper-placement*="left"] .${tooltipClasses$1.arrow}`]: _extends$2({}, !ownerState.isRtl ? {
    right: 0,
    marginRight: "-0.71em"
  } : {
    left: 0,
    marginLeft: "-0.71em"
  }, {
    height: "1em",
    width: "0.71em",
    "&::before": {
      transformOrigin: "0 0"
    }
  })
}));
const TooltipTooltip = styled$1("div", {
  name: "MuiTooltip",
  slot: "Tooltip",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.tooltip, ownerState.touch && styles2.touch, ownerState.arrow && styles2.tooltipArrow, styles2[`tooltipPlacement${capitalize$1(ownerState.placement.split("-")[0])}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  backgroundColor: theme2.vars ? theme2.vars.palette.Tooltip.bg : alpha(theme2.palette.grey[700], 0.92),
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  color: (theme2.vars || theme2).palette.common.white,
  fontFamily: theme2.typography.fontFamily,
  padding: "4px 8px",
  fontSize: theme2.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: "break-word",
  fontWeight: theme2.typography.fontWeightMedium
}, ownerState.arrow && {
  position: "relative",
  margin: 0
}, ownerState.touch && {
  padding: "8px 16px",
  fontSize: theme2.typography.pxToRem(14),
  lineHeight: `${round(16 / 14)}em`,
  fontWeight: theme2.typography.fontWeightRegular
}, {
  [`.${tooltipClasses$1.popper}[data-popper-placement*="left"] &`]: _extends$2({
    transformOrigin: "right center"
  }, !ownerState.isRtl ? _extends$2({
    marginRight: "14px"
  }, ownerState.touch && {
    marginRight: "24px"
  }) : _extends$2({
    marginLeft: "14px"
  }, ownerState.touch && {
    marginLeft: "24px"
  })),
  [`.${tooltipClasses$1.popper}[data-popper-placement*="right"] &`]: _extends$2({
    transformOrigin: "left center"
  }, !ownerState.isRtl ? _extends$2({
    marginLeft: "14px"
  }, ownerState.touch && {
    marginLeft: "24px"
  }) : _extends$2({
    marginRight: "14px"
  }, ownerState.touch && {
    marginRight: "24px"
  })),
  [`.${tooltipClasses$1.popper}[data-popper-placement*="top"] &`]: _extends$2({
    transformOrigin: "center bottom",
    marginBottom: "14px"
  }, ownerState.touch && {
    marginBottom: "24px"
  }),
  [`.${tooltipClasses$1.popper}[data-popper-placement*="bottom"] &`]: _extends$2({
    transformOrigin: "center top",
    marginTop: "14px"
  }, ownerState.touch && {
    marginTop: "24px"
  })
}));
const TooltipArrow = styled$1("span", {
  name: "MuiTooltip",
  slot: "Arrow",
  overridesResolver: (props, styles2) => styles2.arrow
})(({
  theme: theme2
}) => ({
  overflow: "hidden",
  position: "absolute",
  width: "1em",
  height: "0.71em",
  boxSizing: "border-box",
  color: theme2.vars ? theme2.vars.palette.Tooltip.bg : alpha(theme2.palette.grey[700], 0.9),
  "&::before": {
    content: '""',
    margin: "auto",
    display: "block",
    width: "100%",
    height: "100%",
    backgroundColor: "currentColor",
    transform: "rotate(45deg)"
  }
}));
let hystersisOpen = false;
let hystersisTimer = null;
let cursorPosition = {
  x: 0,
  y: 0
};
function composeEventHandler(handler, eventHandler) {
  return (event) => {
    if (eventHandler) {
      eventHandler(event);
    }
    handler(event);
  };
}
const Tooltip = /* @__PURE__ */ reactExports.forwardRef(function Tooltip2(inProps, ref) {
  var _ref, _slots$popper, _ref2, _ref3, _slots$transition, _ref4, _slots$tooltip, _ref5, _slots$arrow, _slotProps$popper, _ref6, _slotProps$popper2, _slotProps$transition, _slotProps$tooltip, _ref7, _slotProps$tooltip2, _slotProps$arrow, _ref8, _slotProps$arrow2;
  const props = useThemeProps({
    props: inProps,
    name: "MuiTooltip"
  });
  const {
    arrow: arrow2 = false,
    children: childrenProp,
    components = {},
    componentsProps = {},
    describeChild = false,
    disableFocusListener = false,
    disableHoverListener = false,
    disableInteractive: disableInteractiveProp = false,
    disableTouchListener = false,
    enterDelay = 100,
    enterNextDelay = 0,
    enterTouchDelay = 700,
    followCursor = false,
    id: idProp,
    leaveDelay = 0,
    leaveTouchDelay = 1500,
    onClose,
    onOpen,
    open: openProp,
    placement = "bottom",
    PopperComponent: PopperComponentProp,
    PopperProps = {},
    slotProps = {},
    slots = {},
    title,
    TransitionComponent: TransitionComponentProp = Grow$1,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1p);
  const children = /* @__PURE__ */ reactExports.isValidElement(childrenProp) ? childrenProp : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    children: childrenProp
  });
  const theme2 = useTheme();
  const isRtl = theme2.direction === "rtl";
  const [childNode, setChildNode] = reactExports.useState();
  const [arrowRef, setArrowRef] = reactExports.useState(null);
  const ignoreNonTouchEvents = reactExports.useRef(false);
  const disableInteractive = disableInteractiveProp || followCursor;
  const closeTimer = reactExports.useRef();
  const enterTimer = reactExports.useRef();
  const leaveTimer = reactExports.useRef();
  const touchTimer = reactExports.useRef();
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: "Tooltip",
    state: "open"
  });
  let open2 = openState;
  const id2 = useId(idProp);
  const prevUserSelect = reactExports.useRef();
  const stopTouchInteraction = reactExports.useCallback(() => {
    if (prevUserSelect.current !== void 0) {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      prevUserSelect.current = void 0;
    }
    clearTimeout(touchTimer.current);
  }, []);
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(closeTimer.current);
      clearTimeout(enterTimer.current);
      clearTimeout(leaveTimer.current);
      stopTouchInteraction();
    };
  }, [stopTouchInteraction]);
  const handleOpen = (event) => {
    clearTimeout(hystersisTimer);
    hystersisOpen = true;
    setOpenState(true);
    if (onOpen && !open2) {
      onOpen(event);
    }
  };
  const handleClose = useEventCallback$1(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    (event) => {
      clearTimeout(hystersisTimer);
      hystersisTimer = setTimeout(() => {
        hystersisOpen = false;
      }, 800 + leaveDelay);
      setOpenState(false);
      if (onClose && open2) {
        onClose(event);
      }
      clearTimeout(closeTimer.current);
      closeTimer.current = setTimeout(() => {
        ignoreNonTouchEvents.current = false;
      }, theme2.transitions.duration.shortest);
    }
  );
  const handleEnter = (event) => {
    if (ignoreNonTouchEvents.current && event.type !== "touchstart") {
      return;
    }
    if (childNode) {
      childNode.removeAttribute("title");
    }
    clearTimeout(enterTimer.current);
    clearTimeout(leaveTimer.current);
    if (enterDelay || hystersisOpen && enterNextDelay) {
      enterTimer.current = setTimeout(() => {
        handleOpen(event);
      }, hystersisOpen ? enterNextDelay : enterDelay);
    } else {
      handleOpen(event);
    }
  };
  const handleLeave = (event) => {
    clearTimeout(enterTimer.current);
    clearTimeout(leaveTimer.current);
    leaveTimer.current = setTimeout(() => {
      handleClose(event);
    }, leaveDelay);
  };
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [, setChildIsFocusVisible] = reactExports.useState(false);
  const handleBlur = (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setChildIsFocusVisible(false);
      handleLeave(event);
    }
  };
  const handleFocus = (event) => {
    if (!childNode) {
      setChildNode(event.currentTarget);
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setChildIsFocusVisible(true);
      handleEnter(event);
    }
  };
  const detectTouchStart = (event) => {
    ignoreNonTouchEvents.current = true;
    const childrenProps2 = children.props;
    if (childrenProps2.onTouchStart) {
      childrenProps2.onTouchStart(event);
    }
  };
  const handleMouseOver = handleEnter;
  const handleMouseLeave = handleLeave;
  const handleTouchStart = (event) => {
    detectTouchStart(event);
    clearTimeout(leaveTimer.current);
    clearTimeout(closeTimer.current);
    stopTouchInteraction();
    prevUserSelect.current = document.body.style.WebkitUserSelect;
    document.body.style.WebkitUserSelect = "none";
    touchTimer.current = setTimeout(() => {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      handleEnter(event);
    }, enterTouchDelay);
  };
  const handleTouchEnd = (event) => {
    if (children.props.onTouchEnd) {
      children.props.onTouchEnd(event);
    }
    stopTouchInteraction();
    clearTimeout(leaveTimer.current);
    leaveTimer.current = setTimeout(() => {
      handleClose(event);
    }, leaveTouchDelay);
  };
  reactExports.useEffect(() => {
    if (!open2) {
      return void 0;
    }
    function handleKeyDown2(nativeEvent) {
      if (nativeEvent.key === "Escape" || nativeEvent.key === "Esc") {
        handleClose(nativeEvent);
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [handleClose, open2]);
  const handleRef = useForkRef(children.ref, focusVisibleRef, setChildNode, ref);
  if (!title && title !== 0) {
    open2 = false;
  }
  const popperRef = reactExports.useRef();
  const handleMouseMove = (event) => {
    const childrenProps2 = children.props;
    if (childrenProps2.onMouseMove) {
      childrenProps2.onMouseMove(event);
    }
    cursorPosition = {
      x: event.clientX,
      y: event.clientY
    };
    if (popperRef.current) {
      popperRef.current.update();
    }
  };
  const nameOrDescProps = {};
  const titleIsString = typeof title === "string";
  if (describeChild) {
    nameOrDescProps.title = !open2 && titleIsString && !disableHoverListener ? title : null;
    nameOrDescProps["aria-describedby"] = open2 ? id2 : null;
  } else {
    nameOrDescProps["aria-label"] = titleIsString ? title : null;
    nameOrDescProps["aria-labelledby"] = open2 && !titleIsString ? id2 : null;
  }
  const childrenProps = _extends$2({}, nameOrDescProps, other, children.props, {
    className: clsx(other.className, children.props.className),
    onTouchStart: detectTouchStart,
    ref: handleRef
  }, followCursor ? {
    onMouseMove: handleMouseMove
  } : {});
  const interactiveWrapperListeners = {};
  if (!disableTouchListener) {
    childrenProps.onTouchStart = handleTouchStart;
    childrenProps.onTouchEnd = handleTouchEnd;
  }
  if (!disableHoverListener) {
    childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
    childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);
    if (!disableInteractive) {
      interactiveWrapperListeners.onMouseOver = handleMouseOver;
      interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
    }
  }
  if (!disableFocusListener) {
    childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
    childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);
    if (!disableInteractive) {
      interactiveWrapperListeners.onFocus = handleFocus;
      interactiveWrapperListeners.onBlur = handleBlur;
    }
  }
  const popperOptions = reactExports.useMemo(() => {
    var _PopperProps$popperOp;
    let tooltipModifiers = [{
      name: "arrow",
      enabled: Boolean(arrowRef),
      options: {
        element: arrowRef,
        padding: 4
      }
    }];
    if ((_PopperProps$popperOp = PopperProps.popperOptions) != null && _PopperProps$popperOp.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
    }
    return _extends$2({}, PopperProps.popperOptions, {
      modifiers: tooltipModifiers
    });
  }, [arrowRef, PopperProps]);
  const ownerState = _extends$2({}, props, {
    isRtl,
    arrow: arrow2,
    disableInteractive,
    placement,
    PopperComponentProp,
    touch: ignoreNonTouchEvents.current
  });
  const classes = useUtilityClasses$12(ownerState);
  const PopperComponent = (_ref = (_slots$popper = slots.popper) != null ? _slots$popper : components.Popper) != null ? _ref : TooltipPopper;
  const TransitionComponent = (_ref2 = (_ref3 = (_slots$transition = slots.transition) != null ? _slots$transition : components.Transition) != null ? _ref3 : TransitionComponentProp) != null ? _ref2 : Grow$1;
  const TooltipComponent = (_ref4 = (_slots$tooltip = slots.tooltip) != null ? _slots$tooltip : components.Tooltip) != null ? _ref4 : TooltipTooltip;
  const ArrowComponent = (_ref5 = (_slots$arrow = slots.arrow) != null ? _slots$arrow : components.Arrow) != null ? _ref5 : TooltipArrow;
  const popperProps = appendOwnerState(PopperComponent, _extends$2({}, PopperProps, (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper, {
    className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className, (_ref6 = (_slotProps$popper2 = slotProps.popper) != null ? _slotProps$popper2 : componentsProps.popper) == null ? void 0 : _ref6.className)
  }), ownerState);
  const transitionProps = appendOwnerState(TransitionComponent, _extends$2({}, TransitionProps, (_slotProps$transition = slotProps.transition) != null ? _slotProps$transition : componentsProps.transition), ownerState);
  const tooltipProps = appendOwnerState(TooltipComponent, _extends$2({}, (_slotProps$tooltip = slotProps.tooltip) != null ? _slotProps$tooltip : componentsProps.tooltip, {
    className: clsx(classes.tooltip, (_ref7 = (_slotProps$tooltip2 = slotProps.tooltip) != null ? _slotProps$tooltip2 : componentsProps.tooltip) == null ? void 0 : _ref7.className)
  }), ownerState);
  const tooltipArrowProps = appendOwnerState(ArrowComponent, _extends$2({}, (_slotProps$arrow = slotProps.arrow) != null ? _slotProps$arrow : componentsProps.arrow, {
    className: clsx(classes.arrow, (_ref8 = (_slotProps$arrow2 = slotProps.arrow) != null ? _slotProps$arrow2 : componentsProps.arrow) == null ? void 0 : _ref8.className)
  }), ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ reactExports.cloneElement(children, childrenProps), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperComponent, _extends$2({
      as: PopperComponentProp != null ? PopperComponentProp : MuiPopper,
      placement,
      anchorEl: followCursor ? {
        getBoundingClientRect: () => ({
          top: cursorPosition.y,
          left: cursorPosition.x,
          right: cursorPosition.x,
          bottom: cursorPosition.y,
          width: 0,
          height: 0
        })
      } : childNode,
      popperRef,
      open: childNode ? open2 : false,
      id: id2,
      transition: true
    }, interactiveWrapperListeners, popperProps, {
      popperOptions,
      children: ({
        TransitionProps: TransitionPropsInner
      }) => /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$2({
        timeout: theme2.transitions.duration.shorter
      }, TransitionPropsInner, transitionProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipComponent, _extends$2({}, tooltipProps, {
          children: [title, arrow2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowComponent, _extends$2({}, tooltipArrowProps, {
            ref: setArrowRef
          })) : null]
        }))
      }))
    }))]
  });
});
const MUITooltip = Tooltip;
function getSwitchUtilityClass(slot) {
  return generateUtilityClass("MuiSwitch", slot);
}
const switchClasses = generateUtilityClasses("MuiSwitch", ["root", "edgeStart", "edgeEnd", "switchBase", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium", "checked", "disabled", "input", "thumb", "track"]);
const switchClasses$1 = switchClasses;
const _excluded$1o = ["className", "color", "edge", "size", "sx"];
const useUtilityClasses$11 = (ownerState) => {
  const {
    classes,
    edge,
    size,
    color: color2,
    checked,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", edge && `edge${capitalize$1(edge)}`, `size${capitalize$1(size)}`],
    switchBase: ["switchBase", `color${capitalize$1(color2)}`, checked && "checked", disabled && "disabled"],
    thumb: ["thumb"],
    track: ["track"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getSwitchUtilityClass, classes);
  return _extends$2({}, classes, composedClasses);
};
const SwitchRoot = styled$1("span", {
  name: "MuiSwitch",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.edge && styles2[`edge${capitalize$1(ownerState.edge)}`], styles2[`size${capitalize$1(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$2({
  display: "inline-flex",
  width: 34 + 12 * 2,
  height: 14 + 12 * 2,
  overflow: "hidden",
  padding: 12,
  boxSizing: "border-box",
  position: "relative",
  flexShrink: 0,
  zIndex: 0,
  // Reset the stacking context.
  verticalAlign: "middle",
  // For correct alignment with the text.
  "@media print": {
    colorAdjust: "exact"
  }
}, ownerState.edge === "start" && {
  marginLeft: -8
}, ownerState.edge === "end" && {
  marginRight: -8
}, ownerState.size === "small" && {
  width: 40,
  height: 24,
  padding: 7,
  [`& .${switchClasses$1.thumb}`]: {
    width: 16,
    height: 16
  },
  [`& .${switchClasses$1.switchBase}`]: {
    padding: 4,
    [`&.${switchClasses$1.checked}`]: {
      transform: "translateX(16px)"
    }
  }
}));
const SwitchSwitchBase = styled$1(SwitchBase$1, {
  name: "MuiSwitch",
  slot: "SwitchBase",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.switchBase, {
      [`& .${switchClasses$1.input}`]: styles2.input
    }, ownerState.color !== "default" && styles2[`color${capitalize$1(ownerState.color)}`]];
  }
})(({
  theme: theme2
}) => ({
  position: "absolute",
  top: 0,
  left: 0,
  zIndex: 1,
  // Render above the focus ripple.
  color: theme2.vars ? theme2.vars.palette.Switch.defaultColor : `${theme2.palette.mode === "light" ? theme2.palette.common.white : theme2.palette.grey[300]}`,
  transition: theme2.transitions.create(["left", "transform"], {
    duration: theme2.transitions.duration.shortest
  }),
  [`&.${switchClasses$1.checked}`]: {
    transform: "translateX(20px)"
  },
  [`&.${switchClasses$1.disabled}`]: {
    color: theme2.vars ? theme2.vars.palette.Switch.defaultDisabledColor : `${theme2.palette.mode === "light" ? theme2.palette.grey[100] : theme2.palette.grey[600]}`
  },
  [`&.${switchClasses$1.checked} + .${switchClasses$1.track}`]: {
    opacity: 0.5
  },
  [`&.${switchClasses$1.disabled} + .${switchClasses$1.track}`]: {
    opacity: theme2.vars ? theme2.vars.opacity.switchTrackDisabled : `${theme2.palette.mode === "light" ? 0.12 : 0.2}`
  },
  [`& .${switchClasses$1.input}`]: {
    left: "-100%",
    width: "300%"
  }
}), ({
  theme: theme2,
  ownerState
}) => _extends$2({
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.action.active, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.color !== "default" && {
  [`&.${switchClasses$1.checked}`]: {
    color: (theme2.vars || theme2).palette[ownerState.color].main,
    "&:hover": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${switchClasses$1.disabled}`]: {
      color: theme2.vars ? theme2.vars.palette.Switch[`${ownerState.color}DisabledColor`] : `${theme2.palette.mode === "light" ? lighten(theme2.palette[ownerState.color].main, 0.62) : darken(theme2.palette[ownerState.color].main, 0.55)}`
    }
  },
  [`&.${switchClasses$1.checked} + .${switchClasses$1.track}`]: {
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main
  }
}));
const SwitchTrack = styled$1("span", {
  name: "MuiSwitch",
  slot: "Track",
  overridesResolver: (props, styles2) => styles2.track
})(({
  theme: theme2
}) => ({
  height: "100%",
  width: "100%",
  borderRadius: 14 / 2,
  zIndex: -1,
  transition: theme2.transitions.create(["opacity", "background-color"], {
    duration: theme2.transitions.duration.shortest
  }),
  backgroundColor: theme2.vars ? theme2.vars.palette.common.onBackground : `${theme2.palette.mode === "light" ? theme2.palette.common.black : theme2.palette.common.white}`,
  opacity: theme2.vars ? theme2.vars.opacity.switchTrack : `${theme2.palette.mode === "light" ? 0.38 : 0.3}`
}));
const SwitchThumb = styled$1("span", {
  name: "MuiSwitch",
  slot: "Thumb",
  overridesResolver: (props, styles2) => styles2.thumb
})(({
  theme: theme2
}) => ({
  boxShadow: (theme2.vars || theme2).shadows[1],
  backgroundColor: "currentColor",
  width: 20,
  height: 20,
  borderRadius: "50%"
}));
const Switch = /* @__PURE__ */ reactExports.forwardRef(function Switch2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSwitch"
  });
  const {
    className,
    color: color2 = "primary",
    edge = false,
    size = "medium",
    sx
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1o);
  const ownerState = _extends$2({}, props, {
    color: color2,
    edge,
    size
  });
  const classes = useUtilityClasses$11(ownerState);
  const icon = /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchThumb, {
    className: classes.thumb,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchRoot, {
    className: clsx(classes.root, className),
    sx,
    ownerState,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SwitchSwitchBase, _extends$2({
      type: "checkbox",
      icon,
      checkedIcon: icon,
      ref,
      ownerState
    }, other, {
      classes: _extends$2({}, classes, {
        root: classes.switchBase
      })
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchTrack, {
      className: classes.track,
      ownerState
    })]
  });
});
const MUISwitch = Switch;
function getTabUtilityClass(slot) {
  return generateUtilityClass("MuiTab", slot);
}
const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"]);
const tabClasses$1 = tabClasses;
const _excluded$1n = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"];
const useUtilityClasses$10 = (ownerState) => {
  const {
    classes,
    textColor,
    fullWidth,
    wrapped,
    icon,
    label,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", icon && label && "labelIcon", `textColor${capitalize$1(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
    iconWrapper: ["iconWrapper"]
  };
  return composeClasses(slots, getTabUtilityClass, classes);
};
const TabRoot = styled$1(ButtonBase$1, {
  name: "MuiTab",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.label && ownerState.icon && styles2.labelIcon, styles2[`textColor${capitalize$1(ownerState.textColor)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.wrapped && styles2.wrapped];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({}, theme2.typography.button, {
  maxWidth: 360,
  minWidth: 90,
  position: "relative",
  minHeight: 48,
  flexShrink: 0,
  padding: "12px 16px",
  overflow: "hidden",
  whiteSpace: "normal",
  textAlign: "center"
}, ownerState.label && {
  flexDirection: ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom" ? "column" : "row"
}, {
  lineHeight: 1.25
}, ownerState.icon && ownerState.label && {
  minHeight: 72,
  paddingTop: 9,
  paddingBottom: 9,
  [`& > .${tabClasses$1.iconWrapper}`]: _extends$2({}, ownerState.iconPosition === "top" && {
    marginBottom: 6
  }, ownerState.iconPosition === "bottom" && {
    marginTop: 6
  }, ownerState.iconPosition === "start" && {
    marginRight: theme2.spacing(1)
  }, ownerState.iconPosition === "end" && {
    marginLeft: theme2.spacing(1)
  })
}, ownerState.textColor === "inherit" && {
  color: "inherit",
  opacity: 0.6,
  // same opacity as theme.palette.text.secondary
  [`&.${tabClasses$1.selected}`]: {
    opacity: 1
  },
  [`&.${tabClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  }
}, ownerState.textColor === "primary" && {
  color: (theme2.vars || theme2).palette.text.secondary,
  [`&.${tabClasses$1.selected}`]: {
    color: (theme2.vars || theme2).palette.primary.main
  },
  [`&.${tabClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  }
}, ownerState.textColor === "secondary" && {
  color: (theme2.vars || theme2).palette.text.secondary,
  [`&.${tabClasses$1.selected}`]: {
    color: (theme2.vars || theme2).palette.secondary.main
  },
  [`&.${tabClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  }
}, ownerState.fullWidth && {
  flexShrink: 1,
  flexGrow: 1,
  flexBasis: 0,
  maxWidth: "none"
}, ownerState.wrapped && {
  fontSize: theme2.typography.pxToRem(12)
}));
const Tab = /* @__PURE__ */ reactExports.forwardRef(function Tab2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTab"
  });
  const {
    className,
    disabled = false,
    disableFocusRipple = false,
    // eslint-disable-next-line react/prop-types
    fullWidth,
    icon: iconProp,
    iconPosition = "top",
    // eslint-disable-next-line react/prop-types
    indicator,
    label,
    onChange,
    onClick,
    onFocus,
    // eslint-disable-next-line react/prop-types
    selected,
    // eslint-disable-next-line react/prop-types
    selectionFollowsFocus,
    // eslint-disable-next-line react/prop-types
    textColor = "inherit",
    value,
    wrapped = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1n);
  const ownerState = _extends$2({}, props, {
    disabled,
    disableFocusRipple,
    selected,
    icon: !!iconProp,
    iconPosition,
    label: !!label,
    fullWidth,
    textColor,
    wrapped
  });
  const classes = useUtilityClasses$10(ownerState);
  const icon = iconProp && label && /* @__PURE__ */ reactExports.isValidElement(iconProp) ? /* @__PURE__ */ reactExports.cloneElement(iconProp, {
    className: clsx(classes.iconWrapper, iconProp.props.className)
  }) : iconProp;
  const handleClick = (event) => {
    if (!selected && onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const handleFocus = (event) => {
    if (selectionFollowsFocus && !selected && onChange) {
      onChange(event, value);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabRoot, _extends$2({
    focusRipple: !disableFocusRipple,
    className: clsx(classes.root, className),
    ref,
    role: "tab",
    "aria-selected": selected,
    disabled,
    onClick: handleClick,
    onFocus: handleFocus,
    ownerState,
    tabIndex: selected ? 0 : -1
  }, other, {
    children: [iconPosition === "top" || iconPosition === "start" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [icon, label]
    }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [label, icon]
    }), indicator]
  }));
});
const Tab$1 = Tab;
const TableContext = /* @__PURE__ */ reactExports.createContext();
const TableContext$1 = TableContext;
function getTableUtilityClass(slot) {
  return generateUtilityClass("MuiTable", slot);
}
generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);
const _excluded$1m = ["className", "component", "padding", "size", "stickyHeader"];
const useUtilityClasses$$ = (ownerState) => {
  const {
    classes,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", stickyHeader && "stickyHeader"]
  };
  return composeClasses(slots, getTableUtilityClass, classes);
};
const TableRoot = styled$1("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": _extends$2({}, theme2.typography.body2, {
    padding: theme2.spacing(2),
    color: (theme2.vars || theme2).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  })
}, ownerState.stickyHeader && {
  borderCollapse: "separate"
}));
const defaultComponent$3 = "table";
const Table = /* @__PURE__ */ reactExports.forwardRef(function Table2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTable"
  });
  const {
    className,
    component = defaultComponent$3,
    padding: padding2 = "normal",
    size = "medium",
    stickyHeader = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1m);
  const ownerState = _extends$2({}, props, {
    component,
    padding: padding2,
    size,
    stickyHeader
  });
  const classes = useUtilityClasses$$(ownerState);
  const table2 = reactExports.useMemo(() => ({
    padding: padding2,
    size,
    stickyHeader
  }), [padding2, size, stickyHeader]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext$1.Provider, {
    value: table2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableRoot, _extends$2({
      as: component,
      role: component === defaultComponent$3 ? null : "table",
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other))
  });
});
const Table$1 = Table;
const Tablelvl2Context = /* @__PURE__ */ reactExports.createContext();
const Tablelvl2Context$1 = Tablelvl2Context;
function getTableBodyUtilityClass(slot) {
  return generateUtilityClass("MuiTableBody", slot);
}
generateUtilityClasses("MuiTableBody", ["root"]);
const _excluded$1l = ["className", "component"];
const useUtilityClasses$_ = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableBodyUtilityClass, classes);
};
const TableBodyRoot = styled$1("tbody", {
  name: "MuiTableBody",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "table-row-group"
});
const tablelvl2$1 = {
  variant: "body"
};
const defaultComponent$2 = "tbody";
const TableBody = /* @__PURE__ */ reactExports.forwardRef(function TableBody2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableBody"
  });
  const {
    className,
    component = defaultComponent$2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1l);
  const ownerState = _extends$2({}, props, {
    component
  });
  const classes = useUtilityClasses$_(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context$1.Provider, {
    value: tablelvl2$1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableBodyRoot, _extends$2({
      className: clsx(classes.root, className),
      as: component,
      ref,
      role: component === defaultComponent$2 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
const TableBody$1 = TableBody;
function getTableCellUtilityClass(slot) {
  return generateUtilityClass("MuiTableCell", slot);
}
const tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
const tableCellClasses$1 = tableCellClasses;
const _excluded$1k = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"];
const useUtilityClasses$Z = (ownerState) => {
  const {
    classes,
    variant,
    align,
    padding: padding2,
    size,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize$1(align)}`, padding2 !== "normal" && `padding${capitalize$1(padding2)}`, `size${capitalize$1(size)}`]
  };
  return composeClasses(slots, getTableCellUtilityClass, classes);
};
const TableCellRoot = styled$1("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize$1(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize$1(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize$1(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({}, theme2.typography.body2, {
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: theme2.vars ? `1px solid ${theme2.vars.palette.TableCell.border}` : `1px solid
    ${theme2.palette.mode === "light" ? lighten(alpha(theme2.palette.divider, 1), 0.88) : darken(alpha(theme2.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16
}, ownerState.variant === "head" && {
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: theme2.typography.pxToRem(24),
  fontWeight: theme2.typography.fontWeightMedium
}, ownerState.variant === "body" && {
  color: (theme2.vars || theme2).palette.text.primary
}, ownerState.variant === "footer" && {
  color: (theme2.vars || theme2).palette.text.secondary,
  lineHeight: theme2.typography.pxToRem(21),
  fontSize: theme2.typography.pxToRem(12)
}, ownerState.size === "small" && {
  padding: "6px 16px",
  [`&.${tableCellClasses$1.paddingCheckbox}`]: {
    width: 24,
    // prevent the checkbox column from growing
    padding: "0 12px 0 16px",
    "& > *": {
      padding: 0
    }
  }
}, ownerState.padding === "checkbox" && {
  width: 48,
  // prevent the checkbox column from growing
  padding: "0 0 0 4px"
}, ownerState.padding === "none" && {
  padding: 0
}, ownerState.align === "left" && {
  textAlign: "left"
}, ownerState.align === "center" && {
  textAlign: "center"
}, ownerState.align === "right" && {
  textAlign: "right",
  flexDirection: "row-reverse"
}, ownerState.align === "justify" && {
  textAlign: "justify"
}, ownerState.stickyHeader && {
  position: "sticky",
  top: 0,
  zIndex: 2,
  backgroundColor: (theme2.vars || theme2).palette.background.default
}));
const TableCell = /* @__PURE__ */ reactExports.forwardRef(function TableCell2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableCell"
  });
  const {
    align = "inherit",
    className,
    component: componentProp,
    padding: paddingProp,
    scope: scopeProp,
    size: sizeProp,
    sortDirection,
    variant: variantProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1k);
  const table2 = reactExports.useContext(TableContext$1);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context$1);
  const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
  let component;
  if (componentProp) {
    component = componentProp;
  } else {
    component = isHeadCell ? "th" : "td";
  }
  let scope = scopeProp;
  if (component === "td") {
    scope = void 0;
  } else if (!scope && isHeadCell) {
    scope = "col";
  }
  const variant = variantProp || tablelvl22 && tablelvl22.variant;
  const ownerState = _extends$2({}, props, {
    align,
    component,
    padding: paddingProp || (table2 && table2.padding ? table2.padding : "normal"),
    size: sizeProp || (table2 && table2.size ? table2.size : "medium"),
    sortDirection,
    stickyHeader: variant === "head" && table2 && table2.stickyHeader,
    variant
  });
  const classes = useUtilityClasses$Z(ownerState);
  let ariaSort = null;
  if (sortDirection) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableCellRoot, _extends$2({
    as: component,
    ref,
    className: clsx(classes.root, className),
    "aria-sort": ariaSort,
    scope,
    ownerState
  }, other));
});
const TableCell$1 = TableCell;
function getTableContainerUtilityClass(slot) {
  return generateUtilityClass("MuiTableContainer", slot);
}
generateUtilityClasses("MuiTableContainer", ["root"]);
const _excluded$1j = ["className", "component"];
const useUtilityClasses$Y = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableContainerUtilityClass, classes);
};
const TableContainerRoot = styled$1("div", {
  name: "MuiTableContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  width: "100%",
  overflowX: "auto"
});
const TableContainer = /* @__PURE__ */ reactExports.forwardRef(function TableContainer2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableContainer"
  });
  const {
    className,
    component = "div"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1j);
  const ownerState = _extends$2({}, props, {
    component
  });
  const classes = useUtilityClasses$Y(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainerRoot, _extends$2({
    ref,
    as: component,
    className: clsx(classes.root, className),
    ownerState
  }, other));
});
const TableContainer$1 = TableContainer;
function getTableHeadUtilityClass(slot) {
  return generateUtilityClass("MuiTableHead", slot);
}
generateUtilityClasses("MuiTableHead", ["root"]);
const _excluded$1i = ["className", "component"];
const useUtilityClasses$X = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableHeadUtilityClass, classes);
};
const TableHeadRoot = styled$1("thead", {
  name: "MuiTableHead",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "table-header-group"
});
const tablelvl2 = {
  variant: "head"
};
const defaultComponent$1 = "thead";
const TableHead = /* @__PURE__ */ reactExports.forwardRef(function TableHead2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableHead"
  });
  const {
    className,
    component = defaultComponent$1
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1i);
  const ownerState = _extends$2({}, props, {
    component
  });
  const classes = useUtilityClasses$X(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Tablelvl2Context$1.Provider, {
    value: tablelvl2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeadRoot, _extends$2({
      as: component,
      className: clsx(classes.root, className),
      ref,
      role: component === defaultComponent$1 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
const TableHead$1 = TableHead;
function getToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiToolbar", slot);
}
generateUtilityClasses("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const _excluded$1h = ["className", "component", "disableGutters", "variant"];
const useUtilityClasses$W = (ownerState) => {
  const {
    classes,
    disableGutters,
    variant
  } = ownerState;
  const slots = {
    root: ["root", !disableGutters && "gutters", variant]
  };
  return composeClasses(slots, getToolbarUtilityClass, classes);
};
const ToolbarRoot = styled$1("div", {
  name: "MuiToolbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableGutters && styles2.gutters, styles2[ownerState.variant]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  position: "relative",
  display: "flex",
  alignItems: "center"
}, !ownerState.disableGutters && {
  paddingLeft: theme2.spacing(2),
  paddingRight: theme2.spacing(2),
  [theme2.breakpoints.up("sm")]: {
    paddingLeft: theme2.spacing(3),
    paddingRight: theme2.spacing(3)
  }
}, ownerState.variant === "dense" && {
  minHeight: 48
}), ({
  theme: theme2,
  ownerState
}) => ownerState.variant === "regular" && theme2.mixins.toolbar);
const Toolbar = /* @__PURE__ */ reactExports.forwardRef(function Toolbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiToolbar"
  });
  const {
    className,
    component = "div",
    disableGutters = false,
    variant = "regular"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1h);
  const ownerState = _extends$2({}, props, {
    component,
    disableGutters,
    variant
  });
  const classes = useUtilityClasses$W(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarRoot, _extends$2({
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other));
});
const Toolbar$1 = Toolbar;
const KeyboardArrowLeft = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft");
const KeyboardArrowRight = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");
var _LastPageIcon, _FirstPageIcon, _KeyboardArrowRight, _KeyboardArrowLeft, _KeyboardArrowLeft2, _KeyboardArrowRight2, _FirstPageIcon2, _LastPageIcon2;
const _excluded$1g = ["backIconButtonProps", "count", "getItemAriaLabel", "nextIconButtonProps", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton"];
const TablePaginationActions = /* @__PURE__ */ reactExports.forwardRef(function TablePaginationActions2(props, ref) {
  const {
    backIconButtonProps,
    count,
    getItemAriaLabel,
    nextIconButtonProps,
    onPageChange,
    page,
    rowsPerPage,
    showFirstButton,
    showLastButton
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1g);
  const theme2 = useTheme();
  const handleFirstPageButtonClick = (event) => {
    onPageChange(event, 0);
  };
  const handleBackButtonClick = (event) => {
    onPageChange(event, page - 1);
  };
  const handleNextButtonClick = (event) => {
    onPageChange(event, page + 1);
  };
  const handleLastPageButtonClick = (event) => {
    onPageChange(event, Math.max(0, Math.ceil(count / rowsPerPage) - 1));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$2({
    ref
  }, other, {
    children: [showFirstButton && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, {
      onClick: handleFirstPageButtonClick,
      disabled: page === 0,
      "aria-label": getItemAriaLabel("first", page),
      title: getItemAriaLabel("first", page),
      children: theme2.direction === "rtl" ? _LastPageIcon || (_LastPageIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(LastPageIcon, {})) : _FirstPageIcon || (_FirstPageIcon = /* @__PURE__ */ jsxRuntimeExports.jsx(FirstPageIcon, {}))
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, _extends$2({
      onClick: handleBackButtonClick,
      disabled: page === 0,
      color: "inherit",
      "aria-label": getItemAriaLabel("previous", page),
      title: getItemAriaLabel("previous", page)
    }, backIconButtonProps, {
      children: theme2.direction === "rtl" ? _KeyboardArrowRight || (_KeyboardArrowRight = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowRight, {})) : _KeyboardArrowLeft || (_KeyboardArrowLeft = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowLeft, {}))
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, _extends$2({
      onClick: handleNextButtonClick,
      disabled: count !== -1 ? page >= Math.ceil(count / rowsPerPage) - 1 : false,
      color: "inherit",
      "aria-label": getItemAriaLabel("next", page),
      title: getItemAriaLabel("next", page)
    }, nextIconButtonProps, {
      children: theme2.direction === "rtl" ? _KeyboardArrowLeft2 || (_KeyboardArrowLeft2 = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowLeft, {})) : _KeyboardArrowRight2 || (_KeyboardArrowRight2 = /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardArrowRight, {}))
    })), showLastButton && /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, {
      onClick: handleLastPageButtonClick,
      disabled: page >= Math.ceil(count / rowsPerPage) - 1,
      "aria-label": getItemAriaLabel("last", page),
      title: getItemAriaLabel("last", page),
      children: theme2.direction === "rtl" ? _FirstPageIcon2 || (_FirstPageIcon2 = /* @__PURE__ */ jsxRuntimeExports.jsx(FirstPageIcon, {})) : _LastPageIcon2 || (_LastPageIcon2 = /* @__PURE__ */ jsxRuntimeExports.jsx(LastPageIcon, {}))
    })]
  }));
});
const TablePaginationActions$1 = TablePaginationActions;
function getTablePaginationUtilityClass(slot) {
  return generateUtilityClass("MuiTablePagination", slot);
}
const tablePaginationClasses = generateUtilityClasses("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]);
const tablePaginationClasses$1 = tablePaginationClasses;
var _InputBase;
const _excluded$1f = ["ActionsComponent", "backIconButtonProps", "className", "colSpan", "component", "count", "getItemAriaLabel", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps", "showFirstButton", "showLastButton"];
const TablePaginationRoot = styled$1(TableCell$1, {
  name: "MuiTablePagination",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => ({
  overflow: "auto",
  color: (theme2.vars || theme2).palette.text.primary,
  fontSize: theme2.typography.pxToRem(14),
  // Increase the specificity to override TableCell.
  "&:last-child": {
    padding: 0
  }
}));
const TablePaginationToolbar = styled$1(Toolbar$1, {
  name: "MuiTablePagination",
  slot: "Toolbar",
  overridesResolver: (props, styles2) => _extends$2({
    [`& .${tablePaginationClasses$1.actions}`]: styles2.actions
  }, styles2.toolbar)
})(({
  theme: theme2
}) => ({
  minHeight: 52,
  paddingRight: 2,
  [`${theme2.breakpoints.up("xs")} and (orientation: landscape)`]: {
    minHeight: 52
  },
  [theme2.breakpoints.up("sm")]: {
    minHeight: 52,
    paddingRight: 2
  },
  [`& .${tablePaginationClasses$1.actions}`]: {
    flexShrink: 0,
    marginLeft: 20
  }
}));
const TablePaginationSpacer = styled$1("div", {
  name: "MuiTablePagination",
  slot: "Spacer",
  overridesResolver: (props, styles2) => styles2.spacer
})({
  flex: "1 1 100%"
});
const TablePaginationSelectLabel = styled$1("p", {
  name: "MuiTablePagination",
  slot: "SelectLabel",
  overridesResolver: (props, styles2) => styles2.selectLabel
})(({
  theme: theme2
}) => _extends$2({}, theme2.typography.body2, {
  flexShrink: 0
}));
const TablePaginationSelect = styled$1(Select$1, {
  name: "MuiTablePagination",
  slot: "Select",
  overridesResolver: (props, styles2) => _extends$2({
    [`& .${tablePaginationClasses$1.selectIcon}`]: styles2.selectIcon,
    [`& .${tablePaginationClasses$1.select}`]: styles2.select
  }, styles2.input, styles2.selectRoot)
})({
  color: "inherit",
  fontSize: "inherit",
  flexShrink: 0,
  marginRight: 32,
  marginLeft: 8,
  [`& .${tablePaginationClasses$1.select}`]: {
    paddingLeft: 8,
    paddingRight: 24,
    textAlign: "right",
    textAlignLast: "right"
    // Align <select> on Chrome.
  }
});
const TablePaginationMenuItem = styled$1(MenuItem$1, {
  name: "MuiTablePagination",
  slot: "MenuItem",
  overridesResolver: (props, styles2) => styles2.menuItem
})({});
const TablePaginationDisplayedRows = styled$1("p", {
  name: "MuiTablePagination",
  slot: "DisplayedRows",
  overridesResolver: (props, styles2) => styles2.displayedRows
})(({
  theme: theme2
}) => _extends$2({}, theme2.typography.body2, {
  flexShrink: 0
}));
function defaultLabelDisplayedRows({
  from: from2,
  to,
  count
}) {
  return `${from2}–${to} of ${count !== -1 ? count : `more than ${to}`}`;
}
function defaultGetAriaLabel(type2) {
  return `Go to ${type2} page`;
}
const useUtilityClasses$V = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    toolbar: ["toolbar"],
    spacer: ["spacer"],
    selectLabel: ["selectLabel"],
    select: ["select"],
    input: ["input"],
    selectIcon: ["selectIcon"],
    menuItem: ["menuItem"],
    displayedRows: ["displayedRows"],
    actions: ["actions"]
  };
  return composeClasses(slots, getTablePaginationUtilityClass, classes);
};
const TablePagination = /* @__PURE__ */ reactExports.forwardRef(function TablePagination2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTablePagination"
  });
  const {
    ActionsComponent = TablePaginationActions$1,
    backIconButtonProps,
    className,
    colSpan: colSpanProp,
    component = TableCell$1,
    count,
    getItemAriaLabel = defaultGetAriaLabel,
    labelDisplayedRows = defaultLabelDisplayedRows,
    labelRowsPerPage = "Rows per page:",
    nextIconButtonProps,
    onPageChange,
    onRowsPerPageChange,
    page,
    rowsPerPage,
    rowsPerPageOptions = [10, 25, 50, 100],
    SelectProps = {},
    showFirstButton = false,
    showLastButton = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1f);
  const ownerState = props;
  const classes = useUtilityClasses$V(ownerState);
  const MenuItemComponent = SelectProps.native ? "option" : TablePaginationMenuItem;
  let colSpan;
  if (component === TableCell$1 || component === "td") {
    colSpan = colSpanProp || 1e3;
  }
  const selectId = useId(SelectProps.id);
  const labelId = useId(SelectProps.labelId);
  const getLabelDisplayedRowsTo = () => {
    if (count === -1) {
      return (page + 1) * rowsPerPage;
    }
    return rowsPerPage === -1 ? count : Math.min(count, (page + 1) * rowsPerPage);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationRoot, _extends$2({
    colSpan,
    ref,
    as: component,
    ownerState,
    className: clsx(classes.root, className)
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TablePaginationToolbar, {
      className: classes.toolbar,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationSpacer, {
        className: classes.spacer
      }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationSelectLabel, {
        className: classes.selectLabel,
        id: labelId,
        children: labelRowsPerPage
      }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationSelect, _extends$2({
        variant: "standard"
      }, !SelectProps.variant && {
        input: _InputBase || (_InputBase = /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, {}))
      }, {
        value: rowsPerPage,
        onChange: onRowsPerPageChange,
        id: selectId,
        labelId
      }, SelectProps, {
        classes: _extends$2({}, SelectProps.classes, {
          // TODO v5 remove `classes.input`
          root: clsx(classes.input, classes.selectRoot, (SelectProps.classes || {}).root),
          select: clsx(classes.select, (SelectProps.classes || {}).select),
          // TODO v5 remove `selectIcon`
          icon: clsx(classes.selectIcon, (SelectProps.classes || {}).icon)
        }),
        children: rowsPerPageOptions.map((rowsPerPageOption) => /* @__PURE__ */ reactExports.createElement(MenuItemComponent, _extends$2({}, !isHostComponent(MenuItemComponent) && {
          ownerState
        }, {
          className: classes.menuItem,
          key: rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption,
          value: rowsPerPageOption.value ? rowsPerPageOption.value : rowsPerPageOption
        }), rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption))
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(TablePaginationDisplayedRows, {
        className: classes.displayedRows,
        children: labelDisplayedRows({
          from: count === 0 ? 0 : page * rowsPerPage + 1,
          to: getLabelDisplayedRowsTo(),
          count: count === -1 ? -1 : count,
          page
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsComponent, {
        className: classes.actions,
        backIconButtonProps,
        count,
        nextIconButtonProps,
        onPageChange,
        page,
        rowsPerPage,
        showFirstButton,
        showLastButton,
        getItemAriaLabel
      })]
    })
  }));
});
const TablePagination$1 = TablePagination;
function getTableRowUtilityClass(slot) {
  return generateUtilityClass("MuiTableRow", slot);
}
const tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
const tableRowClasses$1 = tableRowClasses;
const _excluded$1e = ["className", "component", "hover", "selected"];
const useUtilityClasses$U = (ownerState) => {
  const {
    classes,
    selected,
    hover,
    head,
    footer
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"]
  };
  return composeClasses(slots, getTableRowUtilityClass, classes);
};
const TableRowRoot = styled$1("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
  }
})(({
  theme: theme2
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${tableRowClasses$1.hover}:hover`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.hover
  },
  [`&.${tableRowClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity)
    }
  }
}));
const defaultComponent = "tr";
const TableRow = /* @__PURE__ */ reactExports.forwardRef(function TableRow2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableRow"
  });
  const {
    className,
    component = defaultComponent,
    hover = false,
    selected = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1e);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context$1);
  const ownerState = _extends$2({}, props, {
    component,
    hover,
    selected,
    head: tablelvl22 && tablelvl22.variant === "head",
    footer: tablelvl22 && tablelvl22.variant === "footer"
  });
  const classes = useUtilityClasses$U(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableRowRoot, _extends$2({
    as: component,
    ref,
    className: clsx(classes.root, className),
    role: component === defaultComponent ? null : "row",
    ownerState
  }, other));
});
const TableRow$1 = TableRow;
function easeInOutSin(time2) {
  return (1 + Math.sin(Math.PI * time2 - Math.PI / 2)) / 2;
}
function animate(property, element, to, options = {}, cb2 = () => {
}) {
  const {
    ease = easeInOutSin,
    duration: duration2 = 300
    // standard
  } = options;
  let start2 = null;
  const from2 = element[property];
  let cancelled = false;
  const cancel = () => {
    cancelled = true;
  };
  const step = (timestamp) => {
    if (cancelled) {
      cb2(new Error("Animation cancelled"));
      return;
    }
    if (start2 === null) {
      start2 = timestamp;
    }
    const time2 = Math.min(1, (timestamp - start2) / duration2);
    element[property] = ease(time2) * (to - from2) + from2;
    if (time2 >= 1) {
      requestAnimationFrame(() => {
        cb2(null);
      });
      return;
    }
    requestAnimationFrame(step);
  };
  if (from2 === to) {
    cb2(new Error("Element already at target position"));
    return cancel;
  }
  requestAnimationFrame(step);
  return cancel;
}
const _excluded$1d = ["onChange"];
const styles = {
  width: 99,
  height: 99,
  position: "absolute",
  top: -9999,
  overflow: "scroll"
};
function ScrollbarSize(props) {
  const {
    onChange
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1d);
  const scrollbarHeight = reactExports.useRef();
  const nodeRef = reactExports.useRef(null);
  const setMeasurements = () => {
    scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
  };
  useEnhancedEffect$1(() => {
    const handleResize = debounce$1(() => {
      const prevHeight = scrollbarHeight.current;
      setMeasurements();
      if (prevHeight !== scrollbarHeight.current) {
        onChange(scrollbarHeight.current);
      }
    });
    const containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [onChange]);
  reactExports.useEffect(() => {
    setMeasurements();
    onChange(scrollbarHeight.current);
  }, [onChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends$2({
    style: styles,
    ref: nodeRef
  }, other));
}
function getTabScrollButtonUtilityClass(slot) {
  return generateUtilityClass("MuiTabScrollButton", slot);
}
const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
const tabScrollButtonClasses$1 = tabScrollButtonClasses;
const _excluded$1c = ["className", "slots", "slotProps", "direction", "orientation", "disabled"];
const useUtilityClasses$T = (ownerState) => {
  const {
    classes,
    orientation,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, disabled && "disabled"]
  };
  return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
};
const TabScrollButtonRoot = styled$1(ButtonBase$1, {
  name: "MuiTabScrollButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
  }
})(({
  ownerState
}) => _extends$2({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${tabScrollButtonClasses$1.disabled}`]: {
    opacity: 0
  }
}, ownerState.orientation === "vertical" && {
  width: "100%",
  height: 40,
  "& svg": {
    transform: `rotate(${ownerState.isRtl ? -90 : 90}deg)`
  }
}));
const TabScrollButton = /* @__PURE__ */ reactExports.forwardRef(function TabScrollButton2(inProps, ref) {
  var _slots$StartScrollBut, _slots$EndScrollButto;
  const props = useThemeProps({
    props: inProps,
    name: "MuiTabScrollButton"
  });
  const {
    className,
    slots = {},
    slotProps = {},
    direction: direction2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1c);
  const theme2 = useTheme();
  const isRtl = theme2.direction === "rtl";
  const ownerState = _extends$2({
    isRtl
  }, props);
  const classes = useUtilityClasses$T(ownerState);
  const StartButtonIcon = (_slots$StartScrollBut = slots.StartScrollButtonIcon) != null ? _slots$StartScrollBut : KeyboardArrowLeft;
  const EndButtonIcon = (_slots$EndScrollButto = slots.EndScrollButtonIcon) != null ? _slots$EndScrollButto : KeyboardArrowRight;
  const startButtonIconProps = useSlotProps({
    elementType: StartButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  const endButtonIconProps = useSlotProps({
    elementType: EndButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    additionalProps: {
      fontSize: "small"
    },
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabScrollButtonRoot, _extends$2({
    component: "div",
    className: clsx(classes.root, className),
    ref,
    role: null,
    ownerState,
    tabIndex: null
  }, other, {
    children: direction2 === "left" ? /* @__PURE__ */ jsxRuntimeExports.jsx(StartButtonIcon, _extends$2({}, startButtonIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(EndButtonIcon, _extends$2({}, endButtonIconProps))
  }));
});
const TabScrollButton$1 = TabScrollButton;
function getTabsUtilityClass(slot) {
  return generateUtilityClass("MuiTabs", slot);
}
const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
const tabsClasses$1 = tabsClasses;
const _excluded$1b = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "slots", "slotProps", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"];
const nextItem = (list, item) => {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return list.firstChild;
};
const previousItem = (list, item) => {
  if (list === item) {
    return list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return list.lastChild;
};
const moveFocus = (list, currentFocus, traversalFunction) => {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
};
const useUtilityClasses$S = (ownerState) => {
  const {
    vertical,
    fixed,
    hideScrollbar,
    scrollableX,
    scrollableY,
    centered,
    scrollButtonsHideMobile,
    classes
  } = ownerState;
  const slots = {
    root: ["root", vertical && "vertical"],
    scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
    flexContainer: ["flexContainer", vertical && "flexContainerVertical", centered && "centered"],
    indicator: ["indicator"],
    scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
    scrollableX: [scrollableX && "scrollableX"],
    hideScrollbar: [hideScrollbar && "hideScrollbar"]
  };
  return composeClasses(slots, getTabsUtilityClass, classes);
};
const TabsRoot = styled$1("div", {
  name: "MuiTabs",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${tabsClasses$1.scrollButtons}`]: styles2.scrollButtons
    }, {
      [`& .${tabsClasses$1.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
    }, styles2.root, ownerState.vertical && styles2.vertical];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$2({
  overflow: "hidden",
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  display: "flex"
}, ownerState.vertical && {
  flexDirection: "column"
}, ownerState.scrollButtonsHideMobile && {
  [`& .${tabsClasses$1.scrollButtons}`]: {
    [theme2.breakpoints.down("sm")]: {
      display: "none"
    }
  }
}));
const TabsScroller = styled$1("div", {
  name: "MuiTabs",
  slot: "Scroller",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
  }
})(({
  ownerState
}) => _extends$2({
  position: "relative",
  display: "inline-block",
  flex: "1 1 auto",
  whiteSpace: "nowrap"
}, ownerState.fixed && {
  overflowX: "hidden",
  width: "100%"
}, ownerState.hideScrollbar && {
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
}, ownerState.scrollableX && {
  overflowX: "auto",
  overflowY: "hidden"
}, ownerState.scrollableY && {
  overflowY: "auto",
  overflowX: "hidden"
}));
const FlexContainer = styled$1("div", {
  name: "MuiTabs",
  slot: "FlexContainer",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
  }
})(({
  ownerState
}) => _extends$2({
  display: "flex"
}, ownerState.vertical && {
  flexDirection: "column"
}, ownerState.centered && {
  justifyContent: "center"
}));
const TabsIndicator = styled$1("span", {
  name: "MuiTabs",
  slot: "Indicator",
  overridesResolver: (props, styles2) => styles2.indicator
})(({
  ownerState,
  theme: theme2
}) => _extends$2({
  position: "absolute",
  height: 2,
  bottom: 0,
  width: "100%",
  transition: theme2.transitions.create()
}, ownerState.indicatorColor === "primary" && {
  backgroundColor: (theme2.vars || theme2).palette.primary.main
}, ownerState.indicatorColor === "secondary" && {
  backgroundColor: (theme2.vars || theme2).palette.secondary.main
}, ownerState.vertical && {
  height: "100%",
  width: 2,
  right: 0
}));
const TabsScrollbarSize = styled$1(ScrollbarSize)({
  overflowX: "auto",
  overflowY: "hidden",
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
});
const defaultIndicatorStyle = {};
const Tabs = /* @__PURE__ */ reactExports.forwardRef(function Tabs2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTabs"
  });
  const theme2 = useTheme();
  const isRtl = theme2.direction === "rtl";
  const {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    action,
    centered = false,
    children: childrenProp,
    className,
    component = "div",
    allowScrollButtonsMobile = false,
    indicatorColor = "primary",
    onChange,
    orientation = "horizontal",
    ScrollButtonComponent = TabScrollButton$1,
    scrollButtons = "auto",
    selectionFollowsFocus,
    slots = {},
    slotProps = {},
    TabIndicatorProps = {},
    TabScrollButtonProps = {},
    textColor = "primary",
    value,
    variant = "standard",
    visibleScrollbar = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1b);
  const scrollable = variant === "scrollable";
  const vertical = orientation === "vertical";
  const scrollStart = vertical ? "scrollTop" : "scrollLeft";
  const start2 = vertical ? "top" : "left";
  const end2 = vertical ? "bottom" : "right";
  const clientSize = vertical ? "clientHeight" : "clientWidth";
  const size = vertical ? "height" : "width";
  const ownerState = _extends$2({}, props, {
    component,
    allowScrollButtonsMobile,
    indicatorColor,
    orientation,
    vertical,
    scrollButtons,
    textColor,
    variant,
    visibleScrollbar,
    fixed: !scrollable,
    hideScrollbar: scrollable && !visibleScrollbar,
    scrollableX: scrollable && !vertical,
    scrollableY: scrollable && vertical,
    centered: centered && !scrollable,
    scrollButtonsHideMobile: !allowScrollButtonsMobile
  });
  const classes = useUtilityClasses$S(ownerState);
  const startScrollButtonIconProps = useSlotProps({
    elementType: slots.StartScrollButtonIcon,
    externalSlotProps: slotProps.startScrollButtonIcon,
    ownerState
  });
  const endScrollButtonIconProps = useSlotProps({
    elementType: slots.EndScrollButtonIcon,
    externalSlotProps: slotProps.endScrollButtonIcon,
    ownerState
  });
  const [mounted, setMounted] = reactExports.useState(false);
  const [indicatorStyle, setIndicatorStyle] = reactExports.useState(defaultIndicatorStyle);
  const [displayStartScroll, setDisplayStartScroll] = reactExports.useState(false);
  const [displayEndScroll, setDisplayEndScroll] = reactExports.useState(false);
  const [updateScrollObserver, setUpdateScrollObserver] = reactExports.useState(false);
  const [scrollerStyle, setScrollerStyle] = reactExports.useState({
    overflow: "hidden",
    scrollbarWidth: 0
  });
  const valueToIndex = /* @__PURE__ */ new Map();
  const tabsRef = reactExports.useRef(null);
  const tabListRef = reactExports.useRef(null);
  const getTabsMeta = () => {
    const tabsNode = tabsRef.current;
    let tabsMeta;
    if (tabsNode) {
      const rect = tabsNode.getBoundingClientRect();
      tabsMeta = {
        clientWidth: tabsNode.clientWidth,
        scrollLeft: tabsNode.scrollLeft,
        scrollTop: tabsNode.scrollTop,
        scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, theme2.direction),
        scrollWidth: tabsNode.scrollWidth,
        top: rect.top,
        bottom: rect.bottom,
        left: rect.left,
        right: rect.right
      };
    }
    let tabMeta;
    if (tabsNode && value !== false) {
      const children2 = tabListRef.current.children;
      if (children2.length > 0) {
        const tab = children2[valueToIndex.get(value)];
        tabMeta = tab ? tab.getBoundingClientRect() : null;
      }
    }
    return {
      tabsMeta,
      tabMeta
    };
  };
  const updateIndicatorState = useEventCallback$1(() => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    let startValue = 0;
    let startIndicator;
    if (vertical) {
      startIndicator = "top";
      if (tabMeta && tabsMeta) {
        startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
      }
    } else {
      startIndicator = isRtl ? "right" : "left";
      if (tabMeta && tabsMeta) {
        const correction = isRtl ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;
        startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + correction);
      }
    }
    const newIndicatorStyle = {
      [startIndicator]: startValue,
      // May be wrong until the font is loaded.
      [size]: tabMeta ? tabMeta[size] : 0
    };
    if (isNaN(indicatorStyle[startIndicator]) || isNaN(indicatorStyle[size])) {
      setIndicatorStyle(newIndicatorStyle);
    } else {
      const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
      const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
      if (dStart >= 1 || dSize >= 1) {
        setIndicatorStyle(newIndicatorStyle);
      }
    }
  });
  const scroll = (scrollValue, {
    animation = true
  } = {}) => {
    if (animation) {
      animate(scrollStart, tabsRef.current, scrollValue, {
        duration: theme2.transitions.duration.standard
      });
    } else {
      tabsRef.current[scrollStart] = scrollValue;
    }
  };
  const moveTabsScroll = (delta) => {
    let scrollValue = tabsRef.current[scrollStart];
    if (vertical) {
      scrollValue += delta;
    } else {
      scrollValue += delta * (isRtl ? -1 : 1);
      scrollValue *= isRtl && detectScrollType() === "reverse" ? -1 : 1;
    }
    scroll(scrollValue);
  };
  const getScrollSize = () => {
    const containerSize = tabsRef.current[clientSize];
    let totalSize = 0;
    const children2 = Array.from(tabListRef.current.children);
    for (let i2 = 0; i2 < children2.length; i2 += 1) {
      const tab = children2[i2];
      if (totalSize + tab[clientSize] > containerSize) {
        if (i2 === 0) {
          totalSize = containerSize;
        }
        break;
      }
      totalSize += tab[clientSize];
    }
    return totalSize;
  };
  const handleStartScrollClick = () => {
    moveTabsScroll(-1 * getScrollSize());
  };
  const handleEndScrollClick = () => {
    moveTabsScroll(getScrollSize());
  };
  const handleScrollbarSizeChange = reactExports.useCallback((scrollbarWidth) => {
    setScrollerStyle({
      overflow: null,
      scrollbarWidth
    });
  }, []);
  const getConditionalElements = () => {
    const conditionalElements2 = {};
    conditionalElements2.scrollbarSizeListener = scrollable ? /* @__PURE__ */ jsxRuntimeExports.jsx(TabsScrollbarSize, {
      onChange: handleScrollbarSizeChange,
      className: clsx(classes.scrollableX, classes.hideScrollbar)
    }) : null;
    const scrollButtonsActive = displayStartScroll || displayEndScroll;
    const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
    conditionalElements2.scrollButtonStart = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonComponent, _extends$2({
      slots: {
        StartScrollButtonIcon: slots.StartScrollButtonIcon
      },
      slotProps: {
        startScrollButtonIcon: startScrollButtonIconProps
      },
      orientation,
      direction: isRtl ? "right" : "left",
      onClick: handleStartScrollClick,
      disabled: !displayStartScroll
    }, TabScrollButtonProps, {
      className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
    })) : null;
    conditionalElements2.scrollButtonEnd = showScrollButtons ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollButtonComponent, _extends$2({
      slots: {
        EndScrollButtonIcon: slots.EndScrollButtonIcon
      },
      slotProps: {
        endScrollButtonIcon: endScrollButtonIconProps
      },
      orientation,
      direction: isRtl ? "left" : "right",
      onClick: handleEndScrollClick,
      disabled: !displayEndScroll
    }, TabScrollButtonProps, {
      className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
    })) : null;
    return conditionalElements2;
  };
  const scrollSelectedIntoView = useEventCallback$1((animation) => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    if (!tabMeta || !tabsMeta) {
      return;
    }
    if (tabMeta[start2] < tabsMeta[start2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start2] - tabsMeta[start2]);
      scroll(nextScrollStart, {
        animation
      });
    } else if (tabMeta[end2] > tabsMeta[end2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
      scroll(nextScrollStart, {
        animation
      });
    }
  });
  const updateScrollButtonState = useEventCallback$1(() => {
    if (scrollable && scrollButtons !== false) {
      setUpdateScrollObserver(!updateScrollObserver);
    }
  });
  reactExports.useEffect(() => {
    const handleResize = debounce$1(() => {
      if (tabsRef.current) {
        updateIndicatorState();
      }
    });
    const win = ownerWindow(tabsRef.current);
    win.addEventListener("resize", handleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      Array.from(tabListRef.current.children).forEach((child) => {
        resizeObserver.observe(child);
      });
    }
    return () => {
      handleResize.clear();
      win.removeEventListener("resize", handleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [updateIndicatorState]);
  reactExports.useEffect(() => {
    const tabListChildren = Array.from(tabListRef.current.children);
    const length2 = tabListChildren.length;
    if (typeof IntersectionObserver !== "undefined" && length2 > 0 && scrollable && scrollButtons !== false) {
      const firstTab = tabListChildren[0];
      const lastTab = tabListChildren[length2 - 1];
      const observerOptions = {
        root: tabsRef.current,
        threshold: 0.99
      };
      const handleScrollButtonStart = (entries) => {
        setDisplayStartScroll(!entries[0].isIntersecting);
      };
      const firstObserver = new IntersectionObserver(handleScrollButtonStart, observerOptions);
      firstObserver.observe(firstTab);
      const handleScrollButtonEnd = (entries) => {
        setDisplayEndScroll(!entries[0].isIntersecting);
      };
      const lastObserver = new IntersectionObserver(handleScrollButtonEnd, observerOptions);
      lastObserver.observe(lastTab);
      return () => {
        firstObserver.disconnect();
        lastObserver.disconnect();
      };
    }
    return void 0;
  }, [scrollable, scrollButtons, updateScrollObserver, childrenProp == null ? void 0 : childrenProp.length]);
  reactExports.useEffect(() => {
    setMounted(true);
  }, []);
  reactExports.useEffect(() => {
    updateIndicatorState();
  });
  reactExports.useEffect(() => {
    scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
  }, [scrollSelectedIntoView, indicatorStyle]);
  reactExports.useImperativeHandle(action, () => ({
    updateIndicator: updateIndicatorState,
    updateScrollButtons: updateScrollButtonState
  }), [updateIndicatorState, updateScrollButtonState]);
  const indicator = /* @__PURE__ */ jsxRuntimeExports.jsx(TabsIndicator, _extends$2({}, TabIndicatorProps, {
    className: clsx(classes.indicator, TabIndicatorProps.className),
    ownerState,
    style: _extends$2({}, indicatorStyle, TabIndicatorProps.style)
  }));
  let childIndex = 0;
  const children = reactExports.Children.map(childrenProp, (child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    const childValue = child.props.value === void 0 ? childIndex : child.props.value;
    valueToIndex.set(childValue, childIndex);
    const selected = childValue === value;
    childIndex += 1;
    return /* @__PURE__ */ reactExports.cloneElement(child, _extends$2({
      fullWidth: variant === "fullWidth",
      indicator: selected && !mounted && indicator,
      selected,
      selectionFollowsFocus,
      onChange,
      textColor,
      value: childValue
    }, childIndex === 1 && value === false && !child.props.tabIndex ? {
      tabIndex: 0
    } : {}));
  });
  const handleKeyDown2 = (event) => {
    const list = tabListRef.current;
    const currentFocus = ownerDocument(list).activeElement;
    const role = currentFocus.getAttribute("role");
    if (role !== "tab") {
      return;
    }
    let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
    let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
    if (orientation === "horizontal" && isRtl) {
      previousItemKey = "ArrowRight";
      nextItemKey = "ArrowLeft";
    }
    switch (event.key) {
      case previousItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, previousItem);
        break;
      case nextItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, nextItem);
        break;
      case "Home":
        event.preventDefault();
        moveFocus(list, null, nextItem);
        break;
      case "End":
        event.preventDefault();
        moveFocus(list, null, previousItem);
        break;
    }
  };
  const conditionalElements = getConditionalElements();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsRoot, _extends$2({
    className: clsx(classes.root, className),
    ownerState,
    ref,
    as: component
  }, other, {
    children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsScroller, {
      className: classes.scroller,
      ownerState,
      style: {
        overflow: scrollerStyle.overflow,
        [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
      },
      ref: tabsRef,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FlexContainer, {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-orientation": orientation === "vertical" ? "vertical" : null,
        className: classes.flexContainer,
        ownerState,
        onKeyDown: handleKeyDown2,
        ref: tabListRef,
        role: "tablist",
        children
      }), mounted && indicator]
    }), conditionalElements.scrollButtonEnd]
  }));
});
const Tabs$1 = Tabs;
function getTextFieldUtilityClass(slot) {
  return generateUtilityClass("MuiTextField", slot);
}
generateUtilityClasses("MuiTextField", ["root"]);
const _excluded$1a = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
const variantComponent = {
  standard: Input$1,
  filled: FilledInput$1,
  outlined: OutlinedInput$1
};
const useUtilityClasses$R = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTextFieldUtilityClass, classes);
};
const TextFieldRoot = styled$1(FormControl$1, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTextField"
  });
  const {
    autoComplete,
    autoFocus = false,
    children,
    className,
    color: color2 = "primary",
    defaultValue,
    disabled = false,
    error = false,
    FormHelperTextProps,
    fullWidth = false,
    helperText,
    id: idOverride,
    InputLabelProps,
    inputProps,
    InputProps,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = false,
    rows: rows2,
    select = false,
    SelectProps,
    type: type2,
    value,
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1a);
  const ownerState = _extends$2({}, props, {
    autoFocus,
    color: color2,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select,
    variant
  });
  const classes = useUtilityClasses$R(ownerState);
  const InputMore = {};
  if (variant === "outlined") {
    if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
      InputMore.notched = InputLabelProps.shrink;
    }
    InputMore.label = label;
  }
  if (select) {
    if (!SelectProps || !SelectProps.native) {
      InputMore.id = void 0;
    }
    InputMore["aria-describedby"] = void 0;
  }
  const id2 = useId(idOverride);
  const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
  const inputLabelId = label && id2 ? `${id2}-label` : void 0;
  const InputComponent = variantComponent[variant];
  const InputElement = /* @__PURE__ */ jsxRuntimeExports.jsx(InputComponent, _extends$2({
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name,
    rows: rows2,
    maxRows,
    minRows,
    type: type2,
    value,
    id: id2,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps
  }, InputMore, InputProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TextFieldRoot, _extends$2({
    className: clsx(classes.root, className),
    disabled,
    error,
    fullWidth,
    ref,
    required,
    color: color2,
    variant,
    ownerState
  }, other, {
    children: [label != null && label !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(MUIInputLabel, _extends$2({
      htmlFor: id2,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), select ? /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1, _extends$2({
      "aria-describedby": helperTextId,
      id: id2,
      labelId: inputLabelId,
      value,
      input: InputElement
    }, SelectProps, {
      children
    })) : InputElement, helperText && /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText$1, _extends$2({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
});
const TextField$1 = TextField;
const brandLogo = "" + new URL("virtualrx_logo-bc10d423.svg", import.meta.url).href;
const image$1 = "" + new URL("clock_image-da95e104.svg", import.meta.url).href;
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function mergeObject(target, source, options) {
  var destination = {};
  if (options.isMergeableObject(target)) {
    Object.keys(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }
  Object.keys(source).forEach(function(key) {
    if (!options.isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    } else {
      destination[key] = deepmerge(target[key], source[key], options);
    }
  });
  return destination;
}
function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}
deepmerge.all = function deepmergeAll(array2, options) {
  if (!Array.isArray(array2)) {
    throw new Error("first argument should be an array");
  }
  return array2.reduce(function(prev2, next2) {
    return deepmerge(prev2, next2, options);
  }, {});
};
var deepmerge_1 = deepmerge;
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
const root$1 = root;
var Symbol$1 = root$1.Symbol;
const Symbol$2 = Symbol$1;
var objectProto$d = Object.prototype;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
const getPrototype$1 = getPrototype;
function isObjectLike$1(value) {
  return value != null && typeof value == "object";
}
var objectTag$3 = "[object Object]";
var funcProto$2 = Function.prototype, objectProto$b = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
var objectCtorString = funcToString$2.call(Object);
function isPlainObject$4(value) {
  if (!isObjectLike$1(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$a.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}
var isArray$6 = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;
var hasElementType = typeof Element !== "undefined";
function equal$1(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    var arrA = isArray$6(a2), arrB = isArray$6(b2), i2, length2, key;
    if (arrA && arrB) {
      length2 = a2.length;
      if (length2 != b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!equal$1(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var dateA = a2 instanceof Date, dateB = b2 instanceof Date;
    if (dateA != dateB)
      return false;
    if (dateA && dateB)
      return a2.getTime() == b2.getTime();
    var regexpA = a2 instanceof RegExp, regexpB = b2 instanceof RegExp;
    if (regexpA != regexpB)
      return false;
    if (regexpA && regexpB)
      return a2.toString() == b2.toString();
    var keys3 = keyList(a2);
    length2 = keys3.length;
    if (length2 !== keyList(b2).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!hasProp.call(b2, keys3[i2]))
        return false;
    if (hasElementType && a2 instanceof Element && b2 instanceof Element)
      return a2 === b2;
    for (i2 = length2; i2-- !== 0; ) {
      key = keys3[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      } else {
        if (!equal$1(a2[key], b2[key]))
          return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
var reactFastCompare = function exportedEqual(a2, b2) {
  try {
    return equal$1(a2, b2);
  } catch (error) {
    if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {
      console.warn("Warning: react-fast-compare does not handle circular references.", error.name, error.message);
      return false;
    }
    throw error;
  }
};
const isEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
var isProduction = true;
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }
    var text = "Warning: " + message;
    if (typeof console !== "undefined") {
      console.warn(text);
    }
    try {
      throw Error(text);
    } catch (x2) {
    }
  }
}
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array2, key) {
  var length2 = array2.length;
  while (length2--) {
    if (eq(array2[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
function isObject$9(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$7(value) {
  if (!isObject$9(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
const coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject$9(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$7(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue$1(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
function getNative(object2, key) {
  var value = getValue$1(object2, key);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$1, "Map");
const Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
const nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayEach(array2, iteratee) {
  var index2 = -1, length2 = array2 == null ? 0 : array2.length;
  while (++index2 < length2) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var defineProperty$2 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
const defineProperty$3 = defineProperty$2;
function baseAssignValue(object2, key, value) {
  if (key == "__proto__" && defineProperty$3) {
    defineProperty$3(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function assignValue(object2, key, value) {
  var objValue = object2[key];
  if (!(hasOwnProperty$6.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
    baseAssignValue(object2, key, value);
  }
}
function copyObject(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length2 = props.length;
  while (++index2 < length2) {
    var key = props[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object2, key, newValue);
    } else {
      assignValue(object2, key, newValue);
    }
  }
  return object2;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike$1(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
var isArguments$3 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$1(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
const isArguments$4 = isArguments$3;
var isArray$4 = Array.isArray;
const isArray$5 = isArray$4;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer$2 = nativeIsBuffer || stubFalse;
const isBuffer$3 = isBuffer$2;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type2 = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$1(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
const nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$2 = isTypedArray$1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$5(value), isArg = !isArr && isArguments$4(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
  return value === proto;
}
var nativeKeys = overArg(Object.keys, Object);
const nativeKeys$1 = nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeys(object2) {
  if (!isPrototype(object2)) {
    return nativeKeys$1(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$3.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function isArrayLike$1(value) {
  return value != null && isLength$1(value.length) && !isFunction$7(value);
}
function keys$2(object2) {
  return isArrayLike$1(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
}
function baseAssign(object2, source) {
  return object2 && copyObject(source, keys$2(source), object2);
}
function nativeKeysIn(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeysIn(object2) {
  if (!isObject$9(object2)) {
    return nativeKeysIn(object2);
  }
  var isProto = isPrototype(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$2.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object2) {
  return isArrayLike$1(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
}
function baseAssignIn(object2, source) {
  return object2 && copyObject(source, keysIn(source), object2);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
  buffer.copy(result);
  return result;
}
function copyArray(source, array2) {
  var index2 = -1, length2 = source.length;
  array2 || (array2 = Array(length2));
  while (++index2 < length2) {
    array2[index2] = source[index2];
  }
  return array2;
}
function arrayFilter(array2, predicate) {
  var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$1 = Object.prototype;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
    return propertyIsEnumerable.call(object2, symbol);
  });
};
const getSymbols$1 = getSymbols;
function copySymbols(source, object2) {
  return copyObject(source, getSymbols$1(source), object2);
}
function arrayPush(array2, values2) {
  var index2 = -1, length2 = values2.length, offset2 = array2.length;
  while (++index2 < length2) {
    array2[offset2 + index2] = values2[index2];
  }
  return array2;
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
  var result = [];
  while (object2) {
    arrayPush(result, getSymbols$1(object2));
    object2 = getPrototype$1(object2);
  }
  return result;
};
const getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object2) {
  return copyObject(source, getSymbolsIn$1(source), object2);
}
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray$5(object2) ? result : arrayPush(result, symbolsFunc(object2));
}
function getAllKeys(object2) {
  return baseGetAllKeys(object2, keys$2, getSymbols$1);
}
function getAllKeysIn(object2) {
  return baseGetAllKeys(object2, keysIn, getSymbolsIn$1);
}
var DataView$1 = getNative(root$1, "DataView");
const DataView$2 = DataView$1;
var Promise$1 = getNative(root$1, "Promise");
const Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
const Set$2 = Set$1;
var WeakMap$1 = getNative(root$1, "WeakMap");
const WeakMap$2 = WeakMap$1;
var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag(new Map$2()) != mapTag$3 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$3 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
const getTag$1 = getTag;
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function initCloneArray(array2) {
  var length2 = array2.length, result = new array2.constructor(length2);
  if (length2 && typeof array2[0] == "string" && hasOwnProperty$1.call(array2, "index")) {
    result.index = array2.index;
    result.input = array2.input;
  }
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
const Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object2, tag, isDeep) {
  var Ctor = object2.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object2);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object2);
    case dataViewTag$1:
      return cloneDataView(object2, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object2, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object2);
    case regexpTag$1:
      return cloneRegExp(object2);
    case setTag$2:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object2);
  }
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object2() {
  }
  return function(proto) {
    if (!isObject$9(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object2.prototype = proto;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
const baseCreate$1 = baseCreate;
function initCloneObject(object2) {
  return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
}
var mapTag$1 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike$1(value) && getTag$1(value) == mapTag$1;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
const isMap$1 = isMap;
var setTag$1 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike$1(value) && getTag$1(value) == setTag$1;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
const isSet$1 = isSet;
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key, object2, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object2 ? customizer(value, key, object2, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$9(value)) {
    return value;
  }
  var isArr = isArray$5(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$3(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object2) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object2 ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys$2;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var CLONE_SYMBOLS_FLAG = 4;
function clone$4(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}
function arrayMap(array2, iteratee) {
  var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike$1(value) && baseGetTag(value) == symbolTag;
}
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName$1, function(match2, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar$1, "$1") : number2 || match2);
  });
  return result;
});
const stringToPath$2 = stringToPath$1;
var INFINITY$1 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var INFINITY = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString$1 = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$5(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString$2(value) {
  return value == null ? "" : baseToString(value);
}
function toPath(value) {
  if (isArray$5(value)) {
    return arrayMap(value, toKey);
  }
  return isSymbol(value) ? [value] : copyArray(stringToPath$2(toString$2(value)));
}
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var FormikContext = /* @__PURE__ */ reactExports.createContext(void 0);
FormikContext.displayName = "FormikContext";
FormikContext.Provider;
FormikContext.Consumer;
function useFormikContext() {
  var formik = reactExports.useContext(FormikContext);
  !!!formik ? warning(false) : void 0;
  return formik;
}
var isFunction$6 = function isFunction(obj) {
  return typeof obj === "function";
};
var isObject$8 = function isObject(obj) {
  return obj !== null && typeof obj === "object";
};
var isInteger = function isInteger2(obj) {
  return String(Math.floor(Number(obj))) === obj;
};
var isString$2 = function isString(obj) {
  return Object.prototype.toString.call(obj) === "[object String]";
};
var isPromise$2 = function isPromise(value) {
  return isObject$8(value) && isFunction$6(value.then);
};
function getIn$1(obj, key, def, p2) {
  if (p2 === void 0) {
    p2 = 0;
  }
  var path = toPath(key);
  while (obj && p2 < path.length) {
    obj = obj[path[p2++]];
  }
  if (p2 !== path.length && !obj) {
    return def;
  }
  return obj === void 0 ? def : obj;
}
function setIn(obj, path, value) {
  var res = clone$4(obj);
  var resVal = res;
  var i2 = 0;
  var pathArray = toPath(path);
  for (; i2 < pathArray.length - 1; i2++) {
    var currentPath = pathArray[i2];
    var currentObj = getIn$1(obj, pathArray.slice(0, i2 + 1));
    if (currentObj && (isObject$8(currentObj) || Array.isArray(currentObj))) {
      resVal = resVal[currentPath] = clone$4(currentObj);
    } else {
      var nextPath = pathArray[i2 + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  }
  if ((i2 === 0 ? obj : resVal)[pathArray[i2]] === value) {
    return obj;
  }
  if (value === void 0) {
    delete resVal[pathArray[i2]];
  } else {
    resVal[pathArray[i2]] = value;
  }
  if (i2 === 0 && value === void 0) {
    delete res[pathArray[i2]];
  }
  return res;
}
function setNestedObjectValues(object2, value, visited, response) {
  if (visited === void 0) {
    visited = /* @__PURE__ */ new WeakMap();
  }
  if (response === void 0) {
    response = {};
  }
  for (var _i = 0, _Object$keys = Object.keys(object2); _i < _Object$keys.length; _i++) {
    var k2 = _Object$keys[_i];
    var val = object2[k2];
    if (isObject$8(val)) {
      if (!visited.get(val)) {
        visited.set(val, true);
        response[k2] = Array.isArray(val) ? [] : {};
        setNestedObjectValues(val, value, visited, response[k2]);
      }
    } else {
      response[k2] = value;
    }
  }
  return response;
}
function formikReducer(state, msg) {
  switch (msg.type) {
    case "SET_VALUES":
      return _extends$1({}, state, {
        values: msg.payload
      });
    case "SET_TOUCHED":
      return _extends$1({}, state, {
        touched: msg.payload
      });
    case "SET_ERRORS":
      if (isEqual$1(state.errors, msg.payload)) {
        return state;
      }
      return _extends$1({}, state, {
        errors: msg.payload
      });
    case "SET_STATUS":
      return _extends$1({}, state, {
        status: msg.payload
      });
    case "SET_ISSUBMITTING":
      return _extends$1({}, state, {
        isSubmitting: msg.payload
      });
    case "SET_ISVALIDATING":
      return _extends$1({}, state, {
        isValidating: msg.payload
      });
    case "SET_FIELD_VALUE":
      return _extends$1({}, state, {
        values: setIn(state.values, msg.payload.field, msg.payload.value)
      });
    case "SET_FIELD_TOUCHED":
      return _extends$1({}, state, {
        touched: setIn(state.touched, msg.payload.field, msg.payload.value)
      });
    case "SET_FIELD_ERROR":
      return _extends$1({}, state, {
        errors: setIn(state.errors, msg.payload.field, msg.payload.value)
      });
    case "RESET_FORM":
      return _extends$1({}, state, msg.payload);
    case "SET_FORMIK_STATE":
      return msg.payload(state);
    case "SUBMIT_ATTEMPT":
      return _extends$1({}, state, {
        touched: setNestedObjectValues(state.values, true),
        isSubmitting: true,
        submitCount: state.submitCount + 1
      });
    case "SUBMIT_FAILURE":
      return _extends$1({}, state, {
        isSubmitting: false
      });
    case "SUBMIT_SUCCESS":
      return _extends$1({}, state, {
        isSubmitting: false
      });
    default:
      return state;
  }
}
var emptyErrors = {};
var emptyTouched = {};
function useFormik(_ref) {
  var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose(_ref, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]);
  var props = _extends$1({
    validateOnChange,
    validateOnBlur,
    validateOnMount,
    onSubmit
  }, rest);
  var initialValues = reactExports.useRef(props.initialValues);
  var initialErrors = reactExports.useRef(props.initialErrors || emptyErrors);
  var initialTouched = reactExports.useRef(props.initialTouched || emptyTouched);
  var initialStatus = reactExports.useRef(props.initialStatus);
  var isMounted = reactExports.useRef(false);
  var fieldRegistry = reactExports.useRef({});
  reactExports.useEffect(function() {
    isMounted.current = true;
    return function() {
      isMounted.current = false;
    };
  }, []);
  var _React$useState = reactExports.useState(0), setIteration = _React$useState[1];
  var stateRef = reactExports.useRef({
    values: props.initialValues,
    errors: props.initialErrors || emptyErrors,
    touched: props.initialTouched || emptyTouched,
    status: props.initialStatus,
    isSubmitting: false,
    isValidating: false,
    submitCount: 0
  });
  var state = stateRef.current;
  var dispatch = reactExports.useCallback(function(action) {
    var prev2 = stateRef.current;
    stateRef.current = formikReducer(prev2, action);
    if (prev2 !== stateRef.current)
      setIteration(function(x2) {
        return x2 + 1;
      });
  }, []);
  var runValidateHandler = reactExports.useCallback(function(values2, field) {
    return new Promise(function(resolve2, reject) {
      var maybePromisedErrors = props.validate(values2, field);
      if (maybePromisedErrors == null) {
        resolve2(emptyErrors);
      } else if (isPromise$2(maybePromisedErrors)) {
        maybePromisedErrors.then(function(errors) {
          resolve2(errors || emptyErrors);
        }, function(actualException) {
          reject(actualException);
        });
      } else {
        resolve2(maybePromisedErrors);
      }
    });
  }, [props.validate]);
  var runValidationSchema = reactExports.useCallback(function(values2, field) {
    var validationSchema = props.validationSchema;
    var schema = isFunction$6(validationSchema) ? validationSchema(field) : validationSchema;
    var promise2 = field && schema.validateAt ? schema.validateAt(field, values2) : validateYupSchema(values2, schema);
    return new Promise(function(resolve2, reject) {
      promise2.then(function() {
        resolve2(emptyErrors);
      }, function(err) {
        if (err.name === "ValidationError") {
          resolve2(yupToFormErrors(err));
        } else {
          reject(err);
        }
      });
    });
  }, [props.validationSchema]);
  var runSingleFieldLevelValidation = reactExports.useCallback(function(field, value) {
    return new Promise(function(resolve2) {
      return resolve2(fieldRegistry.current[field].validate(value));
    });
  }, []);
  var runFieldLevelValidations = reactExports.useCallback(function(values2) {
    var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f2) {
      return isFunction$6(fieldRegistry.current[f2].validate);
    });
    var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f2) {
      return runSingleFieldLevelValidation(f2, getIn$1(values2, f2));
    }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
    return Promise.all(fieldValidations).then(function(fieldErrorsList) {
      return fieldErrorsList.reduce(function(prev2, curr, index2) {
        if (curr === "DO_NOT_DELETE_YOU_WILL_BE_FIRED") {
          return prev2;
        }
        if (curr) {
          prev2 = setIn(prev2, fieldKeysWithValidation[index2], curr);
        }
        return prev2;
      }, {});
    });
  }, [runSingleFieldLevelValidation]);
  var runAllValidations = reactExports.useCallback(function(values2) {
    return Promise.all([runFieldLevelValidations(values2), props.validationSchema ? runValidationSchema(values2) : {}, props.validate ? runValidateHandler(values2) : {}]).then(function(_ref2) {
      var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];
      var combinedErrors = deepmerge_1.all([fieldErrors, schemaErrors, validateErrors], {
        arrayMerge
      });
      return combinedErrors;
    });
  }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]);
  var validateFormWithHighPriority = useEventCallback(function(values2) {
    if (values2 === void 0) {
      values2 = state.values;
    }
    dispatch({
      type: "SET_ISVALIDATING",
      payload: true
    });
    return runAllValidations(values2).then(function(combinedErrors) {
      if (!!isMounted.current) {
        dispatch({
          type: "SET_ISVALIDATING",
          payload: false
        });
        dispatch({
          type: "SET_ERRORS",
          payload: combinedErrors
        });
      }
      return combinedErrors;
    });
  });
  reactExports.useEffect(function() {
    if (validateOnMount && isMounted.current === true && isEqual$1(initialValues.current, props.initialValues)) {
      validateFormWithHighPriority(initialValues.current);
    }
  }, [validateOnMount, validateFormWithHighPriority]);
  var resetForm = reactExports.useCallback(function(nextState) {
    var values2 = nextState && nextState.values ? nextState.values : initialValues.current;
    var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};
    var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};
    var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;
    initialValues.current = values2;
    initialErrors.current = errors;
    initialTouched.current = touched;
    initialStatus.current = status;
    var dispatchFn = function dispatchFn2() {
      dispatch({
        type: "RESET_FORM",
        payload: {
          isSubmitting: !!nextState && !!nextState.isSubmitting,
          errors,
          touched,
          status,
          values: values2,
          isValidating: !!nextState && !!nextState.isValidating,
          submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === "number" ? nextState.submitCount : 0
        }
      });
    };
    if (props.onReset) {
      var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);
      if (isPromise$2(maybePromisedOnReset)) {
        maybePromisedOnReset.then(dispatchFn);
      } else {
        dispatchFn();
      }
    } else {
      dispatchFn();
    }
  }, [props.initialErrors, props.initialStatus, props.initialTouched, props.onReset]);
  reactExports.useEffect(function() {
    if (isMounted.current === true && !isEqual$1(initialValues.current, props.initialValues)) {
      if (enableReinitialize) {
        initialValues.current = props.initialValues;
        resetForm();
        if (validateOnMount) {
          validateFormWithHighPriority(initialValues.current);
        }
      }
    }
  }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);
  reactExports.useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !isEqual$1(initialErrors.current, props.initialErrors)) {
      initialErrors.current = props.initialErrors || emptyErrors;
      dispatch({
        type: "SET_ERRORS",
        payload: props.initialErrors || emptyErrors
      });
    }
  }, [enableReinitialize, props.initialErrors]);
  reactExports.useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !isEqual$1(initialTouched.current, props.initialTouched)) {
      initialTouched.current = props.initialTouched || emptyTouched;
      dispatch({
        type: "SET_TOUCHED",
        payload: props.initialTouched || emptyTouched
      });
    }
  }, [enableReinitialize, props.initialTouched]);
  reactExports.useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !isEqual$1(initialStatus.current, props.initialStatus)) {
      initialStatus.current = props.initialStatus;
      dispatch({
        type: "SET_STATUS",
        payload: props.initialStatus
      });
    }
  }, [enableReinitialize, props.initialStatus, props.initialTouched]);
  var validateField = useEventCallback(function(name) {
    if (fieldRegistry.current[name] && isFunction$6(fieldRegistry.current[name].validate)) {
      var value = getIn$1(state.values, name);
      var maybePromise = fieldRegistry.current[name].validate(value);
      if (isPromise$2(maybePromise)) {
        dispatch({
          type: "SET_ISVALIDATING",
          payload: true
        });
        return maybePromise.then(function(x2) {
          return x2;
        }).then(function(error) {
          dispatch({
            type: "SET_FIELD_ERROR",
            payload: {
              field: name,
              value: error
            }
          });
          dispatch({
            type: "SET_ISVALIDATING",
            payload: false
          });
        });
      } else {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field: name,
            value: maybePromise
          }
        });
        return Promise.resolve(maybePromise);
      }
    } else if (props.validationSchema) {
      dispatch({
        type: "SET_ISVALIDATING",
        payload: true
      });
      return runValidationSchema(state.values, name).then(function(x2) {
        return x2;
      }).then(function(error) {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field: name,
            value: getIn$1(error, name)
          }
        });
        dispatch({
          type: "SET_ISVALIDATING",
          payload: false
        });
      });
    }
    return Promise.resolve();
  });
  var registerField = reactExports.useCallback(function(name, _ref3) {
    var validate = _ref3.validate;
    fieldRegistry.current[name] = {
      validate
    };
  }, []);
  var unregisterField = reactExports.useCallback(function(name) {
    delete fieldRegistry.current[name];
  }, []);
  var setTouched = useEventCallback(function(touched, shouldValidate) {
    dispatch({
      type: "SET_TOUCHED",
      payload: touched
    });
    var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var setErrors = reactExports.useCallback(function(errors) {
    dispatch({
      type: "SET_ERRORS",
      payload: errors
    });
  }, []);
  var setValues = useEventCallback(function(values2, shouldValidate) {
    var resolvedValues = isFunction$6(values2) ? values2(state.values) : values2;
    dispatch({
      type: "SET_VALUES",
      payload: resolvedValues
    });
    var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();
  });
  var setFieldError = reactExports.useCallback(function(field, value) {
    dispatch({
      type: "SET_FIELD_ERROR",
      payload: {
        field,
        value
      }
    });
  }, []);
  var setFieldValue = useEventCallback(function(field, value, shouldValidate) {
    dispatch({
      type: "SET_FIELD_VALUE",
      payload: {
        field,
        value
      }
    });
    var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();
  });
  var executeChange = reactExports.useCallback(function(eventOrTextValue, maybePath) {
    var field = maybePath;
    var val = eventOrTextValue;
    var parsed;
    if (!isString$2(eventOrTextValue)) {
      if (eventOrTextValue.persist) {
        eventOrTextValue.persist();
      }
      var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;
      var type2 = target.type, name = target.name, id2 = target.id, value = target.value, checked = target.checked, outerHTML = target.outerHTML, options = target.options, multiple = target.multiple;
      field = maybePath ? maybePath : name ? name : id2;
      if (!field && false) {
        warnAboutMissingIdentifier({
          htmlContent: outerHTML,
          documentationAnchorLink: "handlechange-e-reactchangeeventany--void",
          handlerName: "handleChange"
        });
      }
      val = /number|range/.test(type2) ? (parsed = parseFloat(value), isNaN(parsed) ? "" : parsed) : /checkbox/.test(type2) ? getValueForCheckbox(getIn$1(state.values, field), checked, value) : options && multiple ? getSelectedValues(options) : value;
    }
    if (field) {
      setFieldValue(field, val);
    }
  }, [setFieldValue, state.values]);
  var handleChange = useEventCallback(function(eventOrPath) {
    if (isString$2(eventOrPath)) {
      return function(event) {
        return executeChange(event, eventOrPath);
      };
    } else {
      executeChange(eventOrPath);
    }
  });
  var setFieldTouched = useEventCallback(function(field, touched, shouldValidate) {
    if (touched === void 0) {
      touched = true;
    }
    dispatch({
      type: "SET_FIELD_TOUCHED",
      payload: {
        field,
        value: touched
      }
    });
    var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var executeBlur = reactExports.useCallback(function(e2, path) {
    if (e2.persist) {
      e2.persist();
    }
    var _e$target = e2.target, name = _e$target.name, id2 = _e$target.id, outerHTML = _e$target.outerHTML;
    var field = path ? path : name ? name : id2;
    if (!field && false) {
      warnAboutMissingIdentifier({
        htmlContent: outerHTML,
        documentationAnchorLink: "handleblur-e-any--void",
        handlerName: "handleBlur"
      });
    }
    setFieldTouched(field, true);
  }, [setFieldTouched]);
  var handleBlur = useEventCallback(function(eventOrString) {
    if (isString$2(eventOrString)) {
      return function(event) {
        return executeBlur(event, eventOrString);
      };
    } else {
      executeBlur(eventOrString);
    }
  });
  var setFormikState = reactExports.useCallback(function(stateOrCb) {
    if (isFunction$6(stateOrCb)) {
      dispatch({
        type: "SET_FORMIK_STATE",
        payload: stateOrCb
      });
    } else {
      dispatch({
        type: "SET_FORMIK_STATE",
        payload: function payload() {
          return stateOrCb;
        }
      });
    }
  }, []);
  var setStatus = reactExports.useCallback(function(status) {
    dispatch({
      type: "SET_STATUS",
      payload: status
    });
  }, []);
  var setSubmitting = reactExports.useCallback(function(isSubmitting) {
    dispatch({
      type: "SET_ISSUBMITTING",
      payload: isSubmitting
    });
  }, []);
  var submitForm = useEventCallback(function() {
    dispatch({
      type: "SUBMIT_ATTEMPT"
    });
    return validateFormWithHighPriority().then(function(combinedErrors) {
      var isInstanceOfError = combinedErrors instanceof Error;
      var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;
      if (isActuallyValid) {
        var promiseOrUndefined;
        try {
          promiseOrUndefined = executeSubmit();
          if (promiseOrUndefined === void 0) {
            return;
          }
        } catch (error) {
          throw error;
        }
        return Promise.resolve(promiseOrUndefined).then(function(result) {
          if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_SUCCESS"
            });
          }
          return result;
        })["catch"](function(_errors) {
          if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_FAILURE"
            });
            throw _errors;
          }
        });
      } else if (!!isMounted.current) {
        dispatch({
          type: "SUBMIT_FAILURE"
        });
        if (isInstanceOfError) {
          throw combinedErrors;
        }
      }
      return;
    });
  });
  var handleSubmit = useEventCallback(function(e2) {
    if (e2 && e2.preventDefault && isFunction$6(e2.preventDefault)) {
      e2.preventDefault();
    }
    if (e2 && e2.stopPropagation && isFunction$6(e2.stopPropagation)) {
      e2.stopPropagation();
    }
    submitForm()["catch"](function(reason) {
      console.warn("Warning: An unhandled error was caught from submitForm()", reason);
    });
  });
  var imperativeMethods = {
    resetForm,
    validateForm: validateFormWithHighPriority,
    validateField,
    setErrors,
    setFieldError,
    setFieldTouched,
    setFieldValue,
    setStatus,
    setSubmitting,
    setTouched,
    setValues,
    setFormikState,
    submitForm
  };
  var executeSubmit = useEventCallback(function() {
    return onSubmit(state.values, imperativeMethods);
  });
  var handleReset2 = useEventCallback(function(e2) {
    if (e2 && e2.preventDefault && isFunction$6(e2.preventDefault)) {
      e2.preventDefault();
    }
    if (e2 && e2.stopPropagation && isFunction$6(e2.stopPropagation)) {
      e2.stopPropagation();
    }
    resetForm();
  });
  var getFieldMeta = reactExports.useCallback(function(name) {
    return {
      value: getIn$1(state.values, name),
      error: getIn$1(state.errors, name),
      touched: !!getIn$1(state.touched, name),
      initialValue: getIn$1(initialValues.current, name),
      initialTouched: !!getIn$1(initialTouched.current, name),
      initialError: getIn$1(initialErrors.current, name)
    };
  }, [state.errors, state.touched, state.values]);
  var getFieldHelpers = reactExports.useCallback(function(name) {
    return {
      setValue: function setValue2(value, shouldValidate) {
        return setFieldValue(name, value, shouldValidate);
      },
      setTouched: function setTouched2(value, shouldValidate) {
        return setFieldTouched(name, value, shouldValidate);
      },
      setError: function setError(value) {
        return setFieldError(name, value);
      }
    };
  }, [setFieldValue, setFieldTouched, setFieldError]);
  var getFieldProps = reactExports.useCallback(function(nameOrOptions) {
    var isAnObject = isObject$8(nameOrOptions);
    var name = isAnObject ? nameOrOptions.name : nameOrOptions;
    var valueState = getIn$1(state.values, name);
    var field = {
      name,
      value: valueState,
      onChange: handleChange,
      onBlur: handleBlur
    };
    if (isAnObject) {
      var type2 = nameOrOptions.type, valueProp = nameOrOptions.value, is3 = nameOrOptions.as, multiple = nameOrOptions.multiple;
      if (type2 === "checkbox") {
        if (valueProp === void 0) {
          field.checked = !!valueState;
        } else {
          field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
          field.value = valueProp;
        }
      } else if (type2 === "radio") {
        field.checked = valueState === valueProp;
        field.value = valueProp;
      } else if (is3 === "select" && multiple) {
        field.value = field.value || [];
        field.multiple = true;
      }
    }
    return field;
  }, [handleBlur, handleChange, state.values]);
  var dirty = reactExports.useMemo(function() {
    return !isEqual$1(initialValues.current, state.values);
  }, [initialValues.current, state.values]);
  var isValid = reactExports.useMemo(function() {
    return typeof isInitialValid !== "undefined" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction$6(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;
  }, [isInitialValid, dirty, state.errors, props]);
  var ctx = _extends$1({}, state, {
    initialValues: initialValues.current,
    initialErrors: initialErrors.current,
    initialTouched: initialTouched.current,
    initialStatus: initialStatus.current,
    handleBlur,
    handleChange,
    handleReset: handleReset2,
    handleSubmit,
    resetForm,
    setErrors,
    setFormikState,
    setFieldTouched,
    setFieldValue,
    setFieldError,
    setStatus,
    setSubmitting,
    setTouched,
    setValues,
    submitForm,
    validateForm: validateFormWithHighPriority,
    validateField,
    isValid,
    dirty,
    unregisterField,
    registerField,
    getFieldProps,
    getFieldMeta,
    getFieldHelpers,
    validateOnBlur,
    validateOnChange,
    validateOnMount
  });
  return ctx;
}
function warnAboutMissingIdentifier(_ref4) {
  var htmlContent = _ref4.htmlContent, documentationAnchorLink = _ref4.documentationAnchorLink, handlerName = _ref4.handlerName;
  console.warn("Warning: Formik called `" + handlerName + "`, but you forgot to pass an `id` or `name` attribute to your input:\n    " + htmlContent + "\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#" + documentationAnchorLink + "\n  ");
}
function yupToFormErrors(yupError) {
  var errors = {};
  if (yupError.inner) {
    if (yupError.inner.length === 0) {
      return setIn(errors, yupError.path, yupError.message);
    }
    for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
      var _ref5;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref5 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref5 = _i.value;
      }
      var err = _ref5;
      if (!getIn$1(errors, err.path)) {
        errors = setIn(errors, err.path, err.message);
      }
    }
  }
  return errors;
}
function validateYupSchema(values2, schema, sync, context) {
  if (sync === void 0) {
    sync = false;
  }
  var normalizedValues = prepareDataForValidation(values2);
  return schema[sync ? "validateSync" : "validate"](normalizedValues, {
    abortEarly: false,
    context: context || normalizedValues
  });
}
function prepareDataForValidation(values2) {
  var data = Array.isArray(values2) ? [] : {};
  for (var k2 in values2) {
    if (Object.prototype.hasOwnProperty.call(values2, k2)) {
      var key = String(k2);
      if (Array.isArray(values2[key]) === true) {
        data[key] = values2[key].map(function(value) {
          if (Array.isArray(value) === true || isPlainObject$4(value)) {
            return prepareDataForValidation(value);
          } else {
            return value !== "" ? value : void 0;
          }
        });
      } else if (isPlainObject$4(values2[key])) {
        data[key] = prepareDataForValidation(values2[key]);
      } else {
        data[key] = values2[key] !== "" ? values2[key] : void 0;
      }
    }
  }
  return data;
}
function arrayMerge(target, source, options) {
  var destination = target.slice();
  source.forEach(function merge2(e2, i2) {
    if (typeof destination[i2] === "undefined") {
      var cloneRequested = options.clone !== false;
      var shouldClone = cloneRequested && options.isMergeableObject(e2);
      destination[i2] = shouldClone ? deepmerge_1(Array.isArray(e2) ? [] : {}, e2, options) : e2;
    } else if (options.isMergeableObject(e2)) {
      destination[i2] = deepmerge_1(target[i2], e2, options);
    } else if (target.indexOf(e2) === -1) {
      destination.push(e2);
    }
  });
  return destination;
}
function getSelectedValues(options) {
  return Array.from(options).filter(function(el2) {
    return el2.selected;
  }).map(function(el2) {
    return el2.value;
  });
}
function getValueForCheckbox(currentValue, checked, valueProp) {
  if (typeof currentValue === "boolean") {
    return Boolean(checked);
  }
  var currentArrayOfValues = [];
  var isValueInArray = false;
  var index2 = -1;
  if (!Array.isArray(currentValue)) {
    if (!valueProp || valueProp == "true" || valueProp == "false") {
      return Boolean(checked);
    }
  } else {
    currentArrayOfValues = currentValue;
    index2 = currentValue.indexOf(valueProp);
    isValueInArray = index2 >= 0;
  }
  if (checked && valueProp && !isValueInArray) {
    return currentArrayOfValues.concat(valueProp);
  }
  if (!isValueInArray) {
    return currentArrayOfValues;
  }
  return currentArrayOfValues.slice(0, index2).concat(currentArrayOfValues.slice(index2 + 1));
}
var useIsomorphicLayoutEffect$2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useEventCallback(fn3) {
  var ref = reactExports.useRef(fn3);
  useIsomorphicLayoutEffect$2(function() {
    ref.current = fn3;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current.apply(void 0, args);
  }, []);
}
var Form = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var action = props.action, rest = _objectWithoutPropertiesLoose(props, ["action"]);
  var _action = action != null ? action : "#";
  var _useFormikContext = useFormikContext(), handleReset2 = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;
  return reactExports.createElement("form", _extends$1({
    onSubmit: handleSubmit,
    ref,
    onReset: handleReset2,
    action: _action
  }, rest));
});
Form.displayName = "Form";
function Cache$1(maxSize) {
  this._maxSize = maxSize;
  this.clear();
}
Cache$1.prototype.clear = function() {
  this._size = 0;
  this._values = /* @__PURE__ */ Object.create(null);
};
Cache$1.prototype.get = function(key) {
  return this._values[key];
};
Cache$1.prototype.set = function(key, value) {
  this._size >= this._maxSize && this.clear();
  if (!(key in this._values))
    this._size++;
  return this._values[key] = value;
};
var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g, DIGIT_REGEX = /^\d+$/, LEAD_DIGIT_REGEX = /^\d/, SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/, MAX_CACHE_SIZE = 512;
var pathCache = new Cache$1(MAX_CACHE_SIZE), setCache = new Cache$1(MAX_CACHE_SIZE), getCache = new Cache$1(MAX_CACHE_SIZE);
var propertyExpr = {
  Cache: Cache$1,
  split,
  normalizePath,
  setter: function(path) {
    var parts = normalizePath(path);
    return setCache.get(path) || setCache.set(path, function setter(obj, value) {
      var index2 = 0;
      var len = parts.length;
      var data = obj;
      while (index2 < len - 1) {
        var part = parts[index2];
        if (part === "__proto__" || part === "constructor" || part === "prototype") {
          return obj;
        }
        data = data[parts[index2++]];
      }
      data[parts[index2]] = value;
    });
  },
  getter: function(path, safe) {
    var parts = normalizePath(path);
    return getCache.get(path) || getCache.set(path, function getter(data) {
      var index2 = 0, len = parts.length;
      while (index2 < len) {
        if (data != null || !safe)
          data = data[parts[index2++]];
        else
          return;
      }
      return data;
    });
  },
  join: function(segments) {
    return segments.reduce(function(path, part) {
      return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
    }, "");
  },
  forEach: function(path, cb2, thisArg) {
    forEach$1(Array.isArray(path) ? path : split(path), cb2, thisArg);
  }
};
function normalizePath(path) {
  return pathCache.get(path) || pathCache.set(
    path,
    split(path).map(function(part) {
      return part.replace(CLEAN_QUOTES_REGEX, "$2");
    })
  );
}
function split(path) {
  return path.match(SPLIT_REGEX) || [""];
}
function forEach$1(parts, iter, thisArg) {
  var len = parts.length, part, idx, isArray3, isBracket;
  for (idx = 0; idx < len; idx++) {
    part = parts[idx];
    if (part) {
      if (shouldBeQuoted(part)) {
        part = '"' + part + '"';
      }
      isBracket = isQuoted(part);
      isArray3 = !isBracket && /^\d+$/.test(part);
      iter.call(thisArg, part, isBracket, isArray3, idx, parts);
    }
  }
}
function isQuoted(str) {
  return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
}
function hasLeadingNumber(part) {
  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
}
function hasSpecialChars(part) {
  return SPEC_CHAR_REGEX.test(part);
}
function shouldBeQuoted(part) {
  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
}
const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
const words = (str) => str.match(reWords) || [];
const upperFirst = (str) => str[0].toUpperCase() + str.slice(1);
const join = (str, d2) => words(str).join(d2).toLowerCase();
const camelCase = (str) => words(str).reduce(
  (acc, next2) => `${acc}${!acc ? next2.toLowerCase() : next2[0].toUpperCase() + next2.slice(1).toLowerCase()}`,
  ""
);
const pascalCase = (str) => upperFirst(camelCase(str));
const snakeCase = (str) => join(str, "_");
const kebabCase = (str) => join(str, "-");
const sentenceCase = (str) => upperFirst(join(str, " "));
const titleCase = (str) => words(str).map(upperFirst).join(" ");
var tinyCase = {
  words,
  upperFirst,
  camelCase,
  pascalCase,
  snakeCase,
  kebabCase,
  sentenceCase,
  titleCase
};
var toposort$2 = { exports: {} };
toposort$2.exports = function(edges) {
  return toposort(uniqueNodes(edges), edges);
};
toposort$2.exports.array = toposort;
function toposort(nodes, edges) {
  var cursor2 = nodes.length, sorted = new Array(cursor2), visited = {}, i2 = cursor2, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
  edges.forEach(function(edge) {
    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
      throw new Error("Unknown node. There is an unknown node in the supplied edges.");
    }
  });
  while (i2--) {
    if (!visited[i2])
      visit(nodes[i2], i2, /* @__PURE__ */ new Set());
  }
  return sorted;
  function visit(node2, i3, predecessors) {
    if (predecessors.has(node2)) {
      var nodeRep;
      try {
        nodeRep = ", node was:" + JSON.stringify(node2);
      } catch (e2) {
        nodeRep = "";
      }
      throw new Error("Cyclic dependency" + nodeRep);
    }
    if (!nodesHash.has(node2)) {
      throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node2));
    }
    if (visited[i3])
      return;
    visited[i3] = true;
    var outgoing = outgoingEdges.get(node2) || /* @__PURE__ */ new Set();
    outgoing = Array.from(outgoing);
    if (i3 = outgoing.length) {
      predecessors.add(node2);
      do {
        var child = outgoing[--i3];
        visit(child, nodesHash.get(child), predecessors);
      } while (i3);
      predecessors.delete(node2);
    }
    sorted[--cursor2] = node2;
  }
}
function uniqueNodes(arr) {
  var res = /* @__PURE__ */ new Set();
  for (var i2 = 0, len = arr.length; i2 < len; i2++) {
    var edge = arr[i2];
    res.add(edge[0]);
    res.add(edge[1]);
  }
  return Array.from(res);
}
function makeOutgoingEdges(arr) {
  var edges = /* @__PURE__ */ new Map();
  for (var i2 = 0, len = arr.length; i2 < len; i2++) {
    var edge = arr[i2];
    if (!edges.has(edge[0]))
      edges.set(edge[0], /* @__PURE__ */ new Set());
    if (!edges.has(edge[1]))
      edges.set(edge[1], /* @__PURE__ */ new Set());
    edges.get(edge[0]).add(edge[1]);
  }
  return edges;
}
function makeNodesHash(arr) {
  var res = /* @__PURE__ */ new Map();
  for (var i2 = 0, len = arr.length; i2 < len; i2++) {
    res.set(arr[i2], i2);
  }
  return res;
}
var toposortExports = toposort$2.exports;
const toposort$1 = /* @__PURE__ */ getDefaultExportFromCjs(toposortExports);
const toString$1 = Object.prototype.toString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val)
    return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false)
    return "" + val;
  const typeOf = typeof val;
  if (typeOf === "number")
    return printNumber(val);
  if (typeOf === "string")
    return quoteStrings ? `"${val}"` : val;
  if (typeOf === "function")
    return "[Function " + (val.name || "anonymous") + "]";
  if (typeOf === "symbol")
    return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString$1.call(val).slice(8, -1);
  if (tag === "Date")
    return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
  if (tag === "Error" || val instanceof Error)
    return "[" + errorToString.call(val) + "]";
  if (tag === "RegExp")
    return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null)
    return result;
  return JSON.stringify(value, function(key, value2) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null)
      return result2;
    return value2;
  }, 2);
}
function toArray$2(value) {
  return value == null ? [] : [].concat(value);
}
let _Symbol$toStringTag;
let strReg = /\$\{\s*(\w+)\s*\}/g;
_Symbol$toStringTag = Symbol.toStringTag;
class ValidationError extends Error {
  static formatError(message, params) {
    const path = params.label || params.path || "this";
    if (path !== params.path)
      params = Object.assign({}, params, {
        path
      });
    if (typeof message === "string")
      return message.replace(strReg, (_2, key) => printValue(params[key]));
    if (typeof message === "function")
      return message(params);
    return message;
  }
  static isError(err) {
    return err && err.name === "ValidationError";
  }
  constructor(errorOrErrors, value, field, type2, disableStack) {
    super();
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.errors = void 0;
    this.params = void 0;
    this.inner = void 0;
    this[_Symbol$toStringTag] = "Error";
    this.name = "ValidationError";
    this.value = value;
    this.path = field;
    this.type = type2;
    this.errors = [];
    this.inner = [];
    toArray$2(errorOrErrors).forEach((err) => {
      if (ValidationError.isError(err)) {
        this.errors.push(...err.errors);
        const innerErrors = err.inner.length ? err.inner : [err];
        this.inner.push(...innerErrors);
      } else {
        this.errors.push(err);
      }
    });
    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
    if (!disableStack && Error.captureStackTrace)
      Error.captureStackTrace(this, ValidationError);
  }
}
let mixed = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  defined: "${path} must be defined",
  notNull: "${path} cannot be null",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path,
    type: type2,
    value,
    originalValue
  }) => {
    const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
    return type2 !== "mixed" ? `${path} must be a \`${type2}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
  }
};
let string = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
};
let number = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
};
let date = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
};
let boolean = {
  isValue: "${path} field must be ${value}"
};
let object = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
};
let array = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
let tuple = {
  notType: (params) => {
    const {
      path,
      value,
      spec
    } = params;
    const typeLen = spec.types.length;
    if (Array.isArray(value)) {
      if (value.length < typeLen)
        return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
      if (value.length > typeLen)
        return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
    }
    return ValidationError.formatError(mixed.notType, params);
  }
};
Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed,
  string,
  number,
  date,
  object,
  array,
  boolean,
  tuple
});
const isSchema = (obj) => obj && obj.__isYupSchema__;
class Condition {
  static fromOptions(refs, config2) {
    if (!config2.then && !config2.otherwise)
      throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is: is3,
      then,
      otherwise
    } = config2;
    let check = typeof is3 === "function" ? is3 : (...values2) => values2.every((value) => value === is3);
    return new Condition(refs, (values2, schema) => {
      var _branch;
      let branch = check(...values2) ? then : otherwise;
      return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
    });
  }
  constructor(refs, builder) {
    this.fn = void 0;
    this.refs = refs;
    this.refs = refs;
    this.fn = builder;
  }
  resolve(base, options) {
    let values2 = this.refs.map((ref) => (
      // TODO: ? operator here?
      ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context)
    ));
    let schema = this.fn(values2, base, options);
    if (schema === void 0 || // @ts-ignore this can be base
    schema === base) {
      return base;
    }
    if (!isSchema(schema))
      throw new TypeError("conditions must return a schema object");
    return schema.resolve(options);
  }
}
const prefixes = {
  context: "$",
  value: "."
};
class Reference {
  constructor(key, options = {}) {
    this.key = void 0;
    this.isContext = void 0;
    this.isValue = void 0;
    this.isSibling = void 0;
    this.path = void 0;
    this.getter = void 0;
    this.map = void 0;
    if (typeof key !== "string")
      throw new TypeError("ref must be a string, got: " + key);
    this.key = key.trim();
    if (key === "")
      throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix2 = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
    this.path = this.key.slice(prefix2.length);
    this.getter = this.path && propertyExpr.getter(this.path, true);
    this.map = options.map;
  }
  getValue(value, parent, context) {
    let result = this.isContext ? context : this.isValue ? value : parent;
    if (this.getter)
      result = this.getter(result || {});
    if (this.map)
      result = this.map(result);
    return result;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(value, options) {
    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(value) {
    return value && value.__isYupRef;
  }
}
Reference.prototype.__isYupRef = true;
const isAbsent = (value) => value == null;
function createValidation(config2) {
  function validate({
    value,
    path = "",
    options,
    originalValue,
    schema
  }, panic, next2) {
    const {
      name,
      test: test2,
      params,
      message,
      skipAbsent
    } = config2;
    let {
      parent,
      context,
      abortEarly = schema.spec.abortEarly,
      disableStackTrace = schema.spec.disableStackTrace
    } = options;
    function resolve2(item) {
      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
    }
    function createError(overrides = {}) {
      var _overrides$disableSta;
      const nextParams = Object.assign({
        value,
        originalValue,
        label: schema.spec.label,
        path: overrides.path || path,
        spec: schema.spec
      }, params, overrides.params);
      for (const key of Object.keys(nextParams))
        nextParams[key] = resolve2(nextParams[key]);
      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, (_overrides$disableSta = overrides.disableStackTrace) != null ? _overrides$disableSta : disableStackTrace);
      error.params = nextParams;
      return error;
    }
    const invalid = abortEarly ? panic : next2;
    let ctx = {
      path,
      parent,
      type: name,
      from: options.from,
      createError,
      resolve: resolve2,
      options,
      originalValue,
      schema
    };
    const handleResult = (validOrError) => {
      if (ValidationError.isError(validOrError))
        invalid(validOrError);
      else if (!validOrError)
        invalid(createError());
      else
        next2(null);
    };
    const handleError = (err) => {
      if (ValidationError.isError(err))
        invalid(err);
      else
        panic(err);
    };
    const shouldSkip = skipAbsent && isAbsent(value);
    if (shouldSkip) {
      return handleResult(true);
    }
    let result;
    try {
      var _result;
      result = test2.call(ctx, value, ctx);
      if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
        if (options.sync) {
          throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
        }
        return Promise.resolve(result).then(handleResult, handleError);
      }
    } catch (err) {
      handleError(err);
      return;
    }
    handleResult(result);
  }
  validate.OPTIONS = config2;
  return validate;
}
function getIn(schema, path, value, context = value) {
  let parent, lastPart, lastPartDebug;
  if (!path)
    return {
      parent,
      parentPath: path,
      schema
    };
  propertyExpr.forEach(path, (_part, isBracket, isArray3) => {
    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
    schema = schema.resolve({
      context,
      parent,
      value
    });
    let isTuple = schema.type === "tuple";
    let idx = isArray3 ? parseInt(part, 10) : 0;
    if (schema.innerType || isTuple) {
      if (isTuple && !isArray3)
        throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema = isTuple ? schema.spec.types[idx] : schema.innerType;
    }
    if (!isArray3) {
      if (!schema.fields || !schema.fields[part])
        throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
      parent = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
}
class ReferenceSet extends Set {
  describe() {
    const description = [];
    for (const item of this.values()) {
      description.push(Reference.isRef(item) ? item.describe() : item);
    }
    return description;
  }
  resolveAll(resolve2) {
    let result = [];
    for (const item of this.values()) {
      result.push(resolve2(item));
    }
    return result;
  }
  clone() {
    return new ReferenceSet(this.values());
  }
  merge(newItems, removeItems) {
    const next2 = this.clone();
    newItems.forEach((value) => next2.add(value));
    removeItems.forEach((value) => next2.delete(value));
    return next2;
  }
}
function clone$3(src2, seen2 = /* @__PURE__ */ new Map()) {
  if (isSchema(src2) || !src2 || typeof src2 !== "object")
    return src2;
  if (seen2.has(src2))
    return seen2.get(src2);
  let copy2;
  if (src2 instanceof Date) {
    copy2 = new Date(src2.getTime());
    seen2.set(src2, copy2);
  } else if (src2 instanceof RegExp) {
    copy2 = new RegExp(src2);
    seen2.set(src2, copy2);
  } else if (Array.isArray(src2)) {
    copy2 = new Array(src2.length);
    seen2.set(src2, copy2);
    for (let i2 = 0; i2 < src2.length; i2++)
      copy2[i2] = clone$3(src2[i2], seen2);
  } else if (src2 instanceof Map) {
    copy2 = /* @__PURE__ */ new Map();
    seen2.set(src2, copy2);
    for (const [k2, v2] of src2.entries())
      copy2.set(k2, clone$3(v2, seen2));
  } else if (src2 instanceof Set) {
    copy2 = /* @__PURE__ */ new Set();
    seen2.set(src2, copy2);
    for (const v2 of src2)
      copy2.add(clone$3(v2, seen2));
  } else if (src2 instanceof Object) {
    copy2 = {};
    seen2.set(src2, copy2);
    for (const [k2, v2] of Object.entries(src2))
      copy2[k2] = clone$3(v2, seen2);
  } else {
    throw Error(`Unable to clone ${src2}`);
  }
  return copy2;
}
class Schema {
  constructor(options) {
    this.type = void 0;
    this.deps = [];
    this.tests = void 0;
    this.transforms = void 0;
    this.conditions = [];
    this._mutate = void 0;
    this.internalTests = {};
    this._whitelist = new ReferenceSet();
    this._blacklist = new ReferenceSet();
    this.exclusiveTests = /* @__PURE__ */ Object.create(null);
    this._typeCheck = void 0;
    this.spec = void 0;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = options.type;
    this._typeCheck = options.check;
    this.spec = Object.assign({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      disableStackTrace: false,
      nullable: false,
      optional: true,
      coerce: true
    }, options == null ? void 0 : options.spec);
    this.withMutation((s2) => {
      s2.nonNullable();
    });
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec)
        Object.assign(this.spec, spec);
      return this;
    }
    const next2 = Object.create(Object.getPrototypeOf(this));
    next2.type = this.type;
    next2._typeCheck = this._typeCheck;
    next2._whitelist = this._whitelist.clone();
    next2._blacklist = this._blacklist.clone();
    next2.internalTests = Object.assign({}, this.internalTests);
    next2.exclusiveTests = Object.assign({}, this.exclusiveTests);
    next2.deps = [...this.deps];
    next2.conditions = [...this.conditions];
    next2.tests = [...this.tests];
    next2.transforms = [...this.transforms];
    next2.spec = clone$3(Object.assign({}, this.spec, spec));
    return next2;
  }
  label(label) {
    let next2 = this.clone();
    next2.spec.label = label;
    return next2;
  }
  meta(...args) {
    if (args.length === 0)
      return this.spec.meta;
    let next2 = this.clone();
    next2.spec.meta = Object.assign(next2.spec.meta || {}, args[0]);
    return next2;
  }
  withMutation(fn3) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn3(this);
    this._mutate = before;
    return result;
  }
  concat(schema) {
    if (!schema || schema === this)
      return this;
    if (schema.type !== this.type && this.type !== "mixed")
      throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
    let base = this;
    let combined = schema.clone();
    const mergedSpec = Object.assign({}, base.spec, combined.spec);
    combined.spec = mergedSpec;
    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
    combined.tests = base.tests;
    combined.exclusiveTests = base.exclusiveTests;
    combined.withMutation((next2) => {
      schema.tests.forEach((fn3) => {
        next2.test(fn3.OPTIONS);
      });
    });
    combined.transforms = [...base.transforms, ...combined.transforms];
    return combined;
  }
  isType(v2) {
    if (v2 == null) {
      if (this.spec.nullable && v2 === null)
        return true;
      if (this.spec.optional && v2 === void 0)
        return true;
      return false;
    }
    return this._typeCheck(v2);
  }
  resolve(options) {
    let schema = this;
    if (schema.conditions.length) {
      let conditions = schema.conditions;
      schema = schema.clone();
      schema.conditions = [];
      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
      schema = schema.resolve(options);
    }
    return schema;
  }
  resolveOptions(options) {
    var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
    return Object.assign({}, options, {
      from: options.from || [],
      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
      disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
    });
  }
  /**
   * Run the configured transform pipeline over an input value.
   */
  cast(value, options = {}) {
    let resolvedSchema = this.resolve(Object.assign({
      value
    }, options));
    let allowOptionality = options.assert === "ignore-optionality";
    let result = resolvedSchema._cast(value, options);
    if (options.assert !== false && !resolvedSchema.isType(result)) {
      if (allowOptionality && isAbsent(result)) {
        return result;
      }
      let formattedValue = printValue(value);
      let formattedResult = printValue(result);
      throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
    }
    return result;
  }
  _cast(rawValue, options) {
    let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn3) => fn3.call(this, prevValue, rawValue, this), rawValue);
    if (value === void 0) {
      value = this.getDefault(options);
    }
    return value;
  }
  _validate(_value, options = {}, panic, next2) {
    let {
      path,
      originalValue = _value,
      strict = this.spec.strict
    } = options;
    let value = _value;
    if (!strict) {
      value = this._cast(value, Object.assign({
        assert: false
      }, options));
    }
    let initialTests = [];
    for (let test2 of Object.values(this.internalTests)) {
      if (test2)
        initialTests.push(test2);
    }
    this.runTests({
      path,
      value,
      originalValue,
      options,
      tests: initialTests
    }, panic, (initialErrors) => {
      if (initialErrors.length) {
        return next2(initialErrors, value);
      }
      this.runTests({
        path,
        value,
        originalValue,
        options,
        tests: this.tests
      }, panic, next2);
    });
  }
  /**
   * Executes a set of validations, either schema, produced Tests or a nested
   * schema validate result.
   */
  runTests(runOptions, panic, next2) {
    let fired = false;
    let {
      tests,
      value,
      originalValue,
      path,
      options
    } = runOptions;
    let panicOnce = (arg) => {
      if (fired)
        return;
      fired = true;
      panic(arg, value);
    };
    let nextOnce = (arg) => {
      if (fired)
        return;
      fired = true;
      next2(arg, value);
    };
    let count = tests.length;
    let nestedErrors = [];
    if (!count)
      return nextOnce([]);
    let args = {
      value,
      originalValue,
      path,
      options,
      schema: this
    };
    for (let i2 = 0; i2 < tests.length; i2++) {
      const test2 = tests[i2];
      test2(args, panicOnce, function finishTestRun(err) {
        if (err) {
          Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
        }
        if (--count <= 0) {
          nextOnce(nestedErrors);
        }
      });
    }
  }
  asNestedTest({
    key,
    index: index2,
    parent,
    parentPath,
    originalParent,
    options
  }) {
    const k2 = key != null ? key : index2;
    if (k2 == null) {
      throw TypeError("Must include `key` or `index` for nested validations");
    }
    const isIndex2 = typeof k2 === "number";
    let value = parent[k2];
    const testOptions = Object.assign({}, options, {
      // Nested validations fields are always strict:
      //    1. parent isn't strict so the casting will also have cast inner values
      //    2. parent is strict in which case the nested values weren't cast either
      strict: true,
      parent,
      value,
      originalValue: originalParent[k2],
      // FIXME: tests depend on `index` being passed around deeply,
      //   we should not let the options.key/index bleed through
      key: void 0,
      // index: undefined,
      [isIndex2 ? "index" : "key"]: k2,
      path: isIndex2 || k2.includes(".") ? `${parentPath || ""}[${value ? k2 : `"${k2}"`}]` : (parentPath ? `${parentPath}.` : "") + key
    });
    return (_2, panic, next2) => this.resolve(testOptions)._validate(value, testOptions, panic, next2);
  }
  validate(value, options) {
    var _options$disableStack2;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
    return new Promise((resolve2, reject) => schema._validate(value, options, (error, parsed) => {
      if (ValidationError.isError(error))
        error.value = parsed;
      reject(error);
    }, (errors, validated) => {
      if (errors.length)
        reject(new ValidationError(errors, validated, void 0, void 0, disableStackTrace));
      else
        resolve2(validated);
    }));
  }
  validateSync(value, options) {
    var _options$disableStack3;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let result;
    let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
    schema._validate(value, Object.assign({}, options, {
      sync: true
    }), (error, parsed) => {
      if (ValidationError.isError(error))
        error.value = parsed;
      throw error;
    }, (errors, validated) => {
      if (errors.length)
        throw new ValidationError(errors, value, void 0, void 0, disableStackTrace);
      result = validated;
    });
    return result;
  }
  isValid(value, options) {
    return this.validate(value, options).then(() => true, (err) => {
      if (ValidationError.isError(err))
        return false;
      throw err;
    });
  }
  isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err) {
      if (ValidationError.isError(err))
        return false;
      throw err;
    }
  }
  _getDefault(options) {
    let defaultValue = this.spec.default;
    if (defaultValue == null) {
      return defaultValue;
    }
    return typeof defaultValue === "function" ? defaultValue.call(this, options) : clone$3(defaultValue);
  }
  getDefault(options) {
    let schema = this.resolve(options || {});
    return schema._getDefault(options);
  }
  default(def) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next2 = this.clone({
      default: def
    });
    return next2;
  }
  strict(isStrict = true) {
    return this.clone({
      strict: isStrict
    });
  }
  nullability(nullable, message) {
    const next2 = this.clone({
      nullable
    });
    next2.internalTests.nullable = createValidation({
      message,
      name: "nullable",
      test(value) {
        return value === null ? this.schema.spec.nullable : true;
      }
    });
    return next2;
  }
  optionality(optional, message) {
    const next2 = this.clone({
      optional
    });
    next2.internalTests.optionality = createValidation({
      message,
      name: "optionality",
      test(value) {
        return value === void 0 ? this.schema.spec.optional : true;
      }
    });
    return next2;
  }
  optional() {
    return this.optionality(true);
  }
  defined(message = mixed.defined) {
    return this.optionality(false, message);
  }
  nullable() {
    return this.nullability(true);
  }
  nonNullable(message = mixed.notNull) {
    return this.nullability(false, message);
  }
  required(message = mixed.required) {
    return this.clone().withMutation((next2) => next2.nonNullable(message).defined(message));
  }
  notRequired() {
    return this.clone().withMutation((next2) => next2.nullable().optional());
  }
  transform(fn3) {
    let next2 = this.clone();
    next2.transforms.push(fn3);
    return next2;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === "function") {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === void 0)
      opts.message = mixed.default;
    if (typeof opts.test !== "function")
      throw new TypeError("`test` is a required parameters");
    let next2 = this.clone();
    let validate = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next2.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name)
        throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    }
    if (opts.name)
      next2.exclusiveTests[opts.name] = !!opts.exclusive;
    next2.tests = next2.tests.filter((fn3) => {
      if (fn3.OPTIONS.name === opts.name) {
        if (isExclusive)
          return false;
        if (fn3.OPTIONS.test === validate.OPTIONS.test)
          return false;
      }
      return true;
    });
    next2.tests.push(validate);
    return next2;
  }
  when(keys3, options) {
    if (!Array.isArray(keys3) && typeof keys3 !== "string") {
      options = keys3;
      keys3 = ".";
    }
    let next2 = this.clone();
    let deps = toArray$2(keys3).map((key) => new Reference(key));
    deps.forEach((dep) => {
      if (dep.isSibling)
        next2.deps.push(dep.key);
    });
    next2.conditions.push(typeof options === "function" ? new Condition(deps, options) : Condition.fromOptions(deps, options));
    return next2;
  }
  typeError(message) {
    let next2 = this.clone();
    next2.internalTests.typeError = createValidation({
      message,
      name: "typeError",
      skipAbsent: true,
      test(value) {
        if (!this.schema._typeCheck(value))
          return this.createError({
            params: {
              type: this.schema.type
            }
          });
        return true;
      }
    });
    return next2;
  }
  oneOf(enums, message = mixed.oneOf) {
    let next2 = this.clone();
    enums.forEach((val) => {
      next2._whitelist.add(val);
      next2._blacklist.delete(val);
    });
    next2.internalTests.whiteList = createValidation({
      message,
      name: "oneOf",
      skipAbsent: true,
      test(value) {
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value) ? true : this.createError({
          params: {
            values: Array.from(valids).join(", "),
            resolved
          }
        });
      }
    });
    return next2;
  }
  notOneOf(enums, message = mixed.notOneOf) {
    let next2 = this.clone();
    enums.forEach((val) => {
      next2._blacklist.add(val);
      next2._whitelist.delete(val);
    });
    next2.internalTests.blacklist = createValidation({
      message,
      name: "notOneOf",
      test(value) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value))
          return this.createError({
            params: {
              values: Array.from(invalids).join(", "),
              resolved
            }
          });
        return true;
      }
    });
    return next2;
  }
  strip(strip = true) {
    let next2 = this.clone();
    next2.spec.strip = strip;
    return next2;
  }
  /**
   * Return a serialized description of the schema including validations, flags, types etc.
   *
   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
   */
  describe(options) {
    const next2 = (options ? this.resolve(options) : this).clone();
    const {
      label,
      meta,
      optional,
      nullable
    } = next2.spec;
    const description = {
      meta,
      label,
      optional,
      nullable,
      default: next2.getDefault(options),
      type: next2.type,
      oneOf: next2._whitelist.describe(),
      notOneOf: next2._blacklist.describe(),
      tests: next2.tests.map((fn3) => ({
        name: fn3.OPTIONS.name,
        params: fn3.OPTIONS.params
      })).filter((n2, idx, list) => list.findIndex((c2) => c2.name === n2.name) === idx)
    };
    return description;
  }
}
Schema.prototype.__isYupSchema__ = true;
for (const method of ["validate", "validateSync"])
  Schema.prototype[`${method}At`] = function(path, value, options = {}) {
    const {
      parent,
      parentPath,
      schema
    } = getIn(this, path, value, options.context);
    return schema[method](parent && parent[parentPath], Object.assign({}, options, {
      parent,
      path
    }));
  };
for (const alias of ["equals", "is"])
  Schema.prototype[alias] = Schema.prototype.oneOf;
for (const alias of ["not", "nope"])
  Schema.prototype[alias] = Schema.prototype.notOneOf;
let rEmail = (
  // eslint-disable-next-line
  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
);
let rUrl = (
  // eslint-disable-next-line
  /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
);
let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
let isTrimmed = (value) => isAbsent(value) || value === value.trim();
let objStringTag = {}.toString();
function create$6() {
  return new StringSchema();
}
class StringSchema extends Schema {
  constructor() {
    super({
      type: "string",
      check(value) {
        if (value instanceof String)
          value = value.valueOf();
        return typeof value === "string";
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value))
          return value;
        if (Array.isArray(value))
          return value;
        const strValue = value != null && value.toString ? value.toString() : value;
        if (strValue === objStringTag)
          return value;
        return strValue;
      });
    });
  }
  required(message) {
    return super.required(message).withMutation((schema) => schema.test({
      message: message || mixed.required,
      name: "required",
      skipAbsent: true,
      test: (value) => !!value.length
    }));
  }
  notRequired() {
    return super.notRequired().withMutation((schema) => {
      schema.tests = schema.tests.filter((t3) => t3.OPTIONS.name !== "required");
      return schema;
    });
  }
  length(length2, message = string.length) {
    return this.test({
      message,
      name: "length",
      exclusive: true,
      params: {
        length: length2
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length2);
      }
    });
  }
  min(min2, message = string.min) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      skipAbsent: true,
      test(value) {
        return value.length >= this.resolve(min2);
      }
    });
  }
  max(max2, message = string.max) {
    return this.test({
      name: "max",
      exclusive: true,
      message,
      params: {
        max: max2
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max2);
      }
    });
  }
  matches(regex2, options) {
    let excludeEmptyString = false;
    let message;
    let name;
    if (options) {
      if (typeof options === "object") {
        ({
          excludeEmptyString = false,
          message,
          name
        } = options);
      } else {
        message = options;
      }
    }
    return this.test({
      name: name || "matches",
      message: message || string.matches,
      params: {
        regex: regex2
      },
      skipAbsent: true,
      test: (value) => value === "" && excludeEmptyString || value.search(regex2) !== -1
    });
  }
  email(message = string.email) {
    return this.matches(rEmail, {
      name: "email",
      message,
      excludeEmptyString: true
    });
  }
  url(message = string.url) {
    return this.matches(rUrl, {
      name: "url",
      message,
      excludeEmptyString: true
    });
  }
  uuid(message = string.uuid) {
    return this.matches(rUUID, {
      name: "uuid",
      message,
      excludeEmptyString: false
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((val) => val === null ? "" : val);
  }
  trim(message = string.trim) {
    return this.transform((val) => val != null ? val.trim() : val).test({
      message,
      name: "trim",
      test: isTrimmed
    });
  }
  lowercase(message = string.lowercase) {
    return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
      message,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value) => isAbsent(value) || value === value.toLowerCase()
    });
  }
  uppercase(message = string.uppercase) {
    return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
      message,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value) => isAbsent(value) || value === value.toUpperCase()
    });
  }
}
create$6.prototype = StringSchema.prototype;
const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
function toNumber(str, defaultValue = 0) {
  return Number(str) || defaultValue;
}
function parseIsoDate(date2) {
  const regexResult = isoReg.exec(date2);
  if (!regexResult)
    return Date.parse ? Date.parse(date2) : Number.NaN;
  const struct = {
    year: toNumber(regexResult[1]),
    month: toNumber(regexResult[2], 1) - 1,
    day: toNumber(regexResult[3], 1),
    hour: toNumber(regexResult[4]),
    minute: toNumber(regexResult[5]),
    second: toNumber(regexResult[6]),
    millisecond: regexResult[7] ? (
      // allow arbitrary sub-second precision beyond milliseconds
      toNumber(regexResult[7].substring(0, 3))
    ) : 0,
    z: regexResult[8] || void 0,
    plusMinus: regexResult[9] || void 0,
    hourOffset: toNumber(regexResult[10]),
    minuteOffset: toNumber(regexResult[11])
  };
  if (struct.z === void 0 && struct.plusMinus === void 0) {
    return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
  }
  let totalMinutesOffset = 0;
  if (struct.z !== "Z" && struct.plusMinus !== void 0) {
    totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
    if (struct.plusMinus === "+")
      totalMinutesOffset = 0 - totalMinutesOffset;
  }
  return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
}
let invalidDate = /* @__PURE__ */ new Date("");
let isDate$3 = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
class DateSchema extends Schema {
  constructor() {
    super({
      type: "date",
      check(v2) {
        return isDate$3(v2) && !isNaN(v2.getTime());
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value) || value === null)
          return value;
        value = parseIsoDate(value);
        return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
      });
    });
  }
  prepareParam(ref, name) {
    let param;
    if (!Reference.isRef(ref)) {
      let cast = this.cast(ref);
      if (!this._typeCheck(cast))
        throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
      param = cast;
    } else {
      param = ref;
    }
    return param;
  }
  min(min2, message = date.min) {
    let limit = this.prepareParam(min2, "min");
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min: min2
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(limit);
      }
    });
  }
  max(max2, message = date.max) {
    let limit = this.prepareParam(max2, "max");
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max: max2
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(limit);
      }
    });
  }
}
DateSchema.INVALID_DATE = invalidDate;
DateSchema.prototype;
function sortFields(fields, excludedEdges = []) {
  let edges = [];
  let nodes = /* @__PURE__ */ new Set();
  let excludes = new Set(excludedEdges.map(([a2, b2]) => `${a2}-${b2}`));
  function addNode(depPath, key) {
    let node2 = propertyExpr.split(depPath)[0];
    nodes.add(node2);
    if (!excludes.has(`${key}-${node2}`))
      edges.push([key, node2]);
  }
  for (const key of Object.keys(fields)) {
    let value = fields[key];
    nodes.add(key);
    if (Reference.isRef(value) && value.isSibling)
      addNode(value.path, key);
    else if (isSchema(value) && "deps" in value)
      value.deps.forEach((path) => addNode(path, key));
  }
  return toposort$1.array(Array.from(nodes), edges).reverse();
}
function findIndex(arr, err) {
  let idx = Infinity;
  arr.some((key, ii2) => {
    var _err$path;
    if ((_err$path = err.path) != null && _err$path.includes(key)) {
      idx = ii2;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys3) {
  return (a2, b2) => {
    return findIndex(keys3, a2) - findIndex(keys3, b2);
  };
}
const parseJson = (value, _2, ctx) => {
  if (typeof value !== "string") {
    return value;
  }
  let parsed = value;
  try {
    parsed = JSON.parse(value);
  } catch (err) {
  }
  return ctx.isType(parsed) ? parsed : value;
};
function deepPartial(schema) {
  if ("fields" in schema) {
    const partial = {};
    for (const [key, fieldSchema] of Object.entries(schema.fields)) {
      partial[key] = deepPartial(fieldSchema);
    }
    return schema.setFields(partial);
  }
  if (schema.type === "array") {
    const nextArray = schema.optional();
    if (nextArray.innerType)
      nextArray.innerType = deepPartial(nextArray.innerType);
    return nextArray;
  }
  if (schema.type === "tuple") {
    return schema.optional().clone({
      types: schema.spec.types.map(deepPartial)
    });
  }
  if ("optional" in schema) {
    return schema.optional();
  }
  return schema;
}
const deepHas = (obj, p2) => {
  const path = [...propertyExpr.normalizePath(p2)];
  if (path.length === 1)
    return path[0] in obj;
  let last2 = path.pop();
  let parent = propertyExpr.getter(propertyExpr.join(path), true)(obj);
  return !!(parent && last2 in parent);
};
let isObject$7 = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter((key) => known.indexOf(key) === -1);
}
const defaultSort = sortByKeyOrder([]);
function create$3$1(spec) {
  return new ObjectSchema(spec);
}
class ObjectSchema extends Schema {
  constructor(spec) {
    super({
      type: "object",
      check(value) {
        return isObject$7(value) || typeof value === "function";
      }
    });
    this.fields = /* @__PURE__ */ Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _cast(_value, options = {}) {
    var _options$stripUnknown;
    let value = super._cast(_value, options);
    if (value === void 0)
      return this.getDefault(options);
    if (!this._typeCheck(value))
      return value;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = [].concat(this._nodes, Object.keys(value).filter((v2) => !this._nodes.includes(v2)));
    let intermediateValue = {};
    let innerOptions = Object.assign({}, options, {
      parent: intermediateValue,
      __validating: options.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = prop in value;
      if (field) {
        let fieldValue;
        let inputValue = value[prop];
        innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
        field = field.resolve({
          value: inputValue,
          context: options.context,
          parent: intermediateValue
        });
        let fieldSpec = field instanceof Schema ? field.spec : void 0;
        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
        if (fieldSpec != null && fieldSpec.strip) {
          isChanged = isChanged || prop in value;
          continue;
        }
        fieldValue = !options.__validating || !strict ? (
          // TODO: use _cast, this is double resolving
          field.cast(value[prop], innerOptions)
        ) : value[prop];
        if (fieldValue !== void 0) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value[prop];
      }
      if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value;
  }
  _validate(_value, options = {}, panic, next2) {
    let {
      from: from2 = [],
      originalValue = _value,
      recursive = this.spec.recursive
    } = options;
    options.from = [{
      schema: this,
      value: originalValue
    }, ...from2];
    options.__validating = true;
    options.originalValue = originalValue;
    super._validate(_value, options, panic, (objectErrors, value) => {
      if (!recursive || !isObject$7(value)) {
        next2(objectErrors, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = [];
      for (let key of this._nodes) {
        let field = this.fields[key];
        if (!field || Reference.isRef(field)) {
          continue;
        }
        tests.push(field.asNestedTest({
          options,
          key,
          parent: value,
          parentPath: options.path,
          originalParent: originalValue
        }));
      }
      this.runTests({
        tests,
        value,
        originalValue,
        options
      }, panic, (fieldErrors) => {
        next2(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
      });
    });
  }
  clone(spec) {
    const next2 = super.clone(spec);
    next2.fields = Object.assign({}, this.fields);
    next2._nodes = this._nodes;
    next2._excludedEdges = this._excludedEdges;
    next2._sortErrors = this._sortErrors;
    return next2;
  }
  concat(schema) {
    let next2 = super.concat(schema);
    let nextFields = next2.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      nextFields[field] = target === void 0 ? schemaOrRef : target;
    }
    return next2.withMutation((s2) => (
      // XXX: excludes here is wrong
      s2.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges])
    ));
  }
  _getDefault(options) {
    if ("default" in this.spec) {
      return super._getDefault(options);
    }
    if (!this._nodes.length) {
      return void 0;
    }
    let dft = {};
    this._nodes.forEach((key) => {
      var _innerOptions;
      const field = this.fields[key];
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
    });
    return dft;
  }
  setFields(shape2, excludedEdges) {
    let next2 = this.clone();
    next2.fields = shape2;
    next2._nodes = sortFields(shape2, excludedEdges);
    next2._sortErrors = sortByKeyOrder(Object.keys(shape2));
    if (excludedEdges)
      next2._excludedEdges = excludedEdges;
    return next2;
  }
  shape(additions, excludes = []) {
    return this.clone().withMutation((next2) => {
      let edges = next2._excludedEdges;
      if (excludes.length) {
        if (!Array.isArray(excludes[0]))
          excludes = [excludes];
        edges = [...next2._excludedEdges, ...excludes];
      }
      return next2.setFields(Object.assign(next2.fields, additions), edges);
    });
  }
  partial() {
    const partial = {};
    for (const [key, schema] of Object.entries(this.fields)) {
      partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
    }
    return this.setFields(partial);
  }
  deepPartial() {
    const next2 = deepPartial(this);
    return next2;
  }
  pick(keys3) {
    const picked = {};
    for (const key of keys3) {
      if (this.fields[key])
        picked[key] = this.fields[key];
    }
    return this.setFields(picked);
  }
  omit(keys3) {
    const fields = Object.assign({}, this.fields);
    for (const key of keys3) {
      delete fields[key];
    }
    return this.setFields(fields);
  }
  from(from2, to, alias) {
    let fromGetter = propertyExpr.getter(from2, true);
    return this.transform((obj) => {
      if (!obj)
        return obj;
      let newObj = obj;
      if (deepHas(obj, from2)) {
        newObj = Object.assign({}, obj);
        if (!alias)
          delete newObj[from2];
        newObj[to] = fromGetter(obj);
      }
      return newObj;
    });
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }
  noUnknown(noAllow = true, message = object.noUnknown) {
    if (typeof noAllow !== "boolean") {
      message = noAllow;
      noAllow = true;
    }
    let next2 = this.test({
      name: "noUnknown",
      exclusive: true,
      message,
      test(value) {
        if (value == null)
          return true;
        const unknownKeys = unknown(this.schema, value);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(", ")
          }
        });
      }
    });
    next2.spec.noUnknown = noAllow;
    return next2;
  }
  unknown(allow = true, message = object.noUnknown) {
    return this.noUnknown(!allow, message);
  }
  transformKeys(fn3) {
    return this.transform((obj) => {
      if (!obj)
        return obj;
      const result = {};
      for (const key of Object.keys(obj))
        result[fn3(key)] = obj[key];
      return result;
    });
  }
  camelCase() {
    return this.transformKeys(tinyCase.camelCase);
  }
  snakeCase() {
    return this.transformKeys(tinyCase.snakeCase);
  }
  constantCase() {
    return this.transformKeys((key) => tinyCase.snakeCase(key).toUpperCase());
  }
  describe(options) {
    let base = super.describe(options);
    base.fields = {};
    for (const [key, value] of Object.entries(this.fields)) {
      var _innerOptions2;
      let innerOptions = options;
      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      base.fields[key] = value.describe(innerOptions);
    }
    return base;
  }
}
create$3$1.prototype = ObjectSchema.prototype;
var Close = {};
var interopRequireDefault = { exports: {} };
(function(module2) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module2.exports = _interopRequireDefault2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
var createSvgIcon = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(utils$1);
var hasRequiredCreateSvgIcon;
function requireCreateSvgIcon() {
  if (hasRequiredCreateSvgIcon)
    return createSvgIcon;
  hasRequiredCreateSvgIcon = 1;
  (function(exports2) {
    "use client";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "default", {
      enumerable: true,
      get: function() {
        return _utils.createSvgIcon;
      }
    });
    var _utils = require$$0;
  })(createSvgIcon);
  return createSvgIcon;
}
var _interopRequireDefault$e = interopRequireDefaultExports;
Object.defineProperty(Close, "__esModule", {
  value: true
});
var default_1$e = Close.default = void 0;
var _createSvgIcon$e = _interopRequireDefault$e(requireCreateSvgIcon());
var _jsxRuntime$e = jsxRuntimeExports;
var _default$e = (0, _createSvgIcon$e.default)(/* @__PURE__ */ (0, _jsxRuntime$e.jsx)("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
default_1$e = Close.default = _default$e;
const Transition = reactExports.forwardRef(function Transition2(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Slide$1, { direction: "up", ref, ...props });
});
function CustomDialog({
  open: open2,
  setOpen,
  content: content2,
  showClose = true
}) {
  const handleClose = () => {
    setOpen(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MuiDialog,
    {
      open: open2,
      maxWidth: "sm",
      TransitionComponent: Transition,
      keepMounted: true,
      onClose: handleClose,
      "aria-describedby": "alert-dialog-slide-description",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          p: 1,
          display: "flex",
          flexDirection: "column",
          justifyContent: "start",
          alignItems: "center",
          children: [
            showClose && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Box$1,
              {
                display: "flex",
                flexDirection: "row",
                justifyContent: "end",
                width: "100%",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setOpen(false), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$e, {}) })
              }
            ),
            content2
          ]
        }
      )
    }
  ) });
}
function __rest(s2, e2) {
  var t3 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0) {
      t3[p2] = s2[p2];
    }
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2])) {
        t3[p2[i2]] = s2[p2[i2]];
      }
    }
  }
  return t3;
}
var SourceType;
(function(SourceType2) {
  SourceType2["event"] = "event";
  SourceType2["props"] = "prop";
})(SourceType || (SourceType = {}));
function noop$5() {
}
function memoizeOnce(cb2) {
  var lastArgs;
  var lastValue = void 0;
  return function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (lastArgs && args.length === lastArgs.length && args.every(function(value, index2) {
      return value === lastArgs[index2];
    })) {
      return lastValue;
    }
    lastArgs = args;
    lastValue = cb2.apply(void 0, args);
    return lastValue;
  };
}
function charIsNumber(char2) {
  return !!(char2 || "").match(/\d/);
}
function isNil$1(val) {
  return val === null || val === void 0;
}
function isNanValue(val) {
  return typeof val === "number" && isNaN(val);
}
function isNotValidValue(val) {
  return isNil$1(val) || isNanValue(val) || typeof val === "number" && !isFinite(val);
}
function escapeRegExp$1(str) {
  return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
function getThousandsGroupRegex(thousandsGroupStyle) {
  switch (thousandsGroupStyle) {
    case "lakh":
      return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
    case "wan":
      return /(\d)(?=(\d{4})+(?!\d))/g;
    case "thousand":
    default:
      return /(\d)(?=(\d{3})+(?!\d))/g;
  }
}
function applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {
  var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
  var index2 = str.search(/[1-9]/);
  index2 = index2 === -1 ? str.length : index2;
  return str.substring(0, index2) + str.substring(index2, str.length).replace(thousandsGroupRegex, "$1" + thousandSeparator);
}
function usePersistentCallback(cb2) {
  var callbackRef = reactExports.useRef(cb2);
  callbackRef.current = cb2;
  var persistentCbRef = reactExports.useRef(function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return callbackRef.current.apply(callbackRef, args);
  });
  return persistentCbRef.current;
}
function splitDecimal(numStr, allowNegative) {
  if (allowNegative === void 0)
    allowNegative = true;
  var hasNegation = numStr[0] === "-";
  var addNegation = hasNegation && allowNegative;
  numStr = numStr.replace("-", "");
  var parts = numStr.split(".");
  var beforeDecimal = parts[0];
  var afterDecimal = parts[1] || "";
  return {
    beforeDecimal,
    afterDecimal,
    hasNegation,
    addNegation
  };
}
function fixLeadingZero(numStr) {
  if (!numStr) {
    return numStr;
  }
  var isNegative = numStr[0] === "-";
  if (isNegative) {
    numStr = numStr.substring(1, numStr.length);
  }
  var parts = numStr.split(".");
  var beforeDecimal = parts[0].replace(/^0+/, "") || "0";
  var afterDecimal = parts[1] || "";
  return (isNegative ? "-" : "") + beforeDecimal + (afterDecimal ? "." + afterDecimal : "");
}
function limitToScale(numStr, scale, fixedDecimalScale) {
  var str = "";
  var filler = fixedDecimalScale ? "0" : "";
  for (var i2 = 0; i2 <= scale - 1; i2++) {
    str += numStr[i2] || filler;
  }
  return str;
}
function repeat(str, count) {
  return Array(count + 1).join(str);
}
function toNumericString(num) {
  var _num = num + "";
  var sign = _num[0] === "-" ? "-" : "";
  if (sign) {
    _num = _num.substring(1);
  }
  var ref = _num.split(/[eE]/g);
  var coefficient = ref[0];
  var exponent = ref[1];
  exponent = Number(exponent);
  if (!exponent) {
    return sign + coefficient;
  }
  coefficient = coefficient.replace(".", "");
  var decimalIndex = 1 + exponent;
  var coffiecientLn = coefficient.length;
  if (decimalIndex < 0) {
    coefficient = "0." + repeat("0", Math.abs(decimalIndex)) + coefficient;
  } else if (decimalIndex >= coffiecientLn) {
    coefficient = coefficient + repeat("0", decimalIndex - coffiecientLn);
  } else {
    coefficient = (coefficient.substring(0, decimalIndex) || "0") + "." + coefficient.substring(decimalIndex);
  }
  return sign + coefficient;
}
function roundToPrecision(numStr, scale, fixedDecimalScale) {
  if (["", "-"].indexOf(numStr) !== -1) {
    return numStr;
  }
  var shouldHaveDecimalSeparator = (numStr.indexOf(".") !== -1 || fixedDecimalScale) && scale;
  var ref = splitDecimal(numStr);
  var beforeDecimal = ref.beforeDecimal;
  var afterDecimal = ref.afterDecimal;
  var hasNegation = ref.hasNegation;
  var floatValue = parseFloat("0." + (afterDecimal || "0"));
  var floatValueStr = afterDecimal.length <= scale ? "0." + afterDecimal : floatValue.toFixed(scale);
  var roundedDecimalParts = floatValueStr.split(".");
  var intPart = beforeDecimal.split("").reverse().reduce(function(roundedStr, current, idx) {
    if (roundedStr.length > idx) {
      return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);
    }
    return current + roundedStr;
  }, roundedDecimalParts[0]);
  var decimalPart = limitToScale(roundedDecimalParts[1] || "", scale, fixedDecimalScale);
  var negation = hasNegation ? "-" : "";
  var decimalSeparator = shouldHaveDecimalSeparator ? "." : "";
  return "" + negation + intPart + decimalSeparator + decimalPart;
}
function setCaretPosition(el2, caretPos) {
  el2.value = el2.value;
  if (el2 !== null) {
    if (el2.createTextRange) {
      var range = el2.createTextRange();
      range.move("character", caretPos);
      range.select();
      return true;
    }
    if (el2.selectionStart || el2.selectionStart === 0) {
      el2.focus();
      el2.setSelectionRange(caretPos, caretPos);
      return true;
    }
    el2.focus();
    return false;
  }
}
var findChangeRange = memoizeOnce(function(prevValue, newValue) {
  var i2 = 0, j2 = 0;
  var prevLength = prevValue.length;
  var newLength = newValue.length;
  while (prevValue[i2] === newValue[i2] && i2 < prevLength) {
    i2++;
  }
  while (prevValue[prevLength - 1 - j2] === newValue[newLength - 1 - j2] && newLength - j2 > i2 && prevLength - j2 > i2) {
    j2++;
  }
  return {
    from: { start: i2, end: prevLength - j2 },
    to: { start: i2, end: newLength - j2 }
  };
});
function clamp$1(num, min2, max2) {
  return Math.min(Math.max(num, min2), max2);
}
function geInputCaretPosition(el2) {
  return Math.max(el2.selectionStart, el2.selectionEnd);
}
function addInputMode() {
  return typeof navigator !== "undefined" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}
function getDefaultChangeMeta(value) {
  return {
    from: {
      start: 0,
      end: 0
    },
    to: {
      start: 0,
      end: value.length
    },
    lastValue: ""
  };
}
function defaultIsCharacterSame(ref) {
  var currentValue = ref.currentValue;
  var formattedValue = ref.formattedValue;
  var currentValueIndex = ref.currentValueIndex;
  var formattedValueIndex = ref.formattedValueIndex;
  return currentValue[currentValueIndex] === formattedValue[formattedValueIndex];
}
function getCaretPosition(newFormattedValue, lastFormattedValue, curValue, curCaretPos, boundary, isValidInputCharacter, isCharacterSame) {
  if (isCharacterSame === void 0)
    isCharacterSame = defaultIsCharacterSame;
  var firstAllowedPosition = boundary.findIndex(function(b2) {
    return b2;
  });
  var prefixFormat = newFormattedValue.slice(0, firstAllowedPosition);
  if (!lastFormattedValue && !curValue.startsWith(prefixFormat)) {
    lastFormattedValue = prefixFormat;
    curValue = prefixFormat + curValue;
    curCaretPos = curCaretPos + prefixFormat.length;
  }
  var curValLn = curValue.length;
  var formattedValueLn = newFormattedValue.length;
  var addedIndexMap = {};
  var indexMap = new Array(curValLn);
  for (var i2 = 0; i2 < curValLn; i2++) {
    indexMap[i2] = -1;
    for (var j2 = 0, jLn = formattedValueLn; j2 < jLn; j2++) {
      var isCharSame = isCharacterSame({
        currentValue: curValue,
        lastValue: lastFormattedValue,
        formattedValue: newFormattedValue,
        currentValueIndex: i2,
        formattedValueIndex: j2
      });
      if (isCharSame && addedIndexMap[j2] !== true) {
        indexMap[i2] = j2;
        addedIndexMap[j2] = true;
        break;
      }
    }
  }
  var pos = curCaretPos;
  while (pos < curValLn && (indexMap[pos] === -1 || !isValidInputCharacter(curValue[pos]))) {
    pos++;
  }
  var endIndex = pos === curValLn || indexMap[pos] === -1 ? formattedValueLn : indexMap[pos];
  pos = curCaretPos - 1;
  while (pos > 0 && indexMap[pos] === -1) {
    pos--;
  }
  var startIndex = pos === -1 || indexMap[pos] === -1 ? 0 : indexMap[pos] + 1;
  if (startIndex > endIndex) {
    return endIndex;
  }
  return curCaretPos - startIndex < endIndex - curCaretPos ? startIndex : endIndex;
}
function getCaretPosInBoundary(value, caretPos, boundary, direction2) {
  var valLn = value.length;
  caretPos = clamp$1(caretPos, 0, valLn);
  if (direction2 === "left") {
    while (caretPos >= 0 && !boundary[caretPos]) {
      caretPos--;
    }
    if (caretPos === -1) {
      caretPos = boundary.indexOf(true);
    }
  } else {
    while (caretPos <= valLn && !boundary[caretPos]) {
      caretPos++;
    }
    if (caretPos > valLn) {
      caretPos = boundary.lastIndexOf(true);
    }
  }
  if (caretPos === -1) {
    caretPos = valLn;
  }
  return caretPos;
}
function caretUnknownFormatBoundary(formattedValue) {
  var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
    return true;
  });
  for (var i2 = 0, ln2 = boundaryAry.length; i2 < ln2; i2++) {
    boundaryAry[i2] = Boolean(charIsNumber(formattedValue[i2]) || charIsNumber(formattedValue[i2 - 1]));
  }
  return boundaryAry;
}
function useInternalValues(value, defaultValue, valueIsNumericString, format2, removeFormatting2, onValueChange) {
  if (onValueChange === void 0)
    onValueChange = noop$5;
  var getValues = usePersistentCallback(function(value2, valueIsNumericString2) {
    var formattedValue, numAsString;
    if (isNotValidValue(value2)) {
      numAsString = "";
      formattedValue = "";
    } else if (typeof value2 === "number" || valueIsNumericString2) {
      numAsString = typeof value2 === "number" ? toNumericString(value2) : value2;
      formattedValue = format2(numAsString);
    } else {
      numAsString = removeFormatting2(value2, void 0);
      formattedValue = format2(numAsString);
    }
    return { formattedValue, numAsString };
  });
  var ref = reactExports.useState(function() {
    return getValues(isNil$1(value) ? defaultValue : value, valueIsNumericString);
  });
  var values2 = ref[0];
  var setValues = ref[1];
  var _onValueChange = function(newValues2, sourceInfo) {
    if (newValues2.formattedValue !== values2.formattedValue) {
      setValues({
        formattedValue: newValues2.formattedValue,
        numAsString: newValues2.value
      });
    }
    onValueChange(newValues2, sourceInfo);
  };
  var _value = value;
  var _valueIsNumericString = valueIsNumericString;
  if (isNil$1(value)) {
    _value = values2.numAsString;
    _valueIsNumericString = true;
  }
  var newValues = getValues(_value, _valueIsNumericString);
  reactExports.useMemo(function() {
    setValues(newValues);
  }, [newValues.formattedValue]);
  return [values2, _onValueChange];
}
function defaultRemoveFormatting(value) {
  return value.replace(/[^0-9]/g, "");
}
function defaultFormat(value) {
  return value;
}
function NumberFormatBase(props) {
  var type2 = props.type;
  if (type2 === void 0)
    type2 = "text";
  var displayType = props.displayType;
  if (displayType === void 0)
    displayType = "input";
  var customInput = props.customInput;
  var renderText = props.renderText;
  var getInputRef = props.getInputRef;
  var format2 = props.format;
  if (format2 === void 0)
    format2 = defaultFormat;
  var removeFormatting2 = props.removeFormatting;
  if (removeFormatting2 === void 0)
    removeFormatting2 = defaultRemoveFormatting;
  var defaultValue = props.defaultValue;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var isAllowed = props.isAllowed;
  var onChange = props.onChange;
  if (onChange === void 0)
    onChange = noop$5;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === void 0)
    onKeyDown = noop$5;
  var onMouseUp = props.onMouseUp;
  if (onMouseUp === void 0)
    onMouseUp = noop$5;
  var onFocus = props.onFocus;
  if (onFocus === void 0)
    onFocus = noop$5;
  var onBlur = props.onBlur;
  if (onBlur === void 0)
    onBlur = noop$5;
  var propValue = props.value;
  var getCaretBoundary2 = props.getCaretBoundary;
  if (getCaretBoundary2 === void 0)
    getCaretBoundary2 = caretUnknownFormatBoundary;
  var isValidInputCharacter = props.isValidInputCharacter;
  if (isValidInputCharacter === void 0)
    isValidInputCharacter = charIsNumber;
  var isCharacterSame = props.isCharacterSame;
  var otherProps = __rest(props, ["type", "displayType", "customInput", "renderText", "getInputRef", "format", "removeFormatting", "defaultValue", "valueIsNumericString", "onValueChange", "isAllowed", "onChange", "onKeyDown", "onMouseUp", "onFocus", "onBlur", "value", "getCaretBoundary", "isValidInputCharacter", "isCharacterSame"]);
  var ref = useInternalValues(propValue, defaultValue, Boolean(valueIsNumericString), format2, removeFormatting2, onValueChange);
  var ref_0 = ref[0];
  var formattedValue = ref_0.formattedValue;
  var numAsString = ref_0.numAsString;
  var onFormattedValueChange = ref[1];
  var lastUpdatedValue = reactExports.useRef({ formattedValue, numAsString });
  var _onValueChange = function(values2, source) {
    lastUpdatedValue.current = { formattedValue: values2.formattedValue, numAsString: values2.value };
    onFormattedValueChange(values2, source);
  };
  var ref$1 = reactExports.useState(false);
  var mounted = ref$1[0];
  var setMounted = ref$1[1];
  var focusedElm = reactExports.useRef(null);
  var timeout = reactExports.useRef({
    setCaretTimeout: null,
    focusTimeout: null
  });
  reactExports.useEffect(function() {
    setMounted(true);
    return function() {
      clearTimeout(timeout.current.setCaretTimeout);
      clearTimeout(timeout.current.focusTimeout);
    };
  }, []);
  var _format = format2;
  var getValueObject = function(formattedValue2, numAsString2) {
    var floatValue = parseFloat(numAsString2);
    return {
      formattedValue: formattedValue2,
      value: numAsString2,
      floatValue: isNaN(floatValue) ? void 0 : floatValue
    };
  };
  var setPatchedCaretPosition = function(el2, caretPos, currentValue) {
    if (el2.selectionStart === 0 && el2.selectionEnd === el2.value.length) {
      return;
    }
    setCaretPosition(el2, caretPos);
    timeout.current.setCaretTimeout = setTimeout(function() {
      if (el2.value === currentValue && el2.selectionStart !== el2.selectionEnd) {
        setCaretPosition(el2, caretPos);
      }
    }, 0);
  };
  var correctCaretPosition = function(value, caretPos, direction2) {
    return getCaretPosInBoundary(value, caretPos, getCaretBoundary2(value), direction2);
  };
  var getNewCaretPosition = function(inputValue, newFormattedValue, caretPos) {
    var caretBoundary = getCaretBoundary2(newFormattedValue);
    var updatedCaretPos = getCaretPosition(newFormattedValue, formattedValue, inputValue, caretPos, caretBoundary, isValidInputCharacter, isCharacterSame);
    updatedCaretPos = getCaretPosInBoundary(newFormattedValue, updatedCaretPos, caretBoundary);
    return updatedCaretPos;
  };
  var updateValueAndCaretPosition = function(params) {
    var newFormattedValue = params.formattedValue;
    if (newFormattedValue === void 0)
      newFormattedValue = "";
    var input = params.input;
    var setCaretPosition2 = params.setCaretPosition;
    if (setCaretPosition2 === void 0)
      setCaretPosition2 = true;
    var source = params.source;
    var event = params.event;
    var numAsString2 = params.numAsString;
    var caretPos = params.caretPos;
    if (input) {
      if (caretPos === void 0 && setCaretPosition2) {
        var inputValue = params.inputValue || input.value;
        var currentCaretPosition2 = geInputCaretPosition(input);
        input.value = newFormattedValue;
        caretPos = getNewCaretPosition(inputValue, newFormattedValue, currentCaretPosition2);
      }
      input.value = newFormattedValue;
      if (setCaretPosition2 && caretPos !== void 0) {
        setPatchedCaretPosition(input, caretPos, newFormattedValue);
      }
    }
    if (newFormattedValue !== formattedValue) {
      _onValueChange(getValueObject(newFormattedValue, numAsString2), { event, source });
    }
  };
  reactExports.useEffect(function() {
    var ref2 = lastUpdatedValue.current;
    var lastFormattedValue = ref2.formattedValue;
    var lastNumAsString = ref2.numAsString;
    if (formattedValue !== lastFormattedValue && (formattedValue !== numAsString || lastFormattedValue !== lastNumAsString)) {
      _onValueChange(getValueObject(formattedValue, numAsString), {
        event: void 0,
        source: SourceType.props
      });
    }
  }, [formattedValue, numAsString]);
  var currentCaretPosition = focusedElm.current ? geInputCaretPosition(focusedElm.current) : void 0;
  var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  useIsomorphicLayoutEffect2(function() {
    var input = focusedElm.current;
    if (formattedValue !== lastUpdatedValue.current.formattedValue && input) {
      var caretPos = getNewCaretPosition(lastUpdatedValue.current.formattedValue, formattedValue, currentCaretPosition);
      input.value = formattedValue;
      setPatchedCaretPosition(input, caretPos, formattedValue);
    }
  }, [formattedValue]);
  var formatInputValue = function(inputValue, event, source) {
    var changeRange = findChangeRange(formattedValue, inputValue);
    var changeMeta = Object.assign(Object.assign({}, changeRange), { lastValue: formattedValue });
    var _numAsString = removeFormatting2(inputValue, changeMeta);
    var _formattedValue = _format(_numAsString);
    _numAsString = removeFormatting2(_formattedValue, void 0);
    if (isAllowed && !isAllowed(getValueObject(_formattedValue, _numAsString))) {
      var input = event.target;
      var currentCaretPosition2 = geInputCaretPosition(input);
      var caretPos = getNewCaretPosition(inputValue, formattedValue, currentCaretPosition2);
      input.value = formattedValue;
      setPatchedCaretPosition(input, caretPos, formattedValue);
      return false;
    }
    updateValueAndCaretPosition({
      formattedValue: _formattedValue,
      numAsString: _numAsString,
      inputValue,
      event,
      source,
      setCaretPosition: true,
      input: event.target
    });
    return true;
  };
  var _onChange = function(e2) {
    var el2 = e2.target;
    var inputValue = el2.value;
    var changed = formatInputValue(inputValue, e2, SourceType.event);
    if (changed) {
      onChange(e2);
    }
  };
  var _onKeyDown = function(e2) {
    var el2 = e2.target;
    var key = e2.key;
    var selectionStart = el2.selectionStart;
    var selectionEnd = el2.selectionEnd;
    var value = el2.value;
    if (value === void 0)
      value = "";
    var expectedCaretPosition;
    if (key === "ArrowLeft" || key === "Backspace") {
      expectedCaretPosition = Math.max(selectionStart - 1, 0);
    } else if (key === "ArrowRight") {
      expectedCaretPosition = Math.min(selectionStart + 1, value.length);
    } else if (key === "Delete") {
      expectedCaretPosition = selectionStart;
    }
    if (expectedCaretPosition === void 0 || selectionStart !== selectionEnd) {
      onKeyDown(e2);
      return;
    }
    var newCaretPosition = expectedCaretPosition;
    if (key === "ArrowLeft" || key === "ArrowRight") {
      var direction2 = key === "ArrowLeft" ? "left" : "right";
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, direction2);
      if (newCaretPosition !== expectedCaretPosition) {
        e2.preventDefault();
      }
    } else if (key === "Delete" && !isValidInputCharacter(value[expectedCaretPosition])) {
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "right");
    } else if (key === "Backspace" && !isValidInputCharacter(value[expectedCaretPosition])) {
      newCaretPosition = correctCaretPosition(value, expectedCaretPosition, "left");
    }
    if (newCaretPosition !== expectedCaretPosition) {
      setPatchedCaretPosition(el2, newCaretPosition, value);
    }
    if (e2.isUnitTestRun) {
      setPatchedCaretPosition(el2, newCaretPosition, value);
    }
    onKeyDown(e2);
  };
  var _onMouseUp = function(e2) {
    var el2 = e2.target;
    var selectionStart = el2.selectionStart;
    var selectionEnd = el2.selectionEnd;
    var value = el2.value;
    if (value === void 0)
      value = "";
    if (selectionStart === selectionEnd) {
      var caretPosition = correctCaretPosition(value, selectionStart);
      if (caretPosition !== selectionStart) {
        setPatchedCaretPosition(el2, caretPosition, value);
      }
    }
    onMouseUp(e2);
  };
  var _onFocus = function(e2) {
    if (e2.persist) {
      e2.persist();
    }
    var el2 = e2.target;
    focusedElm.current = el2;
    timeout.current.focusTimeout = setTimeout(function() {
      var selectionStart = el2.selectionStart;
      var selectionEnd = el2.selectionEnd;
      var value = el2.value;
      if (value === void 0)
        value = "";
      var caretPosition = correctCaretPosition(value, selectionStart);
      if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) {
        setPatchedCaretPosition(el2, caretPosition, value);
      }
      onFocus(e2);
    }, 0);
  };
  var _onBlur = function(e2) {
    focusedElm.current = null;
    clearTimeout(timeout.current.focusTimeout);
    clearTimeout(timeout.current.setCaretTimeout);
    onBlur(e2);
  };
  var inputMode = mounted && addInputMode() ? "numeric" : void 0;
  var inputProps = Object.assign({ inputMode }, otherProps, {
    type: type2,
    value: formattedValue,
    onChange: _onChange,
    onKeyDown: _onKeyDown,
    onMouseUp: _onMouseUp,
    onFocus: _onFocus,
    onBlur: _onBlur
  });
  if (displayType === "text") {
    return renderText ? React.createElement(React.Fragment, null, renderText(formattedValue, otherProps) || null) : React.createElement("span", Object.assign({}, otherProps, { ref: getInputRef }), formattedValue);
  } else if (customInput) {
    var CustomInput = customInput;
    return React.createElement(CustomInput, Object.assign({}, inputProps, { ref: getInputRef }));
  }
  return React.createElement("input", Object.assign({}, inputProps, { ref: getInputRef }));
}
function format(numStr, props) {
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var suffix = props.suffix;
  if (suffix === void 0)
    suffix = "";
  var allowNegative = props.allowNegative;
  var thousandsGroupStyle = props.thousandsGroupStyle;
  if (thousandsGroupStyle === void 0)
    thousandsGroupStyle = "thousand";
  if (numStr === "" || numStr === "-") {
    return numStr;
  }
  var ref = getSeparators(props);
  var thousandSeparator = ref.thousandSeparator;
  var decimalSeparator = ref.decimalSeparator;
  var hasDecimalSeparator = decimalScale !== 0 && numStr.indexOf(".") !== -1 || decimalScale && fixedDecimalScale;
  var ref$1 = splitDecimal(numStr, allowNegative);
  var beforeDecimal = ref$1.beforeDecimal;
  var afterDecimal = ref$1.afterDecimal;
  var addNegation = ref$1.addNegation;
  if (decimalScale !== void 0) {
    afterDecimal = limitToScale(afterDecimal, decimalScale, !!fixedDecimalScale);
  }
  if (thousandSeparator) {
    beforeDecimal = applyThousandSeparator(beforeDecimal, thousandSeparator, thousandsGroupStyle);
  }
  if (prefix2) {
    beforeDecimal = prefix2 + beforeDecimal;
  }
  if (suffix) {
    afterDecimal = afterDecimal + suffix;
  }
  if (addNegation) {
    beforeDecimal = "-" + beforeDecimal;
  }
  numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || "") + afterDecimal;
  return numStr;
}
function getSeparators(props) {
  var decimalSeparator = props.decimalSeparator;
  if (decimalSeparator === void 0)
    decimalSeparator = ".";
  var thousandSeparator = props.thousandSeparator;
  var allowedDecimalSeparators = props.allowedDecimalSeparators;
  if (thousandSeparator === true) {
    thousandSeparator = ",";
  }
  if (!allowedDecimalSeparators) {
    allowedDecimalSeparators = [decimalSeparator, "."];
  }
  return {
    decimalSeparator,
    thousandSeparator,
    allowedDecimalSeparators
  };
}
function handleNegation(value, allowNegative) {
  if (value === void 0)
    value = "";
  var negationRegex = new RegExp("(-)");
  var doubleNegationRegex = new RegExp("(-)(.)*(-)");
  var hasNegation = negationRegex.test(value);
  var removeNegation = doubleNegationRegex.test(value);
  value = value.replace(/-/g, "");
  if (hasNegation && !removeNegation && allowNegative) {
    value = "-" + value;
  }
  return value;
}
function getNumberRegex(decimalSeparator, global2) {
  return new RegExp("(^-)|[0-9]|" + escapeRegExp$1(decimalSeparator), global2 ? "g" : void 0);
}
function isNumericString(val, prefix2, suffix) {
  if (val === "") {
    return true;
  }
  return !(prefix2 === null || prefix2 === void 0 ? void 0 : prefix2.match(/\d/)) && !(suffix === null || suffix === void 0 ? void 0 : suffix.match(/\d/)) && typeof val === "string" && !isNaN(Number(val));
}
function removeFormatting(value, changeMeta, props) {
  var assign2;
  if (changeMeta === void 0)
    changeMeta = getDefaultChangeMeta(value);
  var allowNegative = props.allowNegative;
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var suffix = props.suffix;
  if (suffix === void 0)
    suffix = "";
  var decimalScale = props.decimalScale;
  var from2 = changeMeta.from;
  var to = changeMeta.to;
  var start2 = to.start;
  var end2 = to.end;
  var ref = getSeparators(props);
  var allowedDecimalSeparators = ref.allowedDecimalSeparators;
  var decimalSeparator = ref.decimalSeparator;
  var isBeforeDecimalSeparator = value[end2] === decimalSeparator;
  if (charIsNumber(value) && (value === prefix2 || value === suffix) && changeMeta.lastValue === "") {
    return value;
  }
  if (end2 - start2 === 1 && allowedDecimalSeparators.indexOf(value[start2]) !== -1) {
    var separator = decimalScale === 0 ? "" : decimalSeparator;
    value = value.substring(0, start2) + separator + value.substring(start2 + 1, value.length);
  }
  var stripNegation = function(value2, start3, end3) {
    var hasNegation2 = false;
    var hasDoubleNegation = false;
    if (prefix2.startsWith("-")) {
      hasNegation2 = false;
    } else if (value2.startsWith("--")) {
      hasNegation2 = false;
      hasDoubleNegation = true;
    } else if (suffix.startsWith("-") && value2.length === suffix.length) {
      hasNegation2 = false;
    } else if (value2[0] === "-") {
      hasNegation2 = true;
    }
    var charsToRemove = hasNegation2 ? 1 : 0;
    if (hasDoubleNegation) {
      charsToRemove = 2;
    }
    if (charsToRemove) {
      value2 = value2.substring(charsToRemove);
      start3 -= charsToRemove;
      end3 -= charsToRemove;
    }
    return { value: value2, start: start3, end: end3, hasNegation: hasNegation2 };
  };
  var toMetadata = stripNegation(value, start2, end2);
  var hasNegation = toMetadata.hasNegation;
  assign2 = toMetadata, value = assign2.value, start2 = assign2.start, end2 = assign2.end;
  var ref$1 = stripNegation(changeMeta.lastValue, from2.start, from2.end);
  var fromStart = ref$1.start;
  var fromEnd = ref$1.end;
  var lastValue = ref$1.value;
  var updatedSuffixPart = value.substring(start2, end2);
  if (value.length && lastValue.length && (fromStart > lastValue.length - suffix.length || fromEnd < prefix2.length) && !(updatedSuffixPart && suffix.startsWith(updatedSuffixPart))) {
    value = lastValue;
  }
  var startIndex = 0;
  if (value.startsWith(prefix2)) {
    startIndex += prefix2.length;
  } else if (start2 < prefix2.length) {
    startIndex = start2;
  }
  value = value.substring(startIndex);
  end2 -= startIndex;
  var endIndex = value.length;
  var suffixStartIndex = value.length - suffix.length;
  if (value.endsWith(suffix)) {
    endIndex = suffixStartIndex;
  } else if (end2 > suffixStartIndex) {
    endIndex = end2;
  } else if (end2 > value.length - suffix.length) {
    endIndex = end2;
  }
  value = value.substring(0, endIndex);
  value = handleNegation(hasNegation ? "-" + value : value, allowNegative);
  value = (value.match(getNumberRegex(decimalSeparator, true)) || []).join("");
  var firstIndex = value.indexOf(decimalSeparator);
  value = value.replace(new RegExp(escapeRegExp$1(decimalSeparator), "g"), function(match2, index2) {
    return index2 === firstIndex ? "." : "";
  });
  var ref$2 = splitDecimal(value, allowNegative);
  var beforeDecimal = ref$2.beforeDecimal;
  var afterDecimal = ref$2.afterDecimal;
  var addNegation = ref$2.addNegation;
  if (to.end - to.start < from2.end - from2.start && beforeDecimal === "" && isBeforeDecimalSeparator && !parseFloat(afterDecimal)) {
    value = addNegation ? "-" : "";
  }
  return value;
}
function getCaretBoundary(formattedValue, props) {
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var suffix = props.suffix;
  if (suffix === void 0)
    suffix = "";
  var boundaryAry = Array.from({ length: formattedValue.length + 1 }).map(function() {
    return true;
  });
  var hasNegation = formattedValue[0] === "-";
  boundaryAry.fill(false, 0, prefix2.length + (hasNegation ? 1 : 0));
  var valLn = formattedValue.length;
  boundaryAry.fill(false, valLn - suffix.length + 1, valLn + 1);
  return boundaryAry;
}
function validateAndUpdateProps(props) {
  var ref = getSeparators(props);
  var thousandSeparator = ref.thousandSeparator;
  var decimalSeparator = ref.decimalSeparator;
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var allowNegative = props.allowNegative;
  if (allowNegative === void 0)
    allowNegative = true;
  if (thousandSeparator === decimalSeparator) {
    throw new Error("\n        Decimal separator can't be same as thousand separator.\n        thousandSeparator: " + thousandSeparator + ' (thousandSeparator = {true} is same as thousandSeparator = ",")\n        decimalSeparator: ' + decimalSeparator + " (default value for decimalSeparator is .)\n     ");
  }
  if (prefix2.startsWith("-") && allowNegative) {
    console.error("\n      Prefix can't start with '-' when allowNegative is true.\n      prefix: " + prefix2 + "\n      allowNegative: " + allowNegative + "\n    ");
    allowNegative = false;
  }
  return Object.assign(Object.assign({}, props), { allowNegative });
}
function useNumericFormat(props) {
  props = validateAndUpdateProps(props);
  props.decimalSeparator;
  props.allowedDecimalSeparators;
  props.thousandsGroupStyle;
  var suffix = props.suffix;
  var allowNegative = props.allowNegative;
  var allowLeadingZeros = props.allowLeadingZeros;
  var onKeyDown = props.onKeyDown;
  if (onKeyDown === void 0)
    onKeyDown = noop$5;
  var onBlur = props.onBlur;
  if (onBlur === void 0)
    onBlur = noop$5;
  var thousandSeparator = props.thousandSeparator;
  var decimalScale = props.decimalScale;
  var fixedDecimalScale = props.fixedDecimalScale;
  var prefix2 = props.prefix;
  if (prefix2 === void 0)
    prefix2 = "";
  var defaultValue = props.defaultValue;
  var value = props.value;
  var valueIsNumericString = props.valueIsNumericString;
  var onValueChange = props.onValueChange;
  var restProps = __rest(props, ["decimalSeparator", "allowedDecimalSeparators", "thousandsGroupStyle", "suffix", "allowNegative", "allowLeadingZeros", "onKeyDown", "onBlur", "thousandSeparator", "decimalScale", "fixedDecimalScale", "prefix", "defaultValue", "value", "valueIsNumericString", "onValueChange"]);
  var ref = getSeparators(props);
  var decimalSeparator = ref.decimalSeparator;
  var allowedDecimalSeparators = ref.allowedDecimalSeparators;
  var _format = function(numStr) {
    return format(numStr, props);
  };
  var _removeFormatting = function(inputValue, changeMeta) {
    return removeFormatting(inputValue, changeMeta, props);
  };
  var _value = isNil$1(value) ? defaultValue : value;
  var _valueIsNumericString = valueIsNumericString !== null && valueIsNumericString !== void 0 ? valueIsNumericString : isNumericString(_value, prefix2, suffix);
  if (!isNil$1(value)) {
    _valueIsNumericString = _valueIsNumericString || typeof value === "number";
  } else if (!isNil$1(defaultValue)) {
    _valueIsNumericString = _valueIsNumericString || typeof defaultValue === "number";
  }
  var roundIncomingValueToPrecision = function(value2) {
    if (isNotValidValue(value2)) {
      return value2;
    }
    if (typeof value2 === "number") {
      value2 = toNumericString(value2);
    }
    if (_valueIsNumericString && typeof decimalScale === "number") {
      return roundToPrecision(value2, decimalScale, Boolean(fixedDecimalScale));
    }
    return value2;
  };
  var ref$1 = useInternalValues(roundIncomingValueToPrecision(value), roundIncomingValueToPrecision(defaultValue), Boolean(_valueIsNumericString), _format, _removeFormatting, onValueChange);
  var ref$1_0 = ref$1[0];
  var numAsString = ref$1_0.numAsString;
  var formattedValue = ref$1_0.formattedValue;
  var _onValueChange = ref$1[1];
  var _onKeyDown = function(e2) {
    var el2 = e2.target;
    var key = e2.key;
    var selectionStart = el2.selectionStart;
    var selectionEnd = el2.selectionEnd;
    var value2 = el2.value;
    if (value2 === void 0)
      value2 = "";
    if (selectionStart !== selectionEnd) {
      onKeyDown(e2);
      return;
    }
    if (key === "Backspace" && value2[0] === "-" && selectionStart === prefix2.length + 1 && allowNegative) {
      setCaretPosition(el2, 1);
    }
    if (decimalScale && fixedDecimalScale) {
      if (key === "Backspace" && value2[selectionStart - 1] === decimalSeparator) {
        setCaretPosition(el2, selectionStart - 1);
        e2.preventDefault();
      } else if (key === "Delete" && value2[selectionStart] === decimalSeparator) {
        e2.preventDefault();
      }
    }
    if ((allowedDecimalSeparators === null || allowedDecimalSeparators === void 0 ? void 0 : allowedDecimalSeparators.includes(key)) && value2[selectionStart] === decimalSeparator) {
      setCaretPosition(el2, selectionStart + 1);
    }
    var _thousandSeparator = thousandSeparator === true ? "," : thousandSeparator;
    if (key === "Backspace" && value2[selectionStart - 1] === _thousandSeparator) {
      setCaretPosition(el2, selectionStart - 1);
    }
    if (key === "Delete" && value2[selectionStart] === _thousandSeparator) {
      setCaretPosition(el2, selectionStart + 1);
    }
    onKeyDown(e2);
  };
  var _onBlur = function(e2) {
    var _value2 = numAsString;
    if (!_value2.match(/\d/g)) {
      _value2 = "";
    }
    if (!allowLeadingZeros) {
      _value2 = fixLeadingZero(_value2);
    }
    if (fixedDecimalScale && decimalScale) {
      _value2 = roundToPrecision(_value2, decimalScale, fixedDecimalScale);
    }
    if (_value2 !== numAsString) {
      var formattedValue2 = format(_value2, props);
      _onValueChange({
        formattedValue: formattedValue2,
        value: _value2,
        floatValue: parseFloat(_value2)
      }, {
        event: e2,
        source: SourceType.event
      });
    }
    onBlur(e2);
  };
  var isValidInputCharacter = function(inputChar) {
    if (inputChar === decimalSeparator) {
      return true;
    }
    return charIsNumber(inputChar);
  };
  var isCharacterSame = function(ref2) {
    var currentValue = ref2.currentValue;
    var lastValue = ref2.lastValue;
    var formattedValue2 = ref2.formattedValue;
    var currentValueIndex = ref2.currentValueIndex;
    var formattedValueIndex = ref2.formattedValueIndex;
    var curChar = currentValue[currentValueIndex];
    var newChar = formattedValue2[formattedValueIndex];
    var typedRange = findChangeRange(lastValue, currentValue);
    var to = typedRange.to;
    if (currentValueIndex >= to.start && currentValueIndex < to.end && allowedDecimalSeparators && allowedDecimalSeparators.includes(curChar) && newChar === decimalSeparator) {
      return true;
    }
    return curChar === newChar;
  };
  return Object.assign(Object.assign({}, restProps), {
    value: formattedValue,
    valueIsNumericString: false,
    isValidInputCharacter,
    isCharacterSame,
    onValueChange: _onValueChange,
    format: _format,
    removeFormatting: _removeFormatting,
    getCaretBoundary: function(formattedValue2) {
      return getCaretBoundary(formattedValue2, props);
    },
    onKeyDown: _onKeyDown,
    onBlur: _onBlur
  });
}
function NumericFormat(props) {
  var numericFormatProps = useNumericFormat(props);
  return React.createElement(NumberFormatBase, Object.assign({}, numericFormatProps));
}
var shim$4 = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$3 = reactExports;
function h$6(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$3 = "function" === typeof Object.is ? Object.is : h$6, l$4 = e$3.useState, m$4 = e$3.useEffect, n$6 = e$3.useLayoutEffect, p$5 = e$3.useDebugValue;
function q$4(a2, b2) {
  var d2 = b2(), f2 = l$4({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$6(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$3(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$4(function() {
    r$3(c2) && g2({ inst: c2 });
    return a2(function() {
      r$3(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$5(d2);
  return d2;
}
function r$3(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k$3(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$4(a2, b2) {
  return b2();
}
var u$7 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$4 : q$4;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$3.useSyncExternalStore ? e$3.useSyncExternalStore : u$7;
{
  shim$4.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim$4.exports;
var withSelector = { exports: {} };
var withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$5 = reactExports, n$5 = shimExports;
function p$4(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q$3 = "function" === typeof Object.is ? Object.is : p$4, r$2 = n$5.useSyncExternalStore, t$3 = h$5.useRef, u$6 = h$5.useEffect, v$4 = h$5.useMemo, w$4 = h$5.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c2 = t$3(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v$4(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4))
            return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q$3(d3, a4))
        return b3;
      var e3 = l2(a4);
      if (void 0 !== g2 && g2(b3, e3))
        return b3;
      d3 = a4;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$2(a2, c2[0], c2[1]);
  u$6(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w$4(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
function defaultNoopBatch(callback) {
  callback();
}
let batch = defaultNoopBatch;
const setBatch = (newBatch) => batch = newBatch;
const getBatch = () => batch;
const ContextKey = Symbol.for(`react-redux-context`);
const gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  var _gT$ContextKey;
  if (!reactExports.createContext)
    return {};
  const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */ new Map();
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(null);
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
const ReactReduxContext = /* @__PURE__ */ getContext();
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = reactExports.useContext(context);
    return contextValue;
  };
}
const useReduxContext = /* @__PURE__ */ createReduxContextHook();
const notInitialized = () => {
  throw new Error("uSES not initialized!");
};
let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = (fn3) => {
  useSyncExternalStoreWithSelector = fn3;
};
const refEquality = (a2, b2) => a2 === b2;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  return function useSelector2(selector, equalityFnOrOptions = {}) {
    const {
      equalityFn = refEquality,
      stabilityCheck = void 0,
      noopCheck = void 0
    } = typeof equalityFnOrOptions === "function" ? {
      equalityFn: equalityFnOrOptions
    } : equalityFnOrOptions;
    const {
      store: store2,
      subscription,
      getServerState,
      stabilityCheck: globalStabilityCheck,
      noopCheck: globalNoopCheck
    } = useReduxContext$1();
    reactExports.useRef(true);
    const wrappedSelector = reactExports.useCallback({
      [selector.name](state) {
        const selected = selector(state);
        return selected;
      }
    }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store2.getState, getServerState || store2.getState, wrappedSelector, equalityFn);
    reactExports.useDebugValue(selectedState);
    return selectedState;
  };
}
const useSelector = /* @__PURE__ */ createSelectorHook();
function createListenerCollection() {
  const batch2 = getBatch();
  let first = null;
  let last2 = null;
  return {
    clear() {
      first = null;
      last2 = null;
    },
    notify() {
      batch2(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      let listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      let listener = last2 = {
        callback,
        next: null,
        prev: last2
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last2 = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
const nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store2, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store2.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect$1 = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
function Provider({
  store: store2,
  context,
  children,
  serverState,
  stabilityCheck = "once",
  noopCheck = "once"
}) {
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store2);
    return {
      store: store2,
      subscription,
      getServerState: serverState ? () => serverState : void 0,
      stabilityCheck,
      noopCheck
    };
  }, [store2, serverState, stabilityCheck, noopCheck]);
  const previousState = reactExports.useMemo(() => store2.getState(), [store2]);
  useIsomorphicLayoutEffect$1(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store2.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context3 = context || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context3.Provider, {
    value: contextValue
  }, children);
}
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext$1 = (
    // @ts-ignore
    context === ReactReduxContext ? useReduxContext : (
      // @ts-ignore
      createReduxContextHook(context)
    )
  );
  return function useStore2() {
    const {
      store: store2
    } = useReduxContext$1();
    return store2;
  };
}
const useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore$1 = (
    // @ts-ignore
    context === ReactReduxContext ? useStore : createStoreHook(context)
  );
  return function useDispatch2() {
    const store2 = useStore$1();
    return store2.dispatch;
  };
}
const useDispatch = /* @__PURE__ */ createDispatchHook();
initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
setBatch(reactDomExports.unstable_batchedUpdates);
function n$4(n2) {
  for (var r2 = arguments.length, t3 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++)
    t3[e2 - 1] = arguments[e2];
  throw Error("[Immer] minified error nr: " + n2 + (t3.length ? " " + t3.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r$1(n2) {
  return !!n2 && !!n2[Q$3];
}
function t$2(n2) {
  var r2;
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3)
      return false;
    var r3 = Object.getPrototypeOf(n3);
    if (null === r3)
      return true;
    var t3 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
    return t3 === Object || "function" == typeof t3 && Function.toString.call(t3) === Z$4;
  }(n2) || Array.isArray(n2) || !!n2[L$3] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L$3]) || s$3(n2) || v$3(n2));
}
function i$7(n2, r2, t3) {
  void 0 === t3 && (t3 = false), 0 === o$3(n2) ? (t3 ? Object.keys : nn$1)(n2).forEach(function(e2) {
    t3 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
  }) : n2.forEach(function(t4, e2) {
    return r2(e2, t4, n2);
  });
}
function o$3(n2) {
  var r2 = n2[Q$3];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s$3(n2) ? 2 : v$3(n2) ? 3 : 0;
}
function u$5(n2, r2) {
  return 2 === o$3(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a$4(n2, r2) {
  return 2 === o$3(n2) ? n2.get(r2) : n2[r2];
}
function f$4(n2, r2, t3) {
  var e2 = o$3(n2);
  2 === e2 ? n2.set(r2, t3) : 3 === e2 ? n2.add(t3) : n2[r2] = t3;
}
function c$3(n2, r2) {
  return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s$3(n2) {
  return X$3 && n2 instanceof Map;
}
function v$3(n2) {
  return q$2 && n2 instanceof Set;
}
function p$3(n2) {
  return n2.o || n2.t;
}
function l$3(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn$1(n2);
  delete r2[Q$3];
  for (var t3 = nn$1(r2), e2 = 0; e2 < t3.length; e2++) {
    var i2 = t3[e2], o2 = r2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d$3(n2, e2) {
  return void 0 === e2 && (e2 = false), y$2(n2) || r$1(n2) || !t$2(n2) || (o$3(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h$4), Object.freeze(n2), e2 && i$7(n2, function(n3, r2) {
    return d$3(r2, true);
  }, true)), n2;
}
function h$4() {
  n$4(2);
}
function y$2(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b$3(r2) {
  var t3 = tn$1[r2];
  return t3 || n$4(18, r2), t3;
}
function m$3(n2, r2) {
  tn$1[n2] || (tn$1[n2] = r2);
}
function _$4() {
  return U$4;
}
function j$3(n2, r2) {
  r2 && (b$3("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function g$3(n2) {
  O$3(n2), n2.p.forEach(S$3), n2.p = null;
}
function O$3(n2) {
  n2 === U$4 && (U$4 = n2.l);
}
function w$3(n2) {
  return U$4 = { p: [], l: U$4, h: n2, m: true, _: 0 };
}
function S$3(n2) {
  var r2 = n2[Q$3];
  0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
}
function P$3(r2, e2) {
  e2._ = e2.p.length;
  var i2 = e2.p[0], o2 = void 0 !== r2 && r2 !== i2;
  return e2.h.O || b$3("ES5").S(e2, r2, o2), o2 ? (i2[Q$3].P && (g$3(e2), n$4(4)), t$2(r2) && (r2 = M$3(e2, r2), e2.l || x$3(e2, r2)), e2.u && b$3("Patches").M(i2[Q$3].t, r2, e2.u, e2.s)) : r2 = M$3(e2, i2, []), g$3(e2), e2.u && e2.v(e2.u, e2.s), r2 !== H$3 ? r2 : void 0;
}
function M$3(n2, r2, t3) {
  if (y$2(r2))
    return r2;
  var e2 = r2[Q$3];
  if (!e2)
    return i$7(r2, function(i2, o3) {
      return A$4(n2, e2, r2, i2, o3, t3);
    }, true), r2;
  if (e2.A !== n2)
    return r2;
  if (!e2.P)
    return x$3(n2, e2.t, true), e2.t;
  if (!e2.I) {
    e2.I = true, e2.A._--;
    var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l$3(e2.k) : e2.o, u2 = o2, a2 = false;
    3 === e2.i && (u2 = new Set(o2), o2.clear(), a2 = true), i$7(u2, function(r3, i2) {
      return A$4(n2, e2, o2, r3, i2, t3, a2);
    }), x$3(n2, o2, false), t3 && n2.u && b$3("Patches").N(e2, t3, n2.u, n2.s);
  }
  return e2.o;
}
function A$4(e2, i2, o2, a2, c2, s2, v2) {
  if (r$1(c2)) {
    var p2 = M$3(e2, c2, s2 && i2 && 3 !== i2.i && !u$5(i2.R, a2) ? s2.concat(a2) : void 0);
    if (f$4(o2, a2, p2), !r$1(p2))
      return;
    e2.m = false;
  } else
    v2 && o2.add(c2);
  if (t$2(c2) && !y$2(c2)) {
    if (!e2.h.D && e2._ < 1)
      return;
    M$3(e2, c2), i2 && i2.A.l || x$3(e2, c2);
  }
}
function x$3(n2, r2, t3) {
  void 0 === t3 && (t3 = false), !n2.l && n2.h.D && n2.m && d$3(r2, t3);
}
function z$3(n2, r2) {
  var t3 = n2[Q$3];
  return (t3 ? p$3(t3) : n2)[r2];
}
function I$3(n2, r2) {
  if (r2 in n2)
    for (var t3 = Object.getPrototypeOf(n2); t3; ) {
      var e2 = Object.getOwnPropertyDescriptor(t3, r2);
      if (e2)
        return e2;
      t3 = Object.getPrototypeOf(t3);
    }
}
function k$2(n2) {
  n2.P || (n2.P = true, n2.l && k$2(n2.l));
}
function E$3(n2) {
  n2.o || (n2.o = l$3(n2.t));
}
function N$2(n2, r2, t3) {
  var e2 = s$3(r2) ? b$3("MapSet").F(r2, t3) : v$3(r2) ? b$3("MapSet").T(r2, t3) : n2.O ? function(n3, r3) {
    var t4 = Array.isArray(n3), e3 = { i: t4 ? 1 : 0, A: r3 ? r3.A : _$4(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en$1;
    t4 && (i2 = [e3], o2 = on$1);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e3.k = f2, e3.j = a2, f2;
  }(r2, t3) : b$3("ES5").J(r2, t3);
  return (t3 ? t3.A : _$4()).p.push(e2), e2;
}
function R$2(e2) {
  return r$1(e2) || n$4(22, e2), function n2(r2) {
    if (!t$2(r2))
      return r2;
    var e3, u2 = r2[Q$3], c2 = o$3(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b$3("ES5").K(u2)))
        return u2.t;
      u2.I = true, e3 = D$3(r2, c2), u2.I = false;
    } else
      e3 = D$3(r2, c2);
    return i$7(e3, function(r3, t3) {
      u2 && a$4(u2.t, r3) === t3 || f$4(e3, r3, n2(t3));
    }), 3 === c2 ? new Set(e3) : e3;
  }(e2);
}
function D$3(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l$3(n2);
}
function F$4() {
  function t3(n2, r2) {
    var t4 = s2[n2];
    return t4 ? t4.enumerable = r2 : s2[n2] = t4 = { configurable: true, enumerable: r2, get: function() {
      var r3 = this[Q$3];
      return en$1.get(r3, n2);
    }, set: function(r3) {
      var t5 = this[Q$3];
      en$1.set(t5, n2, r3);
    } }, t4;
  }
  function e2(n2) {
    for (var r2 = n2.length - 1; r2 >= 0; r2--) {
      var t4 = n2[r2][Q$3];
      if (!t4.P)
        switch (t4.i) {
          case 5:
            a2(t4) && k$2(t4);
            break;
          case 4:
            o2(t4) && k$2(t4);
        }
    }
  }
  function o2(n2) {
    for (var r2 = n2.t, t4 = n2.k, e3 = nn$1(t4), i2 = e3.length - 1; i2 >= 0; i2--) {
      var o3 = e3[i2];
      if (o3 !== Q$3) {
        var a3 = r2[o3];
        if (void 0 === a3 && !u$5(r2, o3))
          return true;
        var f2 = t4[o3], s3 = f2 && f2[Q$3];
        if (s3 ? s3.t !== a3 : !c$3(f2, a3))
          return true;
      }
    }
    var v2 = !!r2[Q$3];
    return e3.length !== nn$1(r2).length + (v2 ? 0 : 1);
  }
  function a2(n2) {
    var r2 = n2.k;
    if (r2.length !== n2.t.length)
      return true;
    var t4 = Object.getOwnPropertyDescriptor(r2, r2.length - 1);
    if (t4 && !t4.get)
      return true;
    for (var e3 = 0; e3 < r2.length; e3++)
      if (!r2.hasOwnProperty(e3))
        return true;
    return false;
  }
  var s2 = {};
  m$3("ES5", { J: function(n2, r2) {
    var e3 = Array.isArray(n2), i2 = function(n3, r3) {
      if (n3) {
        for (var e4 = Array(r3.length), i3 = 0; i3 < r3.length; i3++)
          Object.defineProperty(e4, "" + i3, t3(i3, true));
        return e4;
      }
      var o4 = rn$1(r3);
      delete o4[Q$3];
      for (var u2 = nn$1(o4), a3 = 0; a3 < u2.length; a3++) {
        var f2 = u2[a3];
        o4[f2] = t3(f2, n3 || !!o4[f2].enumerable);
      }
      return Object.create(Object.getPrototypeOf(r3), o4);
    }(e3, n2), o3 = { i: e3 ? 5 : 4, A: r2 ? r2.A : _$4(), P: false, I: false, R: {}, l: r2, t: n2, k: i2, o: null, g: false, C: false };
    return Object.defineProperty(i2, Q$3, { value: o3, writable: true }), i2;
  }, S: function(n2, t4, o3) {
    o3 ? r$1(t4) && t4[Q$3].A === n2 && e2(n2.p) : (n2.u && function n3(r2) {
      if (r2 && "object" == typeof r2) {
        var t5 = r2[Q$3];
        if (t5) {
          var e3 = t5.t, o4 = t5.k, f2 = t5.R, c2 = t5.i;
          if (4 === c2)
            i$7(o4, function(r3) {
              r3 !== Q$3 && (void 0 !== e3[r3] || u$5(e3, r3) ? f2[r3] || n3(o4[r3]) : (f2[r3] = true, k$2(t5)));
            }), i$7(e3, function(n4) {
              void 0 !== o4[n4] || u$5(o4, n4) || (f2[n4] = false, k$2(t5));
            });
          else if (5 === c2) {
            if (a2(t5) && (k$2(t5), f2.length = true), o4.length < e3.length)
              for (var s3 = o4.length; s3 < e3.length; s3++)
                f2[s3] = false;
            else
              for (var v2 = e3.length; v2 < o4.length; v2++)
                f2[v2] = true;
            for (var p2 = Math.min(o4.length, e3.length), l2 = 0; l2 < p2; l2++)
              o4.hasOwnProperty(l2) || (f2[l2] = true), void 0 === f2[l2] && n3(o4[l2]);
          }
        }
      }
    }(n2.p[0]), e2(n2.p));
  }, K: function(n2) {
    return 4 === n2.i ? o2(n2) : a2(n2);
  } });
}
var G$3, U$4, W$4 = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X$3 = "undefined" != typeof Map, q$2 = "undefined" != typeof Set, B$2 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H$3 = W$4 ? Symbol.for("immer-nothing") : ((G$3 = {})["immer-nothing"] = true, G$3), L$3 = W$4 ? Symbol.for("immer-draftable") : "__$immer_draftable", Q$3 = W$4 ? Symbol.for("immer-state") : "__$immer_state", Z$4 = "" + Object.prototype.constructor, nn$1 = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames, rn$1 = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn$1(n2).forEach(function(t3) {
    r2[t3] = Object.getOwnPropertyDescriptor(n2, t3);
  }), r2;
}, tn$1 = {}, en$1 = { get: function(n2, r2) {
  if (r2 === Q$3)
    return n2;
  var e2 = p$3(n2);
  if (!u$5(e2, r2))
    return function(n3, r3, t3) {
      var e3, i3 = I$3(r3, t3);
      return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
    }(n2, e2, r2);
  var i2 = e2[r2];
  return n2.I || !t$2(i2) ? i2 : i2 === z$3(n2.t, r2) ? (E$3(n2), n2.o[r2] = N$2(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p$3(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p$3(n2));
}, set: function(n2, r2, t3) {
  var e2 = I$3(p$3(n2), r2);
  if (null == e2 ? void 0 : e2.set)
    return e2.set.call(n2.k, t3), true;
  if (!n2.P) {
    var i2 = z$3(p$3(n2), r2), o2 = null == i2 ? void 0 : i2[Q$3];
    if (o2 && o2.t === t3)
      return n2.o[r2] = t3, n2.R[r2] = false, true;
    if (c$3(t3, i2) && (void 0 !== t3 || u$5(n2.t, r2)))
      return true;
    E$3(n2), k$2(n2);
  }
  return n2.o[r2] === t3 && (void 0 !== t3 || r2 in n2.o) || Number.isNaN(t3) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t3, n2.R[r2] = true), true;
}, deleteProperty: function(n2, r2) {
  return void 0 !== z$3(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E$3(n2), k$2(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t3 = p$3(n2), e2 = Reflect.getOwnPropertyDescriptor(t3, r2);
  return e2 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e2.enumerable, value: t3[r2] } : e2;
}, defineProperty: function() {
  n$4(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n$4(12);
} }, on$1 = {};
i$7(en$1, function(n2, r2) {
  on$1[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on$1.deleteProperty = function(r2, t3) {
  return on$1.set.call(this, r2, t3, void 0);
}, on$1.set = function(r2, t3, e2) {
  return en$1.set.call(this, r2[0], t3, e2, r2[0]);
};
var un$1 = function() {
  function e2(r2) {
    var e3 = this;
    this.O = B$2, this.D = true, this.produce = function(r3, i3, o2) {
      if ("function" == typeof r3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = r3;
        var a2 = e3;
        return function(n2) {
          var r4 = this;
          void 0 === n2 && (n2 = u2);
          for (var t3 = arguments.length, e4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            e4[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t4;
            return (t4 = i3).call.apply(t4, [r4, n3].concat(e4));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n$4(6), void 0 !== o2 && "function" != typeof o2 && n$4(7), t$2(r3)) {
        var c2 = w$3(e3), s2 = N$2(e3, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? g$3(c2) : O$3(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
          return j$3(c2, o2), P$3(n2, c2);
        }, function(n2) {
          throw g$3(c2), n2;
        }) : (j$3(c2, o2), P$3(f2, c2));
      }
      if (!r3 || "object" != typeof r3) {
        if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H$3 && (f2 = void 0), e3.D && d$3(f2, true), o2) {
          var p2 = [], l2 = [];
          b$3("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n$4(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if ("function" == typeof n2)
        return function(r4) {
          for (var t4 = arguments.length, i4 = Array(t4 > 1 ? t4 - 1 : 0), o3 = 1; o3 < t4; o3++)
            i4[o3 - 1] = arguments[o3];
          return e3.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t3, i3, o2 = e3.produce(n2, r3, function(n3, r4) {
        t3 = n3, i3 = r4;
      });
      return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t3, i3];
      }) : [o2, t3, i3];
    }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e2.prototype;
  return i2.createDraft = function(e3) {
    t$2(e3) || n$4(8), r$1(e3) && (e3 = R$2(e3));
    var i3 = w$3(this), o2 = N$2(this, e3, void 0);
    return o2[Q$3].C = true, O$3(i3), o2;
  }, i2.finishDraft = function(r2, t3) {
    var e3 = r2 && r2[Q$3];
    var i3 = e3.A;
    return j$3(i3, t3), P$3(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.D = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B$2 && n$4(20), this.O = r2;
  }, i2.applyPatches = function(n2, t3) {
    var e3;
    for (e3 = t3.length - 1; e3 >= 0; e3--) {
      var i3 = t3[e3];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e3 > -1 && (t3 = t3.slice(e3 + 1));
    var o2 = b$3("Patches").$;
    return r$1(n2) ? o2(n2, t3) : this.produce(n2, function(n3) {
      return o2(n3, t3);
    });
  }, e2;
}(), an$1 = new un$1(), fn$1 = an$1.produce;
an$1.produceWithPatches.bind(an$1);
an$1.setAutoFreeze.bind(an$1);
an$1.setUseProxies.bind(an$1);
an$1.applyPatches.bind(an$1);
an$1.createDraft.bind(an$1);
an$1.finishDraft.bind(an$1);
function _typeof$2(o2) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$2(o2);
}
function _toPrimitive$1(input, hint) {
  if (_typeof$2(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$2(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return _typeof$2(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e2, r2) {
  var t3 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t3.push.apply(t3, o2);
  }
  return t3;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t3 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t3), true).forEach(function(r3) {
      _defineProperty(e2, r3, t3[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3)) : ownKeys(Object(t3)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t3, r3));
    });
  }
  return e2;
}
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject$3(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$3(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i2 = 0; i2 < listeners.length; i2++) {
      var listener = listeners[i2];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable2() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable2, _ref2;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function(key) {
    var reducer = reducers[key];
    var initialState2 = reducer(void 0, {
      type: ActionTypes.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(formatProdErrorMessage(12));
    }
    if (typeof reducer(void 0, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage(13));
    }
  });
}
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i2 = 0; i2 < reducerKeys.length; i2++) {
    var key = reducerKeys[i2];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);
  var shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e2) {
    shapeAssertionError = e2;
  }
  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage(14));
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose$1() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a2, b2) {
    return function() {
      return a2(b2.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store2 = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(formatProdErrorMessage(15));
      };
      var middlewareAPI = {
        getState: store2.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware2) {
        return middleware2(middlewareAPI);
      });
      _dispatch = compose$1.apply(void 0, chain)(store2.dispatch);
      return _objectSpread2(_objectSpread2({}, store2), {}, {
        dispatch: _dispatch
      });
    };
  };
}
var NOT_FOUND = "NOT_FOUND";
function createSingletonCache(equals) {
  var entry;
  return {
    get: function get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put: function put(key, value) {
      entry = {
        key,
        value
      };
    },
    getEntries: function getEntries() {
      return entry ? [entry] : [];
    },
    clear: function clear2() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  var entries = [];
  function get(key) {
    var cacheIndex = entries.findIndex(function(entry2) {
      return equals(key, entry2.key);
    });
    if (cacheIndex > -1) {
      var entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({
        key,
        value
      });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear2() {
    entries = [];
  }
  return {
    get,
    put,
    getEntries,
    clear: clear2
  };
}
var defaultEqualityCheck = function defaultEqualityCheck2(a2, b2) {
  return a2 === b2;
};
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev2, next2) {
    if (prev2 === null || next2 === null || prev2.length !== next2.length) {
      return false;
    }
    var length2 = prev2.length;
    for (var i2 = 0; i2 < length2; i2++) {
      if (!equalityCheck(prev2[i2], next2[i2])) {
        return false;
      }
    }
    return true;
  };
}
function defaultMemoize(func, equalityCheckOrOptions) {
  var providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  };
  var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;
  var comparator = createCacheKeyComparator(equalityCheck);
  var cache2 = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    var value = cache2.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      if (resultEqualityCheck) {
        var entries = cache2.getEntries();
        var matchingEntry = entries.find(function(entry) {
          return resultEqualityCheck(entry.value, value);
        });
        if (matchingEntry) {
          value = matchingEntry.value;
        }
      }
      cache2.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = function() {
    return cache2.clear();
  };
  return memoized;
}
function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
  if (!dependencies.every(function(dep) {
    return typeof dep === "function";
  })) {
    var dependencyTypes = dependencies.map(function(dep) {
      return typeof dep === "function" ? "function " + (dep.name || "unnamed") + "()" : typeof dep;
    }).join(", ");
    throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
  }
  return dependencies;
}
function createSelectorCreator(memoize2) {
  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptionsFromArgs[_key - 1] = arguments[_key];
  }
  var createSelector2 = function createSelector3() {
    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }
    var _recomputations = 0;
    var _lastResult;
    var directlyPassedOptions = {
      memoizeOptions: void 0
    };
    var resultFunc = funcs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = funcs.pop();
    }
    if (typeof resultFunc !== "function") {
      throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
    }
    var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2;
    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
    var dependencies = getDependencies(funcs);
    var memoizedResultFunc = memoize2.apply(void 0, [function recomputationWrapper() {
      _recomputations++;
      return resultFunc.apply(null, arguments);
    }].concat(finalMemoizeOptions));
    var selector = memoize2(function dependenciesChecker() {
      var params = [];
      var length2 = dependencies.length;
      for (var i2 = 0; i2 < length2; i2++) {
        params.push(dependencies[i2].apply(null, arguments));
      }
      _lastResult = memoizedResultFunc.apply(null, params);
      return _lastResult;
    });
    Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      lastResult: function lastResult() {
        return _lastResult;
      },
      recomputations: function recomputations() {
        return _recomputations;
      },
      resetRecomputations: function resetRecomputations() {
        return _recomputations = 0;
      }
    });
    return selector;
  };
  return createSelector2;
}
var createSelector$1 = /* @__PURE__ */ createSelectorCreator(defaultMemoize);
function createThunkMiddleware(extraArgument) {
  var middleware2 = function middleware3(_ref) {
    var dispatch = _ref.dispatch, getState = _ref.getState;
    return function(next2) {
      return function(action) {
        if (typeof action === "function") {
          return action(dispatch, getState, extraArgument);
        }
        return next2(action);
      };
    };
  };
  return middleware2;
}
var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
const thunkMiddleware = thunk;
var __extends$2 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __generator$2 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y2, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
          return t3;
        if (y2 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray$2 = globalThis && globalThis.__spreadArray || function(to, from2) {
  for (var i2 = 0, il2 = from2.length, j2 = to.length; i2 < il2; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = function(obj, key, value) {
  return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
};
var __spreadValues = function(a2, b2) {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var _i = 0, _c = __getOwnPropSymbols(b2); _i < _c.length; _i++) {
      var prop = _c[_i];
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = function(a2, b2) {
  return __defProps(a2, __getOwnPropDescs(b2));
};
var __async = function(__this, __arguments, generator) {
  return new Promise(function(resolve2, reject) {
    var fulfilled = function(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = function(value) {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = function(x2) {
      return x2.done ? resolve2(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    };
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose$1;
  return compose$1.apply(null, arguments);
};
function isPlainObject$2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  var proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  var baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
function createAction(type2, prepareAction) {
  function actionCreator() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (prepareAction) {
      var prepared = prepareAction.apply(void 0, args);
      if (!prepared) {
        throw new Error("prepareAction did not return an object");
      }
      return __spreadValues(__spreadValues({
        type: type2,
        payload: prepared.payload
      }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
    }
    return { type: type2, payload: args[0] };
  }
  actionCreator.toString = function() {
    return "" + type2;
  };
  actionCreator.type = type2;
  actionCreator.match = function(action) {
    return action.type === type2;
  };
  return actionCreator;
}
var MiddlewareArray = (
  /** @class */
  function(_super) {
    __extends$2(MiddlewareArray2, _super);
    function MiddlewareArray2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.apply(this, args) || this;
      Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
      return _this;
    }
    Object.defineProperty(MiddlewareArray2, Symbol.species, {
      get: function() {
        return MiddlewareArray2;
      },
      enumerable: false,
      configurable: true
    });
    MiddlewareArray2.prototype.concat = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      return _super.prototype.concat.apply(this, arr);
    };
    MiddlewareArray2.prototype.prepend = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray$2([void 0], arr[0].concat(this))))();
      }
      return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray$2([void 0], arr.concat(this))))();
    };
    return MiddlewareArray2;
  }(Array)
);
var EnhancerArray = (
  /** @class */
  function(_super) {
    __extends$2(EnhancerArray2, _super);
    function EnhancerArray2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.apply(this, args) || this;
      Object.setPrototypeOf(_this, EnhancerArray2.prototype);
      return _this;
    }
    Object.defineProperty(EnhancerArray2, Symbol.species, {
      get: function() {
        return EnhancerArray2;
      },
      enumerable: false,
      configurable: true
    });
    EnhancerArray2.prototype.concat = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      return _super.prototype.concat.apply(this, arr);
    };
    EnhancerArray2.prototype.prepend = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray$2([void 0], arr[0].concat(this))))();
      }
      return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray$2([void 0], arr.concat(this))))();
    };
    return EnhancerArray2;
  }(Array)
);
function freezeDraftable(val) {
  return t$2(val) ? fn$1(val, function() {
  }) : val;
}
function isBoolean$2(x2) {
  return typeof x2 === "boolean";
}
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options) {
    return getDefaultMiddleware(options);
  };
}
function getDefaultMiddleware(options) {
  if (options === void 0) {
    options = {};
  }
  var _c = options.thunk, thunk2 = _c === void 0 ? true : _c;
  options.immutableCheck;
  options.serializableCheck;
  options.actionCreatorCheck;
  var middlewareArray = new MiddlewareArray();
  if (thunk2) {
    if (isBoolean$2(thunk2)) {
      middlewareArray.push(thunkMiddleware);
    } else {
      middlewareArray.push(thunkMiddleware.withExtraArgument(thunk2.extraArgument));
    }
  }
  return middlewareArray;
}
var IS_PRODUCTION = true;
function configureStore(options) {
  var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e2 = _c.middleware, middleware2 = _e2 === void 0 ? curriedGetDefaultMiddleware() : _e2, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
  var rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject$2(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }
  var finalMiddleware = middleware2;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
  }
  var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
  var finalCompose = compose$1;
  if (devTools) {
    finalCompose = composeWithDevTools(__spreadValues({
      trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
  }
  var defaultEnhancers = new EnhancerArray(middlewareEnhancer);
  var storeEnhancers = defaultEnhancers;
  if (Array.isArray(enhancers)) {
    storeEnhancers = __spreadArray$2([middlewareEnhancer], enhancers);
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(defaultEnhancers);
  }
  var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  var actionsMap = {};
  var actionMatchers = [];
  var defaultCaseReducer;
  var builder = {
    addCase: function(typeOrActionCreator, reducer) {
      var type2 = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type2) {
        throw new Error("`builder.addCase` cannot be called with an empty action type");
      }
      if (type2 in actionsMap) {
        throw new Error("`builder.addCase` cannot be called with two reducers for the same action type");
      }
      actionsMap[type2] = reducer;
      return builder;
    },
    addMatcher: function(matcher, reducer) {
      actionMatchers.push({ matcher, reducer });
      return builder;
    },
    addDefaultCase: function(reducer) {
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x2) {
  return typeof x2 === "function";
}
function createReducer(initialState2, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
  if (actionMatchers === void 0) {
    actionMatchers = [];
  }
  var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
  var getInitialState;
  if (isStateFunction(initialState2)) {
    getInitialState = function() {
      return freezeDraftable(initialState2());
    };
  } else {
    var frozenInitialState_1 = freezeDraftable(initialState2);
    getInitialState = function() {
      return frozenInitialState_1;
    };
  }
  function reducer(state, action) {
    if (state === void 0) {
      state = getInitialState();
    }
    var caseReducers = __spreadArray$2([
      actionsMap[action.type]
    ], finalActionMatchers.filter(function(_c2) {
      var matcher = _c2.matcher;
      return matcher(action);
    }).map(function(_c2) {
      var reducer2 = _c2.reducer;
      return reducer2;
    }));
    if (caseReducers.filter(function(cr) {
      return !!cr;
    }).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce(function(previousState, caseReducer) {
      if (caseReducer) {
        if (r$1(previousState)) {
          var draft = previousState;
          var result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!t$2(previousState)) {
          var result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return fn$1(previousState, function(draft2) {
            return caseReducer(draft2, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
function getType2(slice2, actionKey) {
  return slice2 + "/" + actionKey;
}
function createSlice(options) {
  var name = options.name;
  if (!name) {
    throw new Error("`name` is a required option for createSlice");
  }
  if (typeof process !== "undefined" && false) {
    if (options.initialState === void 0) {
      console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    }
  }
  var initialState2 = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
  var reducers = options.reducers || {};
  var reducerNames = Object.keys(reducers);
  var sliceCaseReducersByName = {};
  var sliceCaseReducersByType = {};
  var actionCreators = {};
  reducerNames.forEach(function(reducerName) {
    var maybeReducerWithPrepare = reducers[reducerName];
    var type2 = getType2(name, reducerName);
    var caseReducer;
    var prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type2] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type2, prepareCallback) : createAction(type2);
  });
  function buildReducer() {
    var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e2 = _c[1], actionMatchers = _e2 === void 0 ? [] : _e2, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
    var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
    return createReducer(initialState2, function(builder) {
      for (var key in finalCaseReducers) {
        builder.addCase(key, finalCaseReducers[key]);
      }
      for (var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++) {
        var m2 = actionMatchers_1[_i];
        builder.addMatcher(m2.matcher, m2.reducer);
      }
      if (defaultCaseReducer) {
        builder.addDefaultCase(defaultCaseReducer);
      }
    });
  }
  var _reducer;
  return {
    name,
    reducer: function(state, action) {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer(state, action);
    },
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName,
    getInitialState: function() {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer.getInitialState();
    }
  };
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = function(size) {
  if (size === void 0) {
    size = 21;
  }
  var id2 = "";
  var i2 = size;
  while (i2--) {
    id2 += urlAlphabet[Math.random() * 64 | 0];
  }
  return id2;
};
var commonProperties = [
  "name",
  "message",
  "stack",
  "code"
];
var RejectWithValue = (
  /** @class */
  function() {
    function RejectWithValue2(payload, meta) {
      this.payload = payload;
      this.meta = meta;
    }
    return RejectWithValue2;
  }()
);
var FulfillWithMeta = (
  /** @class */
  function() {
    function FulfillWithMeta2(payload, meta) {
      this.payload = payload;
      this.meta = meta;
    }
    return FulfillWithMeta2;
  }()
);
var miniSerializeError = function(value) {
  if (typeof value === "object" && value !== null) {
    var simpleError = {};
    for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
      var property = commonProperties_1[_i];
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return { message: String(value) };
};
(function() {
  function createAsyncThunk2(typePrefix, payloadCreator, options) {
    var fulfilled = createAction(typePrefix + "/fulfilled", function(payload, requestId, arg, meta) {
      return {
        payload,
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "fulfilled"
        })
      };
    });
    var pending = createAction(typePrefix + "/pending", function(requestId, arg, meta) {
      return {
        payload: void 0,
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "pending"
        })
      };
    });
    var rejected = createAction(typePrefix + "/rejected", function(error, requestId, arg, payload, meta) {
      return {
        payload,
        error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          rejectedWithValue: !!payload,
          requestStatus: "rejected",
          aborted: (error == null ? void 0 : error.name) === "AbortError",
          condition: (error == null ? void 0 : error.name) === "ConditionError"
        })
      };
    });
    var AC = typeof AbortController !== "undefined" ? AbortController : (
      /** @class */
      function() {
        function class_1() {
          this.signal = {
            aborted: false,
            addEventListener: function() {
            },
            dispatchEvent: function() {
              return false;
            },
            onabort: function() {
            },
            removeEventListener: function() {
            },
            reason: void 0,
            throwIfAborted: function() {
            }
          };
        }
        class_1.prototype.abort = function() {
        };
        return class_1;
      }()
    );
    function actionCreator(arg) {
      return function(dispatch, getState, extra) {
        var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
        var abortController = new AC();
        var abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        var promise2 = function() {
          return __async(this, null, function() {
            var _a2, _b2, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
            return __generator$2(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _c.trys.push([0, 4, , 5]);
                  conditionResult = (_a2 = options == null ? void 0 : options.condition) == null ? void 0 : _a2.call(options, arg, { getState, extra });
                  if (!isThenable$1(conditionResult))
                    return [3, 2];
                  return [4, conditionResult];
                case 1:
                  conditionResult = _c.sent();
                  _c.label = 2;
                case 2:
                  if (conditionResult === false || abortController.signal.aborted) {
                    throw {
                      name: "ConditionError",
                      message: "Aborted due to condition callback returning false."
                    };
                  }
                  abortedPromise = new Promise(function(_2, reject) {
                    return abortController.signal.addEventListener("abort", function() {
                      return reject({
                        name: "AbortError",
                        message: abortReason || "Aborted"
                      });
                    });
                  });
                  dispatch(pending(requestId, arg, (_b2 = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b2.call(options, { requestId, arg }, { getState, extra })));
                  return [4, Promise.race([
                    abortedPromise,
                    Promise.resolve(payloadCreator(arg, {
                      dispatch,
                      getState,
                      extra,
                      requestId,
                      signal: abortController.signal,
                      abort,
                      rejectWithValue: function(value, meta) {
                        return new RejectWithValue(value, meta);
                      },
                      fulfillWithValue: function(value, meta) {
                        return new FulfillWithMeta(value, meta);
                      }
                    })).then(function(result) {
                      if (result instanceof RejectWithValue) {
                        throw result;
                      }
                      if (result instanceof FulfillWithMeta) {
                        return fulfilled(result.payload, requestId, arg, result.meta);
                      }
                      return fulfilled(result, requestId, arg);
                    })
                  ])];
                case 3:
                  finalAction = _c.sent();
                  return [3, 5];
                case 4:
                  err_1 = _c.sent();
                  finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                  return [3, 5];
                case 5:
                  skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                  if (!skipDispatch) {
                    dispatch(finalAction);
                  }
                  return [2, finalAction];
              }
            });
          });
        }();
        return Object.assign(promise2, {
          abort,
          requestId,
          arg,
          unwrap: function() {
            return promise2.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = function() {
    return createAsyncThunk2;
  };
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable$1(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var alm = "listenerMiddleware";
createAction(alm + "/add");
createAction(alm + "/removeAll");
createAction(alm + "/remove");
var promise;
typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb2) {
  return (promise || (promise = Promise.resolve())).then(cb2).catch(function(err) {
    return setTimeout(function() {
      throw err;
    }, 0);
  });
};
F$4();
const initialState$8 = {
  isLoading: false,
  isOnline: false,
  shouldReload: false
};
const loaderSlice = createSlice({
  name: "loader",
  // `createSlice` will infer the state type from the `initialState` argument
  initialState: initialState$8,
  reducers: {
    // Use the PayloadAction type to declare the contents of `action.payload`
    setLoading: (state, action) => {
      state.isLoading = action.payload;
    },
    setOnline: (state, action) => {
      state.isOnline = action.payload;
    },
    setReload: (state, action) => {
      state.shouldReload = action.payload;
    }
  }
});
const { setLoading, setOnline, setReload } = loaderSlice.actions;
const loaderReducer = loaderSlice.reducer;
const messages = {
  AbortError: "A request was aborted, for example through a call to IDBTransaction.abort.",
  ConstraintError: "A mutation operation in the transaction failed because a constraint was not satisfied. For example, an object such as an object store or index already exists and a request attempted to create a new one.",
  DataCloneError: "The data being stored could not be cloned by the internal structured cloning algorithm.",
  DataError: "Data provided to an operation does not meet requirements.",
  InvalidAccessError: "An invalid operation was performed on an object. For example transaction creation attempt was made, but an empty scope was provided.",
  InvalidStateError: "An operation was called on an object on which it is not allowed or at a time when it is not allowed. Also occurs if a request is made on a source object that has been deleted or removed. Use TransactionInactiveError or ReadOnlyError when possible, as they are more specific variations of InvalidStateError.",
  NotFoundError: "The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.",
  ReadOnlyError: 'The mutating operation was attempted in a "readonly" transaction.',
  TransactionInactiveError: "A request was placed against a transaction which is currently not active, or which is finished.",
  VersionError: "An attempt was made to open a database using a lower version than the existing version."
};
class AbortError extends Error {
  constructor(message = messages.AbortError) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
}
class ConstraintError extends Error {
  constructor(message = messages.ConstraintError) {
    super();
    this.name = "ConstraintError";
    this.message = message;
  }
}
class DataCloneError extends Error {
  constructor(message = messages.DataCloneError) {
    super();
    this.name = "DataCloneError";
    this.message = message;
  }
}
class DataError extends Error {
  constructor(message = messages.DataError) {
    super();
    this.name = "DataError";
    this.message = message;
  }
}
class InvalidAccessError extends Error {
  constructor(message = messages.InvalidAccessError) {
    super();
    this.name = "InvalidAccessError";
    this.message = message;
  }
}
class InvalidStateError extends Error {
  constructor(message = messages.InvalidStateError) {
    super();
    this.name = "InvalidStateError";
    this.message = message;
  }
}
class NotFoundError extends Error {
  constructor(message = messages.NotFoundError) {
    super();
    this.name = "NotFoundError";
    this.message = message;
  }
}
class ReadOnlyError extends Error {
  constructor(message = messages.ReadOnlyError) {
    super();
    this.name = "ReadOnlyError";
    this.message = message;
  }
}
class TransactionInactiveError extends Error {
  constructor(message = messages.TransactionInactiveError) {
    super();
    this.name = "TransactionInactiveError";
    this.message = message;
  }
}
class VersionError extends Error {
  constructor(message = messages.VersionError) {
    super();
    this.name = "VersionError";
    this.message = message;
  }
}
const valueToKey = (input, seen2) => {
  if (typeof input === "number") {
    if (isNaN(input)) {
      throw new DataError();
    }
    return input;
  } else if (input instanceof Date) {
    const ms = input.valueOf();
    if (isNaN(ms)) {
      throw new DataError();
    }
    return new Date(ms);
  } else if (typeof input === "string") {
    return input;
  } else if (input instanceof ArrayBuffer || typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView && ArrayBuffer.isView(input)) {
    if (input instanceof ArrayBuffer) {
      return new Uint8Array(input).buffer;
    }
    return new Uint8Array(input.buffer).buffer;
  } else if (Array.isArray(input)) {
    if (seen2 === void 0) {
      seen2 = /* @__PURE__ */ new Set();
    } else if (seen2.has(input)) {
      throw new DataError();
    }
    seen2.add(input);
    const keys3 = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const hop = input.hasOwnProperty(i2);
      if (!hop) {
        throw new DataError();
      }
      const entry = input[i2];
      const key = valueToKey(entry, seen2);
      keys3.push(key);
    }
    return keys3;
  } else {
    throw new DataError();
  }
};
const getType$1 = (x2) => {
  if (typeof x2 === "number") {
    return "Number";
  }
  if (x2 instanceof Date) {
    return "Date";
  }
  if (Array.isArray(x2)) {
    return "Array";
  }
  if (typeof x2 === "string") {
    return "String";
  }
  if (x2 instanceof ArrayBuffer) {
    return "Binary";
  }
  throw new DataError();
};
const cmp = (first, second) => {
  if (second === void 0) {
    throw new TypeError();
  }
  first = valueToKey(first);
  second = valueToKey(second);
  const t1 = getType$1(first);
  const t22 = getType$1(second);
  if (t1 !== t22) {
    if (t1 === "Array") {
      return 1;
    }
    if (t1 === "Binary" && (t22 === "String" || t22 === "Date" || t22 === "Number")) {
      return 1;
    }
    if (t1 === "String" && (t22 === "Date" || t22 === "Number")) {
      return 1;
    }
    if (t1 === "Date" && t22 === "Number") {
      return 1;
    }
    return -1;
  }
  if (t1 === "Binary") {
    first = new Uint8Array(first);
    second = new Uint8Array(second);
  }
  if (t1 === "Array" || t1 === "Binary") {
    const length2 = Math.min(first.length, second.length);
    for (let i2 = 0; i2 < length2; i2++) {
      const result = cmp(first[i2], second[i2]);
      if (result !== 0) {
        return result;
      }
    }
    if (first.length > second.length) {
      return 1;
    }
    if (first.length < second.length) {
      return -1;
    }
    return 0;
  }
  if (t1 === "Date") {
    if (first.getTime() === second.getTime()) {
      return 0;
    }
  } else {
    if (first === second) {
      return 0;
    }
  }
  return first > second ? 1 : -1;
};
class FDBKeyRange {
  static only(value) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    value = valueToKey(value);
    return new FDBKeyRange(value, value, false, false);
  }
  static lowerBound(lower, open2 = false) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    lower = valueToKey(lower);
    return new FDBKeyRange(lower, void 0, open2, true);
  }
  static upperBound(upper, open2 = false) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    upper = valueToKey(upper);
    return new FDBKeyRange(void 0, upper, true, open2);
  }
  static bound(lower, upper, lowerOpen = false, upperOpen = false) {
    if (arguments.length < 2) {
      throw new TypeError();
    }
    const cmpResult = cmp(lower, upper);
    if (cmpResult === 1 || cmpResult === 0 && (lowerOpen || upperOpen)) {
      throw new DataError();
    }
    lower = valueToKey(lower);
    upper = valueToKey(upper);
    return new FDBKeyRange(lower, upper, lowerOpen, upperOpen);
  }
  constructor(lower, upper, lowerOpen, upperOpen) {
    this.lower = lower;
    this.upper = upper;
    this.lowerOpen = lowerOpen;
    this.upperOpen = upperOpen;
  }
  // https://w3c.github.io/IndexedDB/#dom-idbkeyrange-includes
  includes(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    key = valueToKey(key);
    if (this.lower !== void 0) {
      const cmpResult = cmp(this.lower, key);
      if (cmpResult === 1 || cmpResult === 0 && this.lowerOpen) {
        return false;
      }
    }
    if (this.upper !== void 0) {
      const cmpResult = cmp(this.upper, key);
      if (cmpResult === -1 || cmpResult === 0 && this.upperOpen) {
        return false;
      }
    }
    return true;
  }
  toString() {
    return "[object IDBKeyRange]";
  }
}
const extractKey = (keyPath, value) => {
  if (Array.isArray(keyPath)) {
    const result = [];
    for (let item of keyPath) {
      if (item !== void 0 && item !== null && typeof item !== "string" && item.toString) {
        item = item.toString();
      }
      result.push(valueToKey(extractKey(item, value)));
    }
    return result;
  }
  if (keyPath === "") {
    return value;
  }
  let remainingKeyPath = keyPath;
  let object2 = value;
  while (remainingKeyPath !== null) {
    let identifier2;
    const i2 = remainingKeyPath.indexOf(".");
    if (i2 >= 0) {
      identifier2 = remainingKeyPath.slice(0, i2);
      remainingKeyPath = remainingKeyPath.slice(i2 + 1);
    } else {
      identifier2 = remainingKeyPath;
      remainingKeyPath = null;
    }
    if (object2 === void 0 || object2 === null || !object2.hasOwnProperty(identifier2)) {
      return;
    }
    object2 = object2[identifier2];
  }
  return object2;
};
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var dist = { exports: {} };
(function(module2, exports2) {
  (function(f2) {
    {
      module2.exports = f2();
    }
  })(function() {
    return function() {
      function r2(e2, n2, t3) {
        function o2(i3, f2) {
          if (!n2[i3]) {
            if (!e2[i3]) {
              var c2 = "function" == typeof commonjsRequire && commonjsRequire;
              if (!f2 && c2)
                return c2(i3, true);
              if (u2)
                return u2(i3, true);
              var a2 = new Error("Cannot find module '" + i3 + "'");
              throw a2.code = "MODULE_NOT_FOUND", a2;
            }
            var p2 = n2[i3] = { exports: {} };
            e2[i3][0].call(p2.exports, function(r3) {
              var n3 = e2[i3][1][r3];
              return o2(n3 || r3);
            }, p2, p2.exports, r2, e2, n2, t3);
          }
          return n2[i3].exports;
        }
        for (var u2 = "function" == typeof commonjsRequire && commonjsRequire, i2 = 0; i2 < t3.length; i2++)
          o2(t3[i2]);
        return o2;
      }
      return r2;
    }()({ 1: [function(_dereq_, module3, exports3) {
      var DOMException2 = _dereq_("domexception");
      var Typeson = _dereq_("typeson");
      var structuredCloningThrowing = _dereq_("typeson-registry/dist/presets/structured-cloning-throwing");
      var globalVar = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : Function("return this;")();
      if (!globalVar.DOMException) {
        globalVar.DOMException = DOMException2;
      }
      var TSON = new Typeson().register(structuredCloningThrowing);
      function realisticStructuredClone2(obj) {
        return TSON.revive(TSON.encapsulate(obj));
      }
      module3.exports = realisticStructuredClone2;
    }, { "domexception": 5, "typeson": 8, "typeson-registry/dist/presets/structured-cloning-throwing": 7 }], 2: [function(_dereq_, module3, exports3) {
      var _slicedToArray = function() {
        function sliceIterator(arr, i2) {
          var _arr = [];
          var _n2 = true;
          var _d = false;
          var _e2 = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i.next()).done); _n2 = true) {
              _arr.push(_s.value);
              if (i2 && _arr.length === i2)
                break;
            }
          } catch (err) {
            _d = true;
            _e2 = err;
          } finally {
            try {
              if (!_n2 && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e2;
            }
          }
          return _arr;
        }
        return function(arr, i2) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i2);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var _createClass2 = function() {
        function defineProperties2(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties2(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var legacyErrorCodes = _dereq_("./legacy-error-codes.json");
      var idlUtils = _dereq_("./utils.js");
      exports3.implementation = function() {
        function DOMExceptionImpl(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), message = _ref2[0], name = _ref2[1];
          _classCallCheck(this, DOMExceptionImpl);
          this.name = name;
          this.message = message;
        }
        _createClass2(DOMExceptionImpl, [{
          key: "code",
          get: function get() {
            return legacyErrorCodes[this.name] || 0;
          }
        }]);
        return DOMExceptionImpl;
      }();
      exports3.init = function(impl) {
        if (Error.captureStackTrace) {
          var wrapper = idlUtils.wrapperForImpl(impl);
          Error.captureStackTrace(wrapper, wrapper.constructor);
        }
      };
    }, { "./legacy-error-codes.json": 4, "./utils.js": 6 }], 3: [function(_dereq_, module3, exports3) {
      var conversions = _dereq_("webidl-conversions");
      var utils2 = _dereq_("./utils.js");
      var impl = utils2.implSymbol;
      function DOMException2() {
        var args = [];
        for (var i2 = 0; i2 < arguments.length && i2 < 2; ++i2) {
          args[i2] = arguments[i2];
        }
        if (args[0] !== void 0) {
          args[0] = conversions["DOMString"](args[0], { context: "Failed to construct 'DOMException': parameter 1" });
        } else {
          args[0] = "";
        }
        if (args[1] !== void 0) {
          args[1] = conversions["DOMString"](args[1], { context: "Failed to construct 'DOMException': parameter 2" });
        } else {
          args[1] = "Error";
        }
        iface.setup(this, args);
      }
      Object.defineProperty(DOMException2, "prototype", {
        value: DOMException2.prototype,
        writable: false,
        enumerable: false,
        configurable: false
      });
      Object.defineProperty(DOMException2.prototype, "name", {
        get: function get() {
          return this[impl]["name"];
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(DOMException2.prototype, "message", {
        get: function get() {
          return this[impl]["message"];
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(DOMException2.prototype, "code", {
        get: function get() {
          return this[impl]["code"];
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(DOMException2, "INDEX_SIZE_ERR", {
        value: 1,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INDEX_SIZE_ERR", {
        value: 1,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "DOMSTRING_SIZE_ERR", {
        value: 2,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "DOMSTRING_SIZE_ERR", {
        value: 2,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "HIERARCHY_REQUEST_ERR", {
        value: 3,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "HIERARCHY_REQUEST_ERR", {
        value: 3,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "WRONG_DOCUMENT_ERR", {
        value: 4,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "WRONG_DOCUMENT_ERR", {
        value: 4,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_CHARACTER_ERR", {
        value: 5,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_CHARACTER_ERR", {
        value: 5,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NO_DATA_ALLOWED_ERR", {
        value: 6,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NO_DATA_ALLOWED_ERR", {
        value: 6,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NO_MODIFICATION_ALLOWED_ERR", {
        value: 7,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NO_MODIFICATION_ALLOWED_ERR", {
        value: 7,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NOT_FOUND_ERR", {
        value: 8,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NOT_FOUND_ERR", {
        value: 8,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NOT_SUPPORTED_ERR", {
        value: 9,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NOT_SUPPORTED_ERR", {
        value: 9,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INUSE_ATTRIBUTE_ERR", {
        value: 10,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INUSE_ATTRIBUTE_ERR", {
        value: 10,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_STATE_ERR", {
        value: 11,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_STATE_ERR", {
        value: 11,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "SYNTAX_ERR", {
        value: 12,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "SYNTAX_ERR", {
        value: 12,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_MODIFICATION_ERR", {
        value: 13,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_MODIFICATION_ERR", {
        value: 13,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NAMESPACE_ERR", {
        value: 14,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NAMESPACE_ERR", {
        value: 14,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_ACCESS_ERR", {
        value: 15,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_ACCESS_ERR", {
        value: 15,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "VALIDATION_ERR", {
        value: 16,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "VALIDATION_ERR", {
        value: 16,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "TYPE_MISMATCH_ERR", {
        value: 17,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "TYPE_MISMATCH_ERR", {
        value: 17,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "SECURITY_ERR", {
        value: 18,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "SECURITY_ERR", {
        value: 18,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NETWORK_ERR", {
        value: 19,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NETWORK_ERR", {
        value: 19,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "ABORT_ERR", {
        value: 20,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "ABORT_ERR", {
        value: 20,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "URL_MISMATCH_ERR", {
        value: 21,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "URL_MISMATCH_ERR", {
        value: 21,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "QUOTA_EXCEEDED_ERR", {
        value: 22,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "QUOTA_EXCEEDED_ERR", {
        value: 22,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "TIMEOUT_ERR", {
        value: 23,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "TIMEOUT_ERR", {
        value: 23,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_NODE_TYPE_ERR", {
        value: 24,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_NODE_TYPE_ERR", {
        value: 24,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "DATA_CLONE_ERR", {
        value: 25,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "DATA_CLONE_ERR", {
        value: 25,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, Symbol.toStringTag, {
        value: "DOMException",
        writable: false,
        enumerable: false,
        configurable: true
      });
      var iface = {
        mixedInto: [],
        is: function is3(obj) {
          if (obj) {
            if (obj[impl] instanceof Impl.implementation) {
              return true;
            }
            for (var i2 = 0; i2 < module3.exports.mixedInto.length; ++i2) {
              if (obj instanceof module3.exports.mixedInto[i2]) {
                return true;
              }
            }
          }
          return false;
        },
        isImpl: function isImpl(obj) {
          if (obj) {
            if (obj instanceof Impl.implementation) {
              return true;
            }
            var wrapper = utils2.wrapperForImpl(obj);
            for (var i2 = 0; i2 < module3.exports.mixedInto.length; ++i2) {
              if (wrapper instanceof module3.exports.mixedInto[i2]) {
                return true;
              }
            }
          }
          return false;
        },
        convert: function convert(obj) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$context = _ref.context, context = _ref$context === void 0 ? "The provided value" : _ref$context;
          if (module3.exports.is(obj)) {
            return utils2.implForWrapper(obj);
          }
          throw new TypeError(context + " is not of type 'DOMException'.");
        },
        create: function create2(constructorArgs, privateData) {
          var obj = Object.create(DOMException2.prototype);
          this.setup(obj, constructorArgs, privateData);
          return obj;
        },
        createImpl: function createImpl(constructorArgs, privateData) {
          var obj = Object.create(DOMException2.prototype);
          this.setup(obj, constructorArgs, privateData);
          return utils2.implForWrapper(obj);
        },
        _internalSetup: function _internalSetup(obj) {
        },
        setup: function setup(obj, constructorArgs, privateData) {
          if (!privateData)
            privateData = {};
          privateData.wrapper = obj;
          this._internalSetup(obj);
          Object.defineProperty(obj, impl, {
            value: new Impl.implementation(constructorArgs, privateData),
            writable: false,
            enumerable: false,
            configurable: true
          });
          obj[impl][utils2.wrapperSymbol] = obj;
          if (Impl.init) {
            Impl.init(obj[impl], privateData);
          }
        },
        interface: DOMException2,
        expose: {
          Window: { DOMException: DOMException2 },
          Worker: { DOMException: DOMException2 }
        }
      };
      module3.exports = iface;
      var Impl = _dereq_(".//DOMException-impl.js");
    }, { ".//DOMException-impl.js": 2, "./utils.js": 6, "webidl-conversions": 9 }], 4: [function(_dereq_, module3, exports3) {
      module3.exports = {
        "IndexSizeError": 1,
        "DOMStringSizeError": 2,
        "HierarchyRequestError": 3,
        "WrongDocumentError": 4,
        "InvalidCharacterError": 5,
        "NoDataAllowedError": 6,
        "NoModificationAllowedError": 7,
        "NotFoundError": 8,
        "NotSupportedError": 9,
        "InUseAttributeError": 10,
        "InvalidStateError": 11,
        "SyntaxError": 12,
        "InvalidModificationError": 13,
        "NamespaceError": 14,
        "InvalidAccessError": 15,
        "ValidationError": 16,
        "TypeMismatchError": 17,
        "SecurityError": 18,
        "NetworkError": 19,
        "AbortError": 20,
        "URLMismatchError": 21,
        "QuotaExceededError": 22,
        "TimeoutError": 23,
        "InvalidNodeTypeError": 24,
        "DataCloneError": 25
      };
    }, {}], 5: [function(_dereq_, module3, exports3) {
      module3.exports = _dereq_("./DOMException").interface;
      Object.setPrototypeOf(module3.exports.prototype, Error.prototype);
    }, { "./DOMException": 3 }], 6: [function(_dereq_, module3, exports3) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function isObject3(value) {
        return (typeof value === "undefined" ? "undefined" : _typeof2(value)) === "object" && value !== null || typeof value === "function";
      }
      function getReferenceToBytes(bufferSource) {
        if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {
          return bufferSource;
        }
        if (bufferSource instanceof ArrayBuffer) {
          return Buffer.from(bufferSource);
        }
        return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);
      }
      function getCopyToBytes(bufferSource) {
        return Buffer.from(getReferenceToBytes(bufferSource));
      }
      function mixin(target, source) {
        var keys3 = Object.getOwnPropertyNames(source);
        for (var i2 = 0; i2 < keys3.length; ++i2) {
          if (keys3[i2] in target) {
            continue;
          }
          Object.defineProperty(target, keys3[i2], Object.getOwnPropertyDescriptor(source, keys3[i2]));
        }
      }
      var wrapperSymbol = Symbol("wrapper");
      var implSymbol = Symbol("impl");
      var sameObjectCaches = Symbol("SameObject caches");
      function getSameObject(wrapper, prop, creator) {
        if (!wrapper[sameObjectCaches]) {
          wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
        }
        if (prop in wrapper[sameObjectCaches]) {
          return wrapper[sameObjectCaches][prop];
        }
        wrapper[sameObjectCaches][prop] = creator();
        return wrapper[sameObjectCaches][prop];
      }
      function wrapperForImpl(impl) {
        return impl ? impl[wrapperSymbol] : null;
      }
      function implForWrapper(wrapper) {
        return wrapper ? wrapper[implSymbol] : null;
      }
      function tryWrapperForImpl(impl) {
        var wrapper = wrapperForImpl(impl);
        return wrapper ? wrapper : impl;
      }
      function tryImplForWrapper(wrapper) {
        var impl = implForWrapper(wrapper);
        return impl ? impl : wrapper;
      }
      var iterInternalSymbol = Symbol("internal");
      var IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
      module3.exports = {
        isObject: isObject3,
        getReferenceToBytes,
        getCopyToBytes,
        mixin,
        wrapperSymbol,
        implSymbol,
        getSameObject,
        wrapperForImpl,
        implForWrapper,
        tryWrapperForImpl,
        tryImplForWrapper,
        iterInternalSymbol,
        IteratorPrototype
      };
    }, {}], 7: [function(_dereq_, module3, exports3) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      !function(e2, t3) {
        "object" == (typeof exports3 === "undefined" ? "undefined" : _typeof2(exports3)) && "undefined" != typeof module3 ? module3.exports = t3() : ((e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).Typeson = e2.Typeson || {}, e2.Typeson.presets = e2.Typeson.presets || {}, e2.Typeson.presets.structuredCloningThrowing = t3());
      }(void 0, function() {
        function _typeof$12(e3) {
          return (_typeof$12 = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function(e4) {
            return typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
          })(e3);
        }
        function _classCallCheck$1(e3, t4) {
          if (!(e3 instanceof t4))
            throw new TypeError("Cannot call a class as a function");
        }
        function _defineProperties$1(e3, t4) {
          for (var r3 = 0; r3 < t4.length; r3++) {
            var n3 = t4[r3];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
          }
        }
        function _defineProperty$1(e3, t4, r3) {
          return t4 in e3 ? Object.defineProperty(e3, t4, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t4] = r3, e3;
        }
        function ownKeys$1(e3, t4) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n3 = Object.getOwnPropertySymbols(e3);
            t4 && (n3 = n3.filter(function(t5) {
              return Object.getOwnPropertyDescriptor(e3, t5).enumerable;
            })), r3.push.apply(r3, n3);
          }
          return r3;
        }
        function _toConsumableArray$1(e3) {
          return function _arrayWithoutHoles$1(e4) {
            if (Array.isArray(e4))
              return _arrayLikeToArray$1(e4);
          }(e3) || function _iterableToArray$1(e4) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e4))
              return Array.from(e4);
          }(e3) || function _unsupportedIterableToArray$1(e4, t4) {
            if (!e4)
              return;
            if ("string" == typeof e4)
              return _arrayLikeToArray$1(e4, t4);
            var r3 = Object.prototype.toString.call(e4).slice(8, -1);
            "Object" === r3 && e4.constructor && (r3 = e4.constructor.name);
            if ("Map" === r3 || "Set" === r3)
              return Array.from(e4);
            if ("Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3))
              return _arrayLikeToArray$1(e4, t4);
          }(e3) || function _nonIterableSpread$1() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function _arrayLikeToArray$1(e3, t4) {
          (null == t4 || t4 > e3.length) && (t4 = e3.length);
          for (var r3 = 0, n3 = new Array(t4); r3 < t4; r3++) {
            n3[r3] = e3[r3];
          }
          return n3;
        }
        function _typeof3(e3) {
          return (_typeof3 = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function _typeof4(e4) {
            return typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
          } : function _typeof4(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
          })(e3);
        }
        function _classCallCheck(e3, t4) {
          if (!(e3 instanceof t4))
            throw new TypeError("Cannot call a class as a function");
        }
        function _defineProperties2(e3, t4) {
          for (var r3 = 0; r3 < t4.length; r3++) {
            var n3 = t4[r3];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
          }
        }
        function _defineProperty2(e3, t4, r3) {
          return t4 in e3 ? Object.defineProperty(e3, t4, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t4] = r3, e3;
        }
        function ownKeys2(e3, t4) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n3 = Object.getOwnPropertySymbols(e3);
            t4 && (n3 = n3.filter(function(t5) {
              return Object.getOwnPropertyDescriptor(e3, t5).enumerable;
            })), r3.push.apply(r3, n3);
          }
          return r3;
        }
        function _objectSpread22(e3) {
          for (var t4 = 1; t4 < arguments.length; t4++) {
            var r3 = null != arguments[t4] ? arguments[t4] : {};
            t4 % 2 ? ownKeys2(Object(r3), true).forEach(function(t5) {
              _defineProperty2(e3, t5, r3[t5]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : ownKeys2(Object(r3)).forEach(function(t5) {
              Object.defineProperty(e3, t5, Object.getOwnPropertyDescriptor(r3, t5));
            });
          }
          return e3;
        }
        function _slicedToArray(e3, t4) {
          return function _arrayWithHoles(e4) {
            if (Array.isArray(e4))
              return e4;
          }(e3) || function _iterableToArrayLimit(e4, t5) {
            if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e4)))
              return;
            var r3 = [], n3 = true, i3 = false, o3 = void 0;
            try {
              for (var a3, c3 = e4[Symbol.iterator](); !(n3 = (a3 = c3.next()).done) && (r3.push(a3.value), !t5 || r3.length !== t5); n3 = true) {
              }
            } catch (e5) {
              i3 = true, o3 = e5;
            } finally {
              try {
                n3 || null == c3.return || c3.return();
              } finally {
                if (i3)
                  throw o3;
              }
            }
            return r3;
          }(e3, t4) || _unsupportedIterableToArray(e3, t4) || function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function _toConsumableArray(e3) {
          return function _arrayWithoutHoles(e4) {
            if (Array.isArray(e4))
              return _arrayLikeToArray(e4);
          }(e3) || function _iterableToArray(e4) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e4))
              return Array.from(e4);
          }(e3) || _unsupportedIterableToArray(e3) || function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function _unsupportedIterableToArray(e3, t4) {
          if (e3) {
            if ("string" == typeof e3)
              return _arrayLikeToArray(e3, t4);
            var r3 = Object.prototype.toString.call(e3).slice(8, -1);
            return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? _arrayLikeToArray(e3, t4) : void 0;
          }
        }
        function _arrayLikeToArray(e3, t4) {
          (null == t4 || t4 > e3.length) && (t4 = e3.length);
          for (var r3 = 0, n3 = new Array(t4); r3 < t4; r3++) {
            n3[r3] = e3[r3];
          }
          return n3;
        }
        var e2 = function TypesonPromise(e3) {
          _classCallCheck(this, TypesonPromise), this.p = new Promise(e3);
        };
        e2.__typeson__type__ = "TypesonPromise", "undefined" != typeof Symbol && (e2.prototype[Symbol.toStringTag] = "TypesonPromise"), e2.prototype.then = function(t4, r3) {
          var n3 = this;
          return new e2(function(e3, i3) {
            n3.p.then(function(r4) {
              e3(t4 ? t4(r4) : r4);
            }).catch(function(e4) {
              return r3 ? r3(e4) : Promise.reject(e4);
            }).then(e3, i3);
          });
        }, e2.prototype.catch = function(e3) {
          return this.then(null, e3);
        }, e2.resolve = function(t4) {
          return new e2(function(e3) {
            e3(t4);
          });
        }, e2.reject = function(t4) {
          return new e2(function(e3, r3) {
            r3(t4);
          });
        }, ["all", "race"].forEach(function(t4) {
          e2[t4] = function(r3) {
            return new e2(function(e3, n3) {
              Promise[t4](r3.map(function(e4) {
                return e4 && e4.constructor && "TypesonPromise" === e4.constructor.__typeson__type__ ? e4.p : e4;
              })).then(e3, n3);
            });
          };
        });
        var t3 = {}.toString, r2 = {}.hasOwnProperty, n2 = Object.getPrototypeOf, i2 = r2.toString;
        function isThenable2(e3, t4) {
          return isObject3(e3) && "function" == typeof e3.then && (!t4 || "function" == typeof e3.catch);
        }
        function toStringTag(e3) {
          return t3.call(e3).slice(8, -1);
        }
        function hasConstructorOf(e3, t4) {
          if (!e3 || "object" !== _typeof3(e3))
            return false;
          var o3 = n2(e3);
          if (!o3)
            return null === t4;
          var a3 = r2.call(o3, "constructor") && o3.constructor;
          return "function" != typeof a3 ? null === t4 : t4 === a3 || null !== t4 && i2.call(a3) === i2.call(t4) || "function" == typeof t4 && "string" == typeof a3.__typeson__type__ && a3.__typeson__type__ === t4.__typeson__type__;
        }
        function isPlainObject2(e3) {
          return !(!e3 || "Object" !== toStringTag(e3)) && (!n2(e3) || hasConstructorOf(e3, Object));
        }
        function isObject3(e3) {
          return e3 && "object" === _typeof3(e3);
        }
        function escapeKeyPathComponent(e3) {
          return e3.replace(/~/g, "~0").replace(/\./g, "~1");
        }
        function unescapeKeyPathComponent(e3) {
          return e3.replace(/~1/g, ".").replace(/~0/g, "~");
        }
        function getByKeyPath(e3, t4) {
          if ("" === t4)
            return e3;
          var r3 = t4.indexOf(".");
          if (r3 > -1) {
            var n3 = e3[unescapeKeyPathComponent(t4.slice(0, r3))];
            return void 0 === n3 ? void 0 : getByKeyPath(n3, t4.slice(r3 + 1));
          }
          return e3[unescapeKeyPathComponent(t4)];
        }
        function setAtKeyPath(e3, t4, r3) {
          if ("" === t4)
            return r3;
          var n3 = t4.indexOf(".");
          return n3 > -1 ? setAtKeyPath(e3[unescapeKeyPathComponent(t4.slice(0, n3))], t4.slice(n3 + 1), r3) : (e3[unescapeKeyPathComponent(t4)] = r3, e3);
        }
        function _await(e3, t4, r3) {
          return r3 ? t4 ? t4(e3) : e3 : (e3 && e3.then || (e3 = Promise.resolve(e3)), t4 ? e3.then(t4) : e3);
        }
        var o2 = Object.keys, a2 = Array.isArray, c2 = {}.hasOwnProperty, u2 = ["type", "replaced", "iterateIn", "iterateUnsetNumeric"];
        function _async(e3) {
          return function() {
            for (var t4 = [], r3 = 0; r3 < arguments.length; r3++) {
              t4[r3] = arguments[r3];
            }
            try {
              return Promise.resolve(e3.apply(this, t4));
            } catch (e4) {
              return Promise.reject(e4);
            }
          };
        }
        function nestedPathsFirst(e3, t4) {
          if ("" === e3.keypath)
            return -1;
          var r3 = e3.keypath.match(/\./g) || 0, n3 = t4.keypath.match(/\./g) || 0;
          return r3 && (r3 = r3.length), n3 && (n3 = n3.length), r3 > n3 ? -1 : r3 < n3 ? 1 : e3.keypath < t4.keypath ? -1 : e3.keypath > t4.keypath;
        }
        var s2 = function() {
          function Typeson(e3) {
            _classCallCheck(this, Typeson), this.options = e3, this.plainObjectReplacers = [], this.nonplainObjectReplacers = [], this.revivers = {}, this.types = {};
          }
          return function _createClass2(e3, t4, r3) {
            return t4 && _defineProperties2(e3.prototype, t4), r3 && _defineProperties2(e3, r3), e3;
          }(Typeson, [{ key: "stringify", value: function stringify2(e3, t4, r3, n3) {
            n3 = _objectSpread22(_objectSpread22(_objectSpread22({}, this.options), n3), {}, { stringification: true });
            var i3 = this.encapsulate(e3, null, n3);
            return a2(i3) ? JSON.stringify(i3[0], t4, r3) : i3.then(function(e4) {
              return JSON.stringify(e4, t4, r3);
            });
          } }, { key: "stringifySync", value: function stringifySync(e3, t4, r3, n3) {
            return this.stringify(e3, t4, r3, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, n3), {}, { sync: true }));
          } }, { key: "stringifyAsync", value: function stringifyAsync(e3, t4, r3, n3) {
            return this.stringify(e3, t4, r3, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, n3), {}, { sync: false }));
          } }, { key: "parse", value: function parse2(e3, t4, r3) {
            return r3 = _objectSpread22(_objectSpread22(_objectSpread22({}, this.options), r3), {}, { parse: true }), this.revive(JSON.parse(e3, t4), r3);
          } }, { key: "parseSync", value: function parseSync(e3, t4, r3) {
            return this.parse(e3, t4, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, r3), {}, { sync: true }));
          } }, { key: "parseAsync", value: function parseAsync(e3, t4, r3) {
            return this.parse(e3, t4, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, r3), {}, { sync: false }));
          } }, { key: "specialTypeNames", value: function specialTypeNames(e3, t4) {
            var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return r3.returnTypeNames = true, this.encapsulate(e3, t4, r3);
          } }, { key: "rootTypeName", value: function rootTypeName(e3, t4) {
            var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return r3.iterateNone = true, this.encapsulate(e3, t4, r3);
          } }, { key: "encapsulate", value: function encapsulate(t4, r3, n3) {
            var i3 = _async(function(t5, r4) {
              return _await(Promise.all(r4.map(function(e3) {
                return e3[1].p;
              })), function(n4) {
                return _await(Promise.all(n4.map(_async(function(n5) {
                  var o3 = false, a3 = [], c3 = _slicedToArray(r4.splice(0, 1), 1), u3 = _slicedToArray(c3[0], 7), s4 = u3[0], f4 = u3[2], l4 = u3[3], p4 = u3[4], y4 = u3[5], v4 = u3[6], b4 = _encapsulate(s4, n5, f4, l4, a3, true, v4), d4 = hasConstructorOf(b4, e2);
                  return function _invoke(e3, t6) {
                    var r5 = e3();
                    return r5 && r5.then ? r5.then(t6) : t6(r5);
                  }(function() {
                    if (s4 && d4)
                      return _await(b4.p, function(e3) {
                        return p4[y4] = e3, o3 = true, i3(t5, a3);
                      });
                  }, function(e3) {
                    return o3 ? e3 : (s4 ? p4[y4] = b4 : t5 = d4 ? b4.p : b4, i3(t5, a3));
                  });
                }))), function() {
                  return t5;
                });
              });
            }), s3 = (n3 = _objectSpread22(_objectSpread22({ sync: true }, this.options), n3)).sync, f3 = this, l3 = {}, p3 = [], y3 = [], v3 = [], b3 = !("cyclic" in n3) || n3.cyclic, d3 = n3.encapsulateObserver, h3 = _encapsulate("", t4, b3, r3 || {}, v3);
            function finish(e3) {
              var t5 = Object.values(l3);
              if (n3.iterateNone)
                return t5.length ? t5[0] : Typeson.getJSONType(e3);
              if (t5.length) {
                if (n3.returnTypeNames)
                  return _toConsumableArray(new Set(t5));
                e3 && isPlainObject2(e3) && !c2.call(e3, "$types") ? e3.$types = l3 : e3 = { $: e3, $types: { $: l3 } };
              } else
                isObject3(e3) && c2.call(e3, "$types") && (e3 = { $: e3, $types: true });
              return !n3.returnTypeNames && e3;
            }
            function _adaptBuiltinStateObjectProperties(e3, t5, r4) {
              Object.assign(e3, t5);
              var n4 = u2.map(function(t6) {
                var r5 = e3[t6];
                return delete e3[t6], r5;
              });
              r4(), u2.forEach(function(t6, r5) {
                e3[t6] = n4[r5];
              });
            }
            function _encapsulate(t5, r4, i4, u3, s4, v4, b4) {
              var h4, g3 = {}, m3 = _typeof3(r4), O3 = d3 ? function(n4) {
                var o3 = b4 || u3.type || Typeson.getJSONType(r4);
                d3(Object.assign(n4 || g3, { keypath: t5, value: r4, cyclic: i4, stateObj: u3, promisesData: s4, resolvingTypesonPromise: v4, awaitingTypesonPromise: hasConstructorOf(r4, e2) }, { type: o3 }));
              } : null;
              if (["string", "boolean", "number", "undefined"].includes(m3))
                return void 0 === r4 || Number.isNaN(r4) || r4 === Number.NEGATIVE_INFINITY || r4 === Number.POSITIVE_INFINITY ? (h4 = u3.replaced ? r4 : replace2(t5, r4, u3, s4, false, v4, O3)) !== r4 && (g3 = { replaced: h4 }) : h4 = r4, O3 && O3(), h4;
              if (null === r4)
                return O3 && O3(), r4;
              if (i4 && !u3.iterateIn && !u3.iterateUnsetNumeric && r4 && "object" === _typeof3(r4)) {
                var _3 = p3.indexOf(r4);
                if (!(_3 < 0))
                  return l3[t5] = "#", O3 && O3({ cyclicKeypath: y3[_3] }), "#" + y3[_3];
                true === i4 && (p3.push(r4), y3.push(t5));
              }
              var j3, S3 = isPlainObject2(r4), T3 = a2(r4), w3 = (S3 || T3) && (!f3.plainObjectReplacers.length || u3.replaced) || u3.iterateIn ? r4 : replace2(t5, r4, u3, s4, S3 || T3, null, O3);
              if (w3 !== r4 ? (h4 = w3, g3 = { replaced: w3 }) : "" === t5 && hasConstructorOf(r4, e2) ? (s4.push([t5, r4, i4, u3, void 0, void 0, u3.type]), h4 = r4) : T3 && "object" !== u3.iterateIn || "array" === u3.iterateIn ? (j3 = new Array(r4.length), g3 = { clone: j3 }) : (["function", "symbol"].includes(_typeof3(r4)) || "toJSON" in r4 || hasConstructorOf(r4, e2) || hasConstructorOf(r4, Promise) || hasConstructorOf(r4, ArrayBuffer)) && !S3 && "object" !== u3.iterateIn ? h4 = r4 : (j3 = {}, u3.addLength && (j3.length = r4.length), g3 = { clone: j3 }), O3 && O3(), n3.iterateNone)
                return j3 || h4;
              if (!j3)
                return h4;
              if (u3.iterateIn) {
                var A3 = function _loop(n4) {
                  var o3 = { ownKeys: c2.call(r4, n4) };
                  _adaptBuiltinStateObjectProperties(u3, o3, function() {
                    var o4 = t5 + (t5 ? "." : "") + escapeKeyPathComponent(n4), a3 = _encapsulate(o4, r4[n4], Boolean(i4), u3, s4, v4);
                    hasConstructorOf(a3, e2) ? s4.push([o4, a3, Boolean(i4), u3, j3, n4, u3.type]) : void 0 !== a3 && (j3[n4] = a3);
                  });
                };
                for (var P3 in r4) {
                  A3(P3);
                }
                O3 && O3({ endIterateIn: true, end: true });
              } else
                o2(r4).forEach(function(n4) {
                  var o3 = t5 + (t5 ? "." : "") + escapeKeyPathComponent(n4);
                  _adaptBuiltinStateObjectProperties(u3, { ownKeys: true }, function() {
                    var t6 = _encapsulate(o3, r4[n4], Boolean(i4), u3, s4, v4);
                    hasConstructorOf(t6, e2) ? s4.push([o3, t6, Boolean(i4), u3, j3, n4, u3.type]) : void 0 !== t6 && (j3[n4] = t6);
                  });
                }), O3 && O3({ endIterateOwn: true, end: true });
              if (u3.iterateUnsetNumeric) {
                for (var C3 = r4.length, I3 = function _loop2(n4) {
                  if (!(n4 in r4)) {
                    var o3 = t5 + (t5 ? "." : "") + n4;
                    _adaptBuiltinStateObjectProperties(u3, { ownKeys: false }, function() {
                      var t6 = _encapsulate(o3, void 0, Boolean(i4), u3, s4, v4);
                      hasConstructorOf(t6, e2) ? s4.push([o3, t6, Boolean(i4), u3, j3, n4, u3.type]) : void 0 !== t6 && (j3[n4] = t6);
                    });
                  }
                }, N3 = 0; N3 < C3; N3++) {
                  I3(N3);
                }
                O3 && O3({ endIterateUnsetNumeric: true, end: true });
              }
              return j3;
            }
            function replace2(e3, t5, r4, n4, i4, o3, a3) {
              for (var c3 = i4 ? f3.plainObjectReplacers : f3.nonplainObjectReplacers, u3 = c3.length; u3--; ) {
                var p4 = c3[u3];
                if (p4.test(t5, r4)) {
                  var y4 = p4.type;
                  if (f3.revivers[y4]) {
                    var v4 = l3[e3];
                    l3[e3] = v4 ? [y4].concat(v4) : y4;
                  }
                  return Object.assign(r4, { type: y4, replaced: true }), !s3 && p4.replaceAsync || p4.replace ? (a3 && a3({ replacing: true }), _encapsulate(e3, p4[s3 || !p4.replaceAsync ? "replace" : "replaceAsync"](t5, r4), b3 && "readonly", r4, n4, o3, y4)) : (a3 && a3({ typeDetected: true }), _encapsulate(e3, t5, b3 && "readonly", r4, n4, o3, y4));
                }
              }
              return t5;
            }
            return v3.length ? s3 && n3.throwOnBadSyncType ? function() {
              throw new TypeError("Sync method requested but async result obtained");
            }() : Promise.resolve(i3(h3, v3)).then(finish) : !s3 && n3.throwOnBadSyncType ? function() {
              throw new TypeError("Async method requested but sync result obtained");
            }() : n3.stringification && s3 ? [finish(h3)] : s3 ? finish(h3) : Promise.resolve(finish(h3));
          } }, { key: "encapsulateSync", value: function encapsulateSync(e3, t4, r3) {
            return this.encapsulate(e3, t4, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, r3), {}, { sync: true }));
          } }, { key: "encapsulateAsync", value: function encapsulateAsync(e3, t4, r3) {
            return this.encapsulate(e3, t4, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, r3), {}, { sync: false }));
          } }, { key: "revive", value: function revive(t4, r3) {
            var n3 = t4 && t4.$types;
            if (!n3)
              return t4;
            if (true === n3)
              return t4.$;
            var i3 = (r3 = _objectSpread22(_objectSpread22({ sync: true }, this.options), r3)).sync, c3 = [], u3 = {}, s3 = true;
            n3.$ && isPlainObject2(n3.$) && (t4 = t4.$, n3 = n3.$, s3 = false);
            var l3 = this;
            function executeReviver(e3, t5) {
              var r4 = _slicedToArray(l3.revivers[e3] || [], 1)[0];
              if (!r4)
                throw new Error("Unregistered type: " + e3);
              return i3 && !("revive" in r4) ? t5 : r4[i3 && r4.revive ? "revive" : !i3 && r4.reviveAsync ? "reviveAsync" : "revive"](t5, u3);
            }
            var p3 = [];
            function checkUndefined(e3) {
              return hasConstructorOf(e3, f2) ? void 0 : e3;
            }
            var y3, v3 = function revivePlainObjects() {
              var r4 = [];
              if (Object.entries(n3).forEach(function(e3) {
                var t5 = _slicedToArray(e3, 2), i4 = t5[0], o3 = t5[1];
                "#" !== o3 && [].concat(o3).forEach(function(e4) {
                  _slicedToArray(l3.revivers[e4] || [null, {}], 2)[1].plain && (r4.push({ keypath: i4, type: e4 }), delete n3[i4]);
                });
              }), r4.length)
                return r4.sort(nestedPathsFirst).reduce(function reducer(r5, n4) {
                  var i4 = n4.keypath, o3 = n4.type;
                  if (isThenable2(r5))
                    return r5.then(function(e3) {
                      return reducer(e3, { keypath: i4, type: o3 });
                    });
                  var a3 = getByKeyPath(t4, i4);
                  if (hasConstructorOf(a3 = executeReviver(o3, a3), e2))
                    return a3.then(function(e3) {
                      var r6 = setAtKeyPath(t4, i4, e3);
                      r6 === e3 && (t4 = r6);
                    });
                  var c4 = setAtKeyPath(t4, i4, a3);
                  c4 === a3 && (t4 = c4);
                }, void 0);
            }();
            return hasConstructorOf(v3, e2) ? y3 = v3.then(function() {
              return t4;
            }) : (y3 = function _revive(t5, r4, i4, u4, l4) {
              if (!s3 || "$types" !== t5) {
                var y4 = n3[t5], v4 = a2(r4);
                if (v4 || isPlainObject2(r4)) {
                  var b3 = v4 ? new Array(r4.length) : {};
                  for (o2(r4).forEach(function(n4) {
                    var o3 = _revive(t5 + (t5 ? "." : "") + escapeKeyPathComponent(n4), r4[n4], i4 || b3, b3, n4), a3 = function set(e3) {
                      return hasConstructorOf(e3, f2) ? b3[n4] = void 0 : void 0 !== e3 && (b3[n4] = e3), e3;
                    };
                    hasConstructorOf(o3, e2) ? p3.push(o3.then(function(e3) {
                      return a3(e3);
                    })) : a3(o3);
                  }), r4 = b3; c3.length; ) {
                    var d3 = _slicedToArray(c3[0], 4), h3 = d3[0], g3 = d3[1], m3 = d3[2], O3 = d3[3], _3 = getByKeyPath(h3, g3);
                    if (void 0 === _3)
                      break;
                    m3[O3] = _3, c3.splice(0, 1);
                  }
                }
                if (!y4)
                  return r4;
                if ("#" === y4) {
                  var j3 = getByKeyPath(i4, r4.slice(1));
                  return void 0 === j3 && c3.push([i4, r4.slice(1), u4, l4]), j3;
                }
                return [].concat(y4).reduce(function reducer(t6, r5) {
                  return hasConstructorOf(t6, e2) ? t6.then(function(e3) {
                    return reducer(e3, r5);
                  }) : executeReviver(r5, t6);
                }, r4);
              }
            }("", t4, null), p3.length && (y3 = e2.resolve(y3).then(function(t5) {
              return e2.all([t5].concat(p3));
            }).then(function(e3) {
              return _slicedToArray(e3, 1)[0];
            }))), isThenable2(y3) ? i3 && r3.throwOnBadSyncType ? function() {
              throw new TypeError("Sync method requested but async result obtained");
            }() : hasConstructorOf(y3, e2) ? y3.p.then(checkUndefined) : y3 : !i3 && r3.throwOnBadSyncType ? function() {
              throw new TypeError("Async method requested but sync result obtained");
            }() : i3 ? checkUndefined(y3) : Promise.resolve(checkUndefined(y3));
          } }, { key: "reviveSync", value: function reviveSync(e3, t4) {
            return this.revive(e3, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, t4), {}, { sync: true }));
          } }, { key: "reviveAsync", value: function reviveAsync(e3, t4) {
            return this.revive(e3, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, t4), {}, { sync: false }));
          } }, { key: "register", value: function register(e3, t4) {
            return t4 = t4 || {}, [].concat(e3).forEach(function R2(e4) {
              var r3 = this;
              if (a2(e4))
                return e4.map(function(e5) {
                  return R2.call(r3, e5);
                });
              e4 && o2(e4).forEach(function(r4) {
                if ("#" === r4)
                  throw new TypeError("# cannot be used as a type name as it is reserved for cyclic objects");
                if (Typeson.JSON_TYPES.includes(r4))
                  throw new TypeError("Plain JSON object types are reserved as type names");
                var n3 = e4[r4], i3 = n3 && n3.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers, o3 = i3.filter(function(e5) {
                  return e5.type === r4;
                });
                if (o3.length && (i3.splice(i3.indexOf(o3[0]), 1), delete this.revivers[r4], delete this.types[r4]), "function" == typeof n3) {
                  var c3 = n3;
                  n3 = { test: function test2(e5) {
                    return e5 && e5.constructor === c3;
                  }, replace: function replace2(e5) {
                    return _objectSpread22({}, e5);
                  }, revive: function revive(e5) {
                    return Object.assign(Object.create(c3.prototype), e5);
                  } };
                } else if (a2(n3)) {
                  var u3 = _slicedToArray(n3, 3);
                  n3 = { test: u3[0], replace: u3[1], revive: u3[2] };
                }
                if (n3 && n3.test) {
                  var s3 = { type: r4, test: n3.test.bind(n3) };
                  n3.replace && (s3.replace = n3.replace.bind(n3)), n3.replaceAsync && (s3.replaceAsync = n3.replaceAsync.bind(n3));
                  var f3 = "number" == typeof t4.fallback ? t4.fallback : t4.fallback ? 0 : Number.POSITIVE_INFINITY;
                  if (n3.testPlainObjects ? this.plainObjectReplacers.splice(f3, 0, s3) : this.nonplainObjectReplacers.splice(f3, 0, s3), n3.revive || n3.reviveAsync) {
                    var l3 = {};
                    n3.revive && (l3.revive = n3.revive.bind(n3)), n3.reviveAsync && (l3.reviveAsync = n3.reviveAsync.bind(n3)), this.revivers[r4] = [l3, { plain: n3.testPlainObjects }];
                  }
                  this.types[r4] = n3;
                }
              }, this);
            }, this), this;
          } }]), Typeson;
        }(), f2 = function Undefined() {
          _classCallCheck(this, Undefined);
        };
        f2.__typeson__type__ = "TypesonUndefined", s2.Undefined = f2, s2.Promise = e2, s2.isThenable = isThenable2, s2.toStringTag = toStringTag, s2.hasConstructorOf = hasConstructorOf, s2.isObject = isObject3, s2.isPlainObject = isPlainObject2, s2.isUserObject = function isUserObject(e3) {
          if (!e3 || "Object" !== toStringTag(e3))
            return false;
          var t4 = n2(e3);
          return !t4 || hasConstructorOf(e3, Object) || isUserObject(t4);
        }, s2.escapeKeyPathComponent = escapeKeyPathComponent, s2.unescapeKeyPathComponent = unescapeKeyPathComponent, s2.getByKeyPath = getByKeyPath, s2.getJSONType = function getJSONType(e3) {
          return null === e3 ? "null" : Array.isArray(e3) ? "array" : _typeof3(e3);
        }, s2.JSON_TYPES = ["null", "boolean", "number", "string", "array", "object"];
        for (var l2 = { userObject: { test: function test2(e3, t4) {
          return s2.isUserObject(e3);
        }, replace: function replace2(e3) {
          return function _objectSpread2$1(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var r3 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? ownKeys$1(Object(r3), true).forEach(function(t5) {
                _defineProperty$1(e4, t5, r3[t5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r3)) : ownKeys$1(Object(r3)).forEach(function(t5) {
                Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(r3, t5));
              });
            }
            return e4;
          }({}, e3);
        }, revive: function revive(e3) {
          return e3;
        } } }, p2 = [{ arrayNonindexKeys: { testPlainObjects: true, test: function test2(e3, t4) {
          return !!Array.isArray(e3) && (Object.keys(e3).some(function(e4) {
            return String(Number.parseInt(e4)) !== e4;
          }) && (t4.iterateIn = "object", t4.addLength = true), true);
        }, replace: function replace2(e3, t4) {
          return t4.iterateUnsetNumeric = true, e3;
        }, revive: function revive(e3) {
          if (Array.isArray(e3))
            return e3;
          var t4 = [];
          return Object.keys(e3).forEach(function(r3) {
            var n3 = e3[r3];
            t4[r3] = n3;
          }), t4;
        } } }, { sparseUndefined: { test: function test2(e3, t4) {
          return void 0 === e3 && false === t4.ownKeys;
        }, replace: function replace2(e3) {
          return 0;
        }, revive: function revive(e3) {
        } } }], y2 = { undef: { test: function test2(e3, t4) {
          return void 0 === e3 && (t4.ownKeys || !("ownKeys" in t4));
        }, replace: function replace2(e3) {
          return 0;
        }, revive: function revive(e3) {
          return new s2.Undefined();
        } } }, v2 = { StringObject: { test: function test2(e3) {
          return "String" === s2.toStringTag(e3) && "object" === _typeof$12(e3);
        }, replace: function replace2(e3) {
          return String(e3);
        }, revive: function revive(e3) {
          return new String(e3);
        } }, BooleanObject: { test: function test2(e3) {
          return "Boolean" === s2.toStringTag(e3) && "object" === _typeof$12(e3);
        }, replace: function replace2(e3) {
          return Boolean(e3);
        }, revive: function revive(e3) {
          return new Boolean(e3);
        } }, NumberObject: { test: function test2(e3) {
          return "Number" === s2.toStringTag(e3) && "object" === _typeof$12(e3);
        }, replace: function replace2(e3) {
          return Number(e3);
        }, revive: function revive(e3) {
          return new Number(e3);
        } } }, b2 = [{ nan: { test: function test2(e3) {
          return Number.isNaN(e3);
        }, replace: function replace2(e3) {
          return "NaN";
        }, revive: function revive(e3) {
          return Number.NaN;
        } } }, { infinity: { test: function test2(e3) {
          return e3 === Number.POSITIVE_INFINITY;
        }, replace: function replace2(e3) {
          return "Infinity";
        }, revive: function revive(e3) {
          return Number.POSITIVE_INFINITY;
        } } }, { negativeInfinity: { test: function test2(e3) {
          return e3 === Number.NEGATIVE_INFINITY;
        }, replace: function replace2(e3) {
          return "-Infinity";
        }, revive: function revive(e3) {
          return Number.NEGATIVE_INFINITY;
        } } }], d2 = { date: { test: function test2(e3) {
          return "Date" === s2.toStringTag(e3);
        }, replace: function replace2(e3) {
          var t4 = e3.getTime();
          return Number.isNaN(t4) ? "NaN" : t4;
        }, revive: function revive(e3) {
          return "NaN" === e3 ? new Date(Number.NaN) : new Date(e3);
        } } }, h2 = { regexp: { test: function test2(e3) {
          return "RegExp" === s2.toStringTag(e3);
        }, replace: function replace2(e3) {
          return { source: e3.source, flags: (e3.global ? "g" : "") + (e3.ignoreCase ? "i" : "") + (e3.multiline ? "m" : "") + (e3.sticky ? "y" : "") + (e3.unicode ? "u" : "") };
        }, revive: function revive(e3) {
          var t4 = e3.source, r3 = e3.flags;
          return new RegExp(t4, r3);
        } } }, g2 = { map: { test: function test2(e3) {
          return "Map" === s2.toStringTag(e3);
        }, replace: function replace2(e3) {
          return _toConsumableArray$1(e3.entries());
        }, revive: function revive(e3) {
          return new Map(e3);
        } } }, m2 = { set: { test: function test2(e3) {
          return "Set" === s2.toStringTag(e3);
        }, replace: function replace2(e3) {
          return _toConsumableArray$1(e3.values());
        }, revive: function revive(e3) {
          return new Set(e3);
        } } }, O2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", _2 = new Uint8Array(256), j2 = 0; j2 < O2.length; j2++) {
          _2[O2.charCodeAt(j2)] = j2;
        }
        var S2 = function encode2(e3, t4, r3) {
          null == r3 && (r3 = e3.byteLength);
          for (var n3 = new Uint8Array(e3, t4 || 0, r3), i3 = n3.length, o3 = "", a3 = 0; a3 < i3; a3 += 3) {
            o3 += O2[n3[a3] >> 2], o3 += O2[(3 & n3[a3]) << 4 | n3[a3 + 1] >> 4], o3 += O2[(15 & n3[a3 + 1]) << 2 | n3[a3 + 2] >> 6], o3 += O2[63 & n3[a3 + 2]];
          }
          return i3 % 3 == 2 ? o3 = o3.slice(0, -1) + "=" : i3 % 3 == 1 && (o3 = o3.slice(0, -2) + "=="), o3;
        }, T2 = function decode2(e3) {
          var t4, r3, n3, i3, o3 = e3.length, a3 = 0.75 * e3.length, c3 = 0;
          "=" === e3[e3.length - 1] && (a3--, "=" === e3[e3.length - 2] && a3--);
          for (var u3 = new ArrayBuffer(a3), s3 = new Uint8Array(u3), f3 = 0; f3 < o3; f3 += 4) {
            t4 = _2[e3.charCodeAt(f3)], r3 = _2[e3.charCodeAt(f3 + 1)], n3 = _2[e3.charCodeAt(f3 + 2)], i3 = _2[e3.charCodeAt(f3 + 3)], s3[c3++] = t4 << 2 | r3 >> 4, s3[c3++] = (15 & r3) << 4 | n3 >> 2, s3[c3++] = (3 & n3) << 6 | 63 & i3;
          }
          return u3;
        }, w2 = { arraybuffer: { test: function test2(e3) {
          return "ArrayBuffer" === s2.toStringTag(e3);
        }, replace: function replace2(e3, t4) {
          t4.buffers || (t4.buffers = []);
          var r3 = t4.buffers.indexOf(e3);
          return r3 > -1 ? { index: r3 } : (t4.buffers.push(e3), S2(e3));
        }, revive: function revive(e3, t4) {
          if (t4.buffers || (t4.buffers = []), "object" === _typeof$12(e3))
            return t4.buffers[e3.index];
          var r3 = T2(e3);
          return t4.buffers.push(r3), r3;
        } } }, A2 = "undefined" == typeof self ? commonjsGlobal : self, P2 = {};
        ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"].forEach(function(e3) {
          var t4 = e3, r3 = A2[t4];
          r3 && (P2[e3.toLowerCase()] = { test: function test2(e4) {
            return s2.toStringTag(e4) === t4;
          }, replace: function replace2(e4, t5) {
            var r4 = e4.buffer, n3 = e4.byteOffset, i3 = e4.length;
            t5.buffers || (t5.buffers = []);
            var o3 = t5.buffers.indexOf(r4);
            return o3 > -1 ? { index: o3, byteOffset: n3, length: i3 } : (t5.buffers.push(r4), { encoded: S2(r4), byteOffset: n3, length: i3 });
          }, revive: function revive(e4, t5) {
            t5.buffers || (t5.buffers = []);
            var n3, i3 = e4.byteOffset, o3 = e4.length, a3 = e4.encoded, c3 = e4.index;
            return "index" in e4 ? n3 = t5.buffers[c3] : (n3 = T2(a3), t5.buffers.push(n3)), new r3(n3, i3, o3);
          } });
        });
        var C2 = { dataview: { test: function test2(e3) {
          return "DataView" === s2.toStringTag(e3);
        }, replace: function replace2(e3, t4) {
          var r3 = e3.buffer, n3 = e3.byteOffset, i3 = e3.byteLength;
          t4.buffers || (t4.buffers = []);
          var o3 = t4.buffers.indexOf(r3);
          return o3 > -1 ? { index: o3, byteOffset: n3, byteLength: i3 } : (t4.buffers.push(r3), { encoded: S2(r3), byteOffset: n3, byteLength: i3 });
        }, revive: function revive(e3, t4) {
          t4.buffers || (t4.buffers = []);
          var r3, n3 = e3.byteOffset, i3 = e3.byteLength, o3 = e3.encoded, a3 = e3.index;
          return "index" in e3 ? r3 = t4.buffers[a3] : (r3 = T2(o3), t4.buffers.push(r3)), new DataView(r3, n3, i3);
        } } }, I2 = { IntlCollator: { test: function test2(e3) {
          return s2.hasConstructorOf(e3, Intl.Collator);
        }, replace: function replace2(e3) {
          return e3.resolvedOptions();
        }, revive: function revive(e3) {
          return new Intl.Collator(e3.locale, e3);
        } }, IntlDateTimeFormat: { test: function test2(e3) {
          return s2.hasConstructorOf(e3, Intl.DateTimeFormat);
        }, replace: function replace2(e3) {
          return e3.resolvedOptions();
        }, revive: function revive(e3) {
          return new Intl.DateTimeFormat(e3.locale, e3);
        } }, IntlNumberFormat: { test: function test2(e3) {
          return s2.hasConstructorOf(e3, Intl.NumberFormat);
        }, replace: function replace2(e3) {
          return e3.resolvedOptions();
        }, revive: function revive(e3) {
          return new Intl.NumberFormat(e3.locale, e3);
        } } };
        function string2arraybuffer(e3) {
          for (var t4 = new Uint8Array(e3.length), r3 = 0; r3 < e3.length; r3++) {
            t4[r3] = e3.charCodeAt(r3);
          }
          return t4.buffer;
        }
        var N2 = { file: { test: function test2(e3) {
          return "File" === s2.toStringTag(e3);
        }, replace: function replace2(e3) {
          var t4 = new XMLHttpRequest();
          if (t4.overrideMimeType("text/plain; charset=x-user-defined"), t4.open("GET", URL.createObjectURL(e3), false), t4.send(), 200 !== t4.status && 0 !== t4.status)
            throw new Error("Bad File access: " + t4.status);
          return { type: e3.type, stringContents: t4.responseText, name: e3.name, lastModified: e3.lastModified };
        }, revive: function revive(e3) {
          var t4 = e3.name, r3 = e3.type, n3 = e3.stringContents, i3 = e3.lastModified;
          return new File([string2arraybuffer(n3)], t4, { type: r3, lastModified: i3 });
        }, replaceAsync: function replaceAsync(e3) {
          return new s2.Promise(function(t4, r3) {
            var n3 = new FileReader();
            n3.addEventListener("load", function() {
              t4({ type: e3.type, stringContents: n3.result, name: e3.name, lastModified: e3.lastModified });
            }), n3.addEventListener("error", function() {
              r3(n3.error);
            }), n3.readAsBinaryString(e3);
          });
        } } }, k2 = { bigint: { test: function test2(e3) {
          return "bigint" == typeof e3;
        }, replace: function replace2(e3) {
          return String(e3);
        }, revive: function revive(e3) {
          return BigInt(e3);
        } } }, E2 = { bigintObject: { test: function test2(e3) {
          return "object" === _typeof$12(e3) && s2.hasConstructorOf(e3, BigInt);
        }, replace: function replace2(e3) {
          return String(e3);
        }, revive: function revive(e3) {
          return new Object(BigInt(e3));
        } } }, B3 = { cryptokey: { test: function test2(e3) {
          return "CryptoKey" === s2.toStringTag(e3) && e3.extractable;
        }, replaceAsync: function replaceAsync(e3) {
          return new s2.Promise(function(t4, r3) {
            crypto.subtle.exportKey("jwk", e3).catch(function(e4) {
              r3(e4);
            }).then(function(r4) {
              t4({ jwk: r4, algorithm: e3.algorithm, usages: e3.usages });
            });
          });
        }, revive: function revive(e3) {
          var t4 = e3.jwk, r3 = e3.algorithm, n3 = e3.usages;
          return crypto.subtle.importKey("jwk", t4, r3, true, n3);
        } } };
        return [l2, y2, p2, v2, b2, d2, h2, { imagedata: { test: function test2(e3) {
          return "ImageData" === s2.toStringTag(e3);
        }, replace: function replace2(e3) {
          return { array: _toConsumableArray$1(e3.data), width: e3.width, height: e3.height };
        }, revive: function revive(e3) {
          return new ImageData(new Uint8ClampedArray(e3.array), e3.width, e3.height);
        } } }, { imagebitmap: { test: function test2(e3) {
          return "ImageBitmap" === s2.toStringTag(e3) || e3 && e3.dataset && "ImageBitmap" === e3.dataset.toStringTag;
        }, replace: function replace2(e3) {
          var t4 = document.createElement("canvas");
          return t4.getContext("2d").drawImage(e3, 0, 0), t4.toDataURL();
        }, revive: function revive(e3) {
          var t4 = document.createElement("canvas"), r3 = t4.getContext("2d"), n3 = document.createElement("img");
          return n3.addEventListener("load", function() {
            r3.drawImage(n3, 0, 0);
          }), n3.src = e3, t4;
        }, reviveAsync: function reviveAsync(e3) {
          var t4 = document.createElement("canvas"), r3 = t4.getContext("2d"), n3 = document.createElement("img");
          return n3.addEventListener("load", function() {
            r3.drawImage(n3, 0, 0);
          }), n3.src = e3, createImageBitmap(t4);
        } } }, N2, { file: N2.file, filelist: { test: function test2(e3) {
          return "FileList" === s2.toStringTag(e3);
        }, replace: function replace2(e3) {
          for (var t4 = [], r3 = 0; r3 < e3.length; r3++) {
            t4[r3] = e3.item(r3);
          }
          return t4;
        }, revive: function revive(e3) {
          return new (function() {
            function FileList() {
              _classCallCheck$1(this, FileList), this._files = arguments[0], this.length = this._files.length;
            }
            return function _createClass$1(e4, t4, r3) {
              return t4 && _defineProperties$1(e4.prototype, t4), r3 && _defineProperties$1(e4, r3), e4;
            }(FileList, [{ key: "item", value: function item(e4) {
              return this._files[e4];
            } }, { key: Symbol.toStringTag, get: function get() {
              return "FileList";
            } }]), FileList;
          }())(e3);
        } } }, { blob: { test: function test2(e3) {
          return "Blob" === s2.toStringTag(e3);
        }, replace: function replace2(e3) {
          var t4 = new XMLHttpRequest();
          if (t4.overrideMimeType("text/plain; charset=x-user-defined"), t4.open("GET", URL.createObjectURL(e3), false), t4.send(), 200 !== t4.status && 0 !== t4.status)
            throw new Error("Bad Blob access: " + t4.status);
          return { type: e3.type, stringContents: t4.responseText };
        }, revive: function revive(e3) {
          var t4 = e3.type, r3 = e3.stringContents;
          return new Blob([string2arraybuffer(r3)], { type: t4 });
        }, replaceAsync: function replaceAsync(e3) {
          return new s2.Promise(function(t4, r3) {
            var n3 = new FileReader();
            n3.addEventListener("load", function() {
              t4({ type: e3.type, stringContents: n3.result });
            }), n3.addEventListener("error", function() {
              r3(n3.error);
            }), n3.readAsBinaryString(e3);
          });
        } } }].concat("function" == typeof Map ? g2 : [], "function" == typeof Set ? m2 : [], "function" == typeof ArrayBuffer ? w2 : [], "function" == typeof Uint8Array ? P2 : [], "function" == typeof DataView ? C2 : [], "undefined" != typeof Intl ? I2 : [], "undefined" != typeof crypto ? B3 : [], "undefined" != typeof BigInt ? [k2, E2] : []).concat({ checkDataCloneException: { test: function test2(e3) {
          var t4 = {}.toString.call(e3).slice(8, -1);
          if (["symbol", "function"].includes(_typeof$12(e3)) || ["Arguments", "Module", "Error", "Promise", "WeakMap", "WeakSet", "Event", "MessageChannel"].includes(t4) || e3 && "object" === _typeof$12(e3) && "number" == typeof e3.nodeType && "function" == typeof e3.insertBefore)
            throw new DOMException("The object cannot be cloned.", "DataCloneError");
          return false;
        } } });
      });
    }, {}], 8: [function(_dereq_, module3, exports3) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _typeof3(e3) {
        return (_typeof3 = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function(e4) {
          return typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
        })(e3);
      }
      function _classCallCheck(e3, t4) {
        if (!(e3 instanceof t4))
          throw new TypeError("Cannot call a class as a function");
      }
      function _defineProperties2(e3, t4) {
        for (var r3 = 0; r3 < t4.length; r3++) {
          var n3 = t4[r3];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
        }
      }
      function _defineProperty2(e3, t4, r3) {
        return t4 in e3 ? Object.defineProperty(e3, t4, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t4] = r3, e3;
      }
      function ownKeys2(e3, t4) {
        var r3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e3);
          t4 && (n3 = n3.filter(function(t5) {
            return Object.getOwnPropertyDescriptor(e3, t5).enumerable;
          })), r3.push.apply(r3, n3);
        }
        return r3;
      }
      function _objectSpread22(e3) {
        for (var t4 = 1; t4 < arguments.length; t4++) {
          var r3 = null != arguments[t4] ? arguments[t4] : {};
          t4 % 2 ? ownKeys2(Object(r3), true).forEach(function(t5) {
            _defineProperty2(e3, t5, r3[t5]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : ownKeys2(Object(r3)).forEach(function(t5) {
            Object.defineProperty(e3, t5, Object.getOwnPropertyDescriptor(r3, t5));
          });
        }
        return e3;
      }
      function _slicedToArray(e3, t4) {
        return function _arrayWithHoles(e4) {
          if (Array.isArray(e4))
            return e4;
        }(e3) || function _iterableToArrayLimit(e4, t5) {
          if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e4)))
            return;
          var r3 = [], n3 = true, o3 = false, a3 = void 0;
          try {
            for (var i3, c3 = e4[Symbol.iterator](); !(n3 = (i3 = c3.next()).done) && (r3.push(i3.value), !t5 || r3.length !== t5); n3 = true) {
            }
          } catch (e5) {
            o3 = true, a3 = e5;
          } finally {
            try {
              n3 || null == c3.return || c3.return();
            } finally {
              if (o3)
                throw a3;
            }
          }
          return r3;
        }(e3, t4) || _unsupportedIterableToArray(e3, t4) || function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function _toConsumableArray(e3) {
        return function _arrayWithoutHoles(e4) {
          if (Array.isArray(e4))
            return _arrayLikeToArray(e4);
        }(e3) || function _iterableToArray(e4) {
          if ("undefined" != typeof Symbol && Symbol.iterator in Object(e4))
            return Array.from(e4);
        }(e3) || _unsupportedIterableToArray(e3) || function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function _unsupportedIterableToArray(e3, t4) {
        if (e3) {
          if ("string" == typeof e3)
            return _arrayLikeToArray(e3, t4);
          var r3 = Object.prototype.toString.call(e3).slice(8, -1);
          return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? _arrayLikeToArray(e3, t4) : void 0;
        }
      }
      function _arrayLikeToArray(e3, t4) {
        (null == t4 || t4 > e3.length) && (t4 = e3.length);
        for (var r3 = 0, n3 = new Array(t4); r3 < t4; r3++) {
          n3[r3] = e3[r3];
        }
        return n3;
      }
      var e2 = function TypesonPromise(e3) {
        _classCallCheck(this, TypesonPromise), this.p = new Promise(e3);
      };
      e2.__typeson__type__ = "TypesonPromise", "undefined" != typeof Symbol && (e2.prototype[Symbol.toStringTag] = "TypesonPromise"), e2.prototype.then = function(t4, r3) {
        var n3 = this;
        return new e2(function(e3, o3) {
          n3.p.then(function(r4) {
            e3(t4 ? t4(r4) : r4);
          }).catch(function(e4) {
            return r3 ? r3(e4) : Promise.reject(e4);
          }).then(e3, o3);
        });
      }, e2.prototype.catch = function(e3) {
        return this.then(null, e3);
      }, e2.resolve = function(t4) {
        return new e2(function(e3) {
          e3(t4);
        });
      }, e2.reject = function(t4) {
        return new e2(function(e3, r3) {
          r3(t4);
        });
      }, ["all", "race", "allSettled"].forEach(function(t4) {
        e2[t4] = function(r3) {
          return new e2(function(e3, n3) {
            Promise[t4](r3.map(function(e4) {
              return e4 && e4.constructor && "TypesonPromise" === e4.constructor.__typeson__type__ ? e4.p : e4;
            })).then(e3, n3);
          });
        };
      });
      var t3 = {}.toString, r2 = {}.hasOwnProperty, n2 = Object.getPrototypeOf, o2 = r2.toString;
      function isThenable2(e3, t4) {
        return isObject3(e3) && "function" == typeof e3.then && (!t4 || "function" == typeof e3.catch);
      }
      function toStringTag(e3) {
        return t3.call(e3).slice(8, -1);
      }
      function hasConstructorOf(e3, t4) {
        if (!e3 || "object" !== _typeof3(e3))
          return false;
        var a3 = n2(e3);
        if (!a3)
          return null === t4;
        var i3 = r2.call(a3, "constructor") && a3.constructor;
        return "function" != typeof i3 ? null === t4 : t4 === i3 || null !== t4 && o2.call(i3) === o2.call(t4) || "function" == typeof t4 && "string" == typeof i3.__typeson__type__ && i3.__typeson__type__ === t4.__typeson__type__;
      }
      function isPlainObject2(e3) {
        return !(!e3 || "Object" !== toStringTag(e3)) && (!n2(e3) || hasConstructorOf(e3, Object));
      }
      function isObject3(e3) {
        return e3 && "object" === _typeof3(e3);
      }
      function escapeKeyPathComponent(e3) {
        return e3.replace(/~/g, "~0").replace(/\./g, "~1");
      }
      function unescapeKeyPathComponent(e3) {
        return e3.replace(/~1/g, ".").replace(/~0/g, "~");
      }
      function getByKeyPath(e3, t4) {
        if ("" === t4)
          return e3;
        var r3 = t4.indexOf(".");
        if (r3 > -1) {
          var n3 = e3[unescapeKeyPathComponent(t4.slice(0, r3))];
          return void 0 === n3 ? void 0 : getByKeyPath(n3, t4.slice(r3 + 1));
        }
        return e3[unescapeKeyPathComponent(t4)];
      }
      function setAtKeyPath(e3, t4, r3) {
        if ("" === t4)
          return r3;
        var n3 = t4.indexOf(".");
        return n3 > -1 ? setAtKeyPath(e3[unescapeKeyPathComponent(t4.slice(0, n3))], t4.slice(n3 + 1), r3) : (e3[unescapeKeyPathComponent(t4)] = r3, e3);
      }
      function _await(e3, t4, r3) {
        return r3 ? t4 ? t4(e3) : e3 : (e3 && e3.then || (e3 = Promise.resolve(e3)), t4 ? e3.then(t4) : e3);
      }
      var a2 = Object.keys, i2 = Array.isArray, c2 = {}.hasOwnProperty, s2 = ["type", "replaced", "iterateIn", "iterateUnsetNumeric"];
      function _async(e3) {
        return function() {
          for (var t4 = [], r3 = 0; r3 < arguments.length; r3++) {
            t4[r3] = arguments[r3];
          }
          try {
            return Promise.resolve(e3.apply(this, t4));
          } catch (e4) {
            return Promise.reject(e4);
          }
        };
      }
      function nestedPathsFirst(e3, t4) {
        if ("" === e3.keypath)
          return -1;
        var r3 = e3.keypath.match(/\./g) || 0, n3 = t4.keypath.match(/\./g) || 0;
        return r3 && (r3 = r3.length), n3 && (n3 = n3.length), r3 > n3 ? -1 : r3 < n3 ? 1 : e3.keypath < t4.keypath ? -1 : e3.keypath > t4.keypath;
      }
      var u2 = function() {
        function Typeson(e3) {
          _classCallCheck(this, Typeson), this.options = e3, this.plainObjectReplacers = [], this.nonplainObjectReplacers = [], this.revivers = {}, this.types = {};
        }
        return function _createClass2(e3, t4, r3) {
          return t4 && _defineProperties2(e3.prototype, t4), r3 && _defineProperties2(e3, r3), e3;
        }(Typeson, [{ key: "stringify", value: function stringify2(e3, t4, r3, n3) {
          n3 = _objectSpread22(_objectSpread22(_objectSpread22({}, this.options), n3), {}, { stringification: true });
          var o3 = this.encapsulate(e3, null, n3);
          return i2(o3) ? JSON.stringify(o3[0], t4, r3) : o3.then(function(e4) {
            return JSON.stringify(e4, t4, r3);
          });
        } }, { key: "stringifySync", value: function stringifySync(e3, t4, r3, n3) {
          return this.stringify(e3, t4, r3, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, n3), {}, { sync: true }));
        } }, { key: "stringifyAsync", value: function stringifyAsync(e3, t4, r3, n3) {
          return this.stringify(e3, t4, r3, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, n3), {}, { sync: false }));
        } }, { key: "parse", value: function parse2(e3, t4, r3) {
          return r3 = _objectSpread22(_objectSpread22(_objectSpread22({}, this.options), r3), {}, { parse: true }), this.revive(JSON.parse(e3, t4), r3);
        } }, { key: "parseSync", value: function parseSync(e3, t4, r3) {
          return this.parse(e3, t4, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, r3), {}, { sync: true }));
        } }, { key: "parseAsync", value: function parseAsync(e3, t4, r3) {
          return this.parse(e3, t4, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, r3), {}, { sync: false }));
        } }, { key: "specialTypeNames", value: function specialTypeNames(e3, t4) {
          var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return r3.returnTypeNames = true, this.encapsulate(e3, t4, r3);
        } }, { key: "rootTypeName", value: function rootTypeName(e3, t4) {
          var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return r3.iterateNone = true, this.encapsulate(e3, t4, r3);
        } }, { key: "encapsulate", value: function encapsulate(t4, r3, n3) {
          var o3 = _async(function(t5, r4) {
            return _await(Promise.all(r4.map(function(e3) {
              return e3[1].p;
            })), function(n4) {
              return _await(Promise.all(n4.map(_async(function(n5) {
                var a3 = false, i3 = [], c3 = _slicedToArray(r4.splice(0, 1), 1), s3 = _slicedToArray(c3[0], 7), u4 = s3[0], p4 = s3[2], y3 = s3[3], l3 = s3[4], f3 = s3[5], h3 = s3[6], v3 = _encapsulate(u4, n5, p4, y3, i3, true, h3), d3 = hasConstructorOf(v3, e2);
                return function _invoke(e3, t6) {
                  var r5 = e3();
                  return r5 && r5.then ? r5.then(t6) : t6(r5);
                }(function() {
                  if (u4 && d3)
                    return _await(v3.p, function(e3) {
                      return l3[f3] = e3, a3 = true, o3(t5, i3);
                    });
                }, function(e3) {
                  return a3 ? e3 : (u4 ? l3[f3] = v3 : t5 = d3 ? v3.p : v3, o3(t5, i3));
                });
              }))), function() {
                return t5;
              });
            });
          }), u3 = (n3 = _objectSpread22(_objectSpread22({ sync: true }, this.options), n3)).sync, p3 = this, y2 = {}, l2 = [], f2 = [], h2 = [], v2 = !("cyclic" in n3) || n3.cyclic, d2 = n3.encapsulateObserver, b2 = _encapsulate("", t4, v2, r3 || {}, h2);
          function finish(e3) {
            var t5 = Object.values(y2);
            if (n3.iterateNone)
              return t5.length ? t5[0] : Typeson.getJSONType(e3);
            if (t5.length) {
              if (n3.returnTypeNames)
                return _toConsumableArray(new Set(t5));
              e3 && isPlainObject2(e3) && !c2.call(e3, "$types") ? e3.$types = y2 : e3 = { $: e3, $types: { $: y2 } };
            } else
              isObject3(e3) && c2.call(e3, "$types") && (e3 = { $: e3, $types: true });
            return !n3.returnTypeNames && e3;
          }
          function _adaptBuiltinStateObjectProperties(e3, t5, r4) {
            Object.assign(e3, t5);
            var n4 = s2.map(function(t6) {
              var r5 = e3[t6];
              return delete e3[t6], r5;
            });
            r4(), s2.forEach(function(t6, r5) {
              e3[t6] = n4[r5];
            });
          }
          function _encapsulate(t5, r4, o4, s3, u4, h3, v3) {
            var b3, _2 = {}, O2 = _typeof3(r4), j2 = d2 ? function(n4) {
              var a3 = v3 || s3.type || Typeson.getJSONType(r4);
              d2(Object.assign(n4 || _2, { keypath: t5, value: r4, cyclic: o4, stateObj: s3, promisesData: u4, resolvingTypesonPromise: h3, awaitingTypesonPromise: hasConstructorOf(r4, e2) }, { type: a3 }));
            } : null;
            if (["string", "boolean", "number", "undefined"].includes(O2))
              return void 0 === r4 || Number.isNaN(r4) || r4 === Number.NEGATIVE_INFINITY || r4 === Number.POSITIVE_INFINITY ? (b3 = s3.replaced ? r4 : replace2(t5, r4, s3, u4, false, h3, j2)) !== r4 && (_2 = { replaced: b3 }) : b3 = r4, j2 && j2(), b3;
            if (null === r4)
              return j2 && j2(), r4;
            if (o4 && !s3.iterateIn && !s3.iterateUnsetNumeric && r4 && "object" === _typeof3(r4)) {
              var m2 = l2.indexOf(r4);
              if (!(m2 < 0))
                return y2[t5] = "#", j2 && j2({ cyclicKeypath: f2[m2] }), "#" + f2[m2];
              true === o4 && (l2.push(r4), f2.push(t5));
            }
            var S2, g2 = isPlainObject2(r4), P2 = i2(r4), T2 = (g2 || P2) && (!p3.plainObjectReplacers.length || s3.replaced) || s3.iterateIn ? r4 : replace2(t5, r4, s3, u4, g2 || P2, null, j2);
            if (T2 !== r4 ? (b3 = T2, _2 = { replaced: T2 }) : "" === t5 && hasConstructorOf(r4, e2) ? (u4.push([t5, r4, o4, s3, void 0, void 0, s3.type]), b3 = r4) : P2 && "object" !== s3.iterateIn || "array" === s3.iterateIn ? (S2 = new Array(r4.length), _2 = { clone: S2 }) : (["function", "symbol"].includes(_typeof3(r4)) || "toJSON" in r4 || hasConstructorOf(r4, e2) || hasConstructorOf(r4, Promise) || hasConstructorOf(r4, ArrayBuffer)) && !g2 && "object" !== s3.iterateIn ? b3 = r4 : (S2 = {}, s3.addLength && (S2.length = r4.length), _2 = { clone: S2 }), j2 && j2(), n3.iterateNone)
              return S2 || b3;
            if (!S2)
              return b3;
            if (s3.iterateIn) {
              var w2 = function _loop(n4) {
                var a3 = { ownKeys: c2.call(r4, n4) };
                _adaptBuiltinStateObjectProperties(s3, a3, function() {
                  var a4 = t5 + (t5 ? "." : "") + escapeKeyPathComponent(n4), i3 = _encapsulate(a4, r4[n4], Boolean(o4), s3, u4, h3);
                  hasConstructorOf(i3, e2) ? u4.push([a4, i3, Boolean(o4), s3, S2, n4, s3.type]) : void 0 !== i3 && (S2[n4] = i3);
                });
              };
              for (var A2 in r4) {
                w2(A2);
              }
              j2 && j2({ endIterateIn: true, end: true });
            } else
              a2(r4).forEach(function(n4) {
                var a3 = t5 + (t5 ? "." : "") + escapeKeyPathComponent(n4);
                _adaptBuiltinStateObjectProperties(s3, { ownKeys: true }, function() {
                  var t6 = _encapsulate(a3, r4[n4], Boolean(o4), s3, u4, h3);
                  hasConstructorOf(t6, e2) ? u4.push([a3, t6, Boolean(o4), s3, S2, n4, s3.type]) : void 0 !== t6 && (S2[n4] = t6);
                });
              }), j2 && j2({ endIterateOwn: true, end: true });
            if (s3.iterateUnsetNumeric) {
              for (var C2 = r4.length, k2 = function _loop2(n4) {
                if (!(n4 in r4)) {
                  var a3 = t5 + (t5 ? "." : "") + n4;
                  _adaptBuiltinStateObjectProperties(s3, { ownKeys: false }, function() {
                    var t6 = _encapsulate(a3, void 0, Boolean(o4), s3, u4, h3);
                    hasConstructorOf(t6, e2) ? u4.push([a3, t6, Boolean(o4), s3, S2, n4, s3.type]) : void 0 !== t6 && (S2[n4] = t6);
                  });
                }
              }, N2 = 0; N2 < C2; N2++) {
                k2(N2);
              }
              j2 && j2({ endIterateUnsetNumeric: true, end: true });
            }
            return S2;
          }
          function replace2(e3, t5, r4, n4, o4, a3, i3) {
            for (var c3 = o4 ? p3.plainObjectReplacers : p3.nonplainObjectReplacers, s3 = c3.length; s3--; ) {
              var l3 = c3[s3];
              if (l3.test(t5, r4)) {
                var f3 = l3.type;
                if (p3.revivers[f3]) {
                  var h3 = y2[e3];
                  y2[e3] = h3 ? [f3].concat(h3) : f3;
                }
                return Object.assign(r4, { type: f3, replaced: true }), !u3 && l3.replaceAsync || l3.replace ? (i3 && i3({ replacing: true }), _encapsulate(e3, l3[u3 || !l3.replaceAsync ? "replace" : "replaceAsync"](t5, r4), v2 && "readonly", r4, n4, a3, f3)) : (i3 && i3({ typeDetected: true }), _encapsulate(e3, t5, v2 && "readonly", r4, n4, a3, f3));
              }
            }
            return t5;
          }
          return h2.length ? u3 && n3.throwOnBadSyncType ? function() {
            throw new TypeError("Sync method requested but async result obtained");
          }() : Promise.resolve(o3(b2, h2)).then(finish) : !u3 && n3.throwOnBadSyncType ? function() {
            throw new TypeError("Async method requested but sync result obtained");
          }() : n3.stringification && u3 ? [finish(b2)] : u3 ? finish(b2) : Promise.resolve(finish(b2));
        } }, { key: "encapsulateSync", value: function encapsulateSync(e3, t4, r3) {
          return this.encapsulate(e3, t4, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, r3), {}, { sync: true }));
        } }, { key: "encapsulateAsync", value: function encapsulateAsync(e3, t4, r3) {
          return this.encapsulate(e3, t4, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, r3), {}, { sync: false }));
        } }, { key: "revive", value: function revive(t4, r3) {
          var n3 = t4 && t4.$types;
          if (!n3)
            return t4;
          if (true === n3)
            return t4.$;
          var o3 = (r3 = _objectSpread22(_objectSpread22({ sync: true }, this.options), r3)).sync, c3 = [], s3 = {}, u3 = true;
          n3.$ && isPlainObject2(n3.$) && (t4 = t4.$, n3 = n3.$, u3 = false);
          var y2 = this;
          function executeReviver(e3, t5) {
            var r4 = _slicedToArray(y2.revivers[e3] || [], 1)[0];
            if (!r4)
              throw new Error("Unregistered type: " + e3);
            return o3 && !("revive" in r4) ? t5 : r4[o3 && r4.revive ? "revive" : !o3 && r4.reviveAsync ? "reviveAsync" : "revive"](t5, s3);
          }
          var l2 = [];
          function checkUndefined(e3) {
            return hasConstructorOf(e3, p2) ? void 0 : e3;
          }
          var f2, h2 = function revivePlainObjects() {
            var r4 = [];
            if (Object.entries(n3).forEach(function(e3) {
              var t5 = _slicedToArray(e3, 2), o4 = t5[0], a3 = t5[1];
              "#" !== a3 && [].concat(a3).forEach(function(e4) {
                _slicedToArray(y2.revivers[e4] || [null, {}], 2)[1].plain && (r4.push({ keypath: o4, type: e4 }), delete n3[o4]);
              });
            }), r4.length)
              return r4.sort(nestedPathsFirst).reduce(function reducer(r5, n4) {
                var o4 = n4.keypath, a3 = n4.type;
                if (isThenable2(r5))
                  return r5.then(function(e3) {
                    return reducer(e3, { keypath: o4, type: a3 });
                  });
                var i3 = getByKeyPath(t4, o4);
                if (hasConstructorOf(i3 = executeReviver(a3, i3), e2))
                  return i3.then(function(e3) {
                    var r6 = setAtKeyPath(t4, o4, e3);
                    r6 === e3 && (t4 = r6);
                  });
                var c4 = setAtKeyPath(t4, o4, i3);
                c4 === i3 && (t4 = c4);
              }, void 0);
          }();
          return hasConstructorOf(h2, e2) ? f2 = h2.then(function() {
            return t4;
          }) : (f2 = function _revive(t5, r4, o4, s4, y3) {
            if (!u3 || "$types" !== t5) {
              var f3 = n3[t5], h3 = i2(r4);
              if (h3 || isPlainObject2(r4)) {
                var v2 = h3 ? new Array(r4.length) : {};
                for (a2(r4).forEach(function(n4) {
                  var a3 = _revive(t5 + (t5 ? "." : "") + escapeKeyPathComponent(n4), r4[n4], o4 || v2, v2, n4), i3 = function set(e3) {
                    return hasConstructorOf(e3, p2) ? v2[n4] = void 0 : void 0 !== e3 && (v2[n4] = e3), e3;
                  };
                  hasConstructorOf(a3, e2) ? l2.push(a3.then(function(e3) {
                    return i3(e3);
                  })) : i3(a3);
                }), r4 = v2; c3.length; ) {
                  var d2 = _slicedToArray(c3[0], 4), b2 = d2[0], _2 = d2[1], O2 = d2[2], j2 = d2[3], m2 = getByKeyPath(b2, _2);
                  if (void 0 === m2)
                    break;
                  O2[j2] = m2, c3.splice(0, 1);
                }
              }
              if (!f3)
                return r4;
              if ("#" === f3) {
                var S2 = getByKeyPath(o4, r4.slice(1));
                return void 0 === S2 && c3.push([o4, r4.slice(1), s4, y3]), S2;
              }
              return [].concat(f3).reduce(function reducer(t6, r5) {
                return hasConstructorOf(t6, e2) ? t6.then(function(e3) {
                  return reducer(e3, r5);
                }) : executeReviver(r5, t6);
              }, r4);
            }
          }("", t4, null), l2.length && (f2 = e2.resolve(f2).then(function(t5) {
            return e2.all([t5].concat(l2));
          }).then(function(e3) {
            return _slicedToArray(e3, 1)[0];
          }))), isThenable2(f2) ? o3 && r3.throwOnBadSyncType ? function() {
            throw new TypeError("Sync method requested but async result obtained");
          }() : hasConstructorOf(f2, e2) ? f2.p.then(checkUndefined) : f2 : !o3 && r3.throwOnBadSyncType ? function() {
            throw new TypeError("Async method requested but sync result obtained");
          }() : o3 ? checkUndefined(f2) : Promise.resolve(checkUndefined(f2));
        } }, { key: "reviveSync", value: function reviveSync(e3, t4) {
          return this.revive(e3, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, t4), {}, { sync: true }));
        } }, { key: "reviveAsync", value: function reviveAsync(e3, t4) {
          return this.revive(e3, _objectSpread22(_objectSpread22({ throwOnBadSyncType: true }, t4), {}, { sync: false }));
        } }, { key: "register", value: function register(e3, t4) {
          return t4 = t4 || {}, [].concat(e3).forEach(function R2(e4) {
            var r3 = this;
            if (i2(e4))
              return e4.map(function(e5) {
                return R2.call(r3, e5);
              });
            e4 && a2(e4).forEach(function(r4) {
              if ("#" === r4)
                throw new TypeError("# cannot be used as a type name as it is reserved for cyclic objects");
              if (Typeson.JSON_TYPES.includes(r4))
                throw new TypeError("Plain JSON object types are reserved as type names");
              var n3 = e4[r4], o3 = n3 && n3.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers, a3 = o3.filter(function(e5) {
                return e5.type === r4;
              });
              if (a3.length && (o3.splice(o3.indexOf(a3[0]), 1), delete this.revivers[r4], delete this.types[r4]), "function" == typeof n3) {
                var c3 = n3;
                n3 = { test: function test2(e5) {
                  return e5 && e5.constructor === c3;
                }, replace: function replace2(e5) {
                  return _objectSpread22({}, e5);
                }, revive: function revive(e5) {
                  return Object.assign(Object.create(c3.prototype), e5);
                } };
              } else if (i2(n3)) {
                var s3 = _slicedToArray(n3, 3);
                n3 = { test: s3[0], replace: s3[1], revive: s3[2] };
              }
              if (n3 && n3.test) {
                var u3 = { type: r4, test: n3.test.bind(n3) };
                n3.replace && (u3.replace = n3.replace.bind(n3)), n3.replaceAsync && (u3.replaceAsync = n3.replaceAsync.bind(n3));
                var p3 = "number" == typeof t4.fallback ? t4.fallback : t4.fallback ? 0 : Number.POSITIVE_INFINITY;
                if (n3.testPlainObjects ? this.plainObjectReplacers.splice(p3, 0, u3) : this.nonplainObjectReplacers.splice(p3, 0, u3), n3.revive || n3.reviveAsync) {
                  var y2 = {};
                  n3.revive && (y2.revive = n3.revive.bind(n3)), n3.reviveAsync && (y2.reviveAsync = n3.reviveAsync.bind(n3)), this.revivers[r4] = [y2, { plain: n3.testPlainObjects }];
                }
                this.types[r4] = n3;
              }
            }, this);
          }, this), this;
        } }]), Typeson;
      }(), p2 = function Undefined() {
        _classCallCheck(this, Undefined);
      };
      p2.__typeson__type__ = "TypesonUndefined", u2.Undefined = p2, u2.Promise = e2, u2.isThenable = isThenable2, u2.toStringTag = toStringTag, u2.hasConstructorOf = hasConstructorOf, u2.isObject = isObject3, u2.isPlainObject = isPlainObject2, u2.isUserObject = function isUserObject(e3) {
        if (!e3 || "Object" !== toStringTag(e3))
          return false;
        var t4 = n2(e3);
        return !t4 || hasConstructorOf(e3, Object) || isUserObject(t4);
      }, u2.escapeKeyPathComponent = escapeKeyPathComponent, u2.unescapeKeyPathComponent = unescapeKeyPathComponent, u2.getByKeyPath = getByKeyPath, u2.getJSONType = function getJSONType(e3) {
        return null === e3 ? "null" : Array.isArray(e3) ? "array" : _typeof3(e3);
      }, u2.JSON_TYPES = ["null", "boolean", "number", "string", "array", "object"], module3.exports = u2;
    }, {}], 9: [function(_dereq_, module3, exports3) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _2(message, opts) {
        return (opts && opts.context ? opts.context : "Value") + " " + message + ".";
      }
      function type2(V2) {
        if (V2 === null) {
          return "Null";
        }
        switch (typeof V2 === "undefined" ? "undefined" : _typeof2(V2)) {
          case "undefined":
            return "Undefined";
          case "boolean":
            return "Boolean";
          case "number":
            return "Number";
          case "string":
            return "String";
          case "symbol":
            return "Symbol";
          case "object":
          case "function":
          default:
            return "Object";
        }
      }
      function evenRound(x2) {
        if (x2 > 0 && x2 % 1 === 0.5 && (x2 & 1) === 0 || x2 < 0 && x2 % 1 === -0.5 && (x2 & 1) === 1) {
          return censorNegativeZero(Math.floor(x2));
        }
        return censorNegativeZero(Math.round(x2));
      }
      function integerPart(n2) {
        return censorNegativeZero(Math.trunc(n2));
      }
      function sign(x2) {
        return x2 < 0 ? -1 : 1;
      }
      function modulo(x2, y2) {
        var signMightNotMatch = x2 % y2;
        if (sign(y2) !== sign(signMightNotMatch)) {
          return signMightNotMatch + y2;
        }
        return signMightNotMatch;
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function createIntegerConversion(bitLength, typeOpts) {
        var isSigned = !typeOpts.unsigned;
        var lowerBound = void 0;
        var upperBound = void 0;
        if (bitLength === 64) {
          upperBound = Math.pow(2, 53) - 1;
          lowerBound = !isSigned ? 0 : -Math.pow(2, 53) + 1;
        } else if (!isSigned) {
          lowerBound = 0;
          upperBound = Math.pow(2, bitLength) - 1;
        } else {
          lowerBound = -Math.pow(2, bitLength - 1);
          upperBound = Math.pow(2, bitLength - 1) - 1;
        }
        var twoToTheBitLength = Math.pow(2, bitLength);
        var twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);
        return function(V2, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var x2 = +V2;
          x2 = censorNegativeZero(x2);
          if (opts.enforceRange) {
            if (!Number.isFinite(x2)) {
              throw new TypeError(_2("is not a finite number", opts));
            }
            x2 = integerPart(x2);
            if (x2 < lowerBound || x2 > upperBound) {
              throw new TypeError(_2("is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive", opts));
            }
            return x2;
          }
          if (!Number.isNaN(x2) && opts.clamp) {
            x2 = Math.min(Math.max(x2, lowerBound), upperBound);
            x2 = evenRound(x2);
            return x2;
          }
          if (!Number.isFinite(x2) || x2 === 0) {
            return 0;
          }
          x2 = integerPart(x2);
          if (x2 >= lowerBound && x2 <= upperBound) {
            return x2;
          }
          x2 = modulo(x2, twoToTheBitLength);
          if (isSigned && x2 >= twoToOneLessThanTheBitLength) {
            return x2 - twoToTheBitLength;
          }
          return x2;
        };
      }
      exports3.any = function(V2) {
        return V2;
      };
      exports3.void = function() {
        return void 0;
      };
      exports3.boolean = function(val) {
        return !!val;
      };
      exports3.byte = createIntegerConversion(8, { unsigned: false });
      exports3.octet = createIntegerConversion(8, { unsigned: true });
      exports3.short = createIntegerConversion(16, { unsigned: false });
      exports3["unsigned short"] = createIntegerConversion(16, { unsigned: true });
      exports3.long = createIntegerConversion(32, { unsigned: false });
      exports3["unsigned long"] = createIntegerConversion(32, { unsigned: true });
      exports3["long long"] = createIntegerConversion(64, { unsigned: false });
      exports3["unsigned long long"] = createIntegerConversion(64, { unsigned: true });
      exports3.double = function(V2, opts) {
        var x2 = +V2;
        if (!Number.isFinite(x2)) {
          throw new TypeError(_2("is not a finite floating-point value", opts));
        }
        return x2;
      };
      exports3["unrestricted double"] = function(V2) {
        var x2 = +V2;
        return x2;
      };
      exports3.float = function(V2, opts) {
        var x2 = +V2;
        if (!Number.isFinite(x2)) {
          throw new TypeError(_2("is not a finite floating-point value", opts));
        }
        if (Object.is(x2, -0)) {
          return x2;
        }
        var y2 = Math.fround(x2);
        if (!Number.isFinite(y2)) {
          throw new TypeError(_2("is outside the range of a single-precision floating-point value", opts));
        }
        return y2;
      };
      exports3["unrestricted float"] = function(V2) {
        var x2 = +V2;
        if (isNaN(x2)) {
          return x2;
        }
        if (Object.is(x2, -0)) {
          return x2;
        }
        return Math.fround(x2);
      };
      exports3.DOMString = function(V2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (opts.treatNullAsEmptyString && V2 === null) {
          return "";
        }
        if ((typeof V2 === "undefined" ? "undefined" : _typeof2(V2)) === "symbol") {
          throw new TypeError(_2("is a symbol, which cannot be converted to a string", opts));
        }
        return String(V2);
      };
      exports3.ByteString = function(V2, opts) {
        var x2 = exports3.DOMString(V2, opts);
        var c2 = void 0;
        for (var i2 = 0; (c2 = x2.codePointAt(i2)) !== void 0; ++i2) {
          if (c2 > 255) {
            throw new TypeError(_2("is not a valid ByteString", opts));
          }
        }
        return x2;
      };
      exports3.USVString = function(V2, opts) {
        var S2 = exports3.DOMString(V2, opts);
        var n2 = S2.length;
        var U2 = [];
        for (var i2 = 0; i2 < n2; ++i2) {
          var c2 = S2.charCodeAt(i2);
          if (c2 < 55296 || c2 > 57343) {
            U2.push(String.fromCodePoint(c2));
          } else if (56320 <= c2 && c2 <= 57343) {
            U2.push(String.fromCodePoint(65533));
          } else if (i2 === n2 - 1) {
            U2.push(String.fromCodePoint(65533));
          } else {
            var d2 = S2.charCodeAt(i2 + 1);
            if (56320 <= d2 && d2 <= 57343) {
              var a2 = c2 & 1023;
              var b2 = d2 & 1023;
              U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a2 + b2));
              ++i2;
            } else {
              U2.push(String.fromCodePoint(65533));
            }
          }
        }
        return U2.join("");
      };
      exports3.object = function(V2, opts) {
        if (type2(V2) !== "Object") {
          throw new TypeError(_2("is not an object", opts));
        }
        return V2;
      };
      function convertCallbackFunction(V2, opts) {
        if (typeof V2 !== "function") {
          throw new TypeError(_2("is not a function", opts));
        }
        return V2;
      }
      [
        Error,
        ArrayBuffer,
        // The IsDetachedBuffer abstract operation is not exposed in JS
        DataView,
        Int8Array,
        Int16Array,
        Int32Array,
        Uint8Array,
        Uint16Array,
        Uint32Array,
        Uint8ClampedArray,
        Float32Array,
        Float64Array
      ].forEach(function(func) {
        var name = func.name;
        var article = /^[AEIOU]/.test(name) ? "an" : "a";
        exports3[name] = function(V2, opts) {
          if (!(V2 instanceof func)) {
            throw new TypeError(_2("is not " + article + " " + name + " object", opts));
          }
          return V2;
        };
      });
      exports3.ArrayBufferView = function(V2, opts) {
        if (!ArrayBuffer.isView(V2)) {
          throw new TypeError(_2("is not a view on an ArrayBuffer object", opts));
        }
        return V2;
      };
      exports3.BufferSource = function(V2, opts) {
        if (!(ArrayBuffer.isView(V2) || V2 instanceof ArrayBuffer)) {
          throw new TypeError(_2("is not an ArrayBuffer object or a view on one", opts));
        }
        return V2;
      };
      exports3.DOMTimeStamp = exports3["unsigned long long"];
      exports3.Function = convertCallbackFunction;
      exports3.VoidFunction = convertCallbackFunction;
    }, {}] }, {}, [1])(1);
  });
})(dist);
var distExports = dist.exports;
const realisticStructuredClone = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
const structuredCloneWrapper = (input) => {
  if (typeof structuredClone !== "undefined") {
    return structuredClone(input);
  }
  try {
    return realisticStructuredClone(input);
  } catch (err) {
    throw new DataCloneError();
  }
};
const getEffectiveObjectStore = (cursor2) => {
  if (cursor2.source instanceof FDBObjectStore$1) {
    return cursor2.source;
  }
  return cursor2.source.objectStore;
};
const makeKeyRange = (range, lowers, uppers) => {
  let lower = range !== void 0 ? range.lower : void 0;
  let upper = range !== void 0 ? range.upper : void 0;
  for (const lowerTemp of lowers) {
    if (lowerTemp === void 0) {
      continue;
    }
    if (lower === void 0 || cmp(lower, lowerTemp) === 1) {
      lower = lowerTemp;
    }
  }
  for (const upperTemp of uppers) {
    if (upperTemp === void 0) {
      continue;
    }
    if (upper === void 0 || cmp(upper, upperTemp) === -1) {
      upper = upperTemp;
    }
  }
  if (lower !== void 0 && upper !== void 0) {
    return FDBKeyRange.bound(lower, upper);
  }
  if (lower !== void 0) {
    return FDBKeyRange.lowerBound(lower);
  }
  if (upper !== void 0) {
    return FDBKeyRange.upperBound(upper);
  }
};
class FDBCursor {
  _gotValue = false;
  _position = void 0;
  // Key of previously returned record
  _objectStorePosition = void 0;
  _keyOnly = false;
  _key = void 0;
  _primaryKey = void 0;
  constructor(source, range, direction2 = "next", request, keyOnly = false) {
    this._range = range;
    this._source = source;
    this._direction = direction2;
    this._request = request;
    this._keyOnly = keyOnly;
  }
  // Read only properties
  get source() {
    return this._source;
  }
  set source(val) {
  }
  get request() {
    return this._request;
  }
  set request(val) {
  }
  get direction() {
    return this._direction;
  }
  set direction(val) {
  }
  get key() {
    return this._key;
  }
  set key(val) {
  }
  get primaryKey() {
    return this._primaryKey;
  }
  set primaryKey(val) {
  }
  // https://w3c.github.io/IndexedDB/#iterate-a-cursor
  _iterate(key, primaryKey) {
    const sourceIsObjectStore = this.source instanceof FDBObjectStore$1;
    const records = this.source instanceof FDBObjectStore$1 ? this.source._rawObjectStore.records : this.source._rawIndex.records;
    let foundRecord;
    if (this.direction === "next") {
      const range = makeKeyRange(this._range, [key, this._position], []);
      for (const record of records.values(range)) {
        const cmpResultKey = key !== void 0 ? cmp(record.key, key) : void 0;
        const cmpResultPosition = this._position !== void 0 ? cmp(record.key, this._position) : void 0;
        if (key !== void 0) {
          if (cmpResultKey === -1) {
            continue;
          }
        }
        if (primaryKey !== void 0) {
          if (cmpResultKey === -1) {
            continue;
          }
          const cmpResultPrimaryKey = cmp(record.value, primaryKey);
          if (cmpResultKey === 0 && cmpResultPrimaryKey === -1) {
            continue;
          }
        }
        if (this._position !== void 0 && sourceIsObjectStore) {
          if (cmpResultPosition !== 1) {
            continue;
          }
        }
        if (this._position !== void 0 && !sourceIsObjectStore) {
          if (cmpResultPosition === -1) {
            continue;
          }
          if (cmpResultPosition === 0 && cmp(record.value, this._objectStorePosition) !== 1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        foundRecord = record;
        break;
      }
    } else if (this.direction === "nextunique") {
      const range = makeKeyRange(this._range, [key, this._position], []);
      for (const record of records.values(range)) {
        if (key !== void 0) {
          if (cmp(record.key, key) === -1) {
            continue;
          }
        }
        if (this._position !== void 0) {
          if (cmp(record.key, this._position) !== 1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        foundRecord = record;
        break;
      }
    } else if (this.direction === "prev") {
      const range = makeKeyRange(this._range, [], [key, this._position]);
      for (const record of records.values(range, "prev")) {
        const cmpResultKey = key !== void 0 ? cmp(record.key, key) : void 0;
        const cmpResultPosition = this._position !== void 0 ? cmp(record.key, this._position) : void 0;
        if (key !== void 0) {
          if (cmpResultKey === 1) {
            continue;
          }
        }
        if (primaryKey !== void 0) {
          if (cmpResultKey === 1) {
            continue;
          }
          const cmpResultPrimaryKey = cmp(record.value, primaryKey);
          if (cmpResultKey === 0 && cmpResultPrimaryKey === 1) {
            continue;
          }
        }
        if (this._position !== void 0 && sourceIsObjectStore) {
          if (cmpResultPosition !== -1) {
            continue;
          }
        }
        if (this._position !== void 0 && !sourceIsObjectStore) {
          if (cmpResultPosition === 1) {
            continue;
          }
          if (cmpResultPosition === 0 && cmp(record.value, this._objectStorePosition) !== -1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        foundRecord = record;
        break;
      }
    } else if (this.direction === "prevunique") {
      let tempRecord;
      const range = makeKeyRange(this._range, [], [key, this._position]);
      for (const record of records.values(range, "prev")) {
        if (key !== void 0) {
          if (cmp(record.key, key) === 1) {
            continue;
          }
        }
        if (this._position !== void 0) {
          if (cmp(record.key, this._position) !== -1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        tempRecord = record;
        break;
      }
      if (tempRecord) {
        foundRecord = records.get(tempRecord.key);
      }
    }
    let result;
    if (!foundRecord) {
      this._key = void 0;
      if (!sourceIsObjectStore) {
        this._objectStorePosition = void 0;
      }
      if (!this._keyOnly && this.toString() === "[object IDBCursorWithValue]") {
        this.value = void 0;
      }
      result = null;
    } else {
      this._position = foundRecord.key;
      if (!sourceIsObjectStore) {
        this._objectStorePosition = foundRecord.value;
      }
      this._key = foundRecord.key;
      if (sourceIsObjectStore) {
        this._primaryKey = structuredCloneWrapper(foundRecord.key);
        if (!this._keyOnly && this.toString() === "[object IDBCursorWithValue]") {
          this.value = structuredCloneWrapper(foundRecord.value);
        }
      } else {
        this._primaryKey = structuredCloneWrapper(foundRecord.value);
        if (!this._keyOnly && this.toString() === "[object IDBCursorWithValue]") {
          if (this.source instanceof FDBObjectStore$1) {
            throw new Error("This should never happen");
          }
          const value = this.source.objectStore._rawObjectStore.getValue(foundRecord.value);
          this.value = structuredCloneWrapper(value);
        }
      }
      this._gotValue = true;
      result = this;
    }
    return result;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-update-IDBRequest-any-value
  update(value) {
    if (value === void 0) {
      throw new TypeError();
    }
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const effectiveKey = this.source.hasOwnProperty("_rawIndex") ? this.primaryKey : this._position;
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue || !this.hasOwnProperty("value")) {
      throw new InvalidStateError();
    }
    const clone2 = structuredCloneWrapper(value);
    if (effectiveObjectStore.keyPath !== null) {
      let tempKey;
      try {
        tempKey = extractKey(effectiveObjectStore.keyPath, clone2);
      } catch (err) {
      }
      if (cmp(tempKey, effectiveKey) !== 0) {
        throw new DataError();
      }
    }
    const record = {
      key: effectiveKey,
      value: clone2
    };
    return transaction._execRequestAsync({
      operation: effectiveObjectStore._rawObjectStore.storeRecord.bind(effectiveObjectStore._rawObjectStore, record, false, transaction._rollbackLog),
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-advance-void-unsigned-long-count
  advance(count) {
    if (!Number.isInteger(count) || count <= 0) {
      throw new TypeError();
    }
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue) {
      throw new InvalidStateError();
    }
    if (this._request) {
      this._request.readyState = "pending";
    }
    transaction._execRequestAsync({
      operation: () => {
        let result;
        for (let i2 = 0; i2 < count; i2++) {
          result = this._iterate();
          if (!result) {
            break;
          }
        }
        return result;
      },
      request: this._request,
      source: this.source
    });
    this._gotValue = false;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-continue-void-any-key
  continue(key) {
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue) {
      throw new InvalidStateError();
    }
    if (key !== void 0) {
      key = valueToKey(key);
      const cmpResult = cmp(key, this._position);
      if (cmpResult <= 0 && (this.direction === "next" || this.direction === "nextunique") || cmpResult >= 0 && (this.direction === "prev" || this.direction === "prevunique")) {
        throw new DataError();
      }
    }
    if (this._request) {
      this._request.readyState = "pending";
    }
    transaction._execRequestAsync({
      operation: this._iterate.bind(this, key),
      request: this._request,
      source: this.source
    });
    this._gotValue = false;
  }
  // hthttps://w3c.github.io/IndexedDB/#dom-idbcursor-continueprimarykey
  continuePrimaryKey(key, primaryKey) {
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (this.source instanceof FDBObjectStore$1 || this.direction !== "next" && this.direction !== "prev") {
      throw new InvalidAccessError();
    }
    if (!this._gotValue) {
      throw new InvalidStateError();
    }
    if (key === void 0 || primaryKey === void 0) {
      throw new DataError();
    }
    key = valueToKey(key);
    const cmpResult = cmp(key, this._position);
    if (cmpResult === -1 && this.direction === "next" || cmpResult === 1 && this.direction === "prev") {
      throw new DataError();
    }
    const cmpResult2 = cmp(primaryKey, this._objectStorePosition);
    if (cmpResult === 0) {
      if (cmpResult2 <= 0 && this.direction === "next" || cmpResult2 >= 0 && this.direction === "prev") {
        throw new DataError();
      }
    }
    if (this._request) {
      this._request.readyState = "pending";
    }
    transaction._execRequestAsync({
      operation: this._iterate.bind(this, key, primaryKey),
      request: this._request,
      source: this.source
    });
    this._gotValue = false;
  }
  delete() {
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const effectiveKey = this.source.hasOwnProperty("_rawIndex") ? this.primaryKey : this._position;
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue || !this.hasOwnProperty("value")) {
      throw new InvalidStateError();
    }
    return transaction._execRequestAsync({
      operation: effectiveObjectStore._rawObjectStore.deleteRecord.bind(effectiveObjectStore._rawObjectStore, effectiveKey, transaction._rollbackLog),
      source: this
    });
  }
  toString() {
    return "[object IDBCursor]";
  }
}
class FDBCursorWithValue extends FDBCursor {
  value = void 0;
  constructor(source, range, direction2, request) {
    super(source, range, direction2, request);
  }
  toString() {
    return "[object IDBCursorWithValue]";
  }
}
const stopped = (event, listener) => {
  return event.immediatePropagationStopped || event.eventPhase === event.CAPTURING_PHASE && listener.capture === false || event.eventPhase === event.BUBBLING_PHASE && listener.capture === true;
};
const invokeEventListeners = (event, obj) => {
  event.currentTarget = obj;
  for (const listener of obj.listeners.slice()) {
    if (event.type !== listener.type || stopped(event, listener)) {
      continue;
    }
    listener.callback.call(event.currentTarget, event);
  }
  const typeToProp = {
    abort: "onabort",
    blocked: "onblocked",
    complete: "oncomplete",
    error: "onerror",
    success: "onsuccess",
    upgradeneeded: "onupgradeneeded",
    versionchange: "onversionchange"
  };
  const prop = typeToProp[event.type];
  if (prop === void 0) {
    throw new Error(`Unknown event type: "${event.type}"`);
  }
  const callback = event.currentTarget[prop];
  if (callback) {
    const listener = {
      callback,
      capture: false,
      type: event.type
    };
    if (!stopped(event, listener)) {
      listener.callback.call(event.currentTarget, event);
    }
  }
};
class FakeEventTarget {
  listeners = [];
  // These will be overridden in individual subclasses and made not readonly
  addEventListener(type2, callback, capture = false) {
    this.listeners.push({
      callback,
      capture,
      type: type2
    });
  }
  removeEventListener(type2, callback, capture = false) {
    const i2 = this.listeners.findIndex((listener) => {
      return listener.type === type2 && listener.callback === callback && listener.capture === capture;
    });
    this.listeners.splice(i2, 1);
  }
  // http://www.w3.org/TR/dom/#dispatching-events
  dispatchEvent(event) {
    if (event.dispatched || !event.initialized) {
      throw new InvalidStateError("The object is in an invalid state.");
    }
    event.isTrusted = false;
    event.dispatched = true;
    event.target = this;
    event.eventPhase = event.CAPTURING_PHASE;
    for (const obj of event.eventPath) {
      if (!event.propagationStopped) {
        invokeEventListeners(event, obj);
      }
    }
    event.eventPhase = event.AT_TARGET;
    if (!event.propagationStopped) {
      invokeEventListeners(event, event.target);
    }
    if (event.bubbles) {
      event.eventPath.reverse();
      event.eventPhase = event.BUBBLING_PHASE;
      for (const obj of event.eventPath) {
        if (!event.propagationStopped) {
          invokeEventListeners(event, obj);
        }
      }
    }
    event.dispatched = false;
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    if (event.canceled) {
      return false;
    }
    return true;
  }
}
class FDBRequest extends FakeEventTarget {
  _result = null;
  _error = null;
  source = null;
  transaction = null;
  readyState = "pending";
  onsuccess = null;
  onerror = null;
  get error() {
    if (this.readyState === "pending") {
      throw new InvalidStateError();
    }
    return this._error;
  }
  set error(value) {
    this._error = value;
  }
  get result() {
    if (this.readyState === "pending") {
      throw new InvalidStateError();
    }
    return this._result;
  }
  set result(value) {
    this._result = value;
  }
  toString() {
    return "[object IDBRequest]";
  }
}
const enforceRange = (num, type2) => {
  const min2 = 0;
  const max2 = type2 === "unsigned long" ? 4294967295 : 9007199254740991;
  if (isNaN(num) || num < min2 || num > max2) {
    throw new TypeError();
  }
  if (num >= 0) {
    return Math.floor(num);
  }
};
class FakeDOMStringList extends Array {
  contains(value) {
    for (const value2 of this) {
      if (value === value2) {
        return true;
      }
    }
    return false;
  }
  item(i2) {
    if (i2 < 0 || i2 >= this.length) {
      return null;
    }
    return this[i2];
  }
  // Used internally, should not be used by others. I could maybe get rid of these and replace rather than mutate, but too lazy to check the spec.
  _push(...values2) {
    return Array.prototype.push.call(this, ...values2);
  }
  _sort(...values2) {
    return Array.prototype.sort.call(this, ...values2);
  }
}
const valueToKeyRange = (value, nullDisallowedFlag = false) => {
  if (value instanceof FDBKeyRange) {
    return value;
  }
  if (value === null || value === void 0) {
    if (nullDisallowedFlag) {
      throw new DataError();
    }
    return new FDBKeyRange(void 0, void 0, false, false);
  }
  const key = valueToKey(value);
  return FDBKeyRange.only(key);
};
const confirmActiveTransaction$1 = (index2) => {
  if (index2._rawIndex.deleted || index2.objectStore._rawObjectStore.deleted) {
    throw new InvalidStateError();
  }
  if (index2.objectStore.transaction._state !== "active") {
    throw new TransactionInactiveError();
  }
};
class FDBIndex {
  constructor(objectStore, rawIndex) {
    this._rawIndex = rawIndex;
    this._name = rawIndex.name;
    this.objectStore = objectStore;
    this.keyPath = rawIndex.keyPath;
    this.multiEntry = rawIndex.multiEntry;
    this.unique = rawIndex.unique;
  }
  get name() {
    return this._name;
  }
  // https://w3c.github.io/IndexedDB/#dom-idbindex-name
  set name(name) {
    const transaction = this.objectStore.transaction;
    if (!transaction.db._runningVersionchangeTransaction) {
      throw new InvalidStateError();
    }
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (this._rawIndex.deleted || this.objectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    name = String(name);
    if (name === this._name) {
      return;
    }
    if (this.objectStore.indexNames.contains(name)) {
      throw new ConstraintError();
    }
    const oldName = this._name;
    const oldIndexNames = [...this.objectStore.indexNames];
    this._name = name;
    this._rawIndex.name = name;
    this.objectStore._indexesCache.delete(oldName);
    this.objectStore._indexesCache.set(name, this);
    this.objectStore._rawObjectStore.rawIndexes.delete(oldName);
    this.objectStore._rawObjectStore.rawIndexes.set(name, this._rawIndex);
    this.objectStore.indexNames = new FakeDOMStringList(...Array.from(this.objectStore._rawObjectStore.rawIndexes.keys()).filter((indexName) => {
      const index2 = this.objectStore._rawObjectStore.rawIndexes.get(indexName);
      return index2 && !index2.deleted;
    }).sort());
    transaction._rollbackLog.push(() => {
      this._name = oldName;
      this._rawIndex.name = oldName;
      this.objectStore._indexesCache.delete(name);
      this.objectStore._indexesCache.set(oldName, this);
      this.objectStore._rawObjectStore.rawIndexes.delete(name);
      this.objectStore._rawObjectStore.rawIndexes.set(oldName, this._rawIndex);
      this.objectStore.indexNames = new FakeDOMStringList(...oldIndexNames);
    });
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-openCursor-IDBRequest-any-range-IDBCursorDirection-direction
  openCursor(range, direction2) {
    confirmActiveTransaction$1(this);
    if (range === null) {
      range = void 0;
    }
    if (range !== void 0 && !(range instanceof FDBKeyRange)) {
      range = FDBKeyRange.only(valueToKey(range));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.objectStore.transaction;
    const cursor2 = new FDBCursorWithValue(this, range, direction2, request);
    return this.objectStore.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-openKeyCursor-IDBRequest-any-range-IDBCursorDirection-direction
  openKeyCursor(range, direction2) {
    confirmActiveTransaction$1(this);
    if (range === null) {
      range = void 0;
    }
    if (range !== void 0 && !(range instanceof FDBKeyRange)) {
      range = FDBKeyRange.only(valueToKey(range));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.objectStore.transaction;
    const cursor2 = new FDBCursor(this, range, direction2, request, true);
    return this.objectStore.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  get(key) {
    confirmActiveTransaction$1(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getValue.bind(this._rawIndex, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbindex-getall
  getAll(query, count) {
    if (arguments.length > 1 && count !== void 0) {
      count = enforceRange(count, "unsigned long");
    }
    confirmActiveTransaction$1(this);
    const range = valueToKeyRange(query);
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getAllValues.bind(this._rawIndex, range, count),
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-getKey-IDBRequest-any-key
  getKey(key) {
    confirmActiveTransaction$1(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getKey.bind(this._rawIndex, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbindex-getallkeys
  getAllKeys(query, count) {
    if (arguments.length > 1 && count !== void 0) {
      count = enforceRange(count, "unsigned long");
    }
    confirmActiveTransaction$1(this);
    const range = valueToKeyRange(query);
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getAllKeys.bind(this._rawIndex, range, count),
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-count-IDBRequest-any-key
  count(key) {
    confirmActiveTransaction$1(this);
    if (key === null) {
      key = void 0;
    }
    if (key !== void 0 && !(key instanceof FDBKeyRange)) {
      key = FDBKeyRange.only(valueToKey(key));
    }
    return this.objectStore.transaction._execRequestAsync({
      operation: () => {
        let count = 0;
        const cursor2 = new FDBCursor(this, key);
        while (cursor2._iterate() !== null) {
          count += 1;
        }
        return count;
      },
      source: this
    });
  }
  toString() {
    return "[object IDBIndex]";
  }
}
const canInjectKey = (keyPath, value) => {
  if (Array.isArray(keyPath)) {
    throw new Error("The key paths used in this section are always strings and never sequences, since it is not possible to create a object store which has a key generator and also has a key path that is a sequence.");
  }
  const identifiers = keyPath.split(".");
  if (identifiers.length === 0) {
    throw new Error("Assert: identifiers is not empty");
  }
  identifiers.pop();
  for (const identifier2 of identifiers) {
    if (typeof value !== "object" && !Array.isArray(value)) {
      return false;
    }
    const hop = value.hasOwnProperty(identifier2);
    if (!hop) {
      return true;
    }
    value = value[identifier2];
  }
  return typeof value === "object" || Array.isArray(value);
};
function binarySearch$1(records, key) {
  let low = 0;
  let high = records.length;
  let mid;
  while (low < high) {
    mid = low + high >>> 1;
    if (cmp(records[mid].key, key) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function getIndexByKey(records, key) {
  const idx = binarySearch$1(records, key);
  const record = records[idx];
  if (record && cmp(record.key, key) === 0) {
    return idx;
  }
  return -1;
}
function getByKey(records, key) {
  const idx = getIndexByKey(records, key);
  return records[idx];
}
function getIndexByKeyRange(records, keyRange) {
  const lowerIdx = typeof keyRange.lower === "undefined" ? 0 : binarySearch$1(records, keyRange.lower);
  const upperIdx = typeof keyRange.upper === "undefined" ? records.length - 1 : binarySearch$1(records, keyRange.upper);
  for (let i2 = lowerIdx; i2 <= upperIdx; i2++) {
    const record = records[i2];
    if (record && keyRange.includes(record.key)) {
      return i2;
    }
  }
  return -1;
}
function getByKeyRange(records, keyRange) {
  const idx = getIndexByKeyRange(records, keyRange);
  return records[idx];
}
function getIndexByKeyGTE(records, key) {
  const idx = binarySearch$1(records, key);
  const record = records[idx];
  if (record && cmp(record.key, key) >= 0) {
    return idx;
  }
  return -1;
}
class RecordStore {
  records = [];
  get(key) {
    if (key instanceof FDBKeyRange) {
      return getByKeyRange(this.records, key);
    }
    return getByKey(this.records, key);
  }
  add(newRecord) {
    let i2;
    if (this.records.length === 0) {
      i2 = 0;
    } else {
      i2 = getIndexByKeyGTE(this.records, newRecord.key);
      if (i2 === -1) {
        i2 = this.records.length;
      } else {
        while (i2 < this.records.length && cmp(this.records[i2].key, newRecord.key) === 0) {
          if (cmp(this.records[i2].value, newRecord.value) !== -1) {
            break;
          }
          i2 += 1;
        }
      }
    }
    this.records.splice(i2, 0, newRecord);
  }
  delete(key) {
    const deletedRecords = [];
    const isRange = key instanceof FDBKeyRange;
    while (true) {
      const idx = isRange ? getIndexByKeyRange(this.records, key) : getIndexByKey(this.records, key);
      if (idx === -1) {
        break;
      }
      deletedRecords.push(this.records[idx]);
      this.records.splice(idx, 1);
    }
    return deletedRecords;
  }
  deleteByValue(key) {
    const range = key instanceof FDBKeyRange ? key : FDBKeyRange.only(key);
    const deletedRecords = [];
    this.records = this.records.filter((record) => {
      const shouldDelete = range.includes(record.value);
      if (shouldDelete) {
        deletedRecords.push(record);
      }
      return !shouldDelete;
    });
    return deletedRecords;
  }
  clear() {
    const deletedRecords = this.records.slice();
    this.records = [];
    return deletedRecords;
  }
  values(range, direction2 = "next") {
    return {
      [Symbol.iterator]: () => {
        let i2;
        if (direction2 === "next") {
          i2 = 0;
          if (range !== void 0 && range.lower !== void 0) {
            while (this.records[i2] !== void 0) {
              const cmpResult = cmp(this.records[i2].key, range.lower);
              if (cmpResult === 1 || cmpResult === 0 && !range.lowerOpen) {
                break;
              }
              i2 += 1;
            }
          }
        } else {
          i2 = this.records.length - 1;
          if (range !== void 0 && range.upper !== void 0) {
            while (this.records[i2] !== void 0) {
              const cmpResult = cmp(this.records[i2].key, range.upper);
              if (cmpResult === -1 || cmpResult === 0 && !range.upperOpen) {
                break;
              }
              i2 -= 1;
            }
          }
        }
        return {
          next: () => {
            let done;
            let value;
            if (direction2 === "next") {
              value = this.records[i2];
              done = i2 >= this.records.length;
              i2 += 1;
              if (!done && range !== void 0 && range.upper !== void 0) {
                const cmpResult = cmp(value.key, range.upper);
                done = cmpResult === 1 || cmpResult === 0 && range.upperOpen;
                if (done) {
                  value = void 0;
                }
              }
            } else {
              value = this.records[i2];
              done = i2 < 0;
              i2 -= 1;
              if (!done && range !== void 0 && range.lower !== void 0) {
                const cmpResult = cmp(value.key, range.lower);
                done = cmpResult === -1 || cmpResult === 0 && range.lowerOpen;
                if (done) {
                  value = void 0;
                }
              }
            }
            return {
              done,
              value
            };
          }
        };
      }
    };
  }
}
class Index {
  deleted = false;
  // Initialized should be used to decide whether to throw an error or abort the versionchange transaction when there is a
  // constraint
  initialized = false;
  records = new RecordStore();
  constructor(rawObjectStore, name, keyPath, multiEntry, unique) {
    this.rawObjectStore = rawObjectStore;
    this.name = name;
    this.keyPath = keyPath;
    this.multiEntry = multiEntry;
    this.unique = unique;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-index
  getKey(key) {
    const record = this.records.get(key);
    return record !== void 0 ? record.value : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-referenced-values-from-an-index
  getAllKeys(range, count) {
    if (count === void 0 || count === 0) {
      count = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range)) {
      records.push(structuredCloneWrapper(record.value));
      if (records.length >= count) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#index-referenced-value-retrieval-operation
  getValue(key) {
    const record = this.records.get(key);
    return record !== void 0 ? this.rawObjectStore.getValue(record.value) : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-referenced-values-from-an-index
  getAllValues(range, count) {
    if (count === void 0 || count === 0) {
      count = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range)) {
      records.push(this.rawObjectStore.getValue(record.value));
      if (records.length >= count) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-storing-a-record-into-an-object-store (step 7)
  storeRecord(newRecord) {
    let indexKey;
    try {
      indexKey = extractKey(this.keyPath, newRecord.value);
    } catch (err) {
      if (err.name === "DataError") {
        return;
      }
      throw err;
    }
    if (!this.multiEntry || !Array.isArray(indexKey)) {
      try {
        valueToKey(indexKey);
      } catch (e2) {
        return;
      }
    } else {
      const keep = [];
      for (const part of indexKey) {
        if (keep.indexOf(part) < 0) {
          try {
            keep.push(valueToKey(part));
          } catch (err) {
          }
        }
      }
      indexKey = keep;
    }
    if (!this.multiEntry || !Array.isArray(indexKey)) {
      if (this.unique) {
        const existingRecord = this.records.get(indexKey);
        if (existingRecord) {
          throw new ConstraintError();
        }
      }
    } else {
      if (this.unique) {
        for (const individualIndexKey of indexKey) {
          const existingRecord = this.records.get(individualIndexKey);
          if (existingRecord) {
            throw new ConstraintError();
          }
        }
      }
    }
    if (!this.multiEntry || !Array.isArray(indexKey)) {
      this.records.add({
        key: indexKey,
        value: newRecord.key
      });
    } else {
      for (const individualIndexKey of indexKey) {
        this.records.add({
          key: individualIndexKey,
          value: newRecord.key
        });
      }
    }
  }
  initialize(transaction) {
    if (this.initialized) {
      throw new Error("Index already initialized");
    }
    transaction._execRequestAsync({
      operation: () => {
        try {
          for (const record of this.rawObjectStore.records.values()) {
            this.storeRecord(record);
          }
          this.initialized = true;
        } catch (err) {
          transaction._abort(err.name);
        }
      },
      source: null
    });
  }
}
const validateKeyPath = (keyPath, parent) => {
  if (keyPath !== void 0 && keyPath !== null && typeof keyPath !== "string" && keyPath.toString && (parent === "array" || !Array.isArray(keyPath))) {
    keyPath = keyPath.toString();
  }
  if (typeof keyPath === "string") {
    if (keyPath === "" && parent !== "string") {
      return;
    }
    try {
      const validIdentifierRegex = /^(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])(?:[\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])*$/;
      if (keyPath.length >= 1 && validIdentifierRegex.test(keyPath)) {
        return;
      }
    } catch (err) {
      throw new SyntaxError(err.message);
    }
    if (keyPath.indexOf(" ") >= 0) {
      throw new SyntaxError("The keypath argument contains an invalid key path (no spaces allowed).");
    }
  }
  if (Array.isArray(keyPath) && keyPath.length > 0) {
    if (parent) {
      throw new SyntaxError("The keypath argument contains an invalid key path (nested arrays).");
    }
    for (const part of keyPath) {
      validateKeyPath(part, "array");
    }
    return;
  } else if (typeof keyPath === "string" && keyPath.indexOf(".") >= 0) {
    keyPath = keyPath.split(".");
    for (const part of keyPath) {
      validateKeyPath(part, "string");
    }
    return;
  }
  throw new SyntaxError();
};
const confirmActiveTransaction = (objectStore) => {
  if (objectStore._rawObjectStore.deleted) {
    throw new InvalidStateError();
  }
  if (objectStore.transaction._state !== "active") {
    throw new TransactionInactiveError();
  }
};
const buildRecordAddPut = (objectStore, value, key) => {
  confirmActiveTransaction(objectStore);
  if (objectStore.transaction.mode === "readonly") {
    throw new ReadOnlyError();
  }
  if (objectStore.keyPath !== null) {
    if (key !== void 0) {
      throw new DataError();
    }
  }
  const clone2 = structuredCloneWrapper(value);
  if (objectStore.keyPath !== null) {
    const tempKey = extractKey(objectStore.keyPath, clone2);
    if (tempKey !== void 0) {
      valueToKey(tempKey);
    } else {
      if (!objectStore._rawObjectStore.keyGenerator) {
        throw new DataError();
      } else if (!canInjectKey(objectStore.keyPath, clone2)) {
        throw new DataError();
      }
    }
  }
  if (objectStore.keyPath === null && objectStore._rawObjectStore.keyGenerator === null && key === void 0) {
    throw new DataError();
  }
  if (key !== void 0) {
    key = valueToKey(key);
  }
  return {
    key,
    value: clone2
  };
};
class FDBObjectStore {
  _indexesCache = /* @__PURE__ */ new Map();
  constructor(transaction, rawObjectStore) {
    this._rawObjectStore = rawObjectStore;
    this._name = rawObjectStore.name;
    this.keyPath = rawObjectStore.keyPath;
    this.autoIncrement = rawObjectStore.autoIncrement;
    this.transaction = transaction;
    this.indexNames = new FakeDOMStringList(...Array.from(rawObjectStore.rawIndexes.keys()).sort());
  }
  get name() {
    return this._name;
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-name
  set name(name) {
    const transaction = this.transaction;
    if (!transaction.db._runningVersionchangeTransaction) {
      throw new InvalidStateError();
    }
    confirmActiveTransaction(this);
    name = String(name);
    if (name === this._name) {
      return;
    }
    if (this._rawObjectStore.rawDatabase.rawObjectStores.has(name)) {
      throw new ConstraintError();
    }
    const oldName = this._name;
    const oldObjectStoreNames = [...transaction.db.objectStoreNames];
    this._name = name;
    this._rawObjectStore.name = name;
    this.transaction._objectStoresCache.delete(oldName);
    this.transaction._objectStoresCache.set(name, this);
    this._rawObjectStore.rawDatabase.rawObjectStores.delete(oldName);
    this._rawObjectStore.rawDatabase.rawObjectStores.set(name, this._rawObjectStore);
    transaction.db.objectStoreNames = new FakeDOMStringList(...Array.from(this._rawObjectStore.rawDatabase.rawObjectStores.keys()).filter((objectStoreName) => {
      const objectStore = this._rawObjectStore.rawDatabase.rawObjectStores.get(objectStoreName);
      return objectStore && !objectStore.deleted;
    }).sort());
    const oldScope = new Set(transaction._scope);
    const oldTransactionObjectStoreNames = [...transaction.objectStoreNames];
    this.transaction._scope.delete(oldName);
    transaction._scope.add(name);
    transaction.objectStoreNames = new FakeDOMStringList(...Array.from(transaction._scope).sort());
    transaction._rollbackLog.push(() => {
      this._name = oldName;
      this._rawObjectStore.name = oldName;
      this.transaction._objectStoresCache.delete(name);
      this.transaction._objectStoresCache.set(oldName, this);
      this._rawObjectStore.rawDatabase.rawObjectStores.delete(name);
      this._rawObjectStore.rawDatabase.rawObjectStores.set(oldName, this._rawObjectStore);
      transaction.db.objectStoreNames = new FakeDOMStringList(...oldObjectStoreNames);
      transaction._scope = oldScope;
      transaction.objectStoreNames = new FakeDOMStringList(...oldTransactionObjectStoreNames);
    });
  }
  put(value, key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    const record = buildRecordAddPut(this, value, key);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, record, false, this.transaction._rollbackLog),
      source: this
    });
  }
  add(value, key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    const record = buildRecordAddPut(this, value, key);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, record, true, this.transaction._rollbackLog),
      source: this
    });
  }
  delete(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    confirmActiveTransaction(this);
    if (this.transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.deleteRecord.bind(this._rawObjectStore, key, this.transaction._rollbackLog),
      source: this
    });
  }
  get(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    confirmActiveTransaction(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getValue.bind(this._rawObjectStore, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getall
  getAll(query, count) {
    if (arguments.length > 1 && count !== void 0) {
      count = enforceRange(count, "unsigned long");
    }
    confirmActiveTransaction(this);
    const range = valueToKeyRange(query);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getAllValues.bind(this._rawObjectStore, range, count),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getkey
  getKey(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    confirmActiveTransaction(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getKey.bind(this._rawObjectStore, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getallkeys
  getAllKeys(query, count) {
    if (arguments.length > 1 && count !== void 0) {
      count = enforceRange(count, "unsigned long");
    }
    confirmActiveTransaction(this);
    const range = valueToKeyRange(query);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getAllKeys.bind(this._rawObjectStore, range, count),
      source: this
    });
  }
  clear() {
    confirmActiveTransaction(this);
    if (this.transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.clear.bind(this._rawObjectStore, this.transaction._rollbackLog),
      source: this
    });
  }
  openCursor(range, direction2) {
    confirmActiveTransaction(this);
    if (range === null) {
      range = void 0;
    }
    if (range !== void 0 && !(range instanceof FDBKeyRange)) {
      range = FDBKeyRange.only(valueToKey(range));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.transaction;
    const cursor2 = new FDBCursorWithValue(this, range, direction2, request);
    return this.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  openKeyCursor(range, direction2) {
    confirmActiveTransaction(this);
    if (range === null) {
      range = void 0;
    }
    if (range !== void 0 && !(range instanceof FDBKeyRange)) {
      range = FDBKeyRange.only(valueToKey(range));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.transaction;
    const cursor2 = new FDBCursor(this, range, direction2, request, true);
    return this.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBObjectStore-createIndex-IDBIndex-DOMString-name-DOMString-sequence-DOMString--keyPath-IDBIndexParameters-optionalParameters
  createIndex(name, keyPath, optionalParameters = {}) {
    if (arguments.length < 2) {
      throw new TypeError();
    }
    const multiEntry = optionalParameters.multiEntry !== void 0 ? optionalParameters.multiEntry : false;
    const unique = optionalParameters.unique !== void 0 ? optionalParameters.unique : false;
    if (this.transaction.mode !== "versionchange") {
      throw new InvalidStateError();
    }
    confirmActiveTransaction(this);
    if (this.indexNames.contains(name)) {
      throw new ConstraintError();
    }
    validateKeyPath(keyPath);
    if (Array.isArray(keyPath) && multiEntry) {
      throw new InvalidAccessError();
    }
    const indexNames = [...this.indexNames];
    this.transaction._rollbackLog.push(() => {
      const index22 = this._rawObjectStore.rawIndexes.get(name);
      if (index22) {
        index22.deleted = true;
      }
      this.indexNames = new FakeDOMStringList(...indexNames);
      this._rawObjectStore.rawIndexes.delete(name);
    });
    const index2 = new Index(this._rawObjectStore, name, keyPath, multiEntry, unique);
    this.indexNames._push(name);
    this.indexNames._sort();
    this._rawObjectStore.rawIndexes.set(name, index2);
    index2.initialize(this.transaction);
    return new FDBIndex(this, index2);
  }
  // https://w3c.github.io/IndexedDB/#dom-idbobjectstore-index
  index(name) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    if (this._rawObjectStore.deleted || this.transaction._state === "finished") {
      throw new InvalidStateError();
    }
    const index2 = this._indexesCache.get(name);
    if (index2 !== void 0) {
      return index2;
    }
    const rawIndex = this._rawObjectStore.rawIndexes.get(name);
    if (!this.indexNames.contains(name) || rawIndex === void 0) {
      throw new NotFoundError();
    }
    const index22 = new FDBIndex(this, rawIndex);
    this._indexesCache.set(name, index22);
    return index22;
  }
  deleteIndex(name) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    if (this.transaction.mode !== "versionchange") {
      throw new InvalidStateError();
    }
    confirmActiveTransaction(this);
    const rawIndex = this._rawObjectStore.rawIndexes.get(name);
    if (rawIndex === void 0) {
      throw new NotFoundError();
    }
    this.transaction._rollbackLog.push(() => {
      rawIndex.deleted = false;
      this._rawObjectStore.rawIndexes.set(name, rawIndex);
      this.indexNames._push(name);
      this.indexNames._sort();
    });
    this.indexNames = new FakeDOMStringList(...Array.from(this.indexNames).filter((indexName) => {
      return indexName !== name;
    }));
    rawIndex.deleted = true;
    this.transaction._execRequestAsync({
      operation: () => {
        const rawIndex2 = this._rawObjectStore.rawIndexes.get(name);
        if (rawIndex === rawIndex2) {
          this._rawObjectStore.rawIndexes.delete(name);
        }
      },
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBObjectStore-count-IDBRequest-any-key
  count(key) {
    confirmActiveTransaction(this);
    if (key === null) {
      key = void 0;
    }
    if (key !== void 0 && !(key instanceof FDBKeyRange)) {
      key = FDBKeyRange.only(valueToKey(key));
    }
    return this.transaction._execRequestAsync({
      operation: () => {
        let count = 0;
        const cursor2 = new FDBCursor(this, key);
        while (cursor2._iterate() !== null) {
          count += 1;
        }
        return count;
      },
      source: this
    });
  }
  toString() {
    return "[object IDBObjectStore]";
  }
}
const FDBObjectStore$1 = FDBObjectStore;
let Event$1 = class Event2 {
  eventPath = [];
  NONE = 0;
  CAPTURING_PHASE = 1;
  AT_TARGET = 2;
  BUBBLING_PHASE = 3;
  // Flags
  propagationStopped = false;
  immediatePropagationStopped = false;
  canceled = false;
  initialized = true;
  dispatched = false;
  target = null;
  currentTarget = null;
  eventPhase = 0;
  defaultPrevented = false;
  isTrusted = false;
  timeStamp = Date.now();
  constructor(type2, eventInitDict = {}) {
    this.type = type2;
    this.bubbles = eventInitDict.bubbles !== void 0 ? eventInitDict.bubbles : false;
    this.cancelable = eventInitDict.cancelable !== void 0 ? eventInitDict.cancelable : false;
  }
  preventDefault() {
    if (this.cancelable) {
      this.canceled = true;
    }
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
  stopImmediatePropagation() {
    this.propagationStopped = true;
    this.immediatePropagationStopped = true;
  }
};
function getSetImmediateFromJsdom() {
  if (typeof navigator !== "undefined" && /jsdom/.test(navigator.userAgent)) {
    const outerRealmFunctionConstructor = Node.constructor;
    return new outerRealmFunctionConstructor("return setImmediate")();
  } else {
    return void 0;
  }
}
const queueTask = globalThis.setImmediate || getSetImmediateFromJsdom() || ((fn3) => setTimeout(fn3, 0));
class FDBTransaction extends FakeEventTarget {
  _state = "active";
  _started = false;
  _rollbackLog = [];
  _objectStoresCache = /* @__PURE__ */ new Map();
  error = null;
  onabort = null;
  oncomplete = null;
  onerror = null;
  _requests = [];
  constructor(storeNames, mode, db2) {
    super();
    this._scope = new Set(storeNames);
    this.mode = mode;
    this.db = db2;
    this.objectStoreNames = new FakeDOMStringList(...Array.from(this._scope).sort());
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-aborting-a-transaction
  _abort(errName) {
    for (const f2 of this._rollbackLog.reverse()) {
      f2();
    }
    if (errName !== null) {
      const e2 = new Error();
      e2.name = errName;
      this.error = e2;
    }
    for (const {
      request
    } of this._requests) {
      if (request.readyState !== "done") {
        request.readyState = "done";
        if (request.source) {
          request.result = void 0;
          request.error = new AbortError();
          const event = new Event$1("error", {
            bubbles: true,
            cancelable: true
          });
          event.eventPath = [this.db, this];
          request.dispatchEvent(event);
        }
      }
    }
    queueTask(() => {
      const event = new Event$1("abort", {
        bubbles: true,
        cancelable: false
      });
      event.eventPath = [this.db];
      this.dispatchEvent(event);
    });
    this._state = "finished";
  }
  abort() {
    if (this._state === "committing" || this._state === "finished") {
      throw new InvalidStateError();
    }
    this._state = "active";
    this._abort(null);
  }
  // http://w3c.github.io/IndexedDB/#dom-idbtransaction-objectstore
  objectStore(name) {
    if (this._state !== "active") {
      throw new InvalidStateError();
    }
    const objectStore = this._objectStoresCache.get(name);
    if (objectStore !== void 0) {
      return objectStore;
    }
    const rawObjectStore = this.db._rawDatabase.rawObjectStores.get(name);
    if (!this._scope.has(name) || rawObjectStore === void 0) {
      throw new NotFoundError();
    }
    const objectStore2 = new FDBObjectStore$1(this, rawObjectStore);
    this._objectStoresCache.set(name, objectStore2);
    return objectStore2;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-asynchronously-executing-a-request
  _execRequestAsync(obj) {
    const source = obj.source;
    const operation = obj.operation;
    let request = obj.hasOwnProperty("request") ? obj.request : null;
    if (this._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (!request) {
      if (!source) {
        request = new FDBRequest();
      } else {
        request = new FDBRequest();
        request.source = source;
        request.transaction = source.transaction;
      }
    }
    this._requests.push({
      operation,
      request
    });
    return request;
  }
  _start() {
    this._started = true;
    let operation;
    let request;
    while (this._requests.length > 0) {
      const r2 = this._requests.shift();
      if (r2 && r2.request.readyState !== "done") {
        request = r2.request;
        operation = r2.operation;
        break;
      }
    }
    if (request && operation) {
      if (!request.source) {
        operation();
      } else {
        let defaultAction;
        let event;
        try {
          const result = operation();
          request.readyState = "done";
          request.result = result;
          request.error = void 0;
          if (this._state === "inactive") {
            this._state = "active";
          }
          event = new Event$1("success", {
            bubbles: false,
            cancelable: false
          });
        } catch (err) {
          request.readyState = "done";
          request.result = void 0;
          request.error = err;
          if (this._state === "inactive") {
            this._state = "active";
          }
          event = new Event$1("error", {
            bubbles: true,
            cancelable: true
          });
          defaultAction = this._abort.bind(this, err.name);
        }
        try {
          event.eventPath = [this.db, this];
          request.dispatchEvent(event);
        } catch (err) {
          if (this._state !== "committing") {
            this._abort("AbortError");
          }
          throw err;
        }
        if (!event.canceled) {
          if (defaultAction) {
            defaultAction();
          }
        }
      }
      queueTask(this._start.bind(this));
      return;
    }
    if (this._state !== "finished") {
      this._state = "finished";
      if (!this.error) {
        const event = new Event$1("complete");
        this.dispatchEvent(event);
      }
    }
  }
  commit() {
    if (this._state !== "active") {
      throw new InvalidStateError();
    }
    this._state = "committing";
  }
  toString() {
    return "[object IDBRequest]";
  }
}
const MAX_KEY = 9007199254740992;
class KeyGenerator {
  // This is kind of wrong. Should start at 1 and increment only after record is saved
  num = 0;
  next() {
    if (this.num >= MAX_KEY) {
      throw new ConstraintError();
    }
    this.num += 1;
    return this.num;
  }
  // https://w3c.github.io/IndexedDB/#possibly-update-the-key-generator
  setIfLarger(num) {
    const value = Math.floor(Math.min(num, MAX_KEY)) - 1;
    if (value >= this.num) {
      this.num = value + 1;
    }
  }
}
class ObjectStore {
  deleted = false;
  records = new RecordStore();
  rawIndexes = /* @__PURE__ */ new Map();
  constructor(rawDatabase, name, keyPath, autoIncrement) {
    this.rawDatabase = rawDatabase;
    this.keyGenerator = autoIncrement === true ? new KeyGenerator() : null;
    this.deleted = false;
    this.name = name;
    this.keyPath = keyPath;
    this.autoIncrement = autoIncrement;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-object-store
  getKey(key) {
    const record = this.records.get(key);
    return record !== void 0 ? structuredCloneWrapper(record.key) : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-keys-from-an-object-store
  getAllKeys(range, count) {
    if (count === void 0 || count === 0) {
      count = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range)) {
      records.push(structuredCloneWrapper(record.key));
      if (records.length >= count) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-object-store
  getValue(key) {
    const record = this.records.get(key);
    return record !== void 0 ? structuredCloneWrapper(record.value) : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-values-from-an-object-store
  getAllValues(range, count) {
    if (count === void 0 || count === 0) {
      count = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range)) {
      records.push(structuredCloneWrapper(record.value));
      if (records.length >= count) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-storing-a-record-into-an-object-store
  storeRecord(newRecord, noOverwrite, rollbackLog) {
    if (this.keyPath !== null) {
      const key = extractKey(this.keyPath, newRecord.value);
      if (key !== void 0) {
        newRecord.key = key;
      }
    }
    if (this.keyGenerator !== null && newRecord.key === void 0) {
      if (rollbackLog) {
        const keyGeneratorBefore = this.keyGenerator.num;
        rollbackLog.push(() => {
          if (this.keyGenerator) {
            this.keyGenerator.num = keyGeneratorBefore;
          }
        });
      }
      newRecord.key = this.keyGenerator.next();
      if (this.keyPath !== null) {
        if (Array.isArray(this.keyPath)) {
          throw new Error("Cannot have an array key path in an object store with a key generator");
        }
        let remainingKeyPath = this.keyPath;
        let object2 = newRecord.value;
        let identifier2;
        let i2 = 0;
        while (i2 >= 0) {
          if (typeof object2 !== "object") {
            throw new DataError();
          }
          i2 = remainingKeyPath.indexOf(".");
          if (i2 >= 0) {
            identifier2 = remainingKeyPath.slice(0, i2);
            remainingKeyPath = remainingKeyPath.slice(i2 + 1);
            if (!object2.hasOwnProperty(identifier2)) {
              object2[identifier2] = {};
            }
            object2 = object2[identifier2];
          }
        }
        identifier2 = remainingKeyPath;
        object2[identifier2] = newRecord.key;
      }
    } else if (this.keyGenerator !== null && typeof newRecord.key === "number") {
      this.keyGenerator.setIfLarger(newRecord.key);
    }
    const existingRecord = this.records.get(newRecord.key);
    if (existingRecord) {
      if (noOverwrite) {
        throw new ConstraintError();
      }
      this.deleteRecord(newRecord.key, rollbackLog);
    }
    this.records.add(newRecord);
    if (rollbackLog) {
      rollbackLog.push(() => {
        this.deleteRecord(newRecord.key);
      });
    }
    for (const rawIndex of this.rawIndexes.values()) {
      if (rawIndex.initialized) {
        rawIndex.storeRecord(newRecord);
      }
    }
    return newRecord.key;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-deleting-records-from-an-object-store
  deleteRecord(key, rollbackLog) {
    const deletedRecords = this.records.delete(key);
    if (rollbackLog) {
      for (const record of deletedRecords) {
        rollbackLog.push(() => {
          this.storeRecord(record, true);
        });
      }
    }
    for (const rawIndex of this.rawIndexes.values()) {
      rawIndex.records.deleteByValue(key);
    }
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-clearing-an-object-store
  clear(rollbackLog) {
    const deletedRecords = this.records.clear();
    if (rollbackLog) {
      for (const record of deletedRecords) {
        rollbackLog.push(() => {
          this.storeRecord(record, true);
        });
      }
    }
    for (const rawIndex of this.rawIndexes.values()) {
      rawIndex.records.clear();
    }
  }
}
const confirmActiveVersionchangeTransaction = (database) => {
  if (!database._runningVersionchangeTransaction) {
    throw new InvalidStateError();
  }
  const transactions = database._rawDatabase.transactions.filter((tx) => {
    return tx.mode === "versionchange";
  });
  const transaction = transactions[transactions.length - 1];
  if (!transaction || transaction._state === "finished") {
    throw new InvalidStateError();
  }
  if (transaction._state !== "active") {
    throw new TransactionInactiveError();
  }
  return transaction;
};
const closeConnection = (connection) => {
  connection._closePending = true;
  const transactionsComplete = connection._rawDatabase.transactions.every((transaction) => {
    return transaction._state === "finished";
  });
  if (transactionsComplete) {
    connection._closed = true;
    connection._rawDatabase.connections = connection._rawDatabase.connections.filter((otherConnection) => {
      return connection !== otherConnection;
    });
  } else {
    queueTask(() => {
      closeConnection(connection);
    });
  }
};
class FDBDatabase extends FakeEventTarget {
  _closePending = false;
  _closed = false;
  _runningVersionchangeTransaction = false;
  constructor(rawDatabase) {
    super();
    this._rawDatabase = rawDatabase;
    this._rawDatabase.connections.push(this);
    this.name = rawDatabase.name;
    this.version = rawDatabase.version;
    this.objectStoreNames = new FakeDOMStringList(...Array.from(rawDatabase.rawObjectStores.keys()).sort());
  }
  // http://w3c.github.io/IndexedDB/#dom-idbdatabase-createobjectstore
  createObjectStore(name, options = {}) {
    if (name === void 0) {
      throw new TypeError();
    }
    const transaction = confirmActiveVersionchangeTransaction(this);
    const keyPath = options !== null && options.keyPath !== void 0 ? options.keyPath : null;
    const autoIncrement = options !== null && options.autoIncrement !== void 0 ? options.autoIncrement : false;
    if (keyPath !== null) {
      validateKeyPath(keyPath);
    }
    if (this._rawDatabase.rawObjectStores.has(name)) {
      throw new ConstraintError();
    }
    if (autoIncrement && (keyPath === "" || Array.isArray(keyPath))) {
      throw new InvalidAccessError();
    }
    const objectStoreNames = [...this.objectStoreNames];
    transaction._rollbackLog.push(() => {
      const objectStore = this._rawDatabase.rawObjectStores.get(name);
      if (objectStore) {
        objectStore.deleted = true;
      }
      this.objectStoreNames = new FakeDOMStringList(...objectStoreNames);
      transaction._scope.delete(name);
      this._rawDatabase.rawObjectStores.delete(name);
    });
    const rawObjectStore = new ObjectStore(this._rawDatabase, name, keyPath, autoIncrement);
    this.objectStoreNames._push(name);
    this.objectStoreNames._sort();
    transaction._scope.add(name);
    this._rawDatabase.rawObjectStores.set(name, rawObjectStore);
    transaction.objectStoreNames = new FakeDOMStringList(...this.objectStoreNames);
    return transaction.objectStore(name);
  }
  deleteObjectStore(name) {
    if (name === void 0) {
      throw new TypeError();
    }
    const transaction = confirmActiveVersionchangeTransaction(this);
    const store2 = this._rawDatabase.rawObjectStores.get(name);
    if (store2 === void 0) {
      throw new NotFoundError();
    }
    this.objectStoreNames = new FakeDOMStringList(...Array.from(this.objectStoreNames).filter((objectStoreName) => {
      return objectStoreName !== name;
    }));
    transaction.objectStoreNames = new FakeDOMStringList(...this.objectStoreNames);
    transaction._rollbackLog.push(() => {
      store2.deleted = false;
      this._rawDatabase.rawObjectStores.set(name, store2);
      this.objectStoreNames._push(name);
      this.objectStoreNames._sort();
    });
    store2.deleted = true;
    this._rawDatabase.rawObjectStores.delete(name);
    transaction._objectStoresCache.delete(name);
  }
  transaction(storeNames, mode) {
    mode = mode !== void 0 ? mode : "readonly";
    if (mode !== "readonly" && mode !== "readwrite" && mode !== "versionchange") {
      throw new TypeError("Invalid mode: " + mode);
    }
    const hasActiveVersionchange = this._rawDatabase.transactions.some((transaction) => {
      return transaction._state === "active" && transaction.mode === "versionchange" && transaction.db === this;
    });
    if (hasActiveVersionchange) {
      throw new InvalidStateError();
    }
    if (this._closePending) {
      throw new InvalidStateError();
    }
    if (!Array.isArray(storeNames)) {
      storeNames = [storeNames];
    }
    if (storeNames.length === 0 && mode !== "versionchange") {
      throw new InvalidAccessError();
    }
    for (const storeName of storeNames) {
      if (!this.objectStoreNames.contains(storeName)) {
        throw new NotFoundError("No objectStore named " + storeName + " in this database");
      }
    }
    const tx = new FDBTransaction(storeNames, mode, this);
    this._rawDatabase.transactions.push(tx);
    this._rawDatabase.processTransactions();
    return tx;
  }
  close() {
    closeConnection(this);
  }
  toString() {
    return "[object IDBDatabase]";
  }
}
class FDBOpenDBRequest extends FDBRequest {
  onupgradeneeded = null;
  onblocked = null;
  toString() {
    return "[object IDBOpenDBRequest]";
  }
}
class FDBVersionChangeEvent extends Event$1 {
  constructor(type2, parameters = {}) {
    super(type2);
    this.newVersion = parameters.newVersion !== void 0 ? parameters.newVersion : null;
    this.oldVersion = parameters.oldVersion !== void 0 ? parameters.oldVersion : 0;
  }
  toString() {
    return "[object IDBVersionChangeEvent]";
  }
}
class Database {
  deletePending = false;
  transactions = [];
  rawObjectStores = /* @__PURE__ */ new Map();
  connections = [];
  constructor(name, version) {
    this.name = name;
    this.version = version;
    this.processTransactions = this.processTransactions.bind(this);
  }
  processTransactions() {
    queueTask(() => {
      const anyRunning = this.transactions.some((transaction) => {
        return transaction._started && transaction._state !== "finished";
      });
      if (!anyRunning) {
        const next2 = this.transactions.find((transaction) => {
          return !transaction._started && transaction._state !== "finished";
        });
        if (next2) {
          next2.addEventListener("complete", this.processTransactions);
          next2.addEventListener("abort", this.processTransactions);
          next2._start();
        }
      }
    });
  }
}
const waitForOthersClosedDelete = (databases, name, openDatabases, cb2) => {
  const anyOpen = openDatabases.some((openDatabase2) => {
    return !openDatabase2._closed && !openDatabase2._closePending;
  });
  if (anyOpen) {
    queueTask(() => waitForOthersClosedDelete(databases, name, openDatabases, cb2));
    return;
  }
  databases.delete(name);
  cb2(null);
};
const deleteDatabase = (databases, name, request, cb2) => {
  try {
    const db2 = databases.get(name);
    if (db2 === void 0) {
      cb2(null);
      return;
    }
    db2.deletePending = true;
    const openDatabases = db2.connections.filter((connection) => {
      return !connection._closed && !connection._closePending;
    });
    for (const openDatabase2 of openDatabases) {
      if (!openDatabase2._closePending) {
        const event = new FDBVersionChangeEvent("versionchange", {
          newVersion: null,
          oldVersion: db2.version
        });
        openDatabase2.dispatchEvent(event);
      }
    }
    const anyOpen = openDatabases.some((openDatabase3) => {
      return !openDatabase3._closed && !openDatabase3._closePending;
    });
    if (request && anyOpen) {
      const event = new FDBVersionChangeEvent("blocked", {
        newVersion: null,
        oldVersion: db2.version
      });
      request.dispatchEvent(event);
    }
    waitForOthersClosedDelete(databases, name, openDatabases, cb2);
  } catch (err) {
    cb2(err);
  }
};
const runVersionchangeTransaction = (connection, version, request, cb2) => {
  connection._runningVersionchangeTransaction = true;
  const oldVersion = connection.version;
  const openDatabases = connection._rawDatabase.connections.filter((otherDatabase) => {
    return connection !== otherDatabase;
  });
  for (const openDatabase2 of openDatabases) {
    if (!openDatabase2._closed && !openDatabase2._closePending) {
      const event = new FDBVersionChangeEvent("versionchange", {
        newVersion: version,
        oldVersion
      });
      openDatabase2.dispatchEvent(event);
    }
  }
  const anyOpen = openDatabases.some((openDatabase3) => {
    return !openDatabase3._closed && !openDatabase3._closePending;
  });
  if (anyOpen) {
    const event = new FDBVersionChangeEvent("blocked", {
      newVersion: version,
      oldVersion
    });
    request.dispatchEvent(event);
  }
  const waitForOthersClosed = () => {
    const anyOpen2 = openDatabases.some((openDatabase2) => {
      return !openDatabase2._closed && !openDatabase2._closePending;
    });
    if (anyOpen2) {
      queueTask(waitForOthersClosed);
      return;
    }
    connection._rawDatabase.version = version;
    connection.version = version;
    const transaction = connection.transaction(connection.objectStoreNames, "versionchange");
    request.result = connection;
    request.readyState = "done";
    request.transaction = transaction;
    transaction._rollbackLog.push(() => {
      connection._rawDatabase.version = oldVersion;
      connection.version = oldVersion;
    });
    const event = new FDBVersionChangeEvent("upgradeneeded", {
      newVersion: version,
      oldVersion
    });
    request.dispatchEvent(event);
    transaction.addEventListener("error", () => {
      connection._runningVersionchangeTransaction = false;
    });
    transaction.addEventListener("abort", () => {
      connection._runningVersionchangeTransaction = false;
      request.transaction = null;
      queueTask(() => {
        cb2(new AbortError());
      });
    });
    transaction.addEventListener("complete", () => {
      connection._runningVersionchangeTransaction = false;
      request.transaction = null;
      queueTask(() => {
        if (connection._closePending) {
          cb2(new AbortError());
        } else {
          cb2(null);
        }
      });
    });
  };
  waitForOthersClosed();
};
const openDatabase = (databases, name, version, request, cb2) => {
  let db2 = databases.get(name);
  if (db2 === void 0) {
    db2 = new Database(name, 0);
    databases.set(name, db2);
  }
  if (version === void 0) {
    version = db2.version !== 0 ? db2.version : 1;
  }
  if (db2.version > version) {
    return cb2(new VersionError());
  }
  const connection = new FDBDatabase(db2);
  if (db2.version < version) {
    runVersionchangeTransaction(connection, version, request, (err) => {
      if (err) {
        return cb2(err);
      }
      cb2(null, connection);
    });
  } else {
    cb2(null, connection);
  }
};
class FDBFactory {
  cmp = cmp;
  _databases = /* @__PURE__ */ new Map();
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBFactory-deleteDatabase-IDBOpenDBRequest-DOMString-name
  deleteDatabase(name) {
    const request = new FDBOpenDBRequest();
    request.source = null;
    queueTask(() => {
      const db2 = this._databases.get(name);
      const oldVersion = db2 !== void 0 ? db2.version : 0;
      deleteDatabase(this._databases, name, request, (err) => {
        if (err) {
          request.error = new Error();
          request.error.name = err.name;
          request.readyState = "done";
          const event = new Event$1("error", {
            bubbles: true,
            cancelable: true
          });
          event.eventPath = [];
          request.dispatchEvent(event);
          return;
        }
        request.result = void 0;
        request.readyState = "done";
        const event2 = new FDBVersionChangeEvent("success", {
          newVersion: null,
          oldVersion
        });
        request.dispatchEvent(event2);
      });
    });
    return request;
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBFactory-open-IDBOpenDBRequest-DOMString-name-unsigned-long-long-version
  open(name, version) {
    if (arguments.length > 1 && version !== void 0) {
      version = enforceRange(version, "MAX_SAFE_INTEGER");
    }
    if (version === 0) {
      throw new TypeError();
    }
    const request = new FDBOpenDBRequest();
    request.source = null;
    queueTask(() => {
      openDatabase(this._databases, name, version, request, (err, connection) => {
        if (err) {
          request.result = void 0;
          request.readyState = "done";
          request.error = new Error();
          request.error.name = err.name;
          const event = new Event$1("error", {
            bubbles: true,
            cancelable: true
          });
          event.eventPath = [];
          request.dispatchEvent(event);
          return;
        }
        request.result = connection;
        request.readyState = "done";
        const event2 = new Event$1("success");
        event2.eventPath = [];
        request.dispatchEvent(event2);
      });
    });
    return request;
  }
  // https://w3c.github.io/IndexedDB/#dom-idbfactory-databases
  databases() {
    return new Promise((resolve2) => {
      const result = [];
      for (const [name, database] of this._databases) {
        result.push({
          name,
          version: database.version
        });
      }
      resolve2(result);
    });
  }
  toString() {
    return "[object IDBFactory]";
  }
}
const fakeIndexedDB = new FDBFactory();
function _typeof$1(o2) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$1(o2);
}
function _toPrimitive(input, hint) {
  if (_typeof$1(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$1(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function lastOfArray$1(ar) {
  return ar[ar.length - 1];
}
function toArray$1(input) {
  return Array.isArray(input) ? input.slice(0) : [input];
}
function isMaybeReadonlyArray(x2) {
  return Array.isArray(x2);
}
function arrayFilterNotEmpty(value) {
  if (value === null || value === void 0) {
    return false;
  }
  return true;
}
function countUntilNotMatching(ar, matchingFn) {
  var count = 0;
  var idx = -1;
  for (var _item of ar) {
    idx = idx + 1;
    var matching = matchingFn(_item, idx);
    if (matching) {
      count = count + 1;
    } else {
      break;
    }
  }
  return count;
}
function appendToArray(ar, add) {
  var amount = add.length;
  for (var i2 = 0; i2 < amount; ++i2) {
    var element = add[i2];
    ar.push(element);
  }
}
function parseRevision(revision) {
  var split2 = revision.split("-");
  if (split2.length !== 2) {
    throw new Error("malformatted revision: " + revision);
  }
  return {
    height: parseInt(split2[0], 10),
    hash: split2[1]
  };
}
function getHeightOfRevision(revision) {
  var ret = parseInt(revision.split("-")[0], 10);
  return ret;
}
function createRevision(databaseInstanceToken, previousDocData) {
  var previousRevision = previousDocData ? previousDocData._rev : null;
  var previousRevisionHeight = previousRevision ? parseRevision(previousRevision).height : 0;
  var newRevisionHeight = previousRevisionHeight + 1;
  return newRevisionHeight + "-" + databaseInstanceToken;
}
var RX_META_LWT_MINIMUM = 1;
function getDefaultRxDocumentMeta() {
  return {
    /**
     * Set this to 1 to not waste performance
     * while calling new Date()..
     * The storage wrappers will anyway update
     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()
     */
    lwt: RX_META_LWT_MINIMUM
  };
}
function getDefaultRevision() {
  return "";
}
function stripMetaDataFromDocument(docData) {
  return Object.assign({}, docData, {
    _meta: void 0,
    _deleted: void 0,
    _rev: void 0
  });
}
function areRxDocumentArraysEqual(primaryPath, ar1, ar2) {
  if (ar1.length !== ar2.length) {
    return false;
  }
  var i2 = 0;
  var len = ar1.length;
  while (i2 < len) {
    var row1 = ar1[i2];
    var row2 = ar2[i2];
    i2++;
    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {
      return false;
    }
  }
  return true;
}
function getSortDocumentsByLastWriteTimeComparator(primaryPath) {
  return (a2, b2) => {
    if (a2._meta.lwt === b2._meta.lwt) {
      if (b2[primaryPath] < a2[primaryPath]) {
        return 1;
      } else {
        return -1;
      }
    } else {
      return a2._meta.lwt - b2._meta.lwt;
    }
  };
}
function sortDocumentsByLastWriteTime(primaryPath, docs) {
  return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));
}
class WordArray {
  constructor(words2, sigBytes) {
    words2 = this.words = words2 || [];
    this.sigBytes = sigBytes === void 0 ? words2.length * 4 : sigBytes;
  }
  toString(encoder) {
    return (encoder || Hex).stringify(this);
  }
  concat(wordArray) {
    this.clamp();
    if (this.sigBytes % 4) {
      for (let i2 = 0; i2 < wordArray.sigBytes; i2++) {
        const thatByte = wordArray.words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
        this.words[this.sigBytes + i2 >>> 2] |= thatByte << 24 - (this.sigBytes + i2) % 4 * 8;
      }
    } else {
      for (let j2 = 0; j2 < wordArray.sigBytes; j2 += 4) {
        this.words[this.sigBytes + j2 >>> 2] = wordArray.words[j2 >>> 2];
      }
    }
    this.sigBytes += wordArray.sigBytes;
    return this;
  }
  clamp() {
    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;
    this.words.length = Math.ceil(this.sigBytes / 4);
  }
  clone() {
    return new WordArray([...this.words]);
  }
}
const Hex = {
  stringify(wordArray) {
    const hexChars = [];
    for (let i2 = 0; i2 < wordArray.sigBytes; i2++) {
      const bite = wordArray.words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));
    }
    return hexChars.join("");
  }
};
const Latin1 = {
  parse(latin1Str) {
    const latin1StrLength = latin1Str.length;
    const words2 = [];
    for (let i2 = 0; i2 < latin1StrLength; i2++) {
      words2[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
    }
    return new WordArray(words2, latin1StrLength);
  }
};
const Utf8 = {
  parse(utf8Str) {
    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  }
};
class BufferedBlockAlgorithm {
  constructor() {
    this._data = new WordArray();
    this._nDataBytes = 0;
    this._minBufferSize = 0;
    this.blockSize = 512 / 32;
  }
  reset() {
    this._data = new WordArray();
    this._nDataBytes = 0;
  }
  _append(data) {
    if (typeof data === "string") {
      data = Utf8.parse(data);
    }
    this._data.concat(data);
    this._nDataBytes += data.sigBytes;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _doProcessBlock(_dataWords, _offset) {
  }
  _process(doFlush) {
    let processedWords;
    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);
    if (doFlush) {
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }
    const nWordsReady = nBlocksReady * this.blockSize;
    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);
    if (nWordsReady) {
      for (let offset2 = 0; offset2 < nWordsReady; offset2 += this.blockSize) {
        this._doProcessBlock(this._data.words, offset2);
      }
      processedWords = this._data.words.splice(0, nWordsReady);
      this._data.sigBytes -= nBytesReady;
    }
    return new WordArray(processedWords, nBytesReady);
  }
}
class Hasher extends BufferedBlockAlgorithm {
  update(messageUpdate) {
    this._append(messageUpdate);
    this._process();
    return this;
  }
  finalize(messageUpdate) {
    if (messageUpdate) {
      this._append(messageUpdate);
    }
  }
}
const H$2 = [
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
];
const K$2 = [
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
];
const W$3 = [];
class SHA256 extends Hasher {
  constructor() {
    super(...arguments);
    this._hash = new WordArray([...H$2]);
  }
  reset() {
    super.reset();
    this._hash = new WordArray([...H$2]);
  }
  _doProcessBlock(M2, offset2) {
    const H22 = this._hash.words;
    let a2 = H22[0];
    let b2 = H22[1];
    let c2 = H22[2];
    let d2 = H22[3];
    let e2 = H22[4];
    let f2 = H22[5];
    let g2 = H22[6];
    let h2 = H22[7];
    for (let i2 = 0; i2 < 64; i2++) {
      if (i2 < 16) {
        W$3[i2] = M2[offset2 + i2] | 0;
      } else {
        const gamma0x = W$3[i2 - 15];
        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
        const gamma1x = W$3[i2 - 2];
        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
        W$3[i2] = gamma0 + W$3[i2 - 7] + gamma1 + W$3[i2 - 16];
      }
      const ch2 = e2 & f2 ^ ~e2 & g2;
      const maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
      const sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
      const sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
      const t1 = h2 + sigma1 + ch2 + K$2[i2] + W$3[i2];
      const t22 = sigma0 + maj;
      h2 = g2;
      g2 = f2;
      f2 = e2;
      e2 = d2 + t1 | 0;
      d2 = c2;
      c2 = b2;
      b2 = a2;
      a2 = t1 + t22 | 0;
    }
    H22[0] = H22[0] + a2 | 0;
    H22[1] = H22[1] + b2 | 0;
    H22[2] = H22[2] + c2 | 0;
    H22[3] = H22[3] + d2 | 0;
    H22[4] = H22[4] + e2 | 0;
    H22[5] = H22[5] + f2 | 0;
    H22[6] = H22[6] + g2 | 0;
    H22[7] = H22[7] + h2 | 0;
  }
  finalize(messageUpdate) {
    super.finalize(messageUpdate);
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = this._data.sigBytes * 8;
    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(
      nBitsTotal / 4294967296
    );
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
    this._data.sigBytes = this._data.words.length * 4;
    this._process();
    return this._hash;
  }
}
function sha256(message) {
  return new SHA256().finalize(message).toString();
}
function defaultHashSha256(input) {
  return sha256(input);
}
function nextTick() {
  return new Promise((res) => setTimeout(res, 0));
}
function promiseWait(ms = 0) {
  return new Promise((res) => setTimeout(res, ms));
}
Promise.resolve(true);
var PROMISE_RESOLVE_FALSE = Promise.resolve(false);
var PROMISE_RESOLVE_NULL = Promise.resolve(null);
var PROMISE_RESOLVE_VOID = Promise.resolve();
var idlePromiseQueue = PROMISE_RESOLVE_VOID;
function requestIdlePromise(timeout = void 0) {
  idlePromiseQueue = idlePromiseQueue.then(() => {
    if (typeof requestIdleCallback === "function") {
      return new Promise((res) => {
        requestIdleCallback(() => res(), {
          timeout
        });
      });
    } else {
      return promiseWait(0);
    }
  });
  return idlePromiseQueue;
}
function promiseSeries(tasks, initial) {
  return tasks.reduce((current, next2) => current.then(next2), Promise.resolve(initial));
}
function randomCouchString(length2 = 10) {
  var text = "";
  var possible = "abcdefghijklmnopqrstuvwxyz";
  for (var i2 = 0; i2 < length2; i2++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
function ucfirst(str) {
  str += "";
  var f2 = str.charAt(0).toUpperCase();
  return f2 + str.substr(1);
}
function trimDots(str) {
  while (str.charAt(0) === ".") {
    str = str.substr(1);
  }
  while (str.slice(-1) === ".") {
    str = str.slice(0, -1);
  }
  return str;
}
function deepEqual$1(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length2;
    var i2;
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 !== b2.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!deepEqual$1(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    var keys3 = Object.keys(a2);
    length2 = keys3.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys3[i2]))
        return false;
    for (i2 = length2; i2-- !== 0; ) {
      var key = keys3[i2];
      if (!deepEqual$1(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
var isObject$6 = (value) => {
  var type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
var disallowedKeys = /* @__PURE__ */ new Set(["__proto__", "prototype", "constructor"]);
var digits = new Set("0123456789");
function getPathSegments(path) {
  var parts = [];
  var currentSegment = "";
  var currentPart = "start";
  var isIgnoring = false;
  for (var character2 of path) {
    switch (character2) {
      case "\\": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (isIgnoring) {
          currentSegment += character2;
        }
        currentPart = "property";
        isIgnoring = !isIgnoring;
        break;
      }
      case ".": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "property";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character2;
          break;
        }
        if (disallowedKeys.has(currentSegment)) {
          return [];
        }
        parts.push(currentSegment);
        currentSegment = "";
        currentPart = "property";
        break;
      }
      case "[": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "index";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character2;
          break;
        }
        if (currentPart === "property") {
          if (disallowedKeys.has(currentSegment)) {
            return [];
          }
          parts.push(currentSegment);
          currentSegment = "";
        }
        currentPart = "index";
        break;
      }
      case "]": {
        if (currentPart === "index") {
          parts.push(Number.parseInt(currentSegment, 10));
          currentSegment = "";
          currentPart = "indexEnd";
          break;
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
      }
      default: {
        if (currentPart === "index" && !digits.has(character2)) {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (currentPart === "start") {
          currentPart = "property";
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += "\\";
        }
        currentSegment += character2;
      }
    }
  }
  if (isIgnoring) {
    currentSegment += "\\";
  }
  switch (currentPart) {
    case "property": {
      if (disallowedKeys.has(currentSegment)) {
        return [];
      }
      parts.push(currentSegment);
      break;
    }
    case "index": {
      throw new Error("Index was not closed");
    }
    case "start": {
      parts.push("");
      break;
    }
  }
  return parts;
}
function isStringIndex$1(object2, key) {
  if (typeof key !== "number" && Array.isArray(object2)) {
    var index2 = Number.parseInt(key, 10);
    return Number.isInteger(index2) && object2[index2] === object2[key];
  }
  return false;
}
function getProperty$1(object2, path, value) {
  if (Array.isArray(path)) {
    path = path.join(".");
  }
  if (!isObject$6(object2) || typeof path !== "string") {
    return value === void 0 ? object2 : value;
  }
  var pathArray = getPathSegments(path);
  if (pathArray.length === 0) {
    return value;
  }
  for (var index2 = 0; index2 < pathArray.length; index2++) {
    var key = pathArray[index2];
    if (isStringIndex$1(object2, key)) {
      object2 = index2 === pathArray.length - 1 ? void 0 : null;
    } else {
      object2 = object2[key];
    }
    if (object2 === void 0 || object2 === null) {
      if (index2 !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object2 === void 0 ? value : object2;
}
function objectPathMonad(objectPath) {
  var split2 = objectPath.split(".");
  var splitLength = split2.length;
  if (splitLength === 1) {
    return (obj) => obj[objectPath];
  }
  return (obj) => {
    var currentVal = obj;
    for (var i2 = 0; i2 < splitLength; ++i2) {
      var subPath = split2[i2];
      currentVal = currentVal[subPath];
      if (typeof currentVal === "undefined") {
        return currentVal;
      }
    }
    return currentVal;
  };
}
function getFromObjectOrThrow(obj, key) {
  var val = obj[key];
  if (!val) {
    throw new Error("missing value from object " + key);
  }
  return val;
}
function flatClone(obj) {
  return Object.assign({}, obj);
}
function firstPropertyNameOfObject(obj) {
  return Object.keys(obj)[0];
}
function sortObject(obj, noArraySort = false) {
  if (!obj)
    return obj;
  if (!noArraySort && Array.isArray(obj)) {
    return obj.sort((a2, b2) => {
      if (typeof a2 === "string" && typeof b2 === "string")
        return a2.localeCompare(b2);
      if (typeof a2 === "object")
        return 1;
      else
        return -1;
    }).map((i2) => sortObject(i2, noArraySort));
  }
  if (typeof obj === "object" && !Array.isArray(obj)) {
    if (obj instanceof RegExp) {
      return obj;
    }
    var out = {};
    Object.keys(obj).sort((a2, b2) => a2.localeCompare(b2)).forEach((key) => {
      out[key] = sortObject(obj[key], noArraySort);
    });
    return out;
  }
  return obj;
}
function deepClone$1(src2) {
  if (!src2) {
    return src2;
  }
  if (src2 === null || typeof src2 !== "object") {
    return src2;
  }
  if (Array.isArray(src2)) {
    var ret = new Array(src2.length);
    var i2 = ret.length;
    while (i2--) {
      ret[i2] = deepClone$1(src2[i2]);
    }
    return ret;
  }
  var dest = {};
  for (var key in src2) {
    dest[key] = deepClone$1(src2[key]);
  }
  return dest;
}
var clone$2 = deepClone$1;
function overwriteGetterForCaching(obj, getterName, value) {
  Object.defineProperty(obj, getterName, {
    get: function() {
      return value;
    }
  });
  return value;
}
function stringifyFilter(key, value) {
  if (value instanceof RegExp) {
    return value.toString();
  }
  return value;
}
function getFromMapOrThrow(map2, key) {
  var val = map2.get(key);
  if (typeof val === "undefined") {
    throw new Error("missing value from map " + key);
  }
  return val;
}
function getFromMapOrCreate(map2, index2, creator, ifWasThere) {
  var value = map2.get(index2);
  if (typeof value === "undefined") {
    value = creator();
    map2.set(index2, value);
  } else if (ifWasThere) {
    ifWasThere(value);
  }
  return value;
}
function pluginMissing(pluginKey) {
  var keyParts = pluginKey.split("-");
  var pluginName = "RxDB";
  keyParts.forEach((part) => {
    pluginName += ucfirst(part);
  });
  pluginName += "Plugin";
  return new Error("You are using a function which must be overwritten by a plugin.\n        You should either prevent the usage of this function or add the plugin via:\n            import { " + pluginName + " } from 'rxdb/plugins/" + pluginKey + "';\n            addRxPlugin(" + pluginName + ");\n        ");
}
var _lastNow = 0;
function now$1() {
  var ret = (/* @__PURE__ */ new Date()).getTime();
  ret = ret + 0.01;
  if (ret <= _lastNow) {
    ret = _lastNow + 0.01;
  }
  var twoDecimals = parseFloat(ret.toFixed(2));
  _lastNow = twoDecimals;
  return twoDecimals;
}
function ensureNotFalsy(obj) {
  if (!obj) {
    throw new Error("ensureNotFalsy() is falsy");
  }
  return obj;
}
var RXJS_SHARE_REPLAY_DEFAULTS = {
  bufferSize: 1,
  refCount: true
};
var REGEX_ALL_DOTS = /\./g;
var REGEX_PARSE_REGEX_EXPRESSION = /(\/?)(.+)\1([a-z]*)/i;
function parseRegex(regex2) {
  var matches = ensureNotFalsy(regex2.toString().match(REGEX_PARSE_REGEX_EXPRESSION));
  return {
    pattern: matches[2],
    flags: matches[3]
  };
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _isNativeFunction(fn3) {
  return Function.toString.call(fn3).indexOf("[native code]") !== -1;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var overwritable = {
  /**
   * if this method is overwritten with one
   * that returns true, we do additional checks
   * which help the developer but have bad performance
   */
  isDevMode() {
    return false;
  },
  /**
   * Deep freezes and object when in dev-mode.
   * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.
   * Also, we can ensure the readonly state via typescript
   * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
   */
  deepFreezeWhenDevMode(obj) {
    return obj;
  },
  /**
   * overwritten to map error-codes to text-messages
   */
  tunnelErrorMessage(message) {
    return "RxDB Error-Code " + message + ".\n        Error messages are not included in RxDB core to reduce build size.\n        - To find out what this error means, either use the dev-mode-plugin https://rxdb.info/dev-mode.html\n        - or search for the error code here: https://github.com/pubkey/rxdb/search?q=" + message + "\n        ";
  }
};
function parametersToString(parameters) {
  var ret = "";
  if (Object.keys(parameters).length === 0)
    return ret;
  ret += "Given parameters: {\n";
  ret += Object.keys(parameters).map((k2) => {
    var paramStr = "[object Object]";
    try {
      if (k2 === "errors") {
        paramStr = parameters[k2].map((err) => JSON.stringify(err, Object.getOwnPropertyNames(err)));
      } else {
        paramStr = JSON.stringify(parameters[k2], function(_k, v2) {
          return v2 === void 0 ? null : v2;
        }, 2);
      }
    } catch (e2) {
    }
    return k2 + ":" + paramStr;
  }).join("\n");
  ret += "}";
  return ret;
}
function messageForError(message, code, parameters) {
  return "RxError (" + code + "):\n" + message + "\n" + parametersToString(parameters);
}
var RxError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(RxError2, _Error);
  function RxError2(code, message, parameters = {}) {
    var _this;
    var mes = messageForError(message, code, parameters);
    _this = _Error.call(this, mes) || this;
    _this.code = code;
    _this.message = mes;
    _this.parameters = parameters;
    _this.rxdb = true;
    return _this;
  }
  var _proto = RxError2.prototype;
  _proto.toString = function toString3() {
    return this.message;
  };
  _createClass(RxError2, [{
    key: "name",
    get: function() {
      return "RxError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return false;
    }
  }]);
  return RxError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var RxTypeError = /* @__PURE__ */ function(_TypeError) {
  _inheritsLoose(RxTypeError2, _TypeError);
  function RxTypeError2(code, message, parameters = {}) {
    var _this2;
    var mes = messageForError(message, code, parameters);
    _this2 = _TypeError.call(this, mes) || this;
    _this2.code = code;
    _this2.message = mes;
    _this2.parameters = parameters;
    _this2.rxdb = true;
    return _this2;
  }
  var _proto2 = RxTypeError2.prototype;
  _proto2.toString = function toString3() {
    return this.message;
  };
  _createClass(RxTypeError2, [{
    key: "name",
    get: function() {
      return "RxTypeError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return true;
    }
  }]);
  return RxTypeError2;
}(/* @__PURE__ */ _wrapNativeSuper(TypeError));
function newRxError(code, parameters) {
  return new RxError(code, overwritable.tunnelErrorMessage(code), parameters);
}
function newRxTypeError(code, parameters) {
  return new RxTypeError(code, overwritable.tunnelErrorMessage(code), parameters);
}
function isBulkWriteConflictError(err) {
  if (err && err.status === 409) {
    return err;
  } else {
    return false;
  }
}
var STORAGE_WRITE_ERROR_CODE_TO_MESSAGE = {
  409: "document write conflict",
  422: "schema validation error",
  510: "attachment data missing"
};
function rxStorageWriteErrorToRxError(err) {
  return newRxError("COL20", {
    name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],
    document: err.documentId,
    writeError: err
  });
}
var HOOKS = {
  /**
   * Runs before a plugin is added.
   * Use this to block the usage of non-compatible plugins.
   */
  preAddRxPlugin: [],
  /**
   * functions that run before the database is created
   */
  preCreateRxDatabase: [],
  /**
   * runs after the database is created and prepared
   * but before the instance is returned to the user
   * @async
   */
  createRxDatabase: [],
  preCreateRxCollection: [],
  createRxCollection: [],
  /**
  * runs at the end of the destroy-process of a collection
  * @async
  */
  postDestroyRxCollection: [],
  /**
   * Runs after a collection is removed.
   * @async
   */
  postRemoveRxCollection: [],
  /**
    * functions that get the json-schema as input
    * to do additionally checks/manipulation
    */
  preCreateRxSchema: [],
  /**
   * functions that run after the RxSchema is created
   * gets RxSchema as attribute
   */
  createRxSchema: [],
  preCreateRxQuery: [],
  /**
   * Runs before a query is send to the
   * prepareQuery function of the storage engine.
   */
  prePrepareQuery: [],
  createRxDocument: [],
  /**
   * runs after a RxDocument is created,
   * cannot be async
   */
  postCreateRxDocument: [],
  /**
   * Runs before a RxStorageInstance is created
   * gets the params of createStorageInstance()
   * as attribute so you can manipulate them.
   * Notice that you have to clone stuff before mutating the inputs.
   */
  preCreateRxStorageInstance: [],
  /**
   * runs on the document-data before the document is migrated
   * {
   *   doc: Object, // original doc-data
   *   migrated: // migrated doc-data after run through migration-strategies
   * }
   */
  preMigrateDocument: [],
  /**
   * runs after the migration of a document has been done
   */
  postMigrateDocument: [],
  /**
   * runs at the beginning of the destroy-process of a database
   */
  preDestroyRxDatabase: [],
  /**
   * runs after a database has been removed
   * @async
   */
  postRemoveRxDatabase: [],
  /**
   * runs before the replication writes the rows to master
   * but before the rows have been modified
   * @async
   */
  preReplicationMasterWrite: [],
  /**
   * runs after the replication has been sent to the server
   * but before the new documents have been handled
   * @async
   */
  preReplicationMasterWriteDocumentsHandle: []
};
function runPluginHooks(hookKey, obj) {
  if (HOOKS[hookKey]) {
    HOOKS[hookKey].forEach((fun) => fun(obj));
  }
}
function runAsyncPluginHooks(hookKey, obj) {
  return Promise.all(HOOKS[hookKey].map((fun) => fun(obj)));
}
function isFunction$5(value) {
  return typeof value === "function";
}
function hasLift(source) {
  return isFunction$5(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __awaiter$1(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y2, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
          return t3;
        if (y2 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spreadArray$1(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle2(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle2(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o2[n2](v2), settle2(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle2(resolve2, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve2({ value: v3, done: d2 });
    }, reject);
  }
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise$1(value) {
  return isFunction$5(value === null || value === void 0 ? void 0 : value.then);
}
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a2, e_2, _b2;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return))
                _a2.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction$5(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray$1(__spreadArray$1([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b2 = _finalizers_1.return))
              _b2.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a2;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction$5(value.remove) && isFunction$5(value.add) && isFunction$5(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction$5(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray$1([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray$1([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop$4() {
}
function errorContext(cb2) {
  {
    cb2();
  }
}
var Subscriber = function(_super) {
  __extends$1(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next2, error, complete) {
    return new SafeSubscriber(next2, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped)
      ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind$3(fn3, thisArg) {
  return _bind.call(fn3, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends$1(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction$5(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind$3(observerOrNext.next, context_1),
          error: observerOrNext.error && bind$3(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind$3(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop$4,
  error: defaultErrorHandler,
  complete: noop$4
};
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev2, fn3) {
      return fn3(prev2);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a2 = _this, operator = _a2.operator, source = _a2.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next2, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next2(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a2;
    return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
function isObserver(value) {
  return value && isFunction$5(value.next) && isFunction$5(value.error) && isFunction$5(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
function isInteropObservable(input) {
  return isFunction$5(input[observable]);
}
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction$5(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
function isIterable(input) {
  return isFunction$5(input === null || input === void 0 ? void 0 : input[iterator]);
}
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a2, value, done;
    return __generator$1(this, function(_b2) {
      switch (_b2.label) {
        case 0:
          reader = readableStream.getReader();
          _b2.label = 1;
        case 1:
          _b2.trys.push([1, , 9, 10]);
          _b2.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a2 = _b2.sent(), value = _a2.value, done = _a2.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b2.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b2.sent()];
        case 7:
          _b2.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction$5(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise$1(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction$5(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array2) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array2.length && !subscriber.closed; i2++) {
      subscriber.next(array2[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise2) {
  return new Observable(function(subscriber) {
    promise2.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a2;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return))
          _a2.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process$1(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process$1(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a2;
  return __awaiter$1(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator$1(this, function(_b2) {
      switch (_b2.label) {
        case 0:
          _b2.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b2.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b2.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b2.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b2.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b2.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a2.call(asyncIterable_1)];
        case 7:
          _b2.sent();
          _b2.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends$1(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a2;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};
function isScheduler(value) {
  return value && isFunction$5(value.schedule);
}
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
function executeSchedule(parentSubscription, scheduler2, work, delay, repeat2) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler2.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}
function observeOn(scheduler2, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler2, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler2, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler2, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}
function subscribeOn(scheduler2, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler2.schedule(function() {
      return source.subscribe(subscriber);
    }, delay));
  });
}
function scheduleObservable(input, scheduler2) {
  return innerFrom(input).pipe(subscribeOn(scheduler2), observeOn(scheduler2));
}
function schedulePromise(input, scheduler2) {
  return innerFrom(input).pipe(subscribeOn(scheduler2), observeOn(scheduler2));
}
function scheduleArray(input, scheduler2) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler2.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable(input, scheduler2) {
  return new Observable(function(subscriber) {
    var iterator$1;
    executeSchedule(subscriber, scheduler2, function() {
      iterator$1 = input[iterator]();
      executeSchedule(subscriber, scheduler2, function() {
        var _a2;
        var value;
        var done;
        try {
          _a2 = iterator$1.next(), value = _a2.value, done = _a2.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction$5(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
    };
  });
}
function scheduleAsyncIterable(input, scheduler2) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler2, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler2, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike(input, scheduler2) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler2);
}
function scheduled(input, scheduler2) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler2);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler2);
    }
    if (isPromise$1(input)) {
      return schedulePromise(input, scheduler2);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler2);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler2);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler2);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function from(input, scheduler2) {
  return scheduler2 ? scheduled(input, scheduler2) : innerFrom(input);
}
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index2++));
    }));
  });
}
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer = [];
  var active = 0;
  var index2 = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer.push(value);
  };
  var doInnerSub = function(value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index2++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction$5(resultSelector)) {
    return mergeMap(function(a2, i2) {
      return map(function(b2, ii2) {
        return resultSelector(a2, b2, i2, ii2);
      })(innerFrom(project(a2, i2)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
var isArray$3 = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray$3(args[0]) ? args[0] : args;
}
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject = function(_super) {
  __extends$1(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a2;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b2 = __values(_this.currentObservers), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b2.return))
              _a2.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a2;
      return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends$1(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a2, _b2;
    (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a2, _b2;
    (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a2, _b2;
    (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a2, _b2;
    return (_b2 = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b2 !== void 0 ? _b2 : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
function concat$1() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}
var EMPTY$1 = new Observable(function(subscriber) {
  return subscriber.complete();
});
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare$1;
  return operate(function(source, subscriber) {
    var previousKey;
    var first = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first || !comparator(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare$1(a2, b2) {
  return a2 === b2;
}
function filter$1(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index2++) && subscriber.next(value);
    }));
  });
}
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
function merge$4() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  args = argsOrArgArray(args);
  return operate(function(source, subscriber) {
    mergeAll(concurrent)(from(__spreadArray$1([source], __read(args)), scheduler2)).subscribe(subscriber);
  });
}
function mergeWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return merge$4.apply(void 0, __spreadArray$1([], __read(otherSources)));
}
var BehaviorSubject = function(_super) {
  __extends$1(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);
var ReplaySubject = function(_super) {
  __extends$1(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a2 = this, isStopped = _a2.isStopped, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer = _a2._buffer;
    var copy2 = _buffer.slice();
    for (var i2 = 0; i2 < copy2.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy2[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last2 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now2; i2 += 2) {
        last2 = i2;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.connector, connector = _a2 === void 0 ? function() {
    return new Subject();
  } : _a2, _b2 = options.resetOnError, resetOnError = _b2 === void 0 ? true : _b2, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount--;
        if (refCount === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on2) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on2 === true) {
    reset();
    return;
  }
  if (on2 === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on2.apply(void 0, __spreadArray$1([], __read(args)))).subscribe(onSubscriber);
}
function shareReplay(configOrBufferSize, windowTime, scheduler2) {
  var _a2, _b2, _c;
  var bufferSize;
  var refCount = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a2 = configOrBufferSize.bufferSize, bufferSize = _a2 === void 0 ? Infinity : _a2, _b2 = configOrBufferSize.windowTime, windowTime = _b2 === void 0 ? Infinity : _b2, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler2 = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime, scheduler2);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount
  });
}
function startWith() {
  var values2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values2[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(values2);
  return operate(function(source, subscriber) {
    (scheduler2 ? concat$1(values2, source, scheduler2) : concat$1(values2, source)).subscribe(subscriber);
  });
}
function getDocumentDataOfRxChangeEvent(rxChangeEvent) {
  if (rxChangeEvent.documentData) {
    return rxChangeEvent.documentData;
  } else {
    return rxChangeEvent.previousDocumentData;
  }
}
function rxChangeEventToEventReduceChangeEvent(rxChangeEvent) {
  switch (rxChangeEvent.operation) {
    case "INSERT":
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: rxChangeEvent.documentData,
        previous: null
      };
    case "UPDATE":
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData),
        previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData : "UNKNOWN"
      };
    case "DELETE":
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: null,
        previous: rxChangeEvent.previousDocumentData
      };
  }
}
function getSchemaByObjectPath(rxJsonSchema, path) {
  var usePath = path;
  usePath = usePath.replace(REGEX_ALL_DOTS, ".properties.");
  usePath = "properties." + usePath;
  usePath = trimDots(usePath);
  var ret = getProperty$1(rxJsonSchema, usePath);
  return ret;
}
function fillPrimaryKey(primaryPath, jsonSchema, documentData) {
  if (typeof jsonSchema.primaryKey === "string") {
    return documentData;
  }
  var newPrimary = getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData);
  var existingPrimary = documentData[primaryPath];
  if (existingPrimary && existingPrimary !== newPrimary) {
    throw newRxError("DOC19", {
      args: {
        documentData,
        existingPrimary,
        newPrimary
      },
      schema: jsonSchema
    });
  }
  documentData[primaryPath] = newPrimary;
  return documentData;
}
function getPrimaryFieldOfPrimaryKey(primaryKey) {
  if (typeof primaryKey === "string") {
    return primaryKey;
  } else {
    return primaryKey.key;
  }
}
function getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData) {
  if (typeof jsonSchema.primaryKey === "string") {
    return documentData[jsonSchema.primaryKey];
  }
  var compositePrimary = jsonSchema.primaryKey;
  return compositePrimary.fields.map((field) => {
    var value = getProperty$1(documentData, field);
    if (typeof value === "undefined") {
      throw newRxError("DOC18", {
        args: {
          field,
          documentData
        }
      });
    }
    return value;
  }).join(compositePrimary.separator);
}
function normalizeRxJsonSchema(jsonSchema) {
  var normalizedSchema = sortObject(jsonSchema, true);
  return normalizedSchema;
}
function fillWithDefaultSettings(schemaObj) {
  schemaObj = flatClone(schemaObj);
  var primaryPath = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);
  schemaObj.properties = flatClone(schemaObj.properties);
  schemaObj.additionalProperties = false;
  if (!schemaObj.hasOwnProperty("keyCompression")) {
    schemaObj.keyCompression = false;
  }
  schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];
  schemaObj.properties._rev = {
    type: "string",
    minLength: 1
  };
  schemaObj.properties._attachments = {
    type: "object"
  };
  schemaObj.properties._deleted = {
    type: "boolean"
  };
  schemaObj.properties._meta = RX_META_SCHEMA;
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.required.push("_deleted");
  schemaObj.required.push("_rev");
  schemaObj.required.push("_meta");
  schemaObj.required.push("_attachments");
  var finalFields = getFinalFields(schemaObj);
  appendToArray(schemaObj.required, finalFields);
  schemaObj.required = schemaObj.required.filter((field) => !field.includes(".")).filter((elem, pos, arr) => arr.indexOf(elem) === pos);
  schemaObj.version = schemaObj.version || 0;
  if (schemaObj.indexes) {
    schemaObj.indexes = schemaObj.indexes.map((index2) => {
      var arIndex = isMaybeReadonlyArray(index2) ? index2.slice(0) : [index2];
      if (!arIndex.includes(primaryPath)) {
        var modifiedIndex = arIndex.slice(0);
        modifiedIndex.push(primaryPath);
        return modifiedIndex;
      }
      return arIndex;
    });
  }
  return schemaObj;
}
var RX_META_SCHEMA = {
  type: "object",
  properties: {
    /**
     * The last-write time.
     * Unix time in milliseconds.
     */
    lwt: {
      type: "number",
      /**
       * We use 1 as minimum so that the value is never falsy.
       */
      minimum: RX_META_LWT_MINIMUM,
      maximum: 1e15,
      multipleOf: 0.01
    }
  },
  /**
   * Additional properties are allowed
   * and can be used by plugins to set various flags.
   */
  additionalProperties: true,
  required: ["lwt"]
};
function getFinalFields(jsonSchema) {
  var ret = Object.keys(jsonSchema.properties).filter((key) => jsonSchema.properties[key].final);
  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);
  ret.push(primaryPath);
  if (typeof jsonSchema.primaryKey !== "string") {
    jsonSchema.primaryKey.fields.forEach((field) => ret.push(field));
  }
  return ret;
}
function fillObjectWithDefaults(rxSchema, obj) {
  var defaultKeys = Object.keys(rxSchema.defaultValues);
  for (var i2 = 0; i2 < defaultKeys.length; ++i2) {
    var key = defaultKeys[i2];
    if (!obj.hasOwnProperty(key) || typeof obj[key] === "undefined") {
      obj[key] = rxSchema.defaultValues[key];
    }
  }
  return obj;
}
var DEFAULT_CHECKPOINT_SCHEMA = {
  type: "object",
  properties: {
    id: {
      type: "string"
    },
    lwt: {
      type: "number"
    }
  },
  required: ["id", "lwt"],
  additionalProperties: false
};
var INTERNAL_STORAGE_NAME = "_rxdb_internal";
async function getSingleDocument(storageInstance, documentId) {
  var results = await storageInstance.findDocumentsById([documentId], false);
  var doc = results[documentId];
  if (doc) {
    return doc;
  } else {
    return null;
  }
}
function storageChangeEventToRxChangeEvent(isLocal, rxStorageChangeEvent, rxCollection) {
  var documentData = rxStorageChangeEvent.documentData;
  var previousDocumentData = rxStorageChangeEvent.previousDocumentData;
  var ret = {
    eventId: rxStorageChangeEvent.eventId,
    documentId: rxStorageChangeEvent.documentId,
    collectionName: rxCollection ? rxCollection.name : void 0,
    startTime: rxStorageChangeEvent.startTime,
    endTime: rxStorageChangeEvent.endTime,
    isLocal,
    operation: rxStorageChangeEvent.operation,
    documentData: overwritable.deepFreezeWhenDevMode(documentData),
    previousDocumentData: overwritable.deepFreezeWhenDevMode(previousDocumentData)
  };
  return ret;
}
function throwIfIsStorageWriteError(collection, documentId, writeData, error) {
  if (error) {
    if (error.status === 409) {
      throw newRxError("CONFLICT", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else if (error.status === 422) {
      throw newRxError("VD2", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else {
      throw error;
    }
  }
}
function categorizeBulkWriteRows(storageInstance, primaryPath, docsInDb, bulkWriteRows, context) {
  var hasAttachments = !!storageInstance.schema.attachments;
  var bulkInsertDocs = [];
  var bulkUpdateDocs = [];
  var errors = {};
  var changeByDocId = /* @__PURE__ */ new Map();
  var eventBulkId = randomCouchString(10);
  var eventBulk = {
    id: eventBulkId,
    events: [],
    checkpoint: null,
    context
  };
  var eventBulkEvents = eventBulk.events;
  var attachmentsAdd = [];
  var attachmentsRemove = [];
  var attachmentsUpdate = [];
  var startTime = now$1();
  var docsByIdIsMap = typeof docsInDb.get === "function";
  var hasDocsInDb = docsByIdIsMap ? docsInDb.size > 0 : Object.keys(docsInDb).length > 0;
  var newestRow;
  var rowAmount = bulkWriteRows.length;
  var _loop = function() {
    var writeRow = bulkWriteRows[rowId];
    var docId = writeRow.document[primaryPath];
    var documentInDb = false;
    if (hasDocsInDb) {
      documentInDb = docsByIdIsMap ? docsInDb.get(docId) : docsInDb[docId];
    }
    var attachmentError;
    if (!documentInDb) {
      var insertedIsDeleted = writeRow.document._deleted ? true : false;
      if (hasAttachments) {
        Object.entries(writeRow.document._attachments).forEach(([attachmentId, attachmentData]) => {
          if (!attachmentData.data) {
            attachmentError = {
              documentId: docId,
              isError: true,
              status: 510,
              writeRow,
              attachmentId
            };
            errors[docId] = attachmentError;
          } else {
            attachmentsAdd.push({
              documentId: docId,
              attachmentId,
              attachmentData,
              digest: defaultHashSha256(attachmentData.data)
            });
          }
        });
      }
      if (!attachmentError) {
        if (hasAttachments) {
          bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));
        } else {
          bulkInsertDocs.push(writeRow);
        }
        if (!newestRow || newestRow.document._meta.lwt < writeRow.document._meta.lwt) {
          newestRow = writeRow;
        }
      }
      if (!insertedIsDeleted) {
        var event = {
          eventId: getUniqueDeterministicEventKey(eventBulkId, rowId, docId, writeRow),
          documentId: docId,
          operation: "INSERT",
          documentData: hasAttachments ? stripAttachmentsDataFromDocument(writeRow.document) : writeRow.document,
          previousDocumentData: hasAttachments && writeRow.previous ? stripAttachmentsDataFromDocument(writeRow.previous) : writeRow.previous,
          startTime,
          endTime: now$1()
        };
        changeByDocId.set(docId, event);
        eventBulkEvents.push(event);
      }
    } else {
      var revInDb = documentInDb._rev;
      if (!writeRow.previous || !!writeRow.previous && revInDb !== writeRow.previous._rev) {
        var err = {
          isError: true,
          status: 409,
          documentId: docId,
          writeRow,
          documentInDb
        };
        errors[docId] = err;
        return 1;
      }
      var updatedRow = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow;
      if (hasAttachments) {
        if (writeRow.document._deleted) {
          if (writeRow.previous) {
            Object.keys(writeRow.previous._attachments).forEach((attachmentId) => {
              attachmentsRemove.push({
                documentId: docId,
                attachmentId,
                digest: ensureNotFalsy(writeRow.previous)._attachments[attachmentId].digest
              });
            });
          }
        } else {
          Object.entries(writeRow.document._attachments).find(([attachmentId, attachmentData]) => {
            var previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : void 0;
            if (!previousAttachmentData && !attachmentData.data) {
              attachmentError = {
                documentId: docId,
                documentInDb,
                isError: true,
                status: 510,
                writeRow,
                attachmentId
              };
            }
            return true;
          });
          if (!attachmentError) {
            Object.entries(writeRow.document._attachments).forEach(([attachmentId, attachmentData]) => {
              var previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : void 0;
              if (!previousAttachmentData) {
                attachmentsAdd.push({
                  documentId: docId,
                  attachmentId,
                  attachmentData,
                  digest: defaultHashSha256(attachmentData.data)
                });
              } else {
                var newDigest = updatedRow.document._attachments[attachmentId].digest;
                if (attachmentData.data && /**
                 * Performance shortcut,
                 * do not update the attachment data if it did not change.
                 */
                previousAttachmentData.digest !== newDigest) {
                  attachmentsUpdate.push({
                    documentId: docId,
                    attachmentId,
                    attachmentData,
                    digest: defaultHashSha256(attachmentData.data)
                  });
                }
              }
            });
          }
        }
      }
      if (attachmentError) {
        errors[docId] = attachmentError;
      } else {
        bulkUpdateDocs.push(updatedRow);
        if (!newestRow || newestRow.document._meta.lwt < updatedRow.document._meta.lwt) {
          newestRow = updatedRow;
        }
      }
      var writeDoc = writeRow.document;
      var eventDocumentData = null;
      var previousEventDocumentData = null;
      var operation = null;
      if (writeRow.previous && writeRow.previous._deleted && !writeDoc._deleted) {
        operation = "INSERT";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc;
      } else if (writeRow.previous && !writeRow.previous._deleted && !writeDoc._deleted) {
        operation = "UPDATE";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc;
        previousEventDocumentData = writeRow.previous;
      } else if (writeDoc._deleted) {
        operation = "DELETE";
        eventDocumentData = ensureNotFalsy(writeRow.document);
        previousEventDocumentData = writeRow.previous;
      } else {
        throw newRxError("SNH", {
          args: {
            writeRow
          }
        });
      }
      var _event = {
        eventId: getUniqueDeterministicEventKey(eventBulkId, rowId, docId, writeRow),
        documentId: docId,
        documentData: eventDocumentData,
        previousDocumentData: previousEventDocumentData,
        operation,
        startTime,
        endTime: now$1()
      };
      changeByDocId.set(docId, _event);
      eventBulkEvents.push(_event);
    }
  };
  for (var rowId = 0; rowId < rowAmount; rowId++) {
    if (_loop())
      continue;
  }
  return {
    bulkInsertDocs,
    bulkUpdateDocs,
    newestRow,
    errors,
    changeByDocId,
    eventBulk,
    attachmentsAdd,
    attachmentsRemove,
    attachmentsUpdate
  };
}
function stripAttachmentsDataFromRow(writeRow) {
  return {
    previous: writeRow.previous,
    document: stripAttachmentsDataFromDocument(writeRow.document)
  };
}
function getAttachmentSize(attachmentBase64String) {
  return atob(attachmentBase64String).length;
}
function attachmentWriteDataToNormalData(writeData) {
  var data = writeData.data;
  if (!data) {
    return writeData;
  }
  var ret = {
    digest: defaultHashSha256(data),
    length: getAttachmentSize(data),
    type: writeData.type
  };
  return ret;
}
function stripAttachmentsDataFromDocument(doc) {
  var useDoc = flatClone(doc);
  useDoc._attachments = {};
  Object.entries(doc._attachments).forEach(([attachmentId, attachmentData]) => {
    useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);
  });
  return useDoc;
}
function flatCloneDocWithMeta(doc) {
  var ret = flatClone(doc);
  ret._meta = flatClone(doc._meta);
  return ret;
}
function getUniqueDeterministicEventKey(eventBulkId, rowId, docId, writeRow) {
  return eventBulkId + "|" + rowId + "|" + docId + "|" + writeRow.document._rev;
}
function getWrappedStorageInstance(database, storageInstance, rxJsonSchema) {
  overwritable.deepFreezeWhenDevMode(rxJsonSchema);
  var primaryPath = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);
  function transformDocumentDataFromRxDBToRxStorage(writeRow) {
    var data = flatClone(writeRow.document);
    data._meta = flatClone(data._meta);
    if (overwritable.isDevMode()) {
      data = fillPrimaryKey(primaryPath, rxJsonSchema, data);
      if (writeRow.previous)
        ;
      if (writeRow.previous) {
        Object.keys(writeRow.previous._meta).forEach((metaFieldName) => {
          if (!writeRow.document._meta.hasOwnProperty(metaFieldName)) {
            throw newRxError("SNH", {
              dataBefore: writeRow.previous,
              dataAfter: writeRow.document
            });
          }
        });
      }
    }
    data._meta.lwt = now$1();
    data._rev = createRevision(database.token, writeRow.previous);
    return {
      document: data,
      previous: writeRow.previous
    };
  }
  var ret = {
    originalStorageInstance: storageInstance,
    schema: storageInstance.schema,
    internals: storageInstance.internals,
    collectionName: storageInstance.collectionName,
    databaseName: storageInstance.databaseName,
    options: storageInstance.options,
    bulkWrite(rows2, context) {
      var toStorageWriteRows = rows2.map((row) => transformDocumentDataFromRxDBToRxStorage(row));
      return database.lockedRun(() => storageInstance.bulkWrite(toStorageWriteRows, context)).then((writeResult) => {
        var reInsertErrors = Object.values(writeResult.error).filter((error) => {
          if (error.status === 409 && !error.writeRow.previous && !error.writeRow.document._deleted && ensureNotFalsy(error.documentInDb)._deleted) {
            return true;
          }
          return false;
        });
        if (reInsertErrors.length > 0) {
          var useWriteResult = {
            error: flatClone(writeResult.error),
            success: flatClone(writeResult.success)
          };
          var reInserts = reInsertErrors.map((error) => {
            delete useWriteResult.error[error.documentId];
            return {
              previous: error.documentInDb,
              document: Object.assign({}, error.writeRow.document, {
                _rev: createRevision(database.token, error.documentInDb)
              })
            };
          });
          return database.lockedRun(() => storageInstance.bulkWrite(reInserts, context)).then((subResult) => {
            useWriteResult.error = Object.assign(useWriteResult.error, subResult.error);
            useWriteResult.success = Object.assign(useWriteResult.success, subResult.success);
            return useWriteResult;
          });
        }
        return writeResult;
      });
    },
    query(preparedQuery) {
      return database.lockedRun(() => storageInstance.query(preparedQuery));
    },
    count(preparedQuery) {
      return database.lockedRun(() => storageInstance.count(preparedQuery));
    },
    findDocumentsById(ids, deleted) {
      return database.lockedRun(() => storageInstance.findDocumentsById(ids, deleted));
    },
    getAttachmentData(documentId, attachmentId, digest) {
      return database.lockedRun(() => storageInstance.getAttachmentData(documentId, attachmentId, digest));
    },
    getChangedDocumentsSince(limit, checkpoint) {
      return database.lockedRun(() => storageInstance.getChangedDocumentsSince(ensureNotFalsy(limit), checkpoint));
    },
    cleanup(minDeletedTime) {
      return database.lockedRun(() => storageInstance.cleanup(minDeletedTime));
    },
    remove() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.remove());
    },
    close() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.close());
    },
    changeStream() {
      return storageInstance.changeStream();
    },
    conflictResultionTasks() {
      return storageInstance.conflictResultionTasks();
    },
    resolveConflictResultionTask(taskSolution) {
      if (taskSolution.output.isEqual) {
        return storageInstance.resolveConflictResultionTask(taskSolution);
      }
      var doc = Object.assign({}, taskSolution.output.documentData, {
        _meta: getDefaultRxDocumentMeta(),
        _rev: getDefaultRevision(),
        _attachments: {}
      });
      var documentData = flatClone(doc);
      delete documentData._meta;
      delete documentData._rev;
      delete documentData._attachments;
      return storageInstance.resolveConflictResultionTask({
        id: taskSolution.id,
        output: {
          isEqual: false,
          documentData
        }
      });
    }
  };
  database.storageInstances.add(ret);
  return ret;
}
function ensureRxStorageInstanceParamsAreCorrect(params) {
  if (params.schema.keyCompression) {
    throw newRxError("UT5", {
      args: {
        params
      }
    });
  }
  if (hasEncryption(params.schema)) {
    throw newRxError("UT6", {
      args: {
        params
      }
    });
  }
  if (params.schema.attachments && params.schema.attachments.compression) {
    throw newRxError("UT7", {
      args: {
        params
      }
    });
  }
}
function hasEncryption(jsonSchema) {
  if (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0 || jsonSchema.attachments && jsonSchema.attachments.encrypted) {
    return true;
  } else {
    return false;
  }
}
var IncrementalWriteQueue = /* @__PURE__ */ function() {
  function IncrementalWriteQueue2(storageInstance, primaryPath, preWrite, postWrite) {
    this.queueByDocId = /* @__PURE__ */ new Map();
    this.isRunning = false;
    this.storageInstance = storageInstance;
    this.primaryPath = primaryPath;
    this.preWrite = preWrite;
    this.postWrite = postWrite;
  }
  var _proto = IncrementalWriteQueue2.prototype;
  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {
    var docId = lastKnownDocumentState[this.primaryPath];
    var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);
    var ret = new Promise((resolve2, reject) => {
      var item = {
        lastKnownDocumentState,
        modifier,
        resolve: resolve2,
        reject
      };
      ensureNotFalsy(ar).push(item);
      this.triggerRun();
    });
    return ret;
  };
  _proto.triggerRun = async function triggerRun() {
    if (this.isRunning === true || this.queueByDocId.size === 0) {
      return;
    }
    this.isRunning = true;
    var writeRows = [];
    var itemsById = this.queueByDocId;
    this.queueByDocId = /* @__PURE__ */ new Map();
    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {
      var oldData = findNewestOfDocumentStates(items.map((i2) => i2.lastKnownDocumentState));
      var newData = oldData;
      for (var item of items) {
        try {
          newData = await item.modifier(
            /**
             * We have to clone() each time because the modifier
             * might throw while it already changed some properties
             * of the document.
             */
            clone$2(newData)
          );
        } catch (err) {
          item.reject(err);
          item.reject = () => {
          };
          item.resolve = () => {
          };
        }
      }
      try {
        await this.preWrite(newData, oldData);
      } catch (err) {
        items.forEach((item2) => item2.reject(err));
        return;
      }
      writeRows.push({
        previous: oldData,
        document: newData
      });
    }));
    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, "incremental-write") : {
      error: {},
      success: {}
    };
    await Promise.all(Array.from(Object.entries(writeResult.success)).map(([docId, result]) => {
      this.postWrite(result);
      var items = getFromMapOrThrow(itemsById, docId);
      items.forEach((item) => item.resolve(result));
    }));
    Array.from(Object.entries(writeResult.error)).forEach(([docId, error]) => {
      var items = getFromMapOrThrow(itemsById, docId);
      var isConflict = isBulkWriteConflictError(error);
      if (isConflict) {
        var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);
        items.reverse().forEach((item) => {
          item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);
          ensureNotFalsy(ar).unshift(item);
        });
      } else {
        var rxError = rxStorageWriteErrorToRxError(error);
        items.forEach((item) => item.reject(rxError));
      }
    });
    this.isRunning = false;
    return this.triggerRun();
  };
  return IncrementalWriteQueue2;
}();
function modifierFromPublicToInternal(publicModifier) {
  var ret = async (docData) => {
    var withoutMeta = stripMetaDataFromDocument(docData);
    withoutMeta._deleted = docData._deleted;
    var modified = await publicModifier(withoutMeta);
    var reattachedMeta = Object.assign({}, modified, {
      _meta: docData._meta,
      _attachments: docData._attachments,
      _rev: docData._rev,
      _deleted: typeof modified._deleted !== "undefined" ? modified._deleted : docData._deleted
    });
    if (typeof reattachedMeta._deleted === "undefined") {
      reattachedMeta._deleted = false;
    }
    return reattachedMeta;
  };
  return ret;
}
function findNewestOfDocumentStates(docs) {
  var newest = docs[0];
  var newestRevisionHeight = parseRevision(newest._rev).height;
  docs.forEach((doc) => {
    var height2 = parseRevision(doc._rev).height;
    if (height2 > newestRevisionHeight) {
      newest = doc;
      newestRevisionHeight = height2;
    }
  });
  return newest;
}
var basePrototype = {
  get primaryPath() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.collection.schema.primaryPath;
  },
  get primary() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data[_this.primaryPath];
  },
  get revision() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._rev;
  },
  get deleted$() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.$.pipe(map((d2) => d2._deleted));
  },
  get deleted() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._deleted;
  },
  getLatest() {
    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);
    return this.collection._docCache.getCachedRxDocument(latestDocData);
  },
  /**
   * returns the observable which emits the plain-data of this document
   */
  get $() {
    var _this = this;
    return _this.collection.$.pipe(filter$1((changeEvent) => !changeEvent.isLocal), filter$1((changeEvent) => changeEvent.documentId === this.primary), map((changeEvent) => getDocumentDataOfRxChangeEvent(changeEvent)), startWith(_this.collection._docCache.getLatestDocumentData(this.primary)), distinctUntilChanged((prev2, curr) => prev2._rev === curr._rev), map((docData) => this.collection._docCache.getCachedRxDocument(docData)), shareReplay(RXJS_SHARE_REPLAY_DEFAULTS));
  },
  /**
   * returns observable of the value of the given path
   */
  get$(path) {
    if (overwritable.isDevMode()) {
      if (path.includes(".item.")) {
        throw newRxError("DOC1", {
          path
        });
      }
      if (path === this.primaryPath) {
        throw newRxError("DOC2");
      }
      if (this.collection.schema.finalFields.includes(path)) {
        throw newRxError("DOC3", {
          path
        });
      }
      var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);
      if (!schemaObj) {
        throw newRxError("DOC4", {
          path
        });
      }
    }
    return this.$.pipe(map((data) => getProperty$1(data, path)), distinctUntilChanged());
  },
  /**
   * populate the given path
   */
  populate(path) {
    var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);
    var value = this.get(path);
    if (!value) {
      return PROMISE_RESOLVE_NULL;
    }
    if (!schemaObj) {
      throw newRxError("DOC5", {
        path
      });
    }
    if (!schemaObj.ref) {
      throw newRxError("DOC6", {
        path,
        schemaObj
      });
    }
    var refCollection = this.collection.database.collections[schemaObj.ref];
    if (!refCollection) {
      throw newRxError("DOC7", {
        ref: schemaObj.ref,
        path,
        schemaObj
      });
    }
    if (schemaObj.type === "array") {
      return refCollection.findByIds(value).exec().then((res) => {
        var valuesIterator = res.values();
        return Array.from(valuesIterator);
      });
    } else {
      return refCollection.findOne(value).exec();
    }
  },
  /**
   * get data by objectPath
   */
  get(objPath) {
    if (!this._data) {
      return void 0;
    }
    var fromCache = this._propertyCache.get(objPath);
    if (fromCache) {
      return fromCache;
    }
    var valueObj = getProperty$1(this._data, objPath);
    if (typeof valueObj !== "object" || Array.isArray(valueObj)) {
      return overwritable.deepFreezeWhenDevMode(valueObj);
    }
    valueObj = clone$2(valueObj);
    defineGetterSetter(this.collection.schema, valueObj, objPath, this);
    this._propertyCache.set(objPath, valueObj);
    return valueObj;
  },
  toJSON(withMetaFields = false) {
    if (!withMetaFields) {
      var data = flatClone(this._data);
      delete data._rev;
      delete data._attachments;
      delete data._deleted;
      delete data._meta;
      return overwritable.deepFreezeWhenDevMode(data);
    } else {
      return overwritable.deepFreezeWhenDevMode(this._data);
    }
  },
  toMutableJSON(withMetaFields = false) {
    return clone$2(this.toJSON(withMetaFields));
  },
  /**
   * updates document
   * @overwritten by plugin (optional)
   * @param updateObj mongodb-like syntax
   */
  update(_updateObj) {
    throw pluginMissing("update");
  },
  incrementalUpdate(_updateObj) {
    throw pluginMissing("update");
  },
  updateCRDT(_updateObj) {
    throw pluginMissing("crdt");
  },
  putAttachment() {
    throw pluginMissing("attachments");
  },
  getAttachment() {
    throw pluginMissing("attachments");
  },
  allAttachments() {
    throw pluginMissing("attachments");
  },
  get allAttachments$() {
    throw pluginMissing("attachments");
  },
  async modify(mutationFunction, _context) {
    var oldData = this._data;
    var newData = await modifierFromPublicToInternal(mutationFunction)(oldData);
    return this._saveData(newData, oldData);
  },
  /**
   * runs an incremental update over the document
   * @param function that takes the document-data and returns a new data-object
   */
  incrementalModify(mutationFunction, _context) {
    return this.collection.incrementalWriteQueue.addWrite(this._data, modifierFromPublicToInternal(mutationFunction)).then((result) => this.collection._docCache.getCachedRxDocument(result));
  },
  patch(patch) {
    var oldData = this._data;
    var newData = clone$2(oldData);
    Object.entries(patch).forEach(([k2, v2]) => {
      newData[k2] = v2;
    });
    return this._saveData(newData, oldData);
  },
  /**
   * patches the given properties
   */
  incrementalPatch(patch) {
    return this.incrementalModify((docData) => {
      Object.entries(patch).forEach(([k2, v2]) => {
        docData[k2] = v2;
      });
      return docData;
    });
  },
  /**
   * saves the new document-data
   * and handles the events
   */
  async _saveData(newData, oldData) {
    newData = flatClone(newData);
    if (this._data._deleted) {
      throw newRxError("DOC11", {
        id: this.primary,
        document: this
      });
    }
    await beforeDocumentUpdateWrite(this.collection, newData, oldData);
    var writeResult = await this.collection.storageInstance.bulkWrite([{
      previous: oldData,
      document: newData
    }], "rx-document-save-data");
    var isError = writeResult.error[this.primary];
    throwIfIsStorageWriteError(this.collection, this.primary, newData, isError);
    await this.collection._runHooks("post", "save", newData, this);
    return this.collection._docCache.getCachedRxDocument(getFromObjectOrThrow(writeResult.success, this.primary));
  },
  /**
   * Remove the document.
   * Notice that there is no hard delete,
   * instead deleted documents get flagged with _deleted=true.
   */
  remove() {
    var collection = this.collection;
    if (this.deleted) {
      return Promise.reject(newRxError("DOC13", {
        document: this,
        id: this.primary
      }));
    }
    var deletedData = flatClone(this._data);
    var removedDocData;
    return collection._runHooks("pre", "remove", deletedData, this).then(async () => {
      deletedData._deleted = true;
      var writeResult = await collection.storageInstance.bulkWrite([{
        previous: this._data,
        document: deletedData
      }], "rx-document-remove");
      var isError = writeResult.error[this.primary];
      throwIfIsStorageWriteError(collection, this.primary, deletedData, isError);
      return getFromObjectOrThrow(writeResult.success, this.primary);
    }).then((removed) => {
      removedDocData = removed;
      return this.collection._runHooks("post", "remove", deletedData, this);
    }).then(() => {
      return this.collection._docCache.getCachedRxDocument(removedDocData);
    });
  },
  incrementalRemove() {
    return this.incrementalModify(async (docData) => {
      await this.collection._runHooks("pre", "remove", docData, this);
      docData._deleted = true;
      return docData;
    }).then(async (newDoc) => {
      await this.collection._runHooks("post", "remove", newDoc._data, newDoc);
      return newDoc;
    });
  },
  destroy() {
    throw newRxError("DOC14");
  }
};
function createRxDocumentConstructor(proto = basePrototype) {
  var constructor = function RxDocumentConstructor(collection, docData) {
    this.collection = collection;
    this._data = docData;
    this._propertyCache = /* @__PURE__ */ new Map();
    this.isInstanceOfRxDocument = true;
  };
  constructor.prototype = proto;
  return constructor;
}
function defineGetterSetter(schema, valueObj, objPath = "", thisObj = false) {
  if (valueObj === null) {
    return;
  }
  var pathProperties = getSchemaByObjectPath(schema.jsonSchema, objPath);
  if (typeof pathProperties === "undefined")
    return;
  if (pathProperties.properties)
    pathProperties = pathProperties.properties;
  Object.keys(pathProperties).forEach((key) => {
    var fullPath = trimDots(objPath + "." + key);
    valueObj.__defineGetter__(key, function() {
      var _this = thisObj ? thisObj : this;
      if (!_this.get || typeof _this.get !== "function") {
        return void 0;
      }
      var ret = _this.get(fullPath);
      return ret;
    });
    Object.defineProperty(valueObj, key + "$", {
      get: function() {
        var _this = thisObj ? thisObj : this;
        return _this.get$(fullPath);
      },
      enumerable: false,
      configurable: false
    });
    Object.defineProperty(valueObj, key + "_", {
      get: function() {
        var _this = thisObj ? thisObj : this;
        return _this.populate(fullPath);
      },
      enumerable: false,
      configurable: false
    });
    valueObj.__defineSetter__(key, function(val) {
      var _this = thisObj ? thisObj : this;
      return _this.set(fullPath, val);
    });
  });
}
function createWithConstructor(constructor, collection, jsonData) {
  var doc = new constructor(collection, jsonData);
  runPluginHooks("createRxDocument", doc);
  return doc;
}
function beforeDocumentUpdateWrite(collection, newData, oldData) {
  newData._meta = Object.assign({}, oldData._meta, newData._meta);
  if (overwritable.isDevMode()) {
    collection.schema.validateChange(oldData, newData);
  }
  return collection._runHooks("pre", "save", newData, oldData);
}
var RxSchema = /* @__PURE__ */ function() {
  function RxSchema2(jsonSchema, hashFunction) {
    this.jsonSchema = jsonSchema;
    this.hashFunction = hashFunction;
    this.indexes = getIndexes(this.jsonSchema);
    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);
    this.finalFields = getFinalFields(this.jsonSchema);
  }
  var _proto = RxSchema2.prototype;
  _proto.validateChange = function validateChange(dataBefore, dataAfter) {
    this.finalFields.forEach((fieldName) => {
      if (!deepEqual$1(dataBefore[fieldName], dataAfter[fieldName])) {
        throw newRxError("DOC9", {
          dataBefore,
          dataAfter,
          fieldName,
          schema: this.jsonSchema
        });
      }
    });
  };
  _proto.getDocumentPrototype = function getDocumentPrototype2() {
    var proto = {};
    defineGetterSetter(this, proto, "");
    overwriteGetterForCaching(this, "getDocumentPrototype", () => proto);
    return proto;
  };
  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {
    return getComposedPrimaryKeyOfDocumentData(this.jsonSchema, documentData);
  };
  _createClass(RxSchema2, [{
    key: "version",
    get: function() {
      return this.jsonSchema.version;
    }
  }, {
    key: "defaultValues",
    get: function() {
      var values2 = {};
      Object.entries(this.jsonSchema.properties).filter(([, v2]) => v2.hasOwnProperty("default")).forEach(([k2, v2]) => values2[k2] = v2.default);
      return overwriteGetterForCaching(this, "defaultValues", values2);
    }
    /**
     * @overrides itself on the first call
     *
     * TODO this should be a pure function that
     * caches the hash in a WeakMap.
     */
  }, {
    key: "hash",
    get: function() {
      return overwriteGetterForCaching(this, "hash", this.hashFunction(JSON.stringify(this.jsonSchema)));
    }
  }]);
  return RxSchema2;
}();
function getIndexes(jsonSchema) {
  return (jsonSchema.indexes || []).map((index2) => isMaybeReadonlyArray(index2) ? index2 : [index2]);
}
function createRxSchema(jsonSchema, hashFunction, runPreCreateHooks = true) {
  if (runPreCreateHooks) {
    runPluginHooks("preCreateRxSchema", jsonSchema);
  }
  var useJsonSchema = fillWithDefaultSettings(jsonSchema);
  useJsonSchema = normalizeRxJsonSchema(useJsonSchema);
  overwritable.deepFreezeWhenDevMode(useJsonSchema);
  var schema = new RxSchema(useJsonSchema, hashFunction);
  runPluginHooks("createRxSchema", schema);
  return schema;
}
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve2, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve2(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve2(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
function merge$3() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY$1 : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler2));
}
const UNKNOWN_VALUE = "UNKNOWN";
function lastOfArray(ar) {
  return ar[ar.length - 1];
}
function isObject$5(value) {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
}
function getProperty(object2, path, value) {
  if (Array.isArray(path)) {
    path = path.join(".");
  }
  if (!isObject$5(object2) || typeof path !== "string") {
    return value === void 0 ? object2 : value;
  }
  const pathArray = path.split(".");
  if (pathArray.length === 0) {
    return value;
  }
  for (let index2 = 0; index2 < pathArray.length; index2++) {
    const key = pathArray[index2];
    if (isStringIndex(object2, key)) {
      object2 = index2 === pathArray.length - 1 ? void 0 : null;
    } else {
      object2 = object2[key];
    }
    if (object2 === void 0 || object2 === null) {
      if (index2 !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object2 === void 0 ? value : object2;
}
function isStringIndex(object2, key) {
  if (typeof key !== "number" && Array.isArray(object2)) {
    const index2 = Number.parseInt(key, 10);
    return Number.isInteger(index2) && object2[index2] === object2[key];
  }
  return false;
}
const hasLimit = (input) => {
  return !!input.queryParams.limit;
};
const isFindOne = (input) => {
  return input.queryParams.limit === 1;
};
const hasSkip = (input) => {
  if (input.queryParams.skip && input.queryParams.skip > 0) {
    return true;
  } else {
    return false;
  }
};
const isDelete = (input) => {
  return input.changeEvent.operation === "DELETE";
};
const isInsert = (input) => {
  return input.changeEvent.operation === "INSERT";
};
const isUpdate = (input) => {
  return input.changeEvent.operation === "UPDATE";
};
const previousUnknown = (input) => {
  return input.changeEvent.previous === UNKNOWN_VALUE;
};
const wasLimitReached = (input) => {
  return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;
};
const sortParamsChanged = (input) => {
  const sortFields2 = input.queryParams.sortFields;
  const prev2 = input.changeEvent.previous;
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  if (!prev2 || prev2 === UNKNOWN_VALUE) {
    return true;
  }
  for (let i2 = 0; i2 < sortFields2.length; i2++) {
    const field = sortFields2[i2];
    const beforeData = getProperty(prev2, field);
    const afterData = getProperty(doc, field);
    if (beforeData !== afterData) {
      return true;
    }
  }
  return false;
};
const wasInResult = (input) => {
  const id2 = input.changeEvent.id;
  if (input.keyDocumentMap) {
    const has2 = input.keyDocumentMap.has(id2);
    return has2;
  } else {
    const primary = input.queryParams.primaryKey;
    const results = input.previousResults;
    for (let i2 = 0; i2 < results.length; i2++) {
      const item = results[i2];
      if (item[primary] === id2) {
        return true;
      }
    }
    return false;
  }
};
const wasFirst = (input) => {
  const first = input.previousResults[0];
  if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  } else {
    return false;
  }
};
const wasLast = (input) => {
  const last2 = lastOfArray(input.previousResults);
  if (last2 && last2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  } else {
    return false;
  }
};
const wasSortedBeforeFirst = (input) => {
  const prev2 = input.changeEvent.previous;
  if (!prev2 || prev2 === UNKNOWN_VALUE) {
    return false;
  }
  const first = input.previousResults[0];
  if (!first) {
    return false;
  }
  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(prev2, first);
  return comp < 0;
};
const wasSortedAfterLast = (input) => {
  const prev2 = input.changeEvent.previous;
  if (!prev2 || prev2 === UNKNOWN_VALUE) {
    return false;
  }
  const last2 = lastOfArray(input.previousResults);
  if (!last2) {
    return false;
  }
  if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(prev2, last2);
  return comp > 0;
};
const isSortedBeforeFirst = (input) => {
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  const first = input.previousResults[0];
  if (!first) {
    return false;
  }
  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(doc, first);
  return comp < 0;
};
const isSortedAfterLast = (input) => {
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  const last2 = lastOfArray(input.previousResults);
  if (!last2) {
    return false;
  }
  if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(doc, last2);
  return comp > 0;
};
const wasMatching = (input) => {
  const prev2 = input.changeEvent.previous;
  if (!prev2 || prev2 === UNKNOWN_VALUE) {
    return false;
  }
  return input.queryParams.queryMatcher(prev2);
};
const doesMatchNow = (input) => {
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  const ret = input.queryParams.queryMatcher(doc);
  return ret;
};
const wasResultsEmpty = (input) => {
  return input.previousResults.length === 0;
};
const stateResolveFunctionByIndex = {
  0: isInsert,
  1: isUpdate,
  2: isDelete,
  3: hasLimit,
  4: isFindOne,
  5: hasSkip,
  6: wasResultsEmpty,
  7: previousUnknown,
  8: wasLimitReached,
  9: wasFirst,
  10: wasLast,
  11: sortParamsChanged,
  12: wasInResult,
  13: wasSortedBeforeFirst,
  14: wasSortedAfterLast,
  15: isSortedBeforeFirst,
  16: isSortedAfterLast,
  17: wasMatching,
  18: doesMatchNow
};
function pushAtSortPosition(array2, item, compareFunction, low) {
  var length2 = array2.length;
  var high = length2 - 1;
  var mid = 0;
  if (length2 === 0) {
    array2.push(item);
    return 0;
  }
  var lastMidDoc;
  while (low <= high) {
    mid = low + (high - low >> 1);
    lastMidDoc = array2[mid];
    if (compareFunction(lastMidDoc, item) <= 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  if (compareFunction(lastMidDoc, item) <= 0) {
    mid++;
  }
  array2.splice(mid, 0, item);
  return mid;
}
const doNothing = (_input) => {
};
const insertFirst = (input) => {
  input.previousResults.unshift(input.changeEvent.doc);
  if (input.keyDocumentMap) {
    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
  }
};
const insertLast = (input) => {
  input.previousResults.push(input.changeEvent.doc);
  if (input.keyDocumentMap) {
    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
  }
};
const removeFirstItem = (input) => {
  const first = input.previousResults.shift();
  if (input.keyDocumentMap && first) {
    input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);
  }
};
const removeLastItem = (input) => {
  const last2 = input.previousResults.pop();
  if (input.keyDocumentMap && last2) {
    input.keyDocumentMap.delete(last2[input.queryParams.primaryKey]);
  }
};
const removeFirstInsertLast = (input) => {
  removeFirstItem(input);
  insertLast(input);
};
const removeLastInsertFirst = (input) => {
  removeLastItem(input);
  insertFirst(input);
};
const removeFirstInsertFirst = (input) => {
  removeFirstItem(input);
  insertFirst(input);
};
const removeLastInsertLast = (input) => {
  removeLastItem(input);
  insertLast(input);
};
const removeExisting = (input) => {
  if (input.keyDocumentMap) {
    input.keyDocumentMap.delete(input.changeEvent.id);
  }
  const primary = input.queryParams.primaryKey;
  const results = input.previousResults;
  for (let i2 = 0; i2 < results.length; i2++) {
    const item = results[i2];
    if (item[primary] === input.changeEvent.id) {
      results.splice(i2, 1);
      break;
    }
  }
};
const replaceExisting = (input) => {
  const doc = input.changeEvent.doc;
  const primary = input.queryParams.primaryKey;
  const results = input.previousResults;
  for (let i2 = 0; i2 < results.length; i2++) {
    const item = results[i2];
    if (item[primary] === input.changeEvent.id) {
      results[i2] = doc;
      if (input.keyDocumentMap) {
        input.keyDocumentMap.set(input.changeEvent.id, doc);
      }
      break;
    }
  }
};
const alwaysWrong = (input) => {
  const wrongHuman = {
    _id: "wrongHuman" + (/* @__PURE__ */ new Date()).getTime()
  };
  input.previousResults.length = 0;
  input.previousResults.push(wrongHuman);
  if (input.keyDocumentMap) {
    input.keyDocumentMap.clear();
    input.keyDocumentMap.set(wrongHuman._id, wrongHuman);
  }
};
const insertAtSortPosition = (input) => {
  const docId = input.changeEvent.id;
  const doc = input.changeEvent.doc;
  if (input.keyDocumentMap) {
    if (input.keyDocumentMap.has(docId)) {
      return;
    }
    input.keyDocumentMap.set(docId, doc);
  } else {
    const isDocInResults = input.previousResults.find((d2) => d2[input.queryParams.primaryKey] === docId);
    if (isDocInResults) {
      return;
    }
  }
  pushAtSortPosition(input.previousResults, doc, input.queryParams.sortComparator, 0);
};
const removeExistingAndInsertAtSortPosition = (input) => {
  removeExisting(input);
  insertAtSortPosition(input);
};
const runFullQueryAgain = (_input) => {
  throw new Error("Action runFullQueryAgain must be implemented by yourself");
};
const unknownAction = (_input) => {
  throw new Error("Action unknownAction should never be called");
};
const orderedActionList = [
  "doNothing",
  "insertFirst",
  "insertLast",
  "removeFirstItem",
  "removeLastItem",
  "removeFirstInsertLast",
  "removeLastInsertFirst",
  "removeFirstInsertFirst",
  "removeLastInsertLast",
  "removeExisting",
  "replaceExisting",
  "alwaysWrong",
  "insertAtSortPosition",
  "removeExistingAndInsertAtSortPosition",
  "runFullQueryAgain",
  "unknownAction"
];
const actionFunctions = {
  doNothing,
  insertFirst,
  insertLast,
  removeFirstItem,
  removeLastItem,
  removeFirstInsertLast,
  removeLastInsertFirst,
  removeFirstInsertFirst,
  removeLastInsertLast,
  removeExisting,
  replaceExisting,
  alwaysWrong,
  insertAtSortPosition,
  removeExistingAndInsertAtSortPosition,
  runFullQueryAgain,
  unknownAction
};
const CHAR_CODE_OFFSET = 40;
function getNumberOfChar(char2) {
  const charCode = char2.charCodeAt(0);
  return charCode - CHAR_CODE_OFFSET;
}
function booleanToBooleanString(b2) {
  if (b2) {
    return "1";
  } else {
    return "0";
  }
}
function splitStringToChunks(str, chunkSize) {
  const chunks = [];
  for (let i2 = 0, charsLength = str.length; i2 < charsLength; i2 += chunkSize) {
    chunks.push(str.substring(i2, i2 + chunkSize));
  }
  return chunks;
}
function minimalStringToSimpleBdd(str) {
  const nodesById = /* @__PURE__ */ new Map();
  const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);
  const lastLeafNodeChar = 2 + leafNodeAmount * 2;
  const leafNodeChars = str.substring(2, lastLeafNodeChar);
  const leafNodeChunks = splitStringToChunks(leafNodeChars, 2);
  for (let i2 = 0; i2 < leafNodeChunks.length; i2++) {
    const chunk = leafNodeChunks[i2];
    const id2 = chunk.charAt(0);
    const value = getNumberOfChar(chunk.charAt(1));
    nodesById.set(id2, value);
  }
  const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);
  const internalNodeChunks = splitStringToChunks(internalNodeChars, 4);
  for (let i2 = 0; i2 < internalNodeChunks.length; i2++) {
    const chunk = internalNodeChunks[i2];
    const id2 = chunk.charAt(0);
    const idOf0Branch = chunk.charAt(1);
    const idOf1Branch = chunk.charAt(2);
    const level = getNumberOfChar(chunk.charAt(3));
    if (!nodesById.has(idOf0Branch)) {
      throw new Error("missing node with id " + idOf0Branch);
    }
    if (!nodesById.has(idOf1Branch)) {
      throw new Error("missing node with id " + idOf1Branch);
    }
    const node0 = nodesById.get(idOf0Branch);
    const node1 = nodesById.get(idOf1Branch);
    const node2 = {
      l: level,
      0: node0,
      1: node1
    };
    nodesById.set(id2, node2);
  }
  const last3 = str.slice(-3);
  const idOf0 = last3.charAt(0);
  const idOf1 = last3.charAt(1);
  const levelOfRoot = getNumberOfChar(last3.charAt(2));
  const nodeOf0 = nodesById.get(idOf0);
  const nodeOf1 = nodesById.get(idOf1);
  const rootNode = {
    l: levelOfRoot,
    0: nodeOf0,
    1: nodeOf1
  };
  return rootNode;
}
function resolveWithSimpleBdd(simpleBdd2, fns, input) {
  let currentNode = simpleBdd2;
  let currentLevel = simpleBdd2.l;
  while (true) {
    const booleanResult = fns[currentLevel](input);
    const branchKey = booleanToBooleanString(booleanResult);
    currentNode = currentNode[branchKey];
    if (typeof currentNode === "number" || typeof currentNode === "string") {
      return currentNode;
    } else {
      currentLevel = currentNode.l;
    }
  }
}
const minimalBddString = "14a2b0c/d1e,f+g5h.i4j*k-l)m(n6ohk1pdf1qef1rin-sjn-ton-ugn-vmn-whn-xkn-yln-zdf5{ef5|wx5}df7~dz7ef7¡bk7¢e{7£g|7¤ry7¥dp7¦gk7§eq7¨gt7©ac7ªmv7«gu7¬nm7­iy7®nw7¯¤s8°«¦8±¬k8²ªm8³®v8´«n8µ¬n8¶vm8·xv8¸mn8¹­j8º®m8»xm8¼­¹3½}~3¾©°3¿¢3À¡£3Ám±3Â®º3Ãmº3Ä©´3Åb®3Æmµ3Çm»3Èx»3Ékn3Êm¸3Ë¼j6ÌÂm6ÍÆÃ6ÎÈm6Ïnm6ÐÊÇ6ÑÌÎ,ÒÍÐ,ÓÅÉ,Ô²¶,Õ³·,Ö®n,×º»,Ømf9ÙËÁ9Úym9ÛmÏ9ÜÑÒ9Ýz{2Þpq2ß½¿2à¾À2á¥§2â°¨2ãÄÓ2ä´Ö2åÝn0æÞn0çØÛ0èÙÜ0éßn0êàã0ë²Ô0ì¯Õ0íán0îâä0ï¹×0ðçv/ñåæ/òçë/óèì/ôéí/õêî/öÚy/÷òm(øóï(ùöy(ú÷ø:ûôõ:ümù:ýðñ4þúû4ÿþý*Āüm*ÿĀ.";
let simpleBdd;
function getSimpleBdd() {
  if (!simpleBdd) {
    simpleBdd = minimalStringToSimpleBdd(minimalBddString);
  }
  return simpleBdd;
}
const resolveInput = (input) => {
  return resolveWithSimpleBdd(getSimpleBdd(), stateResolveFunctionByIndex, input);
};
function calculateActionName(input) {
  const resolvedActionId = resolveInput(input);
  return orderedActionList[resolvedActionId];
}
function runAction(action, queryParams, changeEvent, previousResults, keyDocumentMap) {
  const fn3 = actionFunctions[action];
  fn3({
    queryParams,
    changeEvent,
    previousResults,
    keyDocumentMap
  });
  return previousResults;
}
var INDEX_MAX = String.fromCharCode(65535);
var INDEX_MIN = Number.MIN_VALUE;
function getQueryPlan(schema, query) {
  var primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);
  var selector = query.selector;
  var indexes = schema.indexes ? schema.indexes.slice(0) : [];
  if (query.index) {
    indexes = [query.index];
  } else {
    indexes.push([primaryPath]);
  }
  var optimalSortIndex = query.sort.map((sortField) => Object.keys(sortField)[0]);
  var optimalSortIndexCompareString = optimalSortIndex.join(",");
  var hasDescSorting = !!query.sort.find((sortField) => Object.values(sortField)[0] === "desc");
  var currentBestQuality = -1;
  var currentBestQueryPlan;
  indexes.forEach((index2) => {
    var inclusiveEnd = true;
    var inclusiveStart = true;
    var opts = index2.map((indexField) => {
      var matcher = selector[indexField];
      var operators = matcher ? Object.keys(matcher) : [];
      var matcherOpts = {};
      if (!matcher || !operators.length) {
        var startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;
        matcherOpts = {
          startKey,
          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,
          inclusiveStart: true,
          inclusiveEnd: true
        };
      } else {
        operators.forEach((operator) => {
          if (LOGICAL_OPERATORS.has(operator)) {
            var operatorValue = matcher[operator];
            var partialOpts = getMatcherQueryOpts(operator, operatorValue);
            matcherOpts = Object.assign(matcherOpts, partialOpts);
          }
        });
      }
      if (typeof matcherOpts.startKey === "undefined") {
        matcherOpts.startKey = INDEX_MIN;
      }
      if (typeof matcherOpts.endKey === "undefined") {
        matcherOpts.endKey = INDEX_MAX;
      }
      if (typeof matcherOpts.inclusiveStart === "undefined") {
        matcherOpts.inclusiveStart = true;
      }
      if (typeof matcherOpts.inclusiveEnd === "undefined") {
        matcherOpts.inclusiveEnd = true;
      }
      if (inclusiveStart && !matcherOpts.inclusiveStart) {
        inclusiveStart = false;
      }
      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {
        inclusiveEnd = false;
      }
      return matcherOpts;
    });
    var queryPlan = {
      index: index2,
      startKeys: opts.map((opt) => opt.startKey),
      endKeys: opts.map((opt) => opt.endKey),
      inclusiveEnd,
      inclusiveStart,
      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index2.join(","),
      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index2, query.selector)
    };
    var quality = rateQueryPlan(schema, query, queryPlan);
    if (quality > 0 && quality > currentBestQuality || query.index) {
      currentBestQuality = quality;
      currentBestQueryPlan = queryPlan;
    }
  });
  if (!currentBestQueryPlan) {
    currentBestQueryPlan = {
      index: [primaryPath],
      startKeys: [INDEX_MIN],
      endKeys: [INDEX_MAX],
      inclusiveEnd: true,
      inclusiveStart: true,
      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath,
      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex([primaryPath], query.selector)
    };
  }
  return currentBestQueryPlan;
}
var LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte", "$lt", "$lte"]);
var LOWER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte"]);
var UPPER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$lt", "$lte"]);
function isSelectorSatisfiedByIndex(index2, selector) {
  var selectorEntries = Object.entries(selector);
  var hasNonMatchingOperator = selectorEntries.find(([fieldName, operation]) => {
    if (!index2.includes(fieldName)) {
      return true;
    }
    var hasNonLogicOperator = Object.entries(operation).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));
    return hasNonLogicOperator;
  });
  if (hasNonMatchingOperator) {
    return false;
  }
  var prevLowerBoundaryField;
  var hasMoreThenOneLowerBoundaryField = index2.find((fieldName) => {
    var operation = selector[fieldName];
    if (!operation) {
      return false;
    }
    var hasLowerLogicOp = Object.keys(operation).find((key) => LOWER_BOUND_LOGICAL_OPERATORS.has(key));
    if (prevLowerBoundaryField && hasLowerLogicOp) {
      return true;
    } else if (hasLowerLogicOp !== "$eq") {
      prevLowerBoundaryField = hasLowerLogicOp;
    }
    return false;
  });
  if (hasMoreThenOneLowerBoundaryField) {
    return false;
  }
  var prevUpperBoundaryField;
  var hasMoreThenOneUpperBoundaryField = index2.find((fieldName) => {
    var operation = selector[fieldName];
    if (!operation) {
      return false;
    }
    var hasUpperLogicOp = Object.keys(operation).find((key) => UPPER_BOUND_LOGICAL_OPERATORS.has(key));
    if (prevUpperBoundaryField && hasUpperLogicOp) {
      return true;
    } else if (hasUpperLogicOp !== "$eq") {
      prevUpperBoundaryField = hasUpperLogicOp;
    }
    return false;
  });
  if (hasMoreThenOneUpperBoundaryField) {
    return false;
  }
  return true;
}
function getMatcherQueryOpts(operator, operatorValue) {
  switch (operator) {
    case "$eq":
      return {
        startKey: operatorValue,
        endKey: operatorValue
      };
    case "$lte":
      return {
        endKey: operatorValue
      };
    case "$gte":
      return {
        startKey: operatorValue
      };
    case "$lt":
      return {
        endKey: operatorValue,
        inclusiveEnd: false
      };
    case "$gt":
      return {
        startKey: operatorValue,
        inclusiveStart: false
      };
    default:
      throw new Error("SNH");
  }
}
function rateQueryPlan(schema, query, queryPlan) {
  var quality = 0;
  var addQuality = (value) => {
    if (value > 0) {
      quality = quality + value;
    }
  };
  var pointsPerMatchingKey = 10;
  var nonMinKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);
  addQuality(nonMinKeyCount * pointsPerMatchingKey);
  var nonMaxKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);
  addQuality(nonMaxKeyCount * pointsPerMatchingKey);
  var equalKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue, idx) => {
    if (keyValue === queryPlan.endKeys[idx]) {
      return true;
    } else {
      return false;
    }
  });
  addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);
  var pointsIfNoReSortMustBeDone = queryPlan.sortFieldsSameAsIndexFields ? 5 : 0;
  addQuality(pointsIfNoReSortMustBeDone);
  return quality;
}
const MAX_INT = 2147483647;
const MIN_INT = -2147483648;
const MAX_LONG = Number.MAX_SAFE_INTEGER;
const MIN_LONG = Number.MIN_SAFE_INTEGER;
const MISSING = Symbol("missing");
const OBJECT_PROTOTYPE = Object.getPrototypeOf({});
const OBJECT_TAG = "[object Object]";
const OBJECT_TYPE_RE = /^\[object ([a-zA-Z0-9]+)\]$/;
const DEFAULT_HASH_FUNCTION = (value) => {
  const s2 = stringify(value);
  let hash2 = 0;
  let i2 = s2.length;
  while (i2)
    hash2 = (hash2 << 5) - hash2 ^ s2.charCodeAt(--i2);
  return hash2 >>> 0;
};
const JS_SIMPLE_TYPES = /* @__PURE__ */ new Set([
  "null",
  "undefined",
  "boolean",
  "number",
  "string",
  "date",
  "regexp"
]);
const SORT_ORDER_BY_TYPE = {
  null: 0,
  undefined: 0,
  number: 1,
  string: 2,
  object: 3,
  array: 4,
  boolean: 5,
  date: 6,
  regexp: 7,
  function: 8
};
const compare$2 = (a2, b2) => {
  if (a2 === MISSING)
    a2 = void 0;
  if (b2 === MISSING)
    b2 = void 0;
  const [u2, v2] = [a2, b2].map((n2) => SORT_ORDER_BY_TYPE[getType(n2).toLowerCase()]);
  if (u2 !== v2)
    return u2 - v2;
  if (u2 === 1 || u2 === 2 || u2 === 6) {
    if (a2 < b2)
      return -1;
    if (a2 > b2)
      return 1;
    return 0;
  }
  if (isEqual(a2, b2))
    return 0;
  if (a2 < b2)
    return -1;
  if (a2 > b2)
    return 1;
  return 0;
};
function assert(condition, message) {
  if (!condition)
    throw new Error(message);
}
const cloneDeep = (obj) => {
  const m2 = /* @__PURE__ */ new Map();
  const add = (v2) => {
    if (m2.has(v2))
      throw new Error("cycle detected during clone operation.");
    m2.set(v2, true);
  };
  const clone2 = (val) => {
    if (val instanceof Date)
      return new Date(val);
    if (isArray$2(val)) {
      add(val);
      const res = new Array(val.length);
      const len = val.length;
      for (let i2 = 0; i2 < len; i2++)
        res[i2] = clone2(val[i2]);
      return res;
    }
    if (isObject$4(val)) {
      add(val);
      const res = {};
      for (const k2 in val)
        res[k2] = clone2(val[k2]);
      return res;
    }
    return val;
  };
  return clone2(obj);
};
const getType = (v2) => OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v2))[1];
const isBoolean$1 = (v2) => typeof v2 === "boolean";
const isString$1 = (v2) => typeof v2 === "string";
const isNumber$2 = (v2) => !isNaN(v2) && typeof v2 === "number";
const isArray$2 = Array.isArray;
const isObject$4 = (v2) => {
  if (!v2)
    return false;
  const proto = Object.getPrototypeOf(v2);
  return (proto === OBJECT_PROTOTYPE || proto === null) && OBJECT_TAG === Object.prototype.toString.call(v2);
};
const isObjectLike = (v2) => v2 === Object(v2);
const isDate$2 = (v2) => v2 instanceof Date;
const isRegExp$1 = (v2) => v2 instanceof RegExp;
const isFunction$4 = (v2) => typeof v2 === "function";
const isNil = (v2) => v2 === null || v2 === void 0;
const inArray = (arr, item) => arr.includes(item);
const notInArray = (arr, item) => !inArray(arr, item);
const truthy = (arg, strict = true) => !!arg || strict && arg === "";
const isEmpty = (x2) => isNil(x2) || isString$1(x2) && !x2 || x2 instanceof Array && x2.length === 0 || isObject$4(x2) && Object.keys(x2).length === 0;
const isMissing = (v2) => v2 === MISSING;
const ensureArray = (x2) => x2 instanceof Array ? x2 : [x2];
const has$2 = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);
const mergeable = (left2, right2) => isObject$4(left2) && isObject$4(right2) || isArray$2(left2) && isArray$2(right2);
function merge$2(target, obj, options) {
  options = options || { flatten: false };
  if (isMissing(target) || isNil(target))
    return obj;
  if (isMissing(obj) || isNil(obj))
    return target;
  if (!mergeable(target, obj)) {
    if (options.skipValidation)
      return obj || target;
    throw Error("mismatched types. must both be array or object");
  }
  options.skipValidation = true;
  if (isArray$2(target)) {
    const result = target;
    const input = obj;
    if (options.flatten) {
      let i2 = 0;
      let j2 = 0;
      while (i2 < result.length && j2 < input.length) {
        result[i2] = merge$2(result[i2++], input[j2++], options);
      }
      while (j2 < input.length) {
        result.push(obj[j2++]);
      }
    } else {
      into(result, input);
    }
  } else {
    for (const k2 in obj) {
      target[k2] = merge$2(target[k2], obj[k2], options);
    }
  }
  return target;
}
function buildHashIndex(arr, hashFunction = DEFAULT_HASH_FUNCTION) {
  const map2 = /* @__PURE__ */ new Map();
  arr.forEach((o2, i2) => {
    const h2 = hashCode(o2, hashFunction);
    if (map2.has(h2)) {
      if (!map2.get(h2).some((j2) => isEqual(arr[j2], o2))) {
        map2.get(h2).push(i2);
      }
    } else {
      map2.set(h2, [i2]);
    }
  });
  return map2;
}
function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {
  if (input.some((arr) => arr.length == 0))
    return [];
  if (input.length === 1)
    return Array.from(input);
  const sortedIndex = sortBy(input.map((a2, i2) => [i2, a2.length]), (a2) => a2[1]);
  const smallest = input[sortedIndex[0][0]];
  const map2 = buildHashIndex(smallest, hashFunction);
  const rmap = /* @__PURE__ */ new Map();
  const results = new Array();
  map2.forEach((v2, k2) => {
    const lhs = v2.map((j2) => smallest[j2]);
    const res = lhs.map((_2) => 0);
    const stable = lhs.map((_2) => [sortedIndex[0][0], 0]);
    let found = false;
    for (let i2 = 1; i2 < input.length; i2++) {
      const [currIndex, _2] = sortedIndex[i2];
      const arr = input[currIndex];
      if (!rmap.has(i2))
        rmap.set(i2, buildHashIndex(arr));
      if (rmap.get(i2).has(k2)) {
        const rhs = rmap.get(i2).get(k2).map((j2) => arr[j2]);
        found = lhs.map((s2, n2) => rhs.some((t3, m2) => {
          const p2 = res[n2];
          if (isEqual(s2, t3)) {
            res[n2]++;
            if (currIndex < stable[n2][0]) {
              stable[n2] = [currIndex, rmap.get(i2).get(k2)[m2]];
            }
          }
          return p2 < res[n2];
        })).some(Boolean);
      }
      if (!found)
        return;
    }
    if (found) {
      into(results, res.map((n2, i2) => {
        return n2 === input.length - 1 ? [lhs[i2], stable[i2]] : MISSING;
      }).filter((n2) => n2 !== MISSING));
    }
  });
  return results.sort((a2, b2) => {
    const [_i, [u2, m2]] = a2;
    const [_j, [v2, n2]] = b2;
    const r2 = compare$2(u2, v2);
    if (r2 !== 0)
      return r2;
    return compare$2(m2, n2);
  }).map((v2) => v2[0]);
}
function flatten(xs, depth = 0) {
  const arr = new Array();
  function flatten2(ys, n2) {
    for (let i2 = 0, len = ys.length; i2 < len; i2++) {
      if (isArray$2(ys[i2]) && (n2 > 0 || n2 < 0)) {
        flatten2(ys[i2], Math.max(-1, n2 - 1));
      } else {
        arr.push(ys[i2]);
      }
    }
  }
  flatten2(xs, depth);
  return arr;
}
function isEqual(a2, b2) {
  const lhs = [a2];
  const rhs = [b2];
  while (lhs.length > 0) {
    a2 = lhs.pop();
    b2 = rhs.pop();
    if (a2 === b2)
      continue;
    const nativeType = getType(a2).toLowerCase();
    if (nativeType !== getType(b2).toLowerCase() || nativeType === "function") {
      return false;
    }
    if (nativeType === "array") {
      const xs = a2;
      const ys = b2;
      if (xs.length !== ys.length)
        return false;
      if (xs.length === ys.length && xs.length === 0)
        continue;
      into(lhs, xs);
      into(rhs, ys);
    } else if (nativeType === "object") {
      const aKeys = Object.keys(a2);
      const bKeys = Object.keys(b2);
      if (aKeys.length !== bKeys.length)
        return false;
      for (let i2 = 0, len = aKeys.length; i2 < len; i2++) {
        const k2 = aKeys[i2];
        if (!has$2(b2, k2))
          return false;
        lhs.push(a2[k2]);
        rhs.push(b2[k2]);
      }
    } else {
      if (stringify(a2) !== stringify(b2))
        return false;
    }
  }
  return lhs.length === 0;
}
function stringify(value) {
  const type2 = getType(value).toLowerCase();
  switch (type2) {
    case "boolean":
    case "number":
    case "regexp":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "date":
      return value.toISOString();
    case "null":
    case "undefined":
      return type2;
    case "array":
      return "[" + value.map(stringify).join(",") + "]";
  }
  const prefix2 = type2 === "object" ? "" : `${getType(value)}`;
  const objKeys = Object.keys(value);
  objKeys.sort();
  return `${prefix2}{` + objKeys.map((k2) => `${stringify(k2)}:${stringify(value[k2])}`).join(",") + "}";
}
function hashCode(value, hashFunction) {
  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;
  if (isNil(value))
    return null;
  return hashFunction(value).toString();
}
function sortBy(collection, keyFn, comparator = compare$2) {
  if (isEmpty(collection))
    return collection;
  const sorted = new Array();
  const result = new Array();
  for (let i2 = 0; i2 < collection.length; i2++) {
    const obj = collection[i2];
    const key = keyFn(obj, i2);
    if (isNil(key)) {
      result.push(obj);
    } else {
      sorted.push([key, obj]);
    }
  }
  sorted.sort((a2, b2) => comparator(a2[0], b2[0]));
  return into(result, sorted.map((o2) => o2[1]));
}
function groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {
  if (collection.length < 1)
    return /* @__PURE__ */ new Map();
  const lookup2 = /* @__PURE__ */ new Map();
  const result = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < collection.length; i2++) {
    const obj = collection[i2];
    const key = keyFn(obj, i2);
    const hash2 = hashCode(key, hashFunction);
    if (hash2 === null) {
      if (result.has(null)) {
        result.get(null).push(obj);
      } else {
        result.set(null, [obj]);
      }
    } else {
      const existingKey = lookup2.has(hash2) ? lookup2.get(hash2).find((k2) => isEqual(k2, key)) : null;
      if (isNil(existingKey)) {
        result.set(key, [obj]);
        if (lookup2.has(hash2)) {
          lookup2.get(hash2).push(key);
        } else {
          lookup2.set(hash2, [key]);
        }
      } else {
        result.get(existingKey).push(obj);
      }
    }
  }
  return result;
}
const MAX_ARRAY_PUSH = 5e4;
function into(target, ...rest) {
  if (target instanceof Array) {
    return rest.reduce((acc, arr) => {
      let i2 = Math.ceil(arr.length / MAX_ARRAY_PUSH);
      let begin = 0;
      while (i2-- > 0) {
        Array.prototype.push.apply(acc, arr.slice(begin, begin + MAX_ARRAY_PUSH));
        begin += MAX_ARRAY_PUSH;
      }
      return acc;
    }, target);
  } else {
    return rest.filter(isObjectLike).reduce((acc, item) => {
      Object.assign(acc, item);
      return acc;
    }, target);
  }
}
function getValue(obj, key) {
  return isObjectLike(obj) ? obj[key] : void 0;
}
function unwrap(arr, depth) {
  if (depth < 1)
    return arr;
  while (depth-- && arr.length === 1)
    arr = arr[0];
  return arr;
}
function resolve(obj, selector, options) {
  let depth = 0;
  function resolve2(o2, path) {
    let value = o2;
    for (let i2 = 0; i2 < path.length; i2++) {
      const field = path[i2];
      const isText = /^\d+$/.exec(field) === null;
      if (isText && value instanceof Array) {
        if (i2 === 0 && depth > 0)
          break;
        depth += 1;
        const subpath = path.slice(i2);
        value = value.reduce((acc, item) => {
          const v2 = resolve2(item, subpath);
          if (v2 !== void 0)
            acc.push(v2);
          return acc;
        }, []);
        break;
      } else {
        value = getValue(value, field);
      }
      if (value === void 0)
        break;
    }
    return value;
  }
  const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase()) ? obj : resolve2(obj, selector.split("."));
  return result instanceof Array && (options === null || options === void 0 ? void 0 : options.unwrapArray) ? unwrap(result, depth) : result;
}
function resolveGraph(obj, selector, options) {
  const names = selector.split(".");
  const key = names[0];
  const next2 = names.slice(1).join(".");
  const isIndex2 = /^\d+$/.exec(key) !== null;
  const hasNext = names.length > 1;
  let result;
  let value;
  if (obj instanceof Array) {
    if (isIndex2) {
      result = getValue(obj, Number(key));
      if (hasNext) {
        result = resolveGraph(result, next2, options);
      }
      result = [result];
    } else {
      result = [];
      for (const item of obj) {
        value = resolveGraph(item, selector, options);
        if (options === null || options === void 0 ? void 0 : options.preserveMissing) {
          if (value === void 0) {
            value = MISSING;
          }
          result.push(value);
        } else if (value !== void 0) {
          result.push(value);
        }
      }
    }
  } else {
    value = getValue(obj, key);
    if (hasNext) {
      value = resolveGraph(value, next2, options);
    }
    if (value === void 0)
      return void 0;
    result = (options === null || options === void 0 ? void 0 : options.preserveKeys) ? Object.assign({}, obj) : {};
    result[key] = value;
  }
  return result;
}
function filterMissing(obj) {
  if (obj instanceof Array) {
    for (let i2 = obj.length - 1; i2 >= 0; i2--) {
      if (obj[i2] === MISSING) {
        obj.splice(i2, 1);
      } else {
        filterMissing(obj[i2]);
      }
    }
  } else if (isObject$4(obj)) {
    for (const k2 in obj) {
      if (has$2(obj, k2)) {
        filterMissing(obj[k2]);
      }
    }
  }
}
const NUMBER_RE = /^\d+$/;
function walk(obj, selector, fn3, options) {
  const names = selector.split(".");
  const key = names[0];
  const next2 = names.slice(1).join(".");
  if (names.length === 1) {
    if (isObject$4(obj) || isArray$2(obj) && NUMBER_RE.test(key)) {
      fn3(obj, key);
    }
  } else {
    if ((options === null || options === void 0 ? void 0 : options.buildGraph) && isNil(obj[key])) {
      obj[key] = {};
    }
    const item = obj[key];
    if (!item)
      return;
    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));
    if (item instanceof Array && (options === null || options === void 0 ? void 0 : options.descendArray) && !isNextArrayIndex) {
      item.forEach((e2) => walk(e2, next2, fn3, options));
    } else {
      walk(item, next2, fn3, options);
    }
  }
}
function setValue(obj, selector, value) {
  walk(obj, selector, (item, key) => {
    item[key] = value;
  }, { buildGraph: true });
}
function removeValue(obj, selector, options) {
  walk(obj, selector, (item, key) => {
    if (item instanceof Array) {
      if (/^\d+$/.test(key)) {
        item.splice(parseInt(key), 1);
      } else if (options && options.descendArray) {
        for (const elem of item) {
          if (isObject$4(elem)) {
            delete elem[key];
          }
        }
      }
    } else if (isObject$4(item)) {
      delete item[key];
    }
  }, options);
}
const OPERATOR_NAME_PATTERN = /^\$[a-zA-Z0-9_]+$/;
function isOperator(name) {
  return OPERATOR_NAME_PATTERN.test(name);
}
function normalize$1(expr) {
  if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {
    return isRegExp$1(expr) ? { $regex: expr } : { $eq: expr };
  }
  if (isObjectLike(expr)) {
    const exprObj = expr;
    if (!Object.keys(exprObj).some(isOperator)) {
      return { $eq: expr };
    }
    if (has$2(expr, "$regex")) {
      const newExpr = Object.assign({}, expr);
      newExpr["$regex"] = new RegExp(expr["$regex"], expr["$options"]);
      delete newExpr["$options"];
      return newExpr;
    }
  }
  return expr;
}
var ProcessingMode;
(function(ProcessingMode2) {
  ProcessingMode2["CLONE_ALL"] = "CLONE_ALL";
  ProcessingMode2["CLONE_INPUT"] = "CLONE_INPUT";
  ProcessingMode2["CLONE_OUTPUT"] = "CLONE_OUTPUT";
  ProcessingMode2["CLONE_OFF"] = "CLONE_OFF";
})(ProcessingMode || (ProcessingMode = {}));
class ComputeOptions {
  constructor(_opts, _root, _local, timestamp = Date.now()) {
    this._opts = _opts;
    this._root = _root;
    this._local = _local;
    this.timestamp = timestamp;
    this.update(_root, _local);
  }
  /**
   * Initialize new ComputeOptions.
   *
   * @param options
   * @param root
   * @param local
   * @returns {ComputeOptions}
   */
  static init(options, root2, local) {
    return options instanceof ComputeOptions ? new ComputeOptions(options._opts, isNil(options.root) ? root2 : options.root, Object.assign({}, options.local, local)) : new ComputeOptions(options, root2, local);
  }
  /** Updates the internal mutable state. */
  update(root2, local) {
    var _a2;
    this._root = root2;
    this._local = local ? Object.assign({}, local, {
      variables: Object.assign({}, (_a2 = this._local) === null || _a2 === void 0 ? void 0 : _a2.variables, local === null || local === void 0 ? void 0 : local.variables)
    }) : local;
    return this;
  }
  getOptions() {
    return Object.freeze(Object.assign(Object.assign({}, this._opts), { context: Context$1.from(this._opts.context) }));
  }
  get root() {
    return this._root;
  }
  get local() {
    return this._local;
  }
  get idKey() {
    return this._opts.idKey;
  }
  get collation() {
    var _a2;
    return (_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.collation;
  }
  get processingMode() {
    var _a2;
    return ((_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.processingMode) || ProcessingMode.CLONE_OFF;
  }
  get useStrictMode() {
    var _a2;
    return (_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.useStrictMode;
  }
  get scriptEnabled() {
    var _a2;
    return (_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.scriptEnabled;
  }
  get useGlobalContext() {
    var _a2;
    return (_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.useGlobalContext;
  }
  get hashFunction() {
    var _a2;
    return (_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.hashFunction;
  }
  get collectionResolver() {
    var _a2;
    return (_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.collectionResolver;
  }
  get jsonSchemaValidator() {
    var _a2;
    return (_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.jsonSchemaValidator;
  }
  get variables() {
    var _a2;
    return (_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.variables;
  }
  get context() {
    var _a2;
    return (_a2 = this._opts) === null || _a2 === void 0 ? void 0 : _a2.context;
  }
}
function initOptions(options) {
  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze(Object.assign(Object.assign({ idKey: "_id", scriptEnabled: true, useStrictMode: true, useGlobalContext: true, processingMode: ProcessingMode.CLONE_OFF }, options), { context: (options === null || options === void 0 ? void 0 : options.context) ? Context$1.from(options === null || options === void 0 ? void 0 : options.context) : Context$1.init({}) }));
}
var OperatorType;
(function(OperatorType2) {
  OperatorType2["ACCUMULATOR"] = "accumulator";
  OperatorType2["EXPRESSION"] = "expression";
  OperatorType2["PIPELINE"] = "pipeline";
  OperatorType2["PROJECTION"] = "projection";
  OperatorType2["QUERY"] = "query";
  OperatorType2["WINDOW"] = "window";
})(OperatorType || (OperatorType = {}));
let Context$1 = class Context {
  constructor(ops) {
    this.operators = cloneDeep(ops);
  }
  static init(ops) {
    return new Context(merge$2({
      [OperatorType.ACCUMULATOR]: {},
      [OperatorType.EXPRESSION]: {},
      [OperatorType.PIPELINE]: {},
      [OperatorType.PROJECTION]: {},
      [OperatorType.QUERY]: {},
      [OperatorType.WINDOW]: {}
    }, ops, { skipValidation: true }));
  }
  static from(ctx) {
    return new Context(ctx.operators);
  }
  addOperators(type2, ops) {
    for (const [name, fn3] of Object.entries(ops)) {
      if (!this.getOperator(type2, name)) {
        this.operators[type2][name] = fn3;
      }
    }
    return this;
  }
  // register
  addAccumulatorOps(ops) {
    return this.addOperators(OperatorType.ACCUMULATOR, ops);
  }
  addExpressionOps(ops) {
    return this.addOperators(OperatorType.EXPRESSION, ops);
  }
  addQueryOps(ops) {
    return this.addOperators(OperatorType.QUERY, ops);
  }
  addPipelineOps(ops) {
    return this.addOperators(OperatorType.PIPELINE, ops);
  }
  addProjectionOps(ops) {
    return this.addOperators(OperatorType.PROJECTION, ops);
  }
  addWindowOps(ops) {
    return this.addOperators(OperatorType.WINDOW, ops);
  }
  // getters
  getOperator(type2, name) {
    return type2 in this.operators ? this.operators[type2][name] || null : null;
  }
};
const CONTEXT = Context$1.init({});
function useOperators(type2, operators) {
  for (const [name, fn3] of Object.entries(operators)) {
    assert(isFunction$4(fn3) && isOperator(name), `'${name}' is not a valid operator`);
    const currentFn = getOperator(type2, name, null);
    assert(!currentFn || fn3 === currentFn, `${name} already exists for '${type2}' operators. Cannot change operator function once registered.`);
  }
  CONTEXT.addOperators(type2, operators);
}
function getOperator(type2, operator, options) {
  const { context: ctx, useGlobalContext: fallback } = options || {};
  const fn3 = ctx ? ctx.getOperator(type2, operator) : null;
  return !fn3 && fallback ? CONTEXT.getOperator(type2, operator) : fn3;
}
const systemVariables = {
  $$ROOT(obj, expr, options) {
    return options.root;
  },
  $$CURRENT(obj, expr, options) {
    return obj;
  },
  $$REMOVE(obj, expr, options) {
    return void 0;
  },
  $$NOW(obj, expr, options) {
    return new Date(options.timestamp);
  }
};
const redactVariables = {
  $$KEEP(obj, expr, options) {
    return obj;
  },
  $$PRUNE(obj, expr, options) {
    return void 0;
  },
  $$DESCEND(obj, expr, options) {
    if (!has$2(expr, "$cond"))
      return obj;
    let result;
    for (const [key, current] of Object.entries(obj)) {
      if (isObjectLike(current)) {
        if (current instanceof Array) {
          const array2 = [];
          for (let elem of current) {
            if (isObject$4(elem)) {
              elem = redact(elem, expr, options.update(elem));
            }
            if (!isNil(elem)) {
              array2.push(elem);
            }
          }
          result = array2;
        } else {
          result = redact(current, expr, options.update(current));
        }
        if (isNil(result)) {
          delete obj[key];
        } else {
          obj[key] = result;
        }
      }
    }
    return obj;
  }
};
function computeValue(obj, expr, operator, options) {
  var _a2;
  const copts = ComputeOptions.init(options, obj);
  operator = operator || "";
  if (isOperator(operator)) {
    const callExpression = getOperator(OperatorType.EXPRESSION, operator, options);
    if (callExpression)
      return callExpression(obj, expr, copts);
    const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator, options);
    if (callAccumulator) {
      if (!(obj instanceof Array)) {
        obj = computeValue(obj, expr, null, copts);
        expr = null;
      }
      assert(obj instanceof Array, `'${operator}' target must be an array.`);
      return callAccumulator(
        obj,
        expr,
        // reset the root object for accumulators.
        copts.update(null, copts.local)
      );
    }
    throw new Error(`operator '${operator}' is not registered`);
  }
  if (isString$1(expr) && expr.length > 0 && expr[0] === "$") {
    if (has$2(redactVariables, expr)) {
      return expr;
    }
    let context = copts.root;
    const arr = expr.split(".");
    if (has$2(systemVariables, arr[0])) {
      context = systemVariables[arr[0]](obj, null, copts);
      expr = expr.slice(arr[0].length + 1);
    } else if (arr[0].slice(0, 2) === "$$") {
      context = Object.assign(
        {},
        copts.variables,
        // global vars
        // current item is added before local variables because the binding may be changed.
        { this: obj },
        (_a2 = copts.local) === null || _a2 === void 0 ? void 0 : _a2.variables
        // local vars
      );
      const prefix2 = arr[0].slice(2);
      assert(has$2(context, prefix2), `Use of undefined variable: ${prefix2}`);
      expr = expr.slice(2);
    } else {
      expr = expr.slice(1);
    }
    if (expr === "")
      return context;
    return resolve(context, expr);
  }
  if (isArray$2(expr)) {
    return expr.map((item) => computeValue(obj, item, null, copts));
  } else if (isObject$4(expr)) {
    const result = {};
    for (const [key, val] of Object.entries(expr)) {
      result[key] = computeValue(obj, val, key, copts);
      if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some((t3) => !!getOperator(t3, key, options))) {
        assert(Object.keys(expr).length === 1, "Invalid aggregation expression '" + JSON.stringify(expr) + "'");
        return result[key];
      }
    }
    return result;
  }
  return expr;
}
function redact(obj, expr, options) {
  const result = computeValue(obj, expr, null, options);
  return has$2(redactVariables, result) ? redactVariables[result](obj, expr, options) : result;
}
function Lazy(source) {
  return source instanceof Iterator ? source : new Iterator(source);
}
function compose(...iterators) {
  let index2 = 0;
  return Lazy(() => {
    while (index2 < iterators.length) {
      const o2 = iterators[index2].next();
      if (!o2.done)
        return o2;
      index2++;
    }
    return { done: true };
  });
}
function isGenerator(o2) {
  return !!o2 && typeof o2 === "object" && (o2 === null || o2 === void 0 ? void 0 : o2.next) instanceof Function;
}
function dropItem(array2, i2) {
  const rest = array2.slice(i2 + 1);
  array2.splice(i2);
  Array.prototype.push.apply(array2, rest);
}
const DONE = new Error();
var Action;
(function(Action2) {
  Action2[Action2["MAP"] = 0] = "MAP";
  Action2[Action2["FILTER"] = 1] = "FILTER";
  Action2[Action2["TAKE"] = 2] = "TAKE";
  Action2[Action2["DROP"] = 3] = "DROP";
})(Action || (Action = {}));
function createCallback(nextFn, iteratees, buffer) {
  let done = false;
  let index2 = -1;
  let bufferIndex = 0;
  return function(storeResult) {
    try {
      outer:
        while (!done) {
          let o2 = nextFn();
          index2++;
          let i2 = -1;
          const size = iteratees.length;
          let innerDone = false;
          while (++i2 < size) {
            const r2 = iteratees[i2];
            switch (r2.action) {
              case Action.MAP:
                o2 = r2.func(o2, index2);
                break;
              case Action.FILTER:
                if (!r2.func(o2, index2))
                  continue outer;
                break;
              case Action.TAKE:
                --r2.count;
                if (!r2.count)
                  innerDone = true;
                break;
              case Action.DROP:
                --r2.count;
                if (!r2.count)
                  dropItem(iteratees, i2);
                continue outer;
              default:
                break outer;
            }
          }
          done = innerDone;
          if (storeResult) {
            buffer[bufferIndex++] = o2;
          } else {
            return { value: o2, done: false };
          }
        }
    } catch (e2) {
      if (e2 !== DONE)
        throw e2;
    }
    done = true;
    return { done };
  };
}
class Iterator {
  /**
   * @param {*} source An iterable object or function.
   *    Array - return one element per cycle
   *    Object{next:Function} - call next() for the next value (this also handles generator functions)
   *    Function - call to return the next value
   * @param {Function} fn An optional transformation function
   */
  constructor(source) {
    this.iteratees = [];
    this.yieldedValues = [];
    this.isDone = false;
    let nextVal;
    if (source instanceof Function) {
      source = { next: source };
    }
    if (isGenerator(source)) {
      const src2 = source;
      nextVal = () => {
        const o2 = src2.next();
        if (o2.done)
          throw DONE;
        return o2.value;
      };
    } else if (source instanceof Array) {
      const data = source;
      const size = data.length;
      let index2 = 0;
      nextVal = () => {
        if (index2 < size)
          return data[index2++];
        throw DONE;
      };
    } else if (!(source instanceof Function)) {
      throw new Error(`Source is of type '${typeof source}'. Must be Array, Function, or Generator`);
    }
    this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);
  }
  /**
   * Add an iteratee to this lazy sequence
   */
  push(action, value) {
    if (typeof value === "function") {
      this.iteratees.push({ action, func: value });
    } else if (typeof value === "number") {
      this.iteratees.push({ action, count: value });
    }
    return this;
  }
  next() {
    return this.getNext();
  }
  // Iteratees methods
  /**
   * Transform each item in the sequence to a new value
   * @param {Function} f
   */
  map(f2) {
    return this.push(Action.MAP, f2);
  }
  /**
   * Select only items matching the given predicate
   * @param {Function} pred
   */
  filter(predicate) {
    return this.push(Action.FILTER, predicate);
  }
  /**
   * Take given numbe for values from sequence
   * @param {Number} n A number greater than 0
   */
  take(n2) {
    return n2 > 0 ? this.push(Action.TAKE, n2) : this;
  }
  /**
   * Drop a number of values from the sequence
   * @param {Number} n Number of items to drop greater than 0
   */
  drop(n2) {
    return n2 > 0 ? this.push(Action.DROP, n2) : this;
  }
  // Transformations
  /**
   * Returns a new lazy object with results of the transformation
   * The entire sequence is realized.
   *
   * @param {Function} fn Tranform function of type (Array) => (Any)
   */
  transform(fn3) {
    const self2 = this;
    let iter;
    return Lazy(() => {
      if (!iter) {
        iter = Lazy(fn3(self2.value()));
      }
      return iter.next();
    });
  }
  // Terminal methods
  /**
   * Returns the fully realized values of the iterators.
   * The return value will be an array unless `lazy.first()` was used.
   * The realized values are cached for subsequent calls.
   */
  value() {
    if (!this.isDone) {
      this.isDone = this.getNext(true).done;
    }
    return this.yieldedValues;
  }
  /**
   * Execute the funcion for each value. Will stop when an execution returns false.
   * @param {Function} f
   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true
   */
  each(f2) {
    for (; ; ) {
      const o2 = this.next();
      if (o2.done)
        break;
      if (f2(o2.value) === false)
        return false;
    }
    return true;
  }
  /**
   * Returns the reduction of sequence according the reducing function
   *
   * @param {*} f a reducing function
   * @param {*} initialValue
   */
  reduce(f2, initialValue) {
    let o2 = this.next();
    if (initialValue === void 0 && !o2.done) {
      initialValue = o2.value;
      o2 = this.next();
    }
    while (!o2.done) {
      initialValue = f2(initialValue, o2.value);
      o2 = this.next();
    }
    return initialValue;
  }
  /**
   * Returns the number of matched items in the sequence
   */
  size() {
    return this.reduce((acc, _2) => ++acc, 0);
  }
  [Symbol.iterator]() {
    return this;
  }
}
class Aggregator {
  constructor(pipeline, options) {
    this.pipeline = pipeline;
    this.options = initOptions(options);
  }
  /**
   * Returns an `Lazy` iterator for processing results of pipeline
   *
   * @param {*} collection An array or iterator object
   * @returns {Iterator} an iterator object
   */
  stream(collection) {
    let iterator2 = Lazy(collection);
    const mode = this.options.processingMode;
    if (mode == ProcessingMode.CLONE_ALL || mode == ProcessingMode.CLONE_INPUT) {
      iterator2.map(cloneDeep);
    }
    const pipelineOperators = new Array();
    if (!isEmpty(this.pipeline)) {
      for (const operator of this.pipeline) {
        const operatorKeys = Object.keys(operator);
        const opName = operatorKeys[0];
        const call = getOperator(OperatorType.PIPELINE, opName, this.options);
        assert(operatorKeys.length === 1 && !!call, `invalid pipeline operator ${opName}`);
        pipelineOperators.push(opName);
        iterator2 = call(iterator2, operator[opName], this.options);
      }
    }
    if (mode == ProcessingMode.CLONE_OUTPUT || mode == ProcessingMode.CLONE_ALL && !!intersection([["$group", "$unwind"], pipelineOperators]).length) {
      iterator2.map(cloneDeep);
    }
    return iterator2;
  }
  /**
   * Return the results of the aggregation as an array.
   *
   * @param {*} collection
   * @param {*} query
   */
  run(collection) {
    return this.stream(collection).value();
  }
}
class Cursor {
  constructor(source, predicate, projection, options) {
    this.source = source;
    this.predicate = predicate;
    this.projection = projection;
    this.options = options;
    this.operators = [];
    this.result = null;
    this.buffer = [];
  }
  /** Returns the iterator from running the query */
  fetch() {
    if (this.result)
      return this.result;
    if (isObject$4(this.projection)) {
      this.operators.push({ $project: this.projection });
    }
    this.result = Lazy(this.source).filter(this.predicate);
    if (this.operators.length > 0) {
      this.result = new Aggregator(this.operators, this.options).stream(this.result);
    }
    return this.result;
  }
  /** Returns an iterator with the buffered data included */
  fetchAll() {
    const buffered = Lazy([...this.buffer]);
    this.buffer = [];
    return compose(buffered, this.fetch());
  }
  /**
   * Return remaining objects in the cursor as an array. This method exhausts the cursor
   * @returns {Array}
   */
  all() {
    return this.fetchAll().value();
  }
  /**
   * Returns the number of objects return in the cursor. This method exhausts the cursor
   * @returns {Number}
   */
  count() {
    return this.all().length;
  }
  /**
   * Returns a cursor that begins returning results only after passing or skipping a number of documents.
   * @param {Number} n the number of results to skip.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  skip(n2) {
    this.operators.push({ $skip: n2 });
    return this;
  }
  /**
   * Constrains the size of a cursor's result set.
   * @param {Number} n the number of results to limit to.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  limit(n2) {
    this.operators.push({ $limit: n2 });
    return this;
  }
  /**
   * Returns results ordered according to a sort specification.
   * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  sort(modifier) {
    this.operators.push({ $sort: modifier });
    return this;
  }
  /**
   * Specifies the collation for the cursor returned by the `mingo.Query.find`
   * @param {*} spec
   */
  collation(spec) {
    this.options = Object.assign(Object.assign({}, this.options), { collation: spec });
    return this;
  }
  /**
   * Returns the next document in a cursor.
   * @returns {Object | Boolean}
   */
  next() {
    if (this.buffer.length > 0) {
      return this.buffer.pop();
    }
    const o2 = this.fetch().next();
    if (o2.done)
      return;
    return o2.value;
  }
  /**
   * Returns true if the cursor has documents and can be iterated.
   * @returns {boolean}
   */
  hasNext() {
    if (this.buffer.length > 0)
      return true;
    const o2 = this.fetch().next();
    if (o2.done)
      return false;
    this.buffer.push(o2.value);
    return true;
  }
  /**
   * Applies a function to each document in a cursor and collects the return values in an array.
   * @param fn
   * @returns {Array}
   */
  map(fn3) {
    return this.all().map(fn3);
  }
  /**
   * Applies a JavaScript function for every document in a cursor.
   * @param fn
   */
  forEach(fn3) {
    this.all().forEach(fn3);
  }
  [Symbol.iterator]() {
    return this.fetchAll();
  }
}
class Query {
  constructor(condition, options) {
    this.condition = condition;
    this.options = initOptions(options);
    this.compiled = [];
    this.compile();
  }
  compile() {
    assert(isObject$4(this.condition), "query criteria must be an object");
    const whereOperator = {};
    for (const [field, expr] of Object.entries(this.condition)) {
      if ("$where" === field) {
        Object.assign(whereOperator, { field, expr });
      } else if (inArray(["$and", "$or", "$nor", "$expr", "$jsonSchema"], field)) {
        this.processOperator(field, field, expr);
      } else {
        assert(!isOperator(field), `unknown top level operator: ${field}`);
        for (const [operator, val] of Object.entries(normalize$1(expr))) {
          this.processOperator(field, operator, val);
        }
      }
      if (whereOperator.field) {
        this.processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);
      }
    }
  }
  processOperator(field, operator, value) {
    const call = getOperator(OperatorType.QUERY, operator, this.options);
    if (!call) {
      throw new Error(`unknown operator ${operator}`);
    }
    const fn3 = call(field, value, this.options);
    this.compiled.push(fn3);
  }
  /**
   * Checks if the object passes the query criteria. Returns true if so, false otherwise.
   *
   * @param obj The object to test
   * @returns {boolean} True or false
   */
  test(obj) {
    for (let i2 = 0, len = this.compiled.length; i2 < len; i2++) {
      if (!this.compiled[i2](obj)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns a cursor to select matching documents from the input source.
   *
   * @param source A source providing a sequence of documents
   * @param projection An optional projection criteria
   * @returns {Cursor} A Cursor for iterating over the results
   */
  find(collection, projection) {
    return new Cursor(collection, (x2) => this.test(x2), projection || {}, this.options);
  }
  /**
   * Remove matched documents from the collection returning the remainder
   *
   * @param collection An array of documents
   * @returns {Array} A new array with matching elements removed
   */
  remove(collection) {
    return collection.reduce((acc, obj) => {
      if (!this.test(obj))
        acc.push(obj);
      return acc;
    }, []);
  }
}
function createQueryOperator(predicate) {
  const f2 = (selector, value, options) => {
    const opts = { unwrapArray: true };
    const depth = Math.max(1, selector.split(".").length - 1);
    return (obj) => {
      const lhs = resolve(obj, selector, opts);
      return predicate(lhs, value, Object.assign(Object.assign({}, options), { depth }));
    };
  };
  f2.op = "query";
  return f2;
}
function $eq$1(a2, b2, options) {
  if (isEqual(a2, b2))
    return true;
  if (isNil(a2) && isNil(b2))
    return true;
  if (a2 instanceof Array) {
    const eq2 = isEqual.bind(null, b2);
    return a2.some(eq2) || flatten(a2, options === null || options === void 0 ? void 0 : options.depth).some(eq2);
  }
  return false;
}
function $ne$1(a2, b2, options) {
  return !$eq$1(a2, b2, options);
}
function $in$1(a2, b2, options) {
  if (isNil(a2))
    return b2.some((v2) => v2 === null);
  return intersection([ensureArray(a2), b2], options === null || options === void 0 ? void 0 : options.hashFunction).length > 0;
}
function $nin$1(a2, b2, options) {
  return !$in$1(a2, b2, options);
}
function $lt$1(a2, b2, options) {
  return compare$1(a2, b2, (x2, y2) => compare$2(x2, y2) < 0);
}
function $lte$1(a2, b2, options) {
  return compare$1(a2, b2, (x2, y2) => compare$2(x2, y2) <= 0);
}
function $gt$1(a2, b2, options) {
  return compare$1(a2, b2, (x2, y2) => compare$2(x2, y2) > 0);
}
function $gte$1(a2, b2, options) {
  return compare$1(a2, b2, (x2, y2) => compare$2(x2, y2) >= 0);
}
function $mod$1(a2, b2, options) {
  return ensureArray(a2).some((x2) => b2.length === 2 && x2 % b2[0] === b2[1]);
}
function $regex$1(a2, b2, options) {
  const lhs = ensureArray(a2);
  const match2 = (x2) => isString$1(x2) && truthy(b2.exec(x2), options === null || options === void 0 ? void 0 : options.useStrictMode);
  return lhs.some(match2) || flatten(lhs, 1).some(match2);
}
function $exists$1(a2, b2, options) {
  return (b2 === false || b2 === 0) && a2 === void 0 || (b2 === true || b2 === 1) && a2 !== void 0;
}
function $all(values2, queries, options) {
  if (!isArray$2(values2) || !isArray$2(queries) || !values2.length || !queries.length) {
    return false;
  }
  let matched = true;
  for (const query of queries) {
    if (!matched)
      break;
    if (isObject$4(query) && inArray(Object.keys(query), "$elemMatch")) {
      matched = $elemMatch$1(values2, query["$elemMatch"], options);
    } else if (query instanceof RegExp) {
      matched = values2.some((s2) => typeof s2 === "string" && query.test(s2));
    } else {
      matched = values2.some((v2) => isEqual(query, v2));
    }
  }
  return matched;
}
function $size$1(a2, b2, options) {
  return Array.isArray(a2) && a2.length === b2;
}
function isNonBooleanOperator(name) {
  return isOperator(name) && ["$and", "$or", "$nor"].indexOf(name) === -1;
}
function $elemMatch$1(a2, b2, options) {
  if (isArray$2(a2) && !isEmpty(a2)) {
    let format2 = (x2) => x2;
    let criteria = b2;
    if (Object.keys(b2).every(isNonBooleanOperator)) {
      criteria = { temp: b2 };
      format2 = (x2) => ({ temp: x2 });
    }
    const query = new Query(criteria, options);
    for (let i2 = 0, len = a2.length; i2 < len; i2++) {
      if (query.test(format2(a2[i2]))) {
        return true;
      }
    }
  }
  return false;
}
const isNull = (a2) => a2 === null;
const isInt = (a2) => isNumber$2(a2) && a2 >= MIN_INT && a2 <= MAX_INT && a2.toString().indexOf(".") === -1;
const isLong = (a2) => isNumber$2(a2) && a2 >= MIN_LONG && a2 <= MAX_LONG && a2.toString().indexOf(".") === -1;
const compareFuncs = {
  array: isArray$2,
  bool: isBoolean$1,
  boolean: isBoolean$1,
  date: isDate$2,
  decimal: isNumber$2,
  double: isNumber$2,
  int: isInt,
  long: isLong,
  number: isNumber$2,
  null: isNull,
  object: isObject$4,
  regex: isRegExp$1,
  regexp: isRegExp$1,
  string: isString$1,
  // added for completeness
  undefined: isNil,
  function: (_2) => {
    throw new Error("unsupported type key `function`.");
  },
  // Mongo identifiers
  1: isNumber$2,
  2: isString$1,
  3: isObject$4,
  4: isArray$2,
  6: isNil,
  8: isBoolean$1,
  9: isDate$2,
  10: isNull,
  11: isRegExp$1,
  16: isInt,
  18: isLong,
  19: isNumber$2
  //decimal
};
function compareType(a2, b2, _2) {
  const f2 = compareFuncs[b2];
  return f2 ? f2(a2) : false;
}
function $type$1(a2, b2, options) {
  return Array.isArray(b2) ? b2.findIndex((t3) => compareType(a2, t3)) >= 0 : compareType(a2, b2);
}
function compare$1(a2, b2, f2) {
  return ensureArray(a2).some((x2) => getType(x2) === getType(b2) && f2(x2, b2));
}
const buildMap = (letters, sign) => {
  const h2 = {};
  letters.split("").forEach((v2, i2) => h2[v2] = sign * (i2 + 1));
  return h2;
};
Object.assign(Object.assign(Object.assign({}, buildMap("ABCDEFGHIKLM", 1)), buildMap("NOPQRSTUVWXY", -1)), { Z: 0 });
const FIXED_POINTS = {
  undefined: null,
  null: null,
  NaN: NaN,
  Infinity: new Error(),
  "-Infinity": new Error()
};
function createTrignometryOperator(f2, fixedPoints = FIXED_POINTS) {
  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);
  const keySet = new Set(Object.keys(fp));
  return (obj, expr, options) => {
    const n2 = computeValue(obj, expr, null, options);
    if (keySet.has(`${n2}`)) {
      const res = fp[`${n2}`];
      if (res instanceof Error) {
        throw new Error(`cannot apply $${f2.name} to -inf, value must in (-inf,inf)`);
      }
      return res;
    }
    return f2(n2);
  };
}
createTrignometryOperator(Math.acos, {
  Infinity: Infinity,
  0: new Error()
});
createTrignometryOperator(Math.acosh, {
  Infinity: Infinity,
  0: new Error()
});
createTrignometryOperator(Math.asin);
createTrignometryOperator(Math.asinh, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});
createTrignometryOperator(Math.atan);
createTrignometryOperator(Math.atanh, {
  1: Infinity,
  "-1": -Infinity
});
createTrignometryOperator(Math.cos);
createTrignometryOperator(Math.cosh, {
  "-Infinity": Infinity,
  Infinity: Infinity
  // [Math.PI]: -1,
});
const RADIANS_FACTOR = Math.PI / 180;
createTrignometryOperator((n2) => n2 * RADIANS_FACTOR, {
  Infinity: Infinity,
  "-Infinity": Infinity
});
const DEGREES_FACTOR = 180 / Math.PI;
createTrignometryOperator((n2) => n2 * DEGREES_FACTOR, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});
createTrignometryOperator(Math.sin);
createTrignometryOperator(Math.sinh, {
  "-Infinity": -Infinity,
  Infinity: Infinity
});
createTrignometryOperator(Math.tan);
const $sort = (collection, sortKeys, options) => {
  if (isEmpty(sortKeys) || !isObject$4(sortKeys))
    return collection;
  let cmp2 = compare$2;
  const collationSpec = options.collation;
  if (isObject$4(collationSpec) && isString$1(collationSpec.locale)) {
    cmp2 = collationComparator(collationSpec);
  }
  return collection.transform((coll) => {
    const modifiers = Object.keys(sortKeys);
    for (const key of modifiers.reverse()) {
      const groups = groupBy(coll, (obj) => resolve(obj, key), options.hashFunction);
      const sortedKeys = Array.from(groups.keys()).sort(cmp2);
      if (sortKeys[key] === -1)
        sortedKeys.reverse();
      coll = [];
      sortedKeys.reduce((acc, key2) => into(acc, groups.get(key2)), coll);
    }
    return coll;
  });
};
const COLLATION_STRENGTH = {
  // Only strings that differ in base letters compare as unequal. Examples: a ≠ b, a = á, a = A.
  1: "base",
  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.
  // Examples: a ≠ b, a ≠ á, a = A.
  2: "accent",
  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.
  // Other differences may also be taken into consideration. Examples: a ≠ b, a ≠ á, a ≠ A
  3: "variant"
  // case - Only strings that differ in base letters or case compare as unequal. Examples: a ≠ b, a = á, a ≠ A.
};
function collationComparator(spec) {
  const localeOpt = {
    sensitivity: COLLATION_STRENGTH[spec.strength || 3],
    caseFirst: spec.caseFirst === "off" ? "false" : spec.caseFirst || "false",
    numeric: spec.numericOrdering || false,
    ignorePunctuation: spec.alternate === "shifted"
  };
  if ((spec.caseLevel || false) === true) {
    if (localeOpt.sensitivity === "base")
      localeOpt.sensitivity = "case";
    if (localeOpt.sensitivity === "accent")
      localeOpt.sensitivity = "variant";
  }
  const collator2 = new Intl.Collator(spec.locale, localeOpt);
  return (a2, b2) => {
    if (!isString$1(a2) || !isString$1(b2))
      return compare$2(a2, b2);
    const i2 = collator2.compare(a2, b2);
    if (i2 < 0)
      return -1;
    if (i2 > 0)
      return 1;
    return 0;
  };
}
const $project = (collection, expr, options) => {
  if (isEmpty(expr))
    return collection;
  let expressionKeys = Object.keys(expr);
  let idOnlyExcluded = false;
  validateExpression(expr, options);
  const ID_KEY = options.idKey;
  if (inArray(expressionKeys, ID_KEY)) {
    const id2 = expr[ID_KEY];
    if (id2 === 0 || id2 === false) {
      expressionKeys = expressionKeys.filter(notInArray.bind(null, [ID_KEY]));
      idOnlyExcluded = expressionKeys.length == 0;
    }
  } else {
    expressionKeys.push(ID_KEY);
  }
  const copts = ComputeOptions.init(options);
  return collection.map((obj) => processObject(obj, expr, copts.update(obj), expressionKeys, idOnlyExcluded));
};
function processObject(obj, expr, options, expressionKeys, idOnlyExcluded) {
  let newObj = {};
  let foundSlice = false;
  let foundExclusion = false;
  const dropKeys = [];
  if (idOnlyExcluded) {
    dropKeys.push(options.idKey);
  }
  for (const key of expressionKeys) {
    let value = void 0;
    const subExpr = expr[key];
    if (key !== options.idKey && inArray([0, false], subExpr)) {
      foundExclusion = true;
    }
    if (key === options.idKey && isEmpty(subExpr)) {
      value = obj[key];
    } else if (isString$1(subExpr)) {
      value = computeValue(obj, subExpr, key, options);
    } else if (inArray([1, true], subExpr))
      ;
    else if (subExpr instanceof Array) {
      value = subExpr.map((v2) => {
        const r2 = computeValue(obj, v2, null, options);
        if (isNil(r2))
          return null;
        return r2;
      });
    } else if (isObject$4(subExpr)) {
      const subExprObj = subExpr;
      const subExprKeys = Object.keys(subExpr);
      const operator = subExprKeys.length == 1 ? subExprKeys[0] : "";
      const call = getOperator(OperatorType.PROJECTION, operator, options);
      if (call) {
        if (operator === "$slice") {
          if (ensureArray(subExprObj[operator]).every(isNumber$2)) {
            value = call(obj, subExprObj[operator], key, options);
            foundSlice = true;
          } else {
            value = computeValue(obj, subExprObj, key, options);
          }
        } else {
          value = call(obj, subExprObj[operator], key, options);
        }
      } else if (isOperator(operator)) {
        value = computeValue(obj, subExprObj[operator], operator, options);
      } else if (has$2(obj, key)) {
        validateExpression(subExprObj, options);
        let target = obj[key];
        if (target instanceof Array) {
          value = target.map((o2) => processObject(o2, subExprObj, options, subExprKeys, false));
        } else {
          target = isObject$4(target) ? target : obj;
          value = processObject(target, subExprObj, options, subExprKeys, false);
        }
      } else {
        value = computeValue(obj, subExpr, null, options);
      }
    } else {
      dropKeys.push(key);
      continue;
    }
    const objPathGraph = resolveGraph(obj, key, {
      preserveMissing: true
    });
    if (objPathGraph !== void 0) {
      merge$2(newObj, objPathGraph, {
        flatten: true
      });
    }
    if (notInArray([0, 1, false, true], subExpr)) {
      if (value === void 0) {
        removeValue(newObj, key, { descendArray: true });
      } else {
        setValue(newObj, key, value);
      }
    }
  }
  filterMissing(newObj);
  if (foundSlice || foundExclusion || idOnlyExcluded) {
    newObj = into({}, obj, newObj);
    if (dropKeys.length > 0) {
      for (const k2 of dropKeys) {
        removeValue(newObj, k2, { descendArray: true });
      }
    }
  }
  return newObj;
}
function validateExpression(expr, options) {
  const check = [false, false];
  for (const [k2, v2] of Object.entries(expr)) {
    if (k2 === (options === null || options === void 0 ? void 0 : options.idKey))
      return;
    if (v2 === 0 || v2 === false) {
      check[0] = true;
    } else if (v2 === 1 || v2 === true) {
      check[1] = true;
    }
    assert(!(check[0] && check[1]), "Projection cannot have a mix of inclusion and exclusion.");
  }
}
const $and = (_2, rhs, options) => {
  assert(isArray$2(rhs), "Invalid expression: $and expects value to be an Array.");
  const queries = rhs.map((expr) => new Query(expr, options));
  return (obj) => queries.every((q2) => q2.test(obj));
};
const $or = (_2, rhs, options) => {
  assert(isArray$2(rhs), "Invalid expression. $or expects value to be an Array");
  const queries = rhs.map((expr) => new Query(expr, options));
  return (obj) => queries.some((q2) => q2.test(obj));
};
const $nor = (_2, rhs, options) => {
  assert(isArray$2(rhs), "Invalid expression. $nor expects value to be an array.");
  const f2 = $or("$or", rhs, options);
  return (obj) => !f2(obj);
};
const $not = (selector, rhs, options) => {
  const criteria = {};
  criteria[selector] = normalize$1(rhs);
  const query = new Query(criteria, options);
  return (obj) => !query.test(obj);
};
const $eq = createQueryOperator($eq$1);
const $gt = createQueryOperator($gt$1);
const $gte = createQueryOperator($gte$1);
const $in = createQueryOperator($in$1);
const $lt = createQueryOperator($lt$1);
const $lte = createQueryOperator($lte$1);
const $ne = createQueryOperator($ne$1);
const $nin = createQueryOperator($nin$1);
const $mod = createQueryOperator($mod$1);
const $regex = createQueryOperator($regex$1);
createQueryOperator($all);
const $elemMatch = createQueryOperator($elemMatch$1);
const $size = createQueryOperator($size$1);
const $exists = createQueryOperator($exists$1);
const $type = createQueryOperator($type$1);
var mingoInitDone = false;
function getMingoQuery(selector) {
  if (!mingoInitDone) {
    useOperators(OperatorType.PIPELINE, {
      $sort,
      $project
    });
    useOperators(OperatorType.QUERY, {
      $and,
      $eq,
      $elemMatch,
      $exists,
      $gt,
      $gte,
      $in,
      $lt,
      $lte,
      $ne,
      $nin,
      $mod,
      $nor,
      $not,
      $or,
      $regex,
      $size,
      $type
    });
    mingoInitDone = true;
  }
  return new Query(selector);
}
function normalizeMangoQuery(schema, mangoQuery) {
  var primaryKey = getPrimaryFieldOfPrimaryKey(schema.primaryKey);
  mangoQuery = flatClone(mangoQuery);
  if (mangoQuery.selector) {
    mangoQuery.selector = normalizeQueryRegex(mangoQuery.selector);
  }
  var normalizedMangoQuery = clone$2(mangoQuery);
  if (typeof normalizedMangoQuery.skip !== "number") {
    normalizedMangoQuery.skip = 0;
  }
  if (!normalizedMangoQuery.selector) {
    normalizedMangoQuery.selector = {};
  } else {
    normalizedMangoQuery.selector = normalizedMangoQuery.selector;
    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
      if (typeof matcher !== "object" || matcher === null) {
        normalizedMangoQuery.selector[field] = {
          $eq: matcher
        };
      }
    });
  }
  if (normalizedMangoQuery.index) {
    var indexAr = toArray$1(normalizedMangoQuery.index);
    if (!indexAr.includes(primaryKey)) {
      indexAr.push(primaryKey);
    }
    normalizedMangoQuery.index = indexAr;
  }
  if (!normalizedMangoQuery.sort) {
    if (normalizedMangoQuery.index) {
      normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field) => {
        return {
          [field]: "asc"
        };
      });
    } else {
      if (schema.indexes) {
        var fieldsWithLogicalOperator = /* @__PURE__ */ new Set();
        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
          var hasLogical = false;
          if (typeof matcher === "object" && matcher !== null) {
            hasLogical = !!Object.keys(matcher).find((operator) => LOGICAL_OPERATORS.has(operator));
          } else {
            hasLogical = true;
          }
          if (hasLogical) {
            fieldsWithLogicalOperator.add(field);
          }
        });
        var currentFieldsAmount = -1;
        var currentBestIndexForSort;
        schema.indexes.forEach((index2) => {
          var useIndex = isMaybeReadonlyArray(index2) ? index2 : [index2];
          var firstWrongIndex = useIndex.findIndex((indexField) => !fieldsWithLogicalOperator.has(indexField));
          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {
            currentFieldsAmount = firstWrongIndex;
            currentBestIndexForSort = useIndex;
          }
        });
        if (currentBestIndexForSort) {
          normalizedMangoQuery.sort = currentBestIndexForSort.map((field) => {
            return {
              [field]: "asc"
            };
          });
        }
      }
      if (!normalizedMangoQuery.sort) {
        normalizedMangoQuery.sort = [{
          [primaryKey]: "asc"
        }];
      }
    }
  } else {
    var isPrimaryInSort = normalizedMangoQuery.sort.find((p2) => firstPropertyNameOfObject(p2) === primaryKey);
    if (!isPrimaryInSort) {
      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);
      normalizedMangoQuery.sort.push({
        [primaryKey]: "asc"
      });
    }
  }
  return normalizedMangoQuery;
}
function normalizeQueryRegex(selector) {
  if (typeof selector !== "object" || selector === null) {
    return selector;
  }
  var keys3 = Object.keys(selector);
  var ret = {};
  keys3.forEach((key) => {
    var value = selector[key];
    if (key === "$regex" && value instanceof RegExp) {
      var parsed = parseRegex(value);
      ret.$regex = parsed.pattern;
      ret.$options = parsed.flags;
    } else if (Array.isArray(value)) {
      ret[key] = value.map((item) => normalizeQueryRegex(item));
    } else {
      ret[key] = normalizeQueryRegex(value);
    }
  });
  return ret;
}
function getSortComparator(schema, query) {
  if (!query.sort) {
    throw newRxError("SNH", {
      query
    });
  }
  var sortParts = [];
  query.sort.forEach((sortBlock) => {
    var key = Object.keys(sortBlock)[0];
    var direction2 = Object.values(sortBlock)[0];
    sortParts.push({
      key,
      direction: direction2,
      getValueFn: objectPathMonad(key)
    });
  });
  var fun = (a2, b2) => {
    for (var i2 = 0; i2 < sortParts.length; ++i2) {
      var sortPart = sortParts[i2];
      var valueA = sortPart.getValueFn(a2);
      var valueB = sortPart.getValueFn(b2);
      if (valueA !== valueB) {
        var ret = sortPart.direction === "asc" ? compare$2(valueA, valueB) : compare$2(valueB, valueA);
        return ret;
      }
    }
  };
  return fun;
}
function getQueryMatcher(_schema, query) {
  if (!query.sort) {
    throw newRxError("SNH", {
      query
    });
  }
  var mingoQuery = getMingoQuery(query.selector);
  var fun = (doc) => {
    if (doc._deleted) {
      return false;
    }
    var cursor2 = mingoQuery.find([doc]);
    var next2 = cursor2.next();
    if (next2) {
      return true;
    } else {
      return false;
    }
  };
  return fun;
}
function getSortFieldsOfQuery(primaryKey, query) {
  if (!query.sort || query.sort.length === 0) {
    return [primaryKey];
  } else {
    return query.sort.map((part) => Object.keys(part)[0]);
  }
}
var RXQUERY_QUERY_PARAMS_CACHE = /* @__PURE__ */ new WeakMap();
function getQueryParams(rxQuery) {
  return getFromMapOrCreate(RXQUERY_QUERY_PARAMS_CACHE, rxQuery, () => {
    var collection = rxQuery.collection;
    var normalizedMangoQuery = normalizeMangoQuery(collection.storageInstance.schema, clone$2(rxQuery.mangoQuery));
    var primaryKey = collection.schema.primaryPath;
    var sortComparator = getSortComparator(collection.schema.jsonSchema, normalizedMangoQuery);
    var useSortComparator = (docA, docB) => {
      var sortComparatorData = {
        docA,
        docB,
        rxQuery
      };
      return sortComparator(sortComparatorData.docA, sortComparatorData.docB);
    };
    var queryMatcher = getQueryMatcher(collection.schema.jsonSchema, normalizedMangoQuery);
    var useQueryMatcher = (doc) => {
      var queryMatcherData = {
        doc,
        rxQuery
      };
      return queryMatcher(queryMatcherData.doc);
    };
    var ret = {
      primaryKey: rxQuery.collection.schema.primaryPath,
      skip: normalizedMangoQuery.skip,
      limit: normalizedMangoQuery.limit,
      sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),
      sortComparator: useSortComparator,
      queryMatcher: useQueryMatcher
    };
    return ret;
  });
}
function calculateNewResults(rxQuery, rxChangeEvents) {
  if (!rxQuery.collection.database.eventReduce) {
    return {
      runFullQueryAgain: true
    };
  }
  var queryParams = getQueryParams(rxQuery);
  var previousResults = ensureNotFalsy(rxQuery._result).docsData.slice(0);
  var previousResultsMap = ensureNotFalsy(rxQuery._result).docsDataMap;
  var changed = false;
  var eventReduceEvents = rxChangeEvents.map((cE) => rxChangeEventToEventReduceChangeEvent(cE)).filter(arrayFilterNotEmpty);
  var foundNonOptimizeable = eventReduceEvents.find((eventReduceEvent) => {
    var stateResolveFunctionInput = {
      queryParams,
      changeEvent: eventReduceEvent,
      previousResults,
      keyDocumentMap: previousResultsMap
    };
    var actionName = calculateActionName(stateResolveFunctionInput);
    if (actionName === "runFullQueryAgain") {
      return true;
    } else if (actionName !== "doNothing") {
      changed = true;
      runAction(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);
      return false;
    }
  });
  if (foundNonOptimizeable) {
    return {
      runFullQueryAgain: true
    };
  } else {
    return {
      runFullQueryAgain: false,
      changed,
      newResults: previousResults
    };
  }
}
var QueryCache = /* @__PURE__ */ function() {
  function QueryCache2() {
    this._map = /* @__PURE__ */ new Map();
  }
  var _proto = QueryCache2.prototype;
  _proto.getByQuery = function getByQuery(rxQuery) {
    var stringRep = rxQuery.toString();
    return getFromMapOrCreate(this._map, stringRep, () => rxQuery);
  };
  return QueryCache2;
}();
function createQueryCache() {
  return new QueryCache();
}
function uncacheRxQuery(queryCache, rxQuery) {
  rxQuery.uncached = true;
  var stringRep = rxQuery.toString();
  queryCache._map.delete(stringRep);
}
function countRxQuerySubscribers(rxQuery) {
  return rxQuery.refCount$.observers.length;
}
var DEFAULT_TRY_TO_KEEP_MAX = 100;
var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1e3;
var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {
  if (queryCache._map.size < tryToKeepMax) {
    return;
  }
  var minUnExecutedLifetime = now$1() - unExecutedLifetime;
  var maybeUncache = [];
  var queriesInCache = Array.from(queryCache._map.values());
  for (var rxQuery of queriesInCache) {
    if (countRxQuerySubscribers(rxQuery) > 0) {
      continue;
    }
    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {
      uncacheRxQuery(queryCache, rxQuery);
      continue;
    }
    maybeUncache.push(rxQuery);
  }
  var mustUncache = maybeUncache.length - tryToKeepMax;
  if (mustUncache <= 0) {
    return;
  }
  var sortedByLastUsage = maybeUncache.sort((a2, b2) => a2._lastEnsureEqual - b2._lastEnsureEqual);
  var toRemove = sortedByLastUsage.slice(0, mustUncache);
  toRemove.forEach((rxQuery2) => uncacheRxQuery(queryCache, rxQuery2));
};
var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);
var COLLECTIONS_WITH_RUNNING_CLEANUP = /* @__PURE__ */ new WeakSet();
function triggerCacheReplacement(rxCollection) {
  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {
    return;
  }
  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);
  nextTick().then(() => requestIdlePromise(200)).then(() => {
    if (!rxCollection.destroyed) {
      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);
    }
    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);
  });
}
var _queryCount = 0;
var newQueryID = function() {
  return ++_queryCount;
};
var RxQueryBase = /* @__PURE__ */ function() {
  function RxQueryBase2(op, mangoQuery, collection, other = {}) {
    this.id = newQueryID();
    this._execOverDatabaseCount = 0;
    this._creationTime = now$1();
    this._lastEnsureEqual = 0;
    this.uncached = false;
    this.refCount$ = new BehaviorSubject(null);
    this._result = null;
    this._latestChangeEvent = -1;
    this._lastExecStart = 0;
    this._lastExecEnd = 0;
    this._ensureEqualQueue = PROMISE_RESOLVE_FALSE;
    this.op = op;
    this.mangoQuery = mangoQuery;
    this.collection = collection;
    this.other = other;
    if (!mangoQuery) {
      this.mangoQuery = _getDefaultQuery();
    }
    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);
  }
  var _proto = RxQueryBase2.prototype;
  _proto._setResultData = function _setResultData(newResultData) {
    if (typeof newResultData === "number") {
      this._result = {
        docsData: [],
        docsMap: /* @__PURE__ */ new Map(),
        docsDataMap: /* @__PURE__ */ new Map(),
        count: newResultData,
        docs: [],
        time: now$1()
      };
      return;
    } else if (newResultData instanceof Map) {
      newResultData = Array.from(newResultData.values());
    }
    var docsDataMap = /* @__PURE__ */ new Map();
    var docsMap = /* @__PURE__ */ new Map();
    var docs = newResultData.map((docData) => this.collection._docCache.getCachedRxDocument(docData));
    var docsData = docs.map((doc) => {
      docsDataMap.set(doc.primary, doc._data);
      docsMap.set(doc.primary, doc);
      return doc._data;
    });
    this._result = {
      docsData,
      docsMap,
      docsDataMap,
      count: docsData.length,
      docs,
      time: now$1()
    };
  };
  _proto._execOverDatabase = async function _execOverDatabase() {
    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;
    this._lastExecStart = now$1();
    if (this.op === "count") {
      var preparedQuery = this.getPreparedQuery();
      var result = await this.collection.storageInstance.count(preparedQuery);
      if (result.mode === "slow" && !this.collection.database.allowSlowCount) {
        throw newRxError("QU14", {
          collection: this.collection,
          queryObj: this.mangoQuery
        });
      } else {
        return result.count;
      }
    }
    if (this.op === "findByIds") {
      var ids = ensureNotFalsy(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;
      var ret = /* @__PURE__ */ new Map();
      var mustBeQueried = [];
      ids.forEach((id2) => {
        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id2);
        if (docData) {
          if (!docData._deleted) {
            var doc = this.collection._docCache.getCachedRxDocument(docData);
            ret.set(id2, doc);
          }
        } else {
          mustBeQueried.push(id2);
        }
      });
      if (mustBeQueried.length > 0) {
        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);
        Object.values(docs).forEach((docData) => {
          var doc = this.collection._docCache.getCachedRxDocument(docData);
          ret.set(doc.primary, doc);
        });
      }
      return ret;
    }
    var docsPromise = queryCollection(this);
    return docsPromise.then((docs2) => {
      this._lastExecEnd = now$1();
      return docs2;
    });
  };
  _proto.exec = function exec(throwIfMissing) {
    if (throwIfMissing && this.op !== "findOne") {
      throw newRxError("QU9", {
        collection: this.collection.name,
        query: this.mangoQuery,
        op: this.op
      });
    }
    return _ensureEqual(this).then(() => firstValueFrom(this.$)).then((result) => {
      if (!result && throwIfMissing) {
        throw newRxError("QU10", {
          collection: this.collection.name,
          query: this.mangoQuery,
          op: this.op
        });
      } else {
        return result;
      }
    });
  };
  _proto.toString = function toString3() {
    var stringObj = sortObject({
      op: this.op,
      query: this.mangoQuery,
      other: this.other
    }, true);
    var value = JSON.stringify(stringObj, stringifyFilter);
    this.toString = () => value;
    return value;
  };
  _proto.getPreparedQuery = function getPreparedQuery() {
    var hookInput = {
      rxQuery: this,
      // can be mutated by the hooks so we have to deep clone first.
      mangoQuery: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery)
    };
    runPluginHooks("prePrepareQuery", hookInput);
    var value = this.collection.database.storage.statics.prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);
    this.getPreparedQuery = () => value;
    return value;
  };
  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {
    if (docData._deleted) {
      return false;
    }
    return this.queryMatcher(docData);
  };
  _proto.remove = function remove() {
    return this.exec().then((docs) => {
      if (Array.isArray(docs)) {
        return Promise.all(docs.map((doc) => doc.remove()));
      } else {
        return docs.remove();
      }
    });
  };
  _proto.update = function update2(_updateObj) {
    throw pluginMissing("update");
  };
  _proto.where = function where(_queryObj) {
    throw pluginMissing("query-builder");
  };
  _proto.sort = function sort(_params) {
    throw pluginMissing("query-builder");
  };
  _proto.skip = function skip(_amount) {
    throw pluginMissing("query-builder");
  };
  _proto.limit = function limit(_amount) {
    throw pluginMissing("query-builder");
  };
  _createClass(RxQueryBase2, [{
    key: "$",
    get: function() {
      if (!this._$) {
        var results$ = this.collection.$.pipe(
          /**
           * Performance shortcut.
           * Changes to local documents are not relevant for the query.
           */
          filter$1((changeEvent) => !changeEvent.isLocal),
          /**
           * Start once to ensure the querying also starts
           * when there where no changes.
           */
          startWith(null),
          // ensure query results are up to date.
          mergeMap(() => _ensureEqual(this)),
          // use the current result set, written by _ensureEqual().
          map(() => this._result),
          // do not run stuff above for each new subscriber, only once.
          shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),
          // do not proceed if result set has not changed.
          distinctUntilChanged((prev2, curr) => {
            if (prev2 && prev2.time === ensureNotFalsy(curr).time) {
              return true;
            } else {
              return false;
            }
          }),
          filter$1((result) => !!result),
          /**
           * Map the result set to a single RxDocument or an array,
           * depending on query type
           */
          map((result) => {
            var useResult = ensureNotFalsy(result);
            if (this.op === "count") {
              return useResult.count;
            } else if (this.op === "findOne") {
              return useResult.docs.length === 0 ? null : useResult.docs[0];
            } else if (this.op === "findByIds") {
              return useResult.docsMap;
            } else {
              return useResult.docs.slice(0);
            }
          })
        );
        this._$ = merge$3(
          results$,
          /**
           * Also add the refCount$ to the query observable
           * to allow us to count the amount of subscribers.
           */
          this.refCount$.pipe(filter$1(() => false))
        );
      }
      return this._$;
    }
    // stores the changeEvent-number of the last handled change-event
    // time stamps on when the last full exec over the database has run
    // used to properly handle events that happen while the find-query is running
    /**
     * ensures that the exec-runs
     * are not run in parallel
     */
  }, {
    key: "queryMatcher",
    get: function() {
      var schema = this.collection.schema.jsonSchema;
      var normalizedQuery = normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery);
      return overwriteGetterForCaching(this, "queryMatcher", getQueryMatcher(schema, normalizedQuery));
    }
  }, {
    key: "asRxQuery",
    get: function() {
      return this;
    }
  }]);
  return RxQueryBase2;
}();
function _getDefaultQuery() {
  return {
    selector: {}
  };
}
function tunnelQueryCache(rxQuery) {
  return rxQuery.collection._queryCache.getByQuery(rxQuery);
}
function createRxQuery(op, queryObj, collection, other) {
  runPluginHooks("preCreateRxQuery", {
    op,
    queryObj,
    collection,
    other
  });
  var ret = new RxQueryBase(op, queryObj, collection, other);
  ret = tunnelQueryCache(ret);
  triggerCacheReplacement(collection);
  return ret;
}
function _isResultsInSync(rxQuery) {
  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.counter;
  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {
    return true;
  } else {
    return false;
  }
}
function _ensureEqual(rxQuery) {
  if (rxQuery.collection.database.destroyed || _isResultsInSync(rxQuery)) {
    return PROMISE_RESOLVE_FALSE;
  }
  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));
  return rxQuery._ensureEqualQueue;
}
function __ensureEqual(rxQuery) {
  rxQuery._lastEnsureEqual = now$1();
  if (
    // db is closed
    rxQuery.collection.database.destroyed || // nothing happened since last run
    _isResultsInSync(rxQuery)
  ) {
    return PROMISE_RESOLVE_FALSE;
  }
  var ret = false;
  var mustReExec = false;
  if (rxQuery._latestChangeEvent === -1) {
    mustReExec = true;
  }
  if (!mustReExec) {
    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);
    if (missedChangeEvents === null) {
      mustReExec = true;
    } else {
      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.counter;
      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);
      if (rxQuery.op === "count") {
        var previousCount = ensureNotFalsy(rxQuery._result).count;
        var newCount = previousCount;
        runChangeEvents.forEach((cE) => {
          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);
          var doesMatchNow2 = rxQuery.doesDocumentDataMatch(cE.documentData);
          if (!didMatchBefore && doesMatchNow2) {
            newCount++;
          }
          if (didMatchBefore && !doesMatchNow2) {
            newCount--;
          }
        });
        if (newCount !== previousCount) {
          ret = true;
          rxQuery._setResultData(newCount);
        }
      } else {
        var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);
        if (eventReduceResult.runFullQueryAgain) {
          mustReExec = true;
        } else if (eventReduceResult.changed) {
          ret = true;
          rxQuery._setResultData(eventReduceResult.newResults);
        }
      }
    }
  }
  if (mustReExec) {
    var latestAfter = rxQuery.collection._changeEventBuffer.counter;
    return rxQuery._execOverDatabase().then((newResultData) => {
      rxQuery._latestChangeEvent = latestAfter;
      if (typeof newResultData === "number") {
        if (!rxQuery._result || newResultData !== rxQuery._result.count) {
          ret = true;
          rxQuery._setResultData(newResultData);
        }
        return ret;
      }
      if (!rxQuery._result || !areRxDocumentArraysEqual(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {
        ret = true;
        rxQuery._setResultData(newResultData);
      }
      return ret;
    });
  }
  return Promise.resolve(ret);
}
async function queryCollection(rxQuery) {
  var docs = [];
  var collection = rxQuery.collection;
  if (rxQuery.isFindOneByIdQuery) {
    if (Array.isArray(rxQuery.isFindOneByIdQuery)) {
      var docIds = rxQuery.isFindOneByIdQuery;
      docIds = docIds.filter((docId2) => {
        var docData2 = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId2);
        if (docData2) {
          if (!docData2._deleted) {
            docs.push(docData2);
          }
          return false;
        } else {
          return true;
        }
      });
      if (docIds.length > 0) {
        var docsMap = await collection.storageInstance.findDocumentsById(docIds, false);
        Object.values(docsMap).forEach((docData2) => {
          docs.push(docData2);
        });
      }
    } else {
      var docId = rxQuery.isFindOneByIdQuery;
      var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);
      if (!docData) {
        var _docsMap = await collection.storageInstance.findDocumentsById([docId], false);
        if (_docsMap.hasOwnProperty(docId)) {
          docData = _docsMap[docId];
        }
      }
      if (docData && !docData._deleted) {
        docs.push(docData);
      }
    }
  } else {
    var preparedQuery = rxQuery.getPreparedQuery();
    var queryResult = await collection.storageInstance.query(preparedQuery);
    docs = queryResult.documents;
  }
  return docs;
}
function isFindOneByIdQuery(primaryPath, query) {
  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {
    var value = query.selector[primaryPath];
    if (typeof value === "string") {
      return value;
    } else if (Object.keys(value).length === 1 && typeof value.$eq === "string") {
      return value.$eq;
    }
    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) && // must only contain strings
    !value.$eq.find((r2) => typeof r2 !== "string")) {
      return value.$eq;
    }
  }
  return false;
}
var INTERNAL_CONTEXT_COLLECTION = "collection";
var INTERNAL_CONTEXT_STORAGE_TOKEN = "storage-token";
var INTERNAL_STORE_SCHEMA_TITLE = "RxInternalDocument";
var INTERNAL_STORE_SCHEMA = fillWithDefaultSettings({
  version: 0,
  title: INTERNAL_STORE_SCHEMA_TITLE,
  primaryKey: {
    key: "id",
    fields: ["context", "key"],
    separator: "|"
  },
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 200
    },
    key: {
      type: "string"
    },
    context: {
      type: "string",
      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, "OTHER"]
    },
    data: {
      type: "object",
      additionalProperties: true
    }
  },
  indexes: [],
  required: ["key", "context", "data"],
  additionalProperties: false,
  /**
   * If the sharding plugin is used,
   * it must not shard on the internal RxStorageInstance
   * because that one anyway has only a small amount of documents
   * and also its creation is in the hot path of the initial page load,
   * so we should spend less time creating multiple RxStorageInstances.
   */
  sharding: {
    shards: 1,
    mode: "collection"
  }
});
function getPrimaryKeyOfInternalDocument(key, context) {
  return getComposedPrimaryKeyOfDocumentData(INTERNAL_STORE_SCHEMA, {
    key,
    context
  });
}
async function getAllCollectionDocuments(storageStatics, storageInstance) {
  var getAllQueryPrepared = storageStatics.prepareQuery(storageInstance.schema, {
    selector: {
      context: INTERNAL_CONTEXT_COLLECTION
    },
    sort: [{
      id: "asc"
    }],
    skip: 0
  });
  var queryResult = await storageInstance.query(getAllQueryPrepared);
  var allDocs = queryResult.documents;
  return allDocs;
}
var STORAGE_TOKEN_DOCUMENT_KEY = "storageToken";
var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);
async function ensureStorageTokenDocumentExists(rxDatabase) {
  var storageToken = randomCouchString(10);
  var passwordHash = rxDatabase.password ? rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : void 0;
  var docData = {
    id: STORAGE_TOKEN_DOCUMENT_ID,
    context: INTERNAL_CONTEXT_STORAGE_TOKEN,
    key: STORAGE_TOKEN_DOCUMENT_KEY,
    data: {
      token: storageToken,
      /**
       * We add the instance token here
       * to be able to detect if a given RxDatabase instance
       * is the first instance that was ever created
       * or if databases have existed earlier on that storage
       * with the same database name.
       */
      instanceToken: rxDatabase.token,
      passwordHash
    },
    _deleted: false,
    _meta: getDefaultRxDocumentMeta(),
    _rev: getDefaultRevision(),
    _attachments: {}
  };
  var writeResult = await rxDatabase.internalStore.bulkWrite([{
    document: docData
  }], "internal-add-storage-token");
  if (writeResult.success[STORAGE_TOKEN_DOCUMENT_ID]) {
    return writeResult.success[STORAGE_TOKEN_DOCUMENT_ID];
  }
  var error = ensureNotFalsy(writeResult.error[STORAGE_TOKEN_DOCUMENT_ID]);
  if (error.isError && error.status === 409) {
    var conflictError = error;
    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {
      throw newRxError("DB1", {
        passwordHash,
        existingPasswordHash: conflictError.documentInDb.data.passwordHash
      });
    }
    var storageTokenDocInDb = conflictError.documentInDb;
    return ensureNotFalsy(storageTokenDocInDb);
  }
  throw error;
}
function _collectionNamePrimary(name, schema) {
  return name + "-" + schema.version;
}
function fillObjectDataBeforeInsert(schema, data) {
  data = flatClone(data);
  data = fillObjectWithDefaults(schema, data);
  data = fillPrimaryKey(schema.primaryPath, schema.jsonSchema, data);
  data._meta = getDefaultRxDocumentMeta();
  if (!data.hasOwnProperty("_deleted")) {
    data._deleted = false;
  }
  if (!data.hasOwnProperty("_attachments")) {
    data._attachments = {};
  }
  if (!data.hasOwnProperty("_rev")) {
    data._rev = getDefaultRevision();
  }
  return data;
}
async function createRxCollectionStorageInstance(rxDatabase, storageInstanceCreationParams) {
  storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;
  var storageInstance = await rxDatabase.storage.createStorageInstance(storageInstanceCreationParams);
  return storageInstance;
}
async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, hashFunction) {
  var allCollectionMetaDocs = await getAllCollectionDocuments(storage.statics, databaseInternalStorage);
  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter((metaDoc) => metaDoc.data.name === collectionName);
  var removeStorages = [];
  relevantCollectionMetaDocs.forEach((metaDoc) => {
    removeStorages.push({
      collectionName: metaDoc.data.name,
      schema: metaDoc.data.schema,
      isCollection: true
    });
    metaDoc.data.connectedStorages.forEach((row) => removeStorages.push({
      collectionName: row.collectionName,
      isCollection: false,
      schema: row.schema
    }));
  });
  var alreadyAdded = /* @__PURE__ */ new Set();
  removeStorages = removeStorages.filter((row) => {
    var key = row.collectionName + "||" + row.schema.version;
    if (alreadyAdded.has(key)) {
      return false;
    } else {
      alreadyAdded.add(key);
      return true;
    }
  });
  await Promise.all(removeStorages.map(async (row) => {
    var storageInstance = await storage.createStorageInstance({
      collectionName: row.collectionName,
      databaseInstanceToken,
      databaseName,
      multiInstance: false,
      options: {},
      schema: row.schema,
      devMode: overwritable.isDevMode()
    });
    await storageInstance.remove();
    if (row.isCollection) {
      await runAsyncPluginHooks("postRemoveRxCollection", {
        storage,
        databaseName,
        collectionName
      });
    }
  }));
  if (hashFunction) {
    var writeRows = relevantCollectionMetaDocs.map((doc) => {
      var writeDoc = flatCloneDocWithMeta(doc);
      writeDoc._deleted = true;
      writeDoc._meta.lwt = now$1();
      writeDoc._rev = createRevision(databaseInstanceToken, doc);
      return {
        previous: doc,
        document: writeDoc
      };
    });
    await databaseInternalStorage.bulkWrite(writeRows, "rx-database-remove-collection-all");
  }
}
var DocumentCache = /* @__PURE__ */ function() {
  function DocumentCache2(primaryPath, changes$, documentCreator) {
    this.cacheItemByDocId = /* @__PURE__ */ new Map();
    this.registry = typeof FinalizationRegistry === "function" ? new FinalizationRegistry((docMeta) => {
      var docId = docMeta.docId;
      var cacheItem = this.cacheItemByDocId.get(docId);
      if (cacheItem) {
        cacheItem.documentByRevisionHeight.delete(docMeta.revisionHeight);
        if (cacheItem.documentByRevisionHeight.size === 0) {
          this.cacheItemByDocId.delete(docId);
        }
      }
    }) : void 0;
    this.primaryPath = primaryPath;
    this.changes$ = changes$;
    this.documentCreator = documentCreator;
    changes$.subscribe((changeEvent) => {
      var docId = changeEvent.documentId;
      var cacheItem = this.cacheItemByDocId.get(docId);
      if (cacheItem) {
        var documentData = getDocumentDataOfRxChangeEvent(changeEvent);
        cacheItem.latestDoc = documentData;
      }
    });
  }
  var _proto = DocumentCache2.prototype;
  _proto.getCachedRxDocument = function getCachedRxDocument(docData) {
    var docId = docData[this.primaryPath];
    var revisionHeight = getHeightOfRevision(docData._rev);
    var cacheItem = getFromMapOrCreate(this.cacheItemByDocId, docId, () => getNewCacheItem(docData));
    var cachedRxDocumentWeakRef = cacheItem.documentByRevisionHeight.get(revisionHeight);
    var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : void 0;
    if (!cachedRxDocument) {
      docData = overwritable.deepFreezeWhenDevMode(docData);
      cachedRxDocument = this.documentCreator(docData);
      cacheItem.documentByRevisionHeight.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));
      if (this.registry) {
        this.registry.register(cachedRxDocument, {
          docId,
          revisionHeight
        });
      }
    }
    return cachedRxDocument;
  };
  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {
    var cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);
    return cacheItem.latestDoc;
  };
  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {
    var cacheItem = this.cacheItemByDocId.get(docId);
    if (cacheItem) {
      return cacheItem.latestDoc;
    }
  };
  return DocumentCache2;
}();
function getNewCacheItem(docData) {
  return {
    documentByRevisionHeight: /* @__PURE__ */ new Map(),
    latestDoc: docData
  };
}
var HAS_WEAK_REF = typeof WeakRef === "function";
function createWeakRefWithFallback(obj) {
  if (HAS_WEAK_REF) {
    return new WeakRef(obj);
  } else {
    return {
      deref() {
        return obj;
      }
    };
  }
}
var ChangeEventBuffer = /* @__PURE__ */ function() {
  function ChangeEventBuffer2(collection) {
    this.subs = [];
    this.limit = 100;
    this.counter = 0;
    this.eventCounterMap = /* @__PURE__ */ new WeakMap();
    this.buffer = [];
    this.collection = collection;
    this.subs.push(this.collection.$.pipe(filter$1((cE) => !cE.isLocal)).subscribe((cE) => this._handleChangeEvent(cE)));
  }
  var _proto = ChangeEventBuffer2.prototype;
  _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {
    this.counter++;
    this.buffer.push(changeEvent);
    this.eventCounterMap.set(changeEvent, this.counter);
    while (this.buffer.length > this.limit) {
      this.buffer.shift();
    }
  };
  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {
    var oldestEvent = this.buffer[0];
    var oldestCounter = this.eventCounterMap.get(oldestEvent);
    if (pointer < oldestCounter)
      return null;
    var rest = pointer - oldestCounter;
    return rest;
  };
  _proto.getFrom = function getFrom(pointer) {
    var ret = [];
    var currentIndex = this.getArrayIndexByPointer(pointer);
    if (currentIndex === null)
      return null;
    while (true) {
      var nextEvent = this.buffer[currentIndex];
      currentIndex++;
      if (!nextEvent) {
        return ret;
      } else {
        ret.push(nextEvent);
      }
    }
  };
  _proto.runFrom = function runFrom(pointer, fn3) {
    var ret = this.getFrom(pointer);
    if (ret === null) {
      throw new Error("out of bounds");
    } else {
      ret.forEach((cE) => fn3(cE));
    }
  };
  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {
    return changeEvents.slice(0);
  };
  _proto.destroy = function destroy() {
    this.subs.forEach((sub) => sub.unsubscribe());
  };
  return ChangeEventBuffer2;
}();
function createChangeEventBuffer(collection) {
  return new ChangeEventBuffer(collection);
}
var constructorForCollection = /* @__PURE__ */ new WeakMap();
function getDocumentPrototype(rxCollection) {
  var schemaProto = rxCollection.schema.getDocumentPrototype();
  var ormProto = getDocumentOrmPrototype(rxCollection);
  var baseProto = basePrototype;
  var proto = {};
  [schemaProto, ormProto, baseProto].forEach((obj) => {
    var props = Object.getOwnPropertyNames(obj);
    props.forEach((key) => {
      var desc = Object.getOwnPropertyDescriptor(obj, key);
      var enumerable = true;
      if (key.startsWith("_") || key.endsWith("_") || key.startsWith("$") || key.endsWith("$"))
        enumerable = false;
      if (typeof desc.value === "function") {
        Object.defineProperty(proto, key, {
          get() {
            return desc.value.bind(this);
          },
          enumerable,
          configurable: false
        });
      } else {
        desc.enumerable = enumerable;
        desc.configurable = false;
        if (desc.writable)
          desc.writable = false;
        Object.defineProperty(proto, key, desc);
      }
    });
  });
  return proto;
}
function getRxDocumentConstructor(rxCollection) {
  return getFromMapOrCreate(constructorForCollection, rxCollection, () => createRxDocumentConstructor(getDocumentPrototype(rxCollection)));
}
function createNewRxDocument(rxCollection, docData) {
  var doc = createWithConstructor(getRxDocumentConstructor(rxCollection), rxCollection, overwritable.deepFreezeWhenDevMode(docData));
  rxCollection._runHooksSync("post", "create", docData, doc);
  runPluginHooks("postCreateRxDocument", doc);
  return doc;
}
function getDocumentOrmPrototype(rxCollection) {
  var proto = {};
  Object.entries(rxCollection.methods).forEach(([k2, v2]) => {
    proto[k2] = v2;
  });
  return proto;
}
var defaultConflictHandler = function(i2, _context) {
  if (deepEqual$1(i2.newDocumentState, i2.realMasterState)) {
    return Promise.resolve({
      isEqual: true
    });
  }
  return Promise.resolve({
    isEqual: false,
    documentData: i2.realMasterState
  });
};
var HOOKS_WHEN = ["pre", "post"];
var HOOKS_KEYS = ["insert", "save", "remove", "create"];
var hooksApplied = false;
var RxCollectionBase = /* @__PURE__ */ function() {
  function RxCollectionBase2(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = defaultCacheReplacementPolicy, statics = {}, conflictHandler = defaultConflictHandler) {
    this.storageInstance = {};
    this.timeouts = /* @__PURE__ */ new Set();
    this.incrementalWriteQueue = {};
    this._incrementalUpsertQueues = /* @__PURE__ */ new Map();
    this.synced = false;
    this.hooks = {};
    this._subs = [];
    this._docCache = {};
    this._queryCache = createQueryCache();
    this.$ = {};
    this.checkpoint$ = {};
    this._changeEventBuffer = {};
    this.onDestroy = [];
    this.destroyed = false;
    this.database = database;
    this.name = name;
    this.schema = schema;
    this.internalStorageInstance = internalStorageInstance;
    this.instanceCreationOptions = instanceCreationOptions;
    this.migrationStrategies = migrationStrategies;
    this.methods = methods;
    this.attachments = attachments;
    this.options = options;
    this.cacheReplacementPolicy = cacheReplacementPolicy;
    this.statics = statics;
    this.conflictHandler = conflictHandler;
    _applyHookFunctions(this.asRxCollection);
  }
  var _proto = RxCollectionBase2.prototype;
  _proto.prepare = async function prepare2() {
    this.storageInstance = getWrappedStorageInstance(this.database, this.internalStorageInstance, this.schema.jsonSchema);
    this.incrementalWriteQueue = new IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => beforeDocumentUpdateWrite(this, newData, oldData), (result) => this._runHooks("post", "save", result));
    var collectionEventBulks$ = this.database.eventBulks$.pipe(filter$1((changeEventBulk) => changeEventBulk.collectionName === this.name));
    this.$ = collectionEventBulks$.pipe(mergeMap((changeEventBulk) => changeEventBulk.events));
    this.checkpoint$ = collectionEventBulks$.pipe(map((changeEventBulk) => changeEventBulk.checkpoint));
    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);
    this._docCache = new DocumentCache(this.schema.primaryPath, this.$.pipe(filter$1((cE) => !cE.isLocal)), (docData) => createNewRxDocument(this.asRxCollection, docData));
    var databaseStorageToken = await this.database.storageToken;
    var subDocs = this.storageInstance.changeStream().subscribe((eventBulk) => {
      var changeEventBulk = {
        id: eventBulk.id,
        internal: false,
        collectionName: this.name,
        storageToken: databaseStorageToken,
        events: eventBulk.events.map((ev) => storageChangeEventToRxChangeEvent(false, ev, this)),
        databaseToken: this.database.token,
        checkpoint: eventBulk.checkpoint,
        context: eventBulk.context
      };
      this.database.$emit(changeEventBulk);
    });
    this._subs.push(subDocs);
    this._subs.push(this.storageInstance.conflictResultionTasks().subscribe((task) => {
      this.conflictHandler(task.input, task.context).then((output) => {
        this.storageInstance.resolveConflictResultionTask({
          id: task.id,
          output
        });
      });
    }));
    return PROMISE_RESOLVE_VOID;
  };
  _proto.migrationNeeded = function migrationNeeded() {
    throw pluginMissing("migration");
  };
  _proto.getDataMigrator = function getDataMigrator() {
    throw pluginMissing("migration");
  };
  _proto.migrate = function migrate(batchSize = 10) {
    return this.getDataMigrator().migrate(batchSize);
  };
  _proto.migratePromise = function migratePromise(batchSize = 10) {
    return this.getDataMigrator().migratePromise(batchSize);
  };
  _proto.insert = async function insert(json) {
    var writeResult = await this.bulkInsert([json]);
    var isError = writeResult.error[0];
    throwIfIsStorageWriteError(this, json[this.schema.primaryPath], json, isError);
    var insertResult = ensureNotFalsy(writeResult.success[0]);
    return insertResult;
  };
  _proto.bulkInsert = async function bulkInsert(docsData) {
    if (docsData.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var primaryPath = this.schema.primaryPath;
    var useDocs = docsData.map((docData) => {
      var useDocData = fillObjectDataBeforeInsert(this.schema, docData);
      return useDocData;
    });
    var docs = this.hasHooks("pre", "insert") ? await Promise.all(useDocs.map((doc) => {
      return this._runHooks("pre", "insert", doc).then(() => {
        return doc;
      });
    })) : useDocs;
    var docsMap = /* @__PURE__ */ new Map();
    var insertRows = docs.map((doc) => {
      docsMap.set(doc[primaryPath], doc);
      var row = {
        document: doc
      };
      return row;
    });
    var results = await this.storageInstance.bulkWrite(insertRows, "rx-collection-bulk-insert");
    var rxDocuments = Object.values(results.success).map((writtenDocData) => this._docCache.getCachedRxDocument(writtenDocData));
    if (this.hasHooks("post", "insert")) {
      await Promise.all(rxDocuments.map((doc) => {
        return this._runHooks("post", "insert", docsMap.get(doc.primary), doc);
      }));
    }
    return {
      success: rxDocuments,
      error: Object.values(results.error)
    };
  };
  _proto.bulkRemove = async function bulkRemove(ids) {
    if (ids.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var rxDocumentMap = await this.findByIds(ids).exec();
    var docsData = [];
    var docsMap = /* @__PURE__ */ new Map();
    Array.from(rxDocumentMap.values()).forEach((rxDocument) => {
      var data = rxDocument.toMutableJSON(true);
      docsData.push(data);
      docsMap.set(rxDocument.primary, data);
    });
    await Promise.all(docsData.map((doc) => {
      var primary = doc[this.schema.primaryPath];
      return this._runHooks("pre", "remove", doc, rxDocumentMap.get(primary));
    }));
    var removeDocs = docsData.map((doc) => {
      var writeDoc = flatClone(doc);
      writeDoc._deleted = true;
      return {
        previous: doc,
        document: writeDoc
      };
    });
    var results = await this.storageInstance.bulkWrite(removeDocs, "rx-collection-bulk-remove");
    var successIds = Object.keys(results.success);
    await Promise.all(successIds.map((id2) => {
      return this._runHooks("post", "remove", docsMap.get(id2), rxDocumentMap.get(id2));
    }));
    var rxDocuments = successIds.map((id2) => getFromMapOrThrow(rxDocumentMap, id2));
    return {
      success: rxDocuments,
      error: Object.values(results.error)
    };
  };
  _proto.bulkUpsert = async function bulkUpsert(docsData) {
    var insertData = [];
    var useJsonByDocId = /* @__PURE__ */ new Map();
    docsData.forEach((docData) => {
      var useJson = fillObjectDataBeforeInsert(this.schema, docData);
      var primary = useJson[this.schema.primaryPath];
      if (!primary) {
        throw newRxError("COL3", {
          primaryPath: this.schema.primaryPath,
          data: useJson,
          schema: this.schema.jsonSchema
        });
      }
      useJsonByDocId.set(primary, useJson);
      insertData.push(useJson);
    });
    var insertResult = await this.bulkInsert(insertData);
    var ret = insertResult.success.slice(0);
    var updatedDocs = await Promise.all(insertResult.error.map(async (error) => {
      if (error.status !== 409) {
        throw newRxError("VD2", {
          collection: this.name,
          writeError: error
        });
      }
      var id2 = error.documentId;
      var writeData = getFromMapOrThrow(useJsonByDocId, id2);
      var docDataInDb = ensureNotFalsy(error.documentInDb);
      var doc = this._docCache.getCachedRxDocument(docDataInDb);
      var newDoc = await doc.incrementalModify(() => writeData);
      return newDoc;
    }));
    appendToArray(ret, updatedDocs);
    return ret;
  };
  _proto.upsert = function upsert(json) {
    return this.bulkUpsert([json]).then((result) => result[0]);
  };
  _proto.incrementalUpsert = function incrementalUpsert(json) {
    var useJson = fillObjectDataBeforeInsert(this.schema, json);
    var primary = useJson[this.schema.primaryPath];
    if (!primary) {
      throw newRxError("COL4", {
        data: json
      });
    }
    var queue = this._incrementalUpsertQueues.get(primary);
    if (!queue) {
      queue = PROMISE_RESOLVE_VOID;
    }
    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then((wasInserted) => {
      if (!wasInserted.inserted) {
        return _incrementalUpsertUpdate(wasInserted.doc, useJson);
      } else {
        return wasInserted.doc;
      }
    });
    this._incrementalUpsertQueues.set(primary, queue);
    return queue;
  };
  _proto.find = function find(queryObj) {
    if (typeof queryObj === "string") {
      throw newRxError("COL5", {
        queryObj
      });
    }
    if (!queryObj) {
      queryObj = _getDefaultQuery();
    }
    var query = createRxQuery("find", queryObj, this);
    return query;
  };
  _proto.findOne = function findOne(queryObj) {
    var query;
    if (typeof queryObj === "string") {
      query = createRxQuery("findOne", {
        selector: {
          [this.schema.primaryPath]: queryObj
        },
        limit: 1
      }, this);
    } else {
      if (!queryObj) {
        queryObj = _getDefaultQuery();
      }
      if (queryObj.limit) {
        throw newRxError("QU6");
      }
      queryObj.limit = 1;
      query = createRxQuery("findOne", queryObj, this);
    }
    if (typeof queryObj === "number" || Array.isArray(queryObj)) {
      throw newRxTypeError("COL6", {
        queryObj
      });
    }
    return query;
  };
  _proto.count = function count(queryObj) {
    if (!queryObj) {
      queryObj = _getDefaultQuery();
    }
    var query = createRxQuery("count", queryObj, this);
    return query;
  };
  _proto.findByIds = function findByIds(ids) {
    var mangoQuery = {
      selector: {
        [this.schema.primaryPath]: {
          $in: ids.slice(0)
        }
      }
    };
    var query = createRxQuery("findByIds", mangoQuery, this);
    return query;
  };
  _proto.exportJSON = function exportJSON() {
    throw pluginMissing("json-dump");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw pluginMissing("json-dump");
  };
  _proto.insertCRDT = function insertCRDT(_updateObj) {
    throw pluginMissing("crdt");
  };
  _proto.addHook = function addHook(when, key, fun, parallel = false) {
    if (typeof fun !== "function") {
      throw newRxTypeError("COL7", {
        key,
        when
      });
    }
    if (!HOOKS_WHEN.includes(when)) {
      throw newRxTypeError("COL8", {
        key,
        when
      });
    }
    if (!HOOKS_KEYS.includes(key)) {
      throw newRxError("COL9", {
        key
      });
    }
    if (when === "post" && key === "create" && parallel === true) {
      throw newRxError("COL10", {
        when,
        key,
        parallel
      });
    }
    var boundFun = fun.bind(this);
    var runName = parallel ? "parallel" : "series";
    this.hooks[key] = this.hooks[key] || {};
    this.hooks[key][when] = this.hooks[key][when] || {
      series: [],
      parallel: []
    };
    this.hooks[key][when][runName].push(boundFun);
  };
  _proto.getHooks = function getHooks(when, key) {
    if (!this.hooks[key] || !this.hooks[key][when]) {
      return {
        series: [],
        parallel: []
      };
    }
    return this.hooks[key][when];
  };
  _proto.hasHooks = function hasHooks(when, key) {
    var hooks = this.getHooks(when, key);
    if (!hooks) {
      return false;
    }
    return hooks.series.length > 0 || hooks.parallel.length > 0;
  };
  _proto._runHooks = function _runHooks(when, key, data, instance) {
    var hooks = this.getHooks(when, key);
    if (!hooks) {
      return PROMISE_RESOLVE_VOID;
    }
    var tasks = hooks.series.map((hook) => () => hook(data, instance));
    return promiseSeries(tasks).then(() => Promise.all(hooks.parallel.map((hook) => hook(data, instance))));
  };
  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {
    var hooks = this.getHooks(when, key);
    if (!hooks)
      return;
    hooks.series.forEach((hook) => hook(data, instance));
  };
  _proto.promiseWait = function promiseWait2(time2) {
    var ret = new Promise((res) => {
      var timeout = setTimeout(() => {
        this.timeouts.delete(timeout);
        res();
      }, time2);
      this.timeouts.add(timeout);
    });
    return ret;
  };
  _proto.destroy = function destroy() {
    if (this.destroyed) {
      return PROMISE_RESOLVE_FALSE;
    }
    this.destroyed = true;
    Array.from(this.timeouts).forEach((timeout) => clearTimeout(timeout));
    if (this._changeEventBuffer) {
      this._changeEventBuffer.destroy();
    }
    return this.database.requestIdlePromise().then(() => Promise.all(this.onDestroy.map((fn3) => fn3()))).then(() => this.storageInstance.close()).then(() => {
      this._subs.forEach((sub) => sub.unsubscribe());
      delete this.database.collections[this.name];
      return runAsyncPluginHooks("postDestroyRxCollection", this).then(() => true);
    });
  };
  _proto.remove = async function remove() {
    await this.destroy();
    await removeCollectionStorages(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.hashFunction);
  };
  _createClass(RxCollectionBase2, [{
    key: "insert$",
    get: function() {
      return this.$.pipe(filter$1((cE) => cE.operation === "INSERT"));
    }
  }, {
    key: "update$",
    get: function() {
      return this.$.pipe(filter$1((cE) => cE.operation === "UPDATE"));
    }
  }, {
    key: "remove$",
    get: function() {
      return this.$.pipe(filter$1((cE) => cE.operation === "DELETE"));
    }
    // defaults
    /**
     * When the collection is destroyed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
     */
  }, {
    key: "asRxCollection",
    get: function() {
      return this;
    }
  }]);
  return RxCollectionBase2;
}();
function _applyHookFunctions(collection) {
  if (hooksApplied)
    return;
  hooksApplied = true;
  var colProto = Object.getPrototypeOf(collection);
  HOOKS_KEYS.forEach((key) => {
    HOOKS_WHEN.map((when) => {
      var fnName = when + ucfirst(key);
      colProto[fnName] = function(fun, parallel) {
        return this.addHook(when, key, fun, parallel);
      };
    });
  });
}
function _incrementalUpsertUpdate(doc, json) {
  return doc.incrementalModify((_innerDoc) => {
    return json;
  });
}
function _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {
  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);
  if (docDataFromCache) {
    return Promise.resolve({
      doc: rxCollection._docCache.getCachedRxDocument(docDataFromCache),
      inserted: false
    });
  }
  return rxCollection.findOne(primary).exec().then((doc) => {
    if (!doc) {
      return rxCollection.insert(json).then((newDoc) => ({
        doc: newDoc,
        inserted: true
      }));
    } else {
      return {
        doc,
        inserted: false
      };
    }
  });
}
function createRxCollection({
  database,
  name,
  schema,
  instanceCreationOptions = {},
  migrationStrategies = {},
  autoMigrate = true,
  statics = {},
  methods = {},
  attachments = {},
  options = {},
  localDocuments = false,
  cacheReplacementPolicy = defaultCacheReplacementPolicy,
  conflictHandler = defaultConflictHandler
}) {
  var storageInstanceCreationParams = {
    databaseInstanceToken: database.token,
    databaseName: database.name,
    collectionName: name,
    schema: schema.jsonSchema,
    options: instanceCreationOptions,
    multiInstance: database.multiInstance,
    password: database.password,
    devMode: overwritable.isDevMode()
  };
  runPluginHooks("preCreateRxStorageInstance", storageInstanceCreationParams);
  return createRxCollectionStorageInstance(database, storageInstanceCreationParams).then((storageInstance) => {
    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);
    return collection.prepare().then(() => {
      Object.entries(statics).forEach(([funName, fun]) => {
        Object.defineProperty(collection, funName, {
          get: () => fun.bind(collection)
        });
      });
      var ret = PROMISE_RESOLVE_VOID;
      if (autoMigrate && collection.schema.version !== 0) {
        ret = collection.migratePromise();
      }
      return ret;
    }).then(() => {
      runPluginHooks("createRxCollection", {
        collection,
        creator: {
          name,
          schema,
          storageInstance,
          instanceCreationOptions,
          migrationStrategies,
          methods,
          attachments,
          options,
          cacheReplacementPolicy,
          localDocuments,
          statics
        }
      });
      return collection;
    }).catch((err) => {
      return storageInstance.close().then(() => Promise.reject(err));
    });
  });
}
var IdleQueue = function IdleQueue2() {
  var parallels = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
  this._parallels = parallels || 1;
  this._qC = 0;
  this._iC = /* @__PURE__ */ new Set();
  this._lHN = 0;
  this._hPM = /* @__PURE__ */ new Map();
  this._pHM = /* @__PURE__ */ new Map();
};
IdleQueue.prototype = {
  isIdle: function isIdle() {
    return this._qC < this._parallels;
  },
  /**
   * creates a lock in the queue
   * and returns an unlock-function to remove the lock from the queue
   * @return {function} unlock function than must be called afterwards
   */
  lock: function lock() {
    this._qC++;
  },
  unlock: function unlock() {
    this._qC--;
    _tryIdleCall(this);
  },
  /**
   * wraps a function with lock/unlock and runs it
   * @param  {function}  fun
   * @return {Promise<any>}
   */
  wrapCall: function wrapCall(fun) {
    var _this = this;
    this.lock();
    var maybePromise;
    try {
      maybePromise = fun();
    } catch (err) {
      this.unlock();
      throw err;
    }
    if (!maybePromise.then || typeof maybePromise.then !== "function") {
      this.unlock();
      return maybePromise;
    } else {
      return maybePromise.then(function(ret) {
        _this.unlock();
        return ret;
      })["catch"](function(err) {
        _this.unlock();
        throw err;
      });
    }
  },
  /**
   * does the same as requestIdleCallback() but uses promises instead of the callback
   * @param {{timeout?: number}} options like timeout
   * @return {Promise<void>} promise that resolves when the database is in idle-mode
   */
  requestIdlePromise: function requestIdlePromise2(options) {
    var _this2 = this;
    options = options || {};
    var resolve2;
    var prom = new Promise(function(res) {
      return resolve2 = res;
    });
    var resolveFromOutside = function resolveFromOutside2() {
      _removeIdlePromise(_this2, prom);
      resolve2();
    };
    prom._manRes = resolveFromOutside;
    if (options.timeout) {
      var timeoutObj = setTimeout(function() {
        prom._manRes();
      }, options.timeout);
      prom._timeoutObj = timeoutObj;
    }
    this._iC.add(prom);
    _tryIdleCall(this);
    return prom;
  },
  /**
   * remove the promise so it will never be resolved
   * @param  {Promise} promise from requestIdlePromise()
   * @return {void}
   */
  cancelIdlePromise: function cancelIdlePromise(promise2) {
    _removeIdlePromise(this, promise2);
  },
  /**
   * api equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback
   * @param  {Function} callback
   * @param  {options}   options  [description]
   * @return {number} handle which can be used with cancelIdleCallback()
   */
  requestIdleCallback: function requestIdleCallback2(callback, options) {
    var handle = this._lHN++;
    var promise2 = this.requestIdlePromise(options);
    this._hPM.set(handle, promise2);
    this._pHM.set(promise2, handle);
    promise2.then(function() {
      return callback();
    });
    return handle;
  },
  /**
   * API equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback
   * @param  {number} handle returned from requestIdleCallback()
   * @return {void}
   */
  cancelIdleCallback: function cancelIdleCallback(handle) {
    var promise2 = this._hPM.get(handle);
    this.cancelIdlePromise(promise2);
  },
  /**
   * clears and resets everything
   * @return {void}
   */
  clear: function clear() {
    var _this3 = this;
    this._iC.forEach(function(promise2) {
      return _removeIdlePromise(_this3, promise2);
    });
    this._qC = 0;
    this._iC.clear();
    this._hPM = /* @__PURE__ */ new Map();
    this._pHM = /* @__PURE__ */ new Map();
  }
};
function _resolveOneIdleCall(idleQueue) {
  if (idleQueue._iC.size === 0)
    return;
  var iterator2 = idleQueue._iC.values();
  var oldestPromise = iterator2.next().value;
  oldestPromise._manRes();
  setTimeout(function() {
    return _tryIdleCall(idleQueue);
  }, 0);
}
function _removeIdlePromise(idleQueue, promise2) {
  if (!promise2)
    return;
  if (promise2._timeoutObj)
    clearTimeout(promise2._timeoutObj);
  if (idleQueue._pHM.has(promise2)) {
    var handle = idleQueue._pHM.get(promise2);
    idleQueue._hPM["delete"](handle);
    idleQueue._pHM["delete"](promise2);
  }
  idleQueue._iC["delete"](promise2);
}
function _tryIdleCall(idleQueue) {
  if (idleQueue._tryIR || idleQueue._iC.size === 0)
    return;
  idleQueue._tryIR = true;
  setTimeout(function() {
    if (!idleQueue.isIdle()) {
      idleQueue._tryIR = false;
      return;
    }
    setTimeout(function() {
      if (!idleQueue.isIdle()) {
        idleQueue._tryIR = false;
        return;
      }
      _resolveOneIdleCall(idleQueue);
      idleQueue._tryIR = false;
    }, 0);
  }, 0);
}
var ObliviousSet = (
  /** @class */
  function() {
    function ObliviousSet2(ttl) {
      this.ttl = ttl;
      this.map = /* @__PURE__ */ new Map();
      this._to = false;
    }
    ObliviousSet2.prototype.has = function(value) {
      return this.map.has(value);
    };
    ObliviousSet2.prototype.add = function(value) {
      var _this = this;
      this.map.set(value, now());
      if (!this._to) {
        this._to = true;
        setTimeout(function() {
          _this._to = false;
          removeTooOldValues(_this);
        }, 0);
      }
    };
    ObliviousSet2.prototype.clear = function() {
      this.map.clear();
    };
    return ObliviousSet2;
  }()
);
function removeTooOldValues(obliviousSet) {
  var olderThen = now() - obliviousSet.ttl;
  var iterator2 = obliviousSet.map[Symbol.iterator]();
  while (true) {
    var next2 = iterator2.next().value;
    if (!next2) {
      return;
    }
    var value = next2[0];
    var time2 = next2[1];
    if (time2 < olderThen) {
      obliviousSet.map.delete(value);
    } else {
      return;
    }
  }
}
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var USED_DATABASE_NAMES = /* @__PURE__ */ new Set();
var RxDatabaseBase = /* @__PURE__ */ function() {
  function RxDatabaseBase2(name, token2, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {}, internalStore, hashFunction, cleanupPolicy, allowSlowCount) {
    this.idleQueue = new IdleQueue();
    this.storageInstances = /* @__PURE__ */ new Set();
    this._subs = [];
    this.startupErrors = [];
    this.onDestroy = [];
    this.destroyed = false;
    this.collections = {};
    this.eventBulks$ = new Subject();
    this.observable$ = this.eventBulks$.pipe(mergeMap((changeEventBulk) => changeEventBulk.events));
    this.storageToken = PROMISE_RESOLVE_FALSE;
    this.storageTokenDocument = PROMISE_RESOLVE_FALSE;
    this.emittedEventBulkIds = new ObliviousSet(60 * 1e3);
    this.name = name;
    this.token = token2;
    this.storage = storage;
    this.instanceCreationOptions = instanceCreationOptions;
    this.password = password;
    this.multiInstance = multiInstance;
    this.eventReduce = eventReduce;
    this.options = options;
    this.internalStore = internalStore;
    this.hashFunction = hashFunction;
    this.cleanupPolicy = cleanupPolicy;
    this.allowSlowCount = allowSlowCount;
    if (this.name !== "pseudoInstance") {
      this.internalStore = getWrappedStorageInstance(this.asRxDatabase, internalStore, INTERNAL_STORE_SCHEMA);
      this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase).catch((err) => this.startupErrors.push(err));
      this.storageToken = this.storageTokenDocument.then((doc) => doc.data.token).catch((err) => this.startupErrors.push(err));
    }
  }
  var _proto = RxDatabaseBase2.prototype;
  _proto.$emit = function $emit(changeEventBulk) {
    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {
      return;
    }
    this.emittedEventBulkIds.add(changeEventBulk.id);
    this.eventBulks$.next(changeEventBulk);
  };
  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {
    var doc = await getSingleDocument(this.internalStore, getPrimaryKeyOfInternalDocument(_collectionNamePrimary(name, schema), INTERNAL_CONTEXT_COLLECTION));
    if (!doc) {
      throw newRxError("SNH", {
        name,
        schema
      });
    }
    var writeDoc = flatCloneDocWithMeta(doc);
    writeDoc._deleted = true;
    await this.internalStore.bulkWrite([{
      document: writeDoc,
      previous: doc
    }], "rx-database-remove-collection");
  };
  _proto.addCollections = async function addCollections(collectionCreators) {
    var jsonSchemas = {};
    var schemas = {};
    var bulkPutDocs = [];
    var useArgsByCollectionName = {};
    Object.entries(collectionCreators).forEach(([name, args]) => {
      var collectionName = name;
      var rxJsonSchema = args.schema;
      jsonSchemas[collectionName] = rxJsonSchema;
      var schema = createRxSchema(rxJsonSchema, this.hashFunction);
      schemas[collectionName] = schema;
      if (this.collections[name]) {
        throw newRxError("DB3", {
          name
        });
      }
      var collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);
      var collectionDocData = {
        id: getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION),
        key: collectionNameWithVersion,
        context: INTERNAL_CONTEXT_COLLECTION,
        data: {
          name: collectionName,
          schemaHash: schema.hash,
          schema: schema.jsonSchema,
          version: schema.version,
          connectedStorages: []
        },
        _deleted: false,
        _meta: getDefaultRxDocumentMeta(),
        _rev: getDefaultRevision(),
        _attachments: {}
      };
      bulkPutDocs.push({
        document: collectionDocData
      });
      var useArgs = Object.assign({}, args, {
        name: collectionName,
        schema,
        database: this
      });
      var hookData = flatClone(args);
      hookData.database = this;
      hookData.name = name;
      runPluginHooks("preCreateRxCollection", hookData);
      useArgs.conflictHandler = hookData.conflictHandler;
      useArgsByCollectionName[collectionName] = useArgs;
    });
    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, "rx-database-add-collection");
    await ensureNoStartupErrors(this);
    Object.entries(putDocsResult.error).forEach(([_id, error]) => {
      if (error.status !== 409) {
        throw newRxError("DB12", {
          database: this.name,
          writeError: error
        });
      }
      var docInDb = ensureNotFalsy(error.documentInDb);
      var collectionName = docInDb.data.name;
      var schema = schemas[collectionName];
      if (docInDb.data.schemaHash !== schema.hash) {
        throw newRxError("DB6", {
          database: this.name,
          collection: collectionName,
          previousSchemaHash: docInDb.data.schemaHash,
          schemaHash: schema.hash,
          previousSchema: docInDb.data.schema,
          schema: ensureNotFalsy(jsonSchemas[collectionName])
        });
      }
    });
    var ret = {};
    await Promise.all(Object.keys(collectionCreators).map(async (collectionName) => {
      var useArgs = useArgsByCollectionName[collectionName];
      var collection = await createRxCollection(useArgs);
      ret[collectionName] = collection;
      this.collections[collectionName] = collection;
      if (!this[collectionName]) {
        Object.defineProperty(this, collectionName, {
          get: () => this.collections[collectionName]
        });
      }
    }));
    return ret;
  };
  _proto.lockedRun = function lockedRun(fn3) {
    return this.idleQueue.wrapCall(fn3);
  };
  _proto.requestIdlePromise = function requestIdlePromise3() {
    return this.idleQueue.requestIdlePromise();
  };
  _proto.exportJSON = function exportJSON(_collections) {
    throw pluginMissing("json-dump");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw pluginMissing("json-dump");
  };
  _proto.backup = function backup(_options) {
    throw pluginMissing("backup");
  };
  _proto.leaderElector = function leaderElector() {
    throw pluginMissing("leader-election");
  };
  _proto.isLeader = function isLeader() {
    throw pluginMissing("leader-election");
  };
  _proto.waitForLeadership = function waitForLeadership() {
    throw pluginMissing("leader-election");
  };
  _proto.migrationStates = function migrationStates() {
    throw pluginMissing("migration");
  };
  _proto.destroy = async function destroy() {
    if (this.destroyed) {
      return PROMISE_RESOLVE_FALSE;
    }
    this.destroyed = true;
    await runAsyncPluginHooks("preDestroyRxDatabase", this);
    this.eventBulks$.complete();
    this._subs.map((sub) => sub.unsubscribe());
    if (this.name === "pseudoInstance") {
      return PROMISE_RESOLVE_FALSE;
    }
    return this.requestIdlePromise().then(() => Promise.all(this.onDestroy.map((fn3) => fn3()))).then(() => Promise.all(Object.keys(this.collections).map((key) => this.collections[key]).map((col) => col.destroy()))).then(() => this.internalStore.close()).then(() => USED_DATABASE_NAMES.delete(this.name)).then(() => true);
  };
  _proto.remove = function remove() {
    return this.destroy().then(() => removeRxDatabase(this.name, this.storage));
  };
  _createClass(RxDatabaseBase2, [{
    key: "$",
    get: function() {
      return this.observable$;
    }
    /**
     * Because having unhandled exceptions would fail,
     * we have to store the async errors of the constructor here
     * so we can throw them later.
     */
    /**
     * When the database is destroyed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
     */
    /**
     * Unique token that is stored with the data.
     * Used to detect if the dataset has been deleted
     * and if two RxDatabase instances work on the same dataset or not.
     *
     * Because reading and writing the storageToken runs in the hot path
     * of database creation, we do not await the storageWrites but instead
     * work with the promise when we need the value.
     */
    /**
     * Stores the whole state of the internal storage token document.
     * We need this in some plugins.
     */
    /**
     * Contains the ids of all event bulks that have been emitted
     * by the database.
     * Used to detect duplicates that come in again via BroadcastChannel
     * or other streams.
     * TODO instead of having this here, we should add a test to ensure each RxStorage
     * behaves equal and does never emit duplicate eventBulks.
     */
  }, {
    key: "asRxDatabase",
    get: function() {
      return this;
    }
  }]);
  return RxDatabaseBase2;
}();
function throwIfDatabaseNameUsed(name) {
  if (!USED_DATABASE_NAMES.has(name)) {
    return;
  } else {
    throw newRxError("DB8", {
      name,
      link: "https://pubkey.github.io/rxdb/rx-database.html#ignoreduplicate"
    });
  }
}
async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {
  var internalStore = await storage.createStorageInstance({
    databaseInstanceToken,
    databaseName,
    collectionName: INTERNAL_STORAGE_NAME,
    schema: INTERNAL_STORE_SCHEMA,
    options,
    multiInstance,
    password,
    devMode: overwritable.isDevMode()
  });
  return internalStore;
}
function createRxDatabase({
  storage,
  instanceCreationOptions,
  name,
  password,
  multiInstance = true,
  eventReduce = false,
  ignoreDuplicate = false,
  options = {},
  cleanupPolicy,
  allowSlowCount = false,
  localDocuments = false,
  hashFunction = defaultHashSha256
}) {
  runPluginHooks("preCreateRxDatabase", {
    storage,
    instanceCreationOptions,
    name,
    password,
    multiInstance,
    eventReduce,
    ignoreDuplicate,
    options,
    localDocuments
  });
  if (!ignoreDuplicate) {
    throwIfDatabaseNameUsed(name);
  }
  USED_DATABASE_NAMES.add(name);
  var databaseInstanceToken = randomCouchString(10);
  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password).catch((err) => {
    USED_DATABASE_NAMES.delete(name);
    throw err;
  }).then((storageInstance) => {
    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount);
    return runAsyncPluginHooks("createRxDatabase", {
      database: rxDatabase,
      creator: {
        storage,
        instanceCreationOptions,
        name,
        password,
        multiInstance,
        eventReduce,
        ignoreDuplicate,
        options,
        localDocuments
      }
    }).then(() => rxDatabase);
  });
}
async function removeRxDatabase(databaseName, storage) {
  var databaseInstanceToken = randomCouchString(10);
  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, false);
  var collectionDocs = await getAllCollectionDocuments(storage.statics, dbInternalsStorageInstance);
  var collectionNames = /* @__PURE__ */ new Set();
  collectionDocs.forEach((doc) => collectionNames.add(doc.data.name));
  var removedCollectionNames = Array.from(collectionNames);
  await Promise.all(removedCollectionNames.map((collectionName) => removeCollectionStorages(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName)));
  await runAsyncPluginHooks("postRemoveRxDatabase", {
    databaseName,
    storage
  });
  await dbInternalsStorageInstance.remove();
  return removedCollectionNames;
}
async function ensureNoStartupErrors(rxDatabase) {
  await rxDatabase.storageToken;
  if (rxDatabase.startupErrors[0]) {
    throw rxDatabase.startupErrors[0];
  }
}
var PROTOTYPES = {
  RxSchema: RxSchema.prototype,
  RxDocument: basePrototype,
  RxQuery: RxQueryBase.prototype,
  RxCollection: RxCollectionBase.prototype,
  RxDatabase: RxDatabaseBase.prototype
};
var ADDED_PLUGINS = /* @__PURE__ */ new Set();
var ADDED_PLUGIN_NAMES = /* @__PURE__ */ new Set();
function addRxPlugin(plugin) {
  runPluginHooks("preAddRxPlugin", {
    plugin,
    plugins: ADDED_PLUGINS
  });
  if (ADDED_PLUGINS.has(plugin)) {
    return;
  } else {
    if (ADDED_PLUGIN_NAMES.has(plugin.name)) {
      throw newRxError("PL3", {
        name: plugin.name,
        plugin
      });
    }
    ADDED_PLUGINS.add(plugin);
    ADDED_PLUGIN_NAMES.add(plugin.name);
  }
  if (!plugin.rxdb) {
    throw newRxTypeError("PL1", {
      plugin
    });
  }
  if (plugin.init) {
    plugin.init();
  }
  if (plugin.prototypes) {
    Object.entries(plugin.prototypes).forEach(([name, fun]) => {
      return fun(PROTOTYPES[name]);
    });
  }
  if (plugin.overwritable) {
    Object.assign(overwritable, plugin.overwritable);
  }
  if (plugin.hooks) {
    Object.entries(plugin.hooks).forEach(([name, hooksObj]) => {
      if (hooksObj.after) {
        HOOKS[name].push(hooksObj.after);
      }
      if (hooksObj.before) {
        HOOKS[name].unshift(hooksObj.before);
      }
    });
  }
}
var RxStorageDefaultStatics = {
  prepareQuery(schema, mutateableQuery) {
    if (!mutateableQuery.sort) {
      throw newRxError("SNH", {
        query: mutateableQuery
      });
    }
    var queryPlan = getQueryPlan(schema, mutateableQuery);
    return {
      query: mutateableQuery,
      queryPlan
    };
  },
  checkpointSchema: DEFAULT_CHECKPOINT_SCHEMA
};
function isPromise2(obj) {
  return obj && typeof obj.then === "function";
}
Promise.resolve(false);
Promise.resolve(true);
var PROMISE_RESOLVED_VOID = Promise.resolve();
function sleep(time2, resolveWith) {
  if (!time2)
    time2 = 0;
  return new Promise(function(res) {
    return setTimeout(function() {
      return res(resolveWith);
    }, time2);
  });
}
function randomInt(min2, max2) {
  return Math.floor(Math.random() * (max2 - min2 + 1) + min2);
}
function randomToken() {
  return Math.random().toString(36).substring(2);
}
var lastMs = 0;
var additional = 0;
function microSeconds$4() {
  var ms = (/* @__PURE__ */ new Date()).getTime();
  if (ms === lastMs) {
    additional++;
    return ms * 1e3 + additional;
  } else {
    lastMs = ms;
    additional = 0;
    return ms * 1e3;
  }
}
var microSeconds$3 = microSeconds$4;
var type$3 = "native";
function create$3(channelName) {
  var state = {
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: []
    // subscriberFunctions
  };
  state.bc.onmessage = function(msg) {
    if (state.messagesCallback) {
      state.messagesCallback(msg.data);
    }
  };
  return state;
}
function close$3(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}
function postMessage$3(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}
function onMessage$3(channelState, fn3) {
  channelState.messagesCallback = fn3;
}
function canBeUsed$3() {
  if ((typeof window !== "undefined" || typeof self !== "undefined") && typeof BroadcastChannel === "function") {
    if (BroadcastChannel._pubkey) {
      throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
    }
    return true;
  } else {
    return false;
  }
}
function averageResponseTime$3() {
  return 150;
}
var NativeMethod = {
  create: create$3,
  close: close$3,
  onMessage: onMessage$3,
  postMessage: postMessage$3,
  canBeUsed: canBeUsed$3,
  type: type$3,
  averageResponseTime: averageResponseTime$3,
  microSeconds: microSeconds$3
};
function fillOptionsWithDefaults() {
  var originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var options = JSON.parse(JSON.stringify(originalOptions));
  if (typeof options.webWorkerSupport === "undefined")
    options.webWorkerSupport = true;
  if (!options.idb)
    options.idb = {};
  if (!options.idb.ttl)
    options.idb.ttl = 1e3 * 45;
  if (!options.idb.fallbackInterval)
    options.idb.fallbackInterval = 150;
  if (originalOptions.idb && typeof originalOptions.idb.onclose === "function")
    options.idb.onclose = originalOptions.idb.onclose;
  if (!options.localstorage)
    options.localstorage = {};
  if (!options.localstorage.removeTimeout)
    options.localstorage.removeTimeout = 1e3 * 60;
  if (originalOptions.methods)
    options.methods = originalOptions.methods;
  if (!options.node)
    options.node = {};
  if (!options.node.ttl)
    options.node.ttl = 1e3 * 60 * 2;
  if (!options.node.maxParallelWrites)
    options.node.maxParallelWrites = 2048;
  if (typeof options.node.useFastPath === "undefined")
    options.node.useFastPath = true;
  return options;
}
var microSeconds$2 = microSeconds$4;
var DB_PREFIX = "pubkey.broadcast-channel-0-";
var OBJECT_STORE_ID = "messages";
var TRANSACTION_SETTINGS = {
  durability: "relaxed"
};
var type$2 = "idb";
function getIdb() {
  if (typeof indexedDB !== "undefined")
    return indexedDB;
  if (typeof window !== "undefined") {
    if (typeof window.mozIndexedDB !== "undefined")
      return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== "undefined")
      return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== "undefined")
      return window.msIndexedDB;
  }
  return false;
}
function commitIndexedDBTransaction(tx) {
  if (tx.commit) {
    tx.commit();
  }
}
function createDatabase(channelName) {
  var IndexedDB = getIdb();
  var dbName = DB_PREFIX + channelName;
  var openRequest = IndexedDB.open(dbName);
  openRequest.onupgradeneeded = function(ev) {
    var db2 = ev.target.result;
    db2.createObjectStore(OBJECT_STORE_ID, {
      keyPath: "id",
      autoIncrement: true
    });
  };
  return new Promise(function(res, rej) {
    openRequest.onerror = function(ev) {
      return rej(ev);
    };
    openRequest.onsuccess = function() {
      res(openRequest.result);
    };
  });
}
function writeMessage(db2, readerUuid, messageJson) {
  var time2 = (/* @__PURE__ */ new Date()).getTime();
  var writeObject = {
    uuid: readerUuid,
    time: time2,
    data: messageJson
  };
  var tx = db2.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  return new Promise(function(res, rej) {
    tx.oncomplete = function() {
      return res();
    };
    tx.onerror = function(ev) {
      return rej(ev);
    };
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
    commitIndexedDBTransaction(tx);
  });
}
function getMessagesHigherThan(db2, lastCursorId) {
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
  if (objectStore.getAll) {
    var getAllRequest = objectStore.getAll(keyRangeValue);
    return new Promise(function(res, rej) {
      getAllRequest.onerror = function(err) {
        return rej(err);
      };
      getAllRequest.onsuccess = function(e2) {
        res(e2.target.result);
      };
    });
  }
  function openCursor() {
    try {
      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e2) {
      return objectStore.openCursor();
    }
  }
  return new Promise(function(res, rej) {
    var openCursorRequest = openCursor();
    openCursorRequest.onerror = function(err) {
      return rej(err);
    };
    openCursorRequest.onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        if (cursor2.value.id < lastCursorId + 1) {
          cursor2["continue"](lastCursorId + 1);
        } else {
          ret.push(cursor2.value);
          cursor2["continue"]();
        }
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function removeMessagesById(channelState, ids) {
  if (channelState.closed) {
    return Promise.resolve([]);
  }
  var tx = channelState.db.transaction(OBJECT_STORE_ID, "readwrite", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  return Promise.all(ids.map(function(id2) {
    var deleteRequest = objectStore["delete"](id2);
    return new Promise(function(res) {
      deleteRequest.onsuccess = function() {
        return res();
      };
    });
  }));
}
function getOldMessages(db2, ttl) {
  var olderThen = (/* @__PURE__ */ new Date()).getTime() - ttl;
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function(res) {
    objectStore.openCursor().onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        var msgObk = cursor2.value;
        if (msgObk.time < olderThen) {
          ret.push(msgObk);
          cursor2["continue"]();
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
        }
      } else {
        res(ret);
      }
    };
  });
}
function cleanOldMessages(channelState) {
  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function(tooOld) {
    return removeMessagesById(channelState, tooOld.map(function(msg) {
      return msg.id;
    }));
  });
}
function create$2(channelName, options) {
  options = fillOptionsWithDefaults(options);
  return createDatabase(channelName).then(function(db2) {
    var state = {
      closed: false,
      lastCursorId: 0,
      channelName,
      options,
      uuid: randomToken(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new ObliviousSet(options.idb.ttl * 2),
      // ensures we do not read messages in parallel
      writeBlockPromise: PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db: db2
    };
    db2.onclose = function() {
      state.closed = true;
      if (options.idb.onclose)
        options.idb.onclose();
    };
    _readLoop(state);
    return state;
  });
}
function _readLoop(state) {
  if (state.closed)
    return;
  readNewMessages(state).then(function() {
    return sleep(state.options.idb.fallbackInterval);
  }).then(function() {
    return _readLoop(state);
  });
}
function _filterMessage(msgObj, state) {
  if (msgObj.uuid === state.uuid)
    return false;
  if (state.eMIs.has(msgObj.id))
    return false;
  if (msgObj.data.time < state.messagesCallbackTime)
    return false;
  return true;
}
function readNewMessages(state) {
  if (state.closed)
    return PROMISE_RESOLVED_VOID;
  if (!state.messagesCallback)
    return PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state.db, state.lastCursorId).then(function(newerMessages) {
    var useMessages = newerMessages.filter(function(msgObj) {
      return !!msgObj;
    }).map(function(msgObj) {
      if (msgObj.id > state.lastCursorId) {
        state.lastCursorId = msgObj.id;
      }
      return msgObj;
    }).filter(function(msgObj) {
      return _filterMessage(msgObj, state);
    }).sort(function(msgObjA, msgObjB) {
      return msgObjA.time - msgObjB.time;
    });
    useMessages.forEach(function(msgObj) {
      if (state.messagesCallback) {
        state.eMIs.add(msgObj.id);
        state.messagesCallback(msgObj.data);
      }
    });
    return PROMISE_RESOLVED_VOID;
  });
}
function close$2(channelState) {
  channelState.closed = true;
  channelState.db.close();
}
function postMessage$2(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {
    return writeMessage(channelState.db, channelState.uuid, messageJson);
  }).then(function() {
    if (randomInt(0, 10) === 0) {
      cleanOldMessages(channelState);
    }
  });
  return channelState.writeBlockPromise;
}
function onMessage$2(channelState, fn3, time2) {
  channelState.messagesCallbackTime = time2;
  channelState.messagesCallback = fn3;
  readNewMessages(channelState);
}
function canBeUsed$2() {
  return !!getIdb();
}
function averageResponseTime$2(options) {
  return options.idb.fallbackInterval * 2;
}
var IndexedDBMethod = {
  create: create$2,
  close: close$2,
  onMessage: onMessage$2,
  postMessage: postMessage$2,
  canBeUsed: canBeUsed$2,
  type: type$2,
  averageResponseTime: averageResponseTime$2,
  microSeconds: microSeconds$2
};
var microSeconds$1 = microSeconds$4;
var KEY_PREFIX = "pubkey.broadcastChannel-";
var type$1 = "localstorage";
function getLocalStorage() {
  var localStorage2;
  if (typeof window === "undefined")
    return null;
  try {
    localStorage2 = window.localStorage;
    localStorage2 = window["ie8-eventlistener/storage"] || window.localStorage;
  } catch (e2) {
  }
  return localStorage2;
}
function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}
function postMessage$1(channelState, messageJson) {
  return new Promise(function(res) {
    sleep().then(function() {
      var key = storageKey(channelState.channelName);
      var writeObj = {
        token: randomToken(),
        time: (/* @__PURE__ */ new Date()).getTime(),
        data: messageJson,
        uuid: channelState.uuid
      };
      var value = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value);
      var ev = document.createEvent("Event");
      ev.initEvent("storage", true, true);
      ev.key = key;
      ev.newValue = value;
      window.dispatchEvent(ev);
      res();
    });
  });
}
function addStorageEventListener(channelName, fn3) {
  var key = storageKey(channelName);
  var listener = function listener2(ev) {
    if (ev.key === key) {
      fn3(JSON.parse(ev.newValue));
    }
  };
  window.addEventListener("storage", listener);
  return listener;
}
function removeStorageEventListener(listener) {
  window.removeEventListener("storage", listener);
}
function create$1(channelName, options) {
  options = fillOptionsWithDefaults(options);
  if (!canBeUsed$1()) {
    throw new Error("BroadcastChannel: localstorage cannot be used");
  }
  var uuid = randomToken();
  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);
  var state = {
    channelName,
    uuid,
    eMIs
    // emittedMessagesIds
  };
  state.listener = addStorageEventListener(channelName, function(msgObj) {
    if (!state.messagesCallback)
      return;
    if (msgObj.uuid === uuid)
      return;
    if (!msgObj.token || eMIs.has(msgObj.token))
      return;
    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime)
      return;
    eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  return state;
}
function close$1(channelState) {
  removeStorageEventListener(channelState.listener);
}
function onMessage$1(channelState, fn3, time2) {
  channelState.messagesCallbackTime = time2;
  channelState.messagesCallback = fn3;
}
function canBeUsed$1() {
  var ls = getLocalStorage();
  if (!ls)
    return false;
  try {
    var key = "__broadcastchannel_check";
    ls.setItem(key, "works");
    ls.removeItem(key);
  } catch (e2) {
    return false;
  }
  return true;
}
function averageResponseTime$1() {
  var defaultTime = 120;
  var userAgent = navigator.userAgent.toLowerCase();
  if (userAgent.includes("safari") && !userAgent.includes("chrome")) {
    return defaultTime * 2;
  }
  return defaultTime;
}
var LocalstorageMethod = {
  create: create$1,
  close: close$1,
  onMessage: onMessage$1,
  postMessage: postMessage$1,
  canBeUsed: canBeUsed$1,
  type: type$1,
  averageResponseTime: averageResponseTime$1,
  microSeconds: microSeconds$1
};
var microSeconds = microSeconds$4;
var type = "simulate";
var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
function create(channelName) {
  var state = {
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state);
  return state;
}
function close(channelState) {
  SIMULATE_CHANNELS["delete"](channelState);
}
function postMessage(channelState, messageJson) {
  return new Promise(function(res) {
    return setTimeout(function() {
      var channelArray = Array.from(SIMULATE_CHANNELS);
      channelArray.filter(function(channel) {
        return channel.name === channelState.name;
      }).filter(function(channel) {
        return channel !== channelState;
      }).filter(function(channel) {
        return !!channel.messagesCallback;
      }).forEach(function(channel) {
        return channel.messagesCallback(messageJson);
      });
      res();
    }, 5);
  });
}
function onMessage(channelState, fn3) {
  channelState.messagesCallback = fn3;
}
function canBeUsed() {
  return true;
}
function averageResponseTime() {
  return 5;
}
var SimulateMethod = {
  create,
  close,
  onMessage,
  postMessage,
  canBeUsed,
  type,
  averageResponseTime,
  microSeconds
};
var METHODS = [
  NativeMethod,
  // fastest
  IndexedDBMethod,
  LocalstorageMethod
];
function chooseMethod(options) {
  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
  if (options.type) {
    if (options.type === "simulate") {
      return SimulateMethod;
    }
    var ret = chooseMethods.find(function(m2) {
      return m2.type === options.type;
    });
    if (!ret)
      throw new Error("method-type " + options.type + " not found");
    else
      return ret;
  }
  if (!options.webWorkerSupport) {
    chooseMethods = chooseMethods.filter(function(m2) {
      return m2.type !== "idb";
    });
  }
  var useMethod = chooseMethods.find(function(method) {
    return method.canBeUsed();
  });
  if (!useMethod) {
    throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function(m2) {
      return m2.type;
    })));
  } else {
    return useMethod;
  }
}
var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
var lastId = 0;
var BroadcastChannel$1 = function BroadcastChannel2(name, options) {
  this.id = lastId++;
  OPEN_BROADCAST_CHANNELS.add(this);
  this.name = name;
  if (ENFORCED_OPTIONS) {
    options = ENFORCED_OPTIONS;
  }
  this.options = fillOptionsWithDefaults(options);
  this.method = chooseMethod(this.options);
  this._iL = false;
  this._onML = null;
  this._addEL = {
    message: [],
    internal: []
  };
  this._uMP = /* @__PURE__ */ new Set();
  this._befC = [];
  this._prepP = null;
  _prepareChannel(this);
};
BroadcastChannel$1._pubkey = true;
var ENFORCED_OPTIONS;
BroadcastChannel$1.prototype = {
  postMessage: function postMessage2(msg) {
    if (this.closed) {
      throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
       * In the past when this error appeared, it was really hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(msg));
    }
    return _post(this, "message", msg);
  },
  postInternal: function postInternal(msg) {
    return _post(this, "internal", msg);
  },
  set onmessage(fn3) {
    var time2 = this.method.microSeconds();
    var listenObj = {
      time: time2,
      fn: fn3
    };
    _removeListenerObject(this, "message", this._onML);
    if (fn3 && typeof fn3 === "function") {
      this._onML = listenObj;
      _addListenerObject(this, "message", listenObj);
    } else {
      this._onML = null;
    }
  },
  addEventListener: function addEventListener2(type2, fn3) {
    var time2 = this.method.microSeconds();
    var listenObj = {
      time: time2,
      fn: fn3
    };
    _addListenerObject(this, type2, listenObj);
  },
  removeEventListener: function removeEventListener(type2, fn3) {
    var obj = this._addEL[type2].find(function(obj2) {
      return obj2.fn === fn3;
    });
    _removeListenerObject(this, type2, obj);
  },
  close: function close2() {
    var _this = this;
    if (this.closed) {
      return;
    }
    OPEN_BROADCAST_CHANNELS["delete"](this);
    this.closed = true;
    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
    this._onML = null;
    this._addEL.message = [];
    return awaitPrepare.then(function() {
      return Promise.all(Array.from(_this._uMP));
    }).then(function() {
      return Promise.all(_this._befC.map(function(fn3) {
        return fn3();
      }));
    }).then(function() {
      return _this.method.close(_this._state);
    });
  },
  get type() {
    return this.method.type;
  },
  get isClosed() {
    return this.closed;
  }
};
function _post(broadcastChannel, type2, msg) {
  var time2 = broadcastChannel.method.microSeconds();
  var msgObj = {
    time: time2,
    type: type2,
    data: msg
  };
  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(function() {
    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
    broadcastChannel._uMP.add(sendPromise);
    sendPromise["catch"]().then(function() {
      return broadcastChannel._uMP["delete"](sendPromise);
    });
    return sendPromise;
  });
}
function _prepareChannel(channel) {
  var maybePromise = channel.method.create(channel.name, channel.options);
  if (isPromise2(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then(function(s2) {
      channel._state = s2;
    });
  } else {
    channel._state = maybePromise;
  }
}
function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0)
    return true;
  if (channel._addEL.internal.length > 0)
    return true;
  return false;
}
function _addListenerObject(channel, type2, obj) {
  channel._addEL[type2].push(obj);
  _startListening(channel);
}
function _removeListenerObject(channel, type2, obj) {
  channel._addEL[type2] = channel._addEL[type2].filter(function(o2) {
    return o2 !== obj;
  });
  _stopListening(channel);
}
function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    var listenerFn = function listenerFn2(msgObj) {
      channel._addEL[msgObj.type].forEach(function(listenerObject) {
        var hundredMsInMicro = 100 * 1e3;
        var minMessageTime = listenerObject.time - hundredMsInMicro;
        if (msgObj.time >= minMessageTime) {
          listenerObject.fn(msgObj.data);
        }
      });
    };
    var time2 = channel.method.microSeconds();
    if (channel._prepP) {
      channel._prepP.then(function() {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time2);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time2);
    }
  }
}
function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    channel._iL = false;
    var time2 = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time2);
  }
}
var BROADCAST_CHANNEL_BY_TOKEN = /* @__PURE__ */ new Map();
function getBroadcastChannelReference(databaseInstanceToken, databaseName, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    state = {
      /**
       * We have to use the databaseName instead of the databaseInstanceToken
       * in the BroadcastChannel name because different instances must end with the same
       * channel name to be able to broadcast messages between each other.
       */
      bc: new BroadcastChannel$1("RxDB:" + databaseName),
      refs: /* @__PURE__ */ new Set()
    };
    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);
  }
  state.refs.add(refObject);
  return state.bc;
}
function removeBroadcastChannelReference(databaseInstanceToken, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    return;
  }
  state.refs.delete(refObject);
  if (state.refs.size === 0) {
    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);
    return state.bc.close();
  }
}
function addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance, providedBroadcastChannel) {
  if (!instanceCreationParams.multiInstance) {
    return;
  }
  var broadcastChannel = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);
  var changesFromOtherInstances$ = new Subject();
  var eventListener = (msg) => {
    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {
      changesFromOtherInstances$.next(msg.eventBulk);
    }
  };
  broadcastChannel.addEventListener("message", eventListener);
  var oldChangestream$ = instance.changeStream();
  var closed = false;
  var sub = oldChangestream$.subscribe((eventBulk) => {
    if (closed) {
      return;
    }
    broadcastChannel.postMessage({
      storageName,
      databaseName: instanceCreationParams.databaseName,
      collectionName: instanceCreationParams.collectionName,
      version: instanceCreationParams.schema.version,
      eventBulk
    });
  });
  instance.changeStream = function() {
    return changesFromOtherInstances$.asObservable().pipe(mergeWith(oldChangestream$));
  };
  var oldClose = instance.close.bind(instance);
  instance.close = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldClose();
  };
  var oldRemove = instance.remove.bind(instance);
  instance.remove = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldRemove();
  };
}
const cartSchema = {
  title: "cart schema",
  description: "describes shopping cart",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    items: {
      type: "array",
      items: {
        type: "object",
        properties: {
          name: {
            type: "string"
          },
          image: {
            type: "string"
          },
          quantity: {
            type: "number"
          },
          unitPrice: {
            type: "number"
          },
          productId: {
            type: "string"
          },
          priceWithTax: {
            type: "number"
          },
          variationId: {
            type: "number"
          },
          productType: {
            type: "string"
          },
          productUnitId: {
            type: "number"
          }
        }
      }
    },
    timestamp: {
      type: "date-time"
    }
  }
};
var SPECIAL_PROPERTIES = ["__proto__", "constructor", "prototype"];
function merge$1(to, from2) {
  Object.keys(from2).forEach((key) => {
    if (SPECIAL_PROPERTIES.includes(key)) {
      return;
    }
    if (typeof to[key] === "undefined") {
      to[key] = from2[key];
    } else {
      if (isObject$3(from2[key]))
        merge$1(to[key], from2[key]);
      else
        to[key] = from2[key];
    }
  });
}
function isObject$3(arg) {
  return "[object Object]" === arg.toString();
}
var NoSqlQueryBuilderClass = /* @__PURE__ */ function() {
  function NoSqlQueryBuilderClass2(mangoQuery, _path) {
    this.options = {};
    this._conditions = {};
    this._fields = {};
    this._path = _path;
    if (mangoQuery) {
      var queryBuilder = this;
      if (mangoQuery.selector) {
        queryBuilder.find(mangoQuery.selector);
      }
      if (mangoQuery.limit) {
        queryBuilder.limit(mangoQuery.limit);
      }
      if (mangoQuery.skip) {
        queryBuilder.skip(mangoQuery.skip);
      }
      if (mangoQuery.sort) {
        mangoQuery.sort.forEach((s2) => queryBuilder.sort(s2));
      }
    }
  }
  var _proto = NoSqlQueryBuilderClass2.prototype;
  _proto.where = function where(_path, _val) {
    if (!arguments.length)
      return this;
    var type2 = typeof arguments[0];
    if ("string" === type2) {
      this._path = arguments[0];
      if (2 === arguments.length) {
        this._conditions[this._path] = arguments[1];
      }
      return this;
    }
    if ("object" === type2 && !Array.isArray(arguments[0])) {
      return this.merge(arguments[0]);
    }
    throw newRxTypeError("MQ1", {
      path: arguments[0]
    });
  };
  _proto.equals = function equals(val) {
    this._ensurePath("equals");
    var path = this._path;
    this._conditions[path] = val;
    return this;
  };
  _proto.eq = function eq2(val) {
    this._ensurePath("eq");
    var path = this._path;
    this._conditions[path] = val;
    return this;
  };
  _proto.or = function or(array2) {
    var or2 = this._conditions.$or || (this._conditions.$or = []);
    if (!Array.isArray(array2))
      array2 = [array2];
    or2.push.apply(or2, array2);
    return this;
  };
  _proto.nor = function nor(array2) {
    var nor2 = this._conditions.$nor || (this._conditions.$nor = []);
    if (!Array.isArray(array2))
      array2 = [array2];
    nor2.push.apply(nor2, array2);
    return this;
  };
  _proto.and = function and(array2) {
    var and2 = this._conditions.$and || (this._conditions.$and = []);
    if (!Array.isArray(array2))
      array2 = [array2];
    and2.push.apply(and2, array2);
    return this;
  };
  _proto.mod = function mod(_path, _val) {
    var val;
    var path;
    if (1 === arguments.length) {
      this._ensurePath("mod");
      val = arguments[0];
      path = this._path;
    } else if (2 === arguments.length && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = arguments.slice();
      path = this._path;
    } else if (3 === arguments.length) {
      val = arguments.slice(1);
      path = arguments[0];
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    var conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
  };
  _proto.exists = function exists(_path, _val) {
    var path;
    var val;
    if (0 === arguments.length) {
      this._ensurePath("exists");
      path = this._path;
      val = true;
    } else if (1 === arguments.length) {
      if ("boolean" === typeof arguments[0]) {
        this._ensurePath("exists");
        path = this._path;
        val = arguments[0];
      } else {
        path = arguments[0];
        val = true;
      }
    } else if (2 === arguments.length) {
      path = arguments[0];
      val = arguments[1];
    }
    var conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$exists = val;
    return this;
  };
  _proto.elemMatch = function elemMatch(_path, _criteria) {
    if (null === arguments[0])
      throw newRxTypeError("MQ2");
    var fn3;
    var path;
    var criteria;
    if ("function" === typeof arguments[0]) {
      this._ensurePath("elemMatch");
      path = this._path;
      fn3 = arguments[0];
    } else if (isObject$3(arguments[0])) {
      this._ensurePath("elemMatch");
      path = this._path;
      criteria = arguments[0];
    } else if ("function" === typeof arguments[1]) {
      path = arguments[0];
      fn3 = arguments[1];
    } else if (arguments[1] && isObject$3(arguments[1])) {
      path = arguments[0];
      criteria = arguments[1];
    } else
      throw newRxTypeError("MQ2");
    if (fn3) {
      criteria = new NoSqlQueryBuilderClass2();
      fn3(criteria);
      criteria = criteria._conditions;
    }
    var conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$elemMatch = criteria;
    return this;
  };
  _proto.sort = function sort(arg) {
    if (!arg)
      return this;
    var len;
    var type2 = typeof arg;
    if (Array.isArray(arg)) {
      len = arg.length;
      for (var i2 = 0; i2 < arg.length; ++i2) {
        _pushArr(this.options, arg[i2][0], arg[i2][1]);
      }
      return this;
    }
    if (1 === arguments.length && "string" === type2) {
      arg = arg.split(/\s+/);
      len = arg.length;
      for (var _i = 0; _i < len; ++_i) {
        var field = arg[_i];
        if (!field)
          continue;
        var ascend = "-" === field[0] ? -1 : 1;
        if (ascend === -1)
          field = field.substring(1);
        push(this.options, field, ascend);
      }
      return this;
    }
    if (isObject$3(arg)) {
      var keys3 = Object.keys(arg);
      keys3.forEach((field2) => push(this.options, field2, arg[field2]));
      return this;
    }
    throw newRxTypeError("MQ3", {
      args: arguments
    });
  };
  _proto.merge = function merge2(source) {
    if (!source) {
      return this;
    }
    if (!canMerge(source)) {
      throw newRxTypeError("MQ4", {
        source
      });
    }
    if (source instanceof NoSqlQueryBuilderClass2) {
      if (source._conditions)
        merge$1(this._conditions, source._conditions);
      if (source._fields) {
        if (!this._fields)
          this._fields = {};
        merge$1(this._fields, source._fields);
      }
      if (source.options) {
        if (!this.options)
          this.options = {};
        merge$1(this.options, source.options);
      }
      if (source._distinct)
        this._distinct = source._distinct;
      return this;
    }
    merge$1(this._conditions, source);
    return this;
  };
  _proto.find = function find(criteria) {
    if (canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  _proto._ensurePath = function _ensurePath(method) {
    if (!this._path) {
      throw newRxError("MQ5", {
        method
      });
    }
  };
  _proto.toJSON = function toJSON2() {
    var query = {
      selector: this._conditions
    };
    if (this.options.skip) {
      query.skip = this.options.skip;
    }
    if (this.options.limit) {
      query.limit = this.options.limit;
    }
    if (this.options.sort) {
      query.sort = mQuerySortToRxDBSort(this.options.sort);
    }
    return {
      query,
      path: this._path
    };
  };
  return NoSqlQueryBuilderClass2;
}();
function mQuerySortToRxDBSort(sort) {
  return Object.entries(sort).map(([k2, v2]) => {
    var direction2 = v2 === 1 ? "asc" : "desc";
    var part = {
      [k2]: direction2
    };
    return part;
  });
}
var OTHER_MANGO_ATTRIBUTES = ["limit", "skip", "maxScan", "batchSize", "comment"];
OTHER_MANGO_ATTRIBUTES.forEach(function(method) {
  NoSqlQueryBuilderClass.prototype[method] = function(v2) {
    this.options[method] = v2;
    return this;
  };
});
var OTHER_MANGO_OPERATORS = ["gt", "gte", "lt", "lte", "ne", "in", "nin", "all", "regex", "size"];
OTHER_MANGO_OPERATORS.forEach(function($conditional) {
  NoSqlQueryBuilderClass.prototype[$conditional] = function() {
    var path;
    var val;
    if (1 === arguments.length) {
      this._ensurePath($conditional);
      val = arguments[0];
      path = this._path;
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    var conds = this._conditions[path] === null || typeof this._conditions[path] === "object" ? this._conditions[path] : this._conditions[path] = {};
    conds["$" + $conditional] = val;
    return this;
  };
});
function push(opts, field, value) {
  if (Array.isArray(opts.sort)) {
    throw newRxTypeError("MQ6", {
      opts,
      field,
      value
    });
  }
  if (value && value.$meta) {
    var sort = opts.sort || (opts.sort = {});
    sort[field] = {
      $meta: value.$meta
    };
    return;
  }
  var val = String(value || 1).toLowerCase();
  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {
    if (Array.isArray(value))
      value = "[" + value + "]";
    throw newRxTypeError("MQ7", {
      field,
      value
    });
  }
  var s2 = opts.sort || (opts.sort = {});
  var valueStr = value.toString().replace("asc", "1").replace("ascending", "1").replace("desc", "-1").replace("descending", "-1");
  s2[field] = parseInt(valueStr, 10);
}
function _pushArr(opts, field, value) {
  opts.sort = opts.sort || [];
  if (!Array.isArray(opts.sort)) {
    throw newRxTypeError("MQ8", {
      opts,
      field,
      value
    });
  }
  opts.sort.push([field, value]);
}
function canMerge(conds) {
  return conds instanceof NoSqlQueryBuilderClass || isObject$3(conds);
}
function createQueryBuilder(query, path) {
  return new NoSqlQueryBuilderClass(query, path);
}
var RXQUERY_OTHER_FLAG = "queryBuilderPath";
function runBuildingStep(rxQuery, functionName, value) {
  var queryBuilder = createQueryBuilder(clone$2(rxQuery.mangoQuery), rxQuery.other[RXQUERY_OTHER_FLAG]);
  queryBuilder[functionName](value);
  var queryBuilderJson = queryBuilder.toJSON();
  return createRxQuery(rxQuery.op, queryBuilderJson.query, rxQuery.collection, {
    ...rxQuery.other,
    [RXQUERY_OTHER_FLAG]: queryBuilderJson.path
  });
}
function applyBuildingStep(proto, functionName) {
  proto[functionName] = function(value) {
    return runBuildingStep(this, functionName, value);
  };
}
var RxDBQueryBuilderPlugin = {
  name: "query-builder",
  rxdb: true,
  prototypes: {
    RxQuery(proto) {
      ["where", "equals", "eq", "or", "nor", "and", "mod", "exists", "elemMatch", "sort"].forEach((attribute) => {
        applyBuildingStep(proto, attribute);
      });
      OTHER_MANGO_ATTRIBUTES.forEach((attribute) => {
        applyBuildingStep(proto, attribute);
      });
      OTHER_MANGO_OPERATORS.forEach((operator) => {
        applyBuildingStep(proto, operator);
      });
    }
  }
};
const e$2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, t$1 = Object.keys, n$3 = Array.isArray;
function r(e2, n2) {
  return "object" != typeof n2 || t$1(n2).forEach(function(t3) {
    e2[t3] = n2[t3];
  }), e2;
}
"undefined" == typeof Promise || e$2.Promise || (e$2.Promise = Promise);
const s$2 = Object.getPrototypeOf, i$6 = {}.hasOwnProperty;
function o$2(e2, t3) {
  return i$6.call(e2, t3);
}
function a$3(e2, n2) {
  "function" == typeof n2 && (n2 = n2(s$2(e2))), ("undefined" == typeof Reflect ? t$1 : Reflect.ownKeys)(n2).forEach((t3) => {
    l$2(e2, t3, n2[t3]);
  });
}
const u$4 = Object.defineProperty;
function l$2(e2, t3, n2, s2) {
  u$4(e2, t3, r(n2 && o$2(n2, "get") && "function" == typeof n2.get ? { get: n2.get, set: n2.set, configurable: true } : { value: n2, configurable: true, writable: true }, s2));
}
function c$2(e2) {
  return { from: function(t3) {
    return e2.prototype = Object.create(t3.prototype), l$2(e2.prototype, "constructor", e2), { extend: a$3.bind(null, e2.prototype) };
  } };
}
const h$3 = Object.getOwnPropertyDescriptor;
function d$2(e2, t3) {
  let n2;
  return h$3(e2, t3) || (n2 = s$2(e2)) && d$2(n2, t3);
}
const f$3 = [].slice;
function p$2(e2, t3, n2) {
  return f$3.call(e2, t3, n2);
}
function y$1(e2, t3) {
  return t3(e2);
}
function m$2(e2) {
  if (!e2)
    throw new Error("Assertion Failed");
}
function v$2(t3) {
  e$2.setImmediate ? setImmediate(t3) : setTimeout(t3, 0);
}
function g$2(e2, t3) {
  return e2.reduce((e3, n2, r2) => {
    var s2 = t3(n2, r2);
    return s2 && (e3[s2[0]] = s2[1]), e3;
  }, {});
}
function b$2(e2, t3) {
  if (o$2(e2, t3))
    return e2[t3];
  if (!t3)
    return e2;
  if ("string" != typeof t3) {
    for (var n2 = [], r2 = 0, s2 = t3.length; r2 < s2; ++r2) {
      var i2 = b$2(e2, t3[r2]);
      n2.push(i2);
    }
    return n2;
  }
  var a2 = t3.indexOf(".");
  if (-1 !== a2) {
    var u2 = e2[t3.substr(0, a2)];
    return void 0 === u2 ? void 0 : b$2(u2, t3.substr(a2 + 1));
  }
}
function _$3(e2, t3, r2) {
  if (e2 && void 0 !== t3 && (!("isFrozen" in Object) || !Object.isFrozen(e2)))
    if ("string" != typeof t3 && "length" in t3) {
      m$2("string" != typeof r2 && "length" in r2);
      for (var s2 = 0, i2 = t3.length; s2 < i2; ++s2)
        _$3(e2, t3[s2], r2[s2]);
    } else {
      var a2 = t3.indexOf(".");
      if (-1 !== a2) {
        var u2 = t3.substr(0, a2), l2 = t3.substr(a2 + 1);
        if ("" === l2)
          void 0 === r2 ? n$3(e2) && !isNaN(parseInt(u2)) ? e2.splice(u2, 1) : delete e2[u2] : e2[u2] = r2;
        else {
          var c2 = e2[u2];
          c2 && o$2(e2, u2) || (c2 = e2[u2] = {}), _$3(c2, l2, r2);
        }
      } else
        void 0 === r2 ? n$3(e2) && !isNaN(parseInt(t3)) ? e2.splice(t3, 1) : delete e2[t3] : e2[t3] = r2;
    }
}
function w$2(e2) {
  var t3 = {};
  for (var n2 in e2)
    o$2(e2, n2) && (t3[n2] = e2[n2]);
  return t3;
}
const x$2 = [].concat;
function k$1(e2) {
  return x$2.apply([], e2);
}
const E$2 = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(k$1([8, 16, 32, 64].map((e2) => ["Int", "Uint", "Float"].map((t3) => t3 + e2 + "Array")))).filter((t3) => e$2[t3]), P$2 = E$2.map((t3) => e$2[t3]);
g$2(E$2, (e2) => [e2, true]);
let K$1 = null;
function O$2(e2) {
  K$1 = "undefined" != typeof WeakMap && /* @__PURE__ */ new WeakMap();
  const t3 = S$2(e2);
  return K$1 = null, t3;
}
function S$2(e2) {
  if (!e2 || "object" != typeof e2)
    return e2;
  let t3 = K$1 && K$1.get(e2);
  if (t3)
    return t3;
  if (n$3(e2)) {
    t3 = [], K$1 && K$1.set(e2, t3);
    for (var r2 = 0, i2 = e2.length; r2 < i2; ++r2)
      t3.push(S$2(e2[r2]));
  } else if (P$2.indexOf(e2.constructor) >= 0)
    t3 = e2;
  else {
    const n2 = s$2(e2);
    for (var a2 in t3 = n2 === Object.prototype ? {} : Object.create(n2), K$1 && K$1.set(e2, t3), e2)
      o$2(e2, a2) && (t3[a2] = S$2(e2[a2]));
  }
  return t3;
}
const { toString: A$3 } = {};
function C$1(e2) {
  return A$3.call(e2).slice(8, -1);
}
const j$2 = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator", D$2 = "symbol" == typeof j$2 ? function(e2) {
  var t3;
  return null != e2 && (t3 = e2[j$2]) && t3.apply(e2);
} : function() {
  return null;
}, I$2 = {};
function B$1(e2) {
  var t3, r2, s2, i2;
  if (1 === arguments.length) {
    if (n$3(e2))
      return e2.slice();
    if (this === I$2 && "string" == typeof e2)
      return [e2];
    if (i2 = D$2(e2)) {
      for (r2 = []; !(s2 = i2.next()).done; )
        r2.push(s2.value);
      return r2;
    }
    if (null == e2)
      return [e2];
    if ("number" == typeof (t3 = e2.length)) {
      for (r2 = new Array(t3); t3--; )
        r2[t3] = e2[t3];
      return r2;
    }
    return [e2];
  }
  for (t3 = arguments.length, r2 = new Array(t3); t3--; )
    r2[t3] = arguments[t3];
  return r2;
}
const T$3 = "undefined" != typeof Symbol ? (e2) => "AsyncFunction" === e2[Symbol.toStringTag] : () => false;
var R$1 = "undefined" != typeof location && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function F$3(e2, t3) {
  R$1 = e2, M$2 = t3;
}
var M$2 = () => true;
const N$1 = !new Error("").stack;
function q$1() {
  if (N$1)
    try {
      throw q$1.arguments, new Error();
    } catch (e2) {
      return e2;
    }
  return new Error();
}
function $$2(e2, t3) {
  var n2 = e2.stack;
  return n2 ? (t3 = t3 || 0, 0 === n2.indexOf(e2.name) && (t3 += (e2.name + e2.message).split("\n").length), n2.split("\n").slice(t3).filter(M$2).map((e3) => "\n" + e3).join("")) : "";
}
var U$3 = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], L$2 = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(U$3), V$3 = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function W$2(e2, t3) {
  this._e = q$1(), this.name = e2, this.message = t3;
}
function Y$2(e2, t3) {
  return e2 + ". Errors: " + Object.keys(t3).map((e3) => t3[e3].toString()).filter((e3, t4, n2) => n2.indexOf(e3) === t4).join("\n");
}
function z$2(e2, t3, n2, r2) {
  this._e = q$1(), this.failures = t3, this.failedKeys = r2, this.successCount = n2, this.message = Y$2(e2, t3);
}
function G$2(e2, t3) {
  this._e = q$1(), this.name = "BulkError", this.failures = Object.keys(t3).map((e3) => t3[e3]), this.failuresByPos = t3, this.message = Y$2(e2, t3);
}
c$2(W$2).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + $$2(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), c$2(z$2).from(W$2), c$2(G$2).from(W$2);
var H$1 = L$2.reduce((e2, t3) => (e2[t3] = t3 + "Error", e2), {});
const Q$2 = W$2;
var X$2 = L$2.reduce((e2, t3) => {
  var n2 = t3 + "Error";
  function r2(e3, r3) {
    this._e = q$1(), this.name = n2, e3 ? "string" == typeof e3 ? (this.message = `${e3}${r3 ? "\n " + r3 : ""}`, this.inner = r3 || null) : "object" == typeof e3 && (this.message = `${e3.name} ${e3.message}`, this.inner = e3) : (this.message = V$3[t3] || n2, this.inner = null);
  }
  return c$2(r2).from(Q$2), e2[t3] = r2, e2;
}, {});
X$2.Syntax = SyntaxError, X$2.Type = TypeError, X$2.Range = RangeError;
var J$2 = U$3.reduce((e2, t3) => (e2[t3 + "Error"] = X$2[t3], e2), {});
var Z$3 = L$2.reduce((e2, t3) => (-1 === ["Syntax", "Type", "Range"].indexOf(t3) && (e2[t3 + "Error"] = X$2[t3]), e2), {});
function ee$2() {
}
function te$1(e2) {
  return e2;
}
function ne$2(e2, t3) {
  return null == e2 || e2 === te$1 ? t3 : function(n2) {
    return t3(e2(n2));
  };
}
function re$2(e2, t3) {
  return function() {
    e2.apply(this, arguments), t3.apply(this, arguments);
  };
}
function se$2(e2, t3) {
  return e2 === ee$2 ? t3 : function() {
    var n2 = e2.apply(this, arguments);
    void 0 !== n2 && (arguments[0] = n2);
    var r2 = this.onsuccess, s2 = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var i2 = t3.apply(this, arguments);
    return r2 && (this.onsuccess = this.onsuccess ? re$2(r2, this.onsuccess) : r2), s2 && (this.onerror = this.onerror ? re$2(s2, this.onerror) : s2), void 0 !== i2 ? i2 : n2;
  };
}
function ie$1(e2, t3) {
  return e2 === ee$2 ? t3 : function() {
    e2.apply(this, arguments);
    var n2 = this.onsuccess, r2 = this.onerror;
    this.onsuccess = this.onerror = null, t3.apply(this, arguments), n2 && (this.onsuccess = this.onsuccess ? re$2(n2, this.onsuccess) : n2), r2 && (this.onerror = this.onerror ? re$2(r2, this.onerror) : r2);
  };
}
function oe$2(e2, t3) {
  return e2 === ee$2 ? t3 : function(n2) {
    var s2 = e2.apply(this, arguments);
    r(n2, s2);
    var i2 = this.onsuccess, o2 = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var a2 = t3.apply(this, arguments);
    return i2 && (this.onsuccess = this.onsuccess ? re$2(i2, this.onsuccess) : i2), o2 && (this.onerror = this.onerror ? re$2(o2, this.onerror) : o2), void 0 === s2 ? void 0 === a2 ? void 0 : a2 : r(s2, a2);
  };
}
function ae$1(e2, t3) {
  return e2 === ee$2 ? t3 : function() {
    return false !== t3.apply(this, arguments) && e2.apply(this, arguments);
  };
}
function ue$2(e2, t3) {
  return e2 === ee$2 ? t3 : function() {
    var n2 = e2.apply(this, arguments);
    if (n2 && "function" == typeof n2.then) {
      for (var r2 = this, s2 = arguments.length, i2 = new Array(s2); s2--; )
        i2[s2] = arguments[s2];
      return n2.then(function() {
        return t3.apply(r2, i2);
      });
    }
    return t3.apply(this, arguments);
  };
}
Z$3.ModifyError = z$2, Z$3.DexieError = W$2, Z$3.BulkError = G$2;
var le$2 = {};
const [ce$1, he$2, de$2] = "undefined" == typeof Promise ? [] : (() => {
  let e2 = Promise.resolve();
  if ("undefined" == typeof crypto || !crypto.subtle)
    return [e2, s$2(e2), e2];
  const t3 = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [t3, s$2(t3), e2];
})(), fe$2 = he$2 && he$2.then, pe$2 = ce$1 && ce$1.constructor, ye$2 = !!de$2;
var me$1 = false, ve$2 = de$2 ? () => {
  de$2.then(qe);
} : e$2.setImmediate ? setImmediate.bind(null, qe) : e$2.MutationObserver ? () => {
  var e2 = document.createElement("div");
  new MutationObserver(() => {
    qe(), e2 = null;
  }).observe(e2, { attributes: true }), e2.setAttribute("i", "1");
} : () => {
  setTimeout(qe, 0);
}, ge$2 = function(e2, t3) {
  Oe.push([e2, t3]), _e && (ve$2(), _e = false);
}, be$2 = true, _e = true, we$1 = [], xe$1 = [], ke = null, Ee$1 = te$1, Pe = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: ct$1, pgp: false, env: {}, finalize: function() {
  this.unhandleds.forEach((e2) => {
    try {
      ct$1(e2[0], e2[1]);
    } catch (e3) {
    }
  });
} }, Ke = Pe, Oe = [], Se$1 = 0, Ae$1 = [];
function Ce(e2) {
  if ("object" != typeof this)
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = ee$2, this._lib = false;
  var t3 = this._PSD = Ke;
  if (R$1 && (this._stackHolder = q$1(), this._prev = null, this._numPrev = 0), "function" != typeof e2) {
    if (e2 !== le$2)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (false === this._state && Be(this, this._value));
  }
  this._state = null, this._value = null, ++t3.ref, Ie$1(this, e2);
}
const je = { get: function() {
  var e2 = Ke, t3 = Qe;
  function n2(n3, r2) {
    var s2 = !e2.global && (e2 !== Ke || t3 !== Qe);
    const i2 = s2 && !et$2();
    var o2 = new Ce((t4, o3) => {
      Re$1(this, new De(ut$1(n3, e2, s2, i2), ut$1(r2, e2, s2, i2), t4, o3, e2));
    });
    return R$1 && Ne$1(o2, this), o2;
  }
  return n2.prototype = le$2, n2;
}, set: function(e2) {
  l$2(this, "then", e2 && e2.prototype === le$2 ? je : { get: function() {
    return e2;
  }, set: je.set });
} };
function De(e2, t3, n2, r2, s2) {
  this.onFulfilled = "function" == typeof e2 ? e2 : null, this.onRejected = "function" == typeof t3 ? t3 : null, this.resolve = n2, this.reject = r2, this.psd = s2;
}
function Ie$1(e2, t3) {
  try {
    t3((t4) => {
      if (null === e2._state) {
        if (t4 === e2)
          throw new TypeError("A promise cannot be resolved with itself.");
        var n2 = e2._lib && $e();
        t4 && "function" == typeof t4.then ? Ie$1(e2, (e3, n3) => {
          t4 instanceof Ce ? t4._then(e3, n3) : t4.then(e3, n3);
        }) : (e2._state = true, e2._value = t4, Te$1(e2)), n2 && Ue();
      }
    }, Be.bind(null, e2));
  } catch (t4) {
    Be(e2, t4);
  }
}
function Be(e2, t3) {
  if (xe$1.push(t3), null === e2._state) {
    var n2 = e2._lib && $e();
    t3 = Ee$1(t3), e2._state = false, e2._value = t3, R$1 && null !== t3 && "object" == typeof t3 && !t3._promise && function(e3, t4, n3) {
      try {
        e3.apply(null, n3);
      } catch (e4) {
        t4 && t4(e4);
      }
    }(() => {
      var n3 = d$2(t3, "stack");
      t3._promise = e2, l$2(t3, "stack", { get: () => me$1 ? n3 && (n3.get ? n3.get.apply(t3) : n3.value) : e2.stack });
    }), function(e3) {
      we$1.some((t4) => t4._value === e3._value) || we$1.push(e3);
    }(e2), Te$1(e2), n2 && Ue();
  }
}
function Te$1(e2) {
  var t3 = e2._listeners;
  e2._listeners = [];
  for (var n2 = 0, r2 = t3.length; n2 < r2; ++n2)
    Re$1(e2, t3[n2]);
  var s2 = e2._PSD;
  --s2.ref || s2.finalize(), 0 === Se$1 && (++Se$1, ge$2(() => {
    0 == --Se$1 && Le$1();
  }, []));
}
function Re$1(e2, t3) {
  if (null !== e2._state) {
    var n2 = e2._state ? t3.onFulfilled : t3.onRejected;
    if (null === n2)
      return (e2._state ? t3.resolve : t3.reject)(e2._value);
    ++t3.psd.ref, ++Se$1, ge$2(Fe, [n2, e2, t3]);
  } else
    e2._listeners.push(t3);
}
function Fe(e2, t3, n2) {
  try {
    ke = t3;
    var r2, s2 = t3._value;
    t3._state ? r2 = e2(s2) : (xe$1.length && (xe$1 = []), r2 = e2(s2), -1 === xe$1.indexOf(s2) && function(e3) {
      var t4 = we$1.length;
      for (; t4; )
        if (we$1[--t4]._value === e3._value)
          return void we$1.splice(t4, 1);
    }(t3)), n2.resolve(r2);
  } catch (e3) {
    n2.reject(e3);
  } finally {
    ke = null, 0 == --Se$1 && Le$1(), --n2.psd.ref || n2.psd.finalize();
  }
}
function Me(e2, t3, n2) {
  if (t3.length === n2)
    return t3;
  var r2 = "";
  if (false === e2._state) {
    var s2, i2, o2 = e2._value;
    null != o2 ? (s2 = o2.name || "Error", i2 = o2.message || o2, r2 = $$2(o2, 0)) : (s2 = o2, i2 = ""), t3.push(s2 + (i2 ? ": " + i2 : "") + r2);
  }
  return R$1 && ((r2 = $$2(e2._stackHolder, 2)) && -1 === t3.indexOf(r2) && t3.push(r2), e2._prev && Me(e2._prev, t3, n2)), t3;
}
function Ne$1(e2, t3) {
  var n2 = t3 ? t3._numPrev + 1 : 0;
  n2 < 100 && (e2._prev = t3, e2._numPrev = n2);
}
function qe() {
  $e() && Ue();
}
function $e() {
  var e2 = be$2;
  return be$2 = false, _e = false, e2;
}
function Ue() {
  var e2, t3, n2;
  do {
    for (; Oe.length > 0; )
      for (e2 = Oe, Oe = [], n2 = e2.length, t3 = 0; t3 < n2; ++t3) {
        var r2 = e2[t3];
        r2[0].apply(null, r2[1]);
      }
  } while (Oe.length > 0);
  be$2 = true, _e = true;
}
function Le$1() {
  var e2 = we$1;
  we$1 = [], e2.forEach((e3) => {
    e3._PSD.onunhandled.call(null, e3._value, e3);
  });
  for (var t3 = Ae$1.slice(0), n2 = t3.length; n2; )
    t3[--n2]();
}
function Ve(e2) {
  return new Ce(le$2, false, e2);
}
function We(e2, t3) {
  var n2 = Ke;
  return function() {
    var r2 = $e(), s2 = Ke;
    try {
      return st$1(n2, true), e2.apply(this, arguments);
    } catch (e3) {
      t3 && t3(e3);
    } finally {
      st$1(s2, false), r2 && Ue();
    }
  };
}
a$3(Ce.prototype, { then: je, _then: function(e2, t3) {
  Re$1(this, new De(null, null, e2, t3, Ke));
}, catch: function(e2) {
  if (1 === arguments.length)
    return this.then(null, e2);
  var t3 = arguments[0], n2 = arguments[1];
  return "function" == typeof t3 ? this.then(null, (e3) => e3 instanceof t3 ? n2(e3) : Ve(e3)) : this.then(null, (e3) => e3 && e3.name === t3 ? n2(e3) : Ve(e3));
}, finally: function(e2) {
  return this.then((t3) => (e2(), t3), (t3) => (e2(), Ve(t3)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    me$1 = true;
    var e2 = Me(this, [], 20).join("\nFrom previous: ");
    return null !== this._state && (this._stack = e2), e2;
  } finally {
    me$1 = false;
  }
} }, timeout: function(e2, t3) {
  return e2 < 1 / 0 ? new Ce((n2, r2) => {
    var s2 = setTimeout(() => r2(new X$2.Timeout(t3)), e2);
    this.then(n2, r2).finally(clearTimeout.bind(null, s2));
  }) : this;
} }), "undefined" != typeof Symbol && Symbol.toStringTag && l$2(Ce.prototype, Symbol.toStringTag, "Dexie.Promise"), Pe.env = it$1(), a$3(Ce, { all: function() {
  var e2 = B$1.apply(null, arguments).map(tt$1);
  return new Ce(function(t3, n2) {
    0 === e2.length && t3([]);
    var r2 = e2.length;
    e2.forEach((s2, i2) => Ce.resolve(s2).then((n3) => {
      e2[i2] = n3, --r2 || t3(e2);
    }, n2));
  });
}, resolve: (e2) => {
  if (e2 instanceof Ce)
    return e2;
  if (e2 && "function" == typeof e2.then)
    return new Ce((t4, n2) => {
      e2.then(t4, n2);
    });
  var t3 = new Ce(le$2, true, e2);
  return Ne$1(t3, ke), t3;
}, reject: Ve, race: function() {
  var e2 = B$1.apply(null, arguments).map(tt$1);
  return new Ce((t3, n2) => {
    e2.map((e3) => Ce.resolve(e3).then(t3, n2));
  });
}, PSD: { get: () => Ke, set: (e2) => Ke = e2 }, totalEchoes: { get: () => Qe }, newPSD: Je, usePSD: ot$1, scheduler: { get: () => ge$2, set: (e2) => {
  ge$2 = e2;
} }, rejectionMapper: { get: () => Ee$1, set: (e2) => {
  Ee$1 = e2;
} }, follow: (e2, t3) => new Ce((n2, r2) => Je((t4, n3) => {
  var r3 = Ke;
  r3.unhandleds = [], r3.onunhandled = n3, r3.finalize = re$2(function() {
    !function(e3) {
      function t5() {
        e3(), Ae$1.splice(Ae$1.indexOf(t5), 1);
      }
      Ae$1.push(t5), ++Se$1, ge$2(() => {
        0 == --Se$1 && Le$1();
      }, []);
    }(() => {
      0 === this.unhandleds.length ? t4() : n3(this.unhandleds[0]);
    });
  }, r3.finalize), e2();
}, t3, n2, r2)) }), pe$2 && (pe$2.allSettled && l$2(Ce, "allSettled", function() {
  const e2 = B$1.apply(null, arguments).map(tt$1);
  return new Ce((t3) => {
    0 === e2.length && t3([]);
    let n2 = e2.length;
    const r2 = new Array(n2);
    e2.forEach((e3, s2) => Ce.resolve(e3).then((e4) => r2[s2] = { status: "fulfilled", value: e4 }, (e4) => r2[s2] = { status: "rejected", reason: e4 }).then(() => --n2 || t3(r2)));
  });
}), pe$2.any && "undefined" != typeof AggregateError && l$2(Ce, "any", function() {
  const e2 = B$1.apply(null, arguments).map(tt$1);
  return new Ce((t3, n2) => {
    0 === e2.length && n2(new AggregateError([]));
    let r2 = e2.length;
    const s2 = new Array(r2);
    e2.forEach((e3, i2) => Ce.resolve(e3).then((e4) => t3(e4), (e4) => {
      s2[i2] = e4, --r2 || n2(new AggregateError(s2));
    }));
  });
}));
const Ye = { awaits: 0, echoes: 0, id: 0 };
var ze = 0, Ge = [], He = 0, Qe = 0, Xe = 0;
function Je(e2, t3, n2, s2) {
  var i2 = Ke, o2 = Object.create(i2);
  o2.parent = i2, o2.ref = 0, o2.global = false, o2.id = ++Xe;
  var a2 = Pe.env;
  o2.env = ye$2 ? { Promise: Ce, PromiseProp: { value: Ce, configurable: true, writable: true }, all: Ce.all, race: Ce.race, allSettled: Ce.allSettled, any: Ce.any, resolve: Ce.resolve, reject: Ce.reject, nthen: lt$1(a2.nthen, o2), gthen: lt$1(a2.gthen, o2) } : {}, t3 && r(o2, t3), ++i2.ref, o2.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var u2 = ot$1(o2, e2, n2, s2);
  return 0 === o2.ref && o2.finalize(), u2;
}
function Ze() {
  return Ye.id || (Ye.id = ++ze), ++Ye.awaits, Ye.echoes += 100, Ye.id;
}
function et$2() {
  return !!Ye.awaits && (0 == --Ye.awaits && (Ye.id = 0), Ye.echoes = 100 * Ye.awaits, true);
}
function tt$1(e2) {
  return Ye.echoes && e2 && e2.constructor === pe$2 ? (Ze(), e2.then((e3) => (et$2(), e3), (e3) => (et$2(), ht$1(e3)))) : e2;
}
function nt$1(e2) {
  ++Qe, Ye.echoes && 0 != --Ye.echoes || (Ye.echoes = Ye.id = 0), Ge.push(Ke), st$1(e2, true);
}
function rt$1() {
  var e2 = Ge[Ge.length - 1];
  Ge.pop(), st$1(e2, false);
}
function st$1(t3, n2) {
  var r2 = Ke;
  if ((n2 ? !Ye.echoes || He++ && t3 === Ke : !He || --He && t3 === Ke) || at$1(n2 ? nt$1.bind(null, t3) : rt$1), t3 !== Ke && (Ke = t3, r2 === Pe && (Pe.env = it$1()), ye$2)) {
    var s2 = Pe.env.Promise, i2 = t3.env;
    he$2.then = i2.nthen, s2.prototype.then = i2.gthen, (r2.global || t3.global) && (Object.defineProperty(e$2, "Promise", i2.PromiseProp), s2.all = i2.all, s2.race = i2.race, s2.resolve = i2.resolve, s2.reject = i2.reject, i2.allSettled && (s2.allSettled = i2.allSettled), i2.any && (s2.any = i2.any));
  }
}
function it$1() {
  var t3 = e$2.Promise;
  return ye$2 ? { Promise: t3, PromiseProp: Object.getOwnPropertyDescriptor(e$2, "Promise"), all: t3.all, race: t3.race, allSettled: t3.allSettled, any: t3.any, resolve: t3.resolve, reject: t3.reject, nthen: he$2.then, gthen: t3.prototype.then } : {};
}
function ot$1(e2, t3, n2, r2, s2) {
  var i2 = Ke;
  try {
    return st$1(e2, true), t3(n2, r2, s2);
  } finally {
    st$1(i2, false);
  }
}
function at$1(e2) {
  fe$2.call(ce$1, e2);
}
function ut$1(e2, t3, n2, r2) {
  return "function" != typeof e2 ? e2 : function() {
    var s2 = Ke;
    n2 && Ze(), st$1(t3, true);
    try {
      return e2.apply(this, arguments);
    } finally {
      st$1(s2, false), r2 && at$1(et$2);
    }
  };
}
function lt$1(e2, t3) {
  return function(n2, r2) {
    return e2.call(this, ut$1(n2, t3), ut$1(r2, t3));
  };
}
-1 === ("" + fe$2).indexOf("[native code]") && (Ze = et$2 = ee$2);
function ct$1(t3, n2) {
  var s2;
  try {
    s2 = n2.onuncatched(t3);
  } catch (e2) {
  }
  if (false !== s2)
    try {
      var i2, o2 = { promise: n2, reason: t3 };
      if (e$2.document && document.createEvent ? ((i2 = document.createEvent("Event")).initEvent("unhandledrejection", true, true), r(i2, o2)) : e$2.CustomEvent && r(i2 = new CustomEvent("unhandledrejection", { detail: o2 }), o2), i2 && e$2.dispatchEvent && (dispatchEvent(i2), !e$2.PromiseRejectionEvent && e$2.onunhandledrejection))
        try {
          e$2.onunhandledrejection(i2);
        } catch (e2) {
        }
      R$1 && i2 && !i2.defaultPrevented && console.warn(`Unhandled rejection: ${t3.stack || t3}`);
    } catch (e2) {
    }
}
var ht$1 = Ce.reject;
function dt$1(e2, t3, n2, r2) {
  if (e2.idbdb && (e2._state.openComplete || Ke.letThrough || e2._vip)) {
    var s2 = e2._createTransaction(t3, n2, e2._dbSchema);
    try {
      s2.create(), e2._state.PR1398_maxLoop = 3;
    } catch (s3) {
      return s3.name === H$1.InvalidState && e2.isOpen() && --e2._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e2._close(), e2.open().then(() => dt$1(e2, t3, n2, r2))) : ht$1(s3);
    }
    return s2._promise(t3, (e3, t4) => Je(() => (Ke.trans = s2, r2(e3, t4, s2)))).then((e3) => s2._completion.then(() => e3));
  }
  if (e2._state.openComplete)
    return ht$1(new X$2.DatabaseClosed(e2._state.dbOpenError));
  if (!e2._state.isBeingOpened) {
    if (!e2._options.autoOpen)
      return ht$1(new X$2.DatabaseClosed());
    e2.open().catch(ee$2);
  }
  return e2._state.dbReadyPromise.then(() => dt$1(e2, t3, n2, r2));
}
const ft$1 = String.fromCharCode(65535), pt$1 = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", yt$1 = [], mt$1 = "undefined" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent), vt$1 = mt$1, gt$1 = mt$1, bt$1 = (e2) => !/(dexie\.js|dexie\.min\.js)/.test(e2);
function _t$2(e2, t3) {
  return e2 ? t3 ? function() {
    return e2.apply(this, arguments) && t3.apply(this, arguments);
  } : e2 : t3;
}
const wt$1 = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };
function xt$1(e2) {
  return "string" != typeof e2 || /\./.test(e2) ? (e3) => e3 : (t3) => (void 0 === t3[e2] && e2 in t3 && delete (t3 = O$2(t3))[e2], t3);
}
function kt$1() {
  throw X$2.Type();
}
let Et$1 = class Et {
  _trans(e2, t3, n2) {
    const r2 = this._tx || Ke.trans, s2 = this.name;
    function i2(e3, n3, r3) {
      if (!r3.schema[s2])
        throw new X$2.NotFound("Table " + s2 + " not part of transaction");
      return t3(r3.idbtrans, r3);
    }
    const o2 = $e();
    try {
      return r2 && r2.db === this.db ? r2 === Ke.trans ? r2._promise(e2, i2, n2) : Je(() => r2._promise(e2, i2, n2), { trans: r2, transless: Ke.transless || Ke }) : dt$1(this.db, e2, [this.name], i2);
    } finally {
      o2 && Ue();
    }
  }
  get(e2, t3) {
    return e2 && e2.constructor === Object ? this.where(e2).first(t3) : this._trans("readonly", (t4) => this.core.get({ trans: t4, key: e2 }).then((e3) => this.hook.reading.fire(e3))).then(t3);
  }
  where(e2) {
    if ("string" == typeof e2)
      return new this.db.WhereClause(this, e2);
    if (n$3(e2))
      return new this.db.WhereClause(this, `[${e2.join("+")}]`);
    const r2 = t$1(e2);
    if (1 === r2.length)
      return this.where(r2[0]).equals(e2[r2[0]]);
    const s2 = this.schema.indexes.concat(this.schema.primKey).filter((e3) => e3.compound && r2.every((t3) => e3.keyPath.indexOf(t3) >= 0) && e3.keyPath.every((e4) => r2.indexOf(e4) >= 0))[0];
    if (s2 && this.db._maxKey !== ft$1)
      return this.where(s2.name).equals(s2.keyPath.map((t3) => e2[t3]));
    !s2 && R$1 && console.warn(`The query ${JSON.stringify(e2)} on ${this.name} would benefit of a compound index [${r2.join("+")}]`);
    const { idxByName: i2 } = this.schema, o2 = this.db._deps.indexedDB;
    function a2(e3, t3) {
      try {
        return 0 === o2.cmp(e3, t3);
      } catch (e4) {
        return false;
      }
    }
    const [u2, l2] = r2.reduce(([t3, r3], s3) => {
      const o3 = i2[s3], u3 = e2[s3];
      return [t3 || o3, t3 || !o3 ? _t$2(r3, o3 && o3.multi ? (e3) => {
        const t4 = b$2(e3, s3);
        return n$3(t4) && t4.some((e4) => a2(u3, e4));
      } : (e3) => a2(u3, b$2(e3, s3))) : r3];
    }, [null, null]);
    return u2 ? this.where(u2.name).equals(e2[u2.keyPath]).filter(l2) : s2 ? this.filter(l2) : this.where(r2).equals("");
  }
  filter(e2) {
    return this.toCollection().and(e2);
  }
  count(e2) {
    return this.toCollection().count(e2);
  }
  offset(e2) {
    return this.toCollection().offset(e2);
  }
  limit(e2) {
    return this.toCollection().limit(e2);
  }
  each(e2) {
    return this.toCollection().each(e2);
  }
  toArray(e2) {
    return this.toCollection().toArray(e2);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(e2) {
    return new this.db.Collection(new this.db.WhereClause(this, n$3(e2) ? `[${e2.join("+")}]` : e2));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(e2) {
    const { db: t3, name: n2 } = this;
    this.schema.mappedClass = e2, e2.prototype instanceof kt$1 && (e2 = class extends e2 {
      get db() {
        return t3;
      }
      table() {
        return n2;
      }
    });
    const r2 = /* @__PURE__ */ new Set();
    for (let t4 = e2.prototype; t4; t4 = s$2(t4))
      Object.getOwnPropertyNames(t4).forEach((e3) => r2.add(e3));
    const i2 = (t4) => {
      if (!t4)
        return t4;
      const n3 = Object.create(e2.prototype);
      for (let e3 in t4)
        if (!r2.has(e3))
          try {
            n3[e3] = t4[e3];
          } catch (e4) {
          }
      return n3;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = i2, this.hook("reading", i2), e2;
  }
  defineClass() {
    return this.mapToClass(function(e2) {
      r(this, e2);
    });
  }
  add(e2, t3) {
    const { auto: n2, keyPath: r2 } = this.schema.primKey;
    let s2 = e2;
    return r2 && n2 && (s2 = xt$1(r2)(e2)), this._trans("readwrite", (e3) => this.core.mutate({ trans: e3, type: "add", keys: null != t3 ? [t3] : null, values: [s2] })).then((e3) => e3.numFailures ? Ce.reject(e3.failures[0]) : e3.lastResult).then((t4) => {
      if (r2)
        try {
          _$3(e2, r2, t4);
        } catch (e3) {
        }
      return t4;
    });
  }
  update(e2, r2) {
    if ("object" != typeof e2 || n$3(e2))
      return this.where(":id").equals(e2).modify(r2);
    {
      const n2 = b$2(e2, this.schema.primKey.keyPath);
      if (void 0 === n2)
        return ht$1(new X$2.InvalidArgument("Given object does not contain its primary key"));
      try {
        "function" != typeof r2 ? t$1(r2).forEach((t3) => {
          _$3(e2, t3, r2[t3]);
        }) : r2(e2, { value: e2, primKey: n2 });
      } catch (e3) {
      }
      return this.where(":id").equals(n2).modify(r2);
    }
  }
  put(e2, t3) {
    const { auto: n2, keyPath: r2 } = this.schema.primKey;
    let s2 = e2;
    return r2 && n2 && (s2 = xt$1(r2)(e2)), this._trans("readwrite", (e3) => this.core.mutate({ trans: e3, type: "put", values: [s2], keys: null != t3 ? [t3] : null })).then((e3) => e3.numFailures ? Ce.reject(e3.failures[0]) : e3.lastResult).then((t4) => {
      if (r2)
        try {
          _$3(e2, r2, t4);
        } catch (e3) {
        }
      return t4;
    });
  }
  delete(e2) {
    return this._trans("readwrite", (t3) => this.core.mutate({ trans: t3, type: "delete", keys: [e2] })).then((e3) => e3.numFailures ? Ce.reject(e3.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (e2) => this.core.mutate({ trans: e2, type: "deleteRange", range: wt$1 })).then((e2) => e2.numFailures ? Ce.reject(e2.failures[0]) : void 0);
  }
  bulkGet(e2) {
    return this._trans("readonly", (t3) => this.core.getMany({ keys: e2, trans: t3 }).then((e3) => e3.map((e4) => this.hook.reading.fire(e4))));
  }
  bulkAdd(e2, t3, n2) {
    const r2 = Array.isArray(t3) ? t3 : void 0, s2 = (n2 = n2 || (r2 ? void 0 : t3)) ? n2.allKeys : void 0;
    return this._trans("readwrite", (t4) => {
      const { auto: n3, keyPath: i2 } = this.schema.primKey;
      if (i2 && r2)
        throw new X$2.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (r2 && r2.length !== e2.length)
        throw new X$2.InvalidArgument("Arguments objects and keys must have the same length");
      const o2 = e2.length;
      let a2 = i2 && n3 ? e2.map(xt$1(i2)) : e2;
      return this.core.mutate({ trans: t4, type: "add", keys: r2, values: a2, wantResults: s2 }).then(({ numFailures: e3, results: t5, lastResult: n4, failures: r3 }) => {
        if (0 === e3)
          return s2 ? t5 : n4;
        throw new G$2(`${this.name}.bulkAdd(): ${e3} of ${o2} operations failed`, r3);
      });
    });
  }
  bulkPut(e2, t3, n2) {
    const r2 = Array.isArray(t3) ? t3 : void 0, s2 = (n2 = n2 || (r2 ? void 0 : t3)) ? n2.allKeys : void 0;
    return this._trans("readwrite", (t4) => {
      const { auto: n3, keyPath: i2 } = this.schema.primKey;
      if (i2 && r2)
        throw new X$2.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (r2 && r2.length !== e2.length)
        throw new X$2.InvalidArgument("Arguments objects and keys must have the same length");
      const o2 = e2.length;
      let a2 = i2 && n3 ? e2.map(xt$1(i2)) : e2;
      return this.core.mutate({ trans: t4, type: "put", keys: r2, values: a2, wantResults: s2 }).then(({ numFailures: e3, results: t5, lastResult: n4, failures: r3 }) => {
        if (0 === e3)
          return s2 ? t5 : n4;
        throw new G$2(`${this.name}.bulkPut(): ${e3} of ${o2} operations failed`, r3);
      });
    });
  }
  bulkDelete(e2) {
    const t3 = e2.length;
    return this._trans("readwrite", (t4) => this.core.mutate({ trans: t4, type: "delete", keys: e2 })).then(({ numFailures: e3, lastResult: n2, failures: r2 }) => {
      if (0 === e3)
        return n2;
      throw new G$2(`${this.name}.bulkDelete(): ${e3} of ${t3} operations failed`, r2);
    });
  }
};
function Pt$1(e2) {
  var r2 = {}, s2 = function(t3, n2) {
    if (n2) {
      for (var s3 = arguments.length, i3 = new Array(s3 - 1); --s3; )
        i3[s3 - 1] = arguments[s3];
      return r2[t3].subscribe.apply(null, i3), e2;
    }
    if ("string" == typeof t3)
      return r2[t3];
  };
  s2.addEventType = a2;
  for (var i2 = 1, o2 = arguments.length; i2 < o2; ++i2)
    a2(arguments[i2]);
  return s2;
  function a2(e3, t3, n2) {
    if ("object" == typeof e3)
      return u2(e3);
    t3 || (t3 = ae$1), n2 || (n2 = ee$2);
    var i3 = { subscribers: [], fire: n2, subscribe: function(e4) {
      -1 === i3.subscribers.indexOf(e4) && (i3.subscribers.push(e4), i3.fire = t3(i3.fire, e4));
    }, unsubscribe: function(e4) {
      i3.subscribers = i3.subscribers.filter(function(t4) {
        return t4 !== e4;
      }), i3.fire = i3.subscribers.reduce(t3, n2);
    } };
    return r2[e3] = s2[e3] = i3, i3;
  }
  function u2(e3) {
    t$1(e3).forEach(function(t3) {
      var r3 = e3[t3];
      if (n$3(r3))
        a2(t3, e3[t3][0], e3[t3][1]);
      else {
        if ("asap" !== r3)
          throw new X$2.InvalidArgument("Invalid event config");
        var s3 = a2(t3, te$1, function() {
          for (var e4 = arguments.length, t4 = new Array(e4); e4--; )
            t4[e4] = arguments[e4];
          s3.subscribers.forEach(function(e5) {
            v$2(function() {
              e5.apply(null, t4);
            });
          });
        });
      }
    });
  }
}
function Kt$1(e2, t3) {
  return c$2(t3).from({ prototype: e2 }), t3;
}
function Ot$1(e2, t3) {
  return !(e2.filter || e2.algorithm || e2.or) && (t3 ? e2.justLimit : !e2.replayFilter);
}
function St(e2, t3) {
  e2.filter = _t$2(e2.filter, t3);
}
function At$1(e2, t3, n2) {
  var r2 = e2.replayFilter;
  e2.replayFilter = r2 ? () => _t$2(r2(), t3()) : t3, e2.justLimit = n2 && !r2;
}
function Ct$1(e2, t3) {
  if (e2.isPrimKey)
    return t3.primaryKey;
  const n2 = t3.getIndexByKeyPath(e2.index);
  if (!n2)
    throw new X$2.Schema("KeyPath " + e2.index + " on object store " + t3.name + " is not indexed");
  return n2;
}
function jt$1(e2, t3, n2) {
  const r2 = Ct$1(e2, t3.schema);
  return t3.openCursor({ trans: n2, values: !e2.keysOnly, reverse: "prev" === e2.dir, unique: !!e2.unique, query: { index: r2, range: e2.range } });
}
function Dt$1(e2, t3, n2, r2) {
  const s2 = e2.replayFilter ? _t$2(e2.filter, e2.replayFilter()) : e2.filter;
  if (e2.or) {
    const i2 = {}, a2 = (e3, n3, r3) => {
      if (!s2 || s2(n3, r3, (e4) => n3.stop(e4), (e4) => n3.fail(e4))) {
        var a3 = n3.primaryKey, u2 = "" + a3;
        "[object ArrayBuffer]" === u2 && (u2 = "" + new Uint8Array(a3)), o$2(i2, u2) || (i2[u2] = true, t3(e3, n3, r3));
      }
    };
    return Promise.all([e2.or._iterate(a2, n2), It$1(jt$1(e2, r2, n2), e2.algorithm, a2, !e2.keysOnly && e2.valueMapper)]);
  }
  return It$1(jt$1(e2, r2, n2), _t$2(e2.algorithm, s2), t3, !e2.keysOnly && e2.valueMapper);
}
function It$1(e2, t3, n2, r2) {
  var s2 = We(r2 ? (e3, t4, s3) => n2(r2(e3), t4, s3) : n2);
  return e2.then((e3) => {
    if (e3)
      return e3.start(() => {
        var n3 = () => e3.continue();
        t3 && !t3(e3, (e4) => n3 = e4, (t4) => {
          e3.stop(t4), n3 = ee$2;
        }, (t4) => {
          e3.fail(t4), n3 = ee$2;
        }) || s2(e3.value, e3, (e4) => n3 = e4), n3();
      });
  });
}
function Bt$1(e2, t3) {
  try {
    const n2 = Tt$1(e2), r2 = Tt$1(t3);
    if (n2 !== r2)
      return "Array" === n2 ? 1 : "Array" === r2 ? -1 : "binary" === n2 ? 1 : "binary" === r2 ? -1 : "string" === n2 ? 1 : "string" === r2 ? -1 : "Date" === n2 ? 1 : "Date" !== r2 ? NaN : -1;
    switch (n2) {
      case "number":
      case "Date":
      case "string":
        return e2 > t3 ? 1 : e2 < t3 ? -1 : 0;
      case "binary":
        return function(e3, t4) {
          const n3 = e3.length, r3 = t4.length, s2 = n3 < r3 ? n3 : r3;
          for (let n4 = 0; n4 < s2; ++n4)
            if (e3[n4] !== t4[n4])
              return e3[n4] < t4[n4] ? -1 : 1;
          return n3 === r3 ? 0 : n3 < r3 ? -1 : 1;
        }(Rt$1(e2), Rt$1(t3));
      case "Array":
        return function(e3, t4) {
          const n3 = e3.length, r3 = t4.length, s2 = n3 < r3 ? n3 : r3;
          for (let n4 = 0; n4 < s2; ++n4) {
            const r4 = Bt$1(e3[n4], t4[n4]);
            if (0 !== r4)
              return r4;
          }
          return n3 === r3 ? 0 : n3 < r3 ? -1 : 1;
        }(e2, t3);
    }
  } catch (e3) {
  }
  return NaN;
}
function Tt$1(e2) {
  const t3 = typeof e2;
  if ("object" !== t3)
    return t3;
  if (ArrayBuffer.isView(e2))
    return "binary";
  const n2 = C$1(e2);
  return "ArrayBuffer" === n2 ? "binary" : n2;
}
function Rt$1(e2) {
  return e2 instanceof Uint8Array ? e2 : ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength) : new Uint8Array(e2);
}
let Ft$1 = class Ft {
  _read(e2, t3) {
    var n2 = this._ctx;
    return n2.error ? n2.table._trans(null, ht$1.bind(null, n2.error)) : n2.table._trans("readonly", e2).then(t3);
  }
  _write(e2) {
    var t3 = this._ctx;
    return t3.error ? t3.table._trans(null, ht$1.bind(null, t3.error)) : t3.table._trans("readwrite", e2, "locked");
  }
  _addAlgorithm(e2) {
    var t3 = this._ctx;
    t3.algorithm = _t$2(t3.algorithm, e2);
  }
  _iterate(e2, t3) {
    return Dt$1(this._ctx, e2, t3, this._ctx.table.core);
  }
  clone(e2) {
    var t3 = Object.create(this.constructor.prototype), n2 = Object.create(this._ctx);
    return e2 && r(n2, e2), t3._ctx = n2, t3;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(e2) {
    var t3 = this._ctx;
    return this._read((n2) => Dt$1(t3, e2, n2, t3.table.core));
  }
  count(e2) {
    return this._read((e3) => {
      const t3 = this._ctx, n2 = t3.table.core;
      if (Ot$1(t3, true))
        return n2.count({ trans: e3, query: { index: Ct$1(t3, n2.schema), range: t3.range } }).then((e4) => Math.min(e4, t3.limit));
      var r2 = 0;
      return Dt$1(t3, () => (++r2, false), e3, n2).then(() => r2);
    }).then(e2);
  }
  sortBy(e2, t3) {
    const n2 = e2.split(".").reverse(), r2 = n2[0], s2 = n2.length - 1;
    function i2(e3, t4) {
      return t4 ? i2(e3[n2[t4]], t4 - 1) : e3[r2];
    }
    var o2 = "next" === this._ctx.dir ? 1 : -1;
    function a2(e3, t4) {
      var n3 = i2(e3, s2), r3 = i2(t4, s2);
      return n3 < r3 ? -o2 : n3 > r3 ? o2 : 0;
    }
    return this.toArray(function(e3) {
      return e3.sort(a2);
    }).then(t3);
  }
  toArray(e2) {
    return this._read((e3) => {
      var t3 = this._ctx;
      if ("next" === t3.dir && Ot$1(t3, true) && t3.limit > 0) {
        const { valueMapper: n2 } = t3, r2 = Ct$1(t3, t3.table.core.schema);
        return t3.table.core.query({ trans: e3, limit: t3.limit, values: true, query: { index: r2, range: t3.range } }).then(({ result: e4 }) => n2 ? e4.map(n2) : e4);
      }
      {
        const n2 = [];
        return Dt$1(t3, (e4) => n2.push(e4), e3, t3.table.core).then(() => n2);
      }
    }, e2);
  }
  offset(e2) {
    var t3 = this._ctx;
    return e2 <= 0 || (t3.offset += e2, Ot$1(t3) ? At$1(t3, () => {
      var t4 = e2;
      return (e3, n2) => 0 === t4 || (1 === t4 ? (--t4, false) : (n2(() => {
        e3.advance(t4), t4 = 0;
      }), false));
    }) : At$1(t3, () => {
      var t4 = e2;
      return () => --t4 < 0;
    })), this;
  }
  limit(e2) {
    return this._ctx.limit = Math.min(this._ctx.limit, e2), At$1(this._ctx, () => {
      var t3 = e2;
      return function(e3, n2, r2) {
        return --t3 <= 0 && n2(r2), t3 >= 0;
      };
    }, true), this;
  }
  until(e2, t3) {
    return St(this._ctx, function(n2, r2, s2) {
      return !e2(n2.value) || (r2(s2), t3);
    }), this;
  }
  first(e2) {
    return this.limit(1).toArray(function(e3) {
      return e3[0];
    }).then(e2);
  }
  last(e2) {
    return this.reverse().first(e2);
  }
  filter(e2) {
    var t3, n2;
    return St(this._ctx, function(t4) {
      return e2(t4.value);
    }), t3 = this._ctx, n2 = e2, t3.isMatch = _t$2(t3.isMatch, n2), this;
  }
  and(e2) {
    return this.filter(e2);
  }
  or(e2) {
    return new this.db.WhereClause(this._ctx.table, e2, this);
  }
  reverse() {
    return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(e2) {
    var t3 = this._ctx;
    return t3.keysOnly = !t3.isMatch, this.each(function(t4, n2) {
      e2(n2.key, n2);
    });
  }
  eachUniqueKey(e2) {
    return this._ctx.unique = "unique", this.eachKey(e2);
  }
  eachPrimaryKey(e2) {
    var t3 = this._ctx;
    return t3.keysOnly = !t3.isMatch, this.each(function(t4, n2) {
      e2(n2.primaryKey, n2);
    });
  }
  keys(e2) {
    var t3 = this._ctx;
    t3.keysOnly = !t3.isMatch;
    var n2 = [];
    return this.each(function(e3, t4) {
      n2.push(t4.key);
    }).then(function() {
      return n2;
    }).then(e2);
  }
  primaryKeys(e2) {
    var t3 = this._ctx;
    if ("next" === t3.dir && Ot$1(t3, true) && t3.limit > 0)
      return this._read((e3) => {
        var n3 = Ct$1(t3, t3.table.core.schema);
        return t3.table.core.query({ trans: e3, values: false, limit: t3.limit, query: { index: n3, range: t3.range } });
      }).then(({ result: e3 }) => e3).then(e2);
    t3.keysOnly = !t3.isMatch;
    var n2 = [];
    return this.each(function(e3, t4) {
      n2.push(t4.primaryKey);
    }).then(function() {
      return n2;
    }).then(e2);
  }
  uniqueKeys(e2) {
    return this._ctx.unique = "unique", this.keys(e2);
  }
  firstKey(e2) {
    return this.limit(1).keys(function(e3) {
      return e3[0];
    }).then(e2);
  }
  lastKey(e2) {
    return this.reverse().firstKey(e2);
  }
  distinct() {
    var e2 = this._ctx, t3 = e2.index && e2.table.schema.idxByName[e2.index];
    if (!t3 || !t3.multi)
      return this;
    var n2 = {};
    return St(this._ctx, function(e3) {
      var t4 = e3.primaryKey.toString(), r2 = o$2(n2, t4);
      return n2[t4] = true, !r2;
    }), this;
  }
  modify(e2) {
    var n2 = this._ctx;
    return this._write((r2) => {
      var s2;
      if ("function" == typeof e2)
        s2 = e2;
      else {
        var i2 = t$1(e2), o2 = i2.length;
        s2 = function(t3) {
          for (var n3 = false, r3 = 0; r3 < o2; ++r3) {
            var s3 = i2[r3], a3 = e2[s3];
            b$2(t3, s3) !== a3 && (_$3(t3, s3, a3), n3 = true);
          }
          return n3;
        };
      }
      const a2 = n2.table.core, { outbound: u2, extractKey: l2 } = a2.schema.primaryKey, c2 = this.db._options.modifyChunkSize || 200, h2 = [];
      let d2 = 0;
      const f2 = [], p2 = (e3, n3) => {
        const { failures: r3, numFailures: s3 } = n3;
        d2 += e3 - s3;
        for (let e4 of t$1(r3))
          h2.push(r3[e4]);
      };
      return this.clone().primaryKeys().then((t3) => {
        const i3 = (o3) => {
          const h3 = Math.min(c2, t3.length - o3);
          return a2.getMany({ trans: r2, keys: t3.slice(o3, o3 + h3), cache: "immutable" }).then((d3) => {
            const f3 = [], y2 = [], m2 = u2 ? [] : null, v2 = [];
            for (let e3 = 0; e3 < h3; ++e3) {
              const n3 = d3[e3], r3 = { value: O$2(n3), primKey: t3[o3 + e3] };
              false !== s2.call(r3, r3.value, r3) && (null == r3.value ? v2.push(t3[o3 + e3]) : u2 || 0 === Bt$1(l2(n3), l2(r3.value)) ? (y2.push(r3.value), u2 && m2.push(t3[o3 + e3])) : (v2.push(t3[o3 + e3]), f3.push(r3.value)));
            }
            const g2 = Ot$1(n2) && n2.limit === 1 / 0 && ("function" != typeof e2 || e2 === Mt$1) && { index: n2.index, range: n2.range };
            return Promise.resolve(f3.length > 0 && a2.mutate({ trans: r2, type: "add", values: f3 }).then((e3) => {
              for (let t4 in e3.failures)
                v2.splice(parseInt(t4), 1);
              p2(f3.length, e3);
            })).then(() => (y2.length > 0 || g2 && "object" == typeof e2) && a2.mutate({ trans: r2, type: "put", keys: m2, values: y2, criteria: g2, changeSpec: "function" != typeof e2 && e2 }).then((e3) => p2(y2.length, e3))).then(() => (v2.length > 0 || g2 && e2 === Mt$1) && a2.mutate({ trans: r2, type: "delete", keys: v2, criteria: g2 }).then((e3) => p2(v2.length, e3))).then(() => t3.length > o3 + h3 && i3(o3 + c2));
          });
        };
        return i3(0).then(() => {
          if (h2.length > 0)
            throw new z$2("Error modifying one or more objects", h2, d2, f2);
          return t3.length;
        });
      });
    });
  }
  delete() {
    var e2 = this._ctx, t3 = e2.range;
    return Ot$1(e2) && (e2.isPrimKey && !gt$1 || 3 === t3.type) ? this._write((n2) => {
      const { primaryKey: r2 } = e2.table.core.schema, s2 = t3;
      return e2.table.core.count({ trans: n2, query: { index: r2, range: s2 } }).then((t4) => e2.table.core.mutate({ trans: n2, type: "deleteRange", range: s2 }).then(({ failures: e3, lastResult: n3, results: r3, numFailures: s3 }) => {
        if (s3)
          throw new z$2("Could not delete some values", Object.keys(e3).map((t5) => e3[t5]), t4 - s3);
        return t4 - s3;
      }));
    }) : this.modify(Mt$1);
  }
};
const Mt$1 = (e2, t3) => t3.value = null;
function Nt$1(e2, t3) {
  return e2 < t3 ? -1 : e2 === t3 ? 0 : 1;
}
function qt$1(e2, t3) {
  return e2 > t3 ? -1 : e2 === t3 ? 0 : 1;
}
function $t$1(e2, t3, n2) {
  var r2 = e2 instanceof zt$1 ? new e2.Collection(e2) : e2;
  return r2._ctx.error = n2 ? new n2(t3) : new TypeError(t3), r2;
}
function Ut$1(e2) {
  return new e2.Collection(e2, () => Yt$1("")).limit(0);
}
function Lt$1(e2, t3, n2, r2, s2, i2) {
  for (var o2 = Math.min(e2.length, r2.length), a2 = -1, u2 = 0; u2 < o2; ++u2) {
    var l2 = t3[u2];
    if (l2 !== r2[u2])
      return s2(e2[u2], n2[u2]) < 0 ? e2.substr(0, u2) + n2[u2] + n2.substr(u2 + 1) : s2(e2[u2], r2[u2]) < 0 ? e2.substr(0, u2) + r2[u2] + n2.substr(u2 + 1) : a2 >= 0 ? e2.substr(0, a2) + t3[a2] + n2.substr(a2 + 1) : null;
    s2(e2[u2], l2) < 0 && (a2 = u2);
  }
  return o2 < r2.length && "next" === i2 ? e2 + n2.substr(e2.length) : o2 < e2.length && "prev" === i2 ? e2.substr(0, n2.length) : a2 < 0 ? null : e2.substr(0, a2) + r2[a2] + n2.substr(a2 + 1);
}
function Vt$1(e2, t3, n2, r2) {
  var s2, i2, o2, a2, u2, l2, c2, h2 = n2.length;
  if (!n2.every((e3) => "string" == typeof e3))
    return $t$1(e2, "String expected.");
  function d2(e3) {
    s2 = function(e4) {
      return "next" === e4 ? (e5) => e5.toUpperCase() : (e5) => e5.toLowerCase();
    }(e3), i2 = function(e4) {
      return "next" === e4 ? (e5) => e5.toLowerCase() : (e5) => e5.toUpperCase();
    }(e3), o2 = "next" === e3 ? Nt$1 : qt$1;
    var t4 = n2.map(function(e4) {
      return { lower: i2(e4), upper: s2(e4) };
    }).sort(function(e4, t5) {
      return o2(e4.lower, t5.lower);
    });
    a2 = t4.map(function(e4) {
      return e4.upper;
    }), u2 = t4.map(function(e4) {
      return e4.lower;
    }), l2 = e3, c2 = "next" === e3 ? "" : r2;
  }
  d2("next");
  var f2 = new e2.Collection(e2, () => Wt$1(a2[0], u2[h2 - 1] + r2));
  f2._ondirectionchange = function(e3) {
    d2(e3);
  };
  var p2 = 0;
  return f2._addAlgorithm(function(e3, n3, r3) {
    var s3 = e3.key;
    if ("string" != typeof s3)
      return false;
    var d3 = i2(s3);
    if (t3(d3, u2, p2))
      return true;
    for (var f3 = null, y2 = p2; y2 < h2; ++y2) {
      var m2 = Lt$1(s3, d3, a2[y2], u2[y2], o2, l2);
      null === m2 && null === f3 ? p2 = y2 + 1 : (null === f3 || o2(f3, m2) > 0) && (f3 = m2);
    }
    return n3(null !== f3 ? function() {
      e3.continue(f3 + c2);
    } : r3), false;
  }), f2;
}
function Wt$1(e2, t3, n2, r2) {
  return { type: 2, lower: e2, upper: t3, lowerOpen: n2, upperOpen: r2 };
}
function Yt$1(e2) {
  return { type: 1, lower: e2, upper: e2 };
}
let zt$1 = class zt {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(e2, t3, n2, r2) {
    n2 = false !== n2, r2 = true === r2;
    try {
      return this._cmp(e2, t3) > 0 || 0 === this._cmp(e2, t3) && (n2 || r2) && (!n2 || !r2) ? Ut$1(this) : new this.Collection(this, () => Wt$1(e2, t3, !n2, !r2));
    } catch (e3) {
      return $t$1(this, pt$1);
    }
  }
  equals(e2) {
    return null == e2 ? $t$1(this, pt$1) : new this.Collection(this, () => Yt$1(e2));
  }
  above(e2) {
    return null == e2 ? $t$1(this, pt$1) : new this.Collection(this, () => Wt$1(e2, void 0, true));
  }
  aboveOrEqual(e2) {
    return null == e2 ? $t$1(this, pt$1) : new this.Collection(this, () => Wt$1(e2, void 0, false));
  }
  below(e2) {
    return null == e2 ? $t$1(this, pt$1) : new this.Collection(this, () => Wt$1(void 0, e2, false, true));
  }
  belowOrEqual(e2) {
    return null == e2 ? $t$1(this, pt$1) : new this.Collection(this, () => Wt$1(void 0, e2));
  }
  startsWith(e2) {
    return "string" != typeof e2 ? $t$1(this, "String expected.") : this.between(e2, e2 + ft$1, true, true);
  }
  startsWithIgnoreCase(e2) {
    return "" === e2 ? this.startsWith(e2) : Vt$1(this, (e3, t3) => 0 === e3.indexOf(t3[0]), [e2], ft$1);
  }
  equalsIgnoreCase(e2) {
    return Vt$1(this, (e3, t3) => e3 === t3[0], [e2], "");
  }
  anyOfIgnoreCase() {
    var e2 = B$1.apply(I$2, arguments);
    return 0 === e2.length ? Ut$1(this) : Vt$1(this, (e3, t3) => -1 !== t3.indexOf(e3), e2, "");
  }
  startsWithAnyOfIgnoreCase() {
    var e2 = B$1.apply(I$2, arguments);
    return 0 === e2.length ? Ut$1(this) : Vt$1(this, (e3, t3) => t3.some((t4) => 0 === e3.indexOf(t4)), e2, ft$1);
  }
  anyOf() {
    const e2 = B$1.apply(I$2, arguments);
    let t3 = this._cmp;
    try {
      e2.sort(t3);
    } catch (e3) {
      return $t$1(this, pt$1);
    }
    if (0 === e2.length)
      return Ut$1(this);
    const n2 = new this.Collection(this, () => Wt$1(e2[0], e2[e2.length - 1]));
    n2._ondirectionchange = (n3) => {
      t3 = "next" === n3 ? this._ascending : this._descending, e2.sort(t3);
    };
    let r2 = 0;
    return n2._addAlgorithm((n3, s2, i2) => {
      const o2 = n3.key;
      for (; t3(o2, e2[r2]) > 0; )
        if (++r2, r2 === e2.length)
          return s2(i2), false;
      return 0 === t3(o2, e2[r2]) || (s2(() => {
        n3.continue(e2[r2]);
      }), false);
    }), n2;
  }
  notEqual(e2) {
    return this.inAnyRange([[-(1 / 0), e2], [e2, this.db._maxKey]], { includeLowers: false, includeUppers: false });
  }
  noneOf() {
    const e2 = B$1.apply(I$2, arguments);
    if (0 === e2.length)
      return new this.Collection(this);
    try {
      e2.sort(this._ascending);
    } catch (e3) {
      return $t$1(this, pt$1);
    }
    const t3 = e2.reduce((e3, t4) => e3 ? e3.concat([[e3[e3.length - 1][1], t4]]) : [[-(1 / 0), t4]], null);
    return t3.push([e2[e2.length - 1], this.db._maxKey]), this.inAnyRange(t3, { includeLowers: false, includeUppers: false });
  }
  inAnyRange(e2, t3) {
    const n2 = this._cmp, r2 = this._ascending, s2 = this._descending, i2 = this._min, o2 = this._max;
    if (0 === e2.length)
      return Ut$1(this);
    if (!e2.every((e3) => void 0 !== e3[0] && void 0 !== e3[1] && r2(e3[0], e3[1]) <= 0))
      return $t$1(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", X$2.InvalidArgument);
    const a2 = !t3 || false !== t3.includeLowers, u2 = t3 && true === t3.includeUppers;
    let l2, c2 = r2;
    function h2(e3, t4) {
      return c2(e3[0], t4[0]);
    }
    try {
      l2 = e2.reduce(function(e3, t4) {
        let r3 = 0, s3 = e3.length;
        for (; r3 < s3; ++r3) {
          const s4 = e3[r3];
          if (n2(t4[0], s4[1]) < 0 && n2(t4[1], s4[0]) > 0) {
            s4[0] = i2(s4[0], t4[0]), s4[1] = o2(s4[1], t4[1]);
            break;
          }
        }
        return r3 === s3 && e3.push(t4), e3;
      }, []), l2.sort(h2);
    } catch (e3) {
      return $t$1(this, pt$1);
    }
    let d2 = 0;
    const f2 = u2 ? (e3) => r2(e3, l2[d2][1]) > 0 : (e3) => r2(e3, l2[d2][1]) >= 0, p2 = a2 ? (e3) => s2(e3, l2[d2][0]) > 0 : (e3) => s2(e3, l2[d2][0]) >= 0;
    let y2 = f2;
    const m2 = new this.Collection(this, () => Wt$1(l2[0][0], l2[l2.length - 1][1], !a2, !u2));
    return m2._ondirectionchange = (e3) => {
      "next" === e3 ? (y2 = f2, c2 = r2) : (y2 = p2, c2 = s2), l2.sort(h2);
    }, m2._addAlgorithm((e3, t4, n3) => {
      for (var s3 = e3.key; y2(s3); )
        if (++d2, d2 === l2.length)
          return t4(n3), false;
      return !!function(e4) {
        return !f2(e4) && !p2(e4);
      }(s3) || (0 === this._cmp(s3, l2[d2][1]) || 0 === this._cmp(s3, l2[d2][0]) || t4(() => {
        c2 === r2 ? e3.continue(l2[d2][0]) : e3.continue(l2[d2][1]);
      }), false);
    }), m2;
  }
  startsWithAnyOf() {
    const e2 = B$1.apply(I$2, arguments);
    return e2.every((e3) => "string" == typeof e3) ? 0 === e2.length ? Ut$1(this) : this.inAnyRange(e2.map((e3) => [e3, e3 + ft$1])) : $t$1(this, "startsWithAnyOf() only works with strings");
  }
};
function Gt$1(e2) {
  return We(function(t3) {
    return Ht$1(t3), e2(t3.target.error), false;
  });
}
function Ht$1(e2) {
  e2.stopPropagation && e2.stopPropagation(), e2.preventDefault && e2.preventDefault();
}
const Qt$1 = Pt$1(null, "storagemutated");
let Xt$1 = class Xt {
  _lock() {
    return m$2(!Ke.global), ++this._reculock, 1 !== this._reculock || Ke.global || (Ke.lockOwnerFor = this), this;
  }
  _unlock() {
    if (m$2(!Ke.global), 0 == --this._reculock)
      for (Ke.global || (Ke.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var e2 = this._blockedFuncs.shift();
        try {
          ot$1(e2[1], e2[0]);
        } catch (e3) {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && Ke.lockOwnerFor !== this;
  }
  create(e2) {
    if (!this.mode)
      return this;
    const t3 = this.db.idbdb, n2 = this.db._state.dbOpenError;
    if (m$2(!this.idbtrans), !e2 && !t3)
      switch (n2 && n2.name) {
        case "DatabaseClosedError":
          throw new X$2.DatabaseClosed(n2);
        case "MissingAPIError":
          throw new X$2.MissingAPI(n2.message, n2);
        default:
          throw new X$2.OpenFailed(n2);
      }
    if (!this.active)
      throw new X$2.TransactionInactive();
    return m$2(null === this._completion._state), (e2 = this.idbtrans = e2 || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : t3.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = We((t4) => {
      Ht$1(t4), this._reject(e2.error);
    }), e2.onabort = We((t4) => {
      Ht$1(t4), this.active && this._reject(new X$2.Abort(e2.error)), this.active = false, this.on("abort").fire(t4);
    }), e2.oncomplete = We(() => {
      this.active = false, this._resolve(), "mutatedParts" in e2 && Qt$1.storagemutated.fire(e2.mutatedParts);
    }), this;
  }
  _promise(e2, t3, n2) {
    if ("readwrite" === e2 && "readwrite" !== this.mode)
      return ht$1(new X$2.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return ht$1(new X$2.TransactionInactive());
    if (this._locked())
      return new Ce((r3, s2) => {
        this._blockedFuncs.push([() => {
          this._promise(e2, t3, n2).then(r3, s2);
        }, Ke]);
      });
    if (n2)
      return Je(() => {
        var e3 = new Ce((e4, n3) => {
          this._lock();
          const r3 = t3(e4, n3, this);
          r3 && r3.then && r3.then(e4, n3);
        });
        return e3.finally(() => this._unlock()), e3._lib = true, e3;
      });
    var r2 = new Ce((e3, n3) => {
      var r3 = t3(e3, n3, this);
      r3 && r3.then && r3.then(e3, n3);
    });
    return r2._lib = true, r2;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(e2) {
    var t3 = this._root();
    const n2 = Ce.resolve(e2);
    if (t3._waitingFor)
      t3._waitingFor = t3._waitingFor.then(() => n2);
    else {
      t3._waitingFor = n2, t3._waitingQueue = [];
      var r2 = t3.idbtrans.objectStore(t3.storeNames[0]);
      !function e3() {
        for (++t3._spinCount; t3._waitingQueue.length; )
          t3._waitingQueue.shift()();
        t3._waitingFor && (r2.get(-1 / 0).onsuccess = e3);
      }();
    }
    var s2 = t3._waitingFor;
    return new Ce((e3, r3) => {
      n2.then((n3) => t3._waitingQueue.push(We(e3.bind(null, n3))), (e4) => t3._waitingQueue.push(We(r3.bind(null, e4)))).finally(() => {
        t3._waitingFor === s2 && (t3._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new X$2.Abort()));
  }
  table(e2) {
    const t3 = this._memoizedTables || (this._memoizedTables = {});
    if (o$2(t3, e2))
      return t3[e2];
    const n2 = this.schema[e2];
    if (!n2)
      throw new X$2.NotFound("Table " + e2 + " not part of transaction");
    const r2 = new this.db.Table(e2, n2, this);
    return r2.core = this.db.core.table(e2), t3[e2] = r2, r2;
  }
};
function Jt$1(e2, t3, n2, r2, s2, i2, o2) {
  return { name: e2, keyPath: t3, unique: n2, multi: r2, auto: s2, compound: i2, src: (n2 && !o2 ? "&" : "") + (r2 ? "*" : "") + (s2 ? "++" : "") + Zt$1(t3) };
}
function Zt$1(e2) {
  return "string" == typeof e2 ? e2 : e2 ? "[" + [].join.call(e2, "+") + "]" : "";
}
function en(e2, t3, n2) {
  return { name: e2, primKey: t3, indexes: n2, mappedClass: null, idxByName: g$2(n2, (e3) => [e3.name, e3]) };
}
let tn = (e2) => {
  try {
    return e2.only([[]]), tn = () => [[]], [[]];
  } catch (e3) {
    return tn = () => ft$1, ft$1;
  }
};
function nn(e2) {
  return null == e2 ? () => {
  } : "string" == typeof e2 ? function(e3) {
    return 1 === e3.split(".").length ? (t3) => t3[e3] : (t3) => b$2(t3, e3);
  }(e2) : (t3) => b$2(t3, e2);
}
function rn(e2) {
  return [].slice.call(e2);
}
let sn = 0;
function on(e2) {
  return null == e2 ? ":id" : "string" == typeof e2 ? e2 : `[${e2.join("+")}]`;
}
function an(e2, t3, r2) {
  function s2(e3) {
    if (3 === e3.type)
      return null;
    if (4 === e3.type)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: n2, upper: r3, lowerOpen: s3, upperOpen: i3 } = e3;
    return void 0 === n2 ? void 0 === r3 ? null : t3.upperBound(r3, !!i3) : void 0 === r3 ? t3.lowerBound(n2, !!s3) : t3.bound(n2, r3, !!s3, !!i3);
  }
  const { schema: i2, hasGetAll: o2 } = function(e3, t4) {
    const r3 = rn(e3.objectStoreNames);
    return { schema: { name: e3.name, tables: r3.map((e4) => t4.objectStore(e4)).map((e4) => {
      const { keyPath: t5, autoIncrement: r4 } = e4, s3 = n$3(t5), i3 = null == t5, o3 = {}, a3 = { name: e4.name, primaryKey: { name: null, isPrimaryKey: true, outbound: i3, compound: s3, keyPath: t5, autoIncrement: r4, unique: true, extractKey: nn(t5) }, indexes: rn(e4.indexNames).map((t6) => e4.index(t6)).map((e5) => {
        const { name: t6, unique: r5, multiEntry: s4, keyPath: i4 } = e5, a4 = { name: t6, compound: n$3(i4), keyPath: i4, unique: r5, multiEntry: s4, extractKey: nn(i4) };
        return o3[on(i4)] = a4, a4;
      }), getIndexByKeyPath: (e5) => o3[on(e5)] };
      return o3[":id"] = a3.primaryKey, null != t5 && (o3[on(t5)] = a3.primaryKey), a3;
    }) }, hasGetAll: r3.length > 0 && "getAll" in t4.objectStore(r3[0]) && !("undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(e2, r2), a2 = i2.tables.map((e3) => function(e4) {
    const t4 = e4.name;
    return { name: t4, schema: e4, mutate: function({ trans: e5, type: n2, keys: r3, values: i3, range: o3 }) {
      return new Promise((a3, u3) => {
        a3 = We(a3);
        const l2 = e5.objectStore(t4), c2 = null == l2.keyPath, h2 = "put" === n2 || "add" === n2;
        if (!h2 && "delete" !== n2 && "deleteRange" !== n2)
          throw new Error("Invalid operation type: " + n2);
        const { length: d2 } = r3 || i3 || { length: 1 };
        if (r3 && i3 && r3.length !== i3.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (0 === d2)
          return a3({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let f2;
        const p2 = [], y2 = [];
        let m2 = 0;
        const v2 = (e6) => {
          ++m2, Ht$1(e6);
        };
        if ("deleteRange" === n2) {
          if (4 === o3.type)
            return a3({ numFailures: m2, failures: y2, results: [], lastResult: void 0 });
          3 === o3.type ? p2.push(f2 = l2.clear()) : p2.push(f2 = l2.delete(s2(o3)));
        } else {
          const [e6, t5] = h2 ? c2 ? [i3, r3] : [i3, null] : [r3, null];
          if (h2)
            for (let r4 = 0; r4 < d2; ++r4)
              p2.push(f2 = t5 && void 0 !== t5[r4] ? l2[n2](e6[r4], t5[r4]) : l2[n2](e6[r4])), f2.onerror = v2;
          else
            for (let t6 = 0; t6 < d2; ++t6)
              p2.push(f2 = l2[n2](e6[t6])), f2.onerror = v2;
        }
        const g2 = (e6) => {
          const t5 = e6.target.result;
          p2.forEach((e7, t6) => null != e7.error && (y2[t6] = e7.error)), a3({ numFailures: m2, failures: y2, results: "delete" === n2 ? r3 : p2.map((e7) => e7.result), lastResult: t5 });
        };
        f2.onerror = (e6) => {
          v2(e6), g2(e6);
        }, f2.onsuccess = g2;
      });
    }, getMany: ({ trans: e5, keys: n2 }) => new Promise((r3, s3) => {
      r3 = We(r3);
      const i3 = e5.objectStore(t4), o3 = n2.length, a3 = new Array(o3);
      let u3, l2 = 0, c2 = 0;
      const h2 = (e6) => {
        const t5 = e6.target;
        a3[t5._pos] = t5.result, ++c2 === l2 && r3(a3);
      }, d2 = Gt$1(s3);
      for (let e6 = 0; e6 < o3; ++e6)
        null != n2[e6] && (u3 = i3.get(n2[e6]), u3._pos = e6, u3.onsuccess = h2, u3.onerror = d2, ++l2);
      0 === l2 && r3(a3);
    }), get: ({ trans: e5, key: n2 }) => new Promise((r3, s3) => {
      r3 = We(r3);
      const i3 = e5.objectStore(t4).get(n2);
      i3.onsuccess = (e6) => r3(e6.target.result), i3.onerror = Gt$1(s3);
    }), query: function(e5) {
      return (n2) => new Promise((r3, i3) => {
        r3 = We(r3);
        const { trans: o3, values: a3, limit: u3, query: l2 } = n2, c2 = u3 === 1 / 0 ? void 0 : u3, { index: h2, range: d2 } = l2, f2 = o3.objectStore(t4), p2 = h2.isPrimaryKey ? f2 : f2.index(h2.name), y2 = s2(d2);
        if (0 === u3)
          return r3({ result: [] });
        if (e5) {
          const e6 = a3 ? p2.getAll(y2, c2) : p2.getAllKeys(y2, c2);
          e6.onsuccess = (e7) => r3({ result: e7.target.result }), e6.onerror = Gt$1(i3);
        } else {
          let e6 = 0;
          const t5 = a3 || !("openKeyCursor" in p2) ? p2.openCursor(y2) : p2.openKeyCursor(y2), n3 = [];
          t5.onsuccess = (s3) => {
            const i4 = t5.result;
            return i4 ? (n3.push(a3 ? i4.value : i4.primaryKey), ++e6 === u3 ? r3({ result: n3 }) : void i4.continue()) : r3({ result: n3 });
          }, t5.onerror = Gt$1(i3);
        }
      });
    }(o2), openCursor: function({ trans: e5, values: n2, query: r3, reverse: i3, unique: o3 }) {
      return new Promise((a3, u3) => {
        a3 = We(a3);
        const { index: l2, range: c2 } = r3, h2 = e5.objectStore(t4), d2 = l2.isPrimaryKey ? h2 : h2.index(l2.name), f2 = i3 ? o3 ? "prevunique" : "prev" : o3 ? "nextunique" : "next", p2 = n2 || !("openKeyCursor" in d2) ? d2.openCursor(s2(c2), f2) : d2.openKeyCursor(s2(c2), f2);
        p2.onerror = Gt$1(u3), p2.onsuccess = We((t5) => {
          const n3 = p2.result;
          if (!n3)
            return void a3(null);
          n3.___id = ++sn, n3.done = false;
          const r4 = n3.continue.bind(n3);
          let s3 = n3.continuePrimaryKey;
          s3 && (s3 = s3.bind(n3));
          const i4 = n3.advance.bind(n3), o4 = () => {
            throw new Error("Cursor not stopped");
          };
          n3.trans = e5, n3.stop = n3.continue = n3.continuePrimaryKey = n3.advance = () => {
            throw new Error("Cursor not started");
          }, n3.fail = We(u3), n3.next = function() {
            let e6 = 1;
            return this.start(() => e6-- ? this.continue() : this.stop()).then(() => this);
          }, n3.start = (e6) => {
            const t6 = new Promise((e7, t7) => {
              e7 = We(e7), p2.onerror = Gt$1(t7), n3.fail = t7, n3.stop = (t8) => {
                n3.stop = n3.continue = n3.continuePrimaryKey = n3.advance = o4, e7(t8);
              };
            }), a4 = () => {
              if (p2.result)
                try {
                  e6();
                } catch (e7) {
                  n3.fail(e7);
                }
              else
                n3.done = true, n3.start = () => {
                  throw new Error("Cursor behind last entry");
                }, n3.stop();
            };
            return p2.onsuccess = We((e7) => {
              p2.onsuccess = a4, a4();
            }), n3.continue = r4, n3.continuePrimaryKey = s3, n3.advance = i4, a4(), t6;
          }, a3(n3);
        }, u3);
      });
    }, count({ query: e5, trans: n2 }) {
      const { index: r3, range: i3 } = e5;
      return new Promise((e6, o3) => {
        const a3 = n2.objectStore(t4), u3 = r3.isPrimaryKey ? a3 : a3.index(r3.name), l2 = s2(i3), c2 = l2 ? u3.count(l2) : u3.count();
        c2.onsuccess = We((t5) => e6(t5.target.result)), c2.onerror = Gt$1(o3);
      });
    } };
  }(e3)), u2 = {};
  return a2.forEach((e3) => u2[e3.name] = e3), { stack: "dbcore", transaction: e2.transaction.bind(e2), table(e3) {
    if (!u2[e3])
      throw new Error(`Table '${e3}' not found`);
    return u2[e3];
  }, MIN_KEY: -1 / 0, MAX_KEY: tn(t3), schema: i2 };
}
function un({ _novip: e2 }, t3) {
  const n2 = t3.db, r2 = function(e3, t4, { IDBKeyRange: n3, indexedDB: r3 }, s2) {
    const i2 = function(e4, t5) {
      return t5.reduce((e5, { create: t6 }) => ({ ...e5, ...t6(e5) }), e4);
    }(an(t4, n3, s2), e3.dbcore);
    return { dbcore: i2 };
  }(e2._middlewares, n2, e2._deps, t3);
  e2.core = r2.dbcore, e2.tables.forEach((t4) => {
    const n3 = t4.name;
    e2.core.schema.tables.some((e3) => e3.name === n3) && (t4.core = e2.core.table(n3), e2[n3] instanceof e2.Table && (e2[n3].core = t4.core));
  });
}
function ln$1({ _novip: e2 }, t3, n2, r2) {
  n2.forEach((n3) => {
    const s2 = r2[n3];
    t3.forEach((t4) => {
      const r3 = d$2(t4, n3);
      (!r3 || "value" in r3 && void 0 === r3.value) && (t4 === e2.Transaction.prototype || t4 instanceof e2.Transaction ? l$2(t4, n3, { get() {
        return this.table(n3);
      }, set(e3) {
        u$4(this, n3, { value: e3, writable: true, configurable: true, enumerable: true });
      } }) : t4[n3] = new e2.Table(n3, s2));
    });
  });
}
function cn({ _novip: e2 }, t3) {
  t3.forEach((t4) => {
    for (let n2 in t4)
      t4[n2] instanceof e2.Table && delete t4[n2];
  });
}
function hn(e2, t3) {
  return e2._cfg.version - t3._cfg.version;
}
function dn(e2, n2, r2, s2) {
  const i2 = e2._dbSchema, o2 = e2._createTransaction("readwrite", e2._storeNames, i2);
  o2.create(r2), o2._completion.catch(s2);
  const a2 = o2._reject.bind(o2), u2 = Ke.transless || Ke;
  Je(() => {
    Ke.trans = o2, Ke.transless = u2, 0 === n2 ? (t$1(i2).forEach((e3) => {
      pn(r2, e3, i2[e3].primKey, i2[e3].indexes);
    }), un(e2, r2), Ce.follow(() => e2.on.populate.fire(o2)).catch(a2)) : function({ _novip: e3 }, n3, r3, s3) {
      const i3 = [], o3 = e3._versions;
      let a3 = e3._dbSchema = mn(e3, e3.idbdb, s3), u3 = false;
      function l2() {
        return i3.length ? Ce.resolve(i3.shift()(r3.idbtrans)).then(l2) : Ce.resolve();
      }
      return o3.filter((e4) => e4._cfg.version >= n3).forEach((o4) => {
        i3.push(() => {
          const i4 = a3, l3 = o4._cfg.dbschema;
          vn(e3, i4, s3), vn(e3, l3, s3), a3 = e3._dbSchema = l3;
          const c2 = fn2(i4, l3);
          c2.add.forEach((e4) => {
            pn(s3, e4[0], e4[1].primKey, e4[1].indexes);
          }), c2.change.forEach((e4) => {
            if (e4.recreate)
              throw new X$2.Upgrade("Not yet support for changing primary key");
            {
              const t3 = s3.objectStore(e4.name);
              e4.add.forEach((e5) => yn(t3, e5)), e4.change.forEach((e5) => {
                t3.deleteIndex(e5.name), yn(t3, e5);
              }), e4.del.forEach((e5) => t3.deleteIndex(e5));
            }
          });
          const h2 = o4._cfg.contentUpgrade;
          if (h2 && o4._cfg.version > n3) {
            un(e3, s3), r3._memoizedTables = {}, u3 = true;
            let n4 = w$2(l3);
            c2.del.forEach((e4) => {
              n4[e4] = i4[e4];
            }), cn(e3, [e3.Transaction.prototype]), ln$1(e3, [e3.Transaction.prototype], t$1(n4), n4), r3.schema = n4;
            const o5 = T$3(h2);
            let a4;
            o5 && Ze();
            const d2 = Ce.follow(() => {
              if (a4 = h2(r3), a4 && o5) {
                var e4 = et$2.bind(null, null);
                a4.then(e4, e4);
              }
            });
            return a4 && "function" == typeof a4.then ? Ce.resolve(a4) : d2.then(() => a4);
          }
        }), i3.push((t3) => {
          if (!u3 || !vt$1) {
            !function(e4, t4) {
              [].slice.call(t4.db.objectStoreNames).forEach((n4) => null == e4[n4] && t4.db.deleteObjectStore(n4));
            }(o4._cfg.dbschema, t3);
          }
          cn(e3, [e3.Transaction.prototype]), ln$1(e3, [e3.Transaction.prototype], e3._storeNames, e3._dbSchema), r3.schema = e3._dbSchema;
        });
      }), l2().then(() => {
        var e4, n4;
        n4 = s3, t$1(e4 = a3).forEach((t3) => {
          n4.db.objectStoreNames.contains(t3) || pn(n4, t3, e4[t3].primKey, e4[t3].indexes);
        });
      });
    }(e2, n2, o2, r2).catch(a2);
  });
}
function fn2(e2, t3) {
  const n2 = { del: [], add: [], change: [] };
  let r2;
  for (r2 in e2)
    t3[r2] || n2.del.push(r2);
  for (r2 in t3) {
    const s2 = e2[r2], i2 = t3[r2];
    if (s2) {
      const e3 = { name: r2, def: i2, recreate: false, del: [], add: [], change: [] };
      if ("" + (s2.primKey.keyPath || "") != "" + (i2.primKey.keyPath || "") || s2.primKey.auto !== i2.primKey.auto && !mt$1)
        e3.recreate = true, n2.change.push(e3);
      else {
        const t4 = s2.idxByName, r3 = i2.idxByName;
        let o2;
        for (o2 in t4)
          r3[o2] || e3.del.push(o2);
        for (o2 in r3) {
          const n3 = t4[o2], s3 = r3[o2];
          n3 ? n3.src !== s3.src && e3.change.push(s3) : e3.add.push(s3);
        }
        (e3.del.length > 0 || e3.add.length > 0 || e3.change.length > 0) && n2.change.push(e3);
      }
    } else
      n2.add.push([r2, i2]);
  }
  return n2;
}
function pn(e2, t3, n2, r2) {
  const s2 = e2.db.createObjectStore(t3, n2.keyPath ? { keyPath: n2.keyPath, autoIncrement: n2.auto } : { autoIncrement: n2.auto });
  return r2.forEach((e3) => yn(s2, e3)), s2;
}
function yn(e2, t3) {
  e2.createIndex(t3.name, t3.keyPath, { unique: t3.unique, multiEntry: t3.multi });
}
function mn(e2, t3, n2) {
  const r2 = {};
  return p$2(t3.objectStoreNames, 0).forEach((e3) => {
    const t4 = n2.objectStore(e3);
    let s2 = t4.keyPath;
    const i2 = Jt$1(Zt$1(s2), s2 || "", false, false, !!t4.autoIncrement, s2 && "string" != typeof s2, true), o2 = [];
    for (let e4 = 0; e4 < t4.indexNames.length; ++e4) {
      const n3 = t4.index(t4.indexNames[e4]);
      s2 = n3.keyPath;
      var a2 = Jt$1(n3.name, s2, !!n3.unique, !!n3.multiEntry, false, s2 && "string" != typeof s2, false);
      o2.push(a2);
    }
    r2[e3] = en(e3, i2, o2);
  }), r2;
}
function vn({ _novip: t3 }, n2, r2) {
  const s2 = r2.db.objectStoreNames;
  for (let e2 = 0; e2 < s2.length; ++e2) {
    const i2 = s2[e2], o2 = r2.objectStore(i2);
    t3._hasGetAll = "getAll" in o2;
    for (let e3 = 0; e3 < o2.indexNames.length; ++e3) {
      const t4 = o2.indexNames[e3], r3 = o2.index(t4).keyPath, s3 = "string" == typeof r3 ? r3 : "[" + p$2(r3).join("+") + "]";
      if (n2[i2]) {
        const e4 = n2[i2].idxByName[s3];
        e4 && (e4.name = t4, delete n2[i2].idxByName[s3], n2[i2].idxByName[t4] = e4);
      }
    }
  }
  "undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && e$2.WorkerGlobalScope && e$2 instanceof e$2.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (t3._hasGetAll = false);
}
class gn {
  _parseStoresSpec(e2, r2) {
    t$1(e2).forEach((t3) => {
      if (null !== e2[t3]) {
        var s2 = e2[t3].split(",").map((e3, t4) => {
          const r3 = (e3 = e3.trim()).replace(/([&*]|\+\+)/g, ""), s3 = /^\[/.test(r3) ? r3.match(/^\[(.*)\]$/)[1].split("+") : r3;
          return Jt$1(r3, s3 || null, /\&/.test(e3), /\*/.test(e3), /\+\+/.test(e3), n$3(s3), 0 === t4);
        }), i2 = s2.shift();
        if (i2.multi)
          throw new X$2.Schema("Primary key cannot be multi-valued");
        s2.forEach((e3) => {
          if (e3.auto)
            throw new X$2.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!e3.keyPath)
            throw new X$2.Schema("Index must have a name and cannot be an empty string");
        }), r2[t3] = en(t3, i2, s2);
      }
    });
  }
  stores(e2) {
    const n2 = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? r(this._cfg.storesSource, e2) : e2;
    const s2 = n2._versions, i2 = {};
    let o2 = {};
    return s2.forEach((e3) => {
      r(i2, e3._cfg.storesSource), o2 = e3._cfg.dbschema = {}, e3._parseStoresSpec(i2, o2);
    }), n2._dbSchema = o2, cn(n2, [n2._allTables, n2, n2.Transaction.prototype]), ln$1(n2, [n2._allTables, n2, n2.Transaction.prototype, this._cfg.tables], t$1(o2), o2), n2._storeNames = t$1(o2), this;
  }
  upgrade(e2) {
    return this._cfg.contentUpgrade = ue$2(this._cfg.contentUpgrade || ee$2, e2), this;
  }
}
function bn(e2, t3) {
  let n2 = e2._dbNamesDB;
  return n2 || (n2 = e2._dbNamesDB = new Un("__dbnames", { addons: [], indexedDB: e2, IDBKeyRange: t3 }), n2.version(1).stores({ dbnames: "name" })), n2.table("dbnames");
}
function _n(e2) {
  return e2 && "function" == typeof e2.databases;
}
function wn(e2) {
  return Je(function() {
    return Ke.letThrough = true, e2();
  });
}
function xn() {
  var e2;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(t3) {
    var n2 = function() {
      return indexedDB.databases().finally(t3);
    };
    e2 = setInterval(n2, 100), n2();
  }).finally(function() {
    return clearInterval(e2);
  }) : Promise.resolve();
}
function kn(e2) {
  const n2 = e2._state, { indexedDB: r2 } = e2._deps;
  if (n2.isBeingOpened || e2.idbdb)
    return n2.dbReadyPromise.then(() => n2.dbOpenError ? ht$1(n2.dbOpenError) : e2);
  R$1 && (n2.openCanceller._stackHolder = q$1()), n2.isBeingOpened = true, n2.dbOpenError = null, n2.openComplete = false;
  const s2 = n2.openCanceller;
  function i2() {
    if (n2.openCanceller !== s2)
      throw new X$2.DatabaseClosed("db.open() was cancelled");
  }
  let o2 = n2.dbReadyResolve, a2 = null, u2 = false;
  return Ce.race([s2, ("undefined" == typeof navigator ? Ce.resolve() : xn()).then(() => new Ce((s3, o3) => {
    if (i2(), !r2)
      throw new X$2.MissingAPI();
    const l2 = e2.name, c2 = n2.autoSchema ? r2.open(l2) : r2.open(l2, Math.round(10 * e2.verno));
    if (!c2)
      throw new X$2.MissingAPI();
    c2.onerror = Gt$1(o3), c2.onblocked = We(e2._fireOnBlocked), c2.onupgradeneeded = We((t3) => {
      if (a2 = c2.transaction, n2.autoSchema && !e2._options.allowEmptyDB) {
        c2.onerror = Ht$1, a2.abort(), c2.result.close();
        const e3 = r2.deleteDatabase(l2);
        e3.onsuccess = e3.onerror = We(() => {
          o3(new X$2.NoSuchDatabase(`Database ${l2} doesnt exist`));
        });
      } else {
        a2.onerror = Gt$1(o3);
        var s4 = t3.oldVersion > Math.pow(2, 62) ? 0 : t3.oldVersion;
        u2 = s4 < 1, e2._novip.idbdb = c2.result, dn(e2, s4 / 10, a2, o3);
      }
    }, o3), c2.onsuccess = We(() => {
      a2 = null;
      const r3 = e2._novip.idbdb = c2.result, i3 = p$2(r3.objectStoreNames);
      if (i3.length > 0)
        try {
          const s4 = r3.transaction(1 === (o4 = i3).length ? o4[0] : o4, "readonly");
          n2.autoSchema ? function({ _novip: e3 }, n3, r4) {
            e3.verno = n3.version / 10;
            const s5 = e3._dbSchema = mn(0, n3, r4);
            e3._storeNames = p$2(n3.objectStoreNames, 0), ln$1(e3, [e3._allTables], t$1(s5), s5);
          }(e2, r3, s4) : (vn(e2, e2._dbSchema, s4), function(e3, t3) {
            const n3 = fn2(mn(0, e3.idbdb, t3), e3._dbSchema);
            return !(n3.add.length || n3.change.some((e4) => e4.add.length || e4.change.length));
          }(e2, s4) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), un(e2, s4);
        } catch (e3) {
        }
      var o4;
      yt$1.push(e2), r3.onversionchange = We((t3) => {
        n2.vcFired = true, e2.on("versionchange").fire(t3);
      }), r3.onclose = We((t3) => {
        e2.on("close").fire(t3);
      }), u2 && function({ indexedDB: e3, IDBKeyRange: t3 }, n3) {
        !_n(e3) && "__dbnames" !== n3 && bn(e3, t3).put({ name: n3 }).catch(ee$2);
      }(e2._deps, l2), s3();
    }, o3);
  }))]).then(() => (i2(), n2.onReadyBeingFired = [], Ce.resolve(wn(() => e2.on.ready.fire(e2.vip))).then(function t3() {
    if (n2.onReadyBeingFired.length > 0) {
      let r3 = n2.onReadyBeingFired.reduce(ue$2, ee$2);
      return n2.onReadyBeingFired = [], Ce.resolve(wn(() => r3(e2.vip))).then(t3);
    }
  }))).finally(() => {
    n2.onReadyBeingFired = null, n2.isBeingOpened = false;
  }).then(() => e2).catch((t3) => {
    n2.dbOpenError = t3;
    try {
      a2 && a2.abort();
    } catch (e3) {
    }
    return s2 === n2.openCanceller && e2._close(), ht$1(t3);
  }).finally(() => {
    n2.openComplete = true, o2();
  });
}
function En(e2) {
  var t3 = (t4) => e2.next(t4), r2 = i2(t3), s2 = i2((t4) => e2.throw(t4));
  function i2(e3) {
    return (t4) => {
      var i3 = e3(t4), o2 = i3.value;
      return i3.done ? o2 : o2 && "function" == typeof o2.then ? o2.then(r2, s2) : n$3(o2) ? Promise.all(o2).then(r2, s2) : r2(o2);
    };
  }
  return i2(t3)();
}
function Pn(e2, t3, n2) {
  var r2 = arguments.length;
  if (r2 < 2)
    throw new X$2.InvalidArgument("Too few arguments");
  for (var s2 = new Array(r2 - 1); --r2; )
    s2[r2 - 1] = arguments[r2];
  n2 = s2.pop();
  var i2 = k$1(s2);
  return [e2, i2, n2];
}
function Kn(e2, t3, n2, r2, s2) {
  return Ce.resolve().then(() => {
    const i2 = Ke.transless || Ke, o2 = e2._createTransaction(t3, n2, e2._dbSchema, r2), a2 = { trans: o2, transless: i2 };
    if (r2)
      o2.idbtrans = r2.idbtrans;
    else
      try {
        o2.create(), e2._state.PR1398_maxLoop = 3;
      } catch (r3) {
        return r3.name === H$1.InvalidState && e2.isOpen() && --e2._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e2._close(), e2.open().then(() => Kn(e2, t3, n2, null, s2))) : ht$1(r3);
      }
    const u2 = T$3(s2);
    let l2;
    u2 && Ze();
    const c2 = Ce.follow(() => {
      if (l2 = s2.call(o2, o2), l2)
        if (u2) {
          var e3 = et$2.bind(null, null);
          l2.then(e3, e3);
        } else
          "function" == typeof l2.next && "function" == typeof l2.throw && (l2 = En(l2));
    }, a2);
    return (l2 && "function" == typeof l2.then ? Ce.resolve(l2).then((e3) => o2.active ? e3 : ht$1(new X$2.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : c2.then(() => l2)).then((e3) => (r2 && o2._resolve(), o2._completion.then(() => e3))).catch((e3) => (o2._reject(e3), ht$1(e3)));
  });
}
function On(e2, t3, r2) {
  const s2 = n$3(e2) ? e2.slice() : [e2];
  for (let e3 = 0; e3 < r2; ++e3)
    s2.push(t3);
  return s2;
}
const Sn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e2) {
  return { ...e2, table(t3) {
    const n2 = e2.table(t3), { schema: r2 } = n2, s2 = {}, i2 = [];
    function o2(e3, t4, n3) {
      const r3 = on(e3), a3 = s2[r3] = s2[r3] || [], u3 = null == e3 ? 0 : "string" == typeof e3 ? 1 : e3.length, l3 = t4 > 0, c2 = { ...n3, isVirtual: l3, keyTail: t4, keyLength: u3, extractKey: nn(e3), unique: !l3 && n3.unique };
      if (a3.push(c2), c2.isPrimaryKey || i2.push(c2), u3 > 1) {
        o2(2 === u3 ? e3[0] : e3.slice(0, u3 - 1), t4 + 1, n3);
      }
      return a3.sort((e4, t5) => e4.keyTail - t5.keyTail), c2;
    }
    const a2 = o2(r2.primaryKey.keyPath, 0, r2.primaryKey);
    s2[":id"] = [a2];
    for (const e3 of r2.indexes)
      o2(e3.keyPath, 0, e3);
    function u2(t4) {
      const n3 = t4.query.index;
      return n3.isVirtual ? { ...t4, query: { index: n3, range: (r3 = t4.query.range, s3 = n3.keyTail, { type: 1 === r3.type ? 2 : r3.type, lower: On(r3.lower, r3.lowerOpen ? e2.MAX_KEY : e2.MIN_KEY, s3), lowerOpen: true, upper: On(r3.upper, r3.upperOpen ? e2.MIN_KEY : e2.MAX_KEY, s3), upperOpen: true }) } } : t4;
      var r3, s3;
    }
    const l2 = { ...n2, schema: { ...r2, primaryKey: a2, indexes: i2, getIndexByKeyPath: function(e3) {
      const t4 = s2[on(e3)];
      return t4 && t4[0];
    } }, count: (e3) => n2.count(u2(e3)), query: (e3) => n2.query(u2(e3)), openCursor(t4) {
      const { keyTail: r3, isVirtual: s3, keyLength: i3 } = t4.query.index;
      if (!s3)
        return n2.openCursor(t4);
      return n2.openCursor(u2(t4)).then((n3) => n3 && function(n4) {
        const s4 = Object.create(n4, { continue: { value: function(s5) {
          null != s5 ? n4.continue(On(s5, t4.reverse ? e2.MAX_KEY : e2.MIN_KEY, r3)) : t4.unique ? n4.continue(n4.key.slice(0, i3).concat(t4.reverse ? e2.MIN_KEY : e2.MAX_KEY, r3)) : n4.continue();
        } }, continuePrimaryKey: { value(t5, s5) {
          n4.continuePrimaryKey(On(t5, e2.MAX_KEY, r3), s5);
        } }, primaryKey: { get: () => n4.primaryKey }, key: { get() {
          const e3 = n4.key;
          return 1 === i3 ? e3[0] : e3.slice(0, i3);
        } }, value: { get: () => n4.value } });
        return s4;
      }(n3));
    } };
    return l2;
  } };
} };
function An(e2, n2, r2, s2) {
  return r2 = r2 || {}, s2 = s2 || "", t$1(e2).forEach((t3) => {
    if (o$2(n2, t3)) {
      var i2 = e2[t3], a2 = n2[t3];
      if ("object" == typeof i2 && "object" == typeof a2 && i2 && a2) {
        const e3 = C$1(i2);
        e3 !== C$1(a2) ? r2[s2 + t3] = n2[t3] : "Object" === e3 ? An(i2, a2, r2, s2 + t3 + ".") : i2 !== a2 && (r2[s2 + t3] = n2[t3]);
      } else
        i2 !== a2 && (r2[s2 + t3] = n2[t3]);
    } else
      r2[s2 + t3] = void 0;
  }), t$1(n2).forEach((t3) => {
    o$2(e2, t3) || (r2[s2 + t3] = n2[t3]);
  }), r2;
}
const Cn = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (e2) => ({ ...e2, table(t3) {
  const n2 = e2.table(t3), { primaryKey: r2 } = n2.schema, s2 = { ...n2, mutate(e3) {
    const s3 = Ke.trans, { deleting: i2, creating: a2, updating: u2 } = s3.table(t3).hook;
    switch (e3.type) {
      case "add":
        if (a2.fire === ee$2)
          break;
        return s3._promise("readwrite", () => l2(e3), true);
      case "put":
        if (a2.fire === ee$2 && u2.fire === ee$2)
          break;
        return s3._promise("readwrite", () => l2(e3), true);
      case "delete":
        if (i2.fire === ee$2)
          break;
        return s3._promise("readwrite", () => l2(e3), true);
      case "deleteRange":
        if (i2.fire === ee$2)
          break;
        return s3._promise("readwrite", () => function(e4) {
          return c2(e4.trans, e4.range, 1e4);
        }(e3), true);
    }
    return n2.mutate(e3);
    function l2(e4) {
      const t4 = Ke.trans, s4 = e4.keys || function(e5, t5) {
        return "delete" === t5.type ? t5.keys : t5.keys || t5.values.map(e5.extractKey);
      }(r2, e4);
      if (!s4)
        throw new Error("Keys missing");
      return "delete" !== (e4 = "add" === e4.type || "put" === e4.type ? { ...e4, keys: s4 } : { ...e4 }).type && (e4.values = [...e4.values]), e4.keys && (e4.keys = [...e4.keys]), function(e5, t5, n3) {
        return "add" === t5.type ? Promise.resolve([]) : e5.getMany({ trans: t5.trans, keys: n3, cache: "immutable" });
      }(n2, e4, s4).then((l3) => {
        const c3 = s4.map((n3, s5) => {
          const c4 = l3[s5], h2 = { onerror: null, onsuccess: null };
          if ("delete" === e4.type)
            i2.fire.call(h2, n3, c4, t4);
          else if ("add" === e4.type || void 0 === c4) {
            const i3 = a2.fire.call(h2, n3, e4.values[s5], t4);
            null == n3 && null != i3 && (n3 = i3, e4.keys[s5] = n3, r2.outbound || _$3(e4.values[s5], r2.keyPath, n3));
          } else {
            const r3 = An(c4, e4.values[s5]), i3 = u2.fire.call(h2, r3, n3, c4, t4);
            if (i3) {
              const t5 = e4.values[s5];
              Object.keys(i3).forEach((e5) => {
                o$2(t5, e5) ? t5[e5] = i3[e5] : _$3(t5, e5, i3[e5]);
              });
            }
          }
          return h2;
        });
        return n2.mutate(e4).then(({ failures: t5, results: n3, numFailures: r3, lastResult: i3 }) => {
          for (let r4 = 0; r4 < s4.length; ++r4) {
            const i4 = n3 ? n3[r4] : s4[r4], o2 = c3[r4];
            null == i4 ? o2.onerror && o2.onerror(t5[r4]) : o2.onsuccess && o2.onsuccess("put" === e4.type && l3[r4] ? e4.values[r4] : i4);
          }
          return { failures: t5, results: n3, numFailures: r3, lastResult: i3 };
        }).catch((e5) => (c3.forEach((t5) => t5.onerror && t5.onerror(e5)), Promise.reject(e5)));
      });
    }
    function c2(e4, t4, s4) {
      return n2.query({ trans: e4, values: false, query: { index: r2, range: t4 }, limit: s4 }).then(({ result: n3 }) => l2({ type: "delete", keys: n3, trans: e4 }).then((r3) => r3.numFailures > 0 ? Promise.reject(r3.failures[0]) : n3.length < s4 ? { failures: [], numFailures: 0, lastResult: void 0 } : c2(e4, { ...t4, lower: n3[n3.length - 1], lowerOpen: true }, s4)));
    }
  } };
  return s2;
} }) };
function jn(e2, t3, n2) {
  try {
    if (!t3)
      return null;
    if (t3.keys.length < e2.length)
      return null;
    const r2 = [];
    for (let s2 = 0, i2 = 0; s2 < t3.keys.length && i2 < e2.length; ++s2)
      0 === Bt$1(t3.keys[s2], e2[i2]) && (r2.push(n2 ? O$2(t3.values[s2]) : t3.values[s2]), ++i2);
    return r2.length === e2.length ? r2 : null;
  } catch (e3) {
    return null;
  }
}
const Dn = { stack: "dbcore", level: -1, create: (e2) => ({ table: (t3) => {
  const n2 = e2.table(t3);
  return { ...n2, getMany: (e3) => {
    if (!e3.cache)
      return n2.getMany(e3);
    const t4 = jn(e3.keys, e3.trans._cache, "clone" === e3.cache);
    return t4 ? Ce.resolve(t4) : n2.getMany(e3).then((t5) => (e3.trans._cache = { keys: e3.keys, values: "clone" === e3.cache ? O$2(t5) : t5 }, t5));
  }, mutate: (e3) => ("add" !== e3.type && (e3.trans._cache = null), n2.mutate(e3)) };
} }) };
function In(e2) {
  return !("from" in e2);
}
const Bn = function(e2, t3) {
  if (!this) {
    const t4 = new Bn();
    return e2 && "d" in e2 && r(t4, e2), t4;
  }
  r(this, arguments.length ? { d: 1, from: e2, to: arguments.length > 1 ? t3 : e2 } : { d: 0 });
};
function Tn(e2, t3, n2) {
  const s2 = Bt$1(t3, n2);
  if (isNaN(s2))
    return;
  if (s2 > 0)
    throw RangeError();
  if (In(e2))
    return r(e2, { from: t3, to: n2, d: 1 });
  const i2 = e2.l, o2 = e2.r;
  if (Bt$1(n2, e2.from) < 0)
    return i2 ? Tn(i2, t3, n2) : e2.l = { from: t3, to: n2, d: 1, l: null, r: null }, Nn(e2);
  if (Bt$1(t3, e2.to) > 0)
    return o2 ? Tn(o2, t3, n2) : e2.r = { from: t3, to: n2, d: 1, l: null, r: null }, Nn(e2);
  Bt$1(t3, e2.from) < 0 && (e2.from = t3, e2.l = null, e2.d = o2 ? o2.d + 1 : 1), Bt$1(n2, e2.to) > 0 && (e2.to = n2, e2.r = null, e2.d = e2.l ? e2.l.d + 1 : 1);
  const a2 = !e2.r;
  i2 && !e2.l && Rn(e2, i2), o2 && a2 && Rn(e2, o2);
}
function Rn(e2, t3) {
  In(t3) || function e3(t4, { from: n2, to: r2, l: s2, r: i2 }) {
    Tn(t4, n2, r2), s2 && e3(t4, s2), i2 && e3(t4, i2);
  }(e2, t3);
}
function Fn(e2, t3) {
  const n2 = Mn(t3);
  let r2 = n2.next();
  if (r2.done)
    return false;
  let s2 = r2.value;
  const i2 = Mn(e2);
  let o2 = i2.next(s2.from), a2 = o2.value;
  for (; !r2.done && !o2.done; ) {
    if (Bt$1(a2.from, s2.to) <= 0 && Bt$1(a2.to, s2.from) >= 0)
      return true;
    Bt$1(s2.from, a2.from) < 0 ? s2 = (r2 = n2.next(a2.from)).value : a2 = (o2 = i2.next(s2.from)).value;
  }
  return false;
}
function Mn(e2) {
  let t3 = In(e2) ? null : { s: 0, n: e2 };
  return { next(e3) {
    const n2 = arguments.length > 0;
    for (; t3; )
      switch (t3.s) {
        case 0:
          if (t3.s = 1, n2)
            for (; t3.n.l && Bt$1(e3, t3.n.from) < 0; )
              t3 = { up: t3, n: t3.n.l, s: 1 };
          else
            for (; t3.n.l; )
              t3 = { up: t3, n: t3.n.l, s: 1 };
        case 1:
          if (t3.s = 2, !n2 || Bt$1(e3, t3.n.to) <= 0)
            return { value: t3.n, done: false };
        case 2:
          if (t3.n.r) {
            t3.s = 3, t3 = { up: t3, n: t3.n.r, s: 0 };
            continue;
          }
        case 3:
          t3 = t3.up;
      }
    return { done: true };
  } };
}
function Nn(e2) {
  var t3, n2;
  const r2 = ((null === (t3 = e2.r) || void 0 === t3 ? void 0 : t3.d) || 0) - ((null === (n2 = e2.l) || void 0 === n2 ? void 0 : n2.d) || 0), s2 = r2 > 1 ? "r" : r2 < -1 ? "l" : "";
  if (s2) {
    const t4 = "r" === s2 ? "l" : "r", n3 = { ...e2 }, r3 = e2[s2];
    e2.from = r3.from, e2.to = r3.to, e2[s2] = r3[s2], n3[s2] = r3[t4], e2[t4] = n3, n3.d = qn(n3);
  }
  e2.d = qn(e2);
}
function qn({ r: e2, l: t3 }) {
  return (e2 ? t3 ? Math.max(e2.d, t3.d) : e2.d : t3 ? t3.d : 0) + 1;
}
a$3(Bn.prototype, { add(e2) {
  return Rn(this, e2), this;
}, addKey(e2) {
  return Tn(this, e2, e2), this;
}, addKeys(e2) {
  return e2.forEach((e3) => Tn(this, e3, e3)), this;
}, [j$2]() {
  return Mn(this);
} });
const $n = { stack: "dbcore", level: 0, create: (e2) => {
  const r2 = e2.schema.name, s2 = new Bn(e2.MIN_KEY, e2.MAX_KEY);
  return { ...e2, table: (i2) => {
    const o2 = e2.table(i2), { schema: a2 } = o2, { primaryKey: u2 } = a2, { extractKey: l2, outbound: c2 } = u2, h2 = { ...o2, mutate: (e3) => {
      const t3 = e3.trans, u3 = t3.mutatedParts || (t3.mutatedParts = {}), l3 = (e4) => {
        const t4 = `idb://${r2}/${i2}/${e4}`;
        return u3[t4] || (u3[t4] = new Bn());
      }, c3 = l3(""), h3 = l3(":dels"), { type: d3 } = e3;
      let [f3, p2] = "deleteRange" === e3.type ? [e3.range] : "delete" === e3.type ? [e3.keys] : e3.values.length < 50 ? [[], e3.values] : [];
      const y2 = e3.trans._cache;
      return o2.mutate(e3).then((e4) => {
        if (n$3(f3)) {
          "delete" !== d3 && (f3 = e4.results), c3.addKeys(f3);
          const t4 = jn(f3, y2);
          t4 || "add" === d3 || h3.addKeys(f3), (t4 || p2) && function(e5, t5, r3, s3) {
            function i3(t6) {
              const i4 = e5(t6.name || "");
              function o3(e6) {
                return null != e6 ? t6.extractKey(e6) : null;
              }
              const a3 = (e6) => t6.multiEntry && n$3(e6) ? e6.forEach((e7) => i4.addKey(e7)) : i4.addKey(e6);
              (r3 || s3).forEach((e6, t7) => {
                const n2 = r3 && o3(r3[t7]), i5 = s3 && o3(s3[t7]);
                0 !== Bt$1(n2, i5) && (null != n2 && a3(n2), null != i5 && a3(i5));
              });
            }
            t5.indexes.forEach(i3);
          }(l3, a2, t4, p2);
        } else if (f3) {
          const e5 = { from: f3.lower, to: f3.upper };
          h3.add(e5), c3.add(e5);
        } else
          c3.add(s2), h3.add(s2), a2.indexes.forEach((e5) => l3(e5.name).add(s2));
        return e4;
      });
    } }, d2 = ({ query: { index: t3, range: n2 } }) => {
      var r3, s3;
      return [t3, new Bn(null !== (r3 = n2.lower) && void 0 !== r3 ? r3 : e2.MIN_KEY, null !== (s3 = n2.upper) && void 0 !== s3 ? s3 : e2.MAX_KEY)];
    }, f2 = { get: (e3) => [u2, new Bn(e3.key)], getMany: (e3) => [u2, new Bn().addKeys(e3.keys)], count: d2, query: d2, openCursor: d2 };
    return t$1(f2).forEach((e3) => {
      h2[e3] = function(t3) {
        const { subscr: n2 } = Ke;
        if (n2) {
          const a3 = (e4) => {
            const t4 = `idb://${r2}/${i2}/${e4}`;
            return n2[t4] || (n2[t4] = new Bn());
          }, u3 = a3(""), h3 = a3(":dels"), [d3, p2] = f2[e3](t3);
          if (a3(d3.name || "").add(p2), !d3.isPrimaryKey) {
            if ("count" !== e3) {
              const n3 = "query" === e3 && c2 && t3.values && o2.query({ ...t3, values: false });
              return o2[e3].apply(this, arguments).then((r3) => {
                if ("query" === e3) {
                  if (c2 && t3.values)
                    return n3.then(({ result: e5 }) => (u3.addKeys(e5), r3));
                  const e4 = t3.values ? r3.result.map(l2) : r3.result;
                  t3.values ? u3.addKeys(e4) : h3.addKeys(e4);
                } else if ("openCursor" === e3) {
                  const e4 = r3, n4 = t3.values;
                  return e4 && Object.create(e4, { key: { get: () => (h3.addKey(e4.primaryKey), e4.key) }, primaryKey: { get() {
                    const t4 = e4.primaryKey;
                    return h3.addKey(t4), t4;
                  } }, value: { get: () => (n4 && u3.addKey(e4.primaryKey), e4.value) } });
                }
                return r3;
              });
            }
            h3.add(s2);
          }
        }
        return o2[e3].apply(this, arguments);
      };
    }), h2;
  } };
} };
class Un {
  constructor(e2, t3) {
    this._middlewares = {}, this.verno = 0;
    const n2 = Un.dependencies;
    this._options = t3 = { addons: Un.addons, autoOpen: true, indexedDB: n2.indexedDB, IDBKeyRange: n2.IDBKeyRange, ...t3 }, this._deps = { indexedDB: t3.indexedDB, IDBKeyRange: t3.IDBKeyRange };
    const { addons: r2 } = t3;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const s2 = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: ee$2, dbReadyPromise: null, cancelOpen: ee$2, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3 };
    var i2;
    s2.dbReadyPromise = new Ce((e3) => {
      s2.dbReadyResolve = e3;
    }), s2.openCanceller = new Ce((e3, t4) => {
      s2.cancelOpen = t4;
    }), this._state = s2, this.name = e2, this.on = Pt$1(this, "populate", "blocked", "versionchange", "close", { ready: [ue$2, ee$2] }), this.on.ready.subscribe = y$1(this.on.ready.subscribe, (e3) => (t4, n3) => {
      Un.vip(() => {
        const r3 = this._state;
        if (r3.openComplete)
          r3.dbOpenError || Ce.resolve().then(t4), n3 && e3(t4);
        else if (r3.onReadyBeingFired)
          r3.onReadyBeingFired.push(t4), n3 && e3(t4);
        else {
          e3(t4);
          const r4 = this;
          n3 || e3(function e4() {
            r4.on.ready.unsubscribe(t4), r4.on.ready.unsubscribe(e4);
          });
        }
      });
    }), this.Collection = (i2 = this, Kt$1(Ft$1.prototype, function(e3, t4) {
      this.db = i2;
      let n3 = wt$1, r3 = null;
      if (t4)
        try {
          n3 = t4();
        } catch (e4) {
          r3 = e4;
        }
      const s3 = e3._ctx, o2 = s3.table, a2 = o2.hook.reading.fire;
      this._ctx = { table: o2, index: s3.index, isPrimKey: !s3.index || o2.schema.primKey.keyPath && s3.index === o2.schema.primKey.name, range: n3, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: r3, or: s3.or, valueMapper: a2 !== te$1 ? a2 : null };
    })), this.Table = function(e3) {
      return Kt$1(Et$1.prototype, function(t4, n3, r3) {
        this.db = e3, this._tx = r3, this.name = t4, this.schema = n3, this.hook = e3._allTables[t4] ? e3._allTables[t4].hook : Pt$1(null, { creating: [se$2, ee$2], reading: [ne$2, te$1], updating: [oe$2, ee$2], deleting: [ie$1, ee$2] });
      });
    }(this), this.Transaction = function(e3) {
      return Kt$1(Xt$1.prototype, function(t4, n3, r3, s3, i3) {
        this.db = e3, this.mode = t4, this.storeNames = n3, this.schema = r3, this.chromeTransactionDurability = s3, this.idbtrans = null, this.on = Pt$1(this, "complete", "error", "abort"), this.parent = i3 || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Ce((e4, t5) => {
          this._resolve = e4, this._reject = t5;
        }), this._completion.then(() => {
          this.active = false, this.on.complete.fire();
        }, (e4) => {
          var t5 = this.active;
          return this.active = false, this.on.error.fire(e4), this.parent ? this.parent._reject(e4) : t5 && this.idbtrans && this.idbtrans.abort(), ht$1(e4);
        });
      });
    }(this), this.Version = function(e3) {
      return Kt$1(gn.prototype, function(t4) {
        this.db = e3, this._cfg = { version: t4, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(e3) {
      return Kt$1(zt$1.prototype, function(t4, n3, r3) {
        this.db = e3, this._ctx = { table: t4, index: ":id" === n3 ? null : n3, or: r3 };
        const s3 = e3._deps.indexedDB;
        if (!s3)
          throw new X$2.MissingAPI();
        this._cmp = this._ascending = s3.cmp.bind(s3), this._descending = (e4, t5) => s3.cmp(t5, e4), this._max = (e4, t5) => s3.cmp(e4, t5) > 0 ? e4 : t5, this._min = (e4, t5) => s3.cmp(e4, t5) < 0 ? e4 : t5, this._IDBKeyRange = e3._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (e3) => {
      e3.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (e3) => {
      !e3.newVersion || e3.newVersion < e3.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${e3.oldVersion / 10}`);
    }), this._maxKey = tn(t3.IDBKeyRange), this._createTransaction = (e3, t4, n3, r3) => new this.Transaction(e3, t4, n3, this._options.chromeTransactionDurability, r3), this._fireOnBlocked = (e3) => {
      this.on("blocked").fire(e3), yt$1.filter((e4) => e4.name === this.name && e4 !== this && !e4._state.vcFired).map((t4) => t4.on("versionchange").fire(e3));
    }, this.use(Sn), this.use(Cn), this.use($n), this.use(Dn), this.vip = Object.create(this, { _vip: { value: true } }), r2.forEach((e3) => e3(this));
  }
  version(e2) {
    if (isNaN(e2) || e2 < 0.1)
      throw new X$2.Type("Given version is not a positive number");
    if (e2 = Math.round(10 * e2) / 10, this.idbdb || this._state.isBeingOpened)
      throw new X$2.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, e2);
    const t3 = this._versions;
    var n2 = t3.filter((t4) => t4._cfg.version === e2)[0];
    return n2 || (n2 = new this.Version(e2), t3.push(n2), t3.sort(hn), n2.stores({}), this._state.autoSchema = false, n2);
  }
  _whenReady(e2) {
    return this.idbdb && (this._state.openComplete || Ke.letThrough || this._vip) ? e2() : new Ce((e3, t3) => {
      if (this._state.openComplete)
        return t3(new X$2.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void t3(new X$2.DatabaseClosed());
        this.open().catch(ee$2);
      }
      this._state.dbReadyPromise.then(e3, t3);
    }).then(e2);
  }
  use({ stack: e2, create: t3, level: n2, name: r2 }) {
    r2 && this.unuse({ stack: e2, name: r2 });
    const s2 = this._middlewares[e2] || (this._middlewares[e2] = []);
    return s2.push({ stack: e2, create: t3, level: null == n2 ? 10 : n2, name: r2 }), s2.sort((e3, t4) => e3.level - t4.level), this;
  }
  unuse({ stack: e2, name: t3, create: n2 }) {
    return e2 && this._middlewares[e2] && (this._middlewares[e2] = this._middlewares[e2].filter((e3) => n2 ? e3.create !== n2 : !!t3 && e3.name !== t3)), this;
  }
  open() {
    return kn(this);
  }
  _close() {
    const e2 = this._state, t3 = yt$1.indexOf(this);
    if (t3 >= 0 && yt$1.splice(t3, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch (e3) {
      }
      this._novip.idbdb = null;
    }
    e2.dbReadyPromise = new Ce((t4) => {
      e2.dbReadyResolve = t4;
    }), e2.openCanceller = new Ce((t4, n2) => {
      e2.cancelOpen = n2;
    });
  }
  close() {
    this._close();
    const e2 = this._state;
    this._options.autoOpen = false, e2.dbOpenError = new X$2.DatabaseClosed(), e2.isBeingOpened && e2.cancelOpen(e2.dbOpenError);
  }
  delete() {
    const e2 = arguments.length > 0, t3 = this._state;
    return new Ce((n2, r2) => {
      const s2 = () => {
        this.close();
        var e3 = this._deps.indexedDB.deleteDatabase(this.name);
        e3.onsuccess = We(() => {
          !function({ indexedDB: e4, IDBKeyRange: t4 }, n3) {
            !_n(e4) && "__dbnames" !== n3 && bn(e4, t4).delete(n3).catch(ee$2);
          }(this._deps, this.name), n2();
        }), e3.onerror = Gt$1(r2), e3.onblocked = this._fireOnBlocked;
      };
      if (e2)
        throw new X$2.InvalidArgument("Arguments not allowed in db.delete()");
      t3.isBeingOpened ? t3.dbReadyPromise.then(s2) : s2();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return null !== this.idbdb;
  }
  hasBeenClosed() {
    const e2 = this._state.dbOpenError;
    return e2 && "DatabaseClosed" === e2.name;
  }
  hasFailed() {
    return null !== this._state.dbOpenError;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return t$1(this._allTables).map((e2) => this._allTables[e2]);
  }
  transaction() {
    const e2 = Pn.apply(this, arguments);
    return this._transaction.apply(this, e2);
  }
  _transaction(e2, t3, n2) {
    let r2 = Ke.trans;
    r2 && r2.db === this && -1 === e2.indexOf("!") || (r2 = null);
    const s2 = -1 !== e2.indexOf("?");
    let i2, o2;
    e2 = e2.replace("!", "").replace("?", "");
    try {
      if (o2 = t3.map((e3) => {
        var t4 = e3 instanceof this.Table ? e3.name : e3;
        if ("string" != typeof t4)
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return t4;
      }), "r" == e2 || "readonly" === e2)
        i2 = "readonly";
      else {
        if ("rw" != e2 && "readwrite" != e2)
          throw new X$2.InvalidArgument("Invalid transaction mode: " + e2);
        i2 = "readwrite";
      }
      if (r2) {
        if ("readonly" === r2.mode && "readwrite" === i2) {
          if (!s2)
            throw new X$2.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          r2 = null;
        }
        r2 && o2.forEach((e3) => {
          if (r2 && -1 === r2.storeNames.indexOf(e3)) {
            if (!s2)
              throw new X$2.SubTransaction("Table " + e3 + " not included in parent transaction.");
            r2 = null;
          }
        }), s2 && r2 && !r2.active && (r2 = null);
      }
    } catch (e3) {
      return r2 ? r2._promise(null, (t4, n3) => {
        n3(e3);
      }) : ht$1(e3);
    }
    const a2 = Kn.bind(null, this, i2, o2, r2, n2);
    return r2 ? r2._promise(i2, a2, "lock") : Ke.trans ? ot$1(Ke.transless, () => this._whenReady(a2)) : this._whenReady(a2);
  }
  table(e2) {
    if (!o$2(this._allTables, e2))
      throw new X$2.InvalidTable(`Table ${e2} does not exist`);
    return this._allTables[e2];
  }
}
const Ln = "undefined" != typeof Symbol && "observable" in Symbol ? Symbol.observable : "@@observable";
class Vn {
  constructor(e2) {
    this._subscribe = e2;
  }
  subscribe(e2, t3, n2) {
    return this._subscribe(e2 && "function" != typeof e2 ? e2 : { next: e2, error: t3, complete: n2 });
  }
  [Ln]() {
    return this;
  }
}
function Wn(e2, n2) {
  return t$1(n2).forEach((t3) => {
    Rn(e2[t3] || (e2[t3] = new Bn()), n2[t3]);
  }), e2;
}
function Yn(e2) {
  return new Vn((n2) => {
    const r2 = T$3(e2);
    let s2 = false, i2 = {}, o2 = {};
    const a2 = { get closed() {
      return s2;
    }, unsubscribe: () => {
      s2 = true, Qt$1.storagemutated.unsubscribe(h2);
    } };
    n2.start && n2.start(a2);
    let u2 = false, l2 = false;
    function c2() {
      return t$1(o2).some((e3) => i2[e3] && Fn(i2[e3], o2[e3]));
    }
    const h2 = (e3) => {
      Wn(i2, e3), c2() && d2();
    }, d2 = () => {
      if (u2 || s2)
        return;
      i2 = {};
      const t3 = {}, f2 = function(t4) {
        r2 && Ze();
        const n3 = () => Je(e2, { subscr: t4, trans: null }), s3 = Ke.trans ? ot$1(Ke.transless, n3) : n3();
        return r2 && s3.then(et$2, et$2), s3;
      }(t3);
      l2 || (Qt$1("storagemutated", h2), l2 = true), u2 = true, Promise.resolve(f2).then((e3) => {
        u2 = false, s2 || (c2() ? d2() : (i2 = {}, o2 = t3, n2.next && n2.next(e3)));
      }, (e3) => {
        ["DatabaseClosedError", "AbortError"].includes(null == e3 ? void 0 : e3.name) || (u2 = false, n2.error && n2.error(e3), a2.unsubscribe());
      });
    };
    return d2(), a2;
  });
}
let zn;
try {
  zn = { indexedDB: e$2.indexedDB || e$2.mozIndexedDB || e$2.webkitIndexedDB || e$2.msIndexedDB, IDBKeyRange: e$2.IDBKeyRange || e$2.webkitIDBKeyRange };
} catch (e2) {
  zn = { indexedDB: null, IDBKeyRange: null };
}
const Gn = Un;
function Hn(e2) {
  let t3 = Qn;
  try {
    Qn = true, Qt$1.storagemutated.fire(e2);
  } finally {
    Qn = t3;
  }
}
a$3(Gn, { ...Z$3, delete: (e2) => new Gn(e2, { addons: [] }).delete(), exists: (e2) => new Gn(e2, { addons: [] }).open().then((e3) => (e3.close(), true)).catch("NoSuchDatabaseError", () => false), getDatabaseNames(e2) {
  try {
    return function({ indexedDB: e3, IDBKeyRange: t3 }) {
      return _n(e3) ? Promise.resolve(e3.databases()).then((e4) => e4.map((e5) => e5.name).filter((e5) => "__dbnames" !== e5)) : bn(e3, t3).toCollection().primaryKeys();
    }(Gn.dependencies).then(e2);
  } catch (e3) {
    return ht$1(new X$2.MissingAPI());
  }
}, defineClass: () => function(e2) {
  r(this, e2);
}, ignoreTransaction: (e2) => Ke.trans ? ot$1(Ke.transless, e2) : e2(), vip: wn, async: function(e2) {
  return function() {
    try {
      var t3 = En(e2.apply(this, arguments));
      return t3 && "function" == typeof t3.then ? t3 : Ce.resolve(t3);
    } catch (e3) {
      return ht$1(e3);
    }
  };
}, spawn: function(e2, t3, n2) {
  try {
    var r2 = En(e2.apply(n2, t3 || []));
    return r2 && "function" == typeof r2.then ? r2 : Ce.resolve(r2);
  } catch (e3) {
    return ht$1(e3);
  }
}, currentTransaction: { get: () => Ke.trans || null }, waitFor: function(e2, t3) {
  const n2 = Ce.resolve("function" == typeof e2 ? Gn.ignoreTransaction(e2) : e2).timeout(t3 || 6e4);
  return Ke.trans ? Ke.trans.waitFor(n2) : n2;
}, Promise: Ce, debug: { get: () => R$1, set: (e2) => {
  F$3(e2, "dexie" === e2 ? () => true : bt$1);
} }, derive: c$2, extend: r, props: a$3, override: y$1, Events: Pt$1, on: Qt$1, liveQuery: Yn, extendObservabilitySet: Wn, getByKeyPath: b$2, setByKeyPath: _$3, delByKeyPath: function(e2, t3) {
  "string" == typeof t3 ? _$3(e2, t3, void 0) : "length" in t3 && [].map.call(t3, function(t4) {
    _$3(e2, t4, void 0);
  });
}, shallowClone: w$2, deepClone: O$2, getObjectDiff: An, cmp: Bt$1, asap: v$2, minKey: -(1 / 0), addons: [], connections: yt$1, errnames: H$1, dependencies: zn, semVer: "4.0.0-alpha.4", version: "4.0.0-alpha.4".split(".").map((e2) => parseInt(e2)).reduce((e2, t3, n2) => e2 + t3 / Math.pow(10, 2 * n2)) }), Gn.maxKey = tn(Gn.dependencies.IDBKeyRange), "undefined" != typeof dispatchEvent && "undefined" != typeof addEventListener && (Qt$1("storagemutated", (e2) => {
  if (!Qn) {
    let t3;
    mt$1 ? (t3 = document.createEvent("CustomEvent"), t3.initCustomEvent("x-storagemutated-1", true, true, e2)) : t3 = new CustomEvent("x-storagemutated-1", { detail: e2 }), Qn = true, dispatchEvent(t3), Qn = false;
  }
}), addEventListener("x-storagemutated-1", ({ detail: e2 }) => {
  Qn || Hn(e2);
}));
let Qn = false;
if ("undefined" != typeof BroadcastChannel) {
  const e2 = new BroadcastChannel("x-storagemutated-1");
  "function" == typeof e2.unref && e2.unref(), Qt$1("storagemutated", (t3) => {
    Qn || e2.postMessage(t3);
  }), e2.onmessage = (e3) => {
    e3.data && Hn(e3.data);
  };
} else if ("undefined" != typeof self && "undefined" != typeof navigator) {
  Qt$1("storagemutated", (e3) => {
    try {
      Qn || ("undefined" != typeof localStorage && localStorage.setItem("x-storagemutated-1", JSON.stringify({ trig: Math.random(), changedParts: e3 })), "object" == typeof self.clients && [...self.clients.matchAll({ includeUncontrolled: true })].forEach((t3) => t3.postMessage({ type: "x-storagemutated-1", changedParts: e3 })));
    } catch (e4) {
    }
  }), "undefined" != typeof addEventListener && addEventListener("storage", (e3) => {
    if ("x-storagemutated-1" === e3.key) {
      const t3 = JSON.parse(e3.newValue);
      t3 && Hn(t3.changedParts);
    }
  });
  const e2 = self.document && navigator.serviceWorker;
  e2 && e2.addEventListener("message", function({ data: e3 }) {
    e3 && "x-storagemutated-1" === e3.type && Hn(e3.changedParts);
  });
}
Ce.rejectionMapper = function(e2, t3) {
  if (!e2 || e2 instanceof W$2 || e2 instanceof TypeError || e2 instanceof SyntaxError || !e2.name || !J$2[e2.name])
    return e2;
  var n2 = new J$2[e2.name](t3 || e2.message, e2);
  return "stack" in e2 && l$2(n2, "stack", { get: function() {
    return this.inner.stack;
  } }), n2;
}, F$3(R$1, bt$1);
var DEXIE_DOCS_TABLE_NAME = "docs";
var DEXIE_DELETED_DOCS_TABLE_NAME = "deleted-docs";
var DEXIE_CHANGES_TABLE_NAME = "changes";
var RX_STORAGE_NAME_DEXIE = "dexie";
var RxStorageDexieStatics = RxStorageDefaultStatics;
var DEXIE_STATE_DB_BY_NAME = /* @__PURE__ */ new Map();
var REF_COUNT_PER_DEXIE_DB = /* @__PURE__ */ new Map();
function getDexieDbWithTables(databaseName, collectionName, settings, schema) {
  var primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);
  var dexieDbName = "rxdb-dexie-" + databaseName + "--" + schema.version + "--" + collectionName;
  var state = getFromMapOrCreate(DEXIE_STATE_DB_BY_NAME, dexieDbName, () => {
    var value = (async () => {
      var useSettings = flatClone(settings);
      useSettings.autoOpen = false;
      var dexieDb = new Un(dexieDbName, useSettings);
      var dexieStoresSettings = {
        [DEXIE_DOCS_TABLE_NAME]: getDexieStoreSchema(schema),
        [DEXIE_CHANGES_TABLE_NAME]: "++sequence, id",
        /**
         * Instead of adding {deleted: false} to every query we run over the document store,
         * we move deleted documents into a separate store where they can only be queried
         * by primary key.
         * This increases performance because it is way easier for the query planner to select
         * a good index and we also do not have to add the _deleted field to every index.
         *
         * We also need the [_meta.lwt+' + primaryPath + '] index for getChangedDocumentsSince()
         */
        [DEXIE_DELETED_DOCS_TABLE_NAME]: primaryPath + ",_meta.lwt,[_meta.lwt+" + primaryPath + "]"
      };
      dexieDb.version(1).stores(dexieStoresSettings);
      await dexieDb.open();
      return {
        dexieDb,
        dexieTable: dexieDb[DEXIE_DOCS_TABLE_NAME],
        dexieDeletedTable: dexieDb[DEXIE_DELETED_DOCS_TABLE_NAME]
      };
    })();
    DEXIE_STATE_DB_BY_NAME.set(dexieDbName, state);
    REF_COUNT_PER_DEXIE_DB.set(state, 0);
    return value;
  });
  return state;
}
async function closeDexieDb(statePromise) {
  var state = await statePromise;
  var prevCount = REF_COUNT_PER_DEXIE_DB.get(statePromise);
  var newCount = prevCount - 1;
  if (newCount === 0) {
    state.dexieDb.close();
    REF_COUNT_PER_DEXIE_DB.delete(statePromise);
  } else {
    REF_COUNT_PER_DEXIE_DB.set(statePromise, newCount);
  }
}
function ensureNoBooleanIndex(schema) {
  if (!schema.indexes) {
    return;
  }
  var checkedFields = /* @__PURE__ */ new Set();
  schema.indexes.forEach((index2) => {
    var fields = toArray$1(index2);
    fields.forEach((field) => {
      if (checkedFields.has(field)) {
        return;
      }
      checkedFields.add(field);
      var schemaObj = getSchemaByObjectPath(schema, field);
      if (schemaObj.type === "boolean") {
        throw newRxError("DXE1", {
          schema,
          index: index2,
          field
        });
      }
    });
  });
}
var DEXIE_PIPE_SUBSTITUTE = "__";
function dexieReplaceIfStartsWithPipe(str) {
  var split2 = str.split(".");
  if (split2.length > 1) {
    return split2.map((part) => dexieReplaceIfStartsWithPipe(part)).join(".");
  }
  if (str.startsWith("|")) {
    var withoutFirst = str.substring(1);
    return DEXIE_PIPE_SUBSTITUTE + withoutFirst;
  } else {
    return str;
  }
}
function dexieReplaceIfStartsWithPipeRevert(str) {
  var split2 = str.split(".");
  if (split2.length > 1) {
    return split2.map((part) => dexieReplaceIfStartsWithPipeRevert(part)).join(".");
  }
  if (str.startsWith(DEXIE_PIPE_SUBSTITUTE)) {
    var withoutFirst = str.substring(DEXIE_PIPE_SUBSTITUTE.length);
    return "|" + withoutFirst;
  } else {
    return str;
  }
}
function fromStorageToDexie(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromStorageToDexie(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object") {
        value = fromStorageToDexie(value);
      }
      ret[dexieReplaceIfStartsWithPipe(key)] = value;
    });
    return ret;
  }
}
function fromDexieToStorage(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromDexieToStorage(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object" || Array.isArray(documentData)) {
        value = fromDexieToStorage(value);
      }
      ret[dexieReplaceIfStartsWithPipeRevert(key)] = value;
    });
    return ret;
  }
}
function getDexieStoreSchema(rxJsonSchema) {
  var parts = [];
  var primaryKey = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);
  parts.push([primaryKey]);
  if (rxJsonSchema.indexes) {
    rxJsonSchema.indexes.forEach((index2) => {
      var arIndex = toArray$1(index2);
      parts.push(arIndex);
    });
  }
  parts.push(["_meta.lwt", primaryKey]);
  parts = parts.map((part) => {
    return part.map((str) => dexieReplaceIfStartsWithPipe(str));
  });
  return parts.map((part) => {
    if (part.length === 1) {
      return part[0];
    } else {
      return "[" + part.join("+") + "]";
    }
  }).join(", ");
}
async function getDocsInDb(internals, docIds) {
  var state = await internals;
  var [nonDeletedDocsInDb, deletedDocsInDb] = await Promise.all([state.dexieTable.bulkGet(docIds), state.dexieDeletedTable.bulkGet(docIds)]);
  var docsInDb = deletedDocsInDb.slice(0);
  nonDeletedDocsInDb.forEach((doc, idx) => {
    if (doc) {
      docsInDb[idx] = doc;
    }
  });
  return docsInDb;
}
function mapKeyForKeyRange(k2) {
  if (k2 === INDEX_MIN) {
    return -Infinity;
  } else {
    return k2;
  }
}
function getKeyRangeByQueryPlan(queryPlan, IDBKeyRange2) {
  if (!IDBKeyRange2) {
    if (typeof window === "undefined") {
      throw new Error("IDBKeyRange missing");
    } else {
      IDBKeyRange2 = window.IDBKeyRange;
    }
  }
  var startKeys = queryPlan.startKeys.map(mapKeyForKeyRange);
  var endKeys = queryPlan.endKeys.map(mapKeyForKeyRange);
  var ret;
  if (queryPlan.index.length === 1) {
    var equalKeys = startKeys[0] === endKeys[0];
    ret = IDBKeyRange2.bound(startKeys[0], endKeys[0], equalKeys ? false : !queryPlan.inclusiveStart, equalKeys ? false : !queryPlan.inclusiveEnd);
  } else {
    ret = IDBKeyRange2.bound(startKeys, endKeys, !queryPlan.inclusiveStart, !queryPlan.inclusiveEnd);
  }
  return ret;
}
async function dexieQuery(instance, preparedQuery) {
  var state = await instance.internals;
  var query = preparedQuery.query;
  var skip = query.skip ? query.skip : 0;
  var limit = query.limit ? query.limit : Infinity;
  var skipPlusLimit = skip + limit;
  var queryPlan = preparedQuery.queryPlan;
  var queryMatcher = false;
  if (!queryPlan.selectorSatisfiedByIndex) {
    queryMatcher = getQueryMatcher(instance.schema, preparedQuery.query);
  }
  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);
  var queryPlanFields = queryPlan.index;
  var rows2 = [];
  await state.dexieDb.transaction("r", state.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store2 = tx.objectStore(DEXIE_DOCS_TABLE_NAME);
    var index2;
    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {
      index2 = store2;
    } else {
      var indexName;
      if (queryPlanFields.length === 1) {
        indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);
      } else {
        indexName = "[" + queryPlanFields.map((field) => dexieReplaceIfStartsWithPipe(field)).join("+") + "]";
      }
      index2 = store2.index(indexName);
    }
    var cursorReq = index2.openCursor(keyRange);
    await new Promise((res) => {
      cursorReq.onsuccess = function(e2) {
        var cursor2 = e2.target.result;
        if (cursor2) {
          var docData = fromDexieToStorage(cursor2.value);
          if (!docData._deleted && (!queryMatcher || queryMatcher(docData))) {
            rows2.push(docData);
          }
          if (queryPlan.sortFieldsSameAsIndexFields && rows2.length === skipPlusLimit) {
            res();
          } else {
            cursor2.continue();
          }
        } else {
          res();
        }
      };
    });
  });
  if (!queryPlan.sortFieldsSameAsIndexFields) {
    var sortComparator = getSortComparator(instance.schema, preparedQuery.query);
    rows2 = rows2.sort(sortComparator);
  }
  rows2 = rows2.slice(skip, skipPlusLimit);
  return {
    documents: rows2
  };
}
async function dexieCount(instance, preparedQuery) {
  var state = await instance.internals;
  var queryPlan = preparedQuery.queryPlan;
  var queryPlanFields = queryPlan.index;
  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);
  var count = -1;
  await state.dexieDb.transaction("r", state.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store2 = tx.objectStore(DEXIE_DOCS_TABLE_NAME);
    var index2;
    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {
      index2 = store2;
    } else {
      var indexName;
      if (queryPlanFields.length === 1) {
        indexName = dexieReplaceIfStartsWithPipe(queryPlanFields[0]);
      } else {
        indexName = "[" + queryPlanFields.map((field) => dexieReplaceIfStartsWithPipe(field)).join("+") + "]";
      }
      index2 = store2.index(indexName);
    }
    var request = index2.count(keyRange);
    count = await new Promise((res, rej) => {
      request.onsuccess = function() {
        res(request.result);
      };
      request.onerror = (err) => rej(err);
    });
  });
  return count;
}
var instanceId = now$1();
var RxStorageInstanceDexie = /* @__PURE__ */ function() {
  function RxStorageInstanceDexie2(storage, databaseName, collectionName, schema, internals, options, settings) {
    this.changes$ = new Subject();
    this.instanceId = instanceId++;
    this.closed = false;
    this.storage = storage;
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.schema = schema;
    this.internals = internals;
    this.options = options;
    this.settings = settings;
    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);
  }
  var _proto = RxStorageInstanceDexie2.prototype;
  _proto.bulkWrite = async function bulkWrite(documentWrites, context) {
    ensureNotClosed(this);
    documentWrites.forEach((row) => {
      if (!row.document._rev || row.previous && !row.previous._rev) {
        throw newRxError("SNH", {
          args: {
            row
          }
        });
      }
    });
    var state = await this.internals;
    var ret = {
      success: {},
      error: {}
    };
    var documentKeys = documentWrites.map((writeRow) => writeRow.document[this.primaryPath]);
    var categorized;
    await state.dexieDb.transaction("rw", state.dexieTable, state.dexieDeletedTable, async () => {
      var docsInDbMap = /* @__PURE__ */ new Map();
      var docsInDbWithInternals = await getDocsInDb(this.internals, documentKeys);
      docsInDbWithInternals.forEach((docWithDexieInternals) => {
        var doc = docWithDexieInternals ? fromDexieToStorage(docWithDexieInternals) : docWithDexieInternals;
        if (doc) {
          docsInDbMap.set(doc[this.primaryPath], doc);
        }
        return doc;
      });
      categorized = categorizeBulkWriteRows(this, this.primaryPath, docsInDbMap, documentWrites, context);
      ret.error = categorized.errors;
      var bulkPutDocs = [];
      var bulkRemoveDocs = [];
      var bulkPutDeletedDocs = [];
      var bulkRemoveDeletedDocs = [];
      categorized.bulkInsertDocs.forEach((row) => {
        var docId = row.document[this.primaryPath];
        ret.success[docId] = row.document;
        bulkPutDocs.push(row.document);
      });
      categorized.bulkUpdateDocs.forEach((row) => {
        var docId = row.document[this.primaryPath];
        ret.success[docId] = row.document;
        if (row.document._deleted && row.previous && !row.previous._deleted) {
          bulkRemoveDocs.push(docId);
          bulkPutDeletedDocs.push(row.document);
        } else if (row.document._deleted && row.previous && row.previous._deleted) {
          bulkPutDeletedDocs.push(row.document);
        } else if (!row.document._deleted) {
          bulkPutDocs.push(row.document);
        } else {
          throw newRxError("SNH", {
            args: {
              row
            }
          });
        }
      });
      await Promise.all([bulkPutDocs.length > 0 ? state.dexieTable.bulkPut(bulkPutDocs.map((d2) => fromStorageToDexie(d2))) : PROMISE_RESOLVE_VOID, bulkRemoveDocs.length > 0 ? state.dexieTable.bulkDelete(bulkRemoveDocs) : PROMISE_RESOLVE_VOID, bulkPutDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkPut(bulkPutDeletedDocs.map((d2) => fromStorageToDexie(d2))) : PROMISE_RESOLVE_VOID, bulkRemoveDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkDelete(bulkRemoveDeletedDocs) : PROMISE_RESOLVE_VOID]);
    });
    categorized = ensureNotFalsy(categorized);
    if (categorized.eventBulk.events.length > 0) {
      var lastState = ensureNotFalsy(categorized.newestRow).document;
      categorized.eventBulk.checkpoint = {
        id: lastState[this.primaryPath],
        lwt: lastState._meta.lwt
      };
      var endTime = now$1();
      categorized.eventBulk.events.forEach((event) => event.endTime = endTime);
      this.changes$.next(categorized.eventBulk);
    }
    return ret;
  };
  _proto.findDocumentsById = async function findDocumentsById(ids, deleted) {
    ensureNotClosed(this);
    var state = await this.internals;
    var ret = {};
    await state.dexieDb.transaction("r", state.dexieTable, state.dexieDeletedTable, async () => {
      var docsInDb;
      if (deleted) {
        docsInDb = await getDocsInDb(this.internals, ids);
      } else {
        docsInDb = await state.dexieTable.bulkGet(ids);
      }
      ids.forEach((id2, idx) => {
        var documentInDb = docsInDb[idx];
        if (documentInDb && (!documentInDb._deleted || deleted)) {
          ret[id2] = fromDexieToStorage(documentInDb);
        }
      });
    });
    return ret;
  };
  _proto.query = function query(preparedQuery) {
    ensureNotClosed(this);
    return dexieQuery(this, preparedQuery);
  };
  _proto.count = async function count(preparedQuery) {
    if (preparedQuery.queryPlan.selectorSatisfiedByIndex) {
      var result = await dexieCount(this, preparedQuery);
      return {
        count: result,
        mode: "fast"
      };
    } else {
      var _result = await dexieQuery(this, preparedQuery);
      return {
        count: _result.documents.length,
        mode: "slow"
      };
    }
  };
  _proto.getChangedDocumentsSince = async function getChangedDocumentsSince(limit, checkpoint) {
    ensureNotClosed(this);
    var sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;
    var sinceId = checkpoint ? checkpoint.id : "";
    var state = await this.internals;
    var [changedDocsNormal, changedDocsDeleted] = await Promise.all([state.dexieTable, state.dexieDeletedTable].map(async (table2) => {
      var query = table2.where("[_meta.lwt+" + this.primaryPath + "]").above([sinceLwt, sinceId]).limit(limit);
      var changedDocuments = await query.toArray();
      return changedDocuments.map((d2) => fromDexieToStorage(d2));
    }));
    var changedDocs = changedDocsNormal.slice(0);
    appendToArray(changedDocs, changedDocsDeleted);
    changedDocs = sortDocumentsByLastWriteTime(this.primaryPath, changedDocs);
    changedDocs = changedDocs.slice(0, limit);
    var lastDoc = lastOfArray$1(changedDocs);
    return {
      documents: changedDocs,
      checkpoint: lastDoc ? {
        id: lastDoc[this.primaryPath],
        lwt: lastDoc._meta.lwt
      } : checkpoint ? checkpoint : {
        id: "",
        lwt: 0
      }
    };
  };
  _proto.remove = async function remove() {
    ensureNotClosed(this);
    var state = await this.internals;
    await Promise.all([state.dexieDeletedTable.clear(), state.dexieTable.clear()]);
    return this.close();
  };
  _proto.changeStream = function changeStream() {
    ensureNotClosed(this);
    return this.changes$.asObservable();
  };
  _proto.cleanup = async function cleanup(minimumDeletedTime) {
    ensureNotClosed(this);
    var state = await this.internals;
    await state.dexieDb.transaction("rw", state.dexieDeletedTable, async () => {
      var maxDeletionTime = now$1() - minimumDeletedTime;
      var toRemove = await state.dexieDeletedTable.where("_meta.lwt").below(maxDeletionTime).toArray();
      var removeIds = toRemove.map((doc) => doc[this.primaryPath]);
      await state.dexieDeletedTable.bulkDelete(removeIds);
    });
    return true;
  };
  _proto.getAttachmentData = function getAttachmentData(_documentId, _attachmentId, _digest) {
    ensureNotClosed(this);
    throw new Error("Attachments are not implemented in the dexie RxStorage. Make a pull request.");
  };
  _proto.close = function close3() {
    ensureNotClosed(this);
    this.closed = true;
    this.changes$.complete();
    closeDexieDb(this.internals);
    return PROMISE_RESOLVE_VOID;
  };
  _proto.conflictResultionTasks = function conflictResultionTasks() {
    return new Subject();
  };
  _proto.resolveConflictResultionTask = async function resolveConflictResultionTask(_taskSolution) {
  };
  return RxStorageInstanceDexie2;
}();
function createDexieStorageInstance(storage, params, settings) {
  var internals = getDexieDbWithTables(params.databaseName, params.collectionName, settings, params.schema);
  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings);
  addRxStorageMultiInstanceSupport(RX_STORAGE_NAME_DEXIE, params, instance);
  return Promise.resolve(instance);
}
function ensureNotClosed(instance) {
  if (instance.closed) {
    throw new Error("RxStorageInstanceDexie is closed " + instance.databaseName + "-" + instance.collectionName);
  }
}
var RxStorageDexie = /* @__PURE__ */ function() {
  function RxStorageDexie2(settings) {
    this.name = RX_STORAGE_NAME_DEXIE;
    this.statics = RxStorageDexieStatics;
    this.settings = settings;
  }
  var _proto = RxStorageDexie2.prototype;
  _proto.createStorageInstance = function createStorageInstance(params) {
    ensureRxStorageInstanceParamsAreCorrect(params);
    ensureNoBooleanIndex(params.schema);
    return createDexieStorageInstance(this, params, this.settings);
  };
  return RxStorageDexie2;
}();
function getRxStorageDexie(settings = {}) {
  var storage = new RxStorageDexie(settings);
  return storage;
}
var clone$1 = { exports: {} };
(function(module2) {
  var clone2 = function() {
    function _instanceof(obj, type2) {
      return type2 != null && obj instanceof type2;
    }
    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_2) {
      nativeMap = function() {
      };
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_2) {
      nativeSet = function() {
      };
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_2) {
      nativePromise = function() {
      };
    }
    function clone3(parent, circular, depth, prototype2, includeNonEnumerable) {
      if (typeof circular === "object") {
        depth = circular.depth;
        prototype2 = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != "undefined";
      if (typeof circular == "undefined")
        circular = true;
      if (typeof depth == "undefined")
        depth = Infinity;
      function _clone(parent2, depth2) {
        if (parent2 === null)
          return null;
        if (depth2 === 0)
          return parent2;
        var child;
        var proto;
        if (typeof parent2 != "object") {
          return parent2;
        }
        if (_instanceof(parent2, nativeMap)) {
          child = new nativeMap();
        } else if (_instanceof(parent2, nativeSet)) {
          child = new nativeSet();
        } else if (_instanceof(parent2, nativePromise)) {
          child = new nativePromise(function(resolve2, reject) {
            parent2.then(function(value) {
              resolve2(_clone(value, depth2 - 1));
            }, function(err) {
              reject(_clone(err, depth2 - 1));
            });
          });
        } else if (clone3.__isArray(parent2)) {
          child = [];
        } else if (clone3.__isRegExp(parent2)) {
          child = new RegExp(parent2.source, __getRegExpFlags(parent2));
          if (parent2.lastIndex)
            child.lastIndex = parent2.lastIndex;
        } else if (clone3.__isDate(parent2)) {
          child = new Date(parent2.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent2)) {
          if (Buffer.allocUnsafe) {
            child = Buffer.allocUnsafe(parent2.length);
          } else {
            child = new Buffer(parent2.length);
          }
          parent2.copy(child);
          return child;
        } else if (_instanceof(parent2, Error)) {
          child = Object.create(parent2);
        } else {
          if (typeof prototype2 == "undefined") {
            proto = Object.getPrototypeOf(parent2);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype2);
            proto = prototype2;
          }
        }
        if (circular) {
          var index2 = allParents.indexOf(parent2);
          if (index2 != -1) {
            return allChildren[index2];
          }
          allParents.push(parent2);
          allChildren.push(child);
        }
        if (_instanceof(parent2, nativeMap)) {
          parent2.forEach(function(value, key) {
            var keyChild = _clone(key, depth2 - 1);
            var valueChild = _clone(value, depth2 - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent2, nativeSet)) {
          parent2.forEach(function(value) {
            var entryChild = _clone(value, depth2 - 1);
            child.add(entryChild);
          });
        }
        for (var i2 in parent2) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i2);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i2] = _clone(parent2[i2], depth2 - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(parent2);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            var symbol = symbols[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol] = _clone(parent2[symbol], depth2 - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol, {
                enumerable: false
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent2);
          for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
            var propertyName = allPropertyNames[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }
        return child;
      }
      return _clone(parent, depth);
    }
    clone3.clonePrototype = function clonePrototype(parent) {
      if (parent === null)
        return null;
      var c2 = function() {
      };
      c2.prototype = parent;
      return new c2();
    };
    function __objToStr(o2) {
      return Object.prototype.toString.call(o2);
    }
    clone3.__objToStr = __objToStr;
    function __isDate(o2) {
      return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
    }
    clone3.__isDate = __isDate;
    function __isArray(o2) {
      return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
    }
    clone3.__isArray = __isArray;
    function __isRegExp(o2) {
      return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
    }
    clone3.__isRegExp = __isRegExp;
    function __getRegExpFlags(re2) {
      var flags3 = "";
      if (re2.global)
        flags3 += "g";
      if (re2.ignoreCase)
        flags3 += "i";
      if (re2.multiline)
        flags3 += "m";
      return flags3;
    }
    clone3.__getRegExpFlags = __getRegExpFlags;
    return clone3;
  }();
  if (module2.exports) {
    module2.exports = clone2;
  }
})(clone$1);
var cloneExports = clone$1.exports;
var toStr$3 = Object.prototype.toString;
var isArguments$2 = function isArguments(value) {
  var str = toStr$3.call(value);
  var isArgs2 = str === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$3.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$8;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation$8;
  hasRequiredImplementation = 1;
  var keysShim2;
  if (!Object.keys) {
    var has2 = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments$2;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o2) {
      var ctor = o2.constructor;
      return ctor && ctor.prototype === o2;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k2 in window) {
        try {
          if (!excludedKeys["$" + k2] && has2.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
            try {
              equalsConstructorPrototype(window[k2]);
            } catch (e2) {
              return true;
            }
          }
        } catch (e2) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o2) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o2);
      }
      try {
        return equalsConstructorPrototype(o2);
      } catch (e2) {
        return false;
      }
    };
    keysShim2 = function keys3(object2) {
      var isObject3 = object2 !== null && typeof object2 === "object";
      var isFunction3 = toStr2.call(object2) === "[object Function]";
      var isArguments5 = isArgs2(object2);
      var isString3 = isObject3 && toStr2.call(object2) === "[object String]";
      var theKeys = [];
      if (!isObject3 && !isFunction3 && !isArguments5) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction3;
      if (isString3 && object2.length > 0 && !has2.call(object2, 0)) {
        for (var i2 = 0; i2 < object2.length; ++i2) {
          theKeys.push(String(i2));
        }
      }
      if (isArguments5 && object2.length > 0) {
        for (var j2 = 0; j2 < object2.length; ++j2) {
          theKeys.push(String(j2));
        }
      } else {
        for (var name in object2) {
          if (!(skipProto && name === "prototype") && has2.call(object2, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
        for (var k2 = 0; k2 < dontEnums.length; ++k2) {
          if (!(skipConstructor && dontEnums[k2] === "constructor") && has2.call(object2, dontEnums[k2])) {
            theKeys.push(dontEnums[k2]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$8 = keysShim2;
  return implementation$8;
}
var slice$1 = Array.prototype.slice;
var isArgs = isArguments$2;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o2) {
  return origKeys(o2);
} : requireImplementation();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object2) {
        if (isArgs(object2)) {
          return originalKeys(slice$1.call(object2));
        }
        return originalKeys(object2);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys$1 = keysShim;
var shams$1 = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var hasSymbols$3 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$3() && !!Symbol.toStringTag;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$2 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var test = {
  foo: {}
};
var $Object$1 = Object;
var hasProto$1 = function hasProto() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object$1);
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr$2 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$7 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$2.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        args.concat(slice.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs.push("$" + i2);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation$6 = implementation$7;
var functionBind = Function.prototype.bind || implementation$6;
var bind$2 = functionBind;
var src = bind$2.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError$1 = SyntaxError;
var $Function = Function;
var $TypeError$3 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e2) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$3();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = hasSymbols$2();
var hasProto2 = hasProto$1();
var getProto$1 = Object.getPrototypeOf || (hasProto2 ? function(x2) {
  return x2.__proto__;
} : null);
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
if (getProto$1) {
  try {
    null.error;
  } catch (e2) {
    var errorProto = getProto$1(getProto$1(e2));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn3 = doEval2("%AsyncGeneratorFunction%");
    if (fn3) {
      value = fn3.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto$1) {
      value = getProto$1(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$1 = functionBind;
var hasOwn = src;
var $concat = bind$1.call(Function.call, Array.prototype.concat);
var $spliceApply = bind$1.call(Function.apply, Array.prototype.splice);
var $replace = bind$1.call(Function.call, String.prototype.replace);
var $strSlice = bind$1.call(Function.call, String.prototype.slice);
var $exec$1 = bind$1.call(Function.call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string2) {
  var first = $strSlice(string2, 0, 1);
  var last2 = $strSlice(string2, -1);
  if (first === "%" && last2 !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  } else if (last2 === "%" && first !== "%") {
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string2, rePropName, function(match2, number2, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match2;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$3("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError$1("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  }
  if ($exec$1(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first = $strSlice(part, 0, 1);
    var last2 = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first !== last2) {
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$3("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i2 + 1 >= parts.length) {
        var desc = $gOPD$1(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$3 = { exports: {} };
(function(module2) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty2 = GetIntrinsic3("%Object.defineProperty%", true);
  var $max2 = GetIntrinsic3("%Math.max%");
  if ($defineProperty2) {
    try {
      $defineProperty2({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty2 = null;
    }
  }
  module2.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind3, $call, arguments);
    if ($gOPD2 && $defineProperty2) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty2(
          func,
          "length",
          { value: 1 + $max2(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty2) {
    $defineProperty2(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$3);
var callBindExports = callBind$3.exports;
var GetIntrinsic$2 = getIntrinsic;
var callBind$2 = callBindExports;
var $indexOf = callBind$2(GetIntrinsic$2("String.prototype.indexOf"));
var callBound$2 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$2(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind$2(intrinsic);
  }
  return intrinsic;
};
var hasToStringTag$2 = shams();
var callBound$1 = callBound$2;
var $toString$1 = callBound$1("Object.prototype.toString");
var isStandardArguments = function isArguments2(value) {
  if (hasToStringTag$2 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return $toString$1(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments3(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString$1(value) !== "[object Array]" && $toString$1(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var GetIntrinsic$1 = getIntrinsic;
var $defineProperty$1 = GetIntrinsic$1("%Object.defineProperty%", true);
var hasPropertyDescriptors$1 = function hasPropertyDescriptors() {
  if ($defineProperty$1) {
    try {
      $defineProperty$1({}, "a", { value: 1 });
      return true;
    } catch (e2) {
      return false;
    }
  }
  return false;
};
hasPropertyDescriptors$1.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  if (!hasPropertyDescriptors$1()) {
    return null;
  }
  try {
    return $defineProperty$1([], "length", { value: 1 }).length !== 1;
  } catch (e2) {
    return true;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors$1;
var gopd$1;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd)
    return gopd$1;
  hasRequiredGopd = 1;
  var GetIntrinsic3 = getIntrinsic;
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD2) {
    try {
      $gOPD2([], "length");
    } catch (e2) {
      $gOPD2 = null;
    }
  }
  gopd$1 = $gOPD2;
  return gopd$1;
}
var hasPropertyDescriptors2 = hasPropertyDescriptors_1();
var GetIntrinsic2 = getIntrinsic;
var $defineProperty = hasPropertyDescriptors2 && GetIntrinsic2("%Object.defineProperty%", true);
var $SyntaxError = GetIntrinsic2("%SyntaxError%");
var $TypeError$2 = GetIntrinsic2("%TypeError%");
var gopd = requireGopd();
var defineDataProperty$1 = function defineDataProperty(obj, property, value) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new $TypeError$2("`obj` must be an object or a function`");
  }
  if (typeof property !== "string" && typeof property !== "symbol") {
    throw new $TypeError$2("`property` must be a string or a symbol`");
  }
  if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
    throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
    throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
    throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
  }
  if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
    throw new $TypeError$2("`loose`, if provided, must be a boolean");
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty) {
    $defineProperty(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    obj[property] = value;
  } else {
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }
};
var keys$1 = objectKeys$1;
var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$1 = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty2 = defineDataProperty$1;
var isFunction$3 = function(fn3) {
  return typeof fn3 === "function" && toStr$1.call(fn3) === "[object Function]";
};
var supportsDescriptors$2 = hasPropertyDescriptors_1();
var defineProperty$1 = function(object2, name, value, predicate) {
  if (name in object2) {
    if (predicate === true) {
      if (object2[name] === value) {
        return;
      }
    } else if (!isFunction$3(predicate) || !predicate()) {
      return;
    }
  }
  if (supportsDescriptors$2) {
    defineDataProperty2(object2, name, value, true);
  } else {
    defineDataProperty2(object2, name, value);
  }
};
var defineProperties = function(object2, map2) {
  var predicates2 = arguments.length > 2 ? arguments[2] : {};
  var props = keys$1(map2);
  if (hasSymbols2) {
    props = concat.call(props, Object.getOwnPropertySymbols(map2));
  }
  for (var i2 = 0; i2 < props.length; i2 += 1) {
    defineProperty$1(object2, props[i2], map2[props[i2]], predicates2[props[i2]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors$2;
var defineProperties_1 = defineProperties;
var numberIsNaN = function(value) {
  return value !== value;
};
var implementation$5 = function is(a2, b2) {
  if (a2 === 0 && b2 === 0) {
    return 1 / a2 === 1 / b2;
  }
  if (a2 === b2) {
    return true;
  }
  if (numberIsNaN(a2) && numberIsNaN(b2)) {
    return true;
  }
  return false;
};
var implementation$4 = implementation$5;
var polyfill$2 = function getPolyfill() {
  return typeof Object.is === "function" ? Object.is : implementation$4;
};
var getPolyfill$3 = polyfill$2;
var define$3 = defineProperties_1;
var shim$3 = function shimObjectIs() {
  var polyfill2 = getPolyfill$3();
  define$3(Object, { is: polyfill2 }, {
    is: function testObjectIs() {
      return Object.is !== polyfill2;
    }
  });
  return polyfill2;
};
var define$2 = defineProperties_1;
var callBind$1 = callBindExports;
var implementation$3 = implementation$5;
var getPolyfill$2 = polyfill$2;
var shim$2 = shim$3;
var polyfill$1 = callBind$1(getPolyfill$2(), Object);
define$2(polyfill$1, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$3,
  shim: shim$2
});
var objectIs = polyfill$1;
var callBound = callBound$2;
var hasToStringTag$1 = shams();
var has$1;
var $exec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag$1) {
  has$1 = callBound("Object.prototype.hasOwnProperty");
  $exec = callBound("RegExp.prototype.exec");
  isRegexMarker = {};
  var throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var $toString = callBound("Object.prototype.toString");
var gOPD$2 = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex$1 = hasToStringTag$1 ? function isRegex(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor = gOPD$2(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor && has$1(descriptor, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    $exec(value, badStringifier);
  } catch (e2) {
    return e2 === isRegexMarker;
  }
} : function isRegex2(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return $toString(value) === regexClass;
};
var functionsHaveNames = function functionsHaveNames2() {
  return typeof function f2() {
  }.name === "string";
};
var gOPD$1 = Object.getOwnPropertyDescriptor;
if (gOPD$1) {
  try {
    gOPD$1([], "length");
  } catch (e2) {
    gOPD$1 = null;
  }
}
functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
  if (!functionsHaveNames() || !gOPD$1) {
    return false;
  }
  var desc = gOPD$1(function() {
  }, "name");
  return !!desc && !!desc.configurable;
};
var $bind = Function.prototype.bind;
functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
  return functionsHaveNames() && typeof $bind === "function" && function f2() {
  }.bind().name !== "";
};
var functionsHaveNames_1 = functionsHaveNames;
var define$1 = defineDataProperty$1;
var hasDescriptors = hasPropertyDescriptors_1();
var functionsHaveConfigurableNames2 = functionsHaveNames_1.functionsHaveConfigurableNames();
var $TypeError$1 = TypeError;
var setFunctionName$1 = function setFunctionName(fn3, name) {
  if (typeof fn3 !== "function") {
    throw new $TypeError$1("`fn` is not a function");
  }
  var loose = arguments.length > 2 && !!arguments[2];
  if (!loose || functionsHaveConfigurableNames2) {
    if (hasDescriptors) {
      define$1(fn3, "name", name, true, true);
    } else {
      define$1(fn3, "name", name);
    }
  }
  return fn3;
};
var setFunctionName2 = setFunctionName$1;
var $Object = Object;
var $TypeError = TypeError;
var implementation$2 = setFunctionName2(function flags() {
  if (this != null && this !== $Object(this)) {
    throw new $TypeError("RegExp.prototype.flags getter called on non-object");
  }
  var result = "";
  if (this.hasIndices) {
    result += "d";
  }
  if (this.global) {
    result += "g";
  }
  if (this.ignoreCase) {
    result += "i";
  }
  if (this.multiline) {
    result += "m";
  }
  if (this.dotAll) {
    result += "s";
  }
  if (this.unicode) {
    result += "u";
  }
  if (this.unicodeSets) {
    result += "v";
  }
  if (this.sticky) {
    result += "y";
  }
  return result;
}, "get flags", true);
var implementation$1 = implementation$2;
var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
var $gOPD = Object.getOwnPropertyDescriptor;
var polyfill = function getPolyfill2() {
  if (supportsDescriptors$1 && /a/mig.flags === "gim") {
    var descriptor = $gOPD(RegExp.prototype, "flags");
    if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
      var calls = "";
      var o2 = {};
      Object.defineProperty(o2, "hasIndices", {
        get: function() {
          calls += "d";
        }
      });
      Object.defineProperty(o2, "sticky", {
        get: function() {
          calls += "y";
        }
      });
      if (calls === "dy") {
        return descriptor.get;
      }
    }
  }
  return implementation$1;
};
var supportsDescriptors = defineProperties_1.supportsDescriptors;
var getPolyfill$1 = polyfill;
var gOPD = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;
var shim$1 = function shimFlags() {
  if (!supportsDescriptors || !getProto) {
    throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  var polyfill2 = getPolyfill$1();
  var proto = getProto(regex);
  var descriptor = gOPD(proto, "flags");
  if (!descriptor || descriptor.get !== polyfill2) {
    defineProperty(proto, "flags", {
      configurable: true,
      enumerable: false,
      get: polyfill2
    });
  }
  return polyfill2;
};
var define = defineProperties_1;
var callBind = callBindExports;
var implementation = implementation$2;
var getPolyfill3 = polyfill;
var shim = shim$1;
var flagsBound = callBind(getPolyfill3());
define(flagsBound, {
  getPolyfill: getPolyfill3,
  implementation,
  shim
});
var regexp_prototype_flags = flagsBound;
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag = shams();
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};
var objectKeys = objectKeys$1;
var isArguments4 = isArguments$1;
var is$1 = objectIs;
var isRegex3 = isRegex$1;
var flags2 = regexp_prototype_flags;
var isDate$1 = isDateObject;
var getTime = Date.prototype.getTime;
function deepEqual(actual, expected, options) {
  var opts = options || {};
  if (opts.strict ? is$1(actual, expected) : actual === expected) {
    return true;
  }
  if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
    return opts.strict ? is$1(actual, expected) : actual == expected;
  }
  return objEquiv(actual, expected, opts);
}
function isUndefinedOrNull(value) {
  return value === null || value === void 0;
}
function isBuffer$1(x2) {
  if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
    return false;
  }
  if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
    return false;
  }
  if (x2.length > 0 && typeof x2[0] !== "number") {
    return false;
  }
  return true;
}
function objEquiv(a2, b2, opts) {
  var i2, key;
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (isUndefinedOrNull(a2) || isUndefinedOrNull(b2)) {
    return false;
  }
  if (a2.prototype !== b2.prototype) {
    return false;
  }
  if (isArguments4(a2) !== isArguments4(b2)) {
    return false;
  }
  var aIsRegex = isRegex3(a2);
  var bIsRegex = isRegex3(b2);
  if (aIsRegex !== bIsRegex) {
    return false;
  }
  if (aIsRegex || bIsRegex) {
    return a2.source === b2.source && flags2(a2) === flags2(b2);
  }
  if (isDate$1(a2) && isDate$1(b2)) {
    return getTime.call(a2) === getTime.call(b2);
  }
  var aIsBuffer = isBuffer$1(a2);
  var bIsBuffer = isBuffer$1(b2);
  if (aIsBuffer !== bIsBuffer) {
    return false;
  }
  if (aIsBuffer || bIsBuffer) {
    if (a2.length !== b2.length) {
      return false;
    }
    for (i2 = 0; i2 < a2.length; i2++) {
      if (a2[i2] !== b2[i2]) {
        return false;
      }
    }
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  try {
    var ka2 = objectKeys(a2);
    var kb2 = objectKeys(b2);
  } catch (e2) {
    return false;
  }
  if (ka2.length !== kb2.length) {
    return false;
  }
  ka2.sort();
  kb2.sort();
  for (i2 = ka2.length - 1; i2 >= 0; i2--) {
    if (ka2[i2] != kb2[i2]) {
      return false;
    }
  }
  for (i2 = ka2.length - 1; i2 >= 0; i2--) {
    key = ka2[i2];
    if (!deepEqual(a2[key], b2[key], opts)) {
      return false;
    }
  }
  return true;
}
var deepEqual_1 = deepEqual;
function _interopDefault(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var clone = _interopDefault(cloneExports);
var equal = _interopDefault(deepEqual_1);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var _extends = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var isObject$2 = function(variableToCheck) {
  return (typeof variableToCheck === "undefined" ? "undefined" : _typeof(variableToCheck)) === "object" && variableToCheck !== null;
};
var every = function(arrayToIterate, cb2) {
  return arrayToIterate.every(function(elem) {
    return cb2 && cb2(elem) || elem;
  });
};
var has = function(objectWithKeys, key) {
  return objectWithKeys.hasOwnProperty(key);
};
var keys2 = function(objectWithKeys) {
  return Object.keys(objectWithKeys);
};
var each = function(objectToIterate, cb2) {
  Object.keys(objectToIterate).forEach(function(key) {
    cb2(objectToIterate[key], key);
  });
};
var libIsArray = function(variableToCheck) {
  return Array.isArray(variableToCheck);
};
var isBinary = function(variableToCheck) {
  return !!(typeof Uint8Array !== "undefined" && variableToCheck instanceof Uint8Array || variableToCheck && variableToCheck.$Uint8ArrayPolyfill);
};
var _$1$1 = { isArray: libIsArray, each };
var isArray$1 = function isArray(x2) {
  return _$1$1.isArray(x2) && !isBinary(x2);
};
var isIndexable = function isIndexable2(x2) {
  return isArray$1(x2) || isPlainObject$1(x2);
};
var isOperatorObject = function isOperatorObject2(valueSelector, inconsistentOK) {
  if (!isPlainObject$1(valueSelector))
    return false;
  var theseAreOperators = void 0;
  _$1$1.each(valueSelector, function(value, selKey) {
    var thisIsOperator = selKey.substr(0, 1) === "$";
    if (theseAreOperators === void 0) {
      theseAreOperators = thisIsOperator;
    } else if (theseAreOperators !== thisIsOperator) {
      if (!inconsistentOK)
        throw new Error("Inconsistent operator: " + JSON.stringify(valueSelector));
      theseAreOperators = false;
    }
  });
  return !!theseAreOperators;
};
var isNumericKey = function isNumericKey2(s2) {
  return /^[0-9]+$/.test(s2);
};
var isPlainObject$1 = function(variableToCheck) {
  if (!variableToCheck)
    return false;
  if (typeof variableToCheck === "number")
    return false;
  if (typeof variableToCheck === "string")
    return false;
  if (typeof variableToCheck === "boolean")
    return false;
  if (isArray$1(variableToCheck))
    return false;
  if (variableToCheck === null)
    return false;
  if (variableToCheck instanceof RegExp)
    return false;
  if (typeof variableToCheck === "function")
    return false;
  if (variableToCheck instanceof Date)
    return false;
  if (isBinary(variableToCheck))
    return false;
  return true;
};
var ModifyJsError = function(message) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof message === "string" && options.field) {
    message += " for field '" + options.field + "'";
  }
  var e2 = new Error(message);
  e2.name = "ModifyJsError";
  return e2;
};
var _$2 = { all: every, each, keys: keys2, has, isObject: isObject$2 };
var modify = function(doc, mod, options) {
  if (options && options.each) {
    return;
  }
  return _modify(doc, mod, _extends({}, options, { returnInsteadOfReplacing: true }));
};
var _modify = function _modify2(doc, mod, options) {
  options = options || {};
  if (!isPlainObject$1(mod))
    throw ModifyJsError("Modifier must be an object");
  mod = clone(mod);
  var isModifier = isOperatorObject(mod);
  var newDoc;
  if (!isModifier) {
    newDoc = mod;
  } else {
    newDoc = clone(doc);
    _$2.each(mod, function(operand, op) {
      var modFunc = MODIFIERS[op];
      if (!modFunc)
        throw ModifyJsError("Invalid modifier specified " + op);
      _$2.each(operand, function(arg, keypath) {
        if (keypath === "") {
          throw ModifyJsError("An empty update path is not valid.");
        }
        var keyparts = keypath.split(".");
        if (!_$2.all(keyparts)) {
          throw ModifyJsError("The update path '" + keypath + "' contains an empty field name, which is not allowed.");
        }
        var target = findModTarget(newDoc, keyparts, {
          noCreate: NO_CREATE_MODIFIERS[op],
          forbidArray: op === "$rename",
          arrayIndices: options.arrayIndices
        });
        var field = keyparts.pop();
        modFunc(target, field, arg, keypath, newDoc);
      });
    });
  }
  if (options.returnInsteadOfReplacing) {
    return newDoc;
  } else {
    _$2.each(_$2.keys(doc), function(k2) {
      if (k2 !== "_id")
        delete doc[k2];
    });
    _$2.each(newDoc, function(v2, k2) {
      doc[k2] = v2;
    });
  }
};
var findModTarget = function findModTarget2(doc, keyparts, options) {
  options = options || {};
  var usedArrayIndex = false;
  for (var i2 = 0; i2 < keyparts.length; i2++) {
    var last2 = i2 === keyparts.length - 1;
    var keypart = keyparts[i2];
    var indexable = isIndexable(doc);
    if (!indexable) {
      if (options.noCreate)
        return void 0;
      var e2 = ModifyJsError("cannot use the part '" + keypart + "' to traverse " + doc);
      e2.setPropertyError = true;
      throw e2;
    }
    if (doc instanceof Array) {
      if (options.forbidArray)
        return null;
      if (keypart === "$") {
        if (usedArrayIndex)
          throw ModifyJsError("Too many positional (i.e. '$') elements");
        if (!options.arrayIndices || !options.arrayIndices.length) {
          throw ModifyJsError("The positional operator did not find the match needed from the query");
        }
        keypart = options.arrayIndices[0];
        usedArrayIndex = true;
      } else if (isNumericKey(keypart)) {
        keypart = parseInt(keypart);
      } else {
        if (options.noCreate)
          return void 0;
        throw ModifyJsError("can't append to array using string field name [" + keypart + "]");
      }
      if (last2)
        keyparts[i2] = keypart;
      if (options.noCreate && keypart >= doc.length)
        return void 0;
      while (doc.length < keypart) {
        doc.push(null);
      }
      if (!last2) {
        if (doc.length === keypart)
          doc.push({});
        else if (_typeof(doc[keypart]) !== "object")
          throw ModifyJsError("can't modify field '" + keyparts[i2 + 1] + "' of list value " + JSON.stringify(doc[keypart]));
      }
    } else {
      if (!(keypart in doc)) {
        if (options.noCreate)
          return void 0;
        if (!last2)
          doc[keypart] = {};
      }
    }
    if (last2)
      return doc;
    doc = doc[keypart];
  }
};
var NO_CREATE_MODIFIERS = {
  $unset: true,
  $pop: true,
  $rename: true,
  $pull: true,
  $pullAll: true
};
var MODIFIERS = {
  $currentDate: function $currentDate(target, field, arg) {
    if ((typeof arg === "undefined" ? "undefined" : _typeof(arg)) === "object" && arg.hasOwnProperty("$type")) {
      if (arg.$type !== "date") {
        throw ModifyJsError("Minimongo does currently only support the date type in $currentDate modifiers", { field });
      }
    } else if (arg !== true) {
      throw ModifyJsError("Invalid $currentDate modifier", { field });
    }
    target[field] = /* @__PURE__ */ new Date();
  },
  $min: function $min(target, field, arg) {
    if (typeof arg !== "number") {
      throw ModifyJsError("Modifier $min allowed for numbers only", { field });
    }
    if (field in target) {
      if (typeof target[field] !== "number") {
        throw ModifyJsError("Cannot apply $min modifier to non-number", { field });
      }
      if (target[field] > arg) {
        target[field] = arg;
      }
    } else {
      target[field] = arg;
    }
  },
  $max: function $max(target, field, arg) {
    if (typeof arg !== "number") {
      throw ModifyJsError("Modifier $max allowed for numbers only", { field });
    }
    if (field in target) {
      if (typeof target[field] !== "number") {
        throw ModifyJsError("Cannot apply $max modifier to non-number", { field });
      }
      if (target[field] < arg) {
        target[field] = arg;
      }
    } else {
      target[field] = arg;
    }
  },
  $inc: function $inc(target, field, arg) {
    if (typeof arg !== "number")
      throw ModifyJsError("Modifier $inc allowed for numbers only", { field });
    if (field in target) {
      if (typeof target[field] !== "number")
        throw ModifyJsError("Cannot apply $inc modifier to non-number", { field });
      target[field] += arg;
    } else {
      target[field] = arg;
    }
  },
  $set: function $set(target, field, arg) {
    if (!_$2.isObject(target)) {
      var e2 = ModifyJsError("Cannot set property on non-object field", { field });
      e2.setPropertyError = true;
      throw e2;
    }
    if (target === null) {
      var e2 = ModifyJsError("Cannot set property on null", { field });
      e2.setPropertyError = true;
      throw e2;
    }
    target[field] = arg;
  },
  $setOnInsert: function $setOnInsert(target, field, arg) {
  },
  $unset: function $unset(target, field, arg) {
    if (target !== void 0) {
      if (target instanceof Array) {
        if (field in target)
          target[field] = null;
      } else
        delete target[field];
    }
  },
  $push: function $push(target, field, arg) {
    if (target[field] === void 0)
      target[field] = [];
    if (!(target[field] instanceof Array))
      throw ModifyJsError("Cannot apply $push modifier to non-array", { field });
    if (!(arg && arg.$each)) {
      target[field].push(arg);
      return;
    }
    var toPush = arg.$each;
    if (!(toPush instanceof Array))
      throw ModifyJsError("$each must be an array", { field });
    var position2 = void 0;
    if ("$position" in arg) {
      if (typeof arg.$position !== "number")
        throw ModifyJsError("$position must be a numeric value", { field });
      if (arg.$position < 0)
        throw ModifyJsError("$position in $push must be zero or positive", { field });
      position2 = arg.$position;
    }
    var slice2 = void 0;
    if ("$slice" in arg) {
      if (typeof arg.$slice !== "number")
        throw ModifyJsError("$slice must be a numeric value", { field });
      if (arg.$slice > 0)
        throw ModifyJsError("$slice in $push must be zero or negative", { field });
      slice2 = arg.$slice;
    }
    if (arg.$sort) {
      throw ModifyJsError("$sort in $push not implemented yet");
    }
    if (position2 === void 0) {
      for (var j2 = 0; j2 < toPush.length; j2++) {
        target[field].push(toPush[j2]);
      }
    } else {
      var spliceArguments = [position2, 0];
      for (var j2 = 0; j2 < toPush.length; j2++) {
        spliceArguments.push(toPush[j2]);
      }
      Array.prototype.splice.apply(target[field], spliceArguments);
    }
    if (slice2 !== void 0) {
      if (slice2 === 0)
        target[field] = [];
      else
        target[field] = target[field].slice(slice2);
    }
  },
  $pushAll: function $pushAll(target, field, arg) {
    if (!((typeof arg === "undefined" ? "undefined" : _typeof(arg)) === "object" && arg instanceof Array))
      throw ModifyJsError("Modifier $pushAll/pullAll allowed for arrays only");
    var x2 = target[field];
    if (x2 === void 0)
      target[field] = arg;
    else if (!(x2 instanceof Array))
      throw ModifyJsError("Cannot apply $pushAll modifier to non-array", { field });
    else {
      for (var i2 = 0; i2 < arg.length; i2++) {
        x2.push(arg[i2]);
      }
    }
  },
  $addToSet: function $addToSet(target, field, arg) {
    var isEach = false;
    if ((typeof arg === "undefined" ? "undefined" : _typeof(arg)) === "object") {
      var _keys = Object.keys(arg);
      if (_keys[0] === "$each") {
        isEach = true;
      }
    }
    var values2 = isEach ? arg["$each"] : [arg];
    var x2 = target[field];
    if (x2 === void 0)
      target[field] = values2;
    else if (!(x2 instanceof Array))
      throw ModifyJsError("Cannot apply $addToSet modifier to non-array", { field });
    else {
      _$2.each(values2, function(value) {
        for (var i2 = 0; i2 < x2.length; i2++) {
          if (equal(value, x2[i2]))
            return;
        }
        x2.push(value);
      });
    }
  },
  $pop: function $pop(target, field, arg) {
    if (target === void 0)
      return;
    var x2 = target[field];
    if (x2 === void 0)
      return;
    else if (!(x2 instanceof Array))
      throw ModifyJsError("Cannot apply $pop modifier to non-array", { field });
    else {
      if (typeof arg === "number" && arg < 0)
        x2.splice(0, 1);
      else
        x2.pop();
    }
  },
  $pull: function $pull(target, field, arg) {
    if (target === void 0)
      return;
    var x2 = target[field];
    if (x2 === void 0)
      return;
    else if (!(x2 instanceof Array))
      throw ModifyJsError("Cannot apply $pull/pullAll modifier to non-array", { field });
    else {
      throw ModifyJsError("$pull not implemented yet");
    }
  },
  $pullAll: function $pullAll(target, field, arg) {
    if (!((typeof arg === "undefined" ? "undefined" : _typeof(arg)) === "object" && arg instanceof Array))
      throw ModifyJsError("Modifier $pushAll/pullAll allowed for arrays only", { field });
    if (target === void 0)
      return;
    var x2 = target[field];
    if (x2 === void 0)
      return;
    else if (!(x2 instanceof Array))
      throw ModifyJsError("Cannot apply $pull/pullAll modifier to non-array", { field });
    else {
      var out = [];
      for (var i2 = 0; i2 < x2.length; i2++) {
        var exclude = false;
        for (var j2 = 0; j2 < arg.length; j2++) {
          if (equal(x2[i2], arg[j2])) {
            exclude = true;
            break;
          }
        }
        if (!exclude)
          out.push(x2[i2]);
      }
      target[field] = out;
    }
  },
  $rename: function $rename(target, field, arg, keypath, doc) {
    if (keypath === arg)
      throw ModifyJsError("$rename source must differ from target", { field });
    if (target === null)
      throw ModifyJsError("$rename source field invalid", { field });
    if (typeof arg !== "string")
      throw ModifyJsError("$rename target must be a string", { field });
    if (arg.indexOf("\0") > -1) {
      throw ModifyJsError("The 'to' field for $rename cannot contain an embedded null byte", { field });
    }
    if (target === void 0)
      return;
    var v2 = target[field];
    delete target[field];
    var keyparts = arg.split(".");
    var target2 = findModTarget(doc, keyparts, { forbidArray: true });
    if (target2 === null)
      throw ModifyJsError("$rename target field invalid", { field });
    var field2 = keyparts.pop();
    target2[field2] = v2;
  },
  $bit: function $bit(target, field, arg) {
    throw ModifyJsError("$bit is not supported", { field });
  }
};
var bundle = modify;
const modifyjs = /* @__PURE__ */ getDefaultExportFromCjs(bundle);
function incrementalUpdate(updateObj) {
  return this.incrementalModify((docData) => {
    var newDocData = modifyjs(docData, updateObj);
    return newDocData;
  });
}
function update(updateObj) {
  var oldDocData = this._data;
  var newDocData = modifyjs(oldDocData, updateObj);
  return this._saveData(newDocData, oldDocData);
}
function RxQueryUpdate(updateObj) {
  return this.exec().then((docs) => {
    if (!docs) {
      return null;
    }
    if (Array.isArray(docs)) {
      return Promise.all(docs.map((doc) => doc.update(updateObj))).then(() => docs);
    } else {
      return docs.update(updateObj).then(() => docs);
    }
  });
}
var RxDBUpdatePlugin = {
  name: "update",
  rxdb: true,
  prototypes: {
    RxDocument: (proto) => {
      proto.update = update;
      proto.incrementalUpdate = incrementalUpdate;
    },
    RxQuery: (proto) => {
      proto.update = RxQueryUpdate;
    }
  }
};
const draftSchema = {
  title: "draft schema",
  description: "describes draft",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    customer: {
      type: "object",
      properties: {
        id: {
          type: "string"
        },
        name: {
          type: "string"
        },
        phone: {
          type: "string"
        }
      }
    },
    amount: {
      type: "number"
    },
    items: {
      type: "array",
      items: {
        type: "object",
        properties: {
          name: {
            type: "string"
          },
          image: {
            type: "string"
          },
          quantity: {
            type: "number"
          },
          unitPrice: {
            type: "number"
          }
        }
      }
    },
    timestamp: {
      type: "date-time"
    }
  },
  required: ["id", "items", "customer", "amount", "timestamp"]
};
const categorySchema = {
  title: "category",
  description: "describes categories",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    business_id: {
      type: "string"
    },
    category_type: {
      type: "string"
    },
    created_at: {
      type: "string"
    },
    created_by: {
      type: "string"
    },
    deleted_at: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    description: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    name: {
      type: "string"
    },
    parent_id: {
      type: "string"
    },
    short_code: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    slug: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    sub_categories: {
      type: "array"
    },
    updated_at: {
      type: "string"
    },
    woocommerce_cat_id: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    }
  }
};
const authSchema = {
  title: "authentication schema",
  description: "describes authentication",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    username: {
      type: "string"
    },
    password: {
      type: "string"
    },
    lastLogin: {
      type: "date-time"
    }
  },
  required: ["id", "username", "password", "lastLogin"]
};
const paymentMethodSchema = {
  title: "payment method schema",
  description: "describes payment method",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    methods: {
      type: "object",
      properties: {
        cash: {
          type: "string"
        },
        card: {
          type: "string"
        },
        cheque: {
          type: "string"
        },
        bank_transfer: {
          type: "string"
        },
        custom_pay_1: {
          type: "string"
        },
        custom_pay_2: {
          type: "string"
        },
        custom_pay_3: {
          type: "string"
        },
        custom_pay_4: {
          type: "string"
        },
        custom_pay_5: {
          type: "string"
        },
        custom_pay_6: {
          type: "string"
        },
        custom_pay_7: {
          type: "string"
        },
        other: {
          type: "string"
        }
      }
    },
    timestamp: {
      type: "date-time"
    }
  },
  required: [
    "id",
    "cash",
    "card",
    "cheque",
    "bank_transfer",
    "other",
    "timestamp"
  ]
};
const businessLocationSchema = {
  title: "businesslocation",
  description: "describes business locations",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    business_id: {
      type: "string"
    },
    city: {
      type: "string"
    },
    country: {
      type: "string"
    },
    created_at: {
      type: "string"
    },
    email: {
      type: "string"
    },
    landmark: {
      type: "string"
    },
    location_id: {
      type: "string"
    },
    mobile: {
      type: "string"
    },
    name: {
      type: "string"
    },
    state: {
      type: "string"
    },
    updated_at: {
      type: "string"
    },
    is_active: {
      type: "string"
    },
    print_receipt_on_invoice: {
      type: "string"
    },
    zip_code: {
      type: "string"
    },
    payment_methods: {
      type: "array"
    },
    timestamp: {
      type: "date-time"
    }
  }
};
const cashRegisterSchema = {
  title: "cash register schema",
  description: "describes cash register",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    location_id: {
      type: "number"
    },
    initial_amount: {
      type: "number"
    },
    created_at: {
      type: "string"
    },
    closed_at: {
      type: "string"
    },
    status: {
      type: "string"
    },
    closing_amount: {
      type: "number"
    },
    total_card_slips: {
      type: "number"
    },
    total_cheques: {
      type: "number"
    },
    closing_note: {
      type: "string"
    },
    transaction_ids: {
      type: "string"
    }
  },
  required: ["id", "location_id", "initial_amount", "created_at", "status"]
};
const stockSchema = {
  title: "stock schema",
  description: "describes product stock report",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    alert_quantity: {
      type: "string"
    },
    category_name: {
      type: "string"
    },
    enable_stock: {
      type: "string"
    },
    location_id: {
      type: "string"
    },
    location_name: {
      type: "string"
    },
    product: {
      type: "string"
    },
    product_id: {
      type: "string"
    },
    product_variation: {
      type: "string"
    },
    sku: {
      type: "string"
    },
    stock: {
      type: "string"
    },
    stock_price: {
      type: "string"
    },
    total_adjusted: {
      type: ["string", "null", "number"],
      // This property can be a string or null
      nullable: true
    },
    total_sold: {
      type: "string"
    },
    total_transfered: {
      type: ["string", "null", "number"],
      // This property can be a string or null
      nullable: true
    },
    type: {
      type: "string"
    },
    unit: {
      type: "string"
    },
    unit_price: {
      type: "string"
    },
    variation_id: {
      type: "string"
    },
    variation_name: {
      type: "string"
    }
  }
};
const productSchema = {
  title: "product",
  description: "describes product",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    alert_quantity: {
      type: "string"
    },
    barcode_type: {
      type: "string"
    },
    brand: {
      type: ["string", "null"],
      nullable: true
    },
    business_id: {
      type: "string"
    },
    category: {
      type: "object",
      properties: {
        type: { type: "string" },
        ref: { type: "category" }
      }
    },
    created_by: {
      type: "string"
    },
    enable_sr_no: {
      type: "string"
    },
    enable_stock: {
      type: "string"
    },
    expiry_period: {
      type: ["string", "null"],
      nullable: true
    },
    image: {
      type: "string"
    },
    image_url: {
      type: "string"
    },
    is_inactive: {
      type: "string"
    },
    name: {
      type: "string"
    },
    not_for_selling: {
      type: "string"
    },
    product_description: {
      type: ["string", "null"],
      nullable: true
    },
    product_locations: {
      type: "array",
      items: {
        type: "string",
        ref: "businesslocation"
      }
    },
    product_tax: {
      type: ["string", "null"],
      nullable: true
    },
    product_variations: {
      type: "array",
      items: {
        type: "string",
        ref: "product_variation"
      }
    },
    sku: {
      type: "string"
    },
    sub_category: {
      type: "string"
    },
    type: {
      type: "string"
    },
    warranty_id: {
      type: ["string", "null"],
      nullable: true
    },
    unit: {
      type: "array"
    },
    weight: {
      type: ["string", "null"],
      nullable: true
    }
  }
};
const userSchema = {
  title: "user_schema",
  description: "describes user",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    username: {
      type: "string"
    },
    first_name: {
      type: "string"
    },
    surname: {
      type: "string"
    },
    last_name: {
      type: "string"
    },
    email: {
      type: "string"
    },
    user_type: {
      type: "string"
    },
    crm_contact_id: {
      type: "string"
    },
    allow_login: {
      type: "number"
    },
    cmmsn_percent: {
      type: "string"
    },
    max_sales_discount_percent: {
      type: "string"
    },
    dob: {
      type: "string"
    },
    gender: {
      type: "string"
    },
    marital_status: {
      type: "string"
    },
    blood_group: {
      type: "string"
    },
    alt_number: {
      type: "string"
    },
    contact_number: {
      type: "string"
    },
    family_number: {
      type: "string"
    },
    fb_link: {
      type: "string"
    },
    twitter_link: {
      type: "string"
    },
    id_proof_number: {
      type: "string"
    },
    permanent_address: {
      type: "string"
    },
    current_address: {
      type: "string"
    },
    status: {
      type: "string"
    }
  },
  required: [
    "id",
    "gender",
    "dob",
    "email",
    "first_name",
    "last_name",
    "contact_number",
    "permanent_address"
  ]
};
const sellSchema = {
  title: "sell_schema",
  description: "describes sell schema structure",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    location_id: {
      type: "number"
    },
    contact_id: {
      type: "number"
    },
    transaction_date: {
      type: "string"
    },
    invoice_no: {
      type: "string"
    },
    sale_note: {
      type: "string"
    },
    shipping_details: {
      type: "string"
    },
    shipping_address: {
      type: "string"
    },
    shipping_status: {
      type: "string"
    },
    delivered_to: {
      type: "string"
    },
    change_return: {
      type: "number"
    },
    products: {
      type: "array",
      items: {
        type: "string",
        ref: "sell_product_schema"
      }
    },
    service_staff_id: {
      type: "string"
    },
    payments: {
      type: "array",
      items: {
        type: "string",
        ref: "sell_payment_schema"
      }
    },
    exchange_rate: {
      type: "number"
    },
    round_off_amount: {
      type: "number"
    }
  },
  required: ["id", "contact_id", "location_id", "transaction_date"]
};
const customerSchema = {
  title: "customer_schema",
  description: "describes a customer",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    first_name: {
      type: "string"
    },
    middle_name: {
      type: "string"
    },
    last_name: {
      type: "string"
    },
    email: {
      type: "string"
    },
    type: {
      type: "string"
    },
    name: {
      type: "string"
    },
    contact_id: {
      type: "string"
    },
    credit_limit: {
      type: "string"
    },
    dob: {
      type: "string"
    },
    mobile: {
      type: "string"
    },
    address_line_1: {
      type: "string"
    },
    state: {
      type: "string"
    },
    alt_number: {
      type: "string"
    },
    city: {
      type: "string"
    },
    tax_number: {
      type: "string"
    },
    prefix: {
      type: "string"
    },
    shipping_address: {
      type: "string"
    },
    pay_term_type: {
      type: "string"
    },
    pay_term_number: {
      type: "number"
    },
    contact_status: {
      type: "string"
    },
    business_id: {
      type: "string"
    }
  },
  required: [
    "id",
    "type"
  ]
};
const pendingSellSchema = {
  title: "pending_sell_schema",
  description: "describes offline sell schema structure",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    sells: {
      type: "array",
      items: {
        type: "object",
        properties: {
          contact_id: {
            type: "number"
          },
          additional_notes: {
            type: "string"
          },
          change_return: {
            type: "string"
          },
          final_total: {
            type: "number"
          },
          delivered_to: {
            type: "string"
          },
          invoice_no: {
            type: "string"
          },
          is_suspend: {
            type: "number"
          },
          location_id: {
            type: "number"
          },
          payments: {
            type: "array",
            items: {
              type: "object",
              properties: {
                amount: {
                  type: "number"
                },
                method: {
                  type: "string"
                },
                note: {
                  type: "string"
                }
              }
            }
          },
          price_group: {
            type: "number"
          },
          products: {
            type: "array",
            items: {
              type: "object",
              properties: {
                base_unit_multiplier: {
                  type: "number"
                },
                enable_stock: {
                  type: "number"
                },
                item_tax: {
                  type: "number"
                },
                line_discount_amount: {
                  type: "number"
                },
                line_discount_type: {
                  type: "string"
                },
                product_id: {
                  type: "number"
                },
                product_type: {
                  type: "string"
                },
                product_unit_id: {
                  type: "number"
                },
                quantity: {
                  type: "number"
                },
                sub_unit_id: {
                  type: "number"
                },
                unit_price: {
                  type: "number"
                },
                variation_id: {
                  type: "number"
                }
              }
            }
          },
          recur_interval_type: {
            type: "string"
          },
          sale_note: {
            type: "string"
          },
          shipping_charges_modal: {
            type: "number"
          },
          staff_note: {
            type: "string"
          },
          status: {
            type: "string"
          },
          transaction_date: {
            type: "string"
          },
          token: {
            type: "string"
          }
        }
      }
    }
  },
  required: ["id", "sells"]
};
addRxPlugin(RxDBQueryBuilderPlugin);
addRxPlugin(RxDBUpdatePlugin);
async function getDatabase(name) {
  try {
    const db2 = await createRxDatabase({
      name,
      storage: getRxStorageDexie({
        indexedDB: fakeIndexedDB,
        IDBKeyRange: FDBKeyRange
      }),
      ignoreDuplicate: true
    });
    await db2.addCollections({
      business_locations: {
        schema: businessLocationSchema
      }
    });
    await db2.addCollections({
      cash_registers: {
        schema: cashRegisterSchema
      }
    });
    await db2.addCollections({
      product_stock_reports: {
        schema: stockSchema
      }
    });
    await db2.addCollections({
      products: {
        schema: productSchema
      }
    });
    await db2.addCollections({
      carts: {
        schema: cartSchema
      }
    });
    await db2.addCollections({
      drafts: {
        schema: draftSchema
      }
    });
    await db2.addCollections({
      categories: {
        schema: categorySchema
      }
    });
    await db2.addCollections({
      auth: {
        schema: authSchema
      }
    });
    await db2.addCollections({
      paymentmethods: {
        schema: paymentMethodSchema
      }
    });
    await db2.addCollections({
      users: {
        schema: userSchema
      }
    });
    await db2.addCollections({
      customers: {
        schema: customerSchema
      }
    });
    await db2.addCollections({
      sells: {
        schema: sellSchema
      }
    });
    await db2.addCollections({
      pendingsells: {
        schema: pendingSellSchema
      }
    });
    return db2;
  } catch (error) {
    console.log("CAUGHT ERROR", error);
  }
}
function bind2(fn3, thisArg) {
  return function wrap() {
    return fn3.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache2) => (thing) => {
  const str = toString.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray: isArray2 } = Array;
const isUndefined$1 = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString2 = typeOfTest("string");
const isFunction$2 = typeOfTest("function");
const isNumber$1 = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction$2(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn3, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray2(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn3.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys3 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys3.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys3[i2];
      fn3.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys3 = Object.keys(obj);
  let i2 = keys3.length;
  let _key;
  while (i2-- > 0) {
    _key = keys3[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined$1(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue2 = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue2);
  }
  return result;
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction$2(val)) {
      a2[key] = bind2(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray2(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber$1(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = ((TypedArray2) => {
  return (thing) => {
    return TypedArray2 && thing instanceof TypedArray2;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn3) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator2 = generator.call(obj);
  let result;
  while ((result = iterator2.next()) && !result.done) {
    const pair = result.value;
    fn3.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$2(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray2(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter2));
  return obj;
};
const noop$3 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$2(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray2(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined$1(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch);
const utils = {
  isArray: isArray2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString2,
  isNumber: isNumber$1,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isUndefined: isUndefined$1,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$3,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each2(token2, i2) {
    token2 = removeBrackets(token2);
    return !dots && i2 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el2, index2) {
          !(utils.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils.forEach(value, function each2(el2, key) {
      const result = !(utils.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append2(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn3) {
    utils.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn3(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys3 = Object.keys(arr);
  let i2;
  const len = keys3.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys3[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    const isNumericKey3 = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey3;
    }
    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey3;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
    i2 = line2.indexOf(":");
    key = line2.substring(0, i2).trim().toLowerCase();
    val = line2.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys3 = Object.keys(this);
    let i2 = keys3.length;
    let deleted = false;
    while (i2--) {
      const key = keys3[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config2 = this || defaults$1;
  const context = response || config2;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform2(fn3) {
    data = fn3.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config2, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write2(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name) {
        const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push2(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if (!requestHeaders.getContentType(/^\s*multipart\/form-data/)) {
        requestHeaders.setContentType("multipart/form-data");
      } else if (utils.isString(contentType = requestHeaders.getContentType())) {
        requestHeaders.setContentType(contentType.replace(/^\s*(multipart\/form-data);+/, "$1"));
      }
    }
    let request = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request.timeout = config2.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitionalDefaults;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config2.withCredentials)) {
      request.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn3, value) => {
  if (fn3) {
    try {
      Object.defineProperty(fn3, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn3, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length2; i2++) {
      nameOrAdapter = adapters2[i2];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless);
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap2 = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
  };
  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap2[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const VERSION = "1.5.1";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i2) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys3 = Object.keys(options);
  let i2 = keys3.length;
  while (i2-- > 0) {
    const opt = keys3[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config2);
      while (i2 < len) {
        promise2 = promise2.then(chain[i2++], chain[i2++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise2 = promise2.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise2;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i2 = token2._listeners.length;
      while (i2-- > 0) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise2 = new Promise((resolve2) => {
        token2.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise2.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message, config2, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config2, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig2) {
  const context = new Axios$1(defaultConfig2);
  const instance = bind2(Axios$1.prototype.request, context);
  utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig2, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
const axiosInstance = axios$1.create({
  baseURL: "https://pos.virtualrx.com.ng",
  headers: {
    "Content-Type": "application/json",
    "Access-Control-Allow-Origin": "http://localhost:5173"
  }
});
axiosInstance.interceptors.request.use(async (req) => {
  try {
    const accessToken = localStorage.getItem("accessToken");
    if (accessToken) {
      req.headers.Authorization = `Bearer ${accessToken}`;
    }
    return req;
  } catch (error) {
    return Promise.reject(error);
  }
});
axiosInstance.interceptors.response.use(
  (res) => res,
  async (err) => {
    const originalConfig = err.config;
    if (err.response) {
      if (err.response.status === 401) {
        originalConfig._retry = true;
        try {
          const refreshToken = localStorage.getItem("refreshToken");
          const refreshResponse = await axiosInstance.post("/auth/token", {
            refreshToken
          });
          if (refreshResponse?.data) {
            localStorage.setItem("accessToken", refreshResponse?.data.accessToken);
            refreshResponse.config.headers.Authorization = `Bearer ${refreshResponse.data.accessToken}`;
          }
          return axiosInstance(originalConfig);
        } catch (_error) {
          if (_error.response && _error.response.data) {
            return Promise.reject(_error.response.data);
          }
          return Promise.reject(_error);
        }
      }
      if (err.response.status === 403 && err.response.data) {
        return Promise.reject(err.response.data);
      }
    }
    return Promise.reject(err);
  }
);
class APIService {
  static fetcher = (url) => axiosInstance.get(url).then((res) => res.data);
  static clockIn = (payload) => axiosInstance.post("/oauth/token", payload).then((res) => res.data);
  static getProducts = () => axiosInstance.get("/connector/api/product").then((res) => res.data);
  static getCategories = () => axiosInstance.get("/connector/api/taxonomy").then((res) => res.data);
  static getProductsStockReport = () => axiosInstance.get("/connector/api/product-stock-report").then((res) => res.data);
  static getPaymentMethods = () => axiosInstance.get("/connector/api/payment-methods").then((res) => res.data);
  static getBusinessLocations = () => axiosInstance.get("/connector/api/business-location").then((res) => res.data);
  static createCashRegister = (payload) => axiosInstance.post("/connector/api/cash-register", payload).then((res) => res.data);
  static addNewCustomer = (payload) => axiosInstance.post("/connector/api/contactapi", payload).then((res) => res.data);
  static getCustomers = () => axiosInstance.get("/connector/api/contactapi").then((res) => res.data);
  static getUsers = () => axiosInstance.get("/connector/api/user").then((res) => res.data);
  static createSell = (payload) => axiosInstance.post("/connector/api/sell", payload).then((res) => res.data);
  static getSalesReport = (locationId, userId) => axiosInstance.get(`/connector/api/sell?location_id=${locationId}?user_id=${userId}?per_page=${-1}`).then((res) => res.data);
}
let e$1 = { data: "" }, t = (t3) => "object" == typeof window ? ((t3 ? t3.querySelector("#_goober") : window._goober) || Object.assign((t3 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t3 || e$1, l$1 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a$2 = /\/\*[^]*?\*\/|  +/g, n$2 = /\n+/g, o$1 = (e2, t3) => {
  let r2 = "", l2 = "", a2 = "";
  for (let n2 in e2) {
    let c2 = e2[n2];
    "@" == n2[0] ? "i" == n2[1] ? r2 = n2 + " " + c2 + ";" : l2 += "f" == n2[1] ? o$1(c2, n2) : n2 + "{" + o$1(c2, "k" == n2[1] ? "" : t3) + "}" : "object" == typeof c2 ? l2 += o$1(c2, t3 ? t3.replace(/([^,])+/g, (e3) => n2.replace(/(^:.*)|([^,])+/g, (t4) => /&/.test(t4) ? t4.replace(/&/g, e3) : e3 ? e3 + " " + t4 : t4)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, "-$&").toLowerCase(), a2 += o$1.p ? o$1.p(n2, c2) : n2 + ":" + c2 + ";");
  }
  return r2 + (t3 && a2 ? t3 + "{" + a2 + "}" : a2) + l2;
}, c$1 = {}, s$1 = (e2) => {
  if ("object" == typeof e2) {
    let t3 = "";
    for (let r2 in e2)
      t3 += r2 + s$1(e2[r2]);
    return t3;
  }
  return e2;
}, i$5 = (e2, t3, r2, i2, p2) => {
  let u2 = s$1(e2), d2 = c$1[u2] || (c$1[u2] = ((e3) => {
    let t4 = 0, r3 = 11;
    for (; t4 < e3.length; )
      r3 = 101 * r3 + e3.charCodeAt(t4++) >>> 0;
    return "go" + r3;
  })(u2));
  if (!c$1[d2]) {
    let t4 = u2 !== e2 ? e2 : ((e3) => {
      let t5, r3, o2 = [{}];
      for (; t5 = l$1.exec(e3.replace(a$2, "")); )
        t5[4] ? o2.shift() : t5[3] ? (r3 = t5[3].replace(n$2, " ").trim(), o2.unshift(o2[0][r3] = o2[0][r3] || {})) : o2[0][t5[1]] = t5[2].replace(n$2, " ").trim();
      return o2[0];
    })(e2);
    c$1[d2] = o$1(p2 ? { ["@keyframes " + d2]: t4 } : t4, r2 ? "" : "." + d2);
  }
  let f2 = r2 && c$1.g ? c$1.g : null;
  return r2 && (c$1.g = c$1[d2]), ((e3, t4, r3, l2) => {
    l2 ? t4.data = t4.data.replace(l2, e3) : -1 === t4.data.indexOf(e3) && (t4.data = r3 ? e3 + t4.data : t4.data + e3);
  })(c$1[d2], t3, i2, f2), d2;
}, p$1 = (e2, t3, r2) => e2.reduce((e3, l2, a2) => {
  let n2 = t3[a2];
  if (n2 && n2.call) {
    let e4 = n2(r2), t4 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;
    n2 = t4 ? "." + t4 : e4 && "object" == typeof e4 ? e4.props ? "" : o$1(e4, "") : false === e4 ? "" : e4;
  }
  return e3 + l2 + (null == n2 ? "" : n2);
}, "");
function u$3(e2) {
  let r2 = this || {}, l2 = e2.call ? e2(r2.p) : e2;
  return i$5(l2.unshift ? l2.raw ? p$1(l2, [].slice.call(arguments, 1), r2.p) : l2.reduce((e3, t3) => Object.assign(e3, t3 && t3.call ? t3(r2.p) : t3), {}) : l2, t(r2.target), r2.g, r2.o, r2.k);
}
let d$1, f$2, g$1;
u$3.bind({ g: 1 });
let h$2 = u$3.bind({ k: 1 });
function m$1(e2, t3, r2, l2) {
  o$1.p = t3, d$1 = e2, f$2 = r2, g$1 = l2;
}
function j$1(e2, t3) {
  let r2 = this || {};
  return function() {
    let l2 = arguments;
    function a2(n2, o2) {
      let c2 = Object.assign({}, n2), s2 = c2.className || a2.className;
      r2.p = Object.assign({ theme: f$2 && f$2() }, c2), r2.o = / *go\d+/.test(s2), c2.className = u$3.apply(r2, l2) + (s2 ? " " + s2 : ""), t3 && (c2.ref = o2);
      let i2 = e2;
      return e2[0] && (i2 = c2.as || e2, delete c2.as), g$1 && i2[0] && g$1(c2), d$1(i2, c2);
    }
    return t3 ? t3(a2) : a2;
  };
}
var W$1 = (e2) => typeof e2 == "function", T$2 = (e2, t3) => W$1(e2) ? e2(t3) : e2;
var U$2 = (() => {
  let e2 = 0;
  return () => (++e2).toString();
})(), b$1 = (() => {
  let e2;
  return () => {
    if (e2 === void 0 && typeof window < "u") {
      let t3 = matchMedia("(prefers-reduced-motion: reduce)");
      e2 = !t3 || t3.matches;
    }
    return e2;
  };
})();
var Q$1 = 20;
var S$1 = /* @__PURE__ */ new Map(), X$1 = 1e3, $$1 = (e2) => {
  if (S$1.has(e2))
    return;
  let t3 = setTimeout(() => {
    S$1.delete(e2), u$2({ type: 4, toastId: e2 });
  }, X$1);
  S$1.set(e2, t3);
}, J$1 = (e2) => {
  let t3 = S$1.get(e2);
  t3 && clearTimeout(t3);
}, v$1 = (e2, t3) => {
  switch (t3.type) {
    case 0:
      return { ...e2, toasts: [t3.toast, ...e2.toasts].slice(0, Q$1) };
    case 1:
      return t3.toast.id && J$1(t3.toast.id), { ...e2, toasts: e2.toasts.map((r2) => r2.id === t3.toast.id ? { ...r2, ...t3.toast } : r2) };
    case 2:
      let { toast: o2 } = t3;
      return e2.toasts.find((r2) => r2.id === o2.id) ? v$1(e2, { type: 1, toast: o2 }) : v$1(e2, { type: 0, toast: o2 });
    case 3:
      let { toastId: s2 } = t3;
      return s2 ? $$1(s2) : e2.toasts.forEach((r2) => {
        $$1(r2.id);
      }), { ...e2, toasts: e2.toasts.map((r2) => r2.id === s2 || s2 === void 0 ? { ...r2, visible: false } : r2) };
    case 4:
      return t3.toastId === void 0 ? { ...e2, toasts: [] } : { ...e2, toasts: e2.toasts.filter((r2) => r2.id !== t3.toastId) };
    case 5:
      return { ...e2, pausedAt: t3.time };
    case 6:
      let a2 = t3.time - (e2.pausedAt || 0);
      return { ...e2, pausedAt: void 0, toasts: e2.toasts.map((r2) => ({ ...r2, pauseDuration: r2.pauseDuration + a2 })) };
  }
}, A$2 = [], P$1 = { toasts: [], pausedAt: void 0 }, u$2 = (e2) => {
  P$1 = v$1(P$1, e2), A$2.forEach((t3) => {
    t3(P$1);
  });
}, Y$1 = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, I$1 = (e2 = {}) => {
  let [t3, o2] = reactExports.useState(P$1);
  reactExports.useEffect(() => (A$2.push(o2), () => {
    let a2 = A$2.indexOf(o2);
    a2 > -1 && A$2.splice(a2, 1);
  }), [t3]);
  let s2 = t3.toasts.map((a2) => {
    var r2, c2;
    return { ...e2, ...e2[a2.type], ...a2, duration: a2.duration || ((r2 = e2[a2.type]) == null ? void 0 : r2.duration) || (e2 == null ? void 0 : e2.duration) || Y$1[a2.type], style: { ...e2.style, ...(c2 = e2[a2.type]) == null ? void 0 : c2.style, ...a2.style } };
  });
  return { ...t3, toasts: s2 };
};
var G$1 = (e2, t3 = "blank", o2) => ({ createdAt: Date.now(), visible: true, type: t3, ariaProps: { role: "status", "aria-live": "polite" }, message: e2, pauseDuration: 0, ...o2, id: (o2 == null ? void 0 : o2.id) || U$2() }), h$1 = (e2) => (t3, o2) => {
  let s2 = G$1(t3, e2, o2);
  return u$2({ type: 2, toast: s2 }), s2.id;
}, n$1 = (e2, t3) => h$1("blank")(e2, t3);
n$1.error = h$1("error");
n$1.success = h$1("success");
n$1.loading = h$1("loading");
n$1.custom = h$1("custom");
n$1.dismiss = (e2) => {
  u$2({ type: 3, toastId: e2 });
};
n$1.remove = (e2) => u$2({ type: 4, toastId: e2 });
n$1.promise = (e2, t3, o2) => {
  let s2 = n$1.loading(t3.loading, { ...o2, ...o2 == null ? void 0 : o2.loading });
  return e2.then((a2) => (n$1.success(T$2(t3.success, a2), { id: s2, ...o2, ...o2 == null ? void 0 : o2.success }), a2)).catch((a2) => {
    n$1.error(T$2(t3.error, a2), { id: s2, ...o2, ...o2 == null ? void 0 : o2.error });
  }), e2;
};
var Z$2 = (e2, t3) => {
  u$2({ type: 1, toast: { id: e2, height: t3 } });
}, ee$1 = () => {
  u$2({ type: 5, time: Date.now() });
}, D$1 = (e2) => {
  let { toasts: t3, pausedAt: o2 } = I$1(e2);
  reactExports.useEffect(() => {
    if (o2)
      return;
    let r2 = Date.now(), c2 = t3.map((i2) => {
      if (i2.duration === 1 / 0)
        return;
      let d2 = (i2.duration || 0) + i2.pauseDuration - (r2 - i2.createdAt);
      if (d2 < 0) {
        i2.visible && n$1.dismiss(i2.id);
        return;
      }
      return setTimeout(() => n$1.dismiss(i2.id), d2);
    });
    return () => {
      c2.forEach((i2) => i2 && clearTimeout(i2));
    };
  }, [t3, o2]);
  let s2 = reactExports.useCallback(() => {
    o2 && u$2({ type: 6, time: Date.now() });
  }, [o2]), a2 = reactExports.useCallback((r2, c2) => {
    let { reverseOrder: i2 = false, gutter: d2 = 8, defaultPosition: p2 } = c2 || {}, g2 = t3.filter((m2) => (m2.position || p2) === (r2.position || p2) && m2.height), E2 = g2.findIndex((m2) => m2.id === r2.id), x2 = g2.filter((m2, R2) => R2 < E2 && m2.visible).length;
    return g2.filter((m2) => m2.visible).slice(...i2 ? [x2 + 1] : [0, x2]).reduce((m2, R2) => m2 + (R2.height || 0) + d2, 0);
  }, [t3]);
  return { toasts: t3, handlers: { updateHeight: Z$2, startPause: ee$1, endPause: s2, calculateOffset: a2 } };
};
var oe$1 = h$2`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, re$1 = h$2`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, se$1 = h$2`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, _$1 = j$1("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oe$1} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${re$1} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e2) => e2.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${se$1} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`;
var ne$1 = h$2`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, V$2 = j$1("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e2) => e2.secondary || "#e0e0e0"};
  border-right-color: ${(e2) => e2.primary || "#616161"};
  animation: ${ne$1} 1s linear infinite;
`;
var pe$1 = h$2`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, de$1 = h$2`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, w$1 = j$1("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pe$1} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${de$1} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e2) => e2.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`;
var ue$1 = j$1("div")`
  position: absolute;
`, le$1 = j$1("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Te = h$2`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, fe$1 = j$1("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Te} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, M$1 = ({ toast: e2 }) => {
  let { icon: t3, type: o2, iconTheme: s2 } = e2;
  return t3 !== void 0 ? typeof t3 == "string" ? reactExports.createElement(fe$1, null, t3) : t3 : o2 === "blank" ? null : reactExports.createElement(le$1, null, reactExports.createElement(V$2, { ...s2 }), o2 !== "loading" && reactExports.createElement(ue$1, null, o2 === "error" ? reactExports.createElement(_$1, { ...s2 }) : reactExports.createElement(w$1, { ...s2 })));
};
var ye$1 = (e2) => `
0% {transform: translate3d(0,${e2 * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ge$1 = (e2) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e2 * -150}%,-1px) scale(.6); opacity:0;}
`, he$1 = "0%{opacity:0;} 100%{opacity:1;}", xe = "0%{opacity:1;} 100%{opacity:0;}", be$1 = j$1("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Se = j$1("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Ae = (e2, t3) => {
  let s2 = e2.includes("top") ? 1 : -1, [a2, r2] = b$1() ? [he$1, xe] : [ye$1(s2), ge$1(s2)];
  return { animation: t3 ? `${h$2(a2)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${h$2(r2)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, F$2 = reactExports.memo(({ toast: e2, position: t3, style: o2, children: s2 }) => {
  let a2 = e2.height ? Ae(e2.position || t3 || "top-center", e2.visible) : { opacity: 0 }, r2 = reactExports.createElement(M$1, { toast: e2 }), c2 = reactExports.createElement(Se, { ...e2.ariaProps }, T$2(e2.message, e2));
  return reactExports.createElement(be$1, { className: e2.className, style: { ...a2, ...o2, ...e2.style } }, typeof s2 == "function" ? s2({ icon: r2, message: c2 }) : reactExports.createElement(reactExports.Fragment, null, r2, c2));
});
m$1(reactExports.createElement);
var Ee = ({ id: e2, className: t3, style: o2, onHeightUpdate: s2, children: a2 }) => {
  let r2 = reactExports.useCallback((c2) => {
    if (c2) {
      let i2 = () => {
        let d2 = c2.getBoundingClientRect().height;
        s2(e2, d2);
      };
      i2(), new MutationObserver(i2).observe(c2, { subtree: true, childList: true, characterData: true });
    }
  }, [e2, s2]);
  return reactExports.createElement("div", { ref: r2, className: t3, style: o2 }, a2);
}, Re = (e2, t3) => {
  let o2 = e2.includes("top"), s2 = o2 ? { top: 0 } : { bottom: 0 }, a2 = e2.includes("center") ? { justifyContent: "center" } : e2.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: b$1() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t3 * (o2 ? 1 : -1)}px)`, ...s2, ...a2 };
}, ve$1 = u$3`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, O$1 = 16, Ie = ({ reverseOrder: e2, position: t3 = "top-center", toastOptions: o2, gutter: s2, children: a2, containerStyle: r2, containerClassName: c2 }) => {
  let { toasts: i2, handlers: d2 } = D$1(o2);
  return reactExports.createElement("div", { style: { position: "fixed", zIndex: 9999, top: O$1, left: O$1, right: O$1, bottom: O$1, pointerEvents: "none", ...r2 }, className: c2, onMouseEnter: d2.startPause, onMouseLeave: d2.endPause }, i2.map((p2) => {
    let g2 = p2.position || t3, E2 = d2.calculateOffset(p2, { reverseOrder: e2, gutter: s2, defaultPosition: t3 }), x2 = Re(g2, E2);
    return reactExports.createElement(Ee, { id: p2.id, key: p2.id, onHeightUpdate: d2.updateHeight, className: p2.visible ? ve$1 : "", style: x2 }, p2.type === "custom" ? T$2(p2.message, p2) : a2 ? a2(p2) : reactExports.createElement(F$2, { toast: p2, position: g2 }));
  }));
};
var _t$1 = n$1;
function padTo2Digits(num) {
  return num.toString().padStart(2, "0");
}
function formatDate(date2) {
  return [
    date2.getFullYear(),
    padTo2Digits(date2.getMonth() + 1),
    padTo2Digits(date2.getDate())
  ].join("-") + " " + [
    padTo2Digits(date2.getHours()),
    padTo2Digits(date2.getMinutes()),
    padTo2Digits(date2.getSeconds())
  ].join(":");
}
const OpenRegisterForm = ({ setOpen }) => {
  const navigate = useNavigate();
  const dispatch = useDispatch();
  const [selectedLocation, setSelectedLocation] = React.useState();
  const isOnline2 = useSelector((state) => state.loader.isOnline);
  const businessLocations = useSelector((state) => state.business_locations.businessLocations);
  const cashRegisterSchema2 = create$3$1().shape({
    amount: create$6().required("Cash in hand is required!"),
    location: create$6().required("Select a business location!")
  });
  const createRegisterOnline = async (payload) => {
    dispatch(setLoading(true));
    try {
      const resp = await APIService.createCashRegister(payload);
      localStorage.setItem("userId", resp?.data?.user_id);
      localStorage.setItem("businessId", resp?.data?.business_id);
    } catch (error) {
      console.log("CASH REG ONLINE ERROR ", error);
      dispatch(setLoading(false));
    }
  };
  const createRegisterOffline = async (payload) => {
    dispatch(setLoading(true));
    try {
      const db2 = await getDatabase(`${localStorage.getItem("dbPath")}`);
      await db2?.cash_registers.insert(payload);
      console.log(payload);
      dispatch(setLoading(false));
      _t$1.success("Cash register created successfully!");
    } catch (error) {
      console.log("REG OFFLINE ERROR ", error);
      dispatch(setLoading(false));
      _t$1.error(`${"Failed to create cash register!"}`);
    }
  };
  const formik = useFormik({
    initialValues: {
      amount: "",
      location: ""
    },
    validationSchema: cashRegisterSchema2,
    onSubmit: async (values22) => {
      const payload = {
        id: (/* @__PURE__ */ new Date()).getTime(),
        location_id: selectedLocation?.id,
        initial_amount: parseInt(
          values22.amount.toString().replace("₦", "").replace(",", "")
        ),
        status: "open",
        created_at: formatDate(/* @__PURE__ */ new Date())
      };
      if (isOnline2) {
        await createRegisterOnline(payload);
      }
      await createRegisterOffline(payload);
      setOpen(false);
      setTimeout(() => {
        navigate("/dashboard");
      }, 500);
    }
  });
  const { errors, values: values2, handleChange, handleSubmit, touched } = formik;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$3,
    {
      display: "flex",
      flexDirection: "column",
      justifyContent: "space-between",
      alignItems: "center",
      width: 360,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$3,
          {
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "stretch",
            width: "100%",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$3, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { gutterBottom: true, children: "Cash in Hand" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  NumericFormat,
                  {
                    placeholder: "Enter Amount",
                    variant: "filled",
                    prefix: "₦",
                    thousandSeparator: true,
                    value: values2.amount,
                    onChange: handleChange,
                    customInput: TextField$1,
                    error: Boolean(touched.amount && errors.amount),
                    name: "amount",
                    fullWidth: true,
                    helperText: touched.amount && errors.amount
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$3, { my: 2, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { gutterBottom: true, children: "Business Location" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  FormControl$1,
                  {
                    fullWidth: true,
                    error: Boolean(touched.location && errors.location),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Select$1,
                        {
                          fullWidth: true,
                          variant: "filled",
                          name: "location",
                          displayEmpty: true,
                          value: values2.location,
                          onChange: (e2) => {
                            handleChange(e2);
                            const filtered = businessLocations?.filter(
                              (item) => item.name === e2.target.value
                            );
                            if (filtered) {
                              setSelectedLocation(filtered[0]);
                              localStorage.setItem("locationId", filtered[0]?.location_id);
                              localStorage.setItem("location_id", filtered[0]?.id);
                            }
                          },
                          renderValue: (selected) => {
                            if (selected.length === 0) {
                              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "gray" }, children: "Select Location" });
                            }
                            return selected;
                          },
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { disabled: true, value: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("em", { children: "Select Location" }) }),
                            Array.isArray(businessLocations) ? businessLocations?.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: item?.name, children: item?.name }, index2)) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
                          ]
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText$1, { children: touched.location && errors.location })
                    ]
                  }
                )
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            onClick: () => handleSubmit(),
            variant: "contained",
            fullWidth: true,
            sx: { padding: 2, textTransform: "capitalize" },
            children: "Open Register"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
      ]
    }
  );
};
const AddCircleOutlineOutlined = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"
}), "AddCircleOutlineOutlined");
const ArrowBack = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"
}), "ArrowBack");
const ArrowDropDown = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m7 10 5 5 5-5z"
}), "ArrowDropDown");
const CallOutlined = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6.54 5c.06.89.21 1.76.45 2.59l-1.2 1.2c-.41-1.2-.67-2.47-.76-3.79h1.51m9.86 12.02c.85.24 1.72.39 2.6.45v1.49c-1.32-.09-2.59-.35-3.8-.75l1.2-1.19M7.5 3H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.49c0-.55-.45-1-1-1-1.24 0-2.45-.2-3.57-.57-.1-.04-.21-.05-.31-.05-.26 0-.51.1-.71.29l-2.2 2.2c-2.83-1.45-5.15-3.76-6.59-6.59l2.2-2.2c.28-.28.36-.67.25-1.02C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1z"
}), "CallOutlined");
const CheckCircleOutline = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16.59 7.58 10 14.17l-3.59-3.58L5 12l5 5 8-8zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "CheckCircleOutline");
const DoneAll = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m18 7-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41 6 19l1.41-1.41L1.83 12 .41 13.41z"
}), "DoneAll");
const Edit = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
}), "Edit");
const Info = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"
}), "Info");
const InsertChartOutlined = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4zm2.5 2.1h-15V5h15v14.1zm0-16.1h-15c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "InsertChartOutlined");
const KeyboardBackspace = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M21 11H6.83l3.58-3.59L9 6l-6 6 6 6 1.41-1.41L6.83 13H21z"
}), "KeyboardBackspace");
const PersonSearchOutlined = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zM4 18c.22-.72 3.31-2 6-2 0-.7.13-1.37.35-1.99C7.62 13.91 2 15.27 2 18v2h9.54c-.52-.58-.93-1.25-1.19-2H4zm15.43.02c.36-.59.57-1.28.57-2.02 0-2.21-1.79-4-4-4s-4 1.79-4 4 1.79 4 4 4c.74 0 1.43-.22 2.02-.57L20.59 22 22 20.59c-1.5-1.5-.79-.8-2.57-2.57zM16 18c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"
}), "PersonSearchOutlined");
const Search$1 = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
}), "Search");
const SupportAgentOutlined = createSvgIcon$1([/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M21 12.22C21 6.73 16.74 3 12 3c-4.69 0-9 3.65-9 9.28-.6.34-1 .98-1 1.72v2c0 1.1.9 2 2 2h1v-6.1c0-3.87 3.13-7 7-7s7 3.13 7 7V19h-8v2h8c1.1 0 2-.9 2-2v-1.22c.59-.31 1-.92 1-1.64v-2.3c0-.7-.41-1.31-1-1.62z"
}, "0"), /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
  cx: "9",
  cy: "13",
  r: "1"
}, "1"), /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
  cx: "15",
  cy: "13",
  r: "1"
}, "2"), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M18 11.03C17.52 8.18 15.04 6 12.05 6c-3.03 0-6.29 2.51-6.03 6.45 2.47-1.01 4.33-3.21 4.86-5.89 1.31 2.63 4 4.44 7.12 4.47z"
}, "3")], "SupportAgentOutlined");
const Visibility = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"
}), "Visibility");
const VisibilityOff = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78 3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"
}), "VisibilityOff");
const WidgetsOutlined = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m16.66 4.52 2.83 2.83-2.83 2.83-2.83-2.83 2.83-2.83M9 5v4H5V5h4m10 10v4h-4v-4h4M9 15v4H5v-4h4m7.66-13.31L11 7.34 16.66 13l5.66-5.66-5.66-5.65zM11 3H3v8h8V3zm10 10h-8v8h8v-8zm-10 0H3v8h8v-8z"
}), "WidgetsOutlined");
const Wifi = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m1 9 2 2c4.97-4.97 13.03-4.97 18 0l2-2C16.93 2.93 7.08 2.93 1 9zm8 8 3 3 3-3c-1.65-1.66-4.34-1.66-6 0zm-4-4 2 2c2.76-2.76 7.24-2.76 10 0l2-2C15.14 9.14 8.87 9.14 5 13z"
}), "Wifi");
const WifiOff = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M22.99 9C19.15 5.16 13.8 3.76 8.84 4.78l2.52 2.52c3.47-.17 6.99 1.05 9.63 3.7l2-2zm-4 4c-1.29-1.29-2.84-2.13-4.49-2.56l3.53 3.53.96-.97zM2 3.05 5.07 6.1C3.6 6.82 2.22 7.78 1 9l1.99 2c1.24-1.24 2.67-2.16 4.2-2.77l2.24 2.24C7.81 10.89 6.27 11.73 5 13v.01L6.99 15c1.36-1.36 3.14-2.04 4.92-2.06L18.98 20l1.27-1.26L3.29 1.79 2 3.05zM9 17l3 3 3-3c-1.65-1.66-4.34-1.66-6 0z"
}), "WifiOff");
const ClockInForm = () => {
  const [show, setShow] = React.useState(false);
  const [openDialog, setOpenDialog] = React.useState(false);
  const dispatch = useDispatch();
  const isOnline2 = useSelector((state) => state.loader.isOnline);
  const loginSchema = create$3$1().shape({
    username: create$6().required("Username is required!"),
    password: create$6().min(8, "Password too short. Min is 8 chars!").required("Password is required!")
  });
  const loginFromAPI = (values22) => {
    const payload = {
      grant_type: "password",
      client_id: 3,
      client_secret: "ih1OrYT8pHRDBuT0pFytbCp9tY9DSKXSc75HgAdn",
      username: values22.username,
      password: values22.password,
      scope: ""
    };
    APIService.clockIn(payload).then(async (resp) => {
      localStorage.setItem("accessToken", resp?.access_token);
      localStorage.setItem("refreshToken", resp?.refresh_token);
      localStorage.setItem("username", values22.username);
      localStorage.setItem("pass", values22.password);
      window.electron.sendAuthToMain(
        JSON.stringify({
          accessToken: resp?.access_token,
          refreshToken: resp?.refresh_token,
          username: values22.username,
          password: values22.password
        })
      );
      dispatch(setLoading(false));
      setOpenDialog(true);
    }).catch((error) => {
      dispatch(setLoading(false));
      _t$1.error(
        `${error?.response?.data?.message || error?.message || "Check your internet connection"}`
      );
      console.error("ERR ==>> ", error);
    });
  };
  const loginFromDB = async (username, password) => {
    dispatch(setLoading(true));
    const authData = await window.electron.auth();
    const parsedAuth = JSON.parse(authData);
    const usrname = localStorage.getItem("username") ?? parsedAuth?.username;
    const pass = localStorage.getItem("pass") ?? parsedAuth?.password;
    if (usrname === username && pass === password) {
      window.electron.sendAuthToMain(
        JSON.stringify({
          accessToken: null,
          refreshToken: null,
          username: values2.username,
          password: values2.password
        })
      );
      setTimeout(() => {
        localStorage.setItem("username", values2.username);
        localStorage.setItem("pass", values2.password);
        dispatch(setLoading(false));
        setOpenDialog(true);
      }, 5e3);
    } else {
      _t$1.error("Incorrect login credentials");
      dispatch(setLoading(false));
    }
  };
  const formik = useFormik({
    initialValues: {
      username: "",
      password: ""
    },
    validationSchema: loginSchema,
    onSubmit: (values22) => {
      dispatch(setLoading(true));
      if (isOnline2) {
        loginFromAPI(values22);
      } else {
        loginFromDB(values22.username, values22.password);
      }
    }
  });
  const { errors, values: values2, handleChange, handleSubmit, touched } = formik;
  const renderDialog = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      p: 4,
      display: "flex",
      flexDirection: "column",
      justifyContent: "space-evenly",
      alignItems: "center",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontWeight: 800, fontSize: 26, gutterBottom: true, children: "Open Register" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(OpenRegisterForm, { setOpen: setOpenDialog })
      ]
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      display: "flex",
      flexDirection: "column",
      justifyContent: "space-between",
      alignItems: "center",
      width: "60%",
      height: "60%",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CustomDialog,
          {
            open: openDialog,
            setOpen: setOpenDialog,
            content: renderDialog
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { alignItems: "center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 36, fontWeight: 800, children: "Welcome Back 👋🏽" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 24, fontWeight: 400, textAlign: "center", children: "Please clock In" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "stretch",
            width: "100%",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { gutterBottom: true, children: "Username" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField$1,
                  {
                    placeholder: "Enter your username",
                    variant: "filled",
                    value: values2.username,
                    onChange: handleChange,
                    error: Boolean(touched.username && errors.username),
                    name: "username",
                    fullWidth: true,
                    helperText: touched.username && errors.username
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { gutterBottom: true, children: "Password" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField$1,
                  {
                    variant: "filled",
                    placeholder: "Enter your password",
                    value: values2.password,
                    type: show ? "text" : "password",
                    onChange: handleChange,
                    error: Boolean(touched.password && errors.password),
                    name: "password",
                    fullWidth: true,
                    helperText: touched.password && errors.password,
                    InputProps: {
                      endAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setShow(!show), children: show ? /* @__PURE__ */ jsxRuntimeExports.jsx(Visibility, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(VisibilityOff, {}) })
                    }
                  }
                )
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            onClick: () => handleSubmit(),
            variant: "contained",
            fullWidth: true,
            sx: { padding: 2, textTransform: "capitalize" },
            children: "start shift"
          }
        )
      ]
    }
  );
};
const LoginScreen = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, height: "100vh", width: "100vw", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        bgcolor: "#C6D2DD",
        height: "100%",
        display: "flex",
        flexDirection: "column",
        justifyContent: "stretch",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: brandLogo, alt: "", width: 128, style: { padding: 16 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box$1,
            {
              flexGrow: 1,
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              alignItems: "center",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: image$1, alt: "", width: "60%", style: { padding: 16 } })
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box$1,
      {
        bgcolor: "white",
        height: "100%",
        display: "flex",
        flexDirection: "column",
        justifyContent: "stretch",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box$1,
          {
            flexGrow: 1,
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClockInForm, {})
          }
        )
      }
    ) })
  ] });
};
const initialState$7 = {
  currentCustomer: null,
  customers: [],
  customerMeta: null
};
const customerSlice = createSlice({
  name: "customers",
  initialState: initialState$7,
  reducers: {
    setCurrentCustomer: (state, action) => {
      state.currentCustomer = action.payload;
    },
    setCustomers: (state, action) => {
      state.customers = action.payload;
    },
    setCustomerMeta: (state, action) => {
      state.customerMeta = action.payload;
    }
  }
});
const { setCurrentCustomer, setCustomerMeta, setCustomers } = customerSlice.actions;
const customerReducer = customerSlice.reducer;
function CustomerDropdown({
  setAnchorEl
}) {
  const theme2 = useTheme();
  const dispatch = useDispatch();
  const currentCustomer = useSelector(
    (state) => state.customers.currentCustomer
  );
  const customers = useSelector(
    (state) => state.customers.customers
  );
  const [current, setCurrent] = React.useState();
  const [filteredCustomer, setFilteredCustomers] = React.useState(customers);
  React.useEffect(() => {
    if (currentCustomer) {
      setCurrent({
        email: currentCustomer?.email,
        name: currentCustomer?.name
      });
    }
  }, [currentCustomer]);
  const handleFilter = (e2) => {
    const filtered = customers?.filter(
      (item) => item.name.toLowerCase().includes(`${e2.target.value}`.toLowerCase())
    );
    setFilteredCustomers(filtered);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { pb: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        pb: 2,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 20, fontWeight: 700, children: "Customers" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setAnchorEl(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$e, {}) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextField$1,
      {
        onChange: handleFilter,
        fullWidth: true,
        size: "small",
        placeholder: "Search Customers",
        InputProps: {
          style: { backgroundColor: "#ECF0F4B2" },
          disableUnderline: true,
          startAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(Search$1, { sx: { color: "gray" } })
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { height: "40vh", sx: { overflowY: "scroll", overflowX: "hidden" }, children: filteredCustomer.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        mt: 2,
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        fullWidth: true,
        bgcolor: current?.email === item?.email && current.name === item?.name ? theme2.palette.primary.light : "transparent",
        component: Button$1,
        onClick: () => {
          dispatch(setCurrentCustomer(item));
          setAnchorEl(null);
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              width: "100%",
              display: "flex",
              flexDirection: "column",
              justifyContent: "start",
              alignItems: "start",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Box$1,
                  {
                    width: "100%",
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Typography$1,
                        {
                          fontSize: 14,
                          textTransform: "capitalize",
                          justifyContent: "start",
                          color: "#000000",
                          children: `${item?.name}`
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Typography$1,
                        {
                          fontSize: 14,
                          textTransform: "capitalize",
                          justifyContent: "start",
                          color: "#000000",
                          children: `${item?.contact_id}`
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Box$1,
                  {
                    display: item?.mobile ? "flex" : "none",
                    flexDirection: "row",
                    justifyContent: "start",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(CallOutlined, { fontSize: "small" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Typography$1,
                        {
                          px: 1,
                          fontSize: 14,
                          textTransform: "capitalize",
                          justifyContent: "start",
                          color: "#000000",
                          children: item?.mobile
                        }
                      )
                    ]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography$1,
            {
              fontSize: 14,
              textTransform: "capitalize",
              justifyContent: "start",
              color: "#000000",
              children: item?._data?.id
            }
          )
        ]
      },
      index2
    )) })
  ] });
}
var Remove = {};
var _interopRequireDefault$d = interopRequireDefaultExports;
Object.defineProperty(Remove, "__esModule", {
  value: true
});
var default_1$d = Remove.default = void 0;
var _createSvgIcon$d = _interopRequireDefault$d(requireCreateSvgIcon());
var _jsxRuntime$d = jsxRuntimeExports;
var _default$d = (0, _createSvgIcon$d.default)(/* @__PURE__ */ (0, _jsxRuntime$d.jsx)("path", {
  d: "M19 13H5v-2h14v2z"
}), "Remove");
default_1$d = Remove.default = _default$d;
var Add = {};
var _interopRequireDefault$c = interopRequireDefaultExports;
Object.defineProperty(Add, "__esModule", {
  value: true
});
var default_1$c = Add.default = void 0;
var _createSvgIcon$c = _interopRequireDefault$c(requireCreateSvgIcon());
var _jsxRuntime$c = jsxRuntimeExports;
var _default$c = (0, _createSvgIcon$c.default)(/* @__PURE__ */ (0, _jsxRuntime$c.jsx)("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
}), "Add");
default_1$c = Add.default = _default$c;
var Description = {};
var _interopRequireDefault$b = interopRequireDefaultExports;
Object.defineProperty(Description, "__esModule", {
  value: true
});
var default_1$b = Description.default = void 0;
var _createSvgIcon$b = _interopRequireDefault$b(requireCreateSvgIcon());
var _jsxRuntime$b = jsxRuntimeExports;
var _default$b = (0, _createSvgIcon$b.default)(/* @__PURE__ */ (0, _jsxRuntime$b.jsx)("path", {
  d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"
}), "Description");
default_1$b = Description.default = _default$b;
var DeleteForever = {};
var _interopRequireDefault$a = interopRequireDefaultExports;
Object.defineProperty(DeleteForever, "__esModule", {
  value: true
});
var default_1$a = DeleteForever.default = void 0;
var _createSvgIcon$a = _interopRequireDefault$a(requireCreateSvgIcon());
var _jsxRuntime$a = jsxRuntimeExports;
var _default$a = (0, _createSvgIcon$a.default)(/* @__PURE__ */ (0, _jsxRuntime$a.jsx)("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"
}), "DeleteForever");
default_1$a = DeleteForever.default = _default$a;
function OrderCard({ order: order2, rxDoc, index: index2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      py: 1,
      width: "100%",
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "stretch",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { pr: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: order2?.image, width: 56, height: 56, alt: "" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            flex: 1,
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "start",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 16, fontWeight: 600, children: order2?.title }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$1,
                {
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "start",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Box$1,
                      {
                        display: "flex",
                        flexDirection: "row",
                        justifyContent: "center",
                        alignItems: "center",
                        bgcolor: "#C6D2DD",
                        width: 34,
                        height: 36,
                        sx: { cursor: "pointer" },
                        onClick: async () => {
                          if (rxDoc?._data.items[index2].quantity > 1) {
                            await rxDoc?.update({
                              $set: {
                                [`items.${index2}.quantity`]: rxDoc.items[index2].quantity - 1
                              }
                            });
                          }
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$d, {})
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { p: 2, children: rxDoc.items[index2].quantity }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Box$1,
                      {
                        display: "flex",
                        flexDirection: "row",
                        justifyContent: "center",
                        alignItems: "center",
                        bgcolor: "#C6D2DD",
                        width: 34,
                        height: 36,
                        sx: { cursor: "pointer" },
                        onClick: async () => {
                          await rxDoc?.update({
                            $set: {
                              [`items.${index2}.quantity`]: rxDoc.items[index2].quantity + 1
                            }
                          });
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$c, {})
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            display: "flex",
            flexDirection: "column",
            justifyContent: "space-between",
            alignItems: "start",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                NumericFormat,
                {
                  style: { fontSize: 15, fontFamily: "sans-serif" },
                  value: parseInt(order2?.unitPrice).toFixed(2),
                  displayType: "text",
                  thousandSeparator: true,
                  prefix: "₦"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$1,
                {
                  marginTop: -6,
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "start",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { px: 1, sx: { cursor: "pointer" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$b, { sx: { color: "grey" } }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Box$1,
                      {
                        px: 1,
                        sx: { cursor: "pointer" },
                        onClick: async () => {
                          const re2 = rxDoc?._data?.items?.filter(
                            (item) => item.name !== rxDoc.items[index2]?.name
                          );
                          await rxDoc?.update({
                            $set: {
                              [`items`]: re2
                            }
                          });
                        },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$a, { sx: { color: "grey" } })
                      }
                    )
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
}
const empty = "" + new URL("empty-b919f247.png", import.meta.url).href;
function Orders() {
  const [cartList, setCartList] = React.useState([]);
  const [updater, setUpdater] = React.useState(false);
  const [data, setData] = React.useState([]);
  async function getCarts() {
    try {
      const db2 = await getDatabase(`${localStorage.getItem("dbPath")}`);
      db2?.carts.find().$.subscribe(function(mCarts) {
        if (!mCarts) {
          console.log("EMPTY DATA ");
          return;
        }
        setData(mCarts);
        setUpdater(!updater);
        const content2 = mCarts.map((cart) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              py: 1,
              display: "flex",
              flexDirection: "column",
              justifyContent: "start",
              alignItems: "start",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { gutterBottom: true, children: `Order ${cart?._data?.id}` }),
                cart?._data?.items?.map((el2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(OrderCard, { order: el2, rxDoc: cart, index: index2 }, index2))
              ]
            }
          );
        });
        setCartList(content2);
      });
    } catch (error) {
      console.log("CATCH ERROR ::: ", error);
    }
  }
  React.useEffect(() => {
    getCarts();
  }, []);
  React.useEffect(() => {
    if (data) {
      const organizedCart = data?.map((item) => {
        return {
          id: item?._data?.id,
          items: item?._data?.items,
          timestamp: item?._data?.timestamp
        };
      });
      window.electron.sendCartDataToMain(
        JSON.stringify([...organizedCart])
      );
    }
  }, [data, updater]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { px: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    cartList?.length < 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: empty, alt: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { mt: -2, textAlign: "center", children: "No orders found" })
        ]
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { children: cartList })
  ] });
}
function DraftCard({ data }) {
  const pluralizer = (num) => {
    return num > 1 ? "items" : "item";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      width: "100%",
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "#8795A0", fontSize: 14, children: "#123" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            px: 1,
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "start",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Typography$1,
                {
                  fontWeight: 700,
                  fontSize: 16,
                  color: "#000000",
                  children: data?.customer?.name
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "#8795A0", fontSize: 14, children: `${data?.items?.length}${pluralizer(data?.items?.length)}` })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: `${new Date(
          data?.timestamp
        ).toLocaleDateString()}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          NumericFormat,
          {
            style: {
              fontSize: 18,
              color: "#313A43",
              fontWeight: "700",
              fontFamily: "sans-serif"
            },
            value: data?.amount.toFixed(2),
            displayType: "text",
            thousandSeparator: true,
            prefix: "₦"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "end",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { cursor: "pointer" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Edit, { sx: { color: "grey" } }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { py: 1, sx: { cursor: "pointer" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$a, { sx: { color: "grey" } }) })
            ]
          }
        )
      ]
    }
  );
}
function Drafts() {
  const [draftsList, setDraftsList] = React.useState([]);
  const [updater, setUpdater] = React.useState(false);
  const [data, setData] = React.useState([]);
  async function getDrafts() {
    try {
      const db2 = await getDatabase(localStorage.getItem("dbPath") ?? "");
      db2?.drafts.find().$.subscribe(function(drafts) {
        if (!drafts) {
          console.log("EMPTY DATA ");
          return;
        }
        console.log("DRAFTS OBS fired");
        console.log("DRAFTS RXDB DATA :: ", drafts);
        setData(drafts);
        setUpdater(!updater);
        const content2 = drafts.map((draft) => {
          console.log("ELEM", draft);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box$1,
            {
              py: 1,
              display: "flex",
              flexDirection: "column",
              justifyContent: "start",
              alignItems: "start",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(DraftCard, { data: draft?._data })
            }
          );
        });
        setDraftsList(content2);
      });
    } catch (error) {
      console.log("CATCH ERROR ::: ", error);
    }
  }
  React.useEffect(() => {
    getDrafts();
  }, []);
  React.useEffect(() => {
    if (data) {
      const organizedDrafts = data?.map((item) => {
        return {
          id: item?._data?.id,
          amount: item?._data?.amount,
          customer: item?._data?.customer,
          items: item?._data?.items,
          timestamp: item?._data?.timestamp
        };
      });
      console.log("DRAFTS DATA :: == :: ", organizedDrafts);
      window.electron.sendDraftDataToMain(
        JSON.stringify(organizedDrafts)
      );
    }
  }, [data]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { px: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 21, fontWeight: 800, color: "black", gutterBottom: true, children: "Drafts" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { children: draftsList })
  ] });
}
const initialState$6 = {
  currentBusinessLocation: null,
  businessLocations: [],
  businessLocationsMeta: null
};
const businessLocationSlice = createSlice({
  name: "business_locations",
  initialState: initialState$6,
  reducers: {
    setCurrentBusinessLocation: (state, action) => {
      state.currentBusinessLocation = action.payload;
    },
    setBusinessLocations: (state, action) => {
      state.businessLocations = action.payload;
    },
    setBusinessLocationsMeta: (state, action) => {
      state.businessLocationsMeta = action.payload;
    }
  }
});
const { setCurrentBusinessLocation, setBusinessLocations, setBusinessLocationsMeta } = businessLocationSlice.actions;
const businessLocationsReducer = businessLocationSlice.reducer;
function AccountForm({
  setOpen,
  currentCustomer,
  data,
  selectedMethod,
  subTotal,
  tax,
  total
}) {
  const [bank, setBank] = React.useState("");
  const [accNum, setAccNum] = React.useState("");
  const [accName, setAccName] = React.useState("");
  const navigate = useNavigate();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      px: 4,
      pb: 4,
      pt: 2,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      width: 400,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography$1,
          {
            textAlign: "center",
            mb: 4,
            fontWeight: 900,
            fontSize: 24,
            gutterBottom: true,
            children: "Account Number"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 12, sm: 6, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              display: "flex",
              flexDirection: "column",
              justifyContent: "start",
              alignItems: "start",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Account Number" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField$1,
                  {
                    name: "accName",
                    variant: "filled",
                    placeholder: "e.g 20003489493",
                    type: "number",
                    fullWidth: true,
                    onChange: (e2) => {
                      setAccNum(e2?.target?.value);
                    },
                    size: "small",
                    InputProps: {
                      disableUnderline: true,
                      style: {
                        backgroundColor: "#eee",
                        borderRadius: 1,
                        height: 50
                      }
                    },
                    helperText: ""
                  }
                )
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 12, sm: 6, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              display: "flex",
              flexDirection: "column",
              justifyContent: "start",
              alignItems: "start",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Bank" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField$1,
                  {
                    name: "bank",
                    variant: "filled",
                    placeholder: "e.g First Bank",
                    type: "text",
                    fullWidth: true,
                    label: "",
                    onChange: (e2) => {
                      setBank(e2?.target?.value);
                    },
                    size: "small",
                    InputProps: {
                      disableUnderline: true,
                      style: {
                        backgroundColor: "#eee",
                        borderRadius: 1,
                        height: 50
                      }
                    }
                  }
                )
              ]
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { container: true, spacing: 2, mt: 0.25, mb: 2.5, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 12, sm: 6, md: 6, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "start",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Account Name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField$1,
                {
                  name: "accName",
                  variant: "filled",
                  placeholder: "e.g DrugStore Limited",
                  type: "text",
                  fullWidth: true,
                  onChange: (e2) => {
                    setAccName(e2?.target?.value);
                  },
                  size: "small",
                  InputProps: {
                    disableUnderline: true,
                    style: {
                      backgroundColor: "#eee",
                      borderRadius: 1,
                      height: 50
                    }
                  }
                }
              )
            ]
          }
        ) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box$1,
          {
            pt: 3,
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "stretch",
            width: 256,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                variant: "contained",
                sx: { textTransform: "capitalize", color: "white", p: 2, mb: 1 },
                onClick: async () => {
                  setOpen(false);
                  navigate("/dashboard/paymentmethod", {
                    state: {
                      paymentMethod: selectedMethod,
                      tax,
                      total,
                      subTotal,
                      customer: currentCustomer,
                      orderNo: `${data?._data?.id}`,
                      itemsOrdered: data?._data?.items,
                      customerName: `${currentCustomer?.first_name ?? currentCustomer?.name} ${currentCustomer?.last_name ?? ""}`,
                      bank,
                      accName,
                      accNum
                    }
                  });
                },
                children: "Save"
              }
            )
          }
        )
      ]
    }
  );
}
function OrderSummary() {
  const [subTotal, setSubTotal] = React.useState(0);
  const [tax, setTax] = React.useState(0);
  const [total, setTotal] = React.useState(0);
  const [data, setData] = React.useState([]);
  const [open2, setOpen] = React.useState(false);
  const [openAccount, setOpenAccount] = React.useState(false);
  const [openCustomer, setOpenCustomer] = React.useState(false);
  const [isSelected, setSelected] = React.useState(false);
  const [selectedIndex, setSelectedIndex] = React.useState(0);
  const [selectedMethod, setSelectedMethod] = React.useState(null);
  const [currentBusinessLocation, setCurrBusinessLocation] = React.useState([]);
  const dispatch = useDispatch();
  const currentCustomer = useSelector(
    (state) => state.customers.currentCustomer
  );
  const customers = useSelector(
    (state) => state.customers.customers
  );
  const dbasePath = useSelector((state) => state.database.dbasePath);
  const businessLocations = useSelector(
    (state) => state.business_locations.businessLocations
  );
  const navigate = useNavigate();
  const theme2 = useTheme();
  async function getCarts() {
    try {
      const db2 = await getDatabase(dbasePath);
      db2?.carts.find().sort({
        id: "asc"
      }).$.subscribe(function(heroes) {
        if (!heroes) {
          return;
        }
        setData(heroes[0]);
        let summer = 0, taxer = 0;
        heroes.forEach((elem) => {
          elem?._data.items?.forEach((el2) => {
            summer = summer + el2?.quantity * el2?.unitPrice;
            taxer = taxer + (el2?.priceWithTax - el2?.unitPrice);
          });
        });
        setSubTotal(summer);
        setTax(taxer);
        setTotal(taxer + summer);
      });
    } catch (error) {
      console.log("CATCH ERROR ::: ", error);
    }
  }
  React.useEffect(() => {
    if (businessLocations) {
      const filtered = businessLocations?.filter(
        (item) => item?.location_id === localStorage.getItem("locationId")
      );
      setCurrBusinessLocation(filtered[0]);
      dispatch(setCurrentBusinessLocation(filtered[0]));
    }
  }, [businessLocations, dispatch]);
  React.useEffect(() => {
    getCarts();
  }, []);
  const checkCustomer = () => {
    if (!currentCustomer) {
      setOpenCustomer(true);
    } else {
      saveDraft();
    }
  };
  const saveDraft = async () => {
    try {
      dispatch(setLoading(true));
      const db2 = await getDatabase(`${localStorage.getItem("dbPath")}`);
      const draftObj = {
        id: (/* @__PURE__ */ new Date()).getTime().toString(),
        customer: currentCustomer,
        amount: total,
        items: data?._data.items,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      const resp = await db2?.drafts.insert(draftObj);
      dispatch(setLoading(false));
      await db2?.carts.remove();
      window.electron.sendCartDataToMain(JSON?.parse("[]"));
      n$1.success("Successfully saved as draft. ", {
        duration: 8e3,
        position: "bottom-center",
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(
          CheckCircleOutline,
          {
            fontSize: "small",
            sx: { color: theme2.palette.success.dark }
          }
        ),
        iconTheme: {
          primary: theme2.palette.success.main,
          secondary: theme2.palette.success.light
        },
        style: {
          backgroundColor: theme2.palette.success.light,
          border: "1px solid",
          borderColor: theme2.palette.success.dark,
          paddingLeft: 21,
          paddingRight: 21,
          paddingTop: 8,
          paddingBottom: 8
        }
      });
      console.log("ADDED DRAFTS RESPONSE >> ", resp);
    } catch (error) {
      console.log(error);
    }
  };
  const renderConfirmDeleteOrder = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      p: 2,
      display: "flex",
      flexDirection: "column",
      justifyContent: "start",
      alignItems: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: ` Are you sure you want to delete this order?` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { gutterBottom: true, children: ` Action can not be undone.` }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            pt: 2,
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "stretch",
            width: "100%",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "contained",
                  sx: { textTransform: "capitalize", color: "white", p: 1, mb: 1 },
                  onClick: async () => {
                    const db2 = await getDatabase(`${localStorage.getItem("dbPath")}`);
                    await db2?.carts.remove();
                    window.electron.sendCartDataToMain(JSON?.parse("[]"));
                    setOpen(false);
                  },
                  children: "delete"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  sx: { textTransform: "capitalize", color: "black", p: 1 },
                  onClick: () => {
                    setOpen(false);
                  },
                  children: "Close"
                }
              )
            ]
          }
        )
      ]
    }
  );
  const renderSelectCustomer = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      px: 4,
      pt: 5,
      pb: 4,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      width: 400,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Typography$1,
          {
            textAlign: "center",
            my: 3,
            fontWeight: 900,
            fontSize: 24,
            gutterBottom: true,
            children: "Enter Customer Name"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Autocomplete$1,
          {
            id: "free-solo-demo",
            freeSolo: true,
            fullWidth: true,
            sx: { mb: 1.5 },
            onChange: (e2, val) => {
              const filtered = customers?.filter((elem) => elem?.name === val);
              dispatch(setCurrentCustomer(filtered[0]));
            },
            options: customers?.map((option) => option.name),
            renderInput: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField$1,
              {
                ...params,
                placeholder: "Type customer name here",
                fullWidth: true
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            pt: 3,
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "stretch",
            width: 256,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "contained",
                  sx: { textTransform: "capitalize", color: "white", p: 2, mb: 1 },
                  onClick: async () => {
                    setOpenCustomer(false);
                    saveDraft();
                  },
                  children: "Save Draft"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  sx: { textTransform: "capitalize", color: "black", p: 2 },
                  onClick: () => {
                    setOpenCustomer(false);
                  },
                  children: "Skip"
                }
              )
            ]
          }
        )
      ]
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card$1, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CustomDialog,
      {
        open: open2,
        setOpen,
        content: renderConfirmDeleteOrder
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CustomDialog,
      {
        open: openAccount,
        setOpen: setOpenAccount,
        content: /* @__PURE__ */ jsxRuntimeExports.jsx(
          AccountForm,
          {
            setOpen: setOpenAccount,
            currentCustomer,
            data,
            selectedMethod,
            subTotal,
            tax,
            total
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CustomDialog,
      {
        showClose: false,
        open: openCustomer,
        setOpen: setOpenCustomer,
        content: renderSelectCustomer
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        display: "flex",
        flexDirection: "column",
        justifyContent: "space-evenly",
        alignItems: "stretch",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Grid$1,
            {
              px: 2,
              pt: 4,
              container: true,
              spacing: 2,
              justifyContent: "space-between",
              alignItems: "center",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Grid$1,
                  {
                    item: true,
                    sm: 6,
                    md: 6,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "space-between",
                    alignItems: "stretch",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Box$1,
                        {
                          display: "flex",
                          flexDirection: "row",
                          justifyContent: "space-between",
                          alignItems: "center",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Sub Total" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              NumericFormat,
                              {
                                style: { fontSize: 15, fontFamily: "sans-serif" },
                                value: subTotal.toFixed(2),
                                displayType: "text",
                                thousandSeparator: true,
                                prefix: "₦"
                              }
                            )
                          ]
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Box$1,
                        {
                          display: "flex",
                          flexDirection: "row",
                          justifyContent: "space-between",
                          alignItems: "center",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Total Discount" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "₦0.00" })
                          ]
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Grid$1,
                  {
                    item: true,
                    sm: 6,
                    md: 6,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "space-between",
                    alignItems: "stretch",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Box$1,
                        {
                          display: "flex",
                          flexDirection: "row",
                          justifyContent: "space-between",
                          alignItems: "center",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Tax" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              NumericFormat,
                              {
                                style: { fontSize: 15, fontFamily: "sans-serif" },
                                value: tax.toFixed(2),
                                displayType: "text",
                                thousandSeparator: true,
                                prefix: "₦"
                              }
                            )
                          ]
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Box$1,
                        {
                          display: "flex",
                          flexDirection: "row",
                          justifyContent: "space-between",
                          alignItems: "center",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Total" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              NumericFormat,
                              {
                                style: { fontSize: 15, fontFamily: "sans-serif" },
                                value: total.toFixed(2),
                                displayType: "text",
                                thousandSeparator: true,
                                prefix: "₦"
                              }
                            )
                          ]
                        }
                      )
                    ]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              py: 2,
              px: 2,
              display: "flex",
              flexDirection: "column",
              justifyContent: "start",
              alignItems: "stretch",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { gutterBottom: true, children: "Payment Method" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Box$1,
                  {
                    width: "100%",
                    height: 56,
                    overflow: "scroll",
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "start",
                    alignItems: "center",
                    sx: {
                      overflowX: "auto",
                      overflowY: "hidden",
                      scrollBehavior: "smooth",
                      scrollbarColor: "red blue"
                    },
                    children: currentBusinessLocation?.payment_methods?.map(
                      (item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { p: 2, borderRadius: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Box$1,
                        {
                          bgcolor: selectedIndex === index2 ? theme2.palette.primary.light : "#ECF0F4",
                          boxShadow: selectedIndex === index2 ? "rgba(50, 50, 93, 0.25) 0px 50px 100px -20px, rgba(0, 0, 0, 0.3) 0px 30px 60px -30px, rgba(10, 37, 64, 0.35) 0px -2px 6px 0px inset" : "none",
                          display: "flex",
                          borderRadius: 2,
                          p: 3,
                          flexDirection: "column",
                          justifyContent: "center",
                          alignItems: "center",
                          component: Button$1,
                          onClick: () => {
                            console.log("CURRENT PAYMENT METHOD ::  ", item);
                            setSelectedIndex(index2);
                            setSelectedMethod(item);
                            setSelected(true);
                          },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Typography$1,
                            {
                              fontSize: 13,
                              textAlign: "center",
                              lineHeight: 1,
                              children: item?.label
                            }
                          )
                        }
                      ) }, index2)
                    )
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              px: 2,
              pb: 2,
              display: "flex",
              flexDirection: "row",
              justifyContent: "space-between",
              alignItems: "center",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Box$1,
                  {
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "start",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button$1,
                        {
                          disabled: !isSelected || !data,
                          variant: "contained",
                          sx: { p: 1, width: 156 },
                          onClick: () => {
                            if (!currentCustomer) {
                              n$1.error("Select customer first!", {
                                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, { color: "error" }),
                                style: {
                                  backgroundColor: "#fadcdcf6",
                                  color: theme2.palette.error.dark,
                                  paddingLeft: 24,
                                  paddingRight: 24,
                                  paddingTop: 16,
                                  paddingBottom: 16,
                                  fontSize: 21
                                },
                                position: "top-center"
                              });
                            } else {
                              if (`${selectedMethod?.name}`.toLowerCase().includes("transfer")) {
                                setOpenAccount(true);
                              } else {
                                navigate("/dashboard/paymentmethod", {
                                  state: {
                                    paymentMethod: selectedMethod,
                                    tax,
                                    total,
                                    subTotal,
                                    customer: currentCustomer,
                                    orderNo: `${data?._data?.id}`,
                                    itemsOrdered: data?._data?.items,
                                    customerName: `${currentCustomer?.first_name ?? currentCustomer?.name} ${currentCustomer?.last_name ?? ""}`
                                  }
                                });
                              }
                            }
                          },
                          children: "Place Order"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button$1,
                        {
                          disabled: !data,
                          variant: "contained",
                          sx: {
                            p: 1,
                            mx: 2,
                            width: 96,
                            bgcolor: "#CCE4F2",
                            color: "black"
                          },
                          onClick: checkCustomer,
                          children: "Save Draft"
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$1,
                  {
                    disabled: !data,
                    variant: "text",
                    sx: { p: 1, width: 156 },
                    onClick: async () => {
                      setOpen(true);
                    },
                    children: "Delete Order"
                  }
                )
              ]
            }
          )
        ]
      }
    )
  ] });
}
function CustomTabPanel$1(props) {
  const { children, value, index: index2, ...other } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      role: "tabpanel",
      hidden: value !== index2,
      id: `simple-tabpanel-${index2}`,
      "aria-labelledby": `simple-tab-${index2}`,
      ...other,
      children: value === index2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { p: 0 }, children })
    }
  );
}
const StyledTabs$3 = styled$1((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Tabs$1,
  {
    ...props,
    TabIndicatorProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "MuiTabs-indicatorSpan" }) }
  }
))({
  "& .MuiTabs-indicator": {
    display: "flex",
    justifyContent: "center",
    backgroundColor: "transparent"
  },
  "& .MuiTabs-indicatorSpan": {
    maxWidth: 0,
    width: "100%",
    backgroundColor: "#635ee7"
  }
});
const StyledTab$2 = styled$1((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tab$1, { disableRipple: true, ...props }))(({ theme: theme2 }) => ({
  textTransform: "none",
  fontWeight: theme2.typography.fontWeightRegular,
  fontSize: 16,
  marginRight: theme2.spacing(1),
  fontFamily: "Inter",
  paddingLeft: 16,
  paddingRight: 16,
  height: 16,
  color: "grey",
  "&.Mui-selected": {
    color: "#000",
    fontWeight: theme2.typography.fontWeightBold,
    backgroundColor: "#DAE1E7",
    fontFamily: "Inter",
    borderRadius: 10,
    paddingLeft: 16,
    paddingRight: 16
  },
  "&.Mui-focusVisible": {
    backgroundColor: "gray"
  }
}));
function RightHandSide() {
  const [value2, setValue2] = React.useState(0);
  const [anchorEl, setAnchorEl] = React.useState(null);
  const currentCustomer = useSelector(
    (state) => state.customers.currentCustomer
  );
  const handleClick = (event) => {
    setAnchorEl(anchorEl ? null : event.currentTarget);
  };
  const open2 = Boolean(anchorEl);
  const id2 = open2 ? "simple-popper" : void 0;
  const handleChange2 = (event, newValue) => {
    setValue2(newValue);
    console.log("EVENT N", event);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      height: "100vh",
      borderLeft: 1,
      borderColor: "#bbb",
      display: "flex",
      flexDirection: "column",
      justifyContent: "space-between",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            AppBar$1,
            {
              sx: {
                bgcolor: "#ECF0F4",
                zIndex: 10,
                maxWidth: "40.5%",
                right: 2,
                pl: 1,
                pr: 4,
                pb: 2
              },
              elevation: 0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  StyledTabs$3,
                  {
                    value: value2,
                    onChange: handleChange2,
                    "aria-label": "styled tabs example2",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTab$2, { label: "Orders" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTab$2, { label: "Drafts" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Box$1,
                        {
                          flex: 1,
                          display: "flex",
                          flexDirection: "row",
                          justifyContent: "end",
                          alignItems: "center",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Button$1,
                              {
                                variant: "text",
                                endIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDropDown, {}),
                                onClick: handleClick,
                                sx: { border: "1px solid gray", color: "gray", minWidth: 156 },
                                children: `${currentCustomer?.name || "Customer Name"}`
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              MuiPopper,
                              {
                                id: id2,
                                open: open2,
                                anchorEl,
                                placement: "bottom-end",
                                sx: { zIndex: 500 },
                                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  Box$1,
                                  {
                                    bgcolor: "white",
                                    zIndex: 2e3,
                                    mt: 2,
                                    width: "24vw",
                                    minWidth: 256,
                                    display: "flex",
                                    flexDirection: "column",
                                    justifyContent: "start",
                                    alignItems: "stretch",
                                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card$1, { elevation: 10, sx: { p: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomerDropdown, { setAnchorEl }) })
                                  }
                                )
                              }
                            )
                          ]
                        }
                      )
                    ]
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CustomTabPanel$1, { value: value2, index: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Orders, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CustomTabPanel$1, { value: value2, index: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Drafts, {}) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { padding: 1, pl: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(OrderSummary, {}) })
      ]
    }
  );
}
var Window = {};
var _interopRequireDefault$9 = interopRequireDefaultExports;
Object.defineProperty(Window, "__esModule", {
  value: true
});
var default_1$9 = Window.default = void 0;
var _createSvgIcon$9 = _interopRequireDefault$9(requireCreateSvgIcon());
var _jsxRuntime$9 = jsxRuntimeExports;
var _default$9 = (0, _createSvgIcon$9.default)(/* @__PURE__ */ (0, _jsxRuntime$9.jsx)("path", {
  d: "M11 11V3H5c-1.1 0-2 .9-2 2v6h8zm2 0h8V5c0-1.1-.9-2-2-2h-6v8zm-2 2H3v6c0 1.1.9 2 2 2h6v-8zm2 0v8h6c1.1 0 2-.9 2-2v-6h-8z"
}), "Window");
default_1$9 = Window.default = _default$9;
var ViewList = {};
var _interopRequireDefault$8 = interopRequireDefaultExports;
Object.defineProperty(ViewList, "__esModule", {
  value: true
});
var default_1$8 = ViewList.default = void 0;
var _createSvgIcon$8 = _interopRequireDefault$8(requireCreateSvgIcon());
var _jsxRuntime$8 = jsxRuntimeExports;
var _default$8 = (0, _createSvgIcon$8.default)(/* @__PURE__ */ (0, _jsxRuntime$8.jsx)("path", {
  d: "M3 14h4v-4H3v4zm0 5h4v-4H3v4zM3 9h4V5H3v4zm5 5h13v-4H8v4zm0 5h13v-4H8v4zM8 5v4h13V5H8z"
}), "ViewList");
default_1$8 = ViewList.default = _default$8;
const initialState$5 = {
  categories: null,
  selectedCategoryItems: [],
  isItemClicked: false
};
const categorySlice = createSlice({
  name: "category",
  initialState: initialState$5,
  reducers: {
    setCategories: (state, action) => {
      state.categories = action.payload;
    },
    setItemClicked: (state, action) => {
      state.isItemClicked = action.payload;
    },
    setSelectedCategoryItems: (state, action) => {
      state.selectedCategoryItems = action.payload;
    }
  }
});
const { setCategories, setItemClicked, setSelectedCategoryItems } = categorySlice.actions;
const categoryReducer = categorySlice.reducer;
const initialState$4 = {
  searchKey: "",
  sorting: null,
  filteredProducts: []
};
const searchSlice = createSlice({
  name: "search",
  initialState: initialState$4,
  reducers: {
    setSearchKey: (state, action) => {
      state.searchKey = action.payload;
    },
    setFilteredProducts: (state, action) => {
      state.filteredProducts = action.payload;
    },
    setSorting: (state, action) => {
      state.sorting = action.payload;
    }
  }
});
const { setSearchKey, setFilteredProducts, setSorting } = searchSlice.actions;
const searchReducer = searchSlice.reducer;
function CategoryCard({ item }) {
  const dispatch = useDispatch();
  const [itemCount, setItemCount] = React.useState(0);
  const [selectedItems, setSelectedItems] = React.useState([]);
  const products = useSelector((state) => state.product.products);
  React.useEffect(() => {
    if (products) {
      const filtered = products?.filter(
        (ite) => ite?.category?.name === item?.name
      );
      setItemCount(filtered.length);
      setSelectedItems(filtered);
      setFilteredProducts(products);
    }
  }, [item?.name, products]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      bgcolor: item?.backgroundColor,
      borderRadius: 2,
      py: 2.5,
      px: 4,
      height: 180,
      display: "flex",
      flexDirection: "column",
      justifyContent: "space-between",
      alignItems: "start",
      component: ListItemButton$1,
      onClick: () => {
        dispatch(setItemClicked(true));
        console.log("ONKJ :: KK ", selectedItems);
        dispatch(setSelectedCategoryItems(selectedItems));
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: item?.icon, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { flex: 1 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "start",
            color: item?.color,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Typography$1,
                {
                  fontSize: 16,
                  fontWeight: 700,
                  color: item?.foreColor,
                  gutterBottom: true,
                  children: item?.name
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Typography$1,
                {
                  fontSize: 13,
                  fontWeight: 400,
                  gutterBottom: true,
                  color: item?.foreColor,
                  children: `${itemCount} items`
                }
              )
            ]
          }
        )
      ]
    }
  );
}
const syringe = "" + new URL("syringe-5be4fd01.svg", import.meta.url).href;
const fluid = "" + new URL("fluid-37b26b27.svg", import.meta.url).href;
const pill = "" + new URL("pill-598d13d6.svg", import.meta.url).href;
const accessible = "" + new URL("accessible-6089cb8b.svg", import.meta.url).href;
function ProductCard({ product }) {
  const theme2 = useTheme();
  const currentCustomer = useSelector(
    (state) => state.customers.currentCustomer
  );
  const dbasePath = useSelector((state) => state.database.dbasePath);
  const addCart = async () => {
    try {
      const db2 = await getDatabase(dbasePath);
      const existingData = await db2?.carts.find().exec();
      const obj = {
        id: (/* @__PURE__ */ new Date()).getTime().toString(),
        items: [
          {
            name: product?._data?.name ?? product?.name,
            image: product?._data?.image_url ?? product?.image_url,
            quantity: 1,
            unitPrice: parseInt(
              product?._data?.product_variations[0]?.variations[0]?.default_sell_price ?? product?.product_variations[0]?.variations[0]?.default_sell_price
            ).toFixed(2),
            productId: product?._data?.id ?? product?.id,
            priceWithTax: parseInt(
              product?._data?.product_variations[0]?.variations[0]?.sell_price_inc_tax ?? product?.product_variations[0]?.variations[0]?.sell_price_inc_tax
            ).toFixed(2),
            variationId: product?._data?.product_variations[0]?.variations[0]?.product_variation_id ?? product?.product_variations[0]?.variations[0]?.product_variation_id,
            productType: product?._data?.type ?? product?.type,
            productUnitId: product?._data?.unit?.id ?? product?.unit?.id
          }
        ],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      if (existingData && existingData?.length > 0) {
        for (const elem of existingData) {
          const itemExists = elem?._data?.items.some(
            (it2) => it2.name.toLowerCase() === (product?._data?.name ?? product?.name)?.toLowerCase()
          );
          if (itemExists) {
            _t$1.error("Product already added!!", {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, { color: "error" }),
              style: {
                backgroundColor: "#fadcdcf6",
                color: theme2.palette.error.dark,
                paddingLeft: 24,
                paddingRight: 24,
                paddingTop: 16,
                paddingBottom: 16,
                fontSize: 21
              },
              position: "top-center"
            });
          } else {
            const updatedItems = [...elem._data.items];
            updatedItems.push({
              name: product?._data?.name ?? product?.name,
              image: product?._data?.image_url ?? product?.image_url,
              quantity: 1,
              unitPrice: parseInt(
                product?._data?.product_variations[0]?.variations[0]?.default_sell_price ?? product?.product_variations[0]?.variations[0]?.default_sell_price
              ).toFixed(2),
              productId: product?._data?.id ?? product?.id,
              priceWithTax: parseInt(
                product?._data?.product_variations[0]?.variations[0]?.sell_price_inc_tax ?? product?.product_variations[0]?.variations[0]?.sell_price_inc_tax
              ).toFixed(2)
            });
            const updatedCart = await elem.update({
              $set: { items: updatedItems }
            });
            await updatedCart.save();
          }
        }
      } else {
        await db2?.carts.insert(obj);
      }
    } catch (error) {
      console.log("ERROR", error);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Card$1,
    {
      elevation: parseInt(
        `${product?._data?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available}`
      ) <= 0 || parseInt(
        `${product?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available}`
      ) <= 0 ? 0 : 1,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          borderRadius: 2,
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between",
          alignItems: "start",
          component: CardActionArea$1,
          disabled: parseInt(
            `${product?._data?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available}`
          ) <= 0 || parseInt(
            `${product?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available}`
          ) <= 0 ? true : false,
          onClick: () => {
            if (!currentCustomer) {
              _t$1.error("Select customer first!", {
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, { color: "error" }),
                style: {
                  backgroundColor: "#fadcdcf6",
                  color: theme2.palette.error.dark,
                  paddingLeft: 24,
                  paddingRight: 24,
                  paddingTop: 16,
                  paddingBottom: 16,
                  fontSize: 21
                },
                position: "top-center"
              });
            } else {
              addCart();
            }
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: product?._data?.image_url ?? product?.image_url,
                alt: "",
                height: 175,
                width: "100%"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Box$1,
              {
                width: "86%",
                flexDirection: "column",
                justifyContent: "space-between",
                alignItems: "stretch",
                padding: 2,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Box$1,
                    {
                      width: "100%",
                      display: "flex",
                      flexDirection: "row",
                      justifyContent: "space-between",
                      alignItems: "center",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Box$1,
                          {
                            display: "flex",
                            flexDirection: "row",
                            justifyContent: "start",
                            alignItems: "center",
                            children: product?._data === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "body2", children: `${product?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available === void 0 ? "0 " : product?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available?.toString().split(".")[0]} left in stock` }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "body2", children: `${product?._data?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available === void 0 ? "0 " : product?._data?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available?.toString().split(".")[0]} left in stock` })
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Chip$1,
                          {
                            label: product?._data?.expiry_period ?? product?.expiry_period,
                            sx: {
                              bgcolor: theme2.palette.success.light,
                              color: theme2.palette.success.dark
                            }
                          }
                        )
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Box$1,
                    {
                      flexDirection: "column",
                      justifyContent: "start",
                      alignItems: "start",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { gutterBottom: true, fontSize: 18, fontWeight: 700, children: product?._data?.name ?? product?.name })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Box$1,
                    {
                      flexDirection: "row",
                      justifyContent: "end",
                      alignItems: "center",
                      width: "100%",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        NumericFormat,
                        {
                          style: { fontSize: 16, fontFamily: "Roboto, sans-serif" },
                          value: parseInt(
                            product?.product_variations[0]?.variations[0]?.default_sell_price
                          ).toFixed(2),
                          displayType: "text",
                          thousandSeparator: true,
                          prefix: "₦"
                        }
                      )
                    }
                  )
                ]
              }
            )
          ]
        }
      )
    }
  );
}
const GridProductItem = ({ product }) => {
  const theme2 = useTheme();
  const dbasePath = useSelector((state) => state.database.dbasePath);
  const currentCustomer = useSelector(
    (state) => state.customers.currentCustomer
  );
  const addCart = async () => {
    try {
      const db2 = await getDatabase(dbasePath);
      const existingData = await db2?.carts.find().exec();
      const obj = {
        id: (/* @__PURE__ */ new Date()).getTime().toString(),
        items: [
          {
            name: product?._data?.name ?? product?.name,
            image: product?._data?.image_url ?? product?.image_url,
            quantity: 1,
            unitPrice: parseInt(
              product?._data?.product_variations[0]?.variations[0]?.default_sell_price ?? product?.product_variations[0]?.variations[0]?.default_sell_price
            ).toFixed(2),
            productId: product?._data?.id ?? product?.id,
            priceWithTax: parseInt(
              product?._data?.product_variations[0]?.variations[0]?.sell_price_inc_tax ?? product?.product_variations[0]?.variations[0]?.sell_price_inc_tax
            ).toFixed(2),
            variationId: product?._data?.product_variations[0]?.variations[0]?.product_variation_id ?? product?.product_variations[0]?.variations[0]?.product_variation_id,
            productType: product?._data?.type ?? product?.type,
            productUnitId: product?._data?.unit?.id ?? product?.unit?.id
          }
        ],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      if (existingData && existingData?.length > 0) {
        for (const elem of existingData) {
          const itemExists = elem?._data?.items.some(
            (it2) => it2.name.toLowerCase() === (product?._data?.name ?? product?.name)?.toLowerCase()
          );
          if (itemExists) {
            n$1.error("Product already added!!", {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, { color: "error" }),
              style: {
                backgroundColor: "#fadcdcf6",
                color: theme2.palette.error.dark,
                paddingLeft: 24,
                paddingRight: 24,
                paddingTop: 16,
                paddingBottom: 16,
                fontSize: 21
              },
              position: "top-center"
            });
          } else {
            const updatedItems = [...elem._data.items];
            updatedItems.push({
              name: product?._data?.name ?? product?.name,
              image: product?._data?.image_url ?? product?.image_url,
              quantity: 1,
              unitPrice: parseInt(
                product?._data?.product_variations[0]?.variations[0]?.default_sell_price ?? product?.product_variations[0]?.variations[0]?.default_sell_price
              ).toFixed(2),
              productId: product?._data?.id ?? product?.id,
              priceWithTax: parseInt(
                product?._data?.product_variations[0]?.variations[0]?.sell_price_inc_tax ?? product?.product_variations[0]?.variations[0]?.sell_price_inc_tax
              ).toFixed(2)
            });
            const updatedCart = await elem.update({
              $set: { items: updatedItems }
            });
            await updatedCart.save();
          }
        }
      } else {
        await db2?.carts.insert(obj);
      }
    } catch (error) {
      console.log("ERROR", error);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ListItem$1,
    {
      divider: true,
      disableGutters: true,
      disablePadding: true,
      button: true,
      onClick: () => {
        if (!currentCustomer) {
          console.log("NO Customer selected !!! ");
          n$1.error("Select customer first!", {
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, { color: "error" }),
            style: {
              backgroundColor: "#fadcdcf6",
              color: theme2.palette.error.dark,
              paddingLeft: 24,
              paddingRight: 24,
              paddingTop: 16,
              paddingBottom: 16,
              fontSize: 21
            },
            position: "top-center"
          });
        } else {
          addCart();
        }
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 1, py: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: product?._data?.image_url ?? product?.image_url,
            width: 64,
            height: 48
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: product?._data?.name ?? product?.name }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: product?._data === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "center", children: `${product?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available === void 0 ? "0 " : product?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available?.toString().split(".")[0]}` }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "center", children: `${product?._data?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available === void 0 ? "0 " : product?._data?.product_variations[0]?.variations[0]?.variation_location_details[0]?.qty_available?.toString().split(".")[0]}` }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "center", children: product?._data?.expiry_period ?? product?.expiry_period }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          NumericFormat,
          {
            style: { fontSize: 16, fontFamily: "Roboto, sans-serif" },
            value: parseInt(
              product?.product_variations[0]?.variations[0]?.default_sell_price
            ).toFixed(2),
            displayType: "text",
            thousandSeparator: true,
            prefix: "₦"
          }
        ) })
      ] })
    }
  );
};
function CategoryShimmer() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { display: "flex", flexDirection: "column", width: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "rounded", height: 186, width: "100%", animation: "wave" }) });
}
function CategoriesTab() {
  const categories = useSelector((state) => state.category.categories);
  const mColors = [
    { bgcolor: "#CCE4F2", color: "#0C2B6A", icon: syringe },
    { bgcolor: "#8DC2E5", color: "#0B1841", icon: pill },
    { bgcolor: "#0F408A", color: "#CCE4F2", icon: accessible },
    { bgcolor: "#0B1841", color: "#CCE4F2", icon: fluid }
  ];
  function assignRandomColors(cates) {
    return cates?.map((item) => {
      const randomColor = mColors[Math.floor(Math.random() * mColors.length)];
      return {
        ...item,
        backgroundColor: randomColor?.bgcolor,
        foreColor: randomColor?.color,
        icon: randomColor?.icon
      };
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { container: true, spacing: 2, mt: 2, children: !categories ? [1, 2, 3, 4, 5, 6, 7, 8].map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, lg: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CategoryShimmer, {}) }, item)) : categories?.length < 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      height: "50vh",
      width: "100%",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: empty, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { mt: -2, textAlign: "center", children: "No data found" })
      ]
    }
  ) : assignRandomColors(categories)?.map((item, index2) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, lg: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CategoryCard, { item }) }, index2);
  }) });
}
function CategoryProducts({ data }) {
  const [isGrid, setGrid] = React.useState(true);
  const dispatch = useDispatch();
  React.useEffect(() => {
    console.log("DTA :: ", data);
  }, [data]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        pb: 2,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBack, {}),
              variant: "text",
              sx: { textTransform: "capitalize" },
              onClick: () => {
                dispatch(setItemClicked(false));
              },
              children: "Go back"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box$1,
            {
              flex: 1,
              display: "flex",
              flexDirection: "row",
              justifyContent: "end",
              alignItems: "center",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setGrid(true), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  default_1$9,
                  {
                    sx: {
                      color: isGrid ? "black" : "grey"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setGrid(false), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  default_1$8,
                  {
                    sx: {
                      color: !isGrid ? "black" : "grey"
                    }
                  }
                ) })
              ] })
            }
          )
        ]
      }
    ),
    isGrid ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        container: true,
        spacing: 2,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "stretch",
        children: data?.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 4, height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProductCard, { product: item }) }, index2))
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 1, mb: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, textAlign: "left", children: "Products" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, textAlign: "center", children: "Quantity" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, textAlign: "center", children: "Exp Date" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, textAlign: "center", children: "Price" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { disablePadding: true, children: data?.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridProductItem, { product: item }, index2)) })
    ] })
  ] });
}
function ProductShimmer() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { display: "flex", flexDirection: "column", p: 1, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "rounded", height: 200, width: "100%" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        p: 2,
        display: "flex",
        flexDirection: "column",
        justifyContent: "start",
        alignItems: "stretch",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              mb: 1,
              display: "flex",
              flexDirection: "row",
              justifyContent: "space-between",
              alignItems: "center",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "text", width: 108, height: 20 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "text", width: 24, height: 20 })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "text", width: 70, height: 21, sx: { mb: 1 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "text", width: 100, height: 21 })
        ]
      }
    )
  ] });
}
function ProductListShimmer() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 1, py: 2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "rounded", height: 72, width: 72 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "text", height: 36, width: 128 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "text", height: 36, width: 48 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "text", height: 36, width: 48 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { variant: "text", height: 36, width: 56 }) })
  ] });
}
function ProductTab() {
  const filteredProducts = useSelector(
    (state) => state.search.filteredProducts
  );
  console.log("PRODICTS: ", filteredProducts);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Grid$1,
    {
      container: true,
      spacing: 2,
      display: "flex",
      flexDirection: "row",
      justifyContent: "start",
      alignItems: "stretch",
      children: !filteredProducts ? [1, 2, 3, 4, 5, 6].map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 4, height: "100%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProductShimmer, {}) }, item)) : filteredProducts?.filter((elem) => elem?._data?.user_type === void 0)?.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 4, height: "100%", children: item?._data?.user_type === void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(ProductCard, { product: item }) }, index2))
    }
  );
}
function ProductListViewTab() {
  const filteredProducts = useSelector(
    (state) => state.search.filteredProducts
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Grid$1,
      {
        container: true,
        spacing: 1,
        mb: 2,
        display: !filteredProducts ? "none" : "flex",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, textAlign: "left", children: "Products" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, textAlign: "center", children: "Quantity" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, textAlign: "center", children: "Exp Date" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 2, md: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, textAlign: "center", children: "Price" }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { disablePadding: true, children: !filteredProducts ? [1, 2, 3, 4, 5, 6].map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(ProductListShimmer, {}, item)) : filteredProducts?.filter((elem) => elem?._data?.user_type === void 0)?.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      GridProductItem,
      {
        product: item?.user_type === void 0 && item
      },
      index2
    )) })
  ] });
}
function CustomTabPanel(props) {
  const { children, value, index: index2, ...other } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      role: "tabpanel",
      hidden: value !== index2,
      id: `simple-tabpanel-${index2}`,
      "aria-labelledby": `simple-tab-${index2}`,
      ...other,
      children: value === index2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { p: 0 }, children })
    }
  );
}
const StyledTabs$2 = styled$1((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Tabs$1,
  {
    ...props,
    TabIndicatorProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "MuiTabs-indicatorSpan" }) }
  }
))({
  "& .MuiTabs-indicator": {
    display: "flex",
    justifyContent: "center",
    backgroundColor: "transparent"
  },
  "& .MuiTabs-indicatorSpan": {
    maxWidth: 0,
    width: "100%",
    backgroundColor: "#635ee7"
  }
});
const StyledTab$1 = styled$1((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tab$1, { disableRipple: true, ...props }))(({ theme: theme2 }) => ({
  textTransform: "none",
  fontWeight: theme2.typography.fontWeightRegular,
  fontSize: 16,
  marginRight: theme2.spacing(1),
  fontFamily: "Inter",
  paddingLeft: 16,
  paddingRight: 16,
  height: 16,
  color: "grey",
  "&.Mui-selected": {
    color: "#000",
    fontWeight: theme2.typography.fontWeightBold,
    backgroundColor: "#DAE1E7",
    fontFamily: "Inter",
    borderRadius: 10,
    paddingLeft: 16,
    paddingRight: 16
  },
  "&.Mui-focusVisible": {
    backgroundColor: "gray"
  }
}));
function LeftHandSide() {
  const [value, setValue2] = React.useState(0);
  const [productViewType, setProductViewType] = React.useState("gridview");
  const isItemClicked = useSelector(
    (state) => state.category.isItemClicked
  );
  const selectedCategoryItems = useSelector(
    (state) => state.category.selectedCategoryItems
  );
  const handleChange = (event, newValue) => {
    setValue2(newValue);
    console.log("VENT ", event);
  };
  const getCarts = async () => {
    try {
      const db2 = await getDatabase(`${localStorage.getItem("dbPath")}`);
      const existingData = await db2?.carts.find().exec();
      console.log("CARTS RESP :: ", existingData);
    } catch (error) {
      console.log("err", error);
    }
  };
  React.useEffect(() => {
    getCarts();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { sx: { width: "100%", position: "relative" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      AppBar$1,
      {
        sx: {
          bgcolor: "#ECF0F4",
          zIndex: 10,
          maxWidth: "58%",
          left: 0,
          px: 4,
          pb: 2
        },
        elevation: 0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            StyledTabs$2,
            {
              value,
              onChange: handleChange,
              "aria-label": "styled tabs example",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTab$1, { label: "Categories" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTab$1, { label: "Products" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Box$1,
                  {
                    flex: 1,
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "end",
                    alignItems: "center",
                    children: value === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setProductViewType("gridview"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        default_1$9,
                        {
                          sx: {
                            color: productViewType === "gridview" ? "black" : "grey"
                          }
                        }
                      ) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setProductViewType("listview"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        default_1$8,
                        {
                          sx: {
                            color: productViewType === "listview" ? "black" : "grey"
                          }
                        }
                      ) })
                    ] })
                  }
                )
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        height: "100vh",
        ml: 4,
        sx: {
          overflowX: "hidden",
          overflowY: "auto",
          height: "96vh",
          scrollbarColor: "red blue"
        },
        display: "flex",
        flexDirection: "column",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CustomTabPanel, { value, index: 0, children: isItemClicked ? /* @__PURE__ */ jsxRuntimeExports.jsx(CategoryProducts, { data: selectedCategoryItems }) : /* @__PURE__ */ jsxRuntimeExports.jsx(CategoriesTab, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CustomTabPanel, { value, index: 1, children: productViewType === "gridview" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ProductTab, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ProductListViewTab, {}) })
        ]
      }
    )
  ] });
}
const HomeScreen = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { py: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, height: "100vh", width: "100vw", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        sm: 7,
        md: 7,
        width: "100%",
        height: "99vh",
        sx: { overflowX: "hidden", overflowY: "visible" },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(LeftHandSide, {})
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        sm: 5,
        md: 5,
        width: "100%",
        height: "99vh",
        sx: { overflowX: "hidden", overflowY: "visible" },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(RightHandSide, {})
      }
    )
  ] }) });
};
var DensitySmall = {};
var _interopRequireDefault$7 = interopRequireDefaultExports;
Object.defineProperty(DensitySmall, "__esModule", {
  value: true
});
var default_1$7 = DensitySmall.default = void 0;
var _createSvgIcon$7 = _interopRequireDefault$7(requireCreateSvgIcon());
var _jsxRuntime$7 = jsxRuntimeExports;
var _default$7 = (0, _createSvgIcon$7.default)(/* @__PURE__ */ (0, _jsxRuntime$7.jsx)("path", {
  d: "M3 2h18v2H3zm0 18h18v2H3zm0-6h18v2H3zm0-6h18v2H3z"
}), "DensitySmall");
default_1$7 = DensitySmall.default = _default$7;
var Search = {};
var _interopRequireDefault$6 = interopRequireDefaultExports;
Object.defineProperty(Search, "__esModule", {
  value: true
});
var default_1$6 = Search.default = void 0;
var _createSvgIcon$6 = _interopRequireDefault$6(requireCreateSvgIcon());
var _jsxRuntime$6 = jsxRuntimeExports;
var _default$6 = (0, _createSvgIcon$6.default)(/* @__PURE__ */ (0, _jsxRuntime$6.jsx)("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
}), "Search");
default_1$6 = Search.default = _default$6;
const filterImg = "" + new URL("tune-4a4e4a32.svg", import.meta.url).href;
var ArrowDropUp = {};
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(ArrowDropUp, "__esModule", {
  value: true
});
var default_1$5 = ArrowDropUp.default = void 0;
var _createSvgIcon$5 = _interopRequireDefault$5(requireCreateSvgIcon());
var _jsxRuntime$5 = jsxRuntimeExports;
var _default$5 = (0, _createSvgIcon$5.default)(/* @__PURE__ */ (0, _jsxRuntime$5.jsx)("path", {
  d: "m7 14 5-5 5 5z"
}), "ArrowDropUp");
default_1$5 = ArrowDropUp.default = _default$5;
var ArrowRight = {};
var _interopRequireDefault$4 = interopRequireDefaultExports;
Object.defineProperty(ArrowRight, "__esModule", {
  value: true
});
var default_1$4 = ArrowRight.default = void 0;
var _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon());
var _jsxRuntime$4 = jsxRuntimeExports;
var _default$4 = (0, _createSvgIcon$4.default)(/* @__PURE__ */ (0, _jsxRuntime$4.jsx)("path", {
  d: "m10 17 5-5-5-5v10z"
}), "ArrowRight");
default_1$4 = ArrowRight.default = _default$4;
const priceMarks = [
  {
    value: 0,
    label: "₦0"
  },
  {
    value: 5,
    label: ""
  },
  {
    value: 15,
    label: "₦20,000"
  },
  {
    value: 50,
    label: "₦100,000"
  },
  {
    value: 100,
    label: "₦200k"
  }
];
function CollapseSection({ setAnchorEl }) {
  const dispatch = useDispatch();
  const [open1, setOpen1] = React.useState(false);
  const [open2, setOpen2] = React.useState(false);
  const [open3, setOpen3] = React.useState(false);
  const [startVal, setStartVal] = React.useState(0);
  const [endVal, setEndVal] = React.useState(3e4);
  const [sortLowHigh, setSortLowHigh] = React.useState(false);
  const [sortHighLow, setSortHighLow] = React.useState(false);
  const [alphabetAZ, setAlphabetAZ] = React.useState(false);
  const [alphabetZA, setAlphabetZA] = React.useState(false);
  const [value, setValue2] = React.useState([0, 20]);
  const sorting = useSelector((state) => state.search.sorting);
  const categories = useSelector((state) => state.category.categories);
  const filteredProducts = useSelector(
    (state) => state.search.filteredProducts
  );
  const products = useSelector((state) => state.product.products);
  const handleChange = (event, newValue) => {
    setValue2(newValue);
    console.log("CURRENT VAL", newValue);
    const start2 = rangeConverter(newValue[0]);
    const end2 = rangeConverter(newValue[1]);
    console.log("START CONVERTED >>> ", start2);
    console.log("END CONVERTED >>> ", end2);
    if (start2 && end2) {
      setStartVal(start2);
      setEndVal(end2);
    }
    dispatch(
      setSorting({
        name: "price-range",
        value: "slide"
      })
    );
  };
  React.useEffect(() => {
    if (sorting?.name === "alphabet-sort") {
      if (sorting?.value === "a-z") {
        setAlphabetAZ(true);
        setAlphabetZA(false);
      } else {
        setAlphabetAZ(false);
        setAlphabetZA(true);
      }
    }
  }, []);
  function valuetext(value2) {
    return `₦${value2}`;
  }
  function valueLabelFormat(value2) {
    return priceMarks.findIndex((mark) => mark.value === value2) + 1;
  }
  function rangeConverter(num) {
    if (num === 0) {
      return 0;
    } else if (num === 5) {
      return 7500;
    } else if (num === 10) {
      return 15e3;
    } else if (num === 15) {
      return 2e4;
    } else if (num === 20) {
      return 3e4;
    } else if (num === 25) {
      return 4e4;
    } else if (num === 30) {
      return 5e4;
    } else if (num === 35) {
      return 6e4;
    } else if (num === 40) {
      return 75e3;
    } else if (num === 45) {
      return 9e4;
    } else if (num === 50) {
      return 1e5;
    } else if (num === 55) {
      return 11e4;
    } else if (num === 60) {
      return 12e4;
    } else if (num === 65) {
      return 13e4;
    } else if (num === 70) {
      return 14e4;
    } else if (num === 75) {
      return 15e4;
    } else if (num === 80) {
      return 16e4;
    } else if (num === 85) {
      return 17e4;
    } else if (num === 90) {
      return 18e4;
    } else if (num === 95) {
      return 19e4;
    } else if (num === 100) {
      return 2e5;
    }
  }
  const applyFilter = () => {
    setAnchorEl(null);
    console.log("CURRENT SORTING CRITERIAV ==>> ", sorting);
    console.log("FILTERED PRODUCTS ==>> ", filteredProducts);
    if (sorting?.name === "alphabet-sort") {
      if (sorting?.value === "a-z") {
        const sortedData = products?.slice().sort((a2, b2) => {
          console.log("DATA INSPECT : ", a2);
          return a2?.name?.localeCompare(b2?.name);
        });
        dispatch(setFilteredProducts(sortedData));
      } else {
        const sortedData = products?.slice().sort((a2, b2) => {
          return b2?.name?.localeCompare(a2?.name);
        });
        dispatch(setFilteredProducts(sortedData));
      }
    } else if (sorting?.name === "price-sort") {
      if (sorting?.value === "low-high") {
        const sortedData = products?.slice().sort((a2, b2) => {
          console.log(
            "A VALUS ",
            a2?.product_variations[0]?.variations[0]?.default_sell_price
          );
          console.log(
            "B VALUE ",
            b2?.product_variations[0]?.variations[0]?.default_sell_price
          );
          const aVal = `${a2?.product_variations[0]?.variations[0]?.default_sell_price}` || "0.0";
          const bVal = `${b2?.product_variations[0]?.variations[0]?.default_sell_price}` || "0.0";
          return parseFloat(aVal) - parseFloat(bVal);
        });
        dispatch(setFilteredProducts(sortedData));
      } else {
        const sortedData = products?.sort((a2, b2) => {
          return parseInt(
            b2?.product_variations[0]?.variations[0]?.default_sell_price
          ) - parseInt(
            a2?.product_variations[0]?.variations[0]?.default_sell_price
          );
        });
        dispatch(setFilteredProducts(sortedData));
      }
    } else if (sorting?.name === "category-sort") {
      console.log("HERE ??>>> ");
      const filteredData = products?.filter(
        (item) => item?.category?.name.toLowerCase() === sorting?.value.toLowerCase()
      );
      dispatch(setFilteredProducts(filteredData));
    } else {
      const filteredData = products?.filter(
        (item) => parseInt(
          item?.product_variations[0]?.variations[0]?.default_sell_price
        ) >= startVal && parseInt(
          item?.product_variations[0]?.variations[0]?.default_sell_price
        ) <= endVal
      );
      dispatch(setFilteredProducts(filteredData));
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$3,
    {
      display: "flex",
      flexDirection: "column",
      justifyContent: "start",
      alignItems: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$3,
          {
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "center",
            mt: 1,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setOpen1(!open1), children: open1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$5, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$4, {}) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 14, fontWeight: 700, color: "black", px: 1, children: "Sort by:" })
            ]
          }
        ),
        open1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$3,
          {
            ml: 6,
            bgcolor: "#ECF0F480",
            display: "flex",
            flexDirection: "column",
            justifyContent: "space-between",
            alignItems: "start",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$3,
                {
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "start",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      MUICheckbox,
                      {
                        checked: sortLowHigh,
                        onChange: (e2, checked) => {
                          setSortLowHigh(checked);
                          setSortHighLow(!checked);
                          dispatch(
                            setSorting({
                              name: "price-sort",
                              value: "low-high"
                            })
                          );
                        },
                        size: "small"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { px: 1, fontWeight: 200, fontSize: 13, children: "Low High Price" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$3, { mx: 4 })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$3,
                {
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "start",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      MUICheckbox,
                      {
                        size: "small",
                        checked: sortHighLow,
                        onChange: (e2, checked) => {
                          setSortHighLow(checked);
                          setSortLowHigh(!checked);
                          dispatch(
                            setSorting({
                              name: "price-sort",
                              value: "high-low"
                            })
                          );
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { px: 1, fontWeight: 200, fontSize: 13, children: "High Low Price" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$3, { mx: 4 })
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$3,
          {
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "center",
            mt: 1,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setOpen2(!open2), children: open2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$5, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$4, {}) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 14, fontWeight: 700, color: "black", px: 1, children: "Alphabetical Order" })
            ]
          }
        ),
        open2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$3,
          {
            ml: 6,
            bgcolor: "#ECF0F480",
            display: "flex",
            flexDirection: "column",
            justifyContent: "space-between",
            alignItems: "start",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$3,
                {
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "start",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      MUICheckbox,
                      {
                        size: "small",
                        checked: alphabetAZ,
                        onChange: (e2, checked) => {
                          setAlphabetAZ(checked);
                          setAlphabetZA(!checked);
                          dispatch(
                            setSorting({
                              name: "alphabet-sort",
                              value: "a-z"
                            })
                          );
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { px: 1, fontWeight: 300, fontSize: 13, children: "A - Z" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box$3, { my: 1 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$3,
                {
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "start",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      MUICheckbox,
                      {
                        size: "small",
                        checked: alphabetZA,
                        onChange: (e2, checked) => {
                          setAlphabetZA(checked);
                          setAlphabetAZ(!checked);
                          dispatch(
                            setSorting({
                              name: "alphabet-sort",
                              value: "z-a"
                            })
                          );
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { px: 1, fontWeight: 300, fontSize: 13, children: "Z - A" })
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$3,
          {
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "center",
            mt: 1,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => setOpen3(!open3), children: open3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$5, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$4, {}) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 14, fontWeight: 700, color: "black", px: 1, children: "Category" })
            ]
          }
        ),
        open3 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box$3,
          {
            display: "flex",
            mx: 6,
            px: 1,
            py: 1,
            flexDirection: "column",
            justifyContent: "space-between",
            alignItems: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl$1, { fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              RadioGroup$1,
              {
                "aria-labelledby": "demo-radio-buttons-group-label",
                defaultValue: "female",
                name: "radio-buttons-group",
                children: categories?.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  FormControlLabel$1,
                  {
                    value: item?.name,
                    control: /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, {}),
                    label: item?.name,
                    onChange: (_e2, _checked) => {
                      dispatch(
                        setSorting({
                          name: "category-sort",
                          value: `${item?.name}`
                        })
                      );
                    }
                  },
                  index2
                ))
              }
            ) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box$3, { sx: { width: "100%", my: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Slider$1,
          {
            sx: { flex: 1 },
            "aria-label": "Always visible",
            value,
            onChange: handleChange,
            valueLabelFormat,
            getAriaValueText: valuetext,
            step: 5,
            valueLabelDisplay: "off",
            marks: priceMarks,
            style: { fontSize: 10 }
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "contained", fullWidth: true, sx: { p: 1 }, onClick: applyFilter, children: "Apply Filter" })
      ]
    }
  );
}
const Searchbar = () => {
  const [anchorEl, setAnchorEl] = React.useState(null);
  const dispatch = useDispatch();
  const searchKey = useSelector((state) => state.search.searchKey);
  const products = useSelector((state) => state.product.products);
  const handleClick = (event) => {
    setAnchorEl(anchorEl ? null : event.currentTarget);
  };
  const handleChange = (e2) => {
    const { value } = e2.target;
    dispatch(setSearchKey(value));
  };
  const searchClick = () => {
    if (searchKey) {
      const filtered = products?.filter(
        (item) => item?.name?.toLowerCase().includes(searchKey.toLowerCase())
      );
      dispatch(setFilteredProducts(filtered));
    } else {
      dispatch(setFilteredProducts(products));
    }
  };
  const open2 = Boolean(anchorEl);
  const id2 = open2 ? "simple-popper" : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$3,
    {
      px: 1,
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-between",
      alignItems: "center",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$3,
          {
            flex: 1,
            display: "flex",
            flexDirection: "row",
            justifyContent: "space-between",
            alignItems: "stretch",
            bgcolor: "white",
            borderRadius: 4,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField$1,
                {
                  placeholder: "Search for drugs",
                  onChange: handleChange,
                  InputProps: {
                    disableUnderline: true,
                    style: {
                      borderRadius: 16,
                      backgroundColor: "white",
                      justifyContent: "center",
                      paddingBottom: 8
                    }
                  },
                  variant: "filled",
                  fullWidth: true,
                  sx: { borderRadius: 10, flex: 1 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "contained",
                  onClick: searchClick,
                  sx: { borderTopRightRadius: 10, borderBottomRightRadius: 10 },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$6, {})
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Box$3, { mx: 2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            sx: { bgcolor: "white", borderRadius: 4, padding: 2 },
            onClick: handleClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: filterImg, alt: "" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          MuiPopper,
          {
            id: id2,
            open: open2,
            anchorEl,
            placement: "bottom-end",
            sx: { zIndex: 500 },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Box$3,
              {
                bgcolor: "white",
                zIndex: 2e3,
                mt: 4,
                width: "34vw",
                minWidth: 256,
                display: "flex",
                flexDirection: "column",
                justifyContent: "start",
                alignItems: "stretch",
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card$1, { elevation: 100, sx: { p: 2 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Box$3,
                    {
                      display: "flex",
                      flexDirection: "row",
                      justifyContent: "end",
                      alignItems: "center",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: handleClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$e, {}) })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$3, { px: 2, pb: 4, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 21, fontWeight: 700, pb: 1, children: "Filters" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TextField$1,
                      {
                        fullWidth: true,
                        size: "small",
                        placeholder: "Search Filter",
                        InputProps: {
                          startAdornment: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$6, { sx: { color: "gray" } }),
                          style: { backgroundColor: "#ECF0F4" }
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseSection, { setAnchorEl })
                  ] })
                ] })
              }
            )
          }
        )
      ]
    }
  );
};
var Sync = {};
var _interopRequireDefault$3 = interopRequireDefaultExports;
Object.defineProperty(Sync, "__esModule", {
  value: true
});
var default_1$3 = Sync.default = void 0;
var _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon());
var _jsxRuntime$3 = jsxRuntimeExports;
var _default$3 = (0, _createSvgIcon$3.default)(/* @__PURE__ */ (0, _jsxRuntime$3.jsx)("path", {
  d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"
}), "Sync");
default_1$3 = Sync.default = _default$3;
var GridView = {};
var _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(GridView, "__esModule", {
  value: true
});
var default_1$2 = GridView.default = void 0;
var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
var _jsxRuntime$2 = jsxRuntimeExports;
var _default$2 = (0, _createSvgIcon$2.default)(/* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
  fillRule: "evenodd",
  d: "M3 3v8h8V3H3zm6 6H5V5h4v4zm-6 4v8h8v-8H3zm6 6H5v-4h4v4zm4-16v8h8V3h-8zm6 6h-4V5h4v4zm-6 4v8h8v-8h-8zm6 6h-4v-4h4v4z"
}), "GridView");
default_1$2 = GridView.default = _default$2;
var AccountCircle = {};
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(AccountCircle, "__esModule", {
  value: true
});
var default_1$1 = AccountCircle.default = void 0;
var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
var _jsxRuntime$1 = jsxRuntimeExports;
var _default$1 = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 4c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm0 14c-2.03 0-4.43-.82-6.14-2.88C7.55 15.8 9.68 15 12 15s4.45.8 6.14 2.12C16.43 19.18 14.03 20 12 20z"
}), "AccountCircle");
default_1$1 = AccountCircle.default = _default$1;
var AccountBalanceWallet = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(AccountBalanceWallet, "__esModule", {
  value: true
});
var default_1 = AccountBalanceWallet.default = void 0;
var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
var _jsxRuntime = jsxRuntimeExports;
var _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
  d: "M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"
}), "AccountBalanceWallet");
default_1 = AccountBalanceWallet.default = _default;
function ProfileDropDownContent() {
  const [openDialog, setOpenDialog] = React.useState(false);
  const navigate = useNavigate();
  const confirmDialogBody = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      px: 8,
      py: 6,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      maxWidth: 360,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontWeight: 300, fontSize: 26, gutterBottom: true, textAlign: "center", children: "Are you sure you want to clock out" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            variant: "contained",
            sx: { px: 4, py: 1 },
            onClick: () => {
              setOpenDialog(false);
              navigate("/");
            },
            children: "Clock out"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            variant: "text",
            sx: { px: 4, py: 1 },
            onClick: () => setOpenDialog(false),
            children: "Cancel"
          }
        )
      ]
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      display: "flex",
      px: 1,
      py: 2,
      flexDirection: "column",
      justifyContent: "start",
      alignItems: "center",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CustomDialog,
          {
            open: openDialog,
            setOpen: setOpenDialog,
            showClose: false,
            content: confirmDialogBody
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", gutterBottom: true, fontWeight: 600, fontSize: 16, children: "Oluwamayowa" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, color: "gray", gutterBottom: true, children: "Attendant • 4hr 56m" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Divider$1,
          {
            variant: "middle",
            sx: { height: 1, width: "90%", backgroundColor: "#DAE1E7", my: 2 }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            p: 1,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignSelf: "start",
            alignItems: "center",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$1, { sx: { color: "#bbb" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { px: 2, fontWeight: 200, fontSize: 15, color: "grey", children: "View Profile" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            p: 1,
            mb: 2,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignSelf: "start",
            alignItems: "center",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(default_1, { sx: { color: "#bbb" } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { px: 2, fontWeight: 200, fontSize: 15, color: "grey", children: "Edit Account Number" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            variant: "contained",
            sx: { py: 1, px: 4 },
            onClick: () => setOpenDialog(true),
            children: "Clock Out"
          }
        )
      ]
    }
  );
}
const initialState$3 = {
  products: null
};
const productSlice = createSlice({
  name: "product",
  initialState: initialState$3,
  reducers: {
    setProducts: (state, action) => {
      state.products = action.payload;
    }
  }
});
const { setProducts } = productSlice.actions;
const productReducer = productSlice.reducer;
const spin = "";
const initialState$2 = {
  paymentMethod: "",
  paymentMethods: [],
  carts: [],
  drafts: [],
  sales: [],
  change: 0,
  salesMeta: null,
  amountPaid: 0
};
const purchaseSlice = createSlice({
  name: "purchase",
  initialState: initialState$2,
  reducers: {
    setPaymentMethod: (state, action) => {
      state.paymentMethod = action.payload;
    },
    setPaymentMethods: (state, action) => {
      state.paymentMethods = action.payload;
    },
    setCarts: (state, action) => {
      state.carts = action.payload;
    },
    setDrafts: (state, action) => {
      state.drafts = action.payload;
    },
    setChange: (state, action) => {
      state.change = action.payload;
    },
    setAmountPaid: (state, action) => {
      state.amountPaid = action.payload;
    },
    setSales: (state, action) => {
      state.sales = action.payload;
    },
    setSalesMeta: (state, action) => {
      state.salesMeta = action.payload;
    }
  }
});
const {
  setPaymentMethod,
  setPaymentMethods,
  setCarts,
  setDrafts,
  setAmountPaid,
  setChange,
  setSales,
  setSalesMeta
} = purchaseSlice.actions;
const purchaseReducer = purchaseSlice.reducer;
const MListItemButton = styled$1(ListItemButton$1)(
  ({ theme: theme2 }) => ({
    background: "tranparent",
    color: "#8A95BF",
    padding: "12px",
    height: "100%",
    width: "100%",
    textAlign: "start",
    borderRadius: "16px",
    textTransform: "capitalize",
    "&:hover": {
      background: "#fff",
      color: theme2.palette.primary.main
    }
  })
);
function Dashboard() {
  const [state, setState] = reactExports.useState({
    top: false,
    left: false,
    bottom: false,
    right: false
  });
  const theme2 = useTheme();
  const navigate = useNavigate();
  const userId = parseInt(`${localStorage.getItem("userId") ?? 0}`);
  const location_ID = parseInt(
    `${localStorage.getItem("location_id") ?? 0}`
  );
  const currlocation = useLocation();
  const [isRotating, setRotating] = reactExports.useState(false);
  const [showSearchbar, setShowSearchbar] = reactExports.useState(true);
  const [selectedIndex, setSelectedIndex] = reactExports.useState(0);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const dispatch = useDispatch();
  const isOnline2 = useSelector((state2) => state2.loader.isOnline);
  const handleClick = (event) => {
    setAnchorEl(anchorEl ? null : event.currentTarget);
  };
  const handleSync = async () => {
    if (!isOnline2) {
      _t$1.error("Internet connection is required!", {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info, { color: "error" }),
        style: {
          backgroundColor: "#fadcdcf6",
          color: theme2.palette.error.dark,
          paddingLeft: 24,
          paddingRight: 24,
          paddingTop: 16,
          paddingBottom: 16,
          fontSize: 21
        },
        position: "top-center"
      });
    } else {
      setRotating(true);
      try {
        const productData = await APIService.getProducts();
        if (productData) {
          window.electron.sendDataToMain(JSON.stringify(productData?.data));
          dispatch(setProducts(productData?.data));
          dispatch(setFilteredProducts(productData?.data));
        }
        const categoryData = await APIService.getCategories();
        if (categoryData) {
          window.electron.sendCategoriesDataToMain(
            JSON.stringify(categoryData?.data)
          );
          dispatch(setCategories(categoryData?.data));
        }
        const businessLocationsData = await APIService.getBusinessLocations();
        if (businessLocationsData) {
          dispatch(setBusinessLocations(businessLocationsData?.data));
          window.electron.sendBusinessLocationDataToMain(
            JSON.stringify(businessLocationsData?.data)
          );
          if (localStorage.getItem("locationId") && localStorage.getItem("businessId")) {
            const locationID = localStorage.getItem("locationId");
            const bizID = localStorage.getItem("businessId");
            const currLocation = businessLocationsData?.data?.filter(
              (item) => `${item?.business_id}`.toLowerCase() === `${bizID}`.toLowerCase() && `${item?.location_id}`.toLowerCase() === `${locationID}`.toLowerCase()
            );
            dispatch(setCurrentBusinessLocation(currLocation[0]));
          }
        }
        const salesData = await APIService.getSalesReport(location_ID, userId);
        if (salesData) {
          dispatch(setSales(salesData?.data));
          dispatch(setSalesMeta(salesData?.meta));
          window.electron.sendSalesSummaryDataToMain(
            JSON.stringify(salesData?.data)
          );
        }
        setRotating(false);
      } catch (error) {
        console.error("ERROR IN SYNC :: :: ", error);
      }
    }
  };
  const open2 = Boolean(anchorEl);
  const id2 = open2 ? "simple-popper" : void 0;
  const drawerListItems = [
    {
      title: "Front Till",
      route: "/dashboard/home",
      icon: default_1$2,
      key: "home"
    },
    {
      title: "Customers",
      route: "/dashboard/customers",
      icon: PersonSearchOutlined,
      key: "customers"
    },
    {
      title: "Report",
      route: "/dashboard/reports",
      icon: InsertChartOutlined,
      key: "report"
    },
    {
      title: "Activity",
      route: "/dashboard/activity",
      icon: WidgetsOutlined,
      key: "activity"
    },
    {
      title: "Support",
      route: "/dashboard/supports",
      icon: SupportAgentOutlined,
      key: "support"
    }
  ];
  const handleItemClick = (e2, index2, route, anchor) => {
    setSelectedIndex(index2);
    setState({ ...state, [anchor]: false });
    navigate(route);
  };
  const activeRootStyle = {
    color: theme2.palette.primary.main,
    fontWeight: "fontWeightMedium",
    background: "white",
    textAlign: "start",
    borderRadius: "16px",
    textTransform: "capitalize"
  };
  reactExports.useEffect(() => {
    if (currlocation.pathname === "/dashboard/home") {
      setSelectedIndex(0);
      setShowSearchbar(true);
    } else if (currlocation.pathname === "/dashboard/customers") {
      setSelectedIndex(1);
      setShowSearchbar(false);
    } else if (currlocation.pathname === "/dashboard/reports") {
      setSelectedIndex(2);
      setShowSearchbar(false);
    } else if (currlocation.pathname === "/dashboard/activity") {
      setSelectedIndex(3);
    } else if (currlocation.pathname === "/dashboard/supports") {
      setSelectedIndex(4);
      setShowSearchbar(false);
    }
  }, [currlocation]);
  const toggleDrawer = (anchor, open22) => (event) => {
    if (event.type === "keydown" && (event.key === "Tab" || event.key === "Shift")) {
      return;
    }
    setState({ ...state, [anchor]: open22 });
  };
  const list = (anchor) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box$1,
    {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { children: drawerListItems?.map((data, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ListItem$1,
        {
          disablePadding: true,
          sx: {
            display: "block",
            ...index2 === selectedIndex && activeRootStyle
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            MListItemButton,
            {
              sx: {
                minHeight: 48,
                display: "flex",
                flexDirection: "column",
                justifyContent: state[anchor] ? "initial" : "center",
                px: 2.5,
                my: 1
              },
              onClick: (e2) => handleItemClick(e2, index2, data?.route, anchor),
              selected: index2 === selectedIndex,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(data.icon, {}),
                state[anchor] && /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { pr: data.key === "explore" ? 2 : 3 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ListItemText$1,
                  {
                    primary: data.title,
                    sx: { opacity: state[anchor] ? 1 : 0 }
                  }
                )
              ]
            }
          )
        },
        index2
      )) })
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: ["left"].map((anchor) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppBar$1, { position: "fixed", sx: { bgcolor: "#ECF0F4", p: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Toolbar$1,
      {
        sx: {
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              flex: 1,
              display: "flex",
              flexDirection: "row",
              justifyContent: "start",
              alignItems: "start",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  IconButton$1,
                  {
                    color: "inherit",
                    "aria-label": "open drawer",
                    onClick: toggleDrawer(anchor, true),
                    edge: "start",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(default_1$7, { sx: { color: "#0F408A" } })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { px: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: brandLogo, alt: "", width: 100 }) })
              ]
            }
          ),
          showSearchbar && /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { ml: 6, mr: 4, flex: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Searchbar, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              flex: 1,
              display: "flex",
              flexDirection: "row",
              justifyContent: "end",
              alignItems: "center",
              children: [
                isOnline2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Wifi, { color: "success", fontSize: "large", sx: { mr: 2 } }) : /* @__PURE__ */ jsxRuntimeExports.jsx(WifiOff, { color: "error", fontSize: "large", sx: { mr: 2 } }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: handleClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Avatar$1,
                  {
                    sx: { width: 56, height: 56 },
                    src: "https://images.generated.photos/yHB68S2StFH13k8q8doQsZa0Ol3MAgQnZ2LrdDoMvCs/rs:fit:256:256/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LnBob3Rvcy92M18w/MDE2NDQ5LmpwZw.jpg"
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MuiPopper,
                  {
                    id: id2,
                    open: open2,
                    anchorEl,
                    placement: "bottom-end",
                    sx: { zIndex: 500 },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Box$1,
                      {
                        bgcolor: "white",
                        zIndex: 2e3,
                        mt: 4,
                        width: "20vw",
                        minWidth: 150,
                        display: "flex",
                        flexDirection: "column",
                        justifyContent: "start",
                        alignItems: "stretch",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card$1, { elevation: 10, sx: { p: 2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProfileDropDownContent, {}) })
                      }
                    )
                  }
                )
              ]
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Drawer$1,
      {
        anchor,
        open: state[anchor],
        sx: { width: 250 },
        onClose: toggleDrawer(anchor, false),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box$1,
            {
              width: 200,
              py: 4,
              px: 2,
              height: "100%",
              display: "flex",
              flexDirection: "column",
              justifyContent: "space-between",
              alignItems: "center",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$1,
                {
                  display: "flex",
                  flexDirection: "column",
                  justifyContent: "start",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: brandLogo, alt: "", width: 128 }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                    list(anchor)
                  ]
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box$1,
            {
              pb: 4,
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              alignItems: "center",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button$1,
                {
                  className: "spinBtn",
                  sx: {
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    alignItems: "center",
                    textTransform: "capitalize",
                    color: "black"
                  },
                  onClick: () => handleSync(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      default_1$3,
                      {
                        className: isRotating ? "spin" : "no-spin",
                        fontSize: "large"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Sync" })
                  ]
                }
              )
            }
          )
        ]
      }
    )
  ] }, anchor)) });
}
const tempActivities = [
  {
    amount: "#30,000",
    time: "12:50pm"
  },
  {
    amount: "#30,000",
    time: "12:50pm"
  },
  {
    amount: "#50,000",
    time: "01:40pm"
  },
  {
    amount: "#30,000",
    time: "12:50pm"
  },
  {
    amount: "#30,000",
    time: "12:50pm"
  },
  {
    amount: "#40,000",
    time: "02:50pm"
  },
  {
    amount: "#30,000",
    time: "12:50pm"
  },
  {
    amount: "#30,000",
    time: "12:50pm"
  },
  {
    amount: "#30,000",
    time: "12:50pm"
  }
];
const prod1 = "" + new URL("product1-16f6bc0d.png", import.meta.url).href;
const prod2 = "" + new URL("product2-c4f7dcb5.png", import.meta.url).href;
const noprod = "" + new URL("no_prod_image-dbb48371.png", import.meta.url).href;
const tempProducts = [
  {
    id: 0,
    image: prod1,
    name: "Emzor Paracetamol I.V 100mg",
    price: 5e3,
    validity: "20/11/24",
    sachet: "16/sachet • 10 sachet/pack",
    quantity: 12
  },
  {
    id: 1,
    image: noprod,
    name: "Emzor Multivite 100mg",
    price: 3100,
    validity: "20/11/24",
    sachet: "16/sachet • 10 sachet/pack",
    quantity: 12
  },
  {
    id: 2,
    image: prod2,
    name: "Emzor Panadol Extra 50mg",
    price: 5e3,
    validity: "20/11/24",
    sachet: "16/sachet • 10 sachet/pack",
    quantity: 32
  },
  {
    id: 3,
    image: noprod,
    name: "Emzor Paracetamol I 100mg",
    price: 4e3,
    validity: "20/11/24",
    sachet: "16/sachet • 10 sachet/pack",
    quantity: 32
  },
  {
    id: 4,
    image: prod2,
    name: "Emzor Parace V 100mg",
    price: 5e3,
    validity: "20/11/24",
    sachet: "16/sachet • 10 sachet/pack",
    quantity: 32
  }
];
function ItemCard({ data }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Card$1, { elevation: 0, sx: { my: 2, p: 3, width: "94%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { display: "flex", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 1, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 5,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, fontWeight: 300, textAlign: "start", children: data?.name })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 2,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 15, textAlign: "start", children: `${data?.quantity}` })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 2,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 15, textAlign: "start", children: `₦${data?.price}` })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 3,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 15, textAlign: "start", children: `₦${data?.price * data?.quantity}` })
      }
    )
  ] }) }) });
}
function ProductTable() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { width: "90%", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 22, fontWeight: 900, color: "black", children: "Items" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 1, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Grid$1,
        {
          item: true,
          md: 5,
          display: "flex",
          flexDirection: "row",
          justifyContent: "start",
          alignItems: "start",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, fontWeight: 300, textAlign: "center", children: "Product" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Grid$1,
        {
          item: true,
          md: 2,
          display: "flex",
          flexDirection: "row",
          justifyContent: "start",
          alignItems: "start",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, fontWeight: 300, textAlign: "center", children: "Qty" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Grid$1,
        {
          item: true,
          md: 2,
          display: "flex",
          flexDirection: "row",
          justifyContent: "start",
          alignItems: "start",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, fontWeight: 300, textAlign: "center", children: "Unit Price" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Grid$1,
        {
          item: true,
          md: 3,
          display: "flex",
          flexDirection: "row",
          justifyContent: "start",
          alignItems: "start",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, fontWeight: 300, textAlign: "center", children: "Total" })
        }
      )
    ] }),
    tempProducts?.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(ItemCard, { data: item }, index2))
  ] });
}
function ItemContent({ activity }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      width: "100%",
      display: "flex",
      flexDirection: "column",
      justifyContent: "start",
      alignItems: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            sx: { width: "40%", p: 3, color: "black", bgcolor: "white", mb: 2 },
            children: "Print Receipt"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Card$1, { elevation: 0, sx: { width: "80%", p: 4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            width: "100%",
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "start",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$1,
                {
                  width: "80%",
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "space-between",
                  alignItems: "center",
                  pb: 1,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Box$1,
                      {
                        display: "flex",
                        flexDirection: "row",
                        justifyContent: "start",
                        alignItems: "center",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Box$1,
                            {
                              bgcolor: "#D9D9D9",
                              borderRadius: 12,
                              width: 24,
                              height: 24
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            Typography$1,
                            {
                              color: "#D9D9D9",
                              px: 2,
                              fontSize: 21,
                              fontWeight: 700,
                              children: "Payment Method"
                            }
                          )
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 21, fontWeight: 700, children: activity?.amount })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$1,
                {
                  py: 1,
                  width: "80%",
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "space-between",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", px: 2, fontSize: 21, fontWeight: 700, children: "Cash" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 21, fontWeight: 700, children: "#20,000" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$1,
                {
                  py: 1,
                  width: "80%",
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "space-between",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", px: 2, fontSize: 21, fontWeight: 700, children: "Transfer" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 21, fontWeight: 700, children: "#10,000" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$1,
                {
                  py: 1,
                  width: "80%",
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "space-between",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", px: 2, fontSize: 21, fontWeight: 700, children: "Amount Due" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 21, fontWeight: 700, children: "#0.00" })
                  ]
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ProductTable, {})
      ]
    }
  );
}
function TabPanel$1(props) {
  const { children, value, index: index2, ...other } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      role: "tabpanel",
      hidden: value !== index2,
      id: `vertical-tabpanel-${index2}`,
      "aria-labelledby": `vertical-tab-${index2}`,
      ...other,
      children: value === index2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { p: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children }) })
    }
  );
}
const StyledTabs$1 = styled$1((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Tabs$1,
  {
    orientation: "vertical",
    variant: "scrollable",
    ...props,
    style: { width: "18%" },
    TabIndicatorProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "MuiTabs-indicatorSpan" }) }
  }
))({
  "& .MuiTabs-indicator": {
    display: "flex",
    justifyContent: "center",
    backgroundColor: "transparent"
  },
  "& .MuiTabs-indicatorSpan": {
    maxWidth: 0,
    width: "100%",
    backgroundColor: "#635ee7"
  }
});
const TabButton = ({
  index: index2,
  setValue: setValue2,
  value,
  amount,
  time: time2
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Button$1,
  {
    sx: {
      bgcolor: value === index2 ? "#D9D9D9" : "white",
      py: 2,
      px: 1,
      my: 1
    },
    onClick: () => setValue2(index2),
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        width: "100%",
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              display: "flex",
              flexDirection: "row",
              justifyContent: "start",
              alignItems: "center",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Box$1,
                  {
                    bgcolor: value === index2 ? "#F8F8F8" : "#D9D9D9",
                    borderRadius: 12,
                    width: 24,
                    height: 24
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 16, fontWeight: 700, color: "black", px: 2, children: amount })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 12, fontWeight: 700, color: "black", px: 2, children: time2 })
        ]
      }
    )
  }
);
const Activity = () => {
  const navigate = useNavigate();
  const [value, setValue2] = React.useState(0);
  const handleChange = (event, newValue) => {
    setValue2(newValue);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { height: "100vh", width: "100vw", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "center",
        px: 3,
        py: 2,
        zIndex: 500,
        width: "100%",
        position: "fixed",
        bgcolor: "#ECF0F4",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => navigate("/dashboard/"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBack, { sx: { color: "black" } }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 21, fontWeight: 800, px: 1, children: "Activity" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        m: 4,
        sx: {
          flexGrow: 1,
          display: "flex"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            StyledTabs$1,
            {
              value,
              onChange: handleChange,
              "aria-label": "Vertical tabs example",
              sx: { py: 2, mt: 2, position: "fixed", width: "25%" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "body2", fontWeight: 600, pt: 2, children: "TODAY" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Box$1,
                  {
                    overflow: "scroll",
                    height: "90vh",
                    display: "flex",
                    flexDirection: "column",
                    children: tempActivities.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TabButton,
                      {
                        value,
                        setValue: setValue2,
                        amount: item?.amount,
                        time: item?.time,
                        index: index2
                      },
                      index2
                    ))
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { width: "75%", left: "25%", position: "absolute", children: tempActivities.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel$1, { value, index: index2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemContent, { activity: item }) }, index2)) })
        ]
      }
    )
  ] });
};
function SalesCard({ data }) {
  function getOrdinalSuffix(day2) {
    if (day2 >= 11 && day2 <= 13) {
      return "th";
    }
    switch (day2 % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  }
  const date2 = new Date(Date.parse(`${data?.updated_at}`));
  const day = date2.getDate();
  const ordinalSuffix = getOrdinalSuffix(day);
  const formattedDate = `${day}${ordinalSuffix} ${date2.toLocaleString("en-US", {
    month: "short"
  })}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Card$1, { elevation: 0, sx: { my: 2, p: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { display: "flex", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 1, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 1,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, fontWeight: 300, textAlign: "start", children: `#${data?.id}` })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 2,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          NumericFormat,
          {
            style: { fontSize: 15, fontFamily: "sans-serif" },
            value: parseFloat(data?.final_total)?.toFixed(2),
            displayType: "text",
            thousandSeparator: true,
            prefix: "₦"
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 1,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, fontWeight: 300, textAlign: "start", children: data?.sell_lines?.length })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 2,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: data?.payment_lines?.map((elem, key) => /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 15, textAlign: "start", children: `${elem?.method?.toString().replace("_", " ")}${data?.payment_lines?.length - key > 1 ? "/" : ""}` }) }, key))
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 2,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          NumericFormat,
          {
            style: { fontSize: 15, fontFamily: "sans-serif" },
            value: parseFloat(data?.final_total)?.toFixed(2),
            displayType: "text",
            thousandSeparator: true,
            prefix: "₦"
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 2,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          NumericFormat,
          {
            style: { fontSize: 15, fontFamily: "sans-serif", marginLeft: 10 },
            value: parseFloat("0")?.toFixed(2),
            displayType: "text",
            thousandSeparator: true,
            prefix: "₦"
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 1,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, fontWeight: 300, textAlign: "start", children: new Intl.DateTimeFormat("en-US", {
          hour: "numeric",
          minute: "numeric",
          hour12: true
        }).format(Date.parse(data?.updated_at)) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Grid$1,
      {
        item: true,
        md: 1,
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "start",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 13, fontWeight: 300, textAlign: "start", children: formattedDate })
      }
    )
  ] }) }) });
}
function SalesSummary({ data }) {
  let tSales = 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { children: data && data?.map((item, index2) => {
    const count = 0;
    tSales = count;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { width: "100%", mb: 6, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Typography$1,
        {
          gutterBottom: true,
          fontSize: 22,
          fontWeight: 900,
          color: "black",
          children: item?.date
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 1, mb: -1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Grid$1,
          {
            item: true,
            md: 1,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                fontSize: 13,
                fontWeight: 300,
                textAlign: "center",
                children: "Order No"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Grid$1,
          {
            item: true,
            md: 2,
            display: "flex",
            flexDirection: "row",
            justifyContent: "center",
            alignItems: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                fontSize: 13,
                fontWeight: 300,
                textAlign: "center",
                children: "Total Amount"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Grid$1,
          {
            item: true,
            md: 1,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                fontSize: 13,
                fontWeight: 300,
                textAlign: "center",
                children: "No of Items"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Grid$1,
          {
            item: true,
            md: 2,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                fontSize: 13,
                fontWeight: 300,
                textAlign: "center",
                children: "Mode of Payment"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Grid$1,
          {
            item: true,
            md: 2,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                fontSize: 13,
                fontWeight: 300,
                textAlign: "center",
                children: "Amount Paid"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Grid$1,
          {
            item: true,
            md: 2,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                fontSize: 13,
                fontWeight: 300,
                textAlign: "start",
                children: "Amount Due"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Grid$1,
          {
            item: true,
            md: 1,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                fontSize: 13,
                fontWeight: 300,
                textAlign: "center",
                children: "Time"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Grid$1,
          {
            item: true,
            md: 1,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "start",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Typography$1,
              {
                fontSize: 13,
                fontWeight: 300,
                textAlign: "center",
                children: "Date"
              }
            )
          }
        )
      ] }),
      item?.transactions?.map((it2, index22) => {
        tSales = tSales + parseFloat(`${it2?.final_total}`);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SalesCard, { data: it2 }, index22);
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 3, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 12, sm: 3, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            p: 2.5,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "center",
            component: Card$1,
            elevation: 0,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 14, pr: 1, children: "Total Sales:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                NumericFormat,
                {
                  style: { fontSize: 14, fontFamily: "sans-serif" },
                  value: tSales?.toFixed(2),
                  displayType: "text",
                  thousandSeparator: true,
                  prefix: "₦"
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 12, sm: 3, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            p: 2.5,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "center",
            component: Card$1,
            elevation: 0,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 14, pr: 1, children: "Amount Due:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                NumericFormat,
                {
                  style: { fontSize: 14, fontFamily: "sans-serif" },
                  value: 0?.toFixed(2),
                  displayType: "text",
                  thousandSeparator: true,
                  prefix: "₦"
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 12, sm: 3, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            p: 2.5,
            display: "flex",
            flexDirection: "row",
            justifyContent: "start",
            alignItems: "center",
            component: Card$1,
            elevation: 0,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 14, pr: 1, children: "Cash in Drawer:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                NumericFormat,
                {
                  style: { fontSize: 14, fontFamily: "sans-serif" },
                  value: 3e4?.toFixed(2),
                  displayType: "text",
                  thousandSeparator: true,
                  prefix: "₦"
                }
              )
            ]
          }
        ) })
      ] })
    ] }, index2);
  }) });
}
const tempCurrentRegiser = [
  {
    expenses: 0,
    paymentMethod: "Cash in hand:",
    sellAmount: "₦5,000.00"
  },
  {
    expenses: 0,
    paymentMethod: "Bank Transfer:",
    sellAmount: "₦5,000.00"
  },
  {
    expenses: 0,
    paymentMethod: "Cash in hand:",
    sellAmount: "₦5,000.00"
  },
  {
    expenses: 0,
    paymentMethod: "Cash in payment:",
    sellAmount: "₦5,000.00"
  },
  {
    expenses: 0,
    paymentMethod: "Cash in hand:",
    sellAmount: "₦5,000.00"
  },
  {
    expenses: 0,
    paymentMethod: "Advance payment:",
    sellAmount: "₦5,000.00"
  },
  {
    expenses: 0,
    paymentMethod: "Cash in hand:",
    sellAmount: "₦5,000.00"
  }
];
const StyledTableCell = styled$1(TableCell$1)(({ theme: theme2 }) => ({
  [`&.${tableCellClasses$1.head}`]: {
    backgroundColor: "transparent",
    color: theme2.palette.common.black
  },
  [`&.${tableCellClasses$1.body}`]: {
    fontSize: 14
  }
}));
const StyledTableRow = styled$1(TableRow$1)(({ theme: theme2 }) => ({
  "&:nth-of-type(odd)": {
    backgroundColor: theme2.palette.action.hover
  },
  // hide last border
  "&:last-child td, &:last-child th": {
    border: 0
  }
}));
function createData(name, calories, fat, carbs) {
  return { name, calories, fat, carbs };
}
const rows = [
  createData("#123", "", 6, 24),
  createData("#124", "", 9, 37),
  createData("#125", "", 16, 24),
  createData("#126", "", 3.7, 67),
  createData("#127", "", 16, 49)
];
function ProductSoldTable() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TableContainer$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table$1, { sx: { minWidth: 700 }, "aria-label": "customized table", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTableCell, { children: "SKU" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTableCell, { align: "right", children: "Product" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTableCell, { align: "right", children: "Quantity" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTableCell, { align: "right", children: "Total Amount" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody$1, { children: rows.map((row) => /* @__PURE__ */ jsxRuntimeExports.jsxs(StyledTableRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTableCell, { component: "th", scope: "row", children: row.name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTableCell, { align: "right", children: row.calories }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTableCell, { align: "right", children: row.fat }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTableCell, { align: "right", children: row.carbs })
    ] }, row.name)) })
  ] }) });
}
const denominations = [5, 10, 20, 50, 100, 200, 500, 1e3];
function CashDenominations() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, mb: 1, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "left", children: "Denomination" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "center", children: "Count" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "center", children: "Subtotal" }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card$1, { sx: { borderRadius: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { p: 1, children: denominations.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, p: 3, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center",
          mr: 6,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "start", children: item }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "X" })
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextField$1,
        {
          variant: "filled",
          size: "small",
          InputProps: {
            disableUnderline: true,
            style: {
              borderRadius: 4
            }
          }
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          display: "flex",
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center",
          ml: 6,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "start", children: item })
          ]
        }
      ) })
    ] }, index2)) }) })
  ] });
}
function CurrentRegister() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        width: "100%",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 22, fontWeight: 900, color: "black", children: "Current Register" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "10th July, 2023 7:20 PM - 10th July, 2023 7:20 PM" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, py: 4, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 7, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          display: "flex",
          flexDirection: "column",
          justifyContent: "start",
          alignItems: "stretch",
          width: "96%",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, mb: 1, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 5, md: 5, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "left", children: "Payment Method" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "left", children: "Sell" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 3, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "left", children: "Expenses" }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Card$1, { sx: { borderRadius: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { p: 1, children: tempCurrentRegiser.map(
              (item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, p: 3, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 5, md: 5, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "start", children: item?.paymentMethod }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "start", children: item?.sellAmount }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 3, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "start", children: item?.expenses }) })
              ] }, index2)
            ) }) })
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Grid$1,
        {
          item: true,
          sm: 6,
          md: 5,
          display: "flex",
          flexDirection: "column",
          justifyContent: "end",
          alignItems: "end",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card$1, { sx: { width: "80%", borderRadius: 3 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              p: 4,
              display: "flex",
              flexDirection: "column",
              justifyContent: "start",
              alignItems: "stretch",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Box$1,
                  {
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    py: 1,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Total Sales" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "₦90,000" })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Box$1,
                  {
                    py: 1,
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Total Refund" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "₦90,000" })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Box$1,
                  {
                    py: 1,
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Total Payment" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "₦90,000" })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Box$1,
                  {
                    py: 1,
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Credit Sales" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "₦90,000" })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$1, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Box$1,
                  {
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    pt: 1,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Total Sales" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "₦90,000" })
                    ]
                  }
                )
              ]
            }
          ) })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 22, fontWeight: 900, color: "black", gutterBottom: true, children: "Details of products Sold" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { width: "75%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProductSoldTable, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 22, fontWeight: 900, color: "black", gutterBottom: true, children: "Details of products Sold (By Brand)" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { width: "75%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProductSoldTable, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 22, fontWeight: 900, color: "black", gutterBottom: true, children: "Cash Denominations" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { width: "60%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CashDenominations, {}) })
  ] });
}
function TabPanel(props) {
  const { children, value, index: index2, ...other } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      role: "tabpanel",
      hidden: value !== index2,
      id: `vertical-tabpanel-${index2}`,
      "aria-labelledby": `vertical-tab-${index2}`,
      ...other,
      children: value === index2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { p: 3 }, children })
    }
  );
}
const StyledTabs = styled$1((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Tabs$1,
  {
    orientation: "vertical",
    variant: "scrollable",
    ...props,
    style: { width: "18%" },
    TabIndicatorProps: { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "MuiTabs-indicatorSpan" }) }
  }
))({
  "& .MuiTabs-indicator": {
    display: "flex",
    justifyContent: "center",
    backgroundColor: "transparent"
  },
  "& .MuiTabs-indicatorSpan": {
    maxWidth: 0,
    width: "100%",
    backgroundColor: "#635ee7"
  }
});
const StyledTab = styled$1((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tab$1, { disableRipple: true, ...props }))(({ theme: theme2 }) => ({
  textTransform: "none",
  fontWeight: theme2.typography.fontWeightRegular,
  fontSize: 16,
  marginRight: theme2.spacing(1),
  fontFamily: "Inter",
  paddingLeft: 24,
  paddingRight: 24,
  backgroundColor: "white",
  marginTop: theme2.spacing(1),
  marginBottom: theme2.spacing(1),
  height: 16,
  color: "grey",
  "&.Mui-selected": {
    color: "#000",
    fontWeight: theme2.typography.fontWeightBold,
    backgroundColor: "white",
    fontFamily: "Inter",
    borderRadius: 10,
    paddingLeft: 16,
    paddingRight: 16
  },
  "&.Mui-focusVisible": {
    backgroundColor: "gray"
  }
}));
function a11yProps(index2) {
  return {
    id: `vertical-tab-${index2}`,
    "aria-controls": `vertical-tabpanel-${index2}`
  };
}
const Reports = () => {
  const navigate = useNavigate();
  const [value, setValue2] = React.useState(0);
  const [groupedSales, setGroupedSales] = React.useState();
  const sales = useSelector((state) => state.purchase.sales);
  React.useEffect(() => {
    if (sales) {
      const groupedTransactions = sales.reduce((grouped, transaction) => {
        const date2 = (/* @__PURE__ */ new Date(`${transaction?.updated_at}`)).toLocaleDateString(
          "en-GB"
        );
        console.log("DATE FORMATTED :: ", date2);
        if (!grouped[date2]) {
          grouped[date2] = [];
        }
        grouped[date2].push(transaction);
        return grouped;
      }, {});
      const sortedGroups = Object.keys(groupedTransactions).sort(
        ([dateA], [dateB]) => Date.parse(`${dateA}`) - Date.parse(`${dateB}`)
      ).map((date2) => ({
        date: date2,
        transactions: groupedTransactions[date2]
      }));
      setGroupedSales(sortedGroups);
    }
  }, [sales]);
  const handleChange = (event, newValue) => {
    setValue2(newValue);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { height: "100vh", width: "100vw", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        alignItems: "center",
        px: 3,
        py: 2,
        zIndex: 500,
        width: "100%",
        position: "fixed",
        bgcolor: "#ECF0F4",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => navigate("/dashboard/"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBack, { sx: { color: "black" } }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 21, fontWeight: 800, px: 1, children: "Report" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        m: 4,
        sx: {
          flexGrow: 1,
          display: "flex"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            StyledTabs,
            {
              value,
              onChange: handleChange,
              "aria-label": "Vertical tabs example",
              sx: { py: 2, mt: 10, position: "fixed", width: "20%" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTab, { label: "Sales Summary", ...a11yProps(0) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTab, { label: "Drawer History", ...a11yProps(1) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(StyledTab, { label: "End of the day", ...a11yProps(2) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { width: "78%", left: "20%", position: "absolute", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { value, index: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SalesSummary, { data: groupedSales }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { value, index: 1, children: "Item Two" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TabPanel, { value, index: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CurrentRegister, {}) })
          ] })
        ]
      }
    )
  ] });
};
const GridApiContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useGridApiContext() {
  const apiRef = reactExports.useContext(GridApiContext);
  if (apiRef === void 0) {
    throw new Error(["MUI: Could not find the data grid context.", "It looks like you rendered your component outside of a DataGrid, DataGridPro or DataGridPremium parent component.", "This can also happen if you are bundling multiple versions of the data grid."].join("\n"));
  }
  return apiRef;
}
const GridRootPropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
const useGridRootProps = () => {
  const contextValue = reactExports.useContext(GridRootPropsContext);
  if (!contextValue) {
    throw new Error("MUI: useGridRootProps should only be used inside the DataGrid, DataGridPro or DataGridPremium component.");
  }
  return contextValue;
};
const GridPrivateApiContext = /* @__PURE__ */ reactExports.createContext(void 0);
function useGridPrivateApiContext() {
  const privateApiRef = reactExports.useContext(GridPrivateApiContext);
  if (privateApiRef === void 0) {
    throw new Error(["MUI: Could not find the data grid private context.", "It looks like you rendered your component outside of a DataGrid, DataGridPro or DataGridPremium parent component.", "This can also happen if you are bundling multiple versions of the data grid."].join("\n"));
  }
  return privateApiRef;
}
const UNINITIALIZED = {};
function useLazyRef(init, initArg) {
  const ref = reactExports.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}
const EMPTY = [];
function useOnMount(fn3) {
  reactExports.useEffect(fn3, EMPTY);
}
const buildWarning$1 = (message, gravity = "warning") => {
  let alreadyWarned = false;
  const cleanMessage = Array.isArray(message) ? message.join("\n") : message;
  return () => {
    if (!alreadyWarned) {
      alreadyWarned = true;
      if (gravity === "error") {
        console.error(cleanMessage);
      } else {
        console.warn(cleanMessage);
      }
    }
  };
};
const is2 = Object.is;
function fastObjectShallowCompare(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (!(a2 instanceof Object) || !(b2 instanceof Object)) {
    return false;
  }
  let aLength = 0;
  let bLength = 0;
  for (const key in a2) {
    aLength += 1;
    if (!is2(a2[key], b2[key])) {
      return false;
    }
    if (!(key in b2)) {
      return false;
    }
  }
  for (const _2 in b2) {
    bLength += 1;
  }
  return aLength === bLength;
}
buildWarning$1(["MUI: `useGridSelector` has been called before the initialization of the state.", "This hook can only be used inside the context of the grid."]);
function isOutputSelector(selector) {
  return selector.acceptsApiRef;
}
function applySelector(apiRef, selector) {
  if (isOutputSelector(selector)) {
    return selector(apiRef);
  }
  return selector(apiRef.current.state);
}
const defaultCompare = Object.is;
const objectShallowCompare = fastObjectShallowCompare;
const createRefs = () => ({
  state: null,
  equals: null,
  selector: null
});
const useGridSelector = (apiRef, selector, equals = defaultCompare) => {
  const refs = useLazyRef(createRefs);
  const didInit = refs.current.selector !== null;
  const [state, setState] = reactExports.useState(
    // We don't use an initialization function to avoid allocations
    didInit ? null : applySelector(apiRef, selector)
  );
  refs.current.state = state;
  refs.current.equals = equals;
  refs.current.selector = selector;
  useOnMount(() => {
    return apiRef.current.store.subscribe(() => {
      const newState = applySelector(apiRef, refs.current.selector);
      if (!refs.current.equals(refs.current.state, newState)) {
        refs.current.state = newState;
        setState(newState);
      }
    });
  });
  return state;
};
function getDataGridUtilityClass(slot) {
  return generateUtilityClass("MuiDataGrid", slot);
}
const gridClasses = generateUtilityClasses("MuiDataGrid", ["actionsCell", "aggregationColumnHeader", "aggregationColumnHeader--alignLeft", "aggregationColumnHeader--alignCenter", "aggregationColumnHeader--alignRight", "aggregationColumnHeaderLabel", "autoHeight", "booleanCell", "cell--editable", "cell--editing", "cell--textCenter", "cell--textLeft", "cell--textRight", "cell--withRenderer", "cell--rangeTop", "cell--rangeBottom", "cell--rangeLeft", "cell--rangeRight", "cell", "cellContent", "cellCheckbox", "cellSkeleton", "checkboxInput", "columnHeader--alignCenter", "columnHeader--alignLeft", "columnHeader--alignRight", "columnHeader--dragging", "columnHeader--moving", "columnHeader--numeric", "columnHeader--sortable", "columnHeader--sorted", "columnHeader--filtered", "columnHeader", "columnHeaderCheckbox", "columnHeaderDraggableContainer", "columnHeaderDropZone", "columnHeaderTitle", "columnHeaderTitleContainer", "columnHeaderTitleContainerContent", "columnGroupHeader", "columnHeader--filledGroup", "columnHeader--emptyGroup", "columnHeader--showColumnBorder", "columnHeaders", "columnHeadersInner", "columnHeadersInner--scrollable", "columnSeparator--resizable", "columnSeparator--resizing", "columnSeparator--sideLeft", "columnSeparator--sideRight", "columnSeparator", "columnsPanel", "columnsPanelRow", "detailPanel", "detailPanels", "detailPanelToggleCell", "detailPanelToggleCell--expanded", "footerCell", "panel", "panelHeader", "panelWrapper", "panelContent", "panelFooter", "paper", "editBooleanCell", "editInputCell", "filterForm", "filterFormDeleteIcon", "filterFormLogicOperatorInput", "filterFormColumnInput", "filterFormOperatorInput", "filterFormValueInput", "filterIcon", "footerContainer", "headerFilterRow", "iconButtonContainer", "iconSeparator", "main", "menu", "menuIcon", "menuIconButton", "menuOpen", "menuList", "overlay", "overlayWrapper", "overlayWrapperInner", "root", "root--densityStandard", "root--densityComfortable", "root--densityCompact", "root--disableUserSelection", "row", "row--editable", "row--editing", "row--lastVisible", "row--dragging", "row--dynamicHeight", "row--detailPanelExpanded", "rowReorderCellPlaceholder", "rowCount", "rowReorderCellContainer", "rowReorderCell", "rowReorderCell--draggable", "scrollArea--left", "scrollArea--right", "scrollArea", "selectedRowCount", "sortIcon", "toolbarContainer", "toolbarFilterList", "virtualScroller", "virtualScrollerContent", "virtualScrollerContent--overflowed", "virtualScrollerRenderZone", "pinnedColumns", "pinnedColumns--left", "pinnedColumns--right", "pinnedColumnHeaders", "pinnedColumnHeaders--left", "pinnedColumnHeaders--right", "withBorderColor", "cell--withRightBorder", "columnHeader--withRightBorder", "treeDataGroupingCell", "treeDataGroupingCellToggle", "groupingCriteriaCell", "groupingCriteriaCellToggle", "pinnedRows", "pinnedRows--top", "pinnedRows--bottom", "pinnedRowsRenderZone"]);
const cacheContainer = {
  cache: /* @__PURE__ */ new WeakMap()
};
buildWarning$1(["MUI: A selector was called without passing the instance ID, which may impact the performance of the grid.", "To fix, call it with `apiRef`, e.g. `mySelector(apiRef)`, or pass the instance ID explicitly, e.g. `mySelector(state, apiRef.current.instanceId)`."]);
function checkIsAPIRef(value) {
  return "current" in value && "instanceId" in value.current;
}
const DEFAULT_INSTANCE_ID = {
  id: "default"
};
const createSelector = (a2, b2, c2, d2, e2, f2, ...rest) => {
  if (rest.length > 0) {
    throw new Error("Unsupported number of selectors");
  }
  let selector;
  if (a2 && b2 && c2 && d2 && e2 && f2) {
    selector = (stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId2 = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a2(state, instanceId2);
      const vb2 = b2(state, instanceId2);
      const vc2 = c2(state, instanceId2);
      const vd2 = d2(state, instanceId2);
      const ve2 = e2(state, instanceId2);
      return f2(va2, vb2, vc2, vd2, ve2);
    };
  } else if (a2 && b2 && c2 && d2 && e2) {
    selector = (stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId2 = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a2(state, instanceId2);
      const vb2 = b2(state, instanceId2);
      const vc2 = c2(state, instanceId2);
      const vd2 = d2(state, instanceId2);
      return e2(va2, vb2, vc2, vd2);
    };
  } else if (a2 && b2 && c2 && d2) {
    selector = (stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId2 = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a2(state, instanceId2);
      const vb2 = b2(state, instanceId2);
      const vc2 = c2(state, instanceId2);
      return d2(va2, vb2, vc2);
    };
  } else if (a2 && b2 && c2) {
    selector = (stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId2 = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a2(state, instanceId2);
      const vb2 = b2(state, instanceId2);
      return c2(va2, vb2);
    };
  } else if (a2 && b2) {
    selector = (stateOrApiRef, instanceIdParam) => {
      const isAPIRef = checkIsAPIRef(stateOrApiRef);
      const instanceId2 = instanceIdParam != null ? instanceIdParam : isAPIRef ? stateOrApiRef.current.instanceId : DEFAULT_INSTANCE_ID;
      const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
      const va2 = a2(state, instanceId2);
      return b2(va2);
    };
  } else {
    throw new Error("Missing arguments");
  }
  selector.acceptsApiRef = true;
  return selector;
};
const createSelectorMemoized = (...args) => {
  const selector = (...selectorArgs) => {
    var _cache$get, _cache$get3;
    const [stateOrApiRef, instanceId2] = selectorArgs;
    const isAPIRef = checkIsAPIRef(stateOrApiRef);
    const cacheKey = isAPIRef ? stateOrApiRef.current.instanceId : instanceId2 != null ? instanceId2 : DEFAULT_INSTANCE_ID;
    const state = isAPIRef ? stateOrApiRef.current.state : stateOrApiRef;
    const {
      cache: cache2
    } = cacheContainer;
    if (cache2.get(cacheKey) && (_cache$get = cache2.get(cacheKey)) != null && _cache$get.get(args)) {
      var _cache$get2;
      return (_cache$get2 = cache2.get(cacheKey)) == null ? void 0 : _cache$get2.get(args)(state, cacheKey);
    }
    const newSelector = createSelector$1(...args);
    if (!cache2.get(cacheKey)) {
      cache2.set(cacheKey, /* @__PURE__ */ new Map());
    }
    (_cache$get3 = cache2.get(cacheKey)) == null || _cache$get3.set(args, newSelector);
    return newSelector(state, cacheKey);
  };
  selector.acceptsApiRef = true;
  return selector;
};
const gridColumnsStateSelector = (state) => state.columns;
const gridColumnFieldsSelector = createSelector(gridColumnsStateSelector, (columnsState) => columnsState.orderedFields);
const gridColumnLookupSelector = createSelector(gridColumnsStateSelector, (columnsState) => columnsState.lookup);
const gridColumnDefinitionsSelector = createSelectorMemoized(gridColumnFieldsSelector, gridColumnLookupSelector, (allFields, lookup2) => allFields.map((field) => lookup2[field]));
const gridColumnVisibilityModelSelector = createSelector(gridColumnsStateSelector, (columnsState) => columnsState.columnVisibilityModel);
const gridVisibleColumnDefinitionsSelector = createSelectorMemoized(gridColumnDefinitionsSelector, gridColumnVisibilityModelSelector, (columns, columnVisibilityModel) => columns.filter((column2) => columnVisibilityModel[column2.field] !== false));
const gridVisibleColumnFieldsSelector = createSelectorMemoized(gridVisibleColumnDefinitionsSelector, (visibleColumns) => visibleColumns.map((column2) => column2.field));
const gridColumnPositionsSelector = createSelectorMemoized(gridVisibleColumnDefinitionsSelector, (visibleColumns) => {
  const positions = [];
  let currentPosition = 0;
  for (let i2 = 0; i2 < visibleColumns.length; i2 += 1) {
    positions.push(currentPosition);
    currentPosition += visibleColumns[i2].computedWidth;
  }
  return positions;
});
const gridColumnsTotalWidthSelector = createSelector(gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector, (visibleColumns, positions) => {
  const colCount = visibleColumns.length;
  if (colCount === 0) {
    return 0;
  }
  return positions[colCount - 1] + visibleColumns[colCount - 1].computedWidth;
});
const gridFilterableColumnDefinitionsSelector = createSelectorMemoized(gridColumnDefinitionsSelector, (columns) => columns.filter((col) => col.filterable));
const gridFilterableColumnLookupSelector = createSelectorMemoized(gridColumnDefinitionsSelector, (columns) => columns.reduce((acc, col) => {
  if (col.filterable) {
    acc[col.field] = col;
  }
  return acc;
}, {}));
const gridColumnGroupingSelector = (state) => state.columnGrouping;
const gridColumnGroupsUnwrappedModelSelector = createSelectorMemoized(gridColumnGroupingSelector, (columnGrouping) => {
  var _columnGrouping$unwra;
  return (_columnGrouping$unwra = columnGrouping == null ? void 0 : columnGrouping.unwrappedGroupingModel) != null ? _columnGrouping$unwra : {};
});
const gridColumnGroupsLookupSelector = createSelectorMemoized(gridColumnGroupingSelector, (columnGrouping) => {
  var _columnGrouping$looku;
  return (_columnGrouping$looku = columnGrouping == null ? void 0 : columnGrouping.lookup) != null ? _columnGrouping$looku : {};
});
const gridColumnGroupsHeaderStructureSelector = createSelectorMemoized(gridColumnGroupingSelector, (columnGrouping) => {
  var _columnGrouping$heade;
  return (_columnGrouping$heade = columnGrouping == null ? void 0 : columnGrouping.headerStructure) != null ? _columnGrouping$heade : [];
});
const gridColumnGroupsHeaderMaxDepthSelector = createSelector(gridColumnGroupingSelector, (columnGrouping) => {
  var _columnGrouping$maxDe;
  return (_columnGrouping$maxDe = columnGrouping == null ? void 0 : columnGrouping.maxDepth) != null ? _columnGrouping$maxDe : 0;
});
const gridRowsStateSelector = (state) => state.rows;
const gridRowCountSelector = createSelector(gridRowsStateSelector, (rows2) => rows2.totalRowCount);
const gridRowsLoadingSelector = createSelector(gridRowsStateSelector, (rows2) => rows2.loading);
const gridTopLevelRowCountSelector = createSelector(gridRowsStateSelector, (rows2) => rows2.totalTopLevelRowCount);
const gridRowsLookupSelector = createSelector(gridRowsStateSelector, (rows2) => rows2.dataRowIdToModelLookup);
const gridRowsDataRowIdToIdLookupSelector = createSelector(gridRowsStateSelector, (rows2) => rows2.dataRowIdToIdLookup);
const gridRowTreeSelector = createSelector(gridRowsStateSelector, (rows2) => rows2.tree);
const gridRowGroupingNameSelector = createSelector(gridRowsStateSelector, (rows2) => rows2.groupingName);
const gridRowTreeDepthsSelector = createSelector(gridRowsStateSelector, (rows2) => rows2.treeDepths);
const gridRowMaximumTreeDepthSelector = createSelectorMemoized(gridRowsStateSelector, (rows2) => {
  const entries = Object.entries(rows2.treeDepths);
  if (entries.length === 0) {
    return 1;
  }
  return entries.filter(([, nodeCount]) => nodeCount > 0).map(([depth]) => Number(depth)).sort((a2, b2) => b2 - a2)[0] + 1;
});
const gridDataRowIdsSelector = createSelector(gridRowsStateSelector, (rows2) => rows2.dataRowIds);
const gridAdditionalRowGroupsSelector = createSelector(gridRowsStateSelector, (rows2) => rows2 == null ? void 0 : rows2.additionalRowGroups);
const gridPinnedRowsSelector = createSelectorMemoized(gridAdditionalRowGroupsSelector, (additionalRowGroups) => {
  var _rawPinnedRows$bottom, _rawPinnedRows$top;
  const rawPinnedRows = additionalRowGroups == null ? void 0 : additionalRowGroups.pinnedRows;
  return {
    bottom: rawPinnedRows == null || (_rawPinnedRows$bottom = rawPinnedRows.bottom) == null ? void 0 : _rawPinnedRows$bottom.map((rowEntry) => {
      var _rowEntry$model;
      return {
        id: rowEntry.id,
        model: (_rowEntry$model = rowEntry.model) != null ? _rowEntry$model : {}
      };
    }),
    top: rawPinnedRows == null || (_rawPinnedRows$top = rawPinnedRows.top) == null ? void 0 : _rawPinnedRows$top.map((rowEntry) => {
      var _rowEntry$model2;
      return {
        id: rowEntry.id,
        model: (_rowEntry$model2 = rowEntry.model) != null ? _rowEntry$model2 : {}
      };
    })
  };
});
const gridPinnedRowsCountSelector = createSelector(gridPinnedRowsSelector, (pinnedRows) => {
  var _pinnedRows$top, _pinnedRows$bottom;
  return ((pinnedRows == null || (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.length) || 0) + ((pinnedRows == null || (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.length) || 0);
});
const useGridAriaAttributes = () => {
  var _rootProps$experiment;
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const totalRowCount = useGridSelector(apiRef, gridRowCountSelector);
  const headerGroupingMaxDepth = useGridSelector(apiRef, gridColumnGroupsHeaderMaxDepthSelector);
  const pinnedRowsCount = useGridSelector(apiRef, gridPinnedRowsCountSelector);
  let role = "grid";
  if ((_rootProps$experiment = rootProps.experimentalFeatures) != null && _rootProps$experiment.ariaV7 && rootProps.treeData) {
    role = "treegrid";
  }
  return {
    role,
    "aria-colcount": visibleColumns.length,
    "aria-rowcount": headerGroupingMaxDepth + 1 + pinnedRowsCount + totalRowCount,
    "aria-multiselectable": !rootProps.disableMultipleRowSelection
  };
};
const useUtilityClasses$Q = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["main"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridMainContainerRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "Main",
  overridesResolver: (props, styles2) => styles2.main
})(() => ({
  position: "relative",
  flexGrow: 1,
  display: "flex",
  flexDirection: "column",
  overflow: "hidden"
}));
const GridMainContainer = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var _rootProps$experiment;
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$Q(rootProps);
  const getAriaAttributes = (_rootProps$experiment = rootProps.experimentalFeatures) != null && _rootProps$experiment.ariaV7 ? useGridAriaAttributes : null;
  const ariaAttributes = typeof getAriaAttributes === "function" ? getAriaAttributes() : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridMainContainerRoot, _extends$2({
    ref,
    className: classes.root,
    ownerState: rootProps
  }, ariaAttributes, {
    children: props.children
  }));
});
const gridSortingStateSelector = (state) => state.sorting;
const gridSortedRowIdsSelector = createSelector(gridSortingStateSelector, (sortingState) => sortingState.sortedRows);
const gridSortedRowEntriesSelector = createSelectorMemoized(
  gridSortedRowIdsSelector,
  gridRowsLookupSelector,
  // TODO rows v6: Is this the best approach ?
  (sortedIds, idRowsLookup) => sortedIds.map((id2) => {
    var _idRowsLookup$id;
    return {
      id: id2,
      model: (_idRowsLookup$id = idRowsLookup[id2]) != null ? _idRowsLookup$id : {}
    };
  })
);
const gridSortModelSelector = createSelector(gridSortingStateSelector, (sorting) => sorting.sortModel);
const gridSortColumnLookupSelector = createSelectorMemoized(gridSortModelSelector, (sortModel) => {
  const result = sortModel.reduce((res, sortItem, index2) => {
    res[sortItem.field] = {
      sortDirection: sortItem.sort,
      sortIndex: sortModel.length > 1 ? index2 + 1 : void 0
    };
    return res;
  }, {});
  return result;
});
const gridFilterStateSelector = (state) => state.filter;
const gridFilterModelSelector = createSelector(gridFilterStateSelector, (filterState) => filterState.filterModel);
createSelector(gridFilterModelSelector, (filterModel) => filterModel.quickFilterValues);
const gridVisibleRowsLookupSelector = (state) => state.visibleRowsLookup;
const gridFilteredRowsLookupSelector = createSelector(gridFilterStateSelector, (filterState) => filterState.filteredRowsLookup);
createSelector(gridFilterStateSelector, (filterState) => filterState.filteredDescendantCountLookup);
const gridExpandedSortedRowEntriesSelector = createSelectorMemoized(gridVisibleRowsLookupSelector, gridSortedRowEntriesSelector, (visibleRowsLookup, sortedRows) => sortedRows.filter((row) => visibleRowsLookup[row.id] !== false));
const gridExpandedSortedRowIdsSelector = createSelectorMemoized(gridExpandedSortedRowEntriesSelector, (visibleSortedRowEntries) => visibleSortedRowEntries.map((row) => row.id));
const gridFilteredSortedRowEntriesSelector = createSelectorMemoized(gridFilteredRowsLookupSelector, gridSortedRowEntriesSelector, (filteredRowsLookup, sortedRows) => sortedRows.filter((row) => filteredRowsLookup[row.id] !== false));
const gridFilteredSortedRowIdsSelector = createSelectorMemoized(gridFilteredSortedRowEntriesSelector, (filteredSortedRowEntries) => filteredSortedRowEntries.map((row) => row.id));
const gridFilteredSortedTopLevelRowEntriesSelector = createSelectorMemoized(gridExpandedSortedRowEntriesSelector, gridRowTreeSelector, gridRowMaximumTreeDepthSelector, (visibleSortedRows, rowTree, rowTreeDepth) => {
  if (rowTreeDepth < 2) {
    return visibleSortedRows;
  }
  return visibleSortedRows.filter((row) => {
    var _rowTree$row$id;
    return ((_rowTree$row$id = rowTree[row.id]) == null ? void 0 : _rowTree$row$id.depth) === 0;
  });
});
const gridExpandedRowCountSelector = createSelector(gridExpandedSortedRowEntriesSelector, (visibleSortedRows) => visibleSortedRows.length);
const gridFilteredTopLevelRowCountSelector = createSelector(gridFilteredSortedTopLevelRowEntriesSelector, (visibleSortedTopLevelRows) => visibleSortedTopLevelRows.length);
const gridFilterActiveItemsSelector = createSelectorMemoized(gridFilterModelSelector, gridColumnLookupSelector, (filterModel, columnLookup) => {
  var _filterModel$items;
  return (_filterModel$items = filterModel.items) == null ? void 0 : _filterModel$items.filter((item) => {
    var _column$filterOperato, _item$value;
    if (!item.field) {
      return false;
    }
    const column2 = columnLookup[item.field];
    if (!(column2 != null && column2.filterOperators) || (column2 == null || (_column$filterOperato = column2.filterOperators) == null ? void 0 : _column$filterOperato.length) === 0) {
      return false;
    }
    const filterOperator = column2.filterOperators.find((operator) => operator.value === item.operator);
    if (!filterOperator) {
      return false;
    }
    return !filterOperator.InputComponent || item.value != null && ((_item$value = item.value) == null ? void 0 : _item$value.toString()) !== "";
  });
});
const gridFilterActiveItemsLookupSelector = createSelectorMemoized(gridFilterActiveItemsSelector, (activeFilters) => {
  const result = activeFilters.reduce((res, filterItem) => {
    if (!res[filterItem.field]) {
      res[filterItem.field] = [filterItem];
    } else {
      res[filterItem.field].push(filterItem);
    }
    return res;
  }, {});
  return result;
});
const gridFocusStateSelector = (state) => state.focus;
const gridFocusCellSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.cell);
const gridFocusColumnHeaderSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.columnHeader);
createSelector(gridFocusStateSelector, (focusState) => focusState.columnHeaderFilter);
const unstable_gridFocusColumnGroupHeaderSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.columnGroupHeader);
const gridTabIndexStateSelector = (state) => state.tabIndex;
const gridTabIndexCellSelector = createSelector(gridTabIndexStateSelector, (state) => state.cell);
const gridTabIndexColumnHeaderSelector = createSelector(gridTabIndexStateSelector, (state) => state.columnHeader);
createSelector(gridTabIndexStateSelector, (state) => state.columnHeaderFilter);
const unstable_gridTabIndexColumnGroupHeaderSelector = createSelector(gridTabIndexStateSelector, (state) => state.columnGroupHeader);
const gridDensitySelector = (state) => state.density;
const gridDensityValueSelector = createSelector(gridDensitySelector, (density) => density.value);
const gridDensityFactorSelector = createSelector(gridDensitySelector, (density) => density.factor);
const gridColumnMenuSelector = (state) => state.columnMenu;
function GridBody(props) {
  const {
    VirtualScrollerComponent,
    ColumnHeadersProps,
    children
  } = props;
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const rootRef = reactExports.useRef(null);
  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const filterColumnLookup = useGridSelector(apiRef, gridFilterActiveItemsLookupSelector);
  const sortColumnLookup = useGridSelector(apiRef, gridSortColumnLookupSelector);
  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);
  const columnHeaderTabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);
  const cellTabIndexState = useGridSelector(apiRef, gridTabIndexCellSelector);
  const columnGroupHeaderTabIndexState = useGridSelector(apiRef, unstable_gridTabIndexColumnGroupHeaderSelector);
  const columnHeaderFocus = useGridSelector(apiRef, gridFocusColumnHeaderSelector);
  const columnGroupHeaderFocus = useGridSelector(apiRef, unstable_gridFocusColumnGroupHeaderSelector);
  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);
  const headerGroupingMaxDepth = useGridSelector(apiRef, gridColumnGroupsHeaderMaxDepthSelector);
  const columnMenuState = useGridSelector(apiRef, gridColumnMenuSelector);
  const columnVisibility = useGridSelector(apiRef, gridColumnVisibilityModelSelector);
  const columnGroupsHeaderStructure = useGridSelector(apiRef, gridColumnGroupsHeaderStructureSelector);
  const hasOtherElementInTabSequence = !(columnGroupHeaderTabIndexState === null && columnHeaderTabIndexState === null && cellTabIndexState === null);
  useEnhancedEffect$1(() => {
    apiRef.current.computeSizeAndPublishResizeEvent();
    const elementToObserve = rootRef.current;
    if (typeof ResizeObserver === "undefined") {
      return () => {
      };
    }
    let animationFrame;
    const observer = new ResizeObserver(() => {
      animationFrame = requestAnimationFrame(() => {
        apiRef.current.computeSizeAndPublishResizeEvent();
      });
    });
    if (elementToObserve) {
      observer.observe(elementToObserve);
    }
    return () => {
      if (animationFrame) {
        window.cancelAnimationFrame(animationFrame);
      }
      if (elementToObserve) {
        observer.unobserve(elementToObserve);
      }
    };
  }, [apiRef]);
  const columnHeadersRef = reactExports.useRef(null);
  const columnsContainerRef = reactExports.useRef(null);
  const virtualScrollerRef = reactExports.useRef(null);
  apiRef.current.register("private", {
    columnHeadersContainerElementRef: columnsContainerRef,
    columnHeadersElementRef: columnHeadersRef,
    virtualScrollerRef,
    mainElementRef: rootRef
  });
  const hasDimensions = !!apiRef.current.getRootDimensions();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridMainContainer, {
    ref: rootRef,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnHeaders, _extends$2({
      ref: columnsContainerRef,
      innerRef: columnHeadersRef,
      visibleColumns,
      filterColumnLookup,
      sortColumnLookup,
      columnPositions,
      columnHeaderTabIndexState,
      columnGroupHeaderTabIndexState,
      columnHeaderFocus,
      columnGroupHeaderFocus,
      densityFactor,
      headerGroupingMaxDepth,
      columnMenuState,
      columnVisibility,
      columnGroupsHeaderStructure,
      hasOtherElementInTabSequence
    }, ColumnHeadersProps)), hasDimensions && /* @__PURE__ */ jsxRuntimeExports.jsx(
      VirtualScrollerComponent,
      {
        ref: virtualScrollerRef
      }
    ), children]
  });
}
function GridFooterPlaceholder() {
  var _rootProps$slotProps;
  const rootProps = useGridRootProps();
  if (rootProps.hideFooter) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.footer, _extends$2({}, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.footer));
}
const GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;
const GRID_ID_AUTOGENERATED = Symbol("mui.id_autogenerated");
const buildRootGroup = () => ({
  type: "group",
  id: GRID_ROOT_GROUP_ID,
  depth: -1,
  groupingField: null,
  groupingKey: null,
  isAutoGenerated: true,
  children: [],
  childrenFromPath: {},
  childrenExpanded: true,
  parent: null
});
function checkGridRowIdIsValid(id2, row, detailErrorMessage = "A row was provided without id in the rows prop:") {
  if (id2 == null) {
    throw new Error(["MUI: The data grid component requires all rows to have a unique `id` property.", "Alternatively, you can use the `getRowId` prop to specify a custom id for each row.", detailErrorMessage, JSON.stringify(row)].join("\n"));
  }
}
const getRowIdFromRowModel = (rowModel, getRowId, detailErrorMessage) => {
  const id2 = getRowId ? getRowId(rowModel) : rowModel.id;
  checkGridRowIdIsValid(id2, rowModel, detailErrorMessage);
  return id2;
};
const createRowsInternalCache = ({
  rows: rows2,
  getRowId,
  loading,
  rowCount
}) => {
  const updates = {
    type: "full",
    rows: []
  };
  const dataRowIdToModelLookup = {};
  const dataRowIdToIdLookup = {};
  for (let i2 = 0; i2 < rows2.length; i2 += 1) {
    const model = rows2[i2];
    const id2 = getRowIdFromRowModel(model, getRowId);
    dataRowIdToModelLookup[id2] = model;
    dataRowIdToIdLookup[id2] = id2;
    updates.rows.push(id2);
  }
  return {
    rowsBeforePartialUpdates: rows2,
    loadingPropBeforePartialUpdates: loading,
    rowCountPropBeforePartialUpdates: rowCount,
    updates,
    dataRowIdToIdLookup,
    dataRowIdToModelLookup
  };
};
const getTopLevelRowCount = ({
  tree,
  rowCountProp = 0
}) => {
  const rootGroupNode = tree[GRID_ROOT_GROUP_ID];
  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));
};
const getRowsStateFromCache = ({
  apiRef,
  rowCountProp = 0,
  loadingProp,
  previousTree,
  previousTreeDepths
}) => {
  const cache2 = apiRef.current.caches.rows;
  const {
    tree: unProcessedTree,
    treeDepths: unProcessedTreeDepths,
    dataRowIds: unProcessedDataRowIds,
    groupingName
  } = apiRef.current.applyStrategyProcessor("rowTreeCreation", {
    previousTree,
    previousTreeDepths,
    updates: cache2.updates,
    dataRowIdToIdLookup: cache2.dataRowIdToIdLookup,
    dataRowIdToModelLookup: cache2.dataRowIdToModelLookup
  });
  const groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors("hydrateRows", {
    tree: unProcessedTree,
    treeDepths: unProcessedTreeDepths,
    dataRowIdToIdLookup: cache2.dataRowIdToIdLookup,
    dataRowIds: unProcessedDataRowIds,
    dataRowIdToModelLookup: cache2.dataRowIdToModelLookup
  });
  apiRef.current.caches.rows.updates = {
    type: "partial",
    actions: {
      insert: [],
      modify: [],
      remove: []
    },
    idToActionLookup: {}
  };
  return _extends$2({}, groupingParamsWithHydrateRows, {
    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),
    totalTopLevelRowCount: getTopLevelRowCount({
      tree: groupingParamsWithHydrateRows.tree,
      rowCountProp
    }),
    groupingName,
    loading: loadingProp
  });
};
const isAutoGeneratedRow = (rowNode) => rowNode.type === "skeletonRow" || rowNode.type === "footer" || rowNode.type === "group" && rowNode.isAutoGenerated || rowNode.type === "pinnedRow" && rowNode.isAutoGenerated;
const getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {
  const node2 = tree[parentId];
  if (node2.type !== "group") {
    return [];
  }
  const validDescendants = [];
  for (let i2 = 0; i2 < node2.children.length; i2 += 1) {
    const child = node2.children[i2];
    if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[child])) {
      validDescendants.push(child);
    }
    validDescendants.push(...getTreeNodeDescendants(tree, child, skipAutoGeneratedRows));
  }
  if (!skipAutoGeneratedRows && node2.footerId != null) {
    validDescendants.push(node2.footerId);
  }
  return validDescendants;
};
const updateCacheWithNewRows = ({
  previousCache,
  getRowId,
  updates
}) => {
  var _previousCache$update, _previousCache$update2, _previousCache$update3;
  if (previousCache.updates.type === "full") {
    throw new Error("MUI: Unable to prepare a partial update if a full update is not applied yet");
  }
  const uniqueUpdates = /* @__PURE__ */ new Map();
  updates.forEach((update2) => {
    const id2 = getRowIdFromRowModel(update2, getRowId, "A row was provided without id when calling updateRows():");
    if (uniqueUpdates.has(id2)) {
      uniqueUpdates.set(id2, _extends$2({}, uniqueUpdates.get(id2), update2));
    } else {
      uniqueUpdates.set(id2, update2);
    }
  });
  const partialUpdates = {
    type: "partial",
    actions: {
      insert: [...(_previousCache$update = previousCache.updates.actions.insert) != null ? _previousCache$update : []],
      modify: [...(_previousCache$update2 = previousCache.updates.actions.modify) != null ? _previousCache$update2 : []],
      remove: [...(_previousCache$update3 = previousCache.updates.actions.remove) != null ? _previousCache$update3 : []]
    },
    idToActionLookup: _extends$2({}, previousCache.updates.idToActionLookup)
  };
  const dataRowIdToModelLookup = _extends$2({}, previousCache.dataRowIdToModelLookup);
  const dataRowIdToIdLookup = _extends$2({}, previousCache.dataRowIdToIdLookup);
  const alreadyAppliedActionsToRemove = {
    insert: {},
    modify: {},
    remove: {}
  };
  uniqueUpdates.forEach((partialRow, id2) => {
    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id2];
    if (partialRow._action === "delete") {
      if (actionAlreadyAppliedToRow === "remove" || !dataRowIdToModelLookup[id2]) {
        return;
      }
      if (actionAlreadyAppliedToRow != null) {
        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id2] = true;
      }
      partialUpdates.actions.remove.push(id2);
      delete dataRowIdToModelLookup[id2];
      delete dataRowIdToIdLookup[id2];
      return;
    }
    const oldRow = dataRowIdToModelLookup[id2];
    if (oldRow) {
      if (actionAlreadyAppliedToRow === "remove") {
        alreadyAppliedActionsToRemove.remove[id2] = true;
        partialUpdates.actions.modify.push(id2);
      } else if (actionAlreadyAppliedToRow == null) {
        partialUpdates.actions.modify.push(id2);
      }
      dataRowIdToModelLookup[id2] = _extends$2({}, oldRow, partialRow);
      return;
    }
    if (actionAlreadyAppliedToRow === "remove") {
      alreadyAppliedActionsToRemove.remove[id2] = true;
      partialUpdates.actions.insert.push(id2);
    } else if (actionAlreadyAppliedToRow == null) {
      partialUpdates.actions.insert.push(id2);
    }
    dataRowIdToModelLookup[id2] = partialRow;
    dataRowIdToIdLookup[id2] = id2;
  });
  const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);
  for (let i2 = 0; i2 < actionTypeWithActionsToRemove.length; i2 += 1) {
    const actionType = actionTypeWithActionsToRemove[i2];
    const idsToRemove = alreadyAppliedActionsToRemove[actionType];
    if (Object.keys(idsToRemove).length > 0) {
      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter((id2) => !idsToRemove[id2]);
    }
  }
  return {
    dataRowIdToModelLookup,
    dataRowIdToIdLookup,
    updates: partialUpdates,
    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,
    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,
    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates
  };
};
function calculatePinnedRowsHeight(apiRef) {
  var _pinnedRows$top, _pinnedRows$bottom;
  const pinnedRows = gridPinnedRowsSelector(apiRef);
  const topPinnedRowsHeight = (pinnedRows == null || (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.reduce((acc, value) => {
    acc += apiRef.current.unstable_getRowHeight(value.id);
    return acc;
  }, 0)) || 0;
  const bottomPinnedRowsHeight = (pinnedRows == null || (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.reduce((acc, value) => {
    acc += apiRef.current.unstable_getRowHeight(value.id);
    return acc;
  }, 0)) || 0;
  return {
    top: topPinnedRowsHeight,
    bottom: bottomPinnedRowsHeight
  };
}
function getMinimalContentHeight(apiRef, rowHeight) {
  const densityFactor = gridDensityFactorSelector(apiRef);
  return `var(--DataGrid-overlayHeight, ${2 * Math.floor(rowHeight * densityFactor)}px)`;
}
const GridOverlayWrapperRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "OverlayWrapper",
  shouldForwardProp: (prop) => prop !== "overlayType",
  overridesResolver: (props, styles2) => styles2.overlayWrapper
})(({
  overlayType
}) => ({
  position: "sticky",
  // To stay in place while scrolling
  top: 0,
  left: 0,
  width: 0,
  // To stay above the content instead of shifting it down
  height: 0,
  // To stay above the content instead of shifting it down
  zIndex: overlayType === "loadingOverlay" ? 5 : 4
  // Should be above pinned columns and detail panel
}));
const GridOverlayWrapperInner = styled$3("div", {
  name: "MuiDataGrid",
  slot: "OverlayWrapperInner",
  shouldForwardProp: (prop) => prop !== "overlayType",
  overridesResolver: (props, styles2) => styles2.overlayWrapperInner
})({});
const useUtilityClasses$P = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["overlayWrapper"],
    inner: ["overlayWrapperInner"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridOverlayWrapper(props) {
  var _viewportInnerSize$he, _viewportInnerSize$wi;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const [viewportInnerSize, setViewportInnerSize] = reactExports.useState(() => {
    var _apiRef$current$getRo, _apiRef$current$getRo2;
    return (_apiRef$current$getRo = (_apiRef$current$getRo2 = apiRef.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo2.viewportInnerSize) != null ? _apiRef$current$getRo : null;
  });
  const handleViewportSizeChange = reactExports.useCallback(() => {
    var _apiRef$current$getRo3, _apiRef$current$getRo4;
    setViewportInnerSize((_apiRef$current$getRo3 = (_apiRef$current$getRo4 = apiRef.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo4.viewportInnerSize) != null ? _apiRef$current$getRo3 : null);
  }, [apiRef]);
  useEnhancedEffect$1(() => {
    return apiRef.current.subscribeEvent("viewportInnerSizeChange", handleViewportSizeChange);
  }, [apiRef, handleViewportSizeChange]);
  let height2 = (_viewportInnerSize$he = viewportInnerSize == null ? void 0 : viewportInnerSize.height) != null ? _viewportInnerSize$he : 0;
  if (rootProps.autoHeight && height2 === 0) {
    height2 = getMinimalContentHeight(apiRef, rootProps.rowHeight);
  }
  const classes = useUtilityClasses$P(_extends$2({}, props, {
    classes: rootProps.classes
  }));
  if (!viewportInnerSize) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayWrapperRoot, {
    className: clsx(classes.root),
    overlayType: props.overlayType,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayWrapperInner, _extends$2({
      className: clsx(classes.inner),
      style: {
        height: height2,
        width: (_viewportInnerSize$wi = viewportInnerSize == null ? void 0 : viewportInnerSize.width) != null ? _viewportInnerSize$wi : 0
      }
    }, props))
  });
}
function GridOverlays() {
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const totalRowCount = useGridSelector(apiRef, gridRowCountSelector);
  const visibleRowCount = useGridSelector(apiRef, gridExpandedRowCountSelector);
  const loading = useGridSelector(apiRef, gridRowsLoadingSelector);
  const showNoRowsOverlay = !loading && totalRowCount === 0;
  const showNoResultsOverlay = !loading && totalRowCount > 0 && visibleRowCount === 0;
  let overlay = null;
  let overlayType = "";
  if (showNoRowsOverlay) {
    var _rootProps$slotProps;
    overlay = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.noRowsOverlay, _extends$2({}, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.noRowsOverlay));
    overlayType = "noRowsOverlay";
  }
  if (showNoResultsOverlay) {
    var _rootProps$slotProps2;
    overlay = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.noResultsOverlay, _extends$2({}, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.noResultsOverlay));
    overlayType = "noResultsOverlay";
  }
  if (loading) {
    var _rootProps$slotProps3;
    overlay = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadingOverlay, _extends$2({}, (_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.loadingOverlay));
    overlayType = "loadingOverlay";
  }
  if (overlay === null) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayWrapper, {
    overlayType,
    children: overlay
  });
}
function fastMemo(component) {
  return /* @__PURE__ */ reactExports.memo(component, fastObjectShallowCompare);
}
let cachedSupportsPreventScroll;
function doesSupportPreventScroll() {
  if (cachedSupportsPreventScroll === void 0) {
    document.createElement("div").focus({
      get preventScroll() {
        cachedSupportsPreventScroll = true;
        return false;
      }
    });
  }
  return cachedSupportsPreventScroll;
}
var GridEditModes = /* @__PURE__ */ function(GridEditModes2) {
  GridEditModes2["Cell"] = "cell";
  GridEditModes2["Row"] = "row";
  return GridEditModes2;
}(GridEditModes || {});
var GridCellModes = /* @__PURE__ */ function(GridCellModes2) {
  GridCellModes2["Edit"] = "edit";
  GridCellModes2["View"] = "view";
  return GridCellModes2;
}(GridCellModes || {});
var GridRowModes = /* @__PURE__ */ function(GridRowModes2) {
  GridRowModes2["Edit"] = "edit";
  GridRowModes2["View"] = "view";
  return GridRowModes2;
}(GridRowModes || {});
var GridLogicOperator = /* @__PURE__ */ function(GridLogicOperator2) {
  GridLogicOperator2["And"] = "and";
  GridLogicOperator2["Or"] = "or";
  return GridLogicOperator2;
}(GridLogicOperator || {});
var GridCellEditStartReasons = /* @__PURE__ */ function(GridCellEditStartReasons2) {
  GridCellEditStartReasons2["enterKeyDown"] = "enterKeyDown";
  GridCellEditStartReasons2["cellDoubleClick"] = "cellDoubleClick";
  GridCellEditStartReasons2["printableKeyDown"] = "printableKeyDown";
  GridCellEditStartReasons2["deleteKeyDown"] = "deleteKeyDown";
  return GridCellEditStartReasons2;
}(GridCellEditStartReasons || {});
var GridCellEditStopReasons = /* @__PURE__ */ function(GridCellEditStopReasons2) {
  GridCellEditStopReasons2["cellFocusOut"] = "cellFocusOut";
  GridCellEditStopReasons2["escapeKeyDown"] = "escapeKeyDown";
  GridCellEditStopReasons2["enterKeyDown"] = "enterKeyDown";
  GridCellEditStopReasons2["tabKeyDown"] = "tabKeyDown";
  GridCellEditStopReasons2["shiftTabKeyDown"] = "shiftTabKeyDown";
  return GridCellEditStopReasons2;
}(GridCellEditStopReasons || {});
var GridRowEditStartReasons = /* @__PURE__ */ function(GridRowEditStartReasons2) {
  GridRowEditStartReasons2["enterKeyDown"] = "enterKeyDown";
  GridRowEditStartReasons2["cellDoubleClick"] = "cellDoubleClick";
  GridRowEditStartReasons2["printableKeyDown"] = "printableKeyDown";
  GridRowEditStartReasons2["deleteKeyDown"] = "deleteKeyDown";
  return GridRowEditStartReasons2;
}(GridRowEditStartReasons || {});
var GridRowEditStopReasons = /* @__PURE__ */ function(GridRowEditStopReasons2) {
  GridRowEditStopReasons2["rowFocusOut"] = "rowFocusOut";
  GridRowEditStopReasons2["escapeKeyDown"] = "escapeKeyDown";
  GridRowEditStopReasons2["enterKeyDown"] = "enterKeyDown";
  GridRowEditStopReasons2["tabKeyDown"] = "tabKeyDown";
  GridRowEditStopReasons2["shiftTabKeyDown"] = "shiftTabKeyDown";
  return GridRowEditStopReasons2;
}(GridRowEditStopReasons || {});
function isLeaf(node2) {
  return node2.field !== void 0;
}
function isOverflown(element) {
  return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
}
function findParentElementFromClassName(elem, className) {
  return elem.closest(`.${className}`);
}
function escapeOperandAttributeSelector(operand) {
  return operand.replace(/["\\]/g, "\\$&");
}
function getGridColumnHeaderElement(root2, field) {
  return root2.querySelector(`[role="columnheader"][data-field="${escapeOperandAttributeSelector(field)}"]`);
}
function getGridRowElementSelector(id2) {
  return `.${gridClasses.row}[data-id="${escapeOperandAttributeSelector(String(id2))}"]`;
}
function getGridRowElement(root2, id2) {
  return root2.querySelector(getGridRowElementSelector(id2));
}
function getGridCellElement(root2, {
  id: id2,
  field
}) {
  const rowSelector = getGridRowElementSelector(id2);
  const cellSelector = `.${gridClasses.cell}[data-field="${escapeOperandAttributeSelector(field)}"]`;
  const selector = `${rowSelector} ${cellSelector}`;
  return root2.querySelector(selector);
}
function useGridApiMethod(privateApiRef, apiMethods, visibility2) {
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    isFirstRender.current = false;
    privateApiRef.current.register(visibility2, apiMethods);
  }, [privateApiRef, visibility2, apiMethods]);
  if (isFirstRender.current) {
    privateApiRef.current.register(visibility2, apiMethods);
  }
}
class MissingRowIdError extends Error {
}
function useGridParamsApi(apiRef, props) {
  const {
    getRowId
  } = props;
  const getColumnHeaderParams = reactExports.useCallback((field) => ({
    field,
    colDef: apiRef.current.getColumn(field)
  }), [apiRef]);
  const getRowParams = reactExports.useCallback((id2) => {
    const row = apiRef.current.getRow(id2);
    if (!row) {
      throw new MissingRowIdError(`No row with id #${id2} found`);
    }
    const params = {
      id: id2,
      columns: apiRef.current.getAllColumns(),
      row
    };
    return params;
  }, [apiRef]);
  const getBaseCellParams = reactExports.useCallback((id2, field) => {
    const row = apiRef.current.getRow(id2);
    const rowNode = apiRef.current.getRowNode(id2);
    if (!row || !rowNode) {
      throw new MissingRowIdError(`No row with id #${id2} found`);
    }
    const cellFocus = gridFocusCellSelector(apiRef);
    const cellTabIndex = gridTabIndexCellSelector(apiRef);
    const params = {
      id: id2,
      field,
      row,
      rowNode,
      value: row[field],
      colDef: apiRef.current.getColumn(field),
      cellMode: apiRef.current.getCellMode(id2, field),
      api: apiRef.current,
      hasFocus: cellFocus !== null && cellFocus.field === field && cellFocus.id === id2,
      tabIndex: cellTabIndex && cellTabIndex.field === field && cellTabIndex.id === id2 ? 0 : -1
    };
    return params;
  }, [apiRef]);
  const getCellParams = reactExports.useCallback((id2, field) => {
    const colDef = apiRef.current.getColumn(field);
    const value = apiRef.current.getCellValue(id2, field);
    const row = apiRef.current.getRow(id2);
    const rowNode = apiRef.current.getRowNode(id2);
    if (!row || !rowNode) {
      throw new MissingRowIdError(`No row with id #${id2} found`);
    }
    const cellFocus = gridFocusCellSelector(apiRef);
    const cellTabIndex = gridTabIndexCellSelector(apiRef);
    const params = {
      id: id2,
      field,
      row,
      rowNode,
      colDef,
      cellMode: apiRef.current.getCellMode(id2, field),
      hasFocus: cellFocus !== null && cellFocus.field === field && cellFocus.id === id2,
      tabIndex: cellTabIndex && cellTabIndex.field === field && cellTabIndex.id === id2 ? 0 : -1,
      value,
      formattedValue: value,
      isEditable: false
    };
    if (colDef && colDef.valueFormatter) {
      params.formattedValue = colDef.valueFormatter({
        id: id2,
        field: params.field,
        value: params.value,
        api: apiRef.current
      });
    }
    params.isEditable = colDef && apiRef.current.isCellEditable(params);
    return params;
  }, [apiRef]);
  const getCellValue = reactExports.useCallback((id2, field) => {
    const colDef = apiRef.current.getColumn(field);
    if (!colDef || !colDef.valueGetter) {
      const rowModel = apiRef.current.getRow(id2);
      if (!rowModel) {
        throw new MissingRowIdError(`No row with id #${id2} found`);
      }
      return rowModel[field];
    }
    return colDef.valueGetter(getBaseCellParams(id2, field));
  }, [apiRef, getBaseCellParams]);
  const getRowValue = reactExports.useCallback((row, colDef) => {
    var _getRowId;
    const id2 = GRID_ID_AUTOGENERATED in row ? row[GRID_ID_AUTOGENERATED] : (_getRowId = getRowId == null ? void 0 : getRowId(row)) != null ? _getRowId : row.id;
    const field = colDef.field;
    if (!colDef || !colDef.valueGetter) {
      return row[field];
    }
    return colDef.valueGetter(getBaseCellParams(id2, field));
  }, [getBaseCellParams, getRowId]);
  const getRowFormattedValue = reactExports.useCallback((row, colDef) => {
    var _ref;
    const value = getRowValue(row, colDef);
    if (!colDef || !colDef.valueFormatter) {
      return value;
    }
    const id2 = (_ref = getRowId ? getRowId(row) : row.id) != null ? _ref : row[GRID_ID_AUTOGENERATED];
    const field = colDef.field;
    return colDef.valueFormatter({
      id: id2,
      field,
      value,
      api: apiRef.current
    });
  }, [apiRef, getRowId, getRowValue]);
  const getColumnHeaderElement = reactExports.useCallback((field) => {
    if (!apiRef.current.rootElementRef.current) {
      return null;
    }
    return getGridColumnHeaderElement(apiRef.current.rootElementRef.current, field);
  }, [apiRef]);
  const getRowElement = reactExports.useCallback((id2) => {
    if (!apiRef.current.rootElementRef.current) {
      return null;
    }
    return getGridRowElement(apiRef.current.rootElementRef.current, id2);
  }, [apiRef]);
  const getCellElement = reactExports.useCallback((id2, field) => {
    if (!apiRef.current.rootElementRef.current) {
      return null;
    }
    return getGridCellElement(apiRef.current.rootElementRef.current, {
      id: id2,
      field
    });
  }, [apiRef]);
  const paramsApi = {
    getCellValue,
    getCellParams,
    getCellElement,
    getRowValue,
    getRowFormattedValue,
    getRowParams,
    getRowElement,
    getColumnHeaderParams,
    getColumnHeaderElement
  };
  useGridApiMethod(apiRef, paramsApi, "public");
}
const _excluded$19 = ["changeReason", "unstable_updateValueOnRender"], _excluded3$3 = ["column", "rowId", "editCellState", "align", "children", "colIndex", "height", "width", "className", "showRightBorder", "extendRowFullWidth", "row", "colSpan", "disableDragEvents", "isNotVisible", "onClick", "onDoubleClick", "onMouseDown", "onMouseUp", "onMouseOver", "onKeyDown", "onKeyUp", "onDragEnter", "onDragOver"], _excluded4 = ["changeReason", "unstable_updateValueOnRender"];
const EMPTY_CELL_PARAMS = {
  id: -1,
  field: "__unset__",
  row: {},
  rowNode: {
    id: -1,
    depth: 0,
    type: "leaf",
    parent: -1,
    groupingKey: null
  },
  colDef: {
    type: "string",
    field: "__unset__",
    computedWidth: 0
  },
  cellMode: GridCellModes.View,
  hasFocus: false,
  tabIndex: -1,
  value: null,
  formattedValue: "__unset__",
  isEditable: false,
  api: {}
};
const useUtilityClasses$O = (ownerState) => {
  const {
    align,
    showRightBorder,
    isEditable,
    isSelected,
    classes
  } = ownerState;
  const slots = {
    root: ["cell", `cell--text${capitalize$1(align)}`, isEditable && "cell--editable", isSelected && "selected", showRightBorder && "cell--withRightBorder", "withBorderColor"],
    content: ["cellContent"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridCellWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  const {
    column: column2,
    rowId,
    editCellState
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const field = column2.field;
  const cellParamsWithAPI = useGridSelector(apiRef, () => {
    try {
      const cellParams = apiRef.current.getCellParams(rowId, field);
      const result = cellParams;
      result.api = apiRef.current;
      return result;
    } catch (e2) {
      if (e2 instanceof MissingRowIdError) {
        return EMPTY_CELL_PARAMS;
      }
      throw e2;
    }
  }, objectShallowCompare);
  const isSelected = useGridSelector(apiRef, () => apiRef.current.unstable_applyPipeProcessors("isCellSelected", false, {
    id: rowId,
    field
  }));
  if (cellParamsWithAPI === EMPTY_CELL_PARAMS) {
    return null;
  }
  const {
    cellMode,
    hasFocus,
    isEditable,
    value,
    formattedValue
  } = cellParamsWithAPI;
  const managesOwnFocus = column2.type === "actions";
  const tabIndex = (cellMode === "view" || !isEditable) && !managesOwnFocus ? cellParamsWithAPI.tabIndex : -1;
  const {
    classes: rootClasses,
    getCellClassName
  } = rootProps;
  const classNames = apiRef.current.unstable_applyPipeProcessors("cellClassName", [], {
    id: rowId,
    field
  });
  if (column2.cellClassName) {
    classNames.push(typeof column2.cellClassName === "function" ? column2.cellClassName(cellParamsWithAPI) : column2.cellClassName);
  }
  if (getCellClassName) {
    classNames.push(getCellClassName(cellParamsWithAPI));
  }
  let children;
  if (editCellState == null && column2.renderCell) {
    children = column2.renderCell(cellParamsWithAPI);
    classNames.push(gridClasses["cell--withRenderer"]);
    classNames.push(rootClasses == null ? void 0 : rootClasses["cell--withRenderer"]);
  }
  if (editCellState != null && column2.renderEditCell) {
    const updatedRow = apiRef.current.getRowWithUpdatedValues(rowId, column2.field);
    const editCellStateRest = _objectWithoutPropertiesLoose$1(editCellState, _excluded$19);
    const params = _extends$2({}, cellParamsWithAPI, {
      row: updatedRow
    }, editCellStateRest);
    children = column2.renderEditCell(params);
    classNames.push(gridClasses["cell--editing"]);
    classNames.push(rootClasses == null ? void 0 : rootClasses["cell--editing"]);
  }
  const {
    slots
  } = rootProps;
  const CellComponent = slots.cell;
  const cellProps = _extends$2({}, props, {
    ref,
    field,
    formattedValue,
    hasFocus,
    isEditable,
    isSelected,
    value,
    cellMode,
    children,
    tabIndex,
    className: clsx(classNames)
  });
  return /* @__PURE__ */ reactExports.createElement(CellComponent, cellProps);
});
const MemoizedCellWrapper = fastMemo(GridCellWrapper);
const GridCellV7 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  var _rootProps$experiment4;
  const {
    column: column2,
    rowId,
    editCellState,
    align,
    colIndex,
    height: height2,
    width: width2,
    className,
    showRightBorder,
    colSpan,
    disableDragEvents,
    isNotVisible,
    onClick,
    onDoubleClick,
    onMouseDown,
    onMouseUp,
    onMouseOver,
    onKeyDown,
    onKeyUp,
    onDragEnter,
    onDragOver
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded3$3);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const field = column2.field;
  const cellParamsWithAPI = useGridSelector(apiRef, () => {
    try {
      const cellParams = apiRef.current.getCellParams(rowId, field);
      const result = cellParams;
      result.api = apiRef.current;
      return result;
    } catch (e2) {
      if (e2 instanceof MissingRowIdError) {
        return EMPTY_CELL_PARAMS;
      }
      throw e2;
    }
  }, objectShallowCompare);
  const isSelected = useGridSelector(apiRef, () => apiRef.current.unstable_applyPipeProcessors("isCellSelected", false, {
    id: rowId,
    field
  }));
  const {
    cellMode,
    hasFocus,
    isEditable,
    value,
    formattedValue
  } = cellParamsWithAPI;
  const managesOwnFocus = column2.type === "actions";
  const tabIndex = (cellMode === "view" || !isEditable) && !managesOwnFocus ? cellParamsWithAPI.tabIndex : -1;
  const {
    classes: rootClasses,
    getCellClassName
  } = rootProps;
  const classNames = apiRef.current.unstable_applyPipeProcessors("cellClassName", [], {
    id: rowId,
    field
  });
  if (column2.cellClassName) {
    classNames.push(typeof column2.cellClassName === "function" ? column2.cellClassName(cellParamsWithAPI) : column2.cellClassName);
  }
  if (getCellClassName) {
    classNames.push(getCellClassName(cellParamsWithAPI));
  }
  const valueToRender = formattedValue == null ? value : formattedValue;
  const cellRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, cellRef);
  const focusElementRef = reactExports.useRef(null);
  const ownerState = {
    align,
    showRightBorder,
    isEditable,
    classes: rootProps.classes,
    isSelected
  };
  const classes = useUtilityClasses$O(ownerState);
  const publishMouseUp = reactExports.useCallback((eventName) => (event) => {
    const params = apiRef.current.getCellParams(rowId, field || "");
    apiRef.current.publishEvent(eventName, params, event);
    if (onMouseUp) {
      onMouseUp(event);
    }
  }, [apiRef, field, onMouseUp, rowId]);
  const publishMouseDown = reactExports.useCallback((eventName) => (event) => {
    const params = apiRef.current.getCellParams(rowId, field || "");
    apiRef.current.publishEvent(eventName, params, event);
    if (onMouseDown) {
      onMouseDown(event);
    }
  }, [apiRef, field, onMouseDown, rowId]);
  const publish = reactExports.useCallback((eventName, propHandler) => (event) => {
    if (!apiRef.current.getRow(rowId)) {
      return;
    }
    const params = apiRef.current.getCellParams(rowId, field || "");
    apiRef.current.publishEvent(eventName, params, event);
    if (propHandler) {
      propHandler(event);
    }
  }, [apiRef, field, rowId]);
  const style2 = reactExports.useMemo(() => {
    if (isNotVisible) {
      return {
        padding: 0,
        opacity: 0,
        width: 0,
        border: 0
      };
    }
    const cellStyle = {
      minWidth: width2,
      maxWidth: width2,
      minHeight: height2,
      maxHeight: height2 === "auto" ? "none" : height2
      // max-height doesn't support "auto"
    };
    return cellStyle;
  }, [width2, height2, isNotVisible]);
  reactExports.useEffect(() => {
    if (!hasFocus || cellMode === GridCellModes.Edit) {
      return;
    }
    const doc = ownerDocument(apiRef.current.rootElementRef.current);
    if (cellRef.current && !cellRef.current.contains(doc.activeElement)) {
      const focusableElement = cellRef.current.querySelector('[tabindex="0"]');
      const elementToFocus = focusElementRef.current || focusableElement || cellRef.current;
      if (doesSupportPreventScroll()) {
        elementToFocus.focus({
          preventScroll: true
        });
      } else {
        const scrollPosition = apiRef.current.getScrollPosition();
        elementToFocus.focus();
        apiRef.current.scroll(scrollPosition);
      }
    }
  }, [hasFocus, cellMode, apiRef]);
  if (cellParamsWithAPI === EMPTY_CELL_PARAMS) {
    return null;
  }
  let handleFocus = other.onFocus;
  let children;
  if (editCellState == null && column2.renderCell) {
    children = column2.renderCell(cellParamsWithAPI);
    classNames.push(gridClasses["cell--withRenderer"]);
    classNames.push(rootClasses == null ? void 0 : rootClasses["cell--withRenderer"]);
  }
  if (editCellState != null && column2.renderEditCell) {
    const updatedRow = apiRef.current.getRowWithUpdatedValues(rowId, column2.field);
    const editCellStateRest = _objectWithoutPropertiesLoose$1(editCellState, _excluded4);
    const params = _extends$2({}, cellParamsWithAPI, {
      row: updatedRow
    }, editCellStateRest);
    children = column2.renderEditCell(params);
    classNames.push(gridClasses["cell--editing"]);
    classNames.push(rootClasses == null ? void 0 : rootClasses["cell--editing"]);
  }
  if (children === void 0) {
    const valueString = valueToRender == null ? void 0 : valueToRender.toString();
    children = /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: classes.content,
      title: valueString,
      role: "presentation",
      children: valueString
    });
  }
  if (/* @__PURE__ */ reactExports.isValidElement(children) && managesOwnFocus) {
    children = /* @__PURE__ */ reactExports.cloneElement(children, {
      focusElementRef
    });
  }
  const draggableEventHandlers = disableDragEvents ? null : {
    onDragEnter: publish("cellDragEnter", onDragEnter),
    onDragOver: publish("cellDragOver", onDragOver)
  };
  const ariaV7 = (_rootProps$experiment4 = rootProps.experimentalFeatures) == null ? void 0 : _rootProps$experiment4.ariaV7;
  return (
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends$2({
      ref: handleRef,
      className: clsx(className, classNames, classes.root),
      role: ariaV7 ? "gridcell" : "cell",
      "data-field": field,
      "data-colindex": colIndex,
      "aria-colindex": colIndex + 1,
      "aria-colspan": colSpan,
      style: style2,
      tabIndex,
      onClick: publish("cellClick", onClick),
      onDoubleClick: publish("cellDoubleClick", onDoubleClick),
      onMouseOver: publish("cellMouseOver", onMouseOver),
      onMouseDown: publishMouseDown("cellMouseDown"),
      onMouseUp: publishMouseUp("cellMouseUp"),
      onKeyDown: publish("cellKeyDown", onKeyDown),
      onKeyUp: publish("cellKeyUp", onKeyUp)
    }, draggableEventHandlers, other, {
      onFocus: handleFocus,
      children
    }))
  );
});
const MemoizedGridCellV7 = fastMemo(GridCellV7);
const _excluded$18 = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "hasFocus", "tabIndex"];
const useUtilityClasses$N = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["booleanCell"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridBooleanCellRaw(props) {
  const {
    value
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$18);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes = useUtilityClasses$N(ownerState);
  const Icon = reactExports.useMemo(() => value ? rootProps.slots.booleanCellTrueIcon : rootProps.slots.booleanCellFalseIcon, [rootProps.slots.booleanCellFalseIcon, rootProps.slots.booleanCellTrueIcon, value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends$2({
    fontSize: "small",
    className: classes.root,
    titleAccess: apiRef.current.getLocaleText(value ? "booleanCellTrueLabel" : "booleanCellFalseLabel"),
    "data-value": Boolean(value)
  }, other));
}
const GridBooleanCell = /* @__PURE__ */ reactExports.memo(GridBooleanCellRaw);
const renderBooleanCell = (params) => {
  if (isAutoGeneratedRow(params.rowNode)) {
    return "";
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridBooleanCell, _extends$2({}, params));
};
const _excluded$17 = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "hasFocus", "isValidating", "isProcessingProps", "error", "onValueChange"];
const useUtilityClasses$M = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["editBooleanCell"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridEditBooleanCell(props) {
  var _rootProps$slotProps;
  const {
    id: idProp,
    value,
    field,
    className,
    hasFocus,
    onValueChange
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$17);
  const apiRef = useGridApiContext();
  const inputRef = reactExports.useRef(null);
  const id2 = useId();
  const [valueState, setValueState] = reactExports.useState(value);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes = useUtilityClasses$M(ownerState);
  const handleChange = reactExports.useCallback(async (event) => {
    const newValue = event.target.checked;
    if (onValueChange) {
      await onValueChange(event, newValue);
    }
    setValueState(newValue);
    await apiRef.current.setEditCellValue({
      id: idProp,
      field,
      value: newValue
    }, event);
  }, [apiRef, field, idProp, onValueChange]);
  reactExports.useEffect(() => {
    setValueState(value);
  }, [value]);
  useEnhancedEffect$1(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("label", _extends$2({
    htmlFor: id2,
    className: clsx(classes.root, className)
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends$2({
      id: id2,
      inputRef,
      checked: Boolean(valueState),
      onChange: handleChange,
      size: "small"
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseCheckbox))
  }));
}
const renderEditBooleanCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditBooleanCell, _extends$2({}, params));
const _excluded$16 = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "inputProps", "isValidating", "isProcessingProps", "onValueChange"];
const StyledInputBase = styled$1(InputBase$1)({
  fontSize: "inherit"
});
const useUtilityClasses$L = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["editInputCell"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridEditDateCell(props) {
  const {
    id: id2,
    value: valueProp,
    field,
    colDef,
    hasFocus,
    inputProps,
    onValueChange
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$16);
  const isDateTime = colDef.type === "dateTime";
  const apiRef = useGridApiContext();
  const inputRef = reactExports.useRef();
  const valueTransformed = reactExports.useMemo(() => {
    let parsedDate;
    if (valueProp == null) {
      parsedDate = null;
    } else if (valueProp instanceof Date) {
      parsedDate = valueProp;
    } else {
      parsedDate = new Date((valueProp != null ? valueProp : "").toString());
    }
    let formattedDate;
    if (parsedDate == null || Number.isNaN(parsedDate.getTime())) {
      formattedDate = "";
    } else {
      const localDate = new Date(parsedDate.getTime() - parsedDate.getTimezoneOffset() * 60 * 1e3);
      formattedDate = localDate.toISOString().substr(0, isDateTime ? 16 : 10);
    }
    return {
      parsed: parsedDate,
      formatted: formattedDate
    };
  }, [valueProp, isDateTime]);
  const [valueState, setValueState] = reactExports.useState(valueTransformed);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes = useUtilityClasses$L(ownerState);
  const hasUpdatedEditValueOnMount = reactExports.useRef(false);
  const parseValueToDate = reactExports.useCallback((value) => {
    if (value === "") {
      return null;
    }
    const [date2, time2] = value.split("T");
    const [year, month, day] = date2.split("-");
    const parsedDate = /* @__PURE__ */ new Date();
    parsedDate.setFullYear(Number(year), Number(month) - 1, Number(day));
    parsedDate.setHours(0, 0, 0, 0);
    if (time2) {
      const [hours, minutes] = time2.split(":");
      parsedDate.setHours(Number(hours), Number(minutes), 0, 0);
    }
    return parsedDate;
  }, []);
  const handleChange = reactExports.useCallback(async (event) => {
    const newFormattedDate = event.target.value;
    const newParsedDate = parseValueToDate(newFormattedDate);
    if (onValueChange) {
      await onValueChange(event, newParsedDate);
    }
    setValueState({
      parsed: newParsedDate,
      formatted: newFormattedDate
    });
    apiRef.current.setEditCellValue({
      id: id2,
      field,
      value: newParsedDate
    }, event);
  }, [apiRef, field, id2, onValueChange, parseValueToDate]);
  reactExports.useEffect(() => {
    setValueState((state) => {
      var _valueTransformed$par, _state$parsed;
      if (valueTransformed.parsed !== state.parsed && ((_valueTransformed$par = valueTransformed.parsed) == null ? void 0 : _valueTransformed$par.getTime()) !== ((_state$parsed = state.parsed) == null ? void 0 : _state$parsed.getTime())) {
        return valueTransformed;
      }
      return state;
    });
  }, [valueTransformed]);
  useEnhancedEffect$1(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  const meta = apiRef.current.unstable_getEditCellMeta(id2, field);
  const handleInputRef = (el2) => {
    inputRef.current = el2;
    if (meta != null && meta.unstable_updateValueOnRender && !hasUpdatedEditValueOnMount.current) {
      const inputValue = inputRef.current.value;
      const parsedDate = parseValueToDate(inputValue);
      setValueState({
        parsed: parsedDate,
        formatted: inputValue
      });
      apiRef.current.setEditCellValue({
        id: id2,
        field,
        value: parsedDate
      });
      hasUpdatedEditValueOnMount.current = true;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInputBase, _extends$2({
    inputRef: handleInputRef,
    fullWidth: true,
    className: classes.root,
    type: isDateTime ? "datetime-local" : "date",
    inputProps: _extends$2({
      max: isDateTime ? "9999-12-31T23:59" : "9999-12-31"
    }, inputProps),
    value: valueState.formatted,
    onChange: handleChange
  }, other));
}
const renderEditDateCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditDateCell, _extends$2({}, params));
const _excluded$15 = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "isValidating", "debounceMs", "isProcessingProps", "onValueChange"];
const useUtilityClasses$K = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["editInputCell"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridEditInputCellRoot = styled$1(InputBase$1, {
  name: "MuiDataGrid",
  slot: "EditInputCell",
  overridesResolver: (props, styles2) => styles2.editInputCell
})(({
  theme: theme2
}) => _extends$2({}, theme2.typography.body2, {
  padding: "1px 0",
  "& input": {
    padding: "0 16px",
    height: "100%"
  }
}));
const GridEditInputCell = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  const rootProps = useGridRootProps();
  const {
    id: id2,
    value,
    field,
    colDef,
    hasFocus,
    debounceMs = 200,
    isProcessingProps,
    onValueChange
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$15);
  const apiRef = useGridApiContext();
  const inputRef = reactExports.useRef();
  const [valueState, setValueState] = reactExports.useState(value);
  const classes = useUtilityClasses$K(rootProps);
  const handleChange = reactExports.useCallback(async (event) => {
    const newValue = event.target.value;
    if (onValueChange) {
      await onValueChange(event, newValue);
    }
    const column2 = apiRef.current.getColumn(field);
    let parsedValue = newValue;
    if (column2.valueParser) {
      parsedValue = column2.valueParser(newValue, apiRef.current.getCellParams(id2, field));
    }
    setValueState(parsedValue);
    apiRef.current.setEditCellValue({
      id: id2,
      field,
      value: parsedValue,
      debounceMs,
      unstable_skipValueParser: true
    }, event);
  }, [apiRef, debounceMs, field, id2, onValueChange]);
  const meta = apiRef.current.unstable_getEditCellMeta(id2, field);
  reactExports.useEffect(() => {
    if ((meta == null ? void 0 : meta.changeReason) !== "debouncedSetEditCellValue") {
      setValueState(value);
    }
  }, [meta, value]);
  useEnhancedEffect$1(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditInputCellRoot, _extends$2({
    ref,
    inputRef,
    className: classes.root,
    ownerState: rootProps,
    fullWidth: true,
    type: colDef.type === "number" ? colDef.type : "text",
    value: valueState != null ? valueState : "",
    onChange: handleChange,
    endAdornment: isProcessingProps ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadIcon, {
      fontSize: "small",
      color: "action"
    }) : void 0
  }, other));
});
const renderEditInputCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditInputCell, _extends$2({}, params));
const isEscapeKey = (key) => key === "Escape";
const isEnterKey = (key) => key === "Enter";
const isTabKey = (key) => key === "Tab";
const isSpaceKey = (key) => key === " ";
const isArrowKeys = (key) => key.indexOf("Arrow") === 0;
const isHomeOrEndKeys = (key) => key === "Home" || key === "End";
const isPageKeys = (key) => key.indexOf("Page") === 0;
function isPrintableKey(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
const isNavigationKey = (key) => isHomeOrEndKeys(key) || isArrowKeys(key) || isPageKeys(key) || isSpaceKey(key);
const isKeyboardEvent$1 = (event) => !!event.key;
const isHideMenuKey = (key) => isTabKey(key) || isEscapeKey(key);
function isSingleSelectColDef(colDef) {
  return (colDef == null ? void 0 : colDef.type) === "singleSelect";
}
function getValueFromValueOptions(value, valueOptions, getOptionValue) {
  if (valueOptions === void 0) {
    return void 0;
  }
  const result = valueOptions.find((option) => {
    const optionValue = getOptionValue(option);
    return String(optionValue) === String(value);
  });
  return getOptionValue(result);
}
const _excluded$14 = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "hasFocus", "isValidating", "isProcessingProps", "error", "onValueChange", "initialOpen", "getOptionLabel", "getOptionValue"], _excluded2$b = ["MenuProps"];
function isKeyboardEvent(event) {
  return !!event.key;
}
function GridEditSingleSelectCell(props) {
  var _rootProps$slotProps, _baseSelectProps$nati, _rootProps$slotProps2;
  const rootProps = useGridRootProps();
  const {
    id: id2,
    value: valueProp,
    field,
    row,
    colDef,
    hasFocus,
    error,
    onValueChange,
    initialOpen = rootProps.editMode === GridEditModes.Cell,
    getOptionLabel: getOptionLabelProp,
    getOptionValue: getOptionValueProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$14);
  const apiRef = useGridApiContext();
  const ref = reactExports.useRef();
  const inputRef = reactExports.useRef();
  const [open2, setOpen] = reactExports.useState(initialOpen);
  const baseSelectProps = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseSelect) || {};
  const isSelectNative = (_baseSelectProps$nati = baseSelectProps.native) != null ? _baseSelectProps$nati : false;
  const _ref = ((_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseSelect) || {}, {
    MenuProps
  } = _ref, otherBaseSelectProps = _objectWithoutPropertiesLoose$1(_ref, _excluded2$b);
  useEnhancedEffect$1(() => {
    if (hasFocus) {
      var _inputRef$current;
      (_inputRef$current = inputRef.current) == null || _inputRef$current.focus();
    }
  }, [hasFocus]);
  if (!isSingleSelectColDef(colDef)) {
    return null;
  }
  let valueOptions;
  if (typeof (colDef == null ? void 0 : colDef.valueOptions) === "function") {
    valueOptions = colDef == null ? void 0 : colDef.valueOptions({
      id: id2,
      row,
      field
    });
  } else {
    valueOptions = colDef == null ? void 0 : colDef.valueOptions;
  }
  if (!valueOptions) {
    return null;
  }
  const getOptionValue = getOptionValueProp || colDef.getOptionValue;
  const getOptionLabel = getOptionLabelProp || colDef.getOptionLabel;
  const handleChange = async (event) => {
    if (!isSingleSelectColDef(colDef) || !valueOptions) {
      return;
    }
    setOpen(false);
    const target = event.target;
    const formattedTargetValue = getValueFromValueOptions(target.value, valueOptions, getOptionValue);
    if (onValueChange) {
      await onValueChange(event, formattedTargetValue);
    }
    await apiRef.current.setEditCellValue({
      id: id2,
      field,
      value: formattedTargetValue
    }, event);
  };
  const handleClose = (event, reason) => {
    if (rootProps.editMode === GridEditModes.Row) {
      setOpen(false);
      return;
    }
    if (reason === "backdropClick" || isEscapeKey(event.key)) {
      const params = apiRef.current.getCellParams(id2, field);
      apiRef.current.publishEvent("cellEditStop", _extends$2({}, params, {
        reason: isEscapeKey(event.key) ? GridCellEditStopReasons.escapeKeyDown : GridCellEditStopReasons.cellFocusOut
      }));
    }
  };
  const handleOpen = (event) => {
    if (isKeyboardEvent(event) && event.key === "Enter") {
      return;
    }
    setOpen(true);
  };
  if (!valueOptions || !colDef) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$2({
    ref,
    inputRef,
    value: valueProp,
    onChange: handleChange,
    open: open2,
    onOpen: handleOpen,
    MenuProps: _extends$2({
      onClose: handleClose
    }, MenuProps),
    error,
    native: isSelectNative,
    fullWidth: true
  }, other, otherBaseSelectProps, {
    children: valueOptions.map((valueOption) => {
      var _rootProps$slotProps3;
      const value = getOptionValue(valueOption);
      return /* @__PURE__ */ reactExports.createElement(rootProps.slots.baseSelectOption, _extends$2({}, ((_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseSelectOption) || {}, {
        native: isSelectNative,
        key: value,
        value
      }), getOptionLabel(valueOption));
    })
  }));
}
const renderEditSingleSelectCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridEditSingleSelectCell, _extends$2({}, params));
const _excluded$13 = ["open", "target", "onClose", "children", "position", "className", "onExited"];
const useUtilityClasses$J = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["menu"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridMenuRoot = styled$1(MuiPopper, {
  name: "MuiDataGrid",
  slot: "Menu",
  overridesResolver: (_2, styles2) => styles2.menu
})(({
  theme: theme2
}) => ({
  zIndex: theme2.zIndex.modal,
  [`& .${gridClasses.menuList}`]: {
    outline: 0
  }
}));
const transformOrigin$1 = {
  "bottom-start": "top left",
  "bottom-end": "top right"
};
function GridMenu(props) {
  var _rootProps$slotProps;
  const {
    open: open2,
    target,
    onClose,
    children,
    position: position2,
    className,
    onExited
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$13);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$J(rootProps);
  const savedFocusRef = reactExports.useRef(null);
  useEnhancedEffect$1(() => {
    if (open2) {
      savedFocusRef.current = document.activeElement instanceof HTMLElement ? document.activeElement : null;
    } else {
      var _savedFocusRef$curren, _savedFocusRef$curren2;
      (_savedFocusRef$curren = savedFocusRef.current) == null || (_savedFocusRef$curren2 = _savedFocusRef$curren.focus) == null || _savedFocusRef$curren2.call(_savedFocusRef$curren);
      savedFocusRef.current = null;
    }
  }, [open2]);
  reactExports.useEffect(() => {
    const eventName = open2 ? "menuOpen" : "menuClose";
    apiRef.current.publishEvent(eventName, {
      target
    });
  }, [apiRef, open2, target]);
  const handleExited = (popperOnExited) => (node2) => {
    if (popperOnExited) {
      popperOnExited();
    }
    if (onExited) {
      onExited(node2);
    }
  };
  const handleClickAway = (event) => {
    if (event.target && (target === event.target || target != null && target.contains(event.target))) {
      return;
    }
    onClose(event);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenuRoot, _extends$2({
    as: rootProps.slots.basePopper,
    className: clsx(className, classes.root),
    ownerState: rootProps,
    open: open2,
    anchorEl: target,
    transition: true,
    placement: position2
  }, other, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.basePopper, {
    children: ({
      TransitionProps,
      placement
    }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwayListener, {
      onClickAway: handleClickAway,
      mouseEvent: "onMouseDown",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grow$1, _extends$2({}, TransitionProps, {
        style: {
          transformOrigin: transformOrigin$1[placement]
        },
        onExited: handleExited(TransitionProps == null ? void 0 : TransitionProps.onExited),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MuiPaper, {
          children
        })
      }))
    })
  }));
}
const _excluded$12 = ["api", "colDef", "id", "hasFocus", "isEditable", "field", "value", "formattedValue", "row", "rowNode", "cellMode", "tabIndex", "position", "focusElementRef"];
const hasActions = (colDef) => typeof colDef.getActions === "function";
function GridActionsCell(props) {
  var _rootProps$slotProps;
  const {
    colDef,
    id: id2,
    hasFocus,
    tabIndex,
    position: position2 = "bottom-end",
    focusElementRef
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$12);
  const [focusedButtonIndex, setFocusedButtonIndex] = reactExports.useState(-1);
  const [open2, setOpen] = reactExports.useState(false);
  const apiRef = useGridApiContext();
  const rootRef = reactExports.useRef(null);
  const buttonRef = reactExports.useRef(null);
  const ignoreCallToFocus = reactExports.useRef(false);
  const touchRippleRefs = reactExports.useRef({});
  const theme2 = useTheme();
  const menuId = useId();
  const buttonId = useId();
  const rootProps = useGridRootProps();
  if (!hasActions(colDef)) {
    throw new Error("MUI: Missing the `getActions` property in the `GridColDef`.");
  }
  const options = colDef.getActions(apiRef.current.getRowParams(id2));
  const iconButtons = options.filter((option) => !option.props.showInMenu);
  const menuButtons = options.filter((option) => option.props.showInMenu);
  const numberOfButtons = iconButtons.length + (menuButtons.length ? 1 : 0);
  reactExports.useLayoutEffect(() => {
    if (!hasFocus) {
      Object.entries(touchRippleRefs.current).forEach(([index2, ref]) => {
        ref == null || ref.stop({}, () => {
          delete touchRippleRefs.current[index2];
        });
      });
    }
  }, [hasFocus]);
  reactExports.useEffect(() => {
    if (focusedButtonIndex < 0 || !rootRef.current) {
      return;
    }
    if (focusedButtonIndex >= rootRef.current.children.length) {
      return;
    }
    const child = rootRef.current.children[focusedButtonIndex];
    child.focus({
      preventScroll: true
    });
  }, [focusedButtonIndex]);
  reactExports.useEffect(() => {
    if (!hasFocus) {
      setFocusedButtonIndex(-1);
      ignoreCallToFocus.current = false;
    }
  }, [hasFocus]);
  reactExports.useImperativeHandle(focusElementRef, () => ({
    focus() {
      if (!ignoreCallToFocus.current) {
        setFocusedButtonIndex(0);
      }
    }
  }), []);
  reactExports.useEffect(() => {
    if (focusedButtonIndex >= numberOfButtons) {
      setFocusedButtonIndex(numberOfButtons - 1);
    }
  }, [focusedButtonIndex, numberOfButtons]);
  const showMenu = () => {
    setOpen(true);
    setFocusedButtonIndex(numberOfButtons - 1);
    ignoreCallToFocus.current = true;
  };
  const hideMenu = () => {
    setOpen(false);
  };
  const handleTouchRippleRef = (index2) => (instance) => {
    touchRippleRefs.current[index2] = instance;
  };
  const handleButtonClick = (index2, onClick) => (event) => {
    setFocusedButtonIndex(index2);
    ignoreCallToFocus.current = true;
    if (onClick) {
      onClick(event);
    }
  };
  const handleRootKeyDown = (event) => {
    if (numberOfButtons <= 1) {
      return;
    }
    let newIndex = focusedButtonIndex;
    if (event.key === "ArrowRight") {
      if (theme2.direction === "rtl") {
        newIndex -= 1;
      } else {
        newIndex += 1;
      }
    } else if (event.key === "ArrowLeft") {
      if (theme2.direction === "rtl") {
        newIndex += 1;
      } else {
        newIndex -= 1;
      }
    }
    if (newIndex < 0 || newIndex >= numberOfButtons) {
      return;
    }
    if (newIndex !== focusedButtonIndex) {
      event.preventDefault();
      event.stopPropagation();
      setFocusedButtonIndex(newIndex);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
    }
    if (["Tab", "Enter", "Escape"].includes(event.key)) {
      hideMenu();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$2({
    role: "menu",
    ref: rootRef,
    tabIndex: -1,
    className: gridClasses.actionsCell,
    onKeyDown: handleRootKeyDown
  }, other, {
    children: [iconButtons.map((button, index2) => /* @__PURE__ */ reactExports.cloneElement(button, {
      key: index2,
      touchRippleRef: handleTouchRippleRef(index2),
      onClick: handleButtonClick(index2, button.props.onClick),
      tabIndex: focusedButtonIndex === index2 ? tabIndex : -1
    })), menuButtons.length > 0 && buttonId && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$2({
      ref: buttonRef,
      id: buttonId,
      "aria-label": apiRef.current.getLocaleText("actionsCellMore"),
      "aria-haspopup": "menu",
      "aria-expanded": open2,
      "aria-controls": open2 ? menuId : void 0,
      role: "menuitem",
      size: "small",
      onClick: showMenu,
      touchRippleRef: handleTouchRippleRef(buttonId),
      tabIndex: focusedButtonIndex === iconButtons.length ? tabIndex : -1
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseIconButton, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.moreActionsIcon, {
        fontSize: "small"
      })
    })), menuButtons.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenu, {
      open: open2,
      target: buttonRef.current,
      position: position2,
      onClose: hideMenu,
      onClick: hideMenu,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuList$1, {
        id: menuId,
        className: gridClasses.menuList,
        onKeyDown: handleListKeyDown,
        "aria-labelledby": buttonId,
        variant: "menu",
        autoFocusItem: true,
        children: menuButtons.map((button, index2) => /* @__PURE__ */ reactExports.cloneElement(button, {
          key: index2
        }))
      })
    })]
  }));
}
const renderActionsCell = (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridActionsCell, _extends$2({}, params));
const _excluded$11 = ["field", "align", "width", "contentWidth"];
const useUtilityClasses$I = (ownerState) => {
  const {
    align,
    classes
  } = ownerState;
  const slots = {
    root: ["cell", "cellSkeleton", `cell--text${capitalize$1(align)}`, "withBorderColor"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridSkeletonCell(props) {
  const {
    align,
    width: width2,
    contentWidth
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$11);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes,
    align
  };
  const classes = useUtilityClasses$I(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends$2({
    className: classes.root,
    style: {
      width: width2
    }
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, {
      width: `${contentWidth}%`
    })
  }));
}
function getBorderColor(theme2) {
  if (theme2.vars) {
    return theme2.vars.palette.TableCell.border;
  }
  if (theme2.palette.mode === "light") {
    return lighten(alpha(theme2.palette.divider, 1), 0.88);
  }
  return darken(alpha(theme2.palette.divider, 1), 0.68);
}
const columnHeadersStyles = {
  [`.${gridClasses.columnSeparator}, .${gridClasses["columnSeparator--resizing"]}`]: {
    visibility: "visible",
    width: "auto"
  }
};
const columnHeaderStyles = {
  [`& .${gridClasses.iconButtonContainer}`]: {
    visibility: "visible",
    width: "auto"
  },
  [`& .${gridClasses.menuIcon}`]: {
    width: "auto",
    visibility: "visible"
  }
};
const GridRootStyles = styled$1("div", {
  name: "MuiDataGrid",
  slot: "Root",
  overridesResolver: (props, styles2) => [
    {
      [`&.${gridClasses.autoHeight}`]: styles2.autoHeight
    },
    {
      [`&.${gridClasses.aggregationColumnHeader}`]: styles2.aggregationColumnHeader
    },
    {
      [`&.${gridClasses["aggregationColumnHeader--alignLeft"]}`]: styles2["aggregationColumnHeader--alignLeft"]
    },
    {
      [`&.${gridClasses["aggregationColumnHeader--alignCenter"]}`]: styles2["aggregationColumnHeader--alignCenter"]
    },
    {
      [`&.${gridClasses["aggregationColumnHeader--alignRight"]}`]: styles2["aggregationColumnHeader--alignRight"]
    },
    {
      [`&.${gridClasses.aggregationColumnHeaderLabel}`]: styles2.aggregationColumnHeaderLabel
    },
    {
      [`&.${gridClasses["root--disableUserSelection"]} .${gridClasses.cell}`]: styles2["root--disableUserSelection"]
    },
    {
      [`& .${gridClasses.editBooleanCell}`]: styles2.editBooleanCell
    },
    {
      [`& .${gridClasses["cell--editing"]}`]: styles2["cell--editing"]
    },
    {
      [`& .${gridClasses["cell--textCenter"]}`]: styles2["cell--textCenter"]
    },
    {
      [`& .${gridClasses["cell--textLeft"]}`]: styles2["cell--textLeft"]
    },
    {
      [`& .${gridClasses["cell--textRight"]}`]: styles2["cell--textRight"]
    },
    // TODO v6: Remove
    {
      [`& .${gridClasses["cell--withRenderer"]}`]: styles2["cell--withRenderer"]
    },
    {
      [`& .${gridClasses.cell}`]: styles2.cell
    },
    {
      [`& .${gridClasses["cell--rangeTop"]}`]: styles2["cell--rangeTop"]
    },
    {
      [`& .${gridClasses["cell--rangeBottom"]}`]: styles2["cell--rangeBottom"]
    },
    {
      [`& .${gridClasses["cell--rangeLeft"]}`]: styles2["cell--rangeLeft"]
    },
    {
      [`& .${gridClasses["cell--rangeRight"]}`]: styles2["cell--rangeRight"]
    },
    {
      [`& .${gridClasses["cell--withRightBorder"]}`]: styles2["cell--withRightBorder"]
    },
    {
      [`& .${gridClasses.cellContent}`]: styles2.cellContent
    },
    {
      [`& .${gridClasses.cellCheckbox}`]: styles2.cellCheckbox
    },
    {
      [`& .${gridClasses.cellSkeleton}`]: styles2.cellSkeleton
    },
    {
      [`& .${gridClasses.checkboxInput}`]: styles2.checkboxInput
    },
    {
      [`& .${gridClasses["columnHeader--alignCenter"]}`]: styles2["columnHeader--alignCenter"]
    },
    {
      [`& .${gridClasses["columnHeader--alignLeft"]}`]: styles2["columnHeader--alignLeft"]
    },
    {
      [`& .${gridClasses["columnHeader--alignRight"]}`]: styles2["columnHeader--alignRight"]
    },
    {
      [`& .${gridClasses["columnHeader--dragging"]}`]: styles2["columnHeader--dragging"]
    },
    {
      [`& .${gridClasses["columnHeader--moving"]}`]: styles2["columnHeader--moving"]
    },
    {
      [`& .${gridClasses["columnHeader--numeric"]}`]: styles2["columnHeader--numeric"]
    },
    {
      [`& .${gridClasses["columnHeader--sortable"]}`]: styles2["columnHeader--sortable"]
    },
    {
      [`& .${gridClasses["columnHeader--sorted"]}`]: styles2["columnHeader--sorted"]
    },
    {
      [`& .${gridClasses["columnHeader--withRightBorder"]}`]: styles2["columnHeader--withRightBorder"]
    },
    {
      [`& .${gridClasses.columnHeader}`]: styles2.columnHeader
    },
    {
      [`& .${gridClasses.headerFilterRow}`]: styles2.headerFilterRow
    },
    {
      [`& .${gridClasses.columnHeaderCheckbox}`]: styles2.columnHeaderCheckbox
    },
    {
      [`& .${gridClasses.columnHeaderDraggableContainer}`]: styles2.columnHeaderDraggableContainer
    },
    {
      [`& .${gridClasses.columnHeaderTitleContainer}`]: styles2.columnHeaderTitleContainer
    },
    {
      [`& .${gridClasses["columnSeparator--resizable"]}`]: styles2["columnSeparator--resizable"]
    },
    {
      [`& .${gridClasses["columnSeparator--resizing"]}`]: styles2["columnSeparator--resizing"]
    },
    {
      [`& .${gridClasses.columnSeparator}`]: styles2.columnSeparator
    },
    {
      [`& .${gridClasses.filterIcon}`]: styles2.filterIcon
    },
    {
      [`& .${gridClasses.iconSeparator}`]: styles2.iconSeparator
    },
    {
      [`& .${gridClasses.menuIcon}`]: styles2.menuIcon
    },
    {
      [`& .${gridClasses.menuIconButton}`]: styles2.menuIconButton
    },
    {
      [`& .${gridClasses.menuOpen}`]: styles2.menuOpen
    },
    {
      [`& .${gridClasses.menuList}`]: styles2.menuList
    },
    {
      [`& .${gridClasses["row--editable"]}`]: styles2["row--editable"]
    },
    {
      [`& .${gridClasses["row--editing"]}`]: styles2["row--editing"]
    },
    {
      [`& .${gridClasses["row--dragging"]}`]: styles2["row--dragging"]
    },
    {
      [`& .${gridClasses.row}`]: styles2.row
    },
    {
      [`& .${gridClasses.rowReorderCellPlaceholder}`]: styles2.rowReorderCellPlaceholder
    },
    {
      [`& .${gridClasses.rowReorderCell}`]: styles2.rowReorderCell
    },
    {
      [`& .${gridClasses["rowReorderCell--draggable"]}`]: styles2["rowReorderCell--draggable"]
    },
    {
      [`& .${gridClasses.sortIcon}`]: styles2.sortIcon
    },
    {
      [`& .${gridClasses.withBorderColor}`]: styles2.withBorderColor
    },
    {
      [`& .${gridClasses.treeDataGroupingCell}`]: styles2.treeDataGroupingCell
    },
    {
      [`& .${gridClasses.treeDataGroupingCellToggle}`]: styles2.treeDataGroupingCellToggle
    },
    {
      [`& .${gridClasses.detailPanelToggleCell}`]: styles2.detailPanelToggleCell
    },
    {
      [`& .${gridClasses["detailPanelToggleCell--expanded"]}`]: styles2["detailPanelToggleCell--expanded"]
    },
    styles2.root
  ]
})(({
  theme: theme2
}) => {
  const borderColor2 = getBorderColor(theme2);
  const radius = theme2.shape.borderRadius;
  const gridStyle = _extends$2({
    "--unstable_DataGrid-radius": typeof radius === "number" ? `${radius}px` : radius,
    "--unstable_DataGrid-headWeight": theme2.typography.fontWeightMedium,
    "--unstable_DataGrid-overlayBackground": theme2.vars ? `rgba(${theme2.vars.palette.background.defaultChannel} / ${theme2.vars.palette.action.disabledOpacity})` : alpha(theme2.palette.background.default, theme2.palette.action.disabledOpacity),
    "--DataGrid-cellOffsetMultiplier": 2,
    flex: 1,
    boxSizing: "border-box",
    position: "relative",
    borderWidth: "1px",
    borderStyle: "solid",
    borderColor: borderColor2,
    borderRadius: "var(--unstable_DataGrid-radius)",
    color: (theme2.vars || theme2).palette.text.primary
  }, theme2.typography.body2, {
    outline: "none",
    height: "100%",
    display: "flex",
    minWidth: 0,
    // See https://github.com/mui/mui-x/issues/8547
    minHeight: 0,
    flexDirection: "column",
    overflowAnchor: "none",
    // Keep the same scrolling position
    [`&.${gridClasses.autoHeight}`]: {
      height: "auto",
      [`& .${gridClasses["row--lastVisible"]} .${gridClasses.cell}`]: {
        borderBottomColor: "transparent"
      }
    },
    [`& .${gridClasses["virtualScrollerContent--overflowed"]} .${gridClasses["row--lastVisible"]} .${gridClasses.cell}`]: {
      borderBottomColor: "transparent"
    },
    [`& .${gridClasses.columnHeader}, & .${gridClasses.cell}`]: {
      WebkitTapHighlightColor: "transparent",
      lineHeight: null,
      padding: "0 10px",
      boxSizing: "border-box"
    },
    [`& .${gridClasses.columnHeader}:focus-within, & .${gridClasses.cell}:focus-within`]: {
      outline: `solid ${theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / 0.5)` : alpha(theme2.palette.primary.main, 0.5)} 1px`,
      outlineWidth: 1,
      outlineOffset: -1
    },
    [`& .${gridClasses.columnHeader}:focus, & .${gridClasses.cell}:focus`]: {
      outline: `solid ${theme2.palette.primary.main} 1px`
    },
    [`& .${gridClasses.columnHeaderCheckbox}, & .${gridClasses.cellCheckbox}`]: {
      padding: 0,
      justifyContent: "center",
      alignItems: "center"
    },
    [`& .${gridClasses.columnHeader}`]: {
      position: "relative",
      display: "flex",
      alignItems: "center"
    },
    [`& .${gridClasses["columnHeader--sorted"]} .${gridClasses.iconButtonContainer}, & .${gridClasses["columnHeader--filtered"]} .${gridClasses.iconButtonContainer}`]: {
      visibility: "visible",
      width: "auto"
    },
    [`& .${gridClasses.columnHeader}:not(.${gridClasses["columnHeader--sorted"]}) .${gridClasses.sortIcon}`]: {
      opacity: 0,
      transition: theme2.transitions.create(["opacity"], {
        duration: theme2.transitions.duration.shorter
      })
    },
    [`& .${gridClasses.columnHeaderTitleContainer}`]: {
      display: "flex",
      alignItems: "center",
      minWidth: 0,
      flex: 1,
      whiteSpace: "nowrap",
      overflow: "hidden",
      // to anchor the aggregation label
      position: "relative"
    },
    [`& .${gridClasses.columnHeaderTitleContainerContent}`]: {
      overflow: "hidden",
      display: "flex",
      alignItems: "center"
    },
    [`& .${gridClasses["columnHeader--filledGroup"]} .${gridClasses.columnHeaderTitleContainer}`]: {
      borderBottomWidth: "1px",
      borderBottomStyle: "solid",
      boxSizing: "border-box"
    },
    [`& .${gridClasses["columnHeader--filledGroup"]}.${gridClasses["columnHeader--showColumnBorder"]} .${gridClasses.columnHeaderTitleContainer}`]: {
      borderBottom: `none`
    },
    [`& .${gridClasses["columnHeader--filledGroup"]}.${gridClasses["columnHeader--showColumnBorder"]}`]: {
      borderBottomWidth: "1px",
      borderBottomStyle: "solid",
      boxSizing: "border-box"
    },
    [`& .${gridClasses.headerFilterRow}`]: {
      borderTop: `1px solid ${borderColor2}`
    },
    [`& .${gridClasses.sortIcon}, & .${gridClasses.filterIcon}`]: {
      fontSize: "inherit"
    },
    [`& .${gridClasses["columnHeader--sortable"]}`]: {
      cursor: "pointer"
    },
    [`& .${gridClasses["columnHeader--alignCenter"]} .${gridClasses.columnHeaderTitleContainer}`]: {
      justifyContent: "center"
    },
    [`& .${gridClasses["columnHeader--alignRight"]} .${gridClasses.columnHeaderDraggableContainer}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.columnHeaderTitleContainer}`]: {
      flexDirection: "row-reverse"
    },
    [`& .${gridClasses["columnHeader--alignCenter"]} .${gridClasses.menuIcon}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}`]: {
      marginRight: "auto",
      marginLeft: -6
    },
    [`& .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}`]: {
      marginRight: "auto",
      marginLeft: -10
    },
    [`& .${gridClasses["columnHeader--moving"]}`]: {
      backgroundColor: (theme2.vars || theme2).palette.action.hover
    },
    [`& .${gridClasses.columnSeparator}`]: {
      visibility: "hidden",
      position: "absolute",
      zIndex: 100,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      color: borderColor2
    },
    "@media (hover: hover)": {
      [`& .${gridClasses.columnHeaders}:hover`]: columnHeadersStyles,
      [`& .${gridClasses.columnHeader}:hover`]: columnHeaderStyles,
      [`& .${gridClasses.columnHeader}:not(.${gridClasses["columnHeader--sorted"]}):hover .${gridClasses.sortIcon}`]: {
        opacity: 0.5
      }
    },
    "@media (hover: none)": {
      [`& .${gridClasses.columnHeaders}`]: columnHeadersStyles,
      [`& .${gridClasses.columnHeader}`]: columnHeaderStyles
    },
    [`& .${gridClasses["columnSeparator--sideLeft"]}`]: {
      left: -12
    },
    [`& .${gridClasses["columnSeparator--sideRight"]}`]: {
      right: -12
    },
    [`& .${gridClasses["columnSeparator--resizable"]}`]: {
      cursor: "col-resize",
      touchAction: "none",
      "&:hover": {
        color: (theme2.vars || theme2).palette.text.primary,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          color: borderColor2
        }
      },
      [`&.${gridClasses["columnSeparator--resizing"]}`]: {
        color: (theme2.vars || theme2).palette.text.primary
      },
      "& svg": {
        pointerEvents: "none"
      }
    },
    [`& .${gridClasses.iconSeparator}`]: {
      color: "inherit"
    },
    [`& .${gridClasses.menuIcon}`]: {
      width: 0,
      visibility: "hidden",
      fontSize: 20,
      marginRight: -10,
      display: "flex",
      alignItems: "center"
    },
    [`.${gridClasses.menuOpen}`]: {
      visibility: "visible",
      width: "auto"
    },
    [`& .${gridClasses.row}`]: {
      display: "flex",
      width: "fit-content",
      breakInside: "avoid",
      // Avoid the row to be broken in two different print pages.
      "&:hover, &.Mui-hovered": {
        backgroundColor: (theme2.vars || theme2).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      "&.Mui-selected": {
        backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
        "&:hover, &.Mui-hovered": {
          backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(
                ${theme2.vars.palette.action.selectedOpacity} + 
                ${theme2.vars.palette.action.hoverOpacity}
              ))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
          }
        }
      }
    },
    [`& .${gridClasses.cell}`]: {
      display: "flex",
      alignItems: "center",
      borderBottom: "1px solid",
      "&.Mui-selected": {
        backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
        "&:hover, &.Mui-hovered": {
          backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
          }
        }
      }
    },
    [`&.${gridClasses["root--disableUserSelection"]} .${gridClasses.cell}`]: {
      userSelect: "none"
    },
    [`& .${gridClasses.row}:not(.${gridClasses["row--dynamicHeight"]}) > .${gridClasses.cell}`]: {
      overflow: "hidden",
      whiteSpace: "nowrap"
    },
    [`& .${gridClasses.cellContent}`]: {
      overflow: "hidden",
      textOverflow: "ellipsis"
    },
    [`& .${gridClasses.cell}.${gridClasses["cell--editing"]}`]: {
      padding: 1,
      display: "flex",
      boxShadow: theme2.shadows[2],
      backgroundColor: (theme2.vars || theme2).palette.background.paper,
      "&:focus-within": {
        outline: `solid ${(theme2.vars || theme2).palette.primary.main} 1px`,
        outlineOffset: "-1px"
      }
    },
    [`& .${gridClasses["row--editing"]}`]: {
      boxShadow: theme2.shadows[2]
    },
    [`& .${gridClasses["row--editing"]} .${gridClasses.cell}`]: {
      boxShadow: theme2.shadows[0],
      backgroundColor: (theme2.vars || theme2).palette.background.paper
    },
    [`& .${gridClasses.editBooleanCell}`]: {
      display: "flex",
      height: "100%",
      width: "100%",
      alignItems: "center",
      justifyContent: "center"
    },
    [`& .${gridClasses.booleanCell}[data-value="true"]`]: {
      color: (theme2.vars || theme2).palette.text.secondary
    },
    [`& .${gridClasses.booleanCell}[data-value="false"]`]: {
      color: (theme2.vars || theme2).palette.text.disabled
    },
    [`& .${gridClasses.actionsCell}`]: {
      display: "inline-flex",
      alignItems: "center",
      gridGap: theme2.spacing(1)
    },
    [`& .${gridClasses.rowReorderCell}`]: {
      display: "inline-flex",
      flex: 1,
      alignItems: "center",
      justifyContent: "center",
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity
    },
    [`& .${gridClasses["rowReorderCell--draggable"]}`]: {
      cursor: "move",
      opacity: 1
    },
    [`& .${gridClasses.rowReorderCellContainer}`]: {
      padding: 0,
      alignItems: "stretch"
    },
    [`.${gridClasses.withBorderColor}`]: {
      borderColor: borderColor2
    },
    [`& .${gridClasses["cell--withRightBorder"]}`]: {
      borderRightWidth: "1px",
      borderRightStyle: "solid"
    },
    [`& .${gridClasses["columnHeader--withRightBorder"]}`]: {
      borderRightWidth: "1px",
      borderRightStyle: "solid"
    },
    [`& .${gridClasses["cell--textLeft"]}`]: {
      justifyContent: "flex-start"
    },
    [`& .${gridClasses["cell--textRight"]}`]: {
      justifyContent: "flex-end"
    },
    [`& .${gridClasses["cell--textCenter"]}`]: {
      justifyContent: "center"
    },
    [`& .${gridClasses.columnHeaderDraggableContainer}`]: {
      display: "flex",
      width: "100%",
      height: "100%"
    },
    [`& .${gridClasses.rowReorderCellPlaceholder}`]: {
      display: "none"
    },
    [`& .${gridClasses["columnHeader--dragging"]}, & .${gridClasses["row--dragging"]}`]: {
      background: (theme2.vars || theme2).palette.background.paper,
      padding: "0 12px",
      borderRadius: "var(--unstable_DataGrid-radius)",
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity
    },
    [`& .${gridClasses["row--dragging"]}`]: {
      background: (theme2.vars || theme2).palette.background.paper,
      padding: "0 12px",
      borderRadius: "var(--unstable_DataGrid-radius)",
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      [`& .${gridClasses.rowReorderCellPlaceholder}`]: {
        display: "flex"
      }
    },
    [`& .${gridClasses.treeDataGroupingCell}`]: {
      display: "flex",
      alignItems: "center",
      width: "100%"
    },
    [`& .${gridClasses.treeDataGroupingCellToggle}`]: {
      flex: "0 0 28px",
      alignSelf: "stretch",
      marginRight: theme2.spacing(2)
    },
    [`& .${gridClasses.groupingCriteriaCell}`]: {
      display: "flex",
      alignItems: "center",
      width: "100%"
    },
    [`& .${gridClasses.groupingCriteriaCellToggle}`]: {
      flex: "0 0 28px",
      alignSelf: "stretch",
      marginRight: theme2.spacing(2)
    }
  });
  return gridStyle;
});
const _excluded$10 = ["children", "className"];
const useUtilityClasses$H = (ownerState) => {
  const {
    autoHeight,
    density,
    classes
  } = ownerState;
  const slots = {
    root: ["root", autoHeight && "autoHeight", `root--density${capitalize$1(density)}`, "withBorderColor"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridRoot = /* @__PURE__ */ reactExports.forwardRef(function GridRoot2(props, ref) {
  var _rootProps$experiment;
  const rootProps = useGridRootProps();
  const {
    children,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$10);
  const apiRef = useGridPrivateApiContext();
  const densityValue = useGridSelector(apiRef, gridDensityValueSelector);
  const rootContainerRef = reactExports.useRef(null);
  const handleRef = useForkRef(rootContainerRef, ref);
  const getAriaAttributes = (_rootProps$experiment = rootProps.experimentalFeatures) != null && _rootProps$experiment.ariaV7 ? null : useGridAriaAttributes;
  const ariaAttributes = typeof getAriaAttributes === "function" ? getAriaAttributes() : null;
  const ownerState = _extends$2({}, rootProps, {
    density: densityValue
  });
  const classes = useUtilityClasses$H(ownerState);
  apiRef.current.register("public", {
    rootElementRef: rootContainerRef
  });
  const [mountedState, setMountedState] = reactExports.useState(false);
  useEnhancedEffect$1(() => {
    setMountedState(true);
  }, []);
  if (!mountedState) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridRootStyles, _extends$2({
    ref: handleRef,
    className: clsx(className, classes.root),
    ownerState
  }, ariaAttributes, other, {
    children
  }));
});
const _excluded$$ = ["className"];
const useUtilityClasses$G = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["footerContainer", "withBorderColor"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridFooterContainerRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "FooterContainer",
  overridesResolver: (props, styles2) => styles2.footerContainer
})({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  minHeight: 52,
  borderTop: "1px solid"
});
const GridFooterContainer = /* @__PURE__ */ reactExports.forwardRef(function GridFooterContainer2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$$);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$G(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridFooterContainerRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState: rootProps
  }, other));
});
const _excluded$_ = ["className"];
const useUtilityClasses$F = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["overlay"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridOverlayRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "Overlay",
  overridesResolver: (_2, styles2) => styles2.overlay
})({
  width: "100%",
  height: "100%",
  display: "flex",
  alignSelf: "center",
  alignItems: "center",
  justifyContent: "center",
  backgroundColor: "var(--unstable_DataGrid-overlayBackground)"
});
const GridOverlay = /* @__PURE__ */ reactExports.forwardRef(function GridOverlay2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$_);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$F(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlayRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState: rootProps
  }, other));
});
const _excluded$Z = ["className"];
const useUtilityClasses$E = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["iconButtonContainer"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridIconButtonContainerRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "IconButtonContainer",
  overridesResolver: (props, styles2) => styles2.iconButtonContainer
})(() => ({
  display: "flex",
  visibility: "hidden",
  width: 0
}));
const GridIconButtonContainer = /* @__PURE__ */ reactExports.forwardRef(function GridIconButtonContainer2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Z);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$E(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridIconButtonContainerRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState: rootProps
  }, other));
});
const useUtilityClasses$D = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    icon: ["sortIcon"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function getIcon(icons, direction2, className, sortingOrder) {
  let Icon;
  const iconProps = {};
  if (direction2 === "asc") {
    Icon = icons.columnSortedAscendingIcon;
  } else if (direction2 === "desc") {
    Icon = icons.columnSortedDescendingIcon;
  } else {
    Icon = icons.columnUnsortedIcon;
    iconProps.sortingOrder = sortingOrder;
  }
  return Icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends$2({
    fontSize: "small",
    className
  }, iconProps)) : null;
}
function GridColumnHeaderSortIconRaw(props) {
  var _rootProps$slotProps;
  const {
    direction: direction2,
    index: index2,
    sortingOrder
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$2({}, props, {
    classes: rootProps.classes
  });
  const classes = useUtilityClasses$D(ownerState);
  const iconElement = getIcon(rootProps.slots, direction2, classes.icon, sortingOrder);
  if (!iconElement) {
    return null;
  }
  const iconButton = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$2({
    tabIndex: -1,
    "aria-label": apiRef.current.getLocaleText("columnHeaderSortIconLabel"),
    title: apiRef.current.getLocaleText("columnHeaderSortIconLabel"),
    size: "small"
  }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseIconButton, {
    children: iconElement
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridIconButtonContainer, {
    children: [index2 != null && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge$1, {
      badgeContent: index2,
      color: "default",
      children: iconButton
    }), index2 == null && iconButton]
  });
}
const GridColumnHeaderSortIcon = /* @__PURE__ */ reactExports.memo(GridColumnHeaderSortIconRaw);
const useUtilityClasses$C = (ownerState) => {
  const {
    classes,
    open: open2
  } = ownerState;
  const slots = {
    root: ["menuIcon", open2 && "menuOpen"],
    button: ["menuIconButton"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const ColumnHeaderMenuIcon = /* @__PURE__ */ reactExports.memo((props) => {
  var _rootProps$slotProps, _rootProps$slotProps2;
  const {
    colDef,
    open: open2,
    columnMenuId,
    columnMenuButtonId,
    iconButtonRef
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$2({}, props, {
    classes: rootProps.classes
  });
  const classes = useUtilityClasses$C(ownerState);
  const handleMenuIconClick = reactExports.useCallback((event) => {
    event.preventDefault();
    event.stopPropagation();
    apiRef.current.toggleColumnMenu(colDef.field);
  }, [apiRef, colDef.field]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: classes.root,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends$2({
      title: apiRef.current.getLocaleText("columnMenuLabel"),
      enterDelay: 1e3
    }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTooltip, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$2({
        ref: iconButtonRef,
        tabIndex: -1,
        className: classes.button,
        "aria-label": apiRef.current.getLocaleText("columnMenuLabel"),
        size: "small",
        onClick: handleMenuIconClick,
        "aria-haspopup": "menu",
        "aria-expanded": open2,
        "aria-controls": open2 ? columnMenuId : void 0,
        id: columnMenuButtonId
      }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseIconButton, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuIcon, {
          fontSize: "small"
        })
      }))
    }))
  });
});
function GridColumnHeaderMenu({
  columnMenuId,
  columnMenuButtonId,
  ContentComponent,
  contentComponentProps,
  field,
  open: open2,
  target,
  onExited
}) {
  const apiRef = useGridApiContext();
  const colDef = apiRef.current.getColumn(field);
  const hideMenu = useEventCallback$1((event) => {
    if (event) {
      event.stopPropagation();
      if (target != null && target.contains(event.target)) {
        return;
      }
    }
    apiRef.current.hideColumnMenu();
  });
  if (!target || !colDef) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridMenu, {
    placement: `bottom-${colDef.align === "right" ? "start" : "end"}`,
    open: open2,
    target,
    onClose: hideMenu,
    onExited,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentComponent, _extends$2({
      colDef,
      hideMenu,
      open: open2,
      id: columnMenuId,
      labelledby: columnMenuButtonId
    }, contentComponentProps))
  });
}
const _excluded$Y = ["className"];
const useUtilityClasses$B = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["columnHeaderTitle"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridColumnHeaderTitleRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "ColumnHeaderTitle",
  overridesResolver: (props, styles2) => styles2.columnHeaderTitle
})({
  textOverflow: "ellipsis",
  overflow: "hidden",
  whiteSpace: "nowrap",
  fontWeight: "var(--unstable_DataGrid-headWeight)"
});
const ColumnHeaderInnerTitle = /* @__PURE__ */ reactExports.forwardRef(function ColumnHeaderInnerTitle2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Y);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$B(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderTitleRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState: rootProps
  }, other));
});
function GridColumnHeaderTitle(props) {
  var _rootProps$slotProps;
  const {
    label,
    description
  } = props;
  const rootProps = useGridRootProps();
  const titleRef = reactExports.useRef(null);
  const [tooltip, setTooltip] = reactExports.useState("");
  const handleMouseOver = reactExports.useCallback(() => {
    if (!description && titleRef != null && titleRef.current) {
      const isOver = isOverflown(titleRef.current);
      if (isOver) {
        setTooltip(label);
      } else {
        setTooltip("");
      }
    }
  }, [description, label]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends$2({
    title: description || tooltip
  }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTooltip, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnHeaderInnerTitle, {
      onMouseOver: handleMouseOver,
      ref: titleRef,
      children: label
    })
  }));
}
const _excluded$X = ["resizable", "resizing", "height", "side"];
var GridColumnHeaderSeparatorSides = /* @__PURE__ */ function(GridColumnHeaderSeparatorSides2) {
  GridColumnHeaderSeparatorSides2["Left"] = "left";
  GridColumnHeaderSeparatorSides2["Right"] = "right";
  return GridColumnHeaderSeparatorSides2;
}(GridColumnHeaderSeparatorSides || {});
const useUtilityClasses$A = (ownerState) => {
  const {
    resizable,
    resizing,
    classes,
    side
  } = ownerState;
  const slots = {
    root: ["columnSeparator", resizable && "columnSeparator--resizable", resizing && "columnSeparator--resizing", side && `columnSeparator--side${capitalize$1(side)}`],
    icon: ["iconSeparator"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridColumnHeaderSeparatorRaw(props) {
  const {
    height: height2,
    side = GridColumnHeaderSeparatorSides.Right
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$X);
  const rootProps = useGridRootProps();
  const ownerState = _extends$2({}, props, {
    side,
    classes: rootProps.classes
  });
  const classes = useUtilityClasses$A(ownerState);
  const stopClick = reactExports.useCallback((event) => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  return (
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", _extends$2({
      className: classes.root,
      style: {
        minHeight: height2,
        opacity: rootProps.showColumnVerticalBorder ? 0 : 1
      }
    }, other, {
      onClick: stopClick,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnResizeIcon, {
        className: classes.icon
      })
    }))
  );
}
const GridColumnHeaderSeparator = /* @__PURE__ */ reactExports.memo(GridColumnHeaderSeparatorRaw);
const _excluded$W = ["classes", "columnMenuOpen", "colIndex", "height", "isResizing", "sortDirection", "hasFocus", "tabIndex", "separatorSide", "isDraggable", "headerComponent", "description", "elementId", "width", "columnMenuIconButton", "columnMenu", "columnTitleIconButtons", "headerClassName", "label", "resizable", "draggableContainerProps", "columnHeaderSeparatorProps"];
const GridGenericColumnHeaderItem = /* @__PURE__ */ reactExports.forwardRef(function GridGenericColumnHeaderItem2(props, ref) {
  const {
    classes,
    columnMenuOpen,
    colIndex,
    height: height2,
    isResizing,
    sortDirection,
    hasFocus,
    tabIndex,
    separatorSide,
    isDraggable,
    headerComponent,
    description,
    width: width2,
    columnMenuIconButton = null,
    columnMenu = null,
    columnTitleIconButtons = null,
    headerClassName,
    label,
    resizable,
    draggableContainerProps,
    columnHeaderSeparatorProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$W);
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const headerCellRef = reactExports.useRef(null);
  const [showColumnMenuIcon, setShowColumnMenuIcon] = reactExports.useState(columnMenuOpen);
  const handleRef = useForkRef(headerCellRef, ref);
  let ariaSort = "none";
  if (sortDirection != null) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  reactExports.useEffect(() => {
    if (!showColumnMenuIcon) {
      setShowColumnMenuIcon(columnMenuOpen);
    }
  }, [showColumnMenuIcon, columnMenuOpen]);
  reactExports.useLayoutEffect(() => {
    const columnMenuState = apiRef.current.state.columnMenu;
    if (hasFocus && !columnMenuState.open) {
      const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
      const elementToFocus = focusableElement || headerCellRef.current;
      elementToFocus == null || elementToFocus.focus();
      apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
    }
  }, [apiRef, hasFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$2({
    ref: handleRef,
    className: clsx(classes.root, headerClassName),
    style: {
      height: height2,
      width: width2,
      minWidth: width2,
      maxWidth: width2
    },
    role: "columnheader",
    tabIndex,
    "aria-colindex": colIndex + 1,
    "aria-sort": ariaSort,
    "aria-label": headerComponent == null ? label : void 0
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$2({
      className: classes.draggableContainer,
      draggable: isDraggable,
      role: "presentation"
    }, draggableContainerProps, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        className: classes.titleContainer,
        role: "presentation",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: classes.titleContainerContent,
          children: headerComponent !== void 0 ? headerComponent : /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderTitle, {
            label,
            description,
            columnWidth: width2
          })
        }), columnTitleIconButtons]
      }), columnMenuIconButton]
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderSeparator, _extends$2({
      resizable: !rootProps.disableColumnResize && !!resizable,
      resizing: isResizing,
      height: height2,
      side: separatorSide
    }, columnHeaderSeparatorProps)), columnMenu]
  }));
});
const useUtilityClasses$z = (ownerState) => {
  const {
    colDef,
    classes,
    isDragging,
    sortDirection,
    showRightBorder,
    filterItemsCounter
  } = ownerState;
  const isColumnSorted = sortDirection != null;
  const isColumnFiltered = filterItemsCounter != null && filterItemsCounter > 0;
  const isColumnNumeric = colDef.type === "number";
  const slots = {
    root: ["columnHeader", colDef.headerAlign === "left" && "columnHeader--alignLeft", colDef.headerAlign === "center" && "columnHeader--alignCenter", colDef.headerAlign === "right" && "columnHeader--alignRight", colDef.sortable && "columnHeader--sortable", isDragging && "columnHeader--moving", isColumnSorted && "columnHeader--sorted", isColumnFiltered && "columnHeader--filtered", isColumnNumeric && "columnHeader--numeric", "withBorderColor", showRightBorder && "columnHeader--withRightBorder"],
    draggableContainer: ["columnHeaderDraggableContainer"],
    titleContainer: ["columnHeaderTitleContainer"],
    titleContainerContent: ["columnHeaderTitleContainerContent"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridColumnHeaderItem(props) {
  var _rootProps$slotProps, _colDef$sortingOrder, _rootProps$slotProps2, _colDef$headerName;
  const {
    colDef,
    columnMenuOpen,
    colIndex,
    headerHeight,
    isResizing,
    sortDirection,
    sortIndex,
    filterItemsCounter,
    hasFocus,
    tabIndex,
    disableReorder,
    separatorSide
  } = props;
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const headerCellRef = reactExports.useRef(null);
  const columnMenuId = useId();
  const columnMenuButtonId = useId();
  const iconButtonRef = reactExports.useRef(null);
  const [showColumnMenuIcon, setShowColumnMenuIcon] = reactExports.useState(columnMenuOpen);
  const isDraggable = reactExports.useMemo(() => !rootProps.disableColumnReorder && !disableReorder && !colDef.disableReorder, [rootProps.disableColumnReorder, disableReorder, colDef.disableReorder]);
  let headerComponent;
  if (colDef.renderHeader) {
    headerComponent = colDef.renderHeader(apiRef.current.getColumnHeaderParams(colDef.field));
  }
  const ownerState = _extends$2({}, props, {
    classes: rootProps.classes,
    showRightBorder: rootProps.showColumnVerticalBorder
  });
  const classes = useUtilityClasses$z(ownerState);
  const publish = reactExports.useCallback((eventName) => (event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    apiRef.current.publishEvent(eventName, apiRef.current.getColumnHeaderParams(colDef.field), event);
  }, [apiRef, colDef.field]);
  const mouseEventsHandlers = reactExports.useMemo(() => ({
    onClick: publish("columnHeaderClick"),
    onDoubleClick: publish("columnHeaderDoubleClick"),
    onMouseOver: publish("columnHeaderOver"),
    // TODO remove as it's not used
    onMouseOut: publish("columnHeaderOut"),
    // TODO remove as it's not used
    onMouseEnter: publish("columnHeaderEnter"),
    // TODO remove as it's not used
    onMouseLeave: publish("columnHeaderLeave"),
    // TODO remove as it's not used
    onKeyDown: publish("columnHeaderKeyDown"),
    onFocus: publish("columnHeaderFocus"),
    onBlur: publish("columnHeaderBlur")
  }), [publish]);
  const draggableEventHandlers = reactExports.useMemo(() => isDraggable ? {
    onDragStart: publish("columnHeaderDragStart"),
    onDragEnter: publish("columnHeaderDragEnter"),
    onDragOver: publish("columnHeaderDragOver"),
    onDragEnd: publish("columnHeaderDragEnd")
  } : {}, [isDraggable, publish]);
  const columnHeaderSeparatorProps = reactExports.useMemo(() => ({
    onMouseDown: publish("columnSeparatorMouseDown"),
    onDoubleClick: publish("columnSeparatorDoubleClick")
  }), [publish]);
  reactExports.useEffect(() => {
    if (!showColumnMenuIcon) {
      setShowColumnMenuIcon(columnMenuOpen);
    }
  }, [showColumnMenuIcon, columnMenuOpen]);
  const handleExited = reactExports.useCallback(() => {
    setShowColumnMenuIcon(false);
  }, []);
  const columnMenuIconButton = !rootProps.disableColumnMenu && !colDef.disableColumnMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnHeaderMenuIcon, {
    colDef,
    columnMenuId,
    columnMenuButtonId,
    open: showColumnMenuIcon,
    iconButtonRef
  });
  const columnMenu = /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderMenu, {
    columnMenuId,
    columnMenuButtonId,
    field: colDef.field,
    open: columnMenuOpen,
    target: iconButtonRef.current,
    ContentComponent: rootProps.slots.columnMenu,
    contentComponentProps: (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.columnMenu,
    onExited: handleExited
  });
  const sortingOrder = (_colDef$sortingOrder = colDef.sortingOrder) != null ? _colDef$sortingOrder : rootProps.sortingOrder;
  const columnTitleIconButtons = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [!rootProps.disableColumnFilter && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnHeaderFilterIconButton, _extends$2({
      field: colDef.field,
      counter: filterItemsCounter
    }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.columnHeaderFilterIconButton)), colDef.sortable && !colDef.hideSortIcons && /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderSortIcon, {
      direction: sortDirection,
      index: sortIndex,
      sortingOrder
    })]
  });
  reactExports.useLayoutEffect(() => {
    const columnMenuState = apiRef.current.state.columnMenu;
    if (hasFocus && !columnMenuState.open) {
      const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
      const elementToFocus = focusableElement || headerCellRef.current;
      elementToFocus == null || elementToFocus.focus();
      apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
    }
  }, [apiRef, hasFocus]);
  const headerClassName = typeof colDef.headerClassName === "function" ? colDef.headerClassName({
    field: colDef.field,
    colDef
  }) : colDef.headerClassName;
  const label = (_colDef$headerName = colDef.headerName) != null ? _colDef$headerName : colDef.field;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridGenericColumnHeaderItem, _extends$2({
    ref: headerCellRef,
    classes,
    columnMenuOpen,
    colIndex,
    height: headerHeight,
    isResizing,
    sortDirection,
    hasFocus,
    tabIndex,
    separatorSide,
    isDraggable,
    headerComponent,
    description: colDef.description,
    elementId: colDef.field,
    width: colDef.computedWidth,
    columnMenuIconButton,
    columnTitleIconButtons,
    headerClassName,
    label,
    resizable: !rootProps.disableColumnResize && !!colDef.resizable,
    "data-field": colDef.field,
    columnMenu,
    draggableContainerProps: draggableEventHandlers,
    columnHeaderSeparatorProps
  }, mouseEventsHandlers));
}
const getDefaultGridFilterModel = () => ({
  items: [],
  logicOperator: GridLogicOperator.And,
  quickFilterValues: [],
  quickFilterLogicOperator: GridLogicOperator.And
});
const CLEANUP_TIMER_LOOP_MILLIS = 1e3;
class TimerBasedCleanupTracking {
  constructor(timeout = CLEANUP_TIMER_LOOP_MILLIS) {
    this.timeouts = /* @__PURE__ */ new Map();
    this.cleanupTimeout = CLEANUP_TIMER_LOOP_MILLIS;
    this.cleanupTimeout = timeout;
  }
  register(object2, unsubscribe, unregisterToken) {
    if (!this.timeouts) {
      this.timeouts = /* @__PURE__ */ new Map();
    }
    const timeout = setTimeout(() => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
      this.timeouts.delete(unregisterToken.cleanupToken);
    }, this.cleanupTimeout);
    this.timeouts.set(unregisterToken.cleanupToken, timeout);
  }
  unregister(unregisterToken) {
    const timeout = this.timeouts.get(unregisterToken.cleanupToken);
    if (timeout) {
      this.timeouts.delete(unregisterToken.cleanupToken);
      clearTimeout(timeout);
    }
  }
  reset() {
    if (this.timeouts) {
      this.timeouts.forEach((value, key) => {
        this.unregister({
          cleanupToken: key
        });
      });
      this.timeouts = void 0;
    }
  }
}
class FinalizationRegistryBasedCleanupTracking {
  constructor() {
    this.registry = new FinalizationRegistry((unsubscribe) => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
    });
  }
  register(object2, unsubscribe, unregisterToken) {
    this.registry.register(object2, unsubscribe, unregisterToken);
  }
  unregister(unregisterToken) {
    this.registry.unregister(unregisterToken);
  }
  // eslint-disable-next-line class-methods-use-this
  reset() {
  }
}
var GridSignature = /* @__PURE__ */ function(GridSignature2) {
  GridSignature2["DataGrid"] = "DataGrid";
  GridSignature2["DataGridPro"] = "DataGridPro";
  return GridSignature2;
}(GridSignature || {});
class ObjectToBeRetainedByReact {
}
function createUseGridApiEventHandler(registryContainer2) {
  let cleanupTokensCounter = 0;
  return function useGridApiEventHandler2(apiRef, eventName, handler, options) {
    if (registryContainer2.registry === null) {
      registryContainer2.registry = typeof FinalizationRegistry !== "undefined" ? new FinalizationRegistryBasedCleanupTracking() : new TimerBasedCleanupTracking();
    }
    const [objectRetainedByReact] = reactExports.useState(new ObjectToBeRetainedByReact());
    const subscription = reactExports.useRef(null);
    const handlerRef = reactExports.useRef();
    handlerRef.current = handler;
    const cleanupTokenRef = reactExports.useRef(null);
    if (!subscription.current && handlerRef.current) {
      const enhancedHandler = (params, event, details) => {
        if (!event.defaultMuiPrevented) {
          var _handlerRef$current;
          (_handlerRef$current = handlerRef.current) == null || _handlerRef$current.call(handlerRef, params, event, details);
        }
      };
      subscription.current = apiRef.current.subscribeEvent(eventName, enhancedHandler, options);
      cleanupTokensCounter += 1;
      cleanupTokenRef.current = {
        cleanupToken: cleanupTokensCounter
      };
      registryContainer2.registry.register(
        objectRetainedByReact,
        // The callback below will be called once this reference stops being retained
        () => {
          var _subscription$current;
          (_subscription$current = subscription.current) == null || _subscription$current.call(subscription);
          subscription.current = null;
          cleanupTokenRef.current = null;
        },
        cleanupTokenRef.current
      );
    } else if (!handlerRef.current && subscription.current) {
      subscription.current();
      subscription.current = null;
      if (cleanupTokenRef.current) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
    }
    reactExports.useEffect(() => {
      if (!subscription.current && handlerRef.current) {
        const enhancedHandler = (params, event, details) => {
          if (!event.defaultMuiPrevented) {
            var _handlerRef$current2;
            (_handlerRef$current2 = handlerRef.current) == null || _handlerRef$current2.call(handlerRef, params, event, details);
          }
        };
        subscription.current = apiRef.current.subscribeEvent(eventName, enhancedHandler, options);
      }
      if (cleanupTokenRef.current && registryContainer2.registry) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
      return () => {
        var _subscription$current2;
        (_subscription$current2 = subscription.current) == null || _subscription$current2.call(subscription);
        subscription.current = null;
      };
    }, [apiRef, eventName, options]);
  };
}
const registryContainer = {
  registry: null
};
const useGridApiEventHandler = createUseGridApiEventHandler(registryContainer);
const optionsSubscriberOptions = {
  isFirst: true
};
function useGridApiOptionHandler(apiRef, eventName, handler) {
  useGridApiEventHandler(apiRef, eventName, handler, optionsSubscriberOptions);
}
function useGridLogger(privateApiRef, name) {
  const logger = reactExports.useRef(null);
  if (logger.current) {
    return logger.current;
  }
  const newLogger = privateApiRef.current.getLogger(name);
  logger.current = newLogger;
  return newLogger;
}
function isNumber(value) {
  return typeof value === "number";
}
function isFunction$1(value) {
  return typeof value === "function";
}
function isObject2(value) {
  return typeof value === "object" && value !== null;
}
function localStorageAvailable() {
  try {
    const key = "__some_random_key_you_are_not_going_to_use__";
    window.localStorage.setItem(key, key);
    window.localStorage.removeItem(key);
    return true;
  } catch (err) {
    return false;
  }
}
function escapeRegExp(value) {
  return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
const clamp = (value, min2, max2) => Math.max(min2, Math.min(max2, value));
function isDeepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    if (a2.constructor !== b2.constructor) {
      return false;
    }
    if (Array.isArray(a2)) {
      const length3 = a2.length;
      if (length3 !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < length3; i2 += 1) {
        if (!isDeepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    if (a2 instanceof Map && b2 instanceof Map) {
      if (a2.size !== b2.size) {
        return false;
      }
      const entriesA = Array.from(a2.entries());
      for (let i2 = 0; i2 < entriesA.length; i2 += 1) {
        if (!b2.has(entriesA[i2][0])) {
          return false;
        }
      }
      for (let i2 = 0; i2 < entriesA.length; i2 += 1) {
        const entryA = entriesA[i2];
        if (!isDeepEqual(entryA[1], b2.get(entryA[0]))) {
          return false;
        }
      }
      return true;
    }
    if (a2 instanceof Set && b2 instanceof Set) {
      if (a2.size !== b2.size) {
        return false;
      }
      const entries = Array.from(a2.entries());
      for (let i2 = 0; i2 < entries.length; i2 += 1) {
        if (!b2.has(entries[i2][0])) {
          return false;
        }
      }
      return true;
    }
    if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
      const length3 = a2.length;
      if (length3 !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < length3; i2 += 1) {
        if (a2[i2] !== b2[i2]) {
          return false;
        }
      }
      return true;
    }
    if (a2.constructor === RegExp) {
      return a2.source === b2.source && a2.flags === b2.flags;
    }
    if (a2.valueOf !== Object.prototype.valueOf) {
      return a2.valueOf() === b2.valueOf();
    }
    if (a2.toString !== Object.prototype.toString) {
      return a2.toString() === b2.toString();
    }
    const keys3 = Object.keys(a2);
    const length2 = keys3.length;
    if (length2 !== Object.keys(b2).length) {
      return false;
    }
    for (let i2 = 0; i2 < length2; i2 += 1) {
      if (!Object.prototype.hasOwnProperty.call(b2, keys3[i2])) {
        return false;
      }
    }
    for (let i2 = 0; i2 < length2; i2 += 1) {
      const key = keys3[i2];
      if (!isDeepEqual(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function mulberry32(a2) {
  return () => {
    let t3 = a2 += 1831565813;
    t3 = Math.imul(t3 ^ t3 >>> 15, t3 | 1);
    t3 ^= t3 + Math.imul(t3 ^ t3 >>> 7, t3 | 61);
    return ((t3 ^ t3 >>> 14) >>> 0) / 4294967296;
  };
}
function randomNumberBetween(seed, min2, max2) {
  const random = mulberry32(seed);
  return () => min2 + (max2 - min2) * random();
}
function deepClone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
const useGridNativeEventListener = (apiRef, ref, eventName, handler, options) => {
  const logger = useGridLogger(apiRef, "useNativeEventListener");
  const [added, setAdded] = reactExports.useState(false);
  const handlerRef = reactExports.useRef(handler);
  const wrapHandler = reactExports.useCallback((event) => {
    return handlerRef.current && handlerRef.current(event);
  }, []);
  reactExports.useEffect(() => {
    handlerRef.current = handler;
  }, [handler]);
  reactExports.useEffect(() => {
    let targetElement;
    if (isFunction$1(ref)) {
      targetElement = ref();
    } else {
      targetElement = ref && ref.current ? ref.current : null;
    }
    if (targetElement && eventName && !added) {
      logger.debug(`Binding native ${eventName} event`);
      targetElement.addEventListener(eventName, wrapHandler, options);
      const boundElem = targetElement;
      setAdded(true);
      const unsubscribe = () => {
        logger.debug(`Clearing native ${eventName} event`);
        boundElem.removeEventListener(eventName, wrapHandler, options);
      };
      apiRef.current.subscribeEvent("unmount", unsubscribe);
    }
  }, [ref, wrapHandler, eventName, added, logger, options, apiRef]);
};
const useFirstRender = (callback) => {
  const isFirstRender = reactExports.useRef(true);
  if (isFirstRender.current) {
    isFirstRender.current = false;
    callback();
  }
};
const MAX_PAGE_SIZE = 100;
const defaultPageSize = (autoPageSize) => autoPageSize ? 0 : 100;
const getPageCount = (rowCount, pageSize2) => {
  if (pageSize2 > 0 && rowCount > 0) {
    return Math.ceil(rowCount / pageSize2);
  }
  return 0;
};
buildWarning$1(["MUI: the 'rowCount' prop is undefined while using paginationMode='server'", "For more detail, see http://mui.com/components/data-grid/pagination/#basic-implementation"], "error");
const getDefaultGridPaginationModel = (autoPageSize) => ({
  page: 0,
  pageSize: autoPageSize ? 0 : 100
});
const getValidPage = (page, pageCount = 0) => {
  if (pageCount === 0) {
    return page;
  }
  return Math.max(Math.min(page, pageCount - 1), 0);
};
const throwIfPageSizeExceedsTheLimit = (pageSize2, signatureProp) => {
  if (signatureProp === GridSignature.DataGrid && pageSize2 > MAX_PAGE_SIZE) {
    throw new Error(["MUI: `pageSize` cannot exceed 100 in the MIT version of the DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));
  }
};
const gridPaginationSelector = (state) => state.pagination;
const gridPaginationModelSelector = createSelector(gridPaginationSelector, (pagination) => pagination.paginationModel);
const gridPageSelector = createSelector(gridPaginationModelSelector, (paginationModel) => paginationModel.page);
const gridPageSizeSelector = createSelector(gridPaginationModelSelector, (paginationModel) => paginationModel.pageSize);
createSelector(gridPaginationModelSelector, gridFilteredTopLevelRowCountSelector, (paginationModel, visibleTopLevelRowCount) => getPageCount(visibleTopLevelRowCount, paginationModel.pageSize));
const gridPaginationRowRangeSelector = createSelectorMemoized(gridPaginationModelSelector, gridRowTreeSelector, gridRowMaximumTreeDepthSelector, gridExpandedSortedRowEntriesSelector, gridFilteredSortedTopLevelRowEntriesSelector, (paginationModel, rowTree, rowTreeDepth, visibleSortedRowEntries, visibleSortedTopLevelRowEntries) => {
  const visibleTopLevelRowCount = visibleSortedTopLevelRowEntries.length;
  const topLevelFirstRowIndex = Math.min(paginationModel.pageSize * paginationModel.page, visibleTopLevelRowCount - 1);
  const topLevelLastRowIndex = Math.min(topLevelFirstRowIndex + paginationModel.pageSize - 1, visibleTopLevelRowCount - 1);
  if (topLevelFirstRowIndex === -1 || topLevelLastRowIndex === -1) {
    return null;
  }
  if (rowTreeDepth < 2) {
    return {
      firstRowIndex: topLevelFirstRowIndex,
      lastRowIndex: topLevelLastRowIndex
    };
  }
  const topLevelFirstRow = visibleSortedTopLevelRowEntries[topLevelFirstRowIndex];
  const topLevelRowsInCurrentPageCount = topLevelLastRowIndex - topLevelFirstRowIndex + 1;
  const firstRowIndex = visibleSortedRowEntries.findIndex((row) => row.id === topLevelFirstRow.id);
  let lastRowIndex = firstRowIndex;
  let topLevelRowAdded = 0;
  while (lastRowIndex < visibleSortedRowEntries.length && topLevelRowAdded <= topLevelRowsInCurrentPageCount) {
    var _rowTree$row$id;
    const row = visibleSortedRowEntries[lastRowIndex];
    const depth = (_rowTree$row$id = rowTree[row.id]) == null ? void 0 : _rowTree$row$id.depth;
    if (depth === void 0) {
      lastRowIndex += 1;
    } else {
      if (topLevelRowAdded < topLevelRowsInCurrentPageCount || depth > 0) {
        lastRowIndex += 1;
      }
      if (depth === 0) {
        topLevelRowAdded += 1;
      }
    }
  }
  return {
    firstRowIndex,
    lastRowIndex: lastRowIndex - 1
  };
});
const gridPaginatedVisibleSortedGridRowEntriesSelector = createSelectorMemoized(gridExpandedSortedRowEntriesSelector, gridPaginationRowRangeSelector, (visibleSortedRowEntries, paginationRange) => {
  if (!paginationRange) {
    return [];
  }
  return visibleSortedRowEntries.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);
});
const gridPaginatedVisibleSortedGridRowIdsSelector = createSelectorMemoized(gridExpandedSortedRowIdsSelector, gridPaginationRowRangeSelector, (visibleSortedRowIds, paginationRange) => {
  if (!paginationRange) {
    return [];
  }
  return visibleSortedRowIds.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);
});
const gridPreferencePanelStateSelector = (state) => state.preferencePanel;
var GridPreferencePanelsValue = /* @__PURE__ */ function(GridPreferencePanelsValue2) {
  GridPreferencePanelsValue2["filters"] = "filters";
  GridPreferencePanelsValue2["columns"] = "columns";
  return GridPreferencePanelsValue2;
}(GridPreferencePanelsValue || {});
const gridRowsMetaSelector = (state) => state.rowsMeta;
const gridRowSelectionStateSelector = (state) => state.rowSelection;
const selectedGridRowsCountSelector = createSelector(gridRowSelectionStateSelector, (selection) => selection.length);
const selectedGridRowsSelector = createSelectorMemoized(gridRowSelectionStateSelector, gridRowsLookupSelector, (selectedRows, rowsLookup) => new Map(selectedRows.map((id2) => [id2, rowsLookup[id2]])));
const selectedIdsLookupSelector = createSelectorMemoized(gridRowSelectionStateSelector, (selection) => selection.reduce((lookup2, rowId) => {
  lookup2[rowId] = rowId;
  return lookup2;
}, {}));
const sortModelDisableMultiColumnsSortingWarning = buildWarning$1(["MUI: The `sortModel` can only contain a single item when the `disableMultipleColumnsSorting` prop is set to `true`.", "If you are using the community version of the `DataGrid`, this prop is always `true`."], "error");
const sanitizeSortModel = (model, disableMultipleColumnsSorting) => {
  if (disableMultipleColumnsSorting && model.length > 1) {
    sortModelDisableMultiColumnsSortingWarning();
    return [model[0]];
  }
  return model;
};
const mergeStateWithSortModel = (sortModel, disableMultipleColumnsSorting) => (state) => _extends$2({}, state, {
  sorting: _extends$2({}, state.sorting, {
    sortModel: sanitizeSortModel(sortModel, disableMultipleColumnsSorting)
  })
});
const isDesc = (direction2) => direction2 === "desc";
const parseSortItem = (sortItem, apiRef) => {
  const column2 = apiRef.current.getColumn(sortItem.field);
  if (!column2) {
    return null;
  }
  const comparator = isDesc(sortItem.sort) ? (...args) => -1 * column2.sortComparator(...args) : column2.sortComparator;
  const getSortCellParams = (id2) => ({
    id: id2,
    field: column2.field,
    rowNode: apiRef.current.getRowNode(id2),
    value: apiRef.current.getCellValue(id2, column2.field),
    api: apiRef.current
  });
  return {
    getSortCellParams,
    comparator
  };
};
const compareRows = (parsedSortItems, row1, row2) => {
  return parsedSortItems.reduce((res, item, index2) => {
    if (res !== 0) {
      return res;
    }
    const sortCellParams1 = row1.params[index2];
    const sortCellParams2 = row2.params[index2];
    res = item.comparator(sortCellParams1.value, sortCellParams2.value, sortCellParams1, sortCellParams2);
    return res;
  }, 0);
};
const buildAggregatedSortingApplier = (sortModel, apiRef) => {
  const comparatorList = sortModel.map((item) => parseSortItem(item, apiRef)).filter((comparator) => !!comparator);
  if (comparatorList.length === 0) {
    return null;
  }
  return (rowList) => rowList.map((node2) => ({
    node: node2,
    params: comparatorList.map((el2) => el2.getSortCellParams(node2.id))
  })).sort((a2, b2) => compareRows(comparatorList, a2, b2)).map((row) => row.node.id);
};
const getNextGridSortDirection = (sortingOrder, current) => {
  const currentIdx = sortingOrder.indexOf(current);
  if (!current || currentIdx === -1 || currentIdx + 1 === sortingOrder.length) {
    return sortingOrder[0];
  }
  return sortingOrder[currentIdx + 1];
};
const gridNillComparator = (v1, v2) => {
  if (v1 == null && v2 != null) {
    return -1;
  }
  if (v2 == null && v1 != null) {
    return 1;
  }
  if (v1 == null && v2 == null) {
    return 0;
  }
  return null;
};
const collator$2 = new Intl.Collator();
const gridStringOrNumberComparator = (value1, value2) => {
  const nillResult = gridNillComparator(value1, value2);
  if (nillResult !== null) {
    return nillResult;
  }
  if (typeof value1 === "string") {
    return collator$2.compare(value1.toString(), value2.toString());
  }
  return value1 - value2;
};
const gridNumberComparator = (value1, value2) => {
  const nillResult = gridNillComparator(value1, value2);
  if (nillResult !== null) {
    return nillResult;
  }
  return Number(value1) - Number(value2);
};
const gridDateComparator = (value1, value2) => {
  const nillResult = gridNillComparator(value1, value2);
  if (nillResult !== null) {
    return nillResult;
  }
  if (value1 > value2) {
    return 1;
  }
  if (value1 < value2) {
    return -1;
  }
  return 0;
};
const unstable_gridHeaderFilteringStateSelector = (state) => state.headerFiltering;
const unstable_gridHeaderFilteringEditFieldSelector = createSelector(unstable_gridHeaderFilteringStateSelector, (headerFilteringState) => headerFilteringState.editing);
const unstable_gridHeaderFilteringMenuSelector = createSelector(unstable_gridHeaderFilteringStateSelector, (headerFilteringState) => headerFilteringState.menuOpen);
const virtualizationStateInitializer = (state, props) => {
  const virtualization = {
    enabled: !props.disableVirtualization,
    enabledForColumns: true
  };
  return _extends$2({}, state, {
    virtualization
  });
};
function useGridVirtualization(apiRef, props) {
  const setVirtualization = (enabled) => {
    apiRef.current.setState((state) => _extends$2({}, state, {
      virtualization: _extends$2({}, state.virtualization, {
        enabled
      })
    }));
  };
  const setColumnVirtualization = (enabled) => {
    apiRef.current.setState((state) => _extends$2({}, state, {
      virtualization: _extends$2({}, state.virtualization, {
        enabledForColumns: enabled
      })
    }));
  };
  const api = {
    unstable_setVirtualization: setVirtualization,
    unstable_setColumnVirtualization: setColumnVirtualization
  };
  useGridApiMethod(apiRef, api, "public");
  reactExports.useEffect(() => {
    setVirtualization(!props.disableVirtualization);
  }, [props.disableVirtualization]);
}
const gridVirtualizationSelector = (state) => state.virtualization;
const gridVirtualizationEnabledSelector = createSelector(gridVirtualizationSelector, (state) => state.enabled);
const gridVirtualizationColumnEnabledSelector = createSelector(gridVirtualizationSelector, (state) => state.enabledForColumns);
const useUtilityClasses$y = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    icon: ["filterIcon"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridColumnHeaderFilterIconButton(props) {
  var _rootProps$slotProps, _rootProps$slotProps2;
  const {
    counter: counter2,
    field,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$2({}, props, {
    classes: rootProps.classes
  });
  const classes = useUtilityClasses$y(ownerState);
  const preferencePanel = useGridSelector(apiRef, gridPreferencePanelStateSelector);
  const labelId = useId();
  const panelId = useId();
  const toggleFilter = reactExports.useCallback((event) => {
    event.preventDefault();
    event.stopPropagation();
    const {
      open: open3,
      openedPanelValue
    } = gridPreferencePanelStateSelector(apiRef.current.state);
    if (open3 && openedPanelValue === GridPreferencePanelsValue.filters) {
      apiRef.current.hideFilterPanel();
    } else {
      apiRef.current.showFilterPanel(void 0, panelId, labelId);
    }
    if (onClick) {
      onClick(apiRef.current.getColumnHeaderParams(field), event);
    }
  }, [apiRef, field, onClick, panelId, labelId]);
  if (!counter2) {
    return null;
  }
  const open2 = preferencePanel.open && preferencePanel.labelId === labelId;
  const iconButton = /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$2({
    id: labelId,
    onClick: toggleFilter,
    color: "default",
    "aria-label": apiRef.current.getLocaleText("columnHeaderFiltersLabel"),
    size: "small",
    tabIndex: -1,
    "aria-haspopup": "menu",
    "aria-expanded": open2,
    "aria-controls": open2 ? panelId : void 0
  }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseIconButton, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnFilteredIcon, {
      className: classes.icon,
      fontSize: "small"
    })
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTooltip, _extends$2({
    title: apiRef.current.getLocaleText("columnHeaderFiltersTooltipActive")(counter2),
    enterDelay: 1e3
  }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseTooltip, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GridIconButtonContainer, {
      children: [counter2 > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge$1, {
        badgeContent: counter2,
        color: "default",
        children: iconButton
      }), counter2 === 1 && iconButton]
    })
  }));
}
const _excluded$V = ["field", "id", "value", "formattedValue", "row", "rowNode", "colDef", "isEditable", "cellMode", "hasFocus", "tabIndex", "api"];
const useUtilityClasses$x = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["checkboxInput"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridCellCheckboxForwardRef = /* @__PURE__ */ reactExports.forwardRef(function GridCellCheckboxRenderer(props, ref) {
  var _rootProps$slotProps;
  const {
    field,
    id: id2,
    value: isChecked,
    rowNode,
    hasFocus,
    tabIndex
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$V);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes = useUtilityClasses$x(ownerState);
  const checkboxElement = reactExports.useRef(null);
  const rippleRef = reactExports.useRef(null);
  const handleRef = useForkRef(checkboxElement, ref);
  const element = apiRef.current.getCellElement(id2, field);
  const handleChange = (event) => {
    const params = {
      value: event.target.checked,
      id: id2
    };
    apiRef.current.publishEvent("rowSelectionCheckboxChange", params, event);
  };
  reactExports.useLayoutEffect(() => {
    if (tabIndex === 0 && element) {
      element.tabIndex = -1;
    }
  }, [element, tabIndex]);
  reactExports.useEffect(() => {
    if (hasFocus) {
      var _checkboxElement$curr;
      const input = (_checkboxElement$curr = checkboxElement.current) == null ? void 0 : _checkboxElement$curr.querySelector("input");
      input == null || input.focus({
        preventScroll: true
      });
    } else if (rippleRef.current) {
      rippleRef.current.stop({});
    }
  }, [hasFocus]);
  const handleKeyDown2 = reactExports.useCallback((event) => {
    if (isSpaceKey(event.key)) {
      event.stopPropagation();
    }
  }, []);
  if (rowNode.type === "footer" || rowNode.type === "pinnedRow") {
    return null;
  }
  const isSelectable = apiRef.current.isRowSelectable(id2);
  const label = apiRef.current.getLocaleText(isChecked ? "checkboxSelectionUnselectRow" : "checkboxSelectionSelectRow");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends$2({
    ref: handleRef,
    tabIndex,
    checked: isChecked,
    onChange: handleChange,
    className: classes.root,
    inputProps: {
      "aria-label": label
    },
    onKeyDown: handleKeyDown2,
    disabled: !isSelectable,
    touchRippleRef: rippleRef
  }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseCheckbox, other));
});
const GridCellCheckboxRenderer2 = GridCellCheckboxForwardRef;
const _excluded$U = ["field", "colDef"];
const useUtilityClasses$w = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["checkboxInput"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridHeaderCheckbox = /* @__PURE__ */ reactExports.forwardRef(function GridHeaderCheckbox2(props, ref) {
  var _rootProps$slotProps;
  const other = _objectWithoutPropertiesLoose$1(props, _excluded$U);
  const [, forceUpdate] = reactExports.useState(false);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes = useUtilityClasses$w(ownerState);
  const tabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);
  const selection = useGridSelector(apiRef, gridRowSelectionStateSelector);
  const visibleRowIds = useGridSelector(apiRef, gridExpandedSortedRowIdsSelector);
  const paginatedVisibleRowIds = useGridSelector(apiRef, gridPaginatedVisibleSortedGridRowIdsSelector);
  const filteredSelection = reactExports.useMemo(() => {
    if (typeof rootProps.isRowSelectable !== "function") {
      return selection;
    }
    return selection.filter((id2) => {
      if (!apiRef.current.getRow(id2)) {
        return false;
      }
      return rootProps.isRowSelectable(apiRef.current.getRowParams(id2));
    });
  }, [apiRef, rootProps.isRowSelectable, selection]);
  const selectionCandidates = reactExports.useMemo(() => {
    const rowIds = !rootProps.pagination || !rootProps.checkboxSelectionVisibleOnly ? visibleRowIds : paginatedVisibleRowIds;
    return rowIds.reduce((acc, id2) => {
      acc[id2] = true;
      return acc;
    }, {});
  }, [rootProps.pagination, rootProps.checkboxSelectionVisibleOnly, paginatedVisibleRowIds, visibleRowIds]);
  const currentSelectionSize = reactExports.useMemo(() => filteredSelection.filter((id2) => selectionCandidates[id2]).length, [filteredSelection, selectionCandidates]);
  const isIndeterminate = currentSelectionSize > 0 && currentSelectionSize < Object.keys(selectionCandidates).length;
  const isChecked = currentSelectionSize > 0;
  const handleChange = (event) => {
    const params = {
      value: event.target.checked
    };
    apiRef.current.publishEvent("headerSelectionCheckboxChange", params);
  };
  const tabIndex = tabIndexState !== null && tabIndexState.field === props.field ? 0 : -1;
  reactExports.useLayoutEffect(() => {
    const element = apiRef.current.getColumnHeaderElement(props.field);
    if (tabIndex === 0 && element) {
      element.tabIndex = -1;
    }
  }, [tabIndex, apiRef, props.field]);
  const handleKeyDown2 = reactExports.useCallback((event) => {
    if (event.key === " ") {
      apiRef.current.publishEvent("headerSelectionCheckboxChange", {
        value: !isChecked
      });
    }
  }, [apiRef, isChecked]);
  const handleSelectionChange = reactExports.useCallback(() => {
    forceUpdate((p2) => !p2);
  }, []);
  reactExports.useEffect(() => {
    return apiRef.current.subscribeEvent("rowSelectionChange", handleSelectionChange);
  }, [apiRef, handleSelectionChange]);
  const label = apiRef.current.getLocaleText(isChecked ? "checkboxSelectionUnselectAllRows" : "checkboxSelectionSelectAllRows");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseCheckbox, _extends$2({
    ref,
    indeterminate: isIndeterminate,
    checked: isChecked,
    onChange: handleChange,
    className: classes.root,
    inputProps: {
      "aria-label": label
    },
    tabIndex,
    onKeyDown: handleKeyDown2
  }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseCheckbox, other));
});
const GridArrowUpwardIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"
}), "ArrowUpward");
const GridArrowDownwardIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}), "ArrowDownward");
const GridKeyboardArrowRight = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), "KeyboardArrowRight");
const GridExpandMoreIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore");
const GridFilterListIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"
}), "FilterList");
const GridFilterAltIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61z"
}), "FilterAlt");
const GridSearchIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
}), "Search");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
}), "Menu");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckCircle");
const GridColumnIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"
}), "ColumnIcon");
const GridSeparatorIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 19V5h2v14z"
}), "Separator");
const GridViewHeadlineIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"
}), "ViewHeadline");
const GridTableRowsIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M21,8H3V4h18V8z M21,10H3v4h18V10z M21,16H3v4h18V16z"
}), "TableRows");
const GridViewStreamIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M4 18h17v-6H4v6zM4 5v6h17V5H4z"
}), "ViewStream");
const GridTripleDotsVerticalIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "TripleDotsVertical");
const GridCloseIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
const GridAddIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
}), "Add");
const GridRemoveIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 13H5v-2h14v2z"
}), "Remove");
const GridLoadIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"
}), "Load");
const GridDragIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "Drag");
const GridSaveAltIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"
}), "SaveAlt");
const GridCheckIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
}), "Check");
const GridMoreVertIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "MoreVert");
const GridVisibilityOffIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"
}), "VisibilityOff");
const GridViewColumnIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("g", {
  children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M14.67,5v14H9.33V5H14.67z M15.67,19H21V5h-5.33V19z M8.33,19V5H3v14H8.33z"
  })
}), "ViewColumn");
const GridClearIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Clear");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
}), "Delete");
const GridDeleteForeverIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"
}), "Delete");
const _excluded$T = ["hideMenu", "colDef", "id", "labelledby", "className", "children", "open"];
const StyledMenuList = styled$1(MenuList$1)(() => ({
  minWidth: 248
}));
const GridColumnMenuContainer = /* @__PURE__ */ reactExports.forwardRef(function GridColumnMenuContainer2(props, ref) {
  const {
    hideMenu,
    id: id2,
    labelledby,
    className,
    children,
    open: open2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$T);
  const handleListKeyDown = reactExports.useCallback((event) => {
    if (isTabKey(event.key)) {
      event.preventDefault();
    }
    if (isHideMenuKey(event.key)) {
      hideMenu(event);
    }
  }, [hideMenu]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledMenuList, _extends$2({
    id: id2,
    ref,
    className: clsx(gridClasses.menuList, className),
    "aria-labelledby": labelledby,
    onKeyDown: handleListKeyDown,
    autoFocus: open2
  }, other, {
    children
  }));
});
const _excluded$S = ["displayOrder"];
const useGridColumnMenuSlots = (props) => {
  const apiRef = useGridPrivateApiContext();
  const {
    defaultSlots: defaultSlots2,
    defaultSlotProps,
    slots = {},
    slotProps = {},
    hideMenu,
    colDef,
    addDividers = true
  } = props;
  const processedComponents = reactExports.useMemo(() => _extends$2({}, defaultSlots2, slots), [defaultSlots2, slots]);
  const processedSlotProps = reactExports.useMemo(() => {
    if (!slotProps || Object.keys(slotProps).length === 0) {
      return defaultSlotProps;
    }
    const mergedProps = _extends$2({}, slotProps);
    Object.entries(defaultSlotProps).forEach(([key, currentSlotProps]) => {
      mergedProps[key] = _extends$2({}, currentSlotProps, slotProps[key] || {});
    });
    return mergedProps;
  }, [defaultSlotProps, slotProps]);
  const defaultItems = apiRef.current.unstable_applyPipeProcessors("columnMenu", [], props.colDef);
  const userItems = reactExports.useMemo(() => {
    const defaultComponentKeys = Object.keys(defaultSlots2);
    return Object.keys(slots).filter((key) => !defaultComponentKeys.includes(key));
  }, [slots, defaultSlots2]);
  return reactExports.useMemo(() => {
    const uniqueItems = Array.from(/* @__PURE__ */ new Set([...defaultItems, ...userItems]));
    const cleansedItems = uniqueItems.filter((key) => processedComponents[key] != null);
    const sorted = cleansedItems.sort((a2, b2) => {
      const leftItemProps = processedSlotProps[a2];
      const rightItemProps = processedSlotProps[b2];
      const leftDisplayOrder = Number.isFinite(leftItemProps == null ? void 0 : leftItemProps.displayOrder) ? leftItemProps.displayOrder : 100;
      const rightDisplayOrder = Number.isFinite(rightItemProps == null ? void 0 : rightItemProps.displayOrder) ? rightItemProps.displayOrder : 100;
      return leftDisplayOrder - rightDisplayOrder;
    });
    return sorted.reduce((acc, key, index2) => {
      let itemProps = {
        colDef,
        onClick: hideMenu
      };
      const processedComponentProps = processedSlotProps[key];
      if (processedComponentProps) {
        const customProps = _objectWithoutPropertiesLoose$1(processedComponentProps, _excluded$S);
        itemProps = _extends$2({}, itemProps, customProps);
      }
      return addDividers && index2 !== sorted.length - 1 ? [...acc, [processedComponents[key], itemProps], [Divider$1, {}]] : [...acc, [processedComponents[key], itemProps]];
    }, []);
  }, [addDividers, colDef, defaultItems, hideMenu, processedComponents, processedSlotProps, userItems]);
};
function GridColumnMenuHideItem(props) {
  const {
    colDef,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
  const columnsWithMenu = visibleColumns.filter((col) => col.disableColumnMenu !== true);
  const disabled = columnsWithMenu.length === 1;
  const toggleColumn = reactExports.useCallback((event) => {
    if (disabled) {
      return;
    }
    apiRef.current.setColumnVisibility(colDef.field, false);
    onClick(event);
  }, [apiRef, colDef.field, onClick, disabled]);
  if (rootProps.disableColumnSelector) {
    return null;
  }
  if (colDef.hideable === false) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem$1, {
    onClick: toggleColumn,
    disabled,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuHideIcon, {
        fontSize: "small"
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
      children: apiRef.current.getLocaleText("columnMenuHideColumn")
    })]
  });
}
function GridColumnMenuManageItem(props) {
  const {
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const showColumns = reactExports.useCallback((event) => {
    onClick(event);
    apiRef.current.showPreferences(GridPreferencePanelsValue.columns);
  }, [apiRef, onClick]);
  if (rootProps.disableColumnSelector) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem$1, {
    onClick: showColumns,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuManageColumnsIcon, {
        fontSize: "small"
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
      children: apiRef.current.getLocaleText("columnMenuManageColumns")
    })]
  });
}
function GridColumnMenuColumnsItem(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenuHideItem, _extends$2({}, props)), /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenuManageItem, _extends$2({}, props))]
  });
}
function GridColumnMenuFilterItem(props) {
  const {
    colDef,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const showFilter = reactExports.useCallback((event) => {
    onClick(event);
    apiRef.current.showFilterPanel(colDef.field);
  }, [apiRef, colDef.field, onClick]);
  if (rootProps.disableColumnFilter || !colDef.filterable) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem$1, {
    onClick: showFilter,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuFilterIcon, {
        fontSize: "small"
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
      children: apiRef.current.getLocaleText("columnMenuFilter")
    })]
  });
}
function GridColumnMenuSortItem(props) {
  var _colDef$sortingOrder;
  const {
    colDef,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const sortModel = useGridSelector(apiRef, gridSortModelSelector);
  const rootProps = useGridRootProps();
  const sortDirection = reactExports.useMemo(() => {
    if (!colDef) {
      return null;
    }
    const sortItem = sortModel.find((item) => item.field === colDef.field);
    return sortItem == null ? void 0 : sortItem.sort;
  }, [colDef, sortModel]);
  const sortingOrder = (_colDef$sortingOrder = colDef.sortingOrder) != null ? _colDef$sortingOrder : rootProps.sortingOrder;
  const onSortMenuItemClick = reactExports.useCallback((event) => {
    onClick(event);
    const direction2 = event.currentTarget.getAttribute("data-value") || null;
    apiRef.current.sortColumn(colDef, direction2 === sortDirection ? null : direction2);
  }, [apiRef, colDef, onClick, sortDirection]);
  if (!colDef || !colDef.sortable || !sortingOrder.some((item) => !!item)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [sortingOrder.includes("asc") && sortDirection !== "asc" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem$1, {
      onClick: onSortMenuItemClick,
      "data-value": "asc",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuSortAscendingIcon, {
          fontSize: "small"
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
        children: apiRef.current.getLocaleText("columnMenuSortAsc")
      })]
    }) : null, sortingOrder.includes("desc") && sortDirection !== "desc" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem$1, {
      onClick: onSortMenuItemClick,
      "data-value": "desc",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnMenuSortDescendingIcon, {
          fontSize: "small"
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
        children: apiRef.current.getLocaleText("columnMenuSortDesc")
      })]
    }) : null, sortingOrder.includes(null) && sortDirection != null ? /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuItem$1, {
      onClick: onSortMenuItemClick,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ListItemIcon$1, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemText$1, {
        children: apiRef.current.getLocaleText("columnMenuUnsort")
      })]
    }) : null]
  });
}
const _excluded$R = ["defaultSlots", "defaultSlotProps", "slots", "slotProps"];
const GRID_COLUMN_MENU_SLOTS = {
  columnMenuSortItem: GridColumnMenuSortItem,
  columnMenuFilterItem: GridColumnMenuFilterItem,
  columnMenuColumnsItem: GridColumnMenuColumnsItem
};
const GRID_COLUMN_MENU_SLOT_PROPS = {
  columnMenuSortItem: {
    displayOrder: 10
  },
  columnMenuFilterItem: {
    displayOrder: 20
  },
  columnMenuColumnsItem: {
    displayOrder: 30
  }
};
const GridGenericColumnMenu = /* @__PURE__ */ reactExports.forwardRef(function GridGenericColumnMenu2(props, ref) {
  const {
    defaultSlots: defaultSlots2,
    defaultSlotProps,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$R);
  const orderedSlots = useGridColumnMenuSlots(_extends$2({}, other, {
    defaultSlots: defaultSlots2,
    defaultSlotProps,
    slots,
    slotProps
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnMenuContainer, _extends$2({
    ref
  }, other, {
    children: orderedSlots.map(([Component, otherProps], index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Component, _extends$2({}, otherProps), index2))
  }));
});
const GridColumnMenu = /* @__PURE__ */ reactExports.forwardRef(function GridColumnMenu2(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridGenericColumnMenu, _extends$2({}, props, {
    ref,
    defaultSlots: GRID_COLUMN_MENU_SLOTS,
    defaultSlotProps: GRID_COLUMN_MENU_SLOT_PROPS
  }));
});
const _excluded$Q = ["className"];
const useUtilityClasses$v = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["panelContent"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridPanelContentRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "PanelContent",
  overridesResolver: (props, styles2) => styles2.panelContent
})({
  display: "flex",
  flexDirection: "column",
  overflow: "auto",
  flex: "1 1",
  maxHeight: 400
});
function GridPanelContent(props) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$Q);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$v(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelContentRoot, _extends$2({
    className: clsx(className, classes.root),
    ownerState: rootProps
  }, other));
}
const _excluded$P = ["className"];
const useUtilityClasses$u = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["panelFooter"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridPanelFooterRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "PanelFooter",
  overridesResolver: (props, styles2) => styles2.panelFooter
})(({
  theme: theme2
}) => ({
  padding: theme2.spacing(0.5),
  display: "flex",
  justifyContent: "space-between"
}));
function GridPanelFooter(props) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$P);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$u(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelFooterRoot, _extends$2({
    className: clsx(className, classes.root),
    ownerState: rootProps
  }, other));
}
const _excluded$O = ["className"];
const useUtilityClasses$t = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["panelHeader"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridPanelHeaderRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "PanelHeader",
  overridesResolver: (props, styles2) => styles2.panelHeader
})(({
  theme: theme2
}) => ({
  padding: theme2.spacing(1)
}));
function GridPanelHeader(props) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$O);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$t(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelHeaderRoot, _extends$2({
    className: clsx(className, classes.root),
    ownerState: rootProps
  }, other));
}
const _excluded$N = ["className", "slotProps"];
const useUtilityClasses$s = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["panelWrapper"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridPanelWrapperRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "PanelWrapper",
  overridesResolver: (props, styles2) => styles2.panelWrapper
})({
  display: "flex",
  flexDirection: "column",
  flex: 1,
  "&:focus": {
    outline: 0
  }
});
const isEnabled = () => true;
const GridPanelWrapper = /* @__PURE__ */ reactExports.forwardRef(function GridPanelWrapper2(props, ref) {
  const {
    className,
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$N);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$s(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, _extends$2({
    open: true,
    disableEnforceFocus: true,
    isEnabled
  }, slotProps.TrapFocus, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelWrapperRoot, _extends$2({
      ref,
      tabIndex: -1,
      className: clsx(className, classes.root),
      ownerState: rootProps
    }, other))
  }));
});
const GRID_EXPERIMENTAL_ENABLED = false;
const _excluded$M = ["sort", "searchPredicate", "autoFocusSearchField", "disableHideAllButton", "disableShowAllButton", "getTogglableColumns"];
const useUtilityClasses$r = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["columnsPanel"],
    columnsPanelRow: ["columnsPanelRow"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridColumnsPanelRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "ColumnsPanel",
  overridesResolver: (props, styles2) => styles2.columnsPanel
})({
  padding: "8px 0px 8px 8px"
});
const GridColumnsPanelRowRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "ColumnsPanelRow",
  overridesResolver: (props, styles2) => styles2.columnsPanelRow
})(({
  theme: theme2
}) => ({
  display: "flex",
  justifyContent: "space-between",
  padding: "1px 8px 1px 7px",
  [`& .${switchClasses$1.root}`]: {
    marginRight: theme2.spacing(0.5)
  }
}));
const GridIconButtonRoot = styled$1(IconButton$1)({
  justifyContent: "flex-end"
});
const collator$1 = new Intl.Collator();
const defaultSearchPredicate = (column2, searchValue) => {
  return (column2.headerName || column2.field).toLowerCase().indexOf(searchValue) > -1;
};
function GridColumnsPanel(props) {
  var _rootProps$slotProps, _rootProps$slotProps3, _rootProps$slotProps4;
  const apiRef = useGridApiContext();
  const searchInputRef = reactExports.useRef(null);
  const columns = useGridSelector(apiRef, gridColumnDefinitionsSelector);
  const columnVisibilityModel = useGridSelector(apiRef, gridColumnVisibilityModelSelector);
  const rootProps = useGridRootProps();
  const [searchValue, setSearchValue] = reactExports.useState("");
  const classes = useUtilityClasses$r(rootProps);
  const {
    sort,
    searchPredicate = defaultSearchPredicate,
    autoFocusSearchField = true,
    disableHideAllButton = false,
    disableShowAllButton = false,
    getTogglableColumns
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$M);
  const sortedColumns = reactExports.useMemo(() => {
    switch (sort) {
      case "asc":
        return [...columns].sort((a2, b2) => collator$1.compare(a2.headerName || a2.field, b2.headerName || b2.field));
      case "desc":
        return [...columns].sort((a2, b2) => -collator$1.compare(a2.headerName || a2.field, b2.headerName || b2.field));
      default:
        return columns;
    }
  }, [columns, sort]);
  const toggleColumn = (event) => {
    const {
      name: field
    } = event.target;
    apiRef.current.setColumnVisibility(field, columnVisibilityModel[field] === false);
  };
  const toggleAllColumns = reactExports.useCallback((isVisible2) => {
    const currentModel = gridColumnVisibilityModelSelector(apiRef);
    const newModel = _extends$2({}, currentModel);
    const togglableColumns = getTogglableColumns ? getTogglableColumns(columns) : null;
    columns.forEach((col) => {
      if (col.hideable && (togglableColumns == null || togglableColumns.includes(col.field))) {
        if (isVisible2) {
          delete newModel[col.field];
        } else {
          newModel[col.field] = false;
        }
      }
    });
    return apiRef.current.setColumnVisibilityModel(newModel);
  }, [apiRef, columns, getTogglableColumns]);
  const handleSearchValueChange = reactExports.useCallback((event) => {
    setSearchValue(event.target.value);
  }, []);
  const currentColumns = reactExports.useMemo(() => {
    const togglableColumns = getTogglableColumns ? getTogglableColumns(sortedColumns) : null;
    const togglableSortedColumns = togglableColumns ? sortedColumns.filter(({
      field
    }) => togglableColumns.includes(field)) : sortedColumns;
    if (!searchValue) {
      return togglableSortedColumns;
    }
    return togglableSortedColumns.filter((column2) => searchPredicate(column2, searchValue.toLowerCase()));
  }, [sortedColumns, searchValue, searchPredicate, getTogglableColumns]);
  const firstSwitchRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (autoFocusSearchField) {
      searchInputRef.current.focus();
    } else if (firstSwitchRef.current && typeof firstSwitchRef.current.focus === "function") {
      firstSwitchRef.current.focus();
    }
  }, [autoFocusSearchField]);
  let firstHideableColumnFound = false;
  const isFirstHideableColumn = (column2) => {
    if (firstHideableColumnFound === false && column2.hideable !== false) {
      firstHideableColumnFound = true;
      return true;
    }
    return false;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelWrapper, _extends$2({}, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelHeader, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends$2({
        label: apiRef.current.getLocaleText("columnsPanelTextFieldLabel"),
        placeholder: apiRef.current.getLocaleText("columnsPanelTextFieldPlaceholder"),
        inputRef: searchInputRef,
        value: searchValue,
        onChange: handleSearchValueChange,
        variant: "standard",
        fullWidth: true
      }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField))
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelContent, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnsPanelRoot, {
        className: classes.root,
        ownerState: rootProps,
        children: currentColumns.map((column2) => {
          var _rootProps$slotProps2;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridColumnsPanelRowRoot, {
            className: classes.columnsPanelRow,
            ownerState: rootProps,
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FormControlLabel$1, {
              control: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSwitch, _extends$2({
                disabled: column2.hideable === false,
                checked: columnVisibilityModel[column2.field] !== false,
                onClick: toggleColumn,
                name: column2.field,
                size: "small",
                inputRef: isFirstHideableColumn(column2) ? firstSwitchRef : void 0
              }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseSwitch)),
              label: column2.headerName || column2.field
            }), !rootProps.disableColumnReorder && GRID_EXPERIMENTAL_ENABLED && /* @__PURE__ */ jsxRuntimeExports.jsx(GridIconButtonRoot, {
              draggable: true,
              "aria-label": apiRef.current.getLocaleText("columnsPanelDragIconLabel"),
              title: apiRef.current.getLocaleText("columnsPanelDragIconLabel"),
              size: "small",
              disabled: true,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.columnReorderIcon, {})
            })]
          }, column2.field);
        })
      })
    }), disableShowAllButton && disableHideAllButton ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelFooter, {
      children: [!disableHideAllButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends$2({
        onClick: () => toggleAllColumns(false)
      }, (_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseButton, {
        disabled: disableHideAllButton,
        children: apiRef.current.getLocaleText("columnsPanelHideAllButton")
      })) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}), !disableShowAllButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends$2({
        onClick: () => toggleAllColumns(true)
      }, (_rootProps$slotProps4 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps4.baseButton, {
        disabled: disableShowAllButton,
        children: apiRef.current.getLocaleText("columnsPanelShowAllButton")
      })) : null]
    })]
  }));
}
const _excluded$L = ["children", "className", "classes"];
const gridPanelClasses = generateUtilityClasses("MuiDataGrid", ["panel", "paper"]);
const GridPanelRoot = styled$1(MuiPopper, {
  name: "MuiDataGrid",
  slot: "Panel",
  overridesResolver: (props, styles2) => styles2.panel
})(({
  theme: theme2
}) => ({
  zIndex: theme2.zIndex.modal
}));
const GridPaperRoot = styled$1(MuiPaper, {
  name: "MuiDataGrid",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})(({
  theme: theme2
}) => ({
  backgroundColor: (theme2.vars || theme2).palette.background.paper,
  minWidth: 300,
  maxHeight: 450,
  display: "flex"
}));
const GridPanel = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  const {
    children,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$L);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const classes = gridPanelClasses;
  const [isPlaced, setIsPlaced] = reactExports.useState(false);
  const handleClickAway = reactExports.useCallback(() => {
    apiRef.current.hidePreferences();
  }, [apiRef]);
  const handleKeyDown2 = reactExports.useCallback((event) => {
    if (isEscapeKey(event.key)) {
      apiRef.current.hidePreferences();
    }
  }, [apiRef]);
  const modifiers = reactExports.useMemo(() => [{
    name: "flip",
    enabled: false
  }, {
    name: "isPlaced",
    enabled: true,
    phase: "main",
    fn: () => {
      setIsPlaced(true);
    },
    effect: () => () => {
      setIsPlaced(false);
    }
  }], []);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  reactExports.useEffect(() => {
    var _apiRef$current$rootE;
    const columnHeadersElement = (_apiRef$current$rootE = apiRef.current.rootElementRef) == null || (_apiRef$current$rootE = _apiRef$current$rootE.current) == null ? void 0 : _apiRef$current$rootE.querySelector(`.${gridClasses.columnHeaders}`);
    if (columnHeadersElement) {
      setAnchorEl(columnHeadersElement);
    }
  }, [apiRef]);
  if (!anchorEl) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelRoot, _extends$2({
    ref,
    placement: "bottom-start",
    className: clsx(className, classes.panel),
    ownerState: rootProps,
    anchorEl,
    modifiers
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ClickAwayListener, {
      mouseEvent: "onMouseUp",
      onClickAway: handleClickAway,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPaperRoot, {
        className: classes.paper,
        ownerState: rootProps,
        elevation: 8,
        onKeyDown: handleKeyDown2,
        children: isPlaced && children
      })
    })
  }));
});
const GridPreferencesPanel = /* @__PURE__ */ reactExports.forwardRef(function GridPreferencesPanel2(props, ref) {
  var _preferencePanelState, _rootProps$slotProps, _rootProps$slotProps2;
  const apiRef = useGridApiContext();
  const columns = useGridSelector(apiRef, gridColumnDefinitionsSelector);
  const rootProps = useGridRootProps();
  const preferencePanelState = useGridSelector(apiRef, gridPreferencePanelStateSelector);
  const panelContent = apiRef.current.unstable_applyPipeProcessors("preferencePanel", null, (_preferencePanelState = preferencePanelState.openedPanelValue) != null ? _preferencePanelState : GridPreferencePanelsValue.filters);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.panel, _extends$2({
    ref,
    as: rootProps.slots.basePopper,
    open: columns.length > 0 && preferencePanelState.open,
    id: preferencePanelState.panelId,
    "aria-labelledby": preferencePanelState.labelId
  }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.panel, props, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.basePopper, {
    children: panelContent
  }));
});
const _excluded$K = ["item", "hasMultipleFilters", "deleteFilter", "applyFilterChanges", "multiFilterOperator", "showMultiFilterOperators", "disableMultiFilterOperator", "applyMultiFilterOperatorChanges", "focusElementRef", "logicOperators", "columnsSort", "filterColumns", "deleteIconProps", "logicOperatorInputProps", "operatorInputProps", "columnInputProps", "valueInputProps", "children"], _excluded2$a = ["InputComponentProps"];
const useUtilityClasses$q = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["filterForm"],
    deleteIcon: ["filterFormDeleteIcon"],
    logicOperatorInput: ["filterFormLogicOperatorInput"],
    columnInput: ["filterFormColumnInput"],
    operatorInput: ["filterFormOperatorInput"],
    valueInput: ["filterFormValueInput"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridFilterFormRoot = styled$1("div", {
  name: "MuiDataGrid",
  slot: "FilterForm",
  overridesResolver: (props, styles2) => styles2.filterForm
})(({
  theme: theme2
}) => ({
  display: "flex",
  padding: theme2.spacing(1)
}));
const FilterFormDeleteIcon = styled$1("div", {
  name: "MuiDataGrid",
  slot: "FilterFormDeleteIcon",
  overridesResolver: (_2, styles2) => styles2.filterFormDeleteIcon
})(({
  theme: theme2
}) => ({
  flexShrink: 0,
  justifyContent: "flex-end",
  marginRight: theme2.spacing(0.5),
  marginBottom: theme2.spacing(0.2)
}));
const FilterFormLogicOperatorInput = styled$1("div", {
  name: "MuiDataGrid",
  slot: "FilterFormLogicOperatorInput",
  overridesResolver: (_2, styles2) => styles2.filterFormLogicOperatorInput
})({
  minWidth: 55,
  marginRight: 5,
  justifyContent: "end"
});
const FilterFormColumnInput = styled$1("div", {
  name: "MuiDataGrid",
  slot: "FilterFormColumnInput",
  overridesResolver: (_2, styles2) => styles2.filterFormColumnInput
})({
  width: 150
});
const FilterFormOperatorInput = styled$1("div", {
  name: "MuiDataGrid",
  slot: "FilterFormOperatorInput",
  overridesResolver: (_2, styles2) => styles2.filterFormOperatorInput
})({
  width: 120
});
const FilterFormValueInput = styled$1("div", {
  name: "MuiDataGrid",
  slot: "FilterFormValueInput",
  overridesResolver: (_2, styles2) => styles2.filterFormValueInput
})({
  width: 190
});
const getLogicOperatorLocaleKey = (logicOperator) => {
  switch (logicOperator) {
    case GridLogicOperator.And:
      return "filterPanelOperatorAnd";
    case GridLogicOperator.Or:
      return "filterPanelOperatorOr";
    default:
      throw new Error("MUI: Invalid `logicOperator` property in the `GridFilterPanel`.");
  }
};
const getColumnLabel = (col) => col.headerName || col.field;
const collator = new Intl.Collator();
const GridFilterForm = /* @__PURE__ */ reactExports.forwardRef(function GridFilterForm2(props, ref) {
  var _rootProps$slotProps, _rootProps$slotProps2, _baseSelectProps$nati, _rootProps$slotProps3, _rootProps$slotProps4, _rootProps$slotProps5, _rootProps$slotProps6, _rootProps$slotProps7, _rootProps$slotProps8, _currentColumn$filter2;
  const {
    item,
    hasMultipleFilters,
    deleteFilter,
    applyFilterChanges,
    multiFilterOperator,
    showMultiFilterOperators,
    disableMultiFilterOperator,
    applyMultiFilterOperatorChanges,
    focusElementRef,
    logicOperators = [GridLogicOperator.And, GridLogicOperator.Or],
    columnsSort,
    filterColumns,
    deleteIconProps = {},
    logicOperatorInputProps = {},
    operatorInputProps = {},
    columnInputProps = {},
    valueInputProps = {}
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$K);
  const apiRef = useGridApiContext();
  const filterableColumns = useGridSelector(apiRef, gridFilterableColumnDefinitionsSelector);
  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);
  const columnSelectId = useId();
  const columnSelectLabelId = useId();
  const operatorSelectId = useId();
  const operatorSelectLabelId = useId();
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$q(rootProps);
  const valueRef = reactExports.useRef(null);
  const filterSelectorRef = reactExports.useRef(null);
  const hasLogicOperatorColumn = hasMultipleFilters && logicOperators.length > 0;
  const baseFormControlProps = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseFormControl) || {};
  const baseSelectProps = ((_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseSelect) || {};
  const isBaseSelectNative = (_baseSelectProps$nati = baseSelectProps.native) != null ? _baseSelectProps$nati : true;
  const baseInputLabelProps = ((_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseInputLabel) || {};
  const baseSelectOptionProps = ((_rootProps$slotProps4 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps4.baseSelectOption) || {};
  const {
    InputComponentProps
  } = valueInputProps, valueInputPropsOther = _objectWithoutPropertiesLoose$1(valueInputProps, _excluded2$a);
  const filteredColumns = reactExports.useMemo(() => {
    if (filterColumns === void 0 || typeof filterColumns !== "function") {
      return filterableColumns;
    }
    const filteredFields = filterColumns({
      field: item.field,
      columns: filterableColumns,
      currentFilters: (filterModel == null ? void 0 : filterModel.items) || []
    });
    return filterableColumns.filter((column2) => filteredFields.includes(column2.field));
  }, [filterColumns, filterModel == null ? void 0 : filterModel.items, filterableColumns, item.field]);
  const sortedFilteredColumns = reactExports.useMemo(() => {
    switch (columnsSort) {
      case "asc":
        return filteredColumns.sort((a2, b2) => collator.compare(getColumnLabel(a2), getColumnLabel(b2)));
      case "desc":
        return filteredColumns.sort((a2, b2) => -collator.compare(getColumnLabel(a2), getColumnLabel(b2)));
      default:
        return filteredColumns;
    }
  }, [filteredColumns, columnsSort]);
  const currentColumn = item.field ? apiRef.current.getColumn(item.field) : null;
  const currentOperator = reactExports.useMemo(() => {
    var _currentColumn$filter;
    if (!item.operator || !currentColumn) {
      return null;
    }
    return (_currentColumn$filter = currentColumn.filterOperators) == null ? void 0 : _currentColumn$filter.find((operator) => operator.value === item.operator);
  }, [item, currentColumn]);
  const changeColumn = reactExports.useCallback((event) => {
    const field = event.target.value;
    const column2 = apiRef.current.getColumn(field);
    if (column2.field === currentColumn.field) {
      return;
    }
    const newOperator = column2.filterOperators.find((operator) => operator.value === item.operator) || column2.filterOperators[0];
    const eraseItemValue = !newOperator.InputComponent || newOperator.InputComponent !== (currentOperator == null ? void 0 : currentOperator.InputComponent);
    applyFilterChanges(_extends$2({}, item, {
      field,
      operator: newOperator.value,
      value: eraseItemValue ? void 0 : item.value
    }));
  }, [apiRef, applyFilterChanges, item, currentColumn, currentOperator]);
  const changeOperator = reactExports.useCallback((event) => {
    const operator = event.target.value;
    const newOperator = currentColumn == null ? void 0 : currentColumn.filterOperators.find((op) => op.value === operator);
    const eraseItemValue = !(newOperator != null && newOperator.InputComponent) || (newOperator == null ? void 0 : newOperator.InputComponent) !== (currentOperator == null ? void 0 : currentOperator.InputComponent);
    applyFilterChanges(_extends$2({}, item, {
      operator,
      value: eraseItemValue ? void 0 : item.value
    }));
  }, [applyFilterChanges, item, currentColumn, currentOperator]);
  const changeLogicOperator = reactExports.useCallback((event) => {
    const logicOperator = event.target.value === GridLogicOperator.And.toString() ? GridLogicOperator.And : GridLogicOperator.Or;
    applyMultiFilterOperatorChanges(logicOperator);
  }, [applyMultiFilterOperatorChanges]);
  const handleDeleteFilter = () => {
    if (rootProps.disableMultipleColumnsFiltering) {
      if (item.value === void 0) {
        deleteFilter(item);
      } else {
        applyFilterChanges(_extends$2({}, item, {
          value: void 0
        }));
      }
    } else {
      deleteFilter(item);
    }
  };
  reactExports.useImperativeHandle(focusElementRef, () => ({
    focus: () => {
      if (currentOperator != null && currentOperator.InputComponent) {
        var _valueRef$current;
        valueRef == null || (_valueRef$current = valueRef.current) == null || _valueRef$current.focus();
      } else {
        filterSelectorRef.current.focus();
      }
    }
  }), [currentOperator]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridFilterFormRoot, _extends$2({
    ref,
    className: classes.root,
    "data-id": item.id,
    ownerState: rootProps
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(FilterFormDeleteIcon, _extends$2({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, deleteIconProps, {
      className: clsx(classes.deleteIcon, baseFormControlProps.className, deleteIconProps.className),
      ownerState: rootProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseIconButton, _extends$2({
        "aria-label": apiRef.current.getLocaleText("filterPanelDeleteIconLabel"),
        title: apiRef.current.getLocaleText("filterPanelDeleteIconLabel"),
        onClick: handleDeleteFilter,
        size: "small"
      }, (_rootProps$slotProps5 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps5.baseIconButton, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.filterPanelDeleteIcon, {
          fontSize: "small"
        })
      }))
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(FilterFormLogicOperatorInput, _extends$2({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, logicOperatorInputProps, {
      sx: _extends$2({
        display: hasLogicOperatorColumn ? "flex" : "none",
        visibility: showMultiFilterOperators ? "visible" : "hidden"
      }, baseFormControlProps.sx || {}, logicOperatorInputProps.sx || {}),
      className: clsx(classes.logicOperatorInput, baseFormControlProps.className, logicOperatorInputProps.className),
      ownerState: rootProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$2({
        inputProps: {
          "aria-label": apiRef.current.getLocaleText("filterPanelLogicOperator")
        },
        value: multiFilterOperator,
        onChange: changeLogicOperator,
        disabled: !!disableMultiFilterOperator || logicOperators.length === 1,
        native: isBaseSelectNative
      }, (_rootProps$slotProps6 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps6.baseSelect, {
        children: logicOperators.map((logicOperator) => /* @__PURE__ */ reactExports.createElement(rootProps.slots.baseSelectOption, _extends$2({}, baseSelectOptionProps, {
          native: isBaseSelectNative,
          key: logicOperator.toString(),
          value: logicOperator.toString()
        }), apiRef.current.getLocaleText(getLogicOperatorLocaleKey(logicOperator))))
      }))
    })), /* @__PURE__ */ jsxRuntimeExports.jsxs(FilterFormColumnInput, _extends$2({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, columnInputProps, {
      className: clsx(classes.columnInput, baseFormControlProps.className, columnInputProps.className),
      ownerState: rootProps,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends$2({}, baseInputLabelProps, {
        htmlFor: columnSelectId,
        id: columnSelectLabelId,
        children: apiRef.current.getLocaleText("filterPanelColumns")
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$2({
        labelId: columnSelectLabelId,
        id: columnSelectId,
        label: apiRef.current.getLocaleText("filterPanelColumns"),
        value: item.field || "",
        onChange: changeColumn,
        native: isBaseSelectNative
      }, (_rootProps$slotProps7 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps7.baseSelect, {
        children: sortedFilteredColumns.map((col) => /* @__PURE__ */ reactExports.createElement(rootProps.slots.baseSelectOption, _extends$2({}, baseSelectOptionProps, {
          native: isBaseSelectNative,
          key: col.field,
          value: col.field
        }), getColumnLabel(col)))
      }))]
    })), /* @__PURE__ */ jsxRuntimeExports.jsxs(FilterFormOperatorInput, _extends$2({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, operatorInputProps, {
      className: clsx(classes.operatorInput, baseFormControlProps.className, operatorInputProps.className),
      ownerState: rootProps,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends$2({}, baseInputLabelProps, {
        htmlFor: operatorSelectId,
        id: operatorSelectLabelId,
        children: apiRef.current.getLocaleText("filterPanelOperator")
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$2({
        labelId: operatorSelectLabelId,
        label: apiRef.current.getLocaleText("filterPanelOperator"),
        id: operatorSelectId,
        value: item.operator,
        onChange: changeOperator,
        native: isBaseSelectNative,
        inputRef: filterSelectorRef
      }, (_rootProps$slotProps8 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps8.baseSelect, {
        children: currentColumn == null || (_currentColumn$filter2 = currentColumn.filterOperators) == null ? void 0 : _currentColumn$filter2.map((operator) => /* @__PURE__ */ reactExports.createElement(rootProps.slots.baseSelectOption, _extends$2({}, baseSelectOptionProps, {
          native: isBaseSelectNative,
          key: operator.value,
          value: operator.value
        }), operator.label || apiRef.current.getLocaleText(`filterOperator${capitalize$1(operator.value)}`)))
      }))]
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(FilterFormValueInput, _extends$2({
      variant: "standard",
      as: rootProps.slots.baseFormControl
    }, baseFormControlProps, valueInputPropsOther, {
      className: clsx(classes.valueInput, baseFormControlProps.className, valueInputPropsOther.className),
      ownerState: rootProps,
      children: currentOperator != null && currentOperator.InputComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(currentOperator.InputComponent, _extends$2({
        apiRef,
        item,
        applyValue: applyFilterChanges,
        focusElementRef: valueRef
      }, currentOperator.InputComponentProps, InputComponentProps)) : null
    }))]
  }));
});
class Timeout {
  constructor() {
    this.currentId = 0;
    this.clear = () => {
      if (this.currentId !== 0) {
        clearTimeout(this.currentId);
        this.currentId = 0;
      }
    };
    this.disposeEffect = () => {
      return this.clear;
    };
  }
  static create() {
    return new Timeout();
  }
  start(delay, fn3) {
    this.clear();
    this.currentId = setTimeout(fn3, delay);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
const _excluded$J = ["item", "applyValue", "type", "apiRef", "focusElementRef", "tabIndex", "disabled", "isFilterActive", "clearButton", "InputProps"];
function GridFilterInputValue(props) {
  var _item$value, _rootProps$slotProps;
  const {
    item,
    applyValue,
    type: type2,
    apiRef,
    focusElementRef,
    tabIndex,
    disabled,
    clearButton,
    InputProps
  } = props, others = _objectWithoutPropertiesLoose$1(props, _excluded$J);
  const filterTimeout = useTimeout();
  const [filterValueState, setFilterValueState] = reactExports.useState((_item$value = item.value) != null ? _item$value : "");
  const [applying, setIsApplying] = reactExports.useState(false);
  const id2 = useId();
  const rootProps = useGridRootProps();
  const onFilterChange = reactExports.useCallback((event) => {
    const {
      value
    } = event.target;
    setFilterValueState(String(value));
    setIsApplying(true);
    filterTimeout.start(rootProps.filterDebounceMs, () => {
      const newItem = _extends$2({}, item, {
        value,
        fromInput: id2
      });
      applyValue(newItem);
      setIsApplying(false);
    });
  }, [id2, applyValue, item, rootProps.filterDebounceMs, filterTimeout]);
  reactExports.useEffect(() => {
    const itemPlusTag = item;
    if (itemPlusTag.fromInput !== id2) {
      var _item$value2;
      setFilterValueState(String((_item$value2 = item.value) != null ? _item$value2 : ""));
    }
  }, [id2, item]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends$2({
    id: id2,
    label: apiRef.current.getLocaleText("filterPanelInputLabel"),
    placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
    value: filterValueState,
    onChange: onFilterChange,
    variant: "standard",
    type: type2 || "text",
    InputProps: _extends$2({}, applying || clearButton ? {
      endAdornment: applying ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadIcon, {
        fontSize: "small",
        color: "action"
      }) : clearButton
    } : {}, {
      disabled
    }, InputProps, {
      inputProps: _extends$2({
        tabIndex
      }, InputProps == null ? void 0 : InputProps.inputProps)
    }),
    InputLabelProps: {
      shrink: true
    },
    inputRef: focusElementRef
  }, others, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));
}
const _excluded$I = ["item", "applyValue", "type", "apiRef", "focusElementRef", "InputProps", "isFilterActive", "clearButton", "tabIndex", "disabled"];
function GridFilterInputDate(props) {
  var _item$value, _rootProps$slotProps;
  const {
    item,
    applyValue,
    type: type2,
    apiRef,
    focusElementRef,
    InputProps,
    clearButton,
    tabIndex,
    disabled
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$I);
  const filterTimeout = useTimeout();
  const [filterValueState, setFilterValueState] = reactExports.useState((_item$value = item.value) != null ? _item$value : "");
  const [applying, setIsApplying] = reactExports.useState(false);
  const id2 = useId();
  const rootProps = useGridRootProps();
  const onFilterChange = reactExports.useCallback((event) => {
    const value = event.target.value;
    setFilterValueState(String(value));
    setIsApplying(true);
    filterTimeout.start(rootProps.filterDebounceMs, () => {
      applyValue(_extends$2({}, item, {
        value
      }));
      setIsApplying(false);
    });
  }, [applyValue, item, rootProps.filterDebounceMs, filterTimeout]);
  reactExports.useEffect(() => {
    var _item$value2;
    const itemValue = (_item$value2 = item.value) != null ? _item$value2 : "";
    setFilterValueState(String(itemValue));
  }, [item.value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends$2({
    fullWidth: true,
    id: id2,
    label: apiRef.current.getLocaleText("filterPanelInputLabel"),
    placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
    value: filterValueState,
    onChange: onFilterChange,
    variant: "standard",
    type: type2 || "text",
    InputLabelProps: {
      shrink: true
    },
    inputRef: focusElementRef,
    InputProps: _extends$2({}, applying || clearButton ? {
      endAdornment: applying ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.loadIcon, {
        fontSize: "small",
        color: "action"
      }) : clearButton
    } : {}, {
      disabled
    }, InputProps, {
      inputProps: _extends$2({
        max: type2 === "datetime-local" ? "9999-12-31T23:59" : "9999-12-31",
        tabIndex
      }, InputProps == null ? void 0 : InputProps.inputProps)
    })
  }, other, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));
}
const _excluded$H = ["item", "applyValue", "type", "apiRef", "focusElementRef", "getOptionLabel", "getOptionValue", "placeholder", "tabIndex", "label", "isFilterActive", "clearButton", "InputLabelProps"];
const renderSingleSelectOptions = ({
  column: {
    valueOptions,
    field
  },
  OptionComponent,
  getOptionLabel,
  getOptionValue,
  isSelectNative,
  baseSelectOptionProps
}) => {
  const iterableColumnValues = typeof valueOptions === "function" ? ["", ...valueOptions({
    field
  })] : ["", ...valueOptions || []];
  return iterableColumnValues.map((option) => {
    const value = getOptionValue(option);
    const label = getOptionLabel(option);
    return /* @__PURE__ */ reactExports.createElement(OptionComponent, _extends$2({}, baseSelectOptionProps, {
      native: isSelectNative,
      key: value,
      value
    }), label);
  });
};
const SingleSelectOperatorContainer = styled$1("div")({
  display: "flex",
  alignItems: "flex-end",
  width: "100%",
  [`& button`]: {
    margin: "auto 0px 5px 5px"
  }
});
function GridFilterInputSingleSelect(props) {
  var _item$value, _rootProps$slotProps$, _rootProps$slotProps, _resolvedColumn, _resolvedColumn2, _rootProps$slotProps2, _rootProps$slotProps3, _rootProps$slotProps4;
  const {
    item,
    applyValue,
    type: type2,
    apiRef,
    focusElementRef,
    getOptionLabel: getOptionLabelProp,
    getOptionValue: getOptionValueProp,
    placeholder,
    tabIndex,
    label: labelProp,
    clearButton
  } = props, others = _objectWithoutPropertiesLoose$1(props, _excluded$H);
  const [filterValueState, setFilterValueState] = reactExports.useState((_item$value = item.value) != null ? _item$value : "");
  const id2 = useId();
  const labelId = useId();
  const rootProps = useGridRootProps();
  const isSelectNative = (_rootProps$slotProps$ = (_rootProps$slotProps = rootProps.slotProps) == null || (_rootProps$slotProps = _rootProps$slotProps.baseSelect) == null ? void 0 : _rootProps$slotProps.native) != null ? _rootProps$slotProps$ : true;
  let resolvedColumn = null;
  if (item.field) {
    const column2 = apiRef.current.getColumn(item.field);
    if (isSingleSelectColDef(column2)) {
      resolvedColumn = column2;
    }
  }
  const getOptionValue = getOptionValueProp || ((_resolvedColumn = resolvedColumn) == null ? void 0 : _resolvedColumn.getOptionValue);
  const getOptionLabel = getOptionLabelProp || ((_resolvedColumn2 = resolvedColumn) == null ? void 0 : _resolvedColumn2.getOptionLabel);
  const currentValueOptions = reactExports.useMemo(() => {
    if (!resolvedColumn) {
      return void 0;
    }
    return typeof resolvedColumn.valueOptions === "function" ? resolvedColumn.valueOptions({
      field: resolvedColumn.field
    }) : resolvedColumn.valueOptions;
  }, [resolvedColumn]);
  const onFilterChange = reactExports.useCallback((event) => {
    let value = event.target.value;
    value = getValueFromValueOptions(value, currentValueOptions, getOptionValue);
    setFilterValueState(String(value));
    applyValue(_extends$2({}, item, {
      value
    }));
  }, [currentValueOptions, getOptionValue, applyValue, item]);
  reactExports.useEffect(() => {
    var _itemValue;
    let itemValue;
    if (currentValueOptions !== void 0) {
      itemValue = getValueFromValueOptions(item.value, currentValueOptions, getOptionValue);
      if (itemValue !== item.value) {
        applyValue(_extends$2({}, item, {
          value: itemValue
        }));
        return;
      }
    } else {
      itemValue = item.value;
    }
    itemValue = (_itemValue = itemValue) != null ? _itemValue : "";
    setFilterValueState(String(itemValue));
  }, [item, currentValueOptions, applyValue, getOptionValue]);
  if (!isSingleSelectColDef(resolvedColumn)) {
    return null;
  }
  if (!isSingleSelectColDef(resolvedColumn)) {
    return null;
  }
  const label = labelProp != null ? labelProp : apiRef.current.getLocaleText("filterPanelInputLabel");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SingleSelectOperatorContainer, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(rootProps.slots.baseFormControl, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends$2({}, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseInputLabel, {
        id: labelId,
        htmlFor: id2,
        shrink: true,
        variant: "standard",
        children: label
      })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelect, _extends$2({
        id: id2,
        label,
        labelId,
        value: filterValueState,
        onChange: onFilterChange,
        variant: "standard",
        type: type2 || "text",
        inputProps: {
          tabIndex,
          ref: focusElementRef,
          placeholder: placeholder != null ? placeholder : apiRef.current.getLocaleText("filterPanelInputPlaceholder")
        },
        native: isSelectNative
      }, others, (_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseSelect, {
        children: renderSingleSelectOptions({
          column: resolvedColumn,
          OptionComponent: rootProps.slots.baseSelectOption,
          getOptionLabel,
          getOptionValue,
          isSelectNative,
          baseSelectOptionProps: (_rootProps$slotProps4 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps4.baseSelectOption
        })
      }))]
    }), clearButton]
  });
}
const _excluded$G = ["item", "applyValue", "apiRef", "focusElementRef", "isFilterActive", "clearButton", "tabIndex", "label", "InputLabelProps"];
const BooleanOperatorContainer = styled$1("div")({
  display: "flex",
  alignItems: "center",
  width: "100%",
  [`& button`]: {
    margin: "auto 0px 5px 5px"
  }
});
function GridFilterInputBoolean(props) {
  var _rootProps$slotProps, _baseSelectProps$nati, _rootProps$slotProps2, _rootProps$slotProps3;
  const {
    item,
    applyValue,
    apiRef,
    focusElementRef,
    clearButton,
    tabIndex,
    label: labelProp
  } = props, others = _objectWithoutPropertiesLoose$1(props, _excluded$G);
  const [filterValueState, setFilterValueState] = reactExports.useState(item.value || "");
  const rootProps = useGridRootProps();
  const labelId = useId();
  const selectId = useId();
  const baseSelectProps = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseSelect) || {};
  const isSelectNative = (_baseSelectProps$nati = baseSelectProps.native) != null ? _baseSelectProps$nati : true;
  const baseSelectOptionProps = ((_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseSelectOption) || {};
  const onFilterChange = reactExports.useCallback((event) => {
    const value = event.target.value;
    setFilterValueState(value);
    applyValue(_extends$2({}, item, {
      value
    }));
  }, [applyValue, item]);
  reactExports.useEffect(() => {
    setFilterValueState(item.value || "");
  }, [item.value]);
  const label = labelProp != null ? labelProp : apiRef.current.getLocaleText("filterPanelInputLabel");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(BooleanOperatorContainer, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(rootProps.slots.baseFormControl, {
      fullWidth: true,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseInputLabel, _extends$2({}, (_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseInputLabel, {
        id: labelId,
        shrink: true,
        variant: "standard",
        children: label
      })), /* @__PURE__ */ jsxRuntimeExports.jsxs(rootProps.slots.baseSelect, _extends$2({
        labelId,
        id: selectId,
        label,
        value: filterValueState,
        onChange: onFilterChange,
        variant: "standard",
        native: isSelectNative,
        displayEmpty: true,
        inputProps: {
          ref: focusElementRef,
          tabIndex
        }
      }, others, baseSelectProps, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelectOption, _extends$2({}, baseSelectOptionProps, {
          native: isSelectNative,
          value: "",
          children: apiRef.current.getLocaleText("filterValueAny")
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelectOption, _extends$2({}, baseSelectOptionProps, {
          native: isSelectNative,
          value: "true",
          children: apiRef.current.getLocaleText("filterValueTrue")
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseSelectOption, _extends$2({}, baseSelectOptionProps, {
          native: isSelectNative,
          value: "false",
          children: apiRef.current.getLocaleText("filterValueFalse")
        }))]
      }))]
    }), clearButton]
  });
}
const _excluded$F = ["logicOperators", "columnsSort", "filterFormProps", "getColumnForNewFilter", "children", "disableAddFilterButton", "disableRemoveAllButton"];
const getGridFilter = (col) => ({
  field: col.field,
  operator: col.filterOperators[0].value,
  id: Math.round(Math.random() * 1e5)
});
const GridFilterPanel = /* @__PURE__ */ reactExports.forwardRef(function GridFilterPanel2(props, ref) {
  var _rootProps$slotProps, _rootProps$slotProps2;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);
  const filterableColumns = useGridSelector(apiRef, gridFilterableColumnDefinitionsSelector);
  const lastFilterRef = reactExports.useRef(null);
  const placeholderFilter = reactExports.useRef(null);
  const {
    logicOperators = [GridLogicOperator.And, GridLogicOperator.Or],
    columnsSort,
    filterFormProps,
    getColumnForNewFilter,
    disableAddFilterButton = false,
    disableRemoveAllButton = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$F);
  const applyFilter = apiRef.current.upsertFilterItem;
  const applyFilterLogicOperator = reactExports.useCallback((operator) => {
    apiRef.current.setFilterLogicOperator(operator);
  }, [apiRef]);
  const getDefaultFilter = reactExports.useCallback(() => {
    let nextColumnWithOperator;
    if (getColumnForNewFilter && typeof getColumnForNewFilter === "function") {
      const nextFieldName = getColumnForNewFilter({
        currentFilters: (filterModel == null ? void 0 : filterModel.items) || [],
        columns: filterableColumns
      });
      if (nextFieldName === null) {
        return null;
      }
      nextColumnWithOperator = filterableColumns.find(({
        field
      }) => field === nextFieldName);
    } else {
      nextColumnWithOperator = filterableColumns.find((colDef) => {
        var _colDef$filterOperato;
        return (_colDef$filterOperato = colDef.filterOperators) == null ? void 0 : _colDef$filterOperato.length;
      });
    }
    if (!nextColumnWithOperator) {
      return null;
    }
    return getGridFilter(nextColumnWithOperator);
  }, [filterModel == null ? void 0 : filterModel.items, filterableColumns, getColumnForNewFilter]);
  const getNewFilter = reactExports.useCallback(() => {
    if (getColumnForNewFilter === void 0 || typeof getColumnForNewFilter !== "function") {
      return getDefaultFilter();
    }
    const currentFilters = filterModel.items.length ? filterModel.items : [getDefaultFilter()].filter(Boolean);
    const nextColumnFieldName = getColumnForNewFilter({
      currentFilters,
      columns: filterableColumns
    });
    if (nextColumnFieldName === null) {
      return null;
    }
    const nextColumnWithOperator = filterableColumns.find(({
      field
    }) => field === nextColumnFieldName);
    if (!nextColumnWithOperator) {
      return null;
    }
    return getGridFilter(nextColumnWithOperator);
  }, [filterModel.items, filterableColumns, getColumnForNewFilter, getDefaultFilter]);
  const items = reactExports.useMemo(() => {
    if (filterModel.items.length) {
      return filterModel.items;
    }
    if (!placeholderFilter.current) {
      placeholderFilter.current = getDefaultFilter();
    }
    return placeholderFilter.current ? [placeholderFilter.current] : [];
  }, [filterModel.items, getDefaultFilter]);
  const hasMultipleFilters = items.length > 1;
  const addNewFilter = () => {
    const newFilter = getNewFilter();
    if (!newFilter) {
      return;
    }
    apiRef.current.upsertFilterItems([...items, newFilter]);
  };
  const deleteFilter = reactExports.useCallback((item) => {
    const shouldCloseFilterPanel = items.length === 1;
    apiRef.current.deleteFilterItem(item);
    if (shouldCloseFilterPanel) {
      apiRef.current.hideFilterPanel();
    }
  }, [apiRef, items.length]);
  const handleRemoveAll = () => {
    if (items.length === 1 && items[0].value === void 0) {
      apiRef.current.deleteFilterItem(items[0]);
      apiRef.current.hideFilterPanel();
    }
    apiRef.current.setFilterModel(_extends$2({}, filterModel, {
      items: []
    }));
  };
  reactExports.useEffect(() => {
    if (logicOperators.length > 0 && filterModel.logicOperator && !logicOperators.includes(filterModel.logicOperator)) {
      applyFilterLogicOperator(logicOperators[0]);
    }
  }, [logicOperators, applyFilterLogicOperator, filterModel.logicOperator]);
  reactExports.useEffect(() => {
    if (items.length > 0) {
      lastFilterRef.current.focus();
    }
  }, [items.length]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelWrapper, _extends$2({
    ref
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridPanelContent, {
      children: items.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridFilterForm, _extends$2({
        item,
        applyFilterChanges: applyFilter,
        deleteFilter,
        hasMultipleFilters,
        showMultiFilterOperators: index2 > 0,
        multiFilterOperator: filterModel.logicOperator,
        disableMultiFilterOperator: index2 !== 1,
        applyMultiFilterOperatorChanges: applyFilterLogicOperator,
        focusElementRef: index2 === items.length - 1 ? lastFilterRef : null,
        logicOperators,
        columnsSort
      }, filterFormProps), item.id == null ? index2 : item.id))
    }), !rootProps.disableMultipleColumnsFiltering && !(disableAddFilterButton && disableRemoveAllButton) ? /* @__PURE__ */ jsxRuntimeExports.jsxs(GridPanelFooter, {
      children: [!disableAddFilterButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends$2({
        onClick: addNewFilter,
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.filterPanelAddIcon, {})
      }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseButton, {
        children: apiRef.current.getLocaleText("filterPanelAddFilter")
      })) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}), !disableRemoveAllButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseButton, _extends$2({
        onClick: handleRemoveAll,
        startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.filterPanelRemoveAllIcon, {})
      }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseButton, {
        children: apiRef.current.getLocaleText("filterPanelRemoveAll")
      })) : null]
    }) : null]
  }));
});
const _excluded$E = ["item", "applyValue", "type", "apiRef", "focusElementRef", "color", "error", "helperText", "size", "variant"];
function GridFilterInputMultipleValue(props) {
  const {
    item,
    applyValue,
    type: type2,
    apiRef,
    focusElementRef,
    color: color2,
    error,
    helperText,
    size,
    variant
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$E);
  const TextFieldProps = {
    color: color2,
    error,
    helperText,
    size,
    variant
  };
  const [filterValueState, setFilterValueState] = reactExports.useState(item.value || []);
  const id2 = useId();
  const rootProps = useGridRootProps();
  reactExports.useEffect(() => {
    var _item$value;
    const itemValue = (_item$value = item.value) != null ? _item$value : [];
    setFilterValueState(itemValue.map(String));
  }, [item.value]);
  const handleChange = reactExports.useCallback((event, value) => {
    setFilterValueState(value.map(String));
    applyValue(_extends$2({}, item, {
      value: [...value]
    }));
  }, [applyValue, item]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, _extends$2({
    multiple: true,
    freeSolo: true,
    options: [],
    filterOptions: (options, params) => {
      const {
        inputValue
      } = params;
      return inputValue == null || inputValue === "" ? [] : [inputValue];
    },
    id: id2,
    value: filterValueState,
    onChange: handleChange,
    renderTags: (value, getTagProps) => value.map((option, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseChip, _extends$2({
      variant: "outlined",
      size: "small",
      label: option
    }, getTagProps({
      index: index2
    })))),
    renderInput: (params) => {
      var _rootProps$slotProps;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends$2({}, params, {
        label: apiRef.current.getLocaleText("filterPanelInputLabel"),
        placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
        InputLabelProps: _extends$2({}, params.InputLabelProps, {
          shrink: true
        }),
        inputRef: focusElementRef,
        type: type2 || "text"
      }, TextFieldProps, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));
    }
  }, other));
}
const _excluded$D = ["item", "applyValue", "type", "apiRef", "focusElementRef", "color", "error", "helperText", "size", "variant", "getOptionLabel", "getOptionValue"];
const filter2 = createFilterOptions();
function GridFilterInputMultipleSingleSelect(props) {
  var _resolvedColumn, _resolvedColumn2;
  const {
    item,
    applyValue,
    apiRef,
    focusElementRef,
    color: color2,
    error,
    helperText,
    size,
    variant = "standard",
    getOptionLabel: getOptionLabelProp,
    getOptionValue: getOptionValueProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$D);
  const TextFieldProps = {
    color: color2,
    error,
    helperText,
    size,
    variant
  };
  const id2 = useId();
  const rootProps = useGridRootProps();
  let resolvedColumn = null;
  if (item.field) {
    const column2 = apiRef.current.getColumn(item.field);
    if (isSingleSelectColDef(column2)) {
      resolvedColumn = column2;
    }
  }
  const getOptionValue = getOptionValueProp || ((_resolvedColumn = resolvedColumn) == null ? void 0 : _resolvedColumn.getOptionValue);
  const getOptionLabel = getOptionLabelProp || ((_resolvedColumn2 = resolvedColumn) == null ? void 0 : _resolvedColumn2.getOptionLabel);
  const isOptionEqualToValue = reactExports.useCallback((option, value) => getOptionValue(option) === getOptionValue(value), [getOptionValue]);
  const resolvedValueOptions = reactExports.useMemo(() => {
    var _resolvedColumn3;
    if (!((_resolvedColumn3 = resolvedColumn) != null && _resolvedColumn3.valueOptions)) {
      return [];
    }
    if (typeof resolvedColumn.valueOptions === "function") {
      return resolvedColumn.valueOptions({
        field: resolvedColumn.field
      });
    }
    return resolvedColumn.valueOptions;
  }, [resolvedColumn]);
  const resolvedFormattedValueOptions = reactExports.useMemo(() => {
    return resolvedValueOptions == null ? void 0 : resolvedValueOptions.map(getOptionValue);
  }, [resolvedValueOptions, getOptionValue]);
  const filteredValues = reactExports.useMemo(() => {
    if (!Array.isArray(item.value)) {
      return [];
    }
    if (resolvedValueOptions !== void 0) {
      const itemValueIndexes = item.value.map((element) => {
        return resolvedFormattedValueOptions == null ? void 0 : resolvedFormattedValueOptions.findIndex((formattedOption) => formattedOption === element);
      });
      return itemValueIndexes.filter((index2) => index2 >= 0).map((index2) => resolvedValueOptions[index2]);
    }
    return item.value;
  }, [item.value, resolvedValueOptions, resolvedFormattedValueOptions]);
  reactExports.useEffect(() => {
    if (!Array.isArray(item.value) || filteredValues.length !== item.value.length) {
      applyValue(_extends$2({}, item, {
        value: filteredValues.map(getOptionValue)
      }));
    }
  }, [item, filteredValues, applyValue, getOptionValue]);
  const handleChange = reactExports.useCallback((event, value) => {
    applyValue(_extends$2({}, item, {
      value: value.map(getOptionValue)
    }));
  }, [applyValue, item, getOptionValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Autocomplete$1, _extends$2({
    multiple: true,
    options: resolvedValueOptions,
    isOptionEqualToValue,
    filterOptions: filter2,
    id: id2,
    value: filteredValues,
    onChange: handleChange,
    getOptionLabel,
    renderTags: (value, getTagProps) => value.map((option, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseChip, _extends$2({
      variant: "outlined",
      size: "small",
      label: getOptionLabel(option)
    }, getTagProps({
      index: index2
    })))),
    renderInput: (params) => {
      var _rootProps$slotProps;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.baseTextField, _extends$2({}, params, {
        label: apiRef.current.getLocaleText("filterPanelInputLabel"),
        placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
        InputLabelProps: _extends$2({}, params.InputLabelProps, {
          shrink: true
        }),
        inputRef: focusElementRef,
        type: "singleSelect"
      }, TextFieldProps, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField));
    }
  }, other));
}
const _excluded$C = ["hideMenu", "options"], _excluded2$9 = ["hideMenu", "options"];
function GridCsvExportMenuItem(props) {
  const apiRef = useGridApiContext();
  const {
    hideMenu,
    options
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$C);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, _extends$2({
    onClick: () => {
      apiRef.current.exportDataAsCsv(options);
      hideMenu == null || hideMenu();
    }
  }, other, {
    children: apiRef.current.getLocaleText("toolbarExportCSV")
  }));
}
function GridPrintExportMenuItem(props) {
  const apiRef = useGridApiContext();
  const {
    hideMenu,
    options
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded2$9);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, _extends$2({
    onClick: () => {
      apiRef.current.exportDataAsPrint(options);
      hideMenu == null || hideMenu();
    }
  }, other, {
    children: apiRef.current.getLocaleText("toolbarExportPrint")
  }));
}
const _excluded$B = ["className", "selectedRowCount"];
const useUtilityClasses$p = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["selectedRowCount"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridSelectedRowCountRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "SelectedRowCount",
  overridesResolver: (props, styles2) => styles2.selectedRowCount
})(({
  theme: theme2
}) => ({
  alignItems: "center",
  display: "flex",
  margin: theme2.spacing(0, 2),
  visibility: "hidden",
  width: 0,
  height: 0,
  [theme2.breakpoints.up("sm")]: {
    visibility: "visible",
    width: "auto",
    height: "auto"
  }
}));
const GridSelectedRowCount = /* @__PURE__ */ reactExports.forwardRef(function GridSelectedRowCount2(props, ref) {
  const {
    className,
    selectedRowCount
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$B);
  const apiRef = useGridApiContext();
  const ownerState = useGridRootProps();
  const classes = useUtilityClasses$p(ownerState);
  const rowSelectedText = apiRef.current.getLocaleText("footerRowSelected")(selectedRowCount);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridSelectedRowCountRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: rowSelectedText
  }));
});
const GridFooter = /* @__PURE__ */ reactExports.forwardRef(function GridFooter2(props, ref) {
  var _rootProps$slotProps, _rootProps$slotProps2;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const totalTopLevelRowCount = useGridSelector(apiRef, gridTopLevelRowCountSelector);
  const selectedRowCount = useGridSelector(apiRef, selectedGridRowsCountSelector);
  const visibleTopLevelRowCount = useGridSelector(apiRef, gridFilteredTopLevelRowCountSelector);
  const selectedRowCountElement = !rootProps.hideFooterSelectedRowCount && selectedRowCount > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(GridSelectedRowCount, {
    selectedRowCount
  }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", {});
  const rowCountElement = !rootProps.hideFooterRowCount && !rootProps.pagination ? /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.footerRowCount, _extends$2({}, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.footerRowCount, {
    rowCount: totalTopLevelRowCount,
    visibleRowCount: visibleTopLevelRowCount
  })) : null;
  const paginationElement = rootProps.pagination && !rootProps.hideFooterPagination && rootProps.slots.pagination && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.pagination, _extends$2({}, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.pagination));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridFooterContainer, _extends$2({
    ref
  }, props, {
    children: [selectedRowCountElement, rowCountElement, paginationElement]
  }));
});
function GridHeader() {
  var _rootProps$slotProps, _rootProps$slotProps2;
  const rootProps = useGridRootProps();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.preferencesPanel, _extends$2({}, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.preferencesPanel)), rootProps.slots.toolbar && /* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.toolbar, _extends$2({}, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.toolbar))]
  });
}
const GridLoadingOverlay = /* @__PURE__ */ reactExports.forwardRef(function GridLoadingOverlay2(props, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlay, _extends$2({
    ref
  }, props, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, {})
  }));
});
const GridNoRowsOverlay = /* @__PURE__ */ reactExports.forwardRef(function GridNoRowsOverlay2(props, ref) {
  const apiRef = useGridApiContext();
  const noRowsLabel = apiRef.current.getLocaleText("noRowsLabel");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlay, _extends$2({
    ref
  }, props, {
    children: noRowsLabel
  }));
});
const GridPaginationRoot = styled$1(TablePagination$1)(({
  theme: theme2
}) => ({
  [`& .${tablePaginationClasses$1.selectLabel}`]: {
    display: "none",
    [theme2.breakpoints.up("sm")]: {
      display: "block"
    }
  },
  [`& .${tablePaginationClasses$1.input}`]: {
    display: "none",
    [theme2.breakpoints.up("sm")]: {
      display: "inline-flex"
    }
  }
}));
const GridPagination = /* @__PURE__ */ reactExports.forwardRef(function GridPagination2(props, ref) {
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const paginationModel = useGridSelector(apiRef, gridPaginationModelSelector);
  const visibleTopLevelRowCount = useGridSelector(apiRef, gridFilteredTopLevelRowCountSelector);
  const rowCount = reactExports.useMemo(() => {
    var _ref, _rootProps$rowCount;
    return (_ref = (_rootProps$rowCount = rootProps.rowCount) != null ? _rootProps$rowCount : visibleTopLevelRowCount) != null ? _ref : 0;
  }, [rootProps.rowCount, visibleTopLevelRowCount]);
  const lastPage = reactExports.useMemo(() => Math.floor(rowCount / (paginationModel.pageSize || 1)), [rowCount, paginationModel.pageSize]);
  const handlePageSizeChange = reactExports.useCallback((event) => {
    const pageSize2 = Number(event.target.value);
    apiRef.current.setPageSize(pageSize2);
  }, [apiRef]);
  const handlePageChange = reactExports.useCallback((_2, page) => {
    apiRef.current.setPage(page);
  }, [apiRef]);
  const isPageSizeIncludedInPageSizeOptions = (pageSize2) => {
    for (let i2 = 0; i2 < rootProps.pageSizeOptions.length; i2 += 1) {
      const option = rootProps.pageSizeOptions[i2];
      if (typeof option === "number") {
        if (option === pageSize2) {
          return true;
        }
      } else if (option.value === pageSize2) {
        return true;
      }
    }
    return false;
  };
  const pageSizeOptions = isPageSizeIncludedInPageSizeOptions(paginationModel.pageSize) ? rootProps.pageSizeOptions : [];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridPaginationRoot, _extends$2({
    ref,
    component: "div",
    count: rowCount,
    page: paginationModel.page <= lastPage ? paginationModel.page : lastPage,
    rowsPerPageOptions: pageSizeOptions,
    rowsPerPage: paginationModel.pageSize,
    onPageChange: handlePageChange,
    onRowsPerPageChange: handlePageSizeChange
  }, apiRef.current.getLocaleText("MuiTablePagination"), props));
});
const _excluded$A = ["className", "rowCount", "visibleRowCount"];
const useUtilityClasses$o = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["rowCount"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridRowCountRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "RowCount",
  overridesResolver: (props, styles2) => styles2.rowCount
})(({
  theme: theme2
}) => ({
  alignItems: "center",
  display: "flex",
  margin: theme2.spacing(0, 2)
}));
const GridRowCount = /* @__PURE__ */ reactExports.forwardRef(function GridRowCount2(props, ref) {
  const {
    className,
    rowCount,
    visibleRowCount
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$A);
  const apiRef = useGridApiContext();
  const ownerState = useGridRootProps();
  const classes = useUtilityClasses$o(ownerState);
  if (rowCount === 0) {
    return null;
  }
  const text = visibleRowCount < rowCount ? apiRef.current.getLocaleText("footerTotalVisibleRows")(visibleRowCount, rowCount) : rowCount.toLocaleString();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridRowCountRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: [apiRef.current.getLocaleText("footerTotalRows"), " ", text]
  }));
});
const getVisibleRows = (apiRef, props) => {
  let rows2;
  let range;
  if (props.pagination && props.paginationMode === "client") {
    range = gridPaginationRowRangeSelector(apiRef);
    rows2 = gridPaginatedVisibleSortedGridRowEntriesSelector(apiRef);
  } else {
    rows2 = gridExpandedSortedRowEntriesSelector(apiRef);
    if (rows2.length === 0) {
      range = null;
    } else {
      range = {
        firstRowIndex: 0,
        lastRowIndex: rows2.length - 1
      };
    }
  }
  return {
    rows: rows2,
    range
  };
};
const useGridVisibleRows = (apiRef, props) => {
  const response = getVisibleRows(apiRef, props);
  return reactExports.useMemo(() => ({
    rows: response.rows,
    range: response.range
  }), [response.rows, response.range]);
};
const GLOBAL_API_REF = {
  current: null
};
function tagInternalFilter(fn3) {
  fn3.isInternal = true;
  return fn3;
}
function isInternalFilter(fn3) {
  return fn3 !== void 0 && fn3.isInternal === true;
}
function convertFilterV7ToLegacy(fn3) {
  return tagInternalFilter((filterItem, column2) => {
    const filterFn = fn3(filterItem, column2);
    if (!filterFn) {
      return filterFn;
    }
    return (cellParams) => {
      return filterFn(cellParams.value, cellParams.row, column2, GLOBAL_API_REF.current);
    };
  });
}
function convertLegacyOperators(ops) {
  return ops.map((op) => {
    return _extends$2({}, op, {
      getApplyFilterFn: convertFilterV7ToLegacy(op.getApplyFilterFnV7),
      getApplyFilterFnV7: tagInternalFilter(op.getApplyFilterFnV7)
    });
  });
}
function convertQuickFilterV7ToLegacy(fn3) {
  return tagInternalFilter((filterItem, column2, apiRef) => {
    const filterFn = fn3(filterItem, column2, apiRef);
    if (!filterFn) {
      return filterFn;
    }
    return (cellParams) => {
      return filterFn(cellParams.value, cellParams.row, column2, apiRef);
    };
  });
}
const getGridStringQuickFilterFn = tagInternalFilter((value) => {
  if (!value) {
    return null;
  }
  const filterRegex = new RegExp(escapeRegExp(value), "i");
  return (_2, row, column2, apiRef) => {
    const columnValue = apiRef.current.getRowFormattedValue(row, column2);
    return columnValue != null ? filterRegex.test(columnValue.toString()) : false;
  };
});
const getGridStringOperators = (disableTrim = false) => convertLegacyOperators([{
  value: "contains",
  getApplyFilterFnV7: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const filterItemValue = disableTrim ? filterItem.value : filterItem.value.trim();
    const filterRegex = new RegExp(escapeRegExp(filterItemValue), "i");
    return (value) => {
      return value != null ? filterRegex.test(String(value)) : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "equals",
  getApplyFilterFnV7: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const filterItemValue = disableTrim ? filterItem.value : filterItem.value.trim();
    const collator2 = new Intl.Collator(void 0, {
      sensitivity: "base",
      usage: "search"
    });
    return (value) => {
      return value != null ? collator2.compare(filterItemValue, value.toString()) === 0 : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "startsWith",
  getApplyFilterFnV7: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const filterItemValue = disableTrim ? filterItem.value : filterItem.value.trim();
    const filterRegex = new RegExp(`^${escapeRegExp(filterItemValue)}.*$`, "i");
    return (value) => {
      return value != null ? filterRegex.test(value.toString()) : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "endsWith",
  getApplyFilterFnV7: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const filterItemValue = disableTrim ? filterItem.value : filterItem.value.trim();
    const filterRegex = new RegExp(`.*${escapeRegExp(filterItemValue)}$`, "i");
    return (value) => {
      return value != null ? filterRegex.test(value.toString()) : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "isEmpty",
  getApplyFilterFnV7: () => {
    return (value) => {
      return value === "" || value == null;
    };
  },
  requiresFilterValue: false
}, {
  value: "isNotEmpty",
  getApplyFilterFnV7: () => {
    return (value) => {
      return value !== "" && value != null;
    };
  },
  requiresFilterValue: false
}, {
  value: "isAnyOf",
  getApplyFilterFnV7: (filterItem) => {
    if (!Array.isArray(filterItem.value) || filterItem.value.length === 0) {
      return null;
    }
    const filterItemValue = disableTrim ? filterItem.value : filterItem.value.map((val) => val.trim());
    const collator2 = new Intl.Collator(void 0, {
      sensitivity: "base",
      usage: "search"
    });
    return (value) => value != null ? filterItemValue.some((filterValue) => {
      return collator2.compare(filterValue, value.toString() || "") === 0;
    }) : false;
  },
  InputComponent: GridFilterInputMultipleValue
}]);
const GRID_STRING_COL_DEF = {
  width: 100,
  minWidth: 50,
  maxWidth: Infinity,
  hideable: true,
  sortable: true,
  resizable: true,
  filterable: true,
  groupable: true,
  pinnable: true,
  // @ts-ignore
  aggregable: true,
  editable: false,
  sortComparator: gridStringOrNumberComparator,
  type: "string",
  align: "left",
  filterOperators: getGridStringOperators(),
  renderEditCell: renderEditInputCell,
  getApplyQuickFilterFn: convertQuickFilterV7ToLegacy(getGridStringQuickFilterFn),
  getApplyQuickFilterFnV7: getGridStringQuickFilterFn
};
const getGridBooleanOperators = () => convertLegacyOperators([{
  value: "is",
  getApplyFilterFnV7: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const valueAsBoolean = filterItem.value === "true";
    return (value) => {
      return Boolean(value) === valueAsBoolean;
    };
  },
  InputComponent: GridFilterInputBoolean
}]);
function gridBooleanFormatter({
  value,
  api
}) {
  return value ? api.getLocaleText("booleanCellTrueLabel") : api.getLocaleText("booleanCellFalseLabel");
}
const stringToBoolean = (value) => {
  switch (value.toLowerCase().trim()) {
    case "true":
    case "yes":
    case "1":
      return true;
    case "false":
    case "no":
    case "0":
    case "null":
    case "undefined":
      return false;
    default:
      return void 0;
  }
};
const GRID_BOOLEAN_COL_DEF = _extends$2({}, GRID_STRING_COL_DEF, {
  type: "boolean",
  align: "center",
  headerAlign: "center",
  renderCell: renderBooleanCell,
  renderEditCell: renderEditBooleanCell,
  sortComparator: gridNumberComparator,
  valueFormatter: gridBooleanFormatter,
  filterOperators: getGridBooleanOperators(),
  getApplyQuickFilterFn: void 0,
  getApplyQuickFilterFnV7: void 0,
  // @ts-ignore
  aggregable: false,
  // @ts-ignore
  pastedValueParser: (value) => stringToBoolean(value)
});
const GRID_CHECKBOX_SELECTION_FIELD = "__check__";
const GRID_CHECKBOX_SELECTION_COL_DEF = _extends$2({}, GRID_BOOLEAN_COL_DEF, {
  field: GRID_CHECKBOX_SELECTION_FIELD,
  type: "checkboxSelection",
  width: 50,
  resizable: false,
  sortable: false,
  filterable: false,
  // @ts-ignore
  aggregable: false,
  disableColumnMenu: true,
  disableReorder: true,
  disableExport: true,
  getApplyQuickFilterFn: void 0,
  getApplyQuickFilterFnV7: void 0,
  valueGetter: (params) => {
    const selectionLookup = selectedIdsLookupSelector(params.api.state, params.api.instanceId);
    return selectionLookup[params.id] !== void 0;
  },
  renderHeader: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridHeaderCheckbox, _extends$2({}, params)),
  renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(GridCellCheckboxRenderer2, _extends$2({}, params))
});
const GRID_ACTIONS_COLUMN_TYPE = "actions";
const GRID_ACTIONS_COL_DEF = _extends$2({}, GRID_STRING_COL_DEF, {
  sortable: false,
  filterable: false,
  // @ts-ignore
  aggregable: false,
  width: 100,
  align: "center",
  headerAlign: "center",
  headerName: "",
  disableColumnMenu: true,
  disableExport: true,
  renderCell: renderActionsCell,
  getApplyQuickFilterFn: void 0,
  getApplyQuickFilterFnV7: void 0
});
const GRID_DETAIL_PANEL_TOGGLE_FIELD = "__detail_panel_toggle__";
const gridEditRowsStateSelector = (state) => state.editRows;
const _excluded$z = ["selected", "hovered", "rowId", "row", "index", "style", "position", "rowHeight", "className", "visibleColumns", "renderedColumns", "containerWidth", "firstColumnToRender", "lastColumnToRender", "isLastVisible", "focusedCellColumnIndexNotInRange", "isNotVisible", "focusedCell", "tabbableCell", "onClick", "onDoubleClick", "onMouseEnter", "onMouseLeave"];
const useUtilityClasses$n = (ownerState) => {
  const {
    editable,
    editing,
    selected,
    isLastVisible,
    rowHeight,
    classes
  } = ownerState;
  const slots = {
    root: ["row", selected && "selected", editable && "row--editable", editing && "row--editing", isLastVisible && "row--lastVisible", rowHeight === "auto" && "row--dynamicHeight"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function EmptyCell({
  width: width2
}) {
  if (!width2) {
    return null;
  }
  const style2 = {
    width: width2
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: `${gridClasses.cell} ${gridClasses.withBorderColor}`,
    style: style2
  });
}
const GridRow = /* @__PURE__ */ reactExports.forwardRef(function GridRow2(props, refProp) {
  const {
    selected,
    hovered,
    rowId,
    row,
    index: index2,
    style: styleProp,
    position: position2,
    rowHeight,
    className,
    visibleColumns,
    renderedColumns,
    containerWidth,
    firstColumnToRender,
    isLastVisible = false,
    focusedCellColumnIndexNotInRange,
    isNotVisible,
    focusedCell,
    onClick,
    onDoubleClick,
    onMouseEnter,
    onMouseLeave
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$z);
  const apiRef = useGridApiContext();
  const ref = reactExports.useRef(null);
  const rootProps = useGridRootProps();
  const currentPage = useGridVisibleRows(apiRef, rootProps);
  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);
  const sortModel = useGridSelector(apiRef, gridSortModelSelector);
  const treeDepth = useGridSelector(apiRef, gridRowMaximumTreeDepthSelector);
  const headerGroupingMaxDepth = useGridSelector(apiRef, gridColumnGroupsHeaderMaxDepthSelector);
  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);
  const handleRef = useForkRef(ref, refProp);
  const ariaRowIndex = index2 + headerGroupingMaxDepth + 2;
  const ownerState = {
    selected,
    hovered,
    isLastVisible,
    classes: rootProps.classes,
    editing: apiRef.current.getRowMode(rowId) === GridRowModes.Edit,
    editable: rootProps.editMode === GridEditModes.Row,
    rowHeight
  };
  const classes = useUtilityClasses$n(ownerState);
  reactExports.useLayoutEffect(() => {
    if (rowHeight === "auto" && ref.current && typeof ResizeObserver === "undefined") {
      apiRef.current.unstable_storeRowHeightMeasurement(rowId, ref.current.clientHeight, position2);
    }
  }, [apiRef, rowHeight, rowId, position2]);
  reactExports.useLayoutEffect(() => {
    if (currentPage.range) {
      const rowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(rowId);
      if (rowIndex != null) {
        apiRef.current.unstable_setLastMeasuredRowIndex(rowIndex);
      }
    }
    const rootElement = ref.current;
    const hasFixedHeight = rowHeight !== "auto";
    if (!rootElement || hasFixedHeight || typeof ResizeObserver === "undefined") {
      return void 0;
    }
    const resizeObserver = new ResizeObserver((entries) => {
      const [entry] = entries;
      const height2 = entry.borderBoxSize && entry.borderBoxSize.length > 0 ? entry.borderBoxSize[0].blockSize : entry.contentRect.height;
      apiRef.current.unstable_storeRowHeightMeasurement(rowId, height2, position2);
    });
    resizeObserver.observe(rootElement);
    return () => resizeObserver.disconnect();
  }, [apiRef, currentPage.range, index2, rowHeight, rowId, position2]);
  const publish = reactExports.useCallback((eventName, propHandler) => (event) => {
    if (event.target.nodeType === 1 && !event.currentTarget.contains(event.target)) {
      return;
    }
    if (!apiRef.current.getRow(rowId)) {
      return;
    }
    apiRef.current.publishEvent(eventName, apiRef.current.getRowParams(rowId), event);
    if (propHandler) {
      propHandler(event);
    }
  }, [apiRef, rowId]);
  const publishClick = reactExports.useCallback((event) => {
    const cell = findParentElementFromClassName(event.target, gridClasses.cell);
    const field = cell == null ? void 0 : cell.getAttribute("data-field");
    if (field) {
      if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {
        return;
      }
      if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
        return;
      }
      if (field === "__reorder__") {
        return;
      }
      if (apiRef.current.getCellMode(rowId, field) === GridCellModes.Edit) {
        return;
      }
      const column2 = apiRef.current.getColumn(field);
      if ((column2 == null ? void 0 : column2.type) === GRID_ACTIONS_COLUMN_TYPE) {
        return;
      }
    }
    publish("rowClick", onClick)(event);
  }, [apiRef, onClick, publish, rowId]);
  const {
    slots,
    slotProps,
    disableColumnReorder
  } = rootProps;
  const CellComponent = slots.cell === MemoizedGridCellV7 ? MemoizedGridCellV7 : MemoizedCellWrapper;
  const rowReordering = rootProps.rowReordering;
  const getCell = (column2, cellProps) => {
    var _editRowsState$rowId$, _editRowsState$rowId;
    const disableDragEvents = disableColumnReorder && column2.disableReorder || !rowReordering && !!sortModel.length && treeDepth > 1 && Object.keys(editRowsState).length > 0;
    const editCellState = (_editRowsState$rowId$ = (_editRowsState$rowId = editRowsState[rowId]) == null ? void 0 : _editRowsState$rowId[column2.field]) != null ? _editRowsState$rowId$ : null;
    let cellIsNotVisible = false;
    if (focusedCellColumnIndexNotInRange !== void 0 && visibleColumns[focusedCellColumnIndexNotInRange].field === column2.field) {
      cellIsNotVisible = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CellComponent, _extends$2({
      column: column2,
      width: cellProps.width,
      rowId,
      height: rowHeight,
      showRightBorder: cellProps.showRightBorder,
      align: column2.align || "left",
      colIndex: cellProps.indexRelativeToAllColumns,
      colSpan: cellProps.colSpan,
      disableDragEvents,
      editCellState,
      isNotVisible: cellIsNotVisible
    }, slotProps == null ? void 0 : slotProps.cell), column2.field);
  };
  const sizes = useGridSelector(apiRef, () => _extends$2({}, apiRef.current.unstable_getRowInternalSizes(rowId)), objectShallowCompare);
  let minHeight2 = rowHeight;
  if (minHeight2 === "auto" && sizes) {
    let numberOfBaseSizes = 0;
    const maximumSize = Object.entries(sizes).reduce((acc, [key, size]) => {
      const isBaseHeight = /^base[A-Z]/.test(key);
      if (!isBaseHeight) {
        return acc;
      }
      numberOfBaseSizes += 1;
      if (size > acc) {
        return size;
      }
      return acc;
    }, 0);
    if (maximumSize > 0 && numberOfBaseSizes > 1) {
      minHeight2 = maximumSize;
    }
  }
  const style2 = reactExports.useMemo(() => {
    if (isNotVisible) {
      return {
        opacity: 0,
        width: 0,
        height: 0
      };
    }
    const rowStyle = _extends$2({}, styleProp, {
      maxHeight: rowHeight === "auto" ? "none" : rowHeight,
      // max-height doesn't support "auto"
      minHeight: minHeight2
    });
    if (sizes != null && sizes.spacingTop) {
      const property = rootProps.rowSpacingType === "border" ? "borderTopWidth" : "marginTop";
      rowStyle[property] = sizes.spacingTop;
    }
    if (sizes != null && sizes.spacingBottom) {
      const property = rootProps.rowSpacingType === "border" ? "borderBottomWidth" : "marginBottom";
      let propertyValue = rowStyle[property];
      if (typeof propertyValue !== "number") {
        propertyValue = parseInt(propertyValue || "0", 10);
      }
      propertyValue += sizes.spacingBottom;
      rowStyle[property] = propertyValue;
    }
    return rowStyle;
  }, [isNotVisible, rowHeight, styleProp, minHeight2, sizes, rootProps.rowSpacingType]);
  const rowClassNames = apiRef.current.unstable_applyPipeProcessors("rowClassName", [], rowId);
  if (typeof rootProps.getRowClassName === "function") {
    var _currentPage$range;
    const indexRelativeToCurrentPage = index2 - (((_currentPage$range = currentPage.range) == null ? void 0 : _currentPage$range.firstRowIndex) || 0);
    const rowParams = _extends$2({}, apiRef.current.getRowParams(rowId), {
      isFirstVisible: indexRelativeToCurrentPage === 0,
      isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,
      indexRelativeToCurrentPage
    });
    rowClassNames.push(rootProps.getRowClassName(rowParams));
  }
  const randomNumber = randomNumberBetween(1e4, 20, 80);
  const rowNode = apiRef.current.getRowNode(rowId);
  if (!rowNode) {
    return null;
  }
  const rowType = rowNode.type;
  const cells = [];
  for (let i2 = 0; i2 < renderedColumns.length; i2 += 1) {
    const column2 = renderedColumns[i2];
    let indexRelativeToAllColumns = firstColumnToRender + i2;
    if (focusedCellColumnIndexNotInRange !== void 0 && focusedCell) {
      if (visibleColumns[focusedCellColumnIndexNotInRange].field === column2.field) {
        indexRelativeToAllColumns = focusedCellColumnIndexNotInRange;
      } else {
        indexRelativeToAllColumns -= 1;
      }
    }
    const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, indexRelativeToAllColumns);
    if (cellColSpanInfo && !cellColSpanInfo.spannedByColSpan) {
      if (rowType !== "skeletonRow") {
        const {
          colSpan,
          width: width2
        } = cellColSpanInfo.cellProps;
        const cellProps = {
          width: width2,
          colSpan,
          showRightBorder: rootProps.showCellVerticalBorder,
          indexRelativeToAllColumns
        };
        cells.push(getCell(column2, cellProps));
      } else {
        const {
          width: width2
        } = cellColSpanInfo.cellProps;
        const contentWidth = Math.round(randomNumber());
        cells.push(/* @__PURE__ */ jsxRuntimeExports.jsx(slots.skeletonCell, {
          width: width2,
          contentWidth,
          field: column2.field,
          align: column2.align
        }, column2.field));
      }
    }
  }
  const emptyCellWidth = containerWidth - columnsTotalWidth;
  const eventHandlers = row ? {
    onClick: publishClick,
    onDoubleClick: publish("rowDoubleClick", onDoubleClick),
    onMouseEnter: publish("rowMouseEnter", onMouseEnter),
    onMouseLeave: publish("rowMouseLeave", onMouseLeave)
  } : null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$2({
    ref: handleRef,
    "data-id": rowId,
    "data-rowindex": index2,
    role: "row",
    className: clsx(...rowClassNames, classes.root, className, hovered && "Mui-hovered"),
    "aria-rowindex": ariaRowIndex,
    "aria-selected": selected,
    style: style2
  }, eventHandlers, other, {
    children: [cells, emptyCellWidth > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(EmptyCell, {
      width: emptyCellWidth
    })]
  }));
});
const MemoizedGridRow = fastMemo(GridRow);
function GridContextProvider({
  privateApiRef,
  props,
  children
}) {
  const apiRef = reactExports.useRef(privateApiRef.current.getPublicApi());
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridRootPropsContext.Provider, {
    value: props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPrivateApiContext.Provider, {
      value: privateApiRef,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridApiContext.Provider, {
        value: apiRef,
        children
      })
    })
  });
}
const forceDebug = localStorageAvailable() && window.localStorage.getItem("DEBUG") != null;
const noop$2 = () => {
};
const noopLogger = {
  debug: noop$2,
  info: noop$2,
  warn: noop$2,
  error: noop$2
};
const LOG_LEVELS = ["debug", "info", "warn", "error"];
function getAppender(name, logLevel, appender = console) {
  const minLogLevelIdx = LOG_LEVELS.indexOf(logLevel);
  if (minLogLevelIdx === -1) {
    throw new Error(`MUI: Log level ${logLevel} not recognized.`);
  }
  const logger = LOG_LEVELS.reduce((loggerObj, method, idx) => {
    if (idx >= minLogLevelIdx) {
      loggerObj[method] = (...args) => {
        const [message, ...other] = args;
        appender[method](`MUI: ${name} - ${message}`, ...other);
      };
    } else {
      loggerObj[method] = noop$2;
    }
    return loggerObj;
  }, {});
  return logger;
}
const useGridLoggerFactory = (apiRef, props) => {
  const getLogger = reactExports.useCallback((name) => {
    if (forceDebug) {
      return getAppender(name, "debug", props.logger);
    }
    if (!props.logLevel) {
      return noopLogger;
    }
    return getAppender(name, props.logLevel.toString(), props.logger);
  }, [props.logLevel, props.logger]);
  useGridApiMethod(apiRef, {
    getLogger
  }, "private");
};
class Store {
  static create(value) {
    return new Store(value);
  }
  constructor(_value) {
    this.value = void 0;
    this.listeners = void 0;
    this.subscribe = (fn3) => {
      this.listeners.add(fn3);
      return () => {
        this.listeners.delete(fn3);
      };
    };
    this.getSnapshot = () => {
      return this.value;
    };
    this.update = (value) => {
      this.value = value;
      this.listeners.forEach((l2) => l2(value));
    };
    this.value = _value;
    this.listeners = /* @__PURE__ */ new Set();
  }
}
class EventManager {
  constructor() {
    this.maxListeners = 20;
    this.warnOnce = false;
    this.events = {};
  }
  on(eventName, listener, options = {}) {
    let collection = this.events[eventName];
    if (!collection) {
      collection = {
        highPriority: /* @__PURE__ */ new Map(),
        regular: /* @__PURE__ */ new Map()
      };
      this.events[eventName] = collection;
    }
    if (options.isFirst) {
      collection.highPriority.set(listener, true);
    } else {
      collection.regular.set(listener, true);
    }
  }
  removeListener(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName].regular.delete(listener);
      this.events[eventName].highPriority.delete(listener);
    }
  }
  removeAllListeners() {
    this.events = {};
  }
  emit(eventName, ...args) {
    const collection = this.events[eventName];
    if (!collection) {
      return;
    }
    const highPriorityListeners = Array.from(collection.highPriority.keys());
    const regularListeners = Array.from(collection.regular.keys());
    for (let i2 = highPriorityListeners.length - 1; i2 >= 0; i2 -= 1) {
      const listener = highPriorityListeners[i2];
      if (collection.highPriority.has(listener)) {
        listener.apply(this, args);
      }
    }
    for (let i2 = 0; i2 < regularListeners.length; i2 += 1) {
      const listener = regularListeners[i2];
      if (collection.regular.has(listener)) {
        listener.apply(this, args);
      }
    }
  }
  once(eventName, listener) {
    const that = this;
    this.on(eventName, function oneTimeListener(...args) {
      that.removeListener(eventName, oneTimeListener);
      listener.apply(that, args);
    });
  }
}
const SYMBOL_API_PRIVATE = Symbol("mui.api_private");
const isSyntheticEvent = (event) => {
  return event.isPropagationStopped !== void 0;
};
let globalId = 0;
function createPrivateAPI(publicApiRef) {
  var _publicApiRef$current;
  const existingPrivateApi = (_publicApiRef$current = publicApiRef.current) == null ? void 0 : _publicApiRef$current[SYMBOL_API_PRIVATE];
  if (existingPrivateApi) {
    return existingPrivateApi;
  }
  const state = {};
  const privateApi = {
    state,
    store: Store.create(state),
    instanceId: {
      id: globalId
    }
  };
  globalId += 1;
  privateApi.getPublicApi = () => publicApiRef.current;
  privateApi.register = (visibility2, methods) => {
    Object.keys(methods).forEach((methodName) => {
      const method = methods[methodName];
      const currentPrivateMethod = privateApi[methodName];
      if ((currentPrivateMethod == null ? void 0 : currentPrivateMethod.spying) === true) {
        currentPrivateMethod.target = method;
      } else {
        privateApi[methodName] = method;
      }
      if (visibility2 === "public") {
        const publicApi = publicApiRef.current;
        const currentPublicMethod = publicApi[methodName];
        if ((currentPublicMethod == null ? void 0 : currentPublicMethod.spying) === true) {
          currentPublicMethod.target = method;
        } else {
          publicApi[methodName] = method;
        }
      }
    });
  };
  privateApi.register("private", {
    caches: {},
    eventManager: new EventManager()
  });
  return privateApi;
}
function createPublicAPI(privateApiRef) {
  const publicApi = {
    get state() {
      return privateApiRef.current.state;
    },
    get store() {
      return privateApiRef.current.store;
    },
    get instanceId() {
      return privateApiRef.current.instanceId;
    },
    [SYMBOL_API_PRIVATE]: privateApiRef.current
  };
  return publicApi;
}
function useGridApiInitialization(inputApiRef, props) {
  const publicApiRef = reactExports.useRef();
  const privateApiRef = reactExports.useRef();
  if (!privateApiRef.current) {
    privateApiRef.current = createPrivateAPI(publicApiRef);
  }
  if (!publicApiRef.current) {
    publicApiRef.current = createPublicAPI(privateApiRef);
  }
  const publishEvent = reactExports.useCallback((...args) => {
    const [name, params, event = {}] = args;
    event.defaultMuiPrevented = false;
    if (isSyntheticEvent(event) && event.isPropagationStopped()) {
      return;
    }
    const details = props.signature === GridSignature.DataGridPro ? {
      api: privateApiRef.current.getPublicApi()
    } : {};
    privateApiRef.current.eventManager.emit(name, params, event, details);
  }, [privateApiRef, props.signature]);
  const subscribeEvent = reactExports.useCallback((event, handler, options) => {
    privateApiRef.current.eventManager.on(event, handler, options);
    const api = privateApiRef.current;
    return () => {
      api.eventManager.removeListener(event, handler);
    };
  }, [privateApiRef]);
  useGridApiMethod(privateApiRef, {
    subscribeEvent,
    publishEvent
  }, "public");
  reactExports.useImperativeHandle(inputApiRef, () => publicApiRef.current, [publicApiRef]);
  reactExports.useEffect(() => {
    const api = privateApiRef.current;
    return () => {
      api.publishEvent("unmount");
    };
  }, [privateApiRef]);
  return privateApiRef;
}
const useGridLocaleText = (apiRef, props) => {
  const getLocaleText = reactExports.useCallback((key) => {
    if (props.localeText[key] == null) {
      throw new Error(`Missing translation for key ${key}.`);
    }
    return props.localeText[key];
  }, [props.localeText]);
  apiRef.current.register("public", {
    getLocaleText
  });
};
const useGridPipeProcessing = (apiRef) => {
  const processorsCache = reactExports.useRef({});
  const isRunning = reactExports.useRef(false);
  const runAppliers = reactExports.useCallback((groupCache) => {
    if (isRunning.current || !groupCache) {
      return;
    }
    isRunning.current = true;
    Object.values(groupCache.appliers).forEach((callback) => {
      callback();
    });
    isRunning.current = false;
  }, []);
  const registerPipeProcessor = reactExports.useCallback((group, id2, processor) => {
    if (!processorsCache.current[group]) {
      processorsCache.current[group] = {
        processors: /* @__PURE__ */ new Map(),
        appliers: {}
      };
    }
    const groupCache = processorsCache.current[group];
    const oldProcessor = groupCache.processors.get(id2);
    if (oldProcessor !== processor) {
      groupCache.processors.set(id2, processor);
      runAppliers(groupCache);
    }
    return () => {
      processorsCache.current[group].processors.set(id2, null);
    };
  }, [runAppliers]);
  const registerPipeApplier = reactExports.useCallback((group, id2, applier) => {
    if (!processorsCache.current[group]) {
      processorsCache.current[group] = {
        processors: /* @__PURE__ */ new Map(),
        appliers: {}
      };
    }
    processorsCache.current[group].appliers[id2] = applier;
    return () => {
      const _appliers = processorsCache.current[group].appliers, otherAppliers = _objectWithoutPropertiesLoose$1(_appliers, [id2].map(_toPropertyKey$1));
      processorsCache.current[group].appliers = otherAppliers;
    };
  }, []);
  const requestPipeProcessorsApplication = reactExports.useCallback((group) => {
    const groupCache = processorsCache.current[group];
    runAppliers(groupCache);
  }, [runAppliers]);
  const applyPipeProcessors = reactExports.useCallback((...args) => {
    const [group, value, context] = args;
    if (!processorsCache.current[group]) {
      return value;
    }
    const preProcessors = Array.from(processorsCache.current[group].processors.values());
    return preProcessors.reduce((acc, preProcessor) => {
      if (!preProcessor) {
        return acc;
      }
      return preProcessor(acc, context);
    }, value);
  }, []);
  const preProcessingPrivateApi = {
    registerPipeProcessor,
    registerPipeApplier,
    requestPipeProcessorsApplication
  };
  const preProcessingPublicApi = {
    unstable_applyPipeProcessors: applyPipeProcessors
  };
  useGridApiMethod(apiRef, preProcessingPrivateApi, "private");
  useGridApiMethod(apiRef, preProcessingPublicApi, "public");
};
const useGridRegisterPipeProcessor = (apiRef, group, callback) => {
  const cleanup = reactExports.useRef();
  const id2 = reactExports.useRef(`mui-${Math.round(Math.random() * 1e9)}`);
  const registerPreProcessor = reactExports.useCallback(() => {
    cleanup.current = apiRef.current.registerPipeProcessor(group, id2.current, callback);
  }, [apiRef, callback, group]);
  useFirstRender(() => {
    registerPreProcessor();
  });
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      registerPreProcessor();
    }
    return () => {
      if (cleanup.current) {
        cleanup.current();
        cleanup.current = null;
      }
    };
  }, [registerPreProcessor]);
};
const useGridRegisterPipeApplier = (apiRef, group, callback) => {
  const cleanup = reactExports.useRef();
  const id2 = reactExports.useRef(`mui-${Math.round(Math.random() * 1e9)}`);
  const registerPreProcessor = reactExports.useCallback(() => {
    cleanup.current = apiRef.current.registerPipeApplier(group, id2.current, callback);
  }, [apiRef, callback, group]);
  useFirstRender(() => {
    registerPreProcessor();
  });
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      registerPreProcessor();
    }
    return () => {
      if (cleanup.current) {
        cleanup.current();
        cleanup.current = null;
      }
    };
  }, [registerPreProcessor]);
};
const useGridRegisterStrategyProcessor = (apiRef, strategyName, group, processor) => {
  const registerPreProcessor = reactExports.useCallback(() => {
    apiRef.current.registerStrategyProcessor(strategyName, group, processor);
  }, [apiRef, processor, group, strategyName]);
  useFirstRender(() => {
    registerPreProcessor();
  });
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      registerPreProcessor();
    }
  }, [registerPreProcessor]);
};
const GRID_DEFAULT_STRATEGY = "none";
const GRID_STRATEGIES_PROCESSORS = {
  rowTreeCreation: "rowTree",
  filtering: "rowTree",
  sorting: "rowTree",
  visibleRowsLookupCreation: "rowTree"
};
const useGridStrategyProcessing = (apiRef) => {
  const availableStrategies = reactExports.useRef(/* @__PURE__ */ new Map());
  const strategiesCache = reactExports.useRef({});
  const registerStrategyProcessor = reactExports.useCallback((strategyName, processorName, processor) => {
    const cleanup = () => {
      const _ref = strategiesCache.current[processorName], otherProcessors = _objectWithoutPropertiesLoose$1(_ref, [strategyName].map(_toPropertyKey$1));
      strategiesCache.current[processorName] = otherProcessors;
    };
    if (!strategiesCache.current[processorName]) {
      strategiesCache.current[processorName] = {};
    }
    const groupPreProcessors = strategiesCache.current[processorName];
    const previousProcessor = groupPreProcessors[strategyName];
    groupPreProcessors[strategyName] = processor;
    if (!previousProcessor || previousProcessor === processor) {
      return cleanup;
    }
    if (strategyName === apiRef.current.getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {
      apiRef.current.publishEvent("activeStrategyProcessorChange", processorName);
    }
    return cleanup;
  }, [apiRef]);
  const applyStrategyProcessor = reactExports.useCallback((processorName, params) => {
    const activeStrategy = apiRef.current.getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);
    if (activeStrategy == null) {
      throw new Error("Can't apply a strategy processor before defining an active strategy");
    }
    const groupCache = strategiesCache.current[processorName];
    if (!groupCache || !groupCache[activeStrategy]) {
      throw new Error(`No processor found for processor "${processorName}" on strategy "${activeStrategy}"`);
    }
    const processor = groupCache[activeStrategy];
    return processor(params);
  }, [apiRef]);
  const getActiveStrategy = reactExports.useCallback((strategyGroup) => {
    var _availableStrategyEnt;
    const strategyEntries = Array.from(availableStrategies.current.entries());
    const availableStrategyEntry = strategyEntries.find(([, strategy]) => {
      if (strategy.group !== strategyGroup) {
        return false;
      }
      return strategy.isAvailable();
    });
    return (_availableStrategyEnt = availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) != null ? _availableStrategyEnt : GRID_DEFAULT_STRATEGY;
  }, []);
  const setStrategyAvailability = reactExports.useCallback((strategyGroup, strategyName, isAvailable) => {
    availableStrategies.current.set(strategyName, {
      group: strategyGroup,
      isAvailable
    });
    apiRef.current.publishEvent("strategyAvailabilityChange");
  }, [apiRef]);
  const strategyProcessingApi = {
    registerStrategyProcessor,
    applyStrategyProcessor,
    getActiveStrategy,
    setStrategyAvailability
  };
  useGridApiMethod(apiRef, strategyProcessingApi, "private");
};
const useGridStateInitialization = (apiRef, props) => {
  const controlStateMapRef = reactExports.useRef({});
  const [, rawForceUpdate] = reactExports.useState();
  const registerControlState = reactExports.useCallback((controlStateItem) => {
    controlStateMapRef.current[controlStateItem.stateId] = controlStateItem;
  }, []);
  const setState = reactExports.useCallback((state, reason) => {
    let newState;
    if (isFunction$1(state)) {
      newState = state(apiRef.current.state);
    } else {
      newState = state;
    }
    if (apiRef.current.state === newState) {
      return false;
    }
    let ignoreSetState = false;
    const updatedControlStateIds = [];
    Object.keys(controlStateMapRef.current).forEach((stateId) => {
      const controlState = controlStateMapRef.current[stateId];
      const oldSubState = controlState.stateSelector(apiRef.current.state, apiRef.current.instanceId);
      const newSubState = controlState.stateSelector(newState, apiRef.current.instanceId);
      if (newSubState === oldSubState) {
        return;
      }
      updatedControlStateIds.push({
        stateId: controlState.stateId,
        hasPropChanged: newSubState !== controlState.propModel
      });
      if (controlState.propModel !== void 0 && newSubState !== controlState.propModel) {
        ignoreSetState = true;
      }
    });
    if (updatedControlStateIds.length > 1) {
      throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${updatedControlStateIds[0].stateId}, therefore, you're not allowed to update ${updatedControlStateIds.map((el2) => el2.stateId).join(", ")} in the same transaction.`);
    }
    if (!ignoreSetState) {
      apiRef.current.state = newState;
      if (apiRef.current.publishEvent) {
        apiRef.current.publishEvent("stateChange", newState);
      }
      apiRef.current.store.update(newState);
    }
    if (updatedControlStateIds.length === 1) {
      const {
        stateId,
        hasPropChanged
      } = updatedControlStateIds[0];
      const controlState = controlStateMapRef.current[stateId];
      const model = controlState.stateSelector(newState, apiRef.current.instanceId);
      if (controlState.propOnChange && hasPropChanged) {
        const details = props.signature === GridSignature.DataGridPro ? {
          api: apiRef.current,
          reason
        } : {
          reason
        };
        controlState.propOnChange(model, details);
      }
      if (!ignoreSetState) {
        apiRef.current.publishEvent(controlState.changeEvent, model, {
          reason
        });
      }
    }
    return !ignoreSetState;
  }, [apiRef, props.signature]);
  const updateControlState = reactExports.useCallback((key, state, reason) => {
    return apiRef.current.setState((previousState) => {
      return _extends$2({}, previousState, {
        [key]: state(previousState[key])
      });
    }, reason);
  }, [apiRef]);
  const forceUpdate = reactExports.useCallback(() => rawForceUpdate(() => apiRef.current.state), [apiRef]);
  const publicStateApi = {
    setState,
    forceUpdate
  };
  const privateStateApi = {
    updateControlState,
    registerControlState
  };
  useGridApiMethod(apiRef, publicStateApi, "public");
  useGridApiMethod(apiRef, privateStateApi, "private");
};
const useGridInitialization = (inputApiRef, props) => {
  const privateApiRef = useGridApiInitialization(inputApiRef, props);
  useGridLoggerFactory(privateApiRef, props);
  useGridStateInitialization(privateApiRef, props);
  useGridPipeProcessing(privateApiRef);
  useGridStrategyProcessing(privateApiRef);
  useGridLocaleText(privateApiRef, props);
  return privateApiRef;
};
const useGridInitializeState = (initializer, privateApiRef, props) => {
  const isInitialized = reactExports.useRef(false);
  if (!isInitialized.current) {
    privateApiRef.current.state = initializer(privateApiRef.current.state, props, privateApiRef);
    isInitialized.current = true;
  }
};
const dateRegex = /(\d+)-(\d+)-(\d+)/;
const dateTimeRegex = /(\d+)-(\d+)-(\d+)T(\d+):(\d+)/;
function buildApplyFilterFn(filterItem, compareFn, showTime, keepHours) {
  if (!filterItem.value) {
    return null;
  }
  const [year, month, day, hour, minute] = filterItem.value.match(showTime ? dateTimeRegex : dateRegex).slice(1).map(Number);
  const time2 = new Date(year, month - 1, day, hour || 0, minute || 0).getTime();
  return (value) => {
    if (!value) {
      return false;
    }
    if (keepHours) {
      return compareFn(value.getTime(), time2);
    }
    const dateCopy = new Date(value);
    const timeToCompare = dateCopy.setHours(showTime ? value.getHours() : 0, showTime ? value.getMinutes() : 0, 0, 0);
    return compareFn(timeToCompare, time2);
  };
}
const getGridDateOperators = (showTime) => convertLegacyOperators([{
  value: "is",
  getApplyFilterFnV7: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 === value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "not",
  getApplyFilterFnV7: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 !== value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "after",
  getApplyFilterFnV7: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 > value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "onOrAfter",
  getApplyFilterFnV7: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 >= value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "before",
  getApplyFilterFnV7: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 < value2, showTime, !showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "onOrBefore",
  getApplyFilterFnV7: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 <= value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "isEmpty",
  getApplyFilterFnV7: () => {
    return (value) => {
      return value == null;
    };
  },
  requiresFilterValue: false
}, {
  value: "isNotEmpty",
  getApplyFilterFnV7: () => {
    return (value) => {
      return value != null;
    };
  },
  requiresFilterValue: false
}]);
function throwIfNotDateObject({
  value,
  columnType,
  rowId,
  field
}) {
  if (!(value instanceof Date)) {
    throw new Error([`MUI: \`${columnType}\` column type only accepts \`Date\` objects as values.`, "Use `valueGetter` to transform the value into a `Date` object.", `Row ID: ${rowId}, field: "${field}".`].join("\n"));
  }
}
function gridDateFormatter({
  value,
  field,
  id: id2
}) {
  if (!value) {
    return "";
  }
  throwIfNotDateObject({
    value,
    columnType: "date",
    rowId: id2,
    field
  });
  return value.toLocaleDateString();
}
function gridDateTimeFormatter({
  value,
  field,
  id: id2
}) {
  if (!value) {
    return "";
  }
  throwIfNotDateObject({
    value,
    columnType: "dateTime",
    rowId: id2,
    field
  });
  return value.toLocaleString();
}
const GRID_DATE_COL_DEF = _extends$2({}, GRID_STRING_COL_DEF, {
  type: "date",
  sortComparator: gridDateComparator,
  valueFormatter: gridDateFormatter,
  filterOperators: getGridDateOperators(),
  renderEditCell: renderEditDateCell,
  getApplyQuickFilterFn: void 0,
  getApplyQuickFilterFnV7: void 0,
  // @ts-ignore
  pastedValueParser: (value) => new Date(value)
});
const GRID_DATETIME_COL_DEF = _extends$2({}, GRID_STRING_COL_DEF, {
  type: "dateTime",
  sortComparator: gridDateComparator,
  valueFormatter: gridDateTimeFormatter,
  filterOperators: getGridDateOperators(true),
  renderEditCell: renderEditDateCell,
  getApplyQuickFilterFn: void 0,
  getApplyQuickFilterFnV7: void 0,
  // @ts-ignore
  pastedValueParser: (value) => new Date(value)
});
const parseNumericValue = (value) => {
  if (value == null) {
    return null;
  }
  return Number(value);
};
const getGridNumericQuickFilterFn = tagInternalFilter((value) => {
  if (value == null || Number.isNaN(value) || value === "") {
    return null;
  }
  return (columnValue) => {
    return parseNumericValue(columnValue) === parseNumericValue(value);
  };
});
const getGridNumericOperators = () => convertLegacyOperators([{
  value: "=",
  getApplyFilterFnV7: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      return parseNumericValue(value) === filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: "!=",
  getApplyFilterFnV7: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      return parseNumericValue(value) !== filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: ">",
  getApplyFilterFnV7: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) > filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: ">=",
  getApplyFilterFnV7: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) >= filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: "<",
  getApplyFilterFnV7: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) < filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: "<=",
  getApplyFilterFnV7: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return (value) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) <= filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: "isEmpty",
  getApplyFilterFnV7: () => {
    return (value) => {
      return value == null;
    };
  },
  requiresFilterValue: false
}, {
  value: "isNotEmpty",
  getApplyFilterFnV7: () => {
    return (value) => {
      return value != null;
    };
  },
  requiresFilterValue: false
}, {
  value: "isAnyOf",
  getApplyFilterFnV7: (filterItem) => {
    if (!Array.isArray(filterItem.value) || filterItem.value.length === 0) {
      return null;
    }
    return (value) => {
      return value != null && filterItem.value.includes(Number(value));
    };
  },
  InputComponent: GridFilterInputMultipleValue,
  InputComponentProps: {
    type: "number"
  }
}]);
const GRID_NUMERIC_COL_DEF = _extends$2({}, GRID_STRING_COL_DEF, {
  type: "number",
  align: "right",
  headerAlign: "right",
  sortComparator: gridNumberComparator,
  valueParser: (value) => value === "" ? null : Number(value),
  valueFormatter: ({
    value
  }) => isNumber(value) ? value.toLocaleString() : value || "",
  filterOperators: getGridNumericOperators(),
  getApplyQuickFilterFn: convertQuickFilterV7ToLegacy(getGridNumericQuickFilterFn),
  getApplyQuickFilterFnV7: getGridNumericQuickFilterFn
});
const parseObjectValue = (value) => {
  if (value == null || !isObject2(value)) {
    return value;
  }
  return value.value;
};
const getGridSingleSelectOperators = () => convertLegacyOperators([{
  value: "is",
  getApplyFilterFnV7: (filterItem) => {
    if (filterItem.value == null || filterItem.value === "") {
      return null;
    }
    return (value) => parseObjectValue(value) === parseObjectValue(filterItem.value);
  },
  InputComponent: GridFilterInputSingleSelect
}, {
  value: "not",
  getApplyFilterFnV7: (filterItem) => {
    if (filterItem.value == null || filterItem.value === "") {
      return null;
    }
    return (value) => parseObjectValue(value) !== parseObjectValue(filterItem.value);
  },
  InputComponent: GridFilterInputSingleSelect
}, {
  value: "isAnyOf",
  getApplyFilterFnV7: (filterItem) => {
    if (!Array.isArray(filterItem.value) || filterItem.value.length === 0) {
      return null;
    }
    const filterItemValues = filterItem.value.map(parseObjectValue);
    return (value) => filterItemValues.includes(parseObjectValue(value));
  },
  InputComponent: GridFilterInputMultipleSingleSelect
}]);
const isArrayOfObjects = (options) => {
  return typeof options[0] === "object";
};
const defaultGetOptionValue = (value) => {
  return isObject2(value) ? value.value : value;
};
const defaultGetOptionLabel = (value) => {
  return isObject2(value) ? value.label : String(value);
};
const GRID_SINGLE_SELECT_COL_DEF = _extends$2({}, GRID_STRING_COL_DEF, {
  type: "singleSelect",
  getOptionLabel: defaultGetOptionLabel,
  getOptionValue: defaultGetOptionValue,
  valueFormatter(params) {
    const {
      id: id2,
      field,
      value,
      api
    } = params;
    const colDef = params.api.getColumn(field);
    if (!isSingleSelectColDef(colDef)) {
      return "";
    }
    let valueOptions;
    if (typeof colDef.valueOptions === "function") {
      valueOptions = colDef.valueOptions({
        id: id2,
        row: id2 ? api.getRow(id2) : null,
        field
      });
    } else {
      valueOptions = colDef.valueOptions;
    }
    if (value == null) {
      return "";
    }
    if (!valueOptions) {
      return value;
    }
    if (!isArrayOfObjects(valueOptions)) {
      return colDef.getOptionLabel(value);
    }
    const valueOption = valueOptions.find((option) => colDef.getOptionValue(option) === value);
    return valueOption ? colDef.getOptionLabel(valueOption) : "";
  },
  renderEditCell: renderEditSingleSelectCell,
  filterOperators: getGridSingleSelectOperators(),
  // @ts-ignore
  pastedValueParser: (value, params) => {
    const colDef = params.colDef;
    const colDefValueOptions = colDef.valueOptions;
    const valueOptions = typeof colDefValueOptions === "function" ? colDefValueOptions({
      field: colDef.field
    }) : colDefValueOptions || [];
    const getOptionValue = colDef.getOptionValue;
    const valueOption = valueOptions.find((option) => {
      if (getOptionValue(option) === value) {
        return true;
      }
      return false;
    });
    if (valueOption) {
      return value;
    }
    return void 0;
  }
});
const DEFAULT_GRID_COL_TYPE_KEY = "__default__";
const getGridDefaultColumnTypes = () => {
  const nativeColumnTypes = {
    string: GRID_STRING_COL_DEF,
    number: GRID_NUMERIC_COL_DEF,
    date: GRID_DATE_COL_DEF,
    dateTime: GRID_DATETIME_COL_DEF,
    boolean: GRID_BOOLEAN_COL_DEF,
    singleSelect: GRID_SINGLE_SELECT_COL_DEF,
    [GRID_ACTIONS_COLUMN_TYPE]: GRID_ACTIONS_COL_DEF,
    [DEFAULT_GRID_COL_TYPE_KEY]: GRID_STRING_COL_DEF
  };
  return nativeColumnTypes;
};
function sanitizeCellValue(value, delimiterCharacter) {
  if (typeof value === "string") {
    if ([delimiterCharacter, "\n", "\r", '"'].some((delimiter2) => value.includes(delimiter2))) {
      return `"${value.replace(/"/g, '""')}"`;
    }
    return value;
  }
  return value;
}
const serializeCellValue = (cellParams, options) => {
  const {
    delimiterCharacter,
    ignoreValueFormatter
  } = options;
  let value;
  if (ignoreValueFormatter) {
    var _cellParams$value2;
    const columnType = cellParams.colDef.type;
    if (columnType === "number") {
      value = String(cellParams.value);
    } else if (columnType === "date" || columnType === "dateTime") {
      var _cellParams$value;
      value = (_cellParams$value = cellParams.value) == null ? void 0 : _cellParams$value.toISOString();
    } else if (typeof ((_cellParams$value2 = cellParams.value) == null ? void 0 : _cellParams$value2.toString) === "function") {
      value = cellParams.value.toString();
    } else {
      value = cellParams.value;
    }
  } else {
    value = cellParams.formattedValue;
  }
  return sanitizeCellValue(value, delimiterCharacter);
};
buildWarning$1(["MUI: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.", "You can provide a `valueFormatter` with a string representation to be used."]);
class CSVRow {
  constructor(options) {
    this.options = void 0;
    this.rowString = "";
    this.isEmpty = true;
    this.options = options;
  }
  addValue(value) {
    if (!this.isEmpty) {
      this.rowString += this.options.delimiterCharacter;
    }
    if (value === null || value === void 0) {
      this.rowString += "";
    } else if (typeof this.options.sanitizeCellValue === "function") {
      this.rowString += this.options.sanitizeCellValue(value, this.options.delimiterCharacter);
    } else {
      this.rowString += value;
    }
    this.isEmpty = false;
  }
  getRowString() {
    return this.rowString;
  }
}
const serializeRow = ({
  id: id2,
  columns,
  getCellParams,
  delimiterCharacter,
  ignoreValueFormatter
}) => {
  const row = new CSVRow({
    delimiterCharacter
  });
  columns.forEach((column2) => {
    const cellParams = getCellParams(id2, column2.field);
    row.addValue(serializeCellValue(cellParams, {
      delimiterCharacter,
      ignoreValueFormatter
    }));
  });
  return row.getRowString();
};
function buildCSV(options) {
  const {
    columns,
    rowIds,
    delimiterCharacter,
    includeHeaders,
    includeColumnGroupsHeaders,
    ignoreValueFormatter,
    apiRef
  } = options;
  const CSVBody = rowIds.reduce((acc, id2) => `${acc}${serializeRow({
    id: id2,
    columns,
    getCellParams: apiRef.current.getCellParams,
    delimiterCharacter,
    ignoreValueFormatter
  })}\r
`, "").trim();
  if (!includeHeaders) {
    return CSVBody;
  }
  const filteredColumns = columns.filter((column2) => column2.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field);
  const headerRows = [];
  if (includeColumnGroupsHeaders) {
    const columnGroupLookup = apiRef.current.unstable_getAllGroupDetails();
    let maxColumnGroupsDepth = 0;
    const columnGroupPathsLookup = filteredColumns.reduce((acc, column2) => {
      const columnGroupPath = apiRef.current.unstable_getColumnGroupPath(column2.field);
      acc[column2.field] = columnGroupPath;
      maxColumnGroupsDepth = Math.max(maxColumnGroupsDepth, columnGroupPath.length);
      return acc;
    }, {});
    for (let i2 = 0; i2 < maxColumnGroupsDepth; i2 += 1) {
      const headerGroupRow = new CSVRow({
        delimiterCharacter,
        sanitizeCellValue
      });
      headerRows.push(headerGroupRow);
      filteredColumns.forEach((column2) => {
        const columnGroupId = (columnGroupPathsLookup[column2.field] || [])[i2];
        const columnGroup = columnGroupLookup[columnGroupId];
        headerGroupRow.addValue(columnGroup ? columnGroup.headerName || columnGroup.groupId : "");
      });
    }
  }
  const mainHeaderRow = new CSVRow({
    delimiterCharacter,
    sanitizeCellValue
  });
  filteredColumns.forEach((column2) => {
    mainHeaderRow.addValue(column2.headerName || column2.field);
  });
  headerRows.push(mainHeaderRow);
  const CSVHead = `${headerRows.map((row) => row.getRowString()).join("\r\n")}\r
`;
  return `${CSVHead}${CSVBody}`.trim();
}
function writeToClipboardPolyfill(data) {
  const span = document.createElement("span");
  span.style.whiteSpace = "pre";
  span.style.userSelect = "all";
  span.style.opacity = "0px";
  span.textContent = data;
  document.body.appendChild(span);
  const range = document.createRange();
  range.selectNode(span);
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
  try {
    document.execCommand("copy");
  } finally {
    document.body.removeChild(span);
  }
}
function copyToClipboard(data) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(data).catch(() => {
      writeToClipboardPolyfill(data);
    });
  } else {
    writeToClipboardPolyfill(data);
  }
}
function hasNativeSelection(element) {
  var _window$getSelection;
  if ((_window$getSelection = window.getSelection()) != null && _window$getSelection.toString()) {
    return true;
  }
  if (element && (element.selectionEnd || 0) - (element.selectionStart || 0) > 0) {
    return true;
  }
  return false;
}
const useGridClipboard = (apiRef, props) => {
  const ignoreValueFormatterProp = props.unstable_ignoreValueFormatterDuringExport;
  const ignoreValueFormatter = (typeof ignoreValueFormatterProp === "object" ? ignoreValueFormatterProp == null ? void 0 : ignoreValueFormatterProp.clipboardExport : ignoreValueFormatterProp) || false;
  const clipboardCopyCellDelimiter = props.clipboardCopyCellDelimiter;
  const handleCopy = reactExports.useCallback((event) => {
    if (!((event.ctrlKey || event.metaKey) && event.key === "c")) {
      return;
    }
    if (hasNativeSelection(event.target)) {
      return;
    }
    let textToCopy = "";
    const selectedRows = apiRef.current.getSelectedRows();
    if (selectedRows.size > 0) {
      textToCopy = apiRef.current.getDataAsCsv({
        includeHeaders: false,
        // TODO: make it configurable
        delimiter: clipboardCopyCellDelimiter
      });
    } else {
      const focusedCell = gridFocusCellSelector(apiRef);
      if (focusedCell) {
        const cellParams = apiRef.current.getCellParams(focusedCell.id, focusedCell.field);
        textToCopy = serializeCellValue(cellParams, {
          delimiterCharacter: clipboardCopyCellDelimiter,
          ignoreValueFormatter
        });
      }
    }
    textToCopy = apiRef.current.unstable_applyPipeProcessors("clipboardCopy", textToCopy);
    if (textToCopy) {
      copyToClipboard(textToCopy);
      apiRef.current.publishEvent("clipboardCopy", textToCopy);
    }
  }, [apiRef, ignoreValueFormatter, clipboardCopyCellDelimiter]);
  useGridNativeEventListener(apiRef, apiRef.current.rootElementRef, "keydown", handleCopy);
  useGridApiOptionHandler(apiRef, "clipboardCopy", props.onClipboardCopy);
};
const columnMenuStateInitializer = (state) => _extends$2({}, state, {
  columnMenu: {
    open: false
  }
});
const useGridColumnMenu = (apiRef) => {
  const logger = useGridLogger(apiRef, "useGridColumnMenu");
  const showColumnMenu = reactExports.useCallback((field) => {
    const shouldUpdate = apiRef.current.setState((state) => {
      if (state.columnMenu.open && state.columnMenu.field === field) {
        return state;
      }
      logger.debug("Opening Column Menu");
      return _extends$2({}, state, {
        columnMenu: {
          open: true,
          field
        }
      });
    });
    if (shouldUpdate) {
      apiRef.current.hidePreferences();
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const hideColumnMenu = reactExports.useCallback(() => {
    const columnMenuState = gridColumnMenuSelector(apiRef.current.state);
    if (columnMenuState.field) {
      const columnLookup = gridColumnLookupSelector(apiRef);
      const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);
      const orderedFields = gridColumnFieldsSelector(apiRef);
      let fieldToFocus = columnMenuState.field;
      if (!columnLookup[fieldToFocus]) {
        fieldToFocus = orderedFields[0];
      }
      if (columnVisibilityModel[fieldToFocus] === false) {
        const visibleOrderedFields = orderedFields.filter((field) => {
          if (field === fieldToFocus) {
            return true;
          }
          return columnVisibilityModel[field] !== false;
        });
        const fieldIndex = visibleOrderedFields.indexOf(fieldToFocus);
        fieldToFocus = visibleOrderedFields[fieldIndex + 1] || visibleOrderedFields[fieldIndex - 1];
      }
      apiRef.current.setColumnHeaderFocus(fieldToFocus);
    }
    const shouldUpdate = apiRef.current.setState((state) => {
      if (!state.columnMenu.open && state.columnMenu.field === void 0) {
        return state;
      }
      logger.debug("Hiding Column Menu");
      return _extends$2({}, state, {
        columnMenu: _extends$2({}, state.columnMenu, {
          open: false,
          field: void 0
        })
      });
    });
    if (shouldUpdate) {
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const toggleColumnMenu = reactExports.useCallback((field) => {
    logger.debug("Toggle Column Menu");
    const columnMenu = gridColumnMenuSelector(apiRef.current.state);
    if (!columnMenu.open || columnMenu.field !== field) {
      showColumnMenu(field);
    } else {
      hideColumnMenu();
    }
  }, [apiRef, logger, showColumnMenu, hideColumnMenu]);
  const columnMenuApi = {
    showColumnMenu,
    hideColumnMenu,
    toggleColumnMenu
  };
  useGridApiMethod(apiRef, columnMenuApi, "public");
  useGridApiEventHandler(apiRef, "columnResizeStart", hideColumnMenu);
  useGridApiEventHandler(apiRef, "virtualScrollerWheel", apiRef.current.hideColumnMenu);
  useGridApiEventHandler(apiRef, "virtualScrollerTouchMove", apiRef.current.hideColumnMenu);
};
const COLUMNS_DIMENSION_PROPERTIES = ["maxWidth", "minWidth", "width", "flex"];
function computeFlexColumnsWidth({
  initialFreeSpace,
  totalFlexUnits,
  flexColumns
}) {
  const uniqueFlexColumns = new Set(flexColumns.map((col) => col.field));
  const flexColumnsLookup = {
    all: {},
    frozenFields: [],
    freeze: (field) => {
      const value = flexColumnsLookup.all[field];
      if (value && value.frozen !== true) {
        flexColumnsLookup.all[field].frozen = true;
        flexColumnsLookup.frozenFields.push(field);
      }
    }
  };
  function loopOverFlexItems() {
    if (flexColumnsLookup.frozenFields.length === uniqueFlexColumns.size) {
      return;
    }
    const violationsLookup = {
      min: {},
      max: {}
    };
    let remainingFreeSpace = initialFreeSpace;
    let flexUnits = totalFlexUnits;
    let totalViolation = 0;
    flexColumnsLookup.frozenFields.forEach((field) => {
      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;
      flexUnits -= flexColumnsLookup.all[field].flex;
    });
    for (let i2 = 0; i2 < flexColumns.length; i2 += 1) {
      const column2 = flexColumns[i2];
      if (flexColumnsLookup.all[column2.field] && flexColumnsLookup.all[column2.field].frozen === true) {
        continue;
      }
      const widthPerFlexUnit = remainingFreeSpace / flexUnits;
      let computedWidth = widthPerFlexUnit * column2.flex;
      if (computedWidth < column2.minWidth) {
        totalViolation += column2.minWidth - computedWidth;
        computedWidth = column2.minWidth;
        violationsLookup.min[column2.field] = true;
      } else if (computedWidth > column2.maxWidth) {
        totalViolation += column2.maxWidth - computedWidth;
        computedWidth = column2.maxWidth;
        violationsLookup.max[column2.field] = true;
      }
      flexColumnsLookup.all[column2.field] = {
        frozen: false,
        computedWidth,
        flex: column2.flex
      };
    }
    if (totalViolation < 0) {
      Object.keys(violationsLookup.max).forEach((field) => {
        flexColumnsLookup.freeze(field);
      });
    } else if (totalViolation > 0) {
      Object.keys(violationsLookup.min).forEach((field) => {
        flexColumnsLookup.freeze(field);
      });
    } else {
      flexColumns.forEach(({
        field
      }) => {
        flexColumnsLookup.freeze(field);
      });
    }
    loopOverFlexItems();
  }
  loopOverFlexItems();
  return flexColumnsLookup.all;
}
const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {
  const columnsLookup = {};
  let totalFlexUnits = 0;
  let widthAllocatedBeforeFlex = 0;
  const flexColumns = [];
  rawState.orderedFields.forEach((columnField) => {
    const newColumn = _extends$2({}, rawState.lookup[columnField]);
    if (rawState.columnVisibilityModel[columnField] === false) {
      newColumn.computedWidth = 0;
    } else {
      let computedWidth;
      if (newColumn.flex && newColumn.flex > 0) {
        totalFlexUnits += newColumn.flex;
        computedWidth = 0;
        flexColumns.push(newColumn);
      } else {
        computedWidth = clamp(newColumn.width || GRID_STRING_COL_DEF.width, newColumn.minWidth || GRID_STRING_COL_DEF.minWidth, newColumn.maxWidth || GRID_STRING_COL_DEF.maxWidth);
      }
      widthAllocatedBeforeFlex += computedWidth;
      newColumn.computedWidth = computedWidth;
    }
    columnsLookup[columnField] = newColumn;
  });
  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0);
  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {
    const computedColumnWidths = computeFlexColumnsWidth({
      initialFreeSpace,
      totalFlexUnits,
      flexColumns
    });
    Object.keys(computedColumnWidths).forEach((field) => {
      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;
    });
  }
  return _extends$2({}, rawState, {
    lookup: columnsLookup
  });
};
const applyInitialState = (columnsState, initialState2) => {
  if (!initialState2) {
    return columnsState;
  }
  const {
    orderedFields = [],
    dimensions = {}
  } = initialState2;
  const columnsWithUpdatedDimensions = Object.keys(dimensions);
  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {
    return columnsState;
  }
  const orderedFieldsLookup = {};
  const cleanOrderedFields = [];
  for (let i2 = 0; i2 < orderedFields.length; i2 += 1) {
    const field = orderedFields[i2];
    if (columnsState.lookup[field]) {
      orderedFieldsLookup[field] = true;
      cleanOrderedFields.push(field);
    }
  }
  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter((field) => !orderedFieldsLookup[field])];
  const newColumnLookup = _extends$2({}, columnsState.lookup);
  for (let i2 = 0; i2 < columnsWithUpdatedDimensions.length; i2 += 1) {
    const field = columnsWithUpdatedDimensions[i2];
    const newColDef = _extends$2({}, newColumnLookup[field], {
      hasBeenResized: true
    });
    Object.entries(dimensions[field]).forEach(([key, value]) => {
      newColDef[key] = value === -1 ? Infinity : value;
    });
    newColumnLookup[field] = newColDef;
  }
  const newColumnsState = _extends$2({}, columnsState, {
    orderedFields: newOrderedFields,
    lookup: newColumnLookup
  });
  return newColumnsState;
};
function getDefaultColTypeDef(columnTypes, type2) {
  let colDef = columnTypes[DEFAULT_GRID_COL_TYPE_KEY];
  if (type2 && columnTypes[type2]) {
    colDef = columnTypes[type2];
  }
  return colDef;
}
const createColumnsState = ({
  apiRef,
  columnsToUpsert,
  initialState: initialState2,
  columnTypes,
  columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),
  keepOnlyColumnsToUpsert = false
}) => {
  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current;
  const isInsideStateInitializer = !apiRef.current.state.columns;
  let columnsState;
  if (isInsideStateInitializer) {
    columnsState = {
      orderedFields: [],
      lookup: {},
      columnVisibilityModel
    };
  } else {
    const currentState = gridColumnsStateSelector(apiRef.current.state);
    columnsState = {
      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],
      lookup: _extends$2({}, currentState.lookup),
      // Will be cleaned later if keepOnlyColumnsToUpsert=true
      columnVisibilityModel
    };
  }
  let columnsToKeep = {};
  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {
    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => _extends$2({}, acc, {
      [key]: false
    }), {});
  }
  columnsToUpsert.forEach((newColumn) => {
    const {
      field
    } = newColumn;
    columnsToKeep[field] = true;
    let existingState = columnsState.lookup[field];
    if (existingState == null) {
      existingState = _extends$2({}, getDefaultColTypeDef(columnTypes, newColumn.type), {
        field,
        hasBeenResized: false
      });
      columnsState.orderedFields.push(field);
    } else if (keepOnlyColumnsToUpsert) {
      columnsState.orderedFields.push(field);
    }
    if (existingState && existingState.type !== newColumn.type) {
      existingState = _extends$2({}, getDefaultColTypeDef(columnTypes, newColumn.type), {
        field
      });
    }
    let hasBeenResized = existingState.hasBeenResized;
    COLUMNS_DIMENSION_PROPERTIES.forEach((key) => {
      if (newColumn[key] !== void 0) {
        hasBeenResized = true;
        if (newColumn[key] === -1) {
          newColumn[key] = Infinity;
        }
      }
    });
    columnsState.lookup[field] = _extends$2({}, existingState, newColumn, {
      hasBeenResized
    });
  });
  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {
    Object.keys(columnsState.lookup).forEach((field) => {
      if (!columnsToKeep[field]) {
        delete columnsState.lookup[field];
      }
    });
  }
  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors("hydrateColumns", columnsState);
  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState2);
  return hydrateColumnsWidth(columnsStateWithPortableColumns, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null || (_apiRef$current$getRo2 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo2.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);
};
const mergeColumnsState = (columnsState) => (state) => _extends$2({}, state, {
  columns: columnsState
});
function getFirstNonSpannedColumnToRender({
  firstColumnToRender,
  apiRef,
  firstRowToRender,
  lastRowToRender,
  visibleRows
}) {
  let firstNonSpannedColumnToRender = firstColumnToRender;
  for (let i2 = firstRowToRender; i2 < lastRowToRender; i2 += 1) {
    const row = visibleRows[i2];
    if (row) {
      const rowId = visibleRows[i2].id;
      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);
      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {
        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;
      }
    }
  }
  return firstNonSpannedColumnToRender;
}
function getFirstColumnIndexToRender({
  firstColumnIndex,
  minColumnIndex,
  columnBuffer,
  firstRowToRender,
  lastRowToRender,
  apiRef,
  visibleRows
}) {
  const initialFirstColumnToRender = Math.max(firstColumnIndex - columnBuffer, minColumnIndex);
  const firstColumnToRender = getFirstNonSpannedColumnToRender({
    firstColumnToRender: initialFirstColumnToRender,
    apiRef,
    firstRowToRender,
    lastRowToRender,
    visibleRows
  });
  return firstColumnToRender;
}
function getTotalHeaderHeight(apiRef, headerHeight) {
  const densityFactor = gridDensityFactorSelector(apiRef);
  const maxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);
  return Math.floor(headerHeight * densityFactor) * ((maxDepth != null ? maxDepth : 0) + 1);
}
const defaultColumnTypes = getGridDefaultColumnTypes();
const columnsStateInitializer = (state, props, apiRef) => {
  var _props$initialState, _ref, _props$columnVisibili, _props$initialState2;
  const columnsState = createColumnsState({
    apiRef,
    columnTypes: defaultColumnTypes,
    columnsToUpsert: props.columns,
    initialState: (_props$initialState = props.initialState) == null ? void 0 : _props$initialState.columns,
    columnVisibilityModel: (_ref = (_props$columnVisibili = props.columnVisibilityModel) != null ? _props$columnVisibili : (_props$initialState2 = props.initialState) == null || (_props$initialState2 = _props$initialState2.columns) == null ? void 0 : _props$initialState2.columnVisibilityModel) != null ? _ref : {},
    keepOnlyColumnsToUpsert: true
  });
  return _extends$2({}, state, {
    columns: columnsState
  });
};
function useGridColumns(apiRef, props) {
  var _props$initialState4, _props$slotProps2;
  const logger = useGridLogger(apiRef, "useGridColumns");
  const columnTypes = defaultColumnTypes;
  const previousColumnsProp = reactExports.useRef(props.columns);
  const previousColumnTypesProp = reactExports.useRef(columnTypes);
  apiRef.current.registerControlState({
    stateId: "visibleColumns",
    propModel: props.columnVisibilityModel,
    propOnChange: props.onColumnVisibilityModelChange,
    stateSelector: gridColumnVisibilityModelSelector,
    changeEvent: "columnVisibilityModelChange"
  });
  const setGridColumnsState = reactExports.useCallback((columnsState) => {
    logger.debug("Updating columns state.");
    apiRef.current.setState(mergeColumnsState(columnsState));
    apiRef.current.forceUpdate();
    apiRef.current.publishEvent("columnsChange", columnsState.orderedFields);
  }, [logger, apiRef]);
  const getColumn = reactExports.useCallback((field) => gridColumnLookupSelector(apiRef)[field], [apiRef]);
  const getAllColumns = reactExports.useCallback(() => gridColumnDefinitionsSelector(apiRef), [apiRef]);
  const getVisibleColumns = reactExports.useCallback(() => gridVisibleColumnDefinitionsSelector(apiRef), [apiRef]);
  const getColumnIndex = reactExports.useCallback((field, useVisibleColumns = true) => {
    const columns = useVisibleColumns ? gridVisibleColumnDefinitionsSelector(apiRef) : gridColumnDefinitionsSelector(apiRef);
    return columns.findIndex((col) => col.field === field);
  }, [apiRef]);
  const getColumnPosition = reactExports.useCallback((field) => {
    const index2 = getColumnIndex(field);
    return gridColumnPositionsSelector(apiRef)[index2];
  }, [apiRef, getColumnIndex]);
  const setColumnVisibilityModel = reactExports.useCallback((model) => {
    const currentModel = gridColumnVisibilityModelSelector(apiRef);
    if (currentModel !== model) {
      apiRef.current.setState((state) => _extends$2({}, state, {
        columns: createColumnsState({
          apiRef,
          columnTypes,
          columnsToUpsert: [],
          initialState: void 0,
          columnVisibilityModel: model,
          keepOnlyColumnsToUpsert: false
        })
      }));
      apiRef.current.forceUpdate();
    }
  }, [apiRef, columnTypes]);
  const updateColumns = reactExports.useCallback((columns) => {
    const columnsState = createColumnsState({
      apiRef,
      columnTypes,
      columnsToUpsert: columns,
      initialState: void 0,
      keepOnlyColumnsToUpsert: false
    });
    setGridColumnsState(columnsState);
  }, [apiRef, setGridColumnsState, columnTypes]);
  const setColumnVisibility = reactExports.useCallback((field, isVisible2) => {
    var _columnVisibilityMode;
    const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);
    const isCurrentlyVisible = (_columnVisibilityMode = columnVisibilityModel[field]) != null ? _columnVisibilityMode : true;
    if (isVisible2 !== isCurrentlyVisible) {
      const newModel = _extends$2({}, columnVisibilityModel, {
        [field]: isVisible2
      });
      apiRef.current.setColumnVisibilityModel(newModel);
    }
  }, [apiRef]);
  const getColumnIndexRelativeToVisibleColumns = reactExports.useCallback((field) => {
    const allColumns = gridColumnFieldsSelector(apiRef);
    return allColumns.findIndex((col) => col === field);
  }, [apiRef]);
  const setColumnIndex = reactExports.useCallback((field, targetIndexPosition) => {
    const allColumns = gridColumnFieldsSelector(apiRef);
    const oldIndexPosition = getColumnIndexRelativeToVisibleColumns(field);
    if (oldIndexPosition === targetIndexPosition) {
      return;
    }
    logger.debug(`Moving column ${field} to index ${targetIndexPosition}`);
    const updatedColumns = [...allColumns];
    const fieldRemoved = updatedColumns.splice(oldIndexPosition, 1)[0];
    updatedColumns.splice(targetIndexPosition, 0, fieldRemoved);
    setGridColumnsState(_extends$2({}, gridColumnsStateSelector(apiRef.current.state), {
      orderedFields: updatedColumns
    }));
    const params = {
      column: apiRef.current.getColumn(field),
      targetIndex: apiRef.current.getColumnIndexRelativeToVisibleColumns(field),
      oldIndex: oldIndexPosition
    };
    apiRef.current.publishEvent("columnIndexChange", params);
  }, [apiRef, logger, setGridColumnsState, getColumnIndexRelativeToVisibleColumns]);
  const setColumnWidth = reactExports.useCallback((field, width2) => {
    var _apiRef$current$getRo, _apiRef$current$getRo2;
    logger.debug(`Updating column ${field} width to ${width2}`);
    const columnsState = gridColumnsStateSelector(apiRef.current.state);
    const column2 = columnsState.lookup[field];
    const newColumn = _extends$2({}, column2, {
      width: width2,
      hasBeenResized: true
    });
    setGridColumnsState(hydrateColumnsWidth(_extends$2({}, columnsState, {
      lookup: _extends$2({}, columnsState.lookup, {
        [field]: newColumn
      })
    }), (_apiRef$current$getRo = (_apiRef$current$getRo2 = apiRef.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo2.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0));
    apiRef.current.publishEvent("columnWidthChange", {
      element: apiRef.current.getColumnHeaderElement(field),
      colDef: newColumn,
      width: width2
    });
  }, [apiRef, logger, setGridColumnsState]);
  const columnApi = {
    getColumn,
    getAllColumns,
    getColumnIndex,
    getColumnPosition,
    getVisibleColumns,
    getColumnIndexRelativeToVisibleColumns,
    updateColumns,
    setColumnVisibilityModel,
    setColumnVisibility,
    setColumnWidth
  };
  const columnReorderApi = {
    setColumnIndex
  };
  useGridApiMethod(apiRef, columnApi, "public");
  useGridApiMethod(apiRef, columnReorderApi, props.signature === GridSignature.DataGrid ? "private" : "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _props$initialState$c, _props$initialState3;
    const columnsStateToExport = {};
    const columnVisibilityModelToExport = gridColumnVisibilityModelSelector(apiRef);
    const shouldExportColumnVisibilityModel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the model is controlled
      props.columnVisibilityModel != null || // Always export if the model has been initialized
      // TODO v6 Do a nullish check instead to export even if the initial model equals "{}"
      Object.keys((_props$initialState$c = (_props$initialState3 = props.initialState) == null || (_props$initialState3 = _props$initialState3.columns) == null ? void 0 : _props$initialState3.columnVisibilityModel) != null ? _props$initialState$c : {}).length > 0 || // Always export if the model is not empty
      Object.keys(columnVisibilityModelToExport).length > 0
    );
    if (shouldExportColumnVisibilityModel) {
      columnsStateToExport.columnVisibilityModel = columnVisibilityModelToExport;
    }
    columnsStateToExport.orderedFields = gridColumnFieldsSelector(apiRef);
    const columns = gridColumnDefinitionsSelector(apiRef);
    const dimensions = {};
    columns.forEach((colDef) => {
      if (colDef.hasBeenResized) {
        const colDefDimensions = {};
        COLUMNS_DIMENSION_PROPERTIES.forEach((propertyName) => {
          let propertyValue = colDef[propertyName];
          if (propertyValue === Infinity) {
            propertyValue = -1;
          }
          colDefDimensions[propertyName] = propertyValue;
        });
        dimensions[colDef.field] = colDefDimensions;
      }
    });
    if (Object.keys(dimensions).length > 0) {
      columnsStateToExport.dimensions = dimensions;
    }
    return _extends$2({}, prevState, {
      columns: columnsStateToExport
    });
  }, [apiRef, props.columnVisibilityModel, (_props$initialState4 = props.initialState) == null ? void 0 : _props$initialState4.columns]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _context$stateToResto;
    const columnVisibilityModelToImport = (_context$stateToResto = context.stateToRestore.columns) == null ? void 0 : _context$stateToResto.columnVisibilityModel;
    const initialState2 = context.stateToRestore.columns;
    if (columnVisibilityModelToImport == null && initialState2 == null) {
      return params;
    }
    const columnsState = createColumnsState({
      apiRef,
      columnTypes,
      columnsToUpsert: [],
      initialState: initialState2,
      columnVisibilityModel: columnVisibilityModelToImport,
      keepOnlyColumnsToUpsert: false
    });
    apiRef.current.setState(mergeColumnsState(columnsState));
    if (initialState2 != null) {
      apiRef.current.publishEvent("columnsChange", columnsState.orderedFields);
    }
    return params;
  }, [apiRef, columnTypes]);
  const preferencePanelPreProcessing = reactExports.useCallback((initialValue, value) => {
    if (value === GridPreferencePanelsValue.columns) {
      var _props$slotProps;
      const ColumnsPanel = props.slots.columnsPanel;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnsPanel, _extends$2({}, (_props$slotProps = props.slotProps) == null ? void 0 : _props$slotProps.columnsPanel));
    }
    return initialValue;
  }, [props.slots.columnsPanel, (_props$slotProps2 = props.slotProps) == null ? void 0 : _props$slotProps2.columnsPanel]);
  const addColumnMenuItems = reactExports.useCallback((columnMenuItems) => {
    if (props.disableColumnSelector) {
      return columnMenuItems;
    }
    return [...columnMenuItems, "columnMenuColumnsItem"];
  }, [props.disableColumnSelector]);
  useGridRegisterPipeProcessor(apiRef, "columnMenu", addColumnMenuItems);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  useGridRegisterPipeProcessor(apiRef, "preferencePanel", preferencePanelPreProcessing);
  const prevInnerWidth = reactExports.useRef(null);
  const handleGridSizeChange = (viewportInnerSize) => {
    if (prevInnerWidth.current !== viewportInnerSize.width) {
      prevInnerWidth.current = viewportInnerSize.width;
      setGridColumnsState(hydrateColumnsWidth(gridColumnsStateSelector(apiRef.current.state), viewportInnerSize.width));
    }
  };
  useGridApiEventHandler(apiRef, "viewportInnerSizeChange", handleGridSizeChange);
  const hydrateColumns = reactExports.useCallback(() => {
    logger.info(`Columns pipe processing have changed, regenerating the columns`);
    const columnsState = createColumnsState({
      apiRef,
      columnTypes,
      columnsToUpsert: [],
      initialState: void 0,
      keepOnlyColumnsToUpsert: false
    });
    setGridColumnsState(columnsState);
  }, [apiRef, logger, setGridColumnsState, columnTypes]);
  useGridRegisterPipeApplier(apiRef, "hydrateColumns", hydrateColumns);
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    logger.info(`GridColumns have changed, new length ${props.columns.length}`);
    if (previousColumnsProp.current === props.columns && previousColumnTypesProp.current === columnTypes) {
      return;
    }
    const columnsState = createColumnsState({
      apiRef,
      columnTypes,
      initialState: void 0,
      // If the user provides a model, we don't want to set it in the state here because it has it's dedicated `useEffect` which calls `setColumnVisibilityModel`
      columnsToUpsert: props.columns,
      keepOnlyColumnsToUpsert: true
    });
    previousColumnsProp.current = props.columns;
    previousColumnTypesProp.current = columnTypes;
    setGridColumnsState(columnsState);
  }, [logger, apiRef, setGridColumnsState, props.columns, columnTypes]);
  reactExports.useEffect(() => {
    if (props.columnVisibilityModel !== void 0) {
      apiRef.current.setColumnVisibilityModel(props.columnVisibilityModel);
    }
  }, [apiRef, logger, props.columnVisibilityModel]);
}
const COMPACT_DENSITY_FACTOR = 0.7;
const COMFORTABLE_DENSITY_FACTOR = 1.3;
const DENSITY_FACTORS = {
  compact: COMPACT_DENSITY_FACTOR,
  comfortable: COMFORTABLE_DENSITY_FACTOR,
  standard: 1
};
const densityStateInitializer = (state, props) => _extends$2({}, state, {
  density: {
    value: props.density,
    factor: DENSITY_FACTORS[props.density]
  }
});
const useGridDensity = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useDensity");
  const setDensity = reactExports.useCallback((newDensity) => {
    logger.debug(`Set grid density to ${newDensity}`);
    apiRef.current.setState((state) => {
      const currentDensityState = gridDensitySelector(state);
      const newDensityState = {
        value: newDensity,
        factor: DENSITY_FACTORS[newDensity]
      };
      if (isDeepEqual(currentDensityState, newDensityState)) {
        return state;
      }
      return _extends$2({}, state, {
        density: newDensityState
      });
    });
    apiRef.current.forceUpdate();
  }, [logger, apiRef]);
  reactExports.useEffect(() => {
    apiRef.current.setDensity(props.density);
  }, [apiRef, props.density]);
  const densityApi = {
    setDensity
  };
  useGridApiMethod(apiRef, densityApi, "public");
};
function exportAs(blob, extension = "csv", filename = document.title || "untitled") {
  const fullName = `${filename}.${extension}`;
  if ("download" in HTMLAnchorElement.prototype) {
    const url = URL.createObjectURL(blob);
    const a2 = document.createElement("a");
    a2.href = url;
    a2.download = fullName;
    a2.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
    });
    return;
  }
  throw new Error("MUI: exportAs not supported");
}
const getColumnsToExport = ({
  apiRef,
  options
}) => {
  const columns = gridColumnDefinitionsSelector(apiRef);
  if (options.fields) {
    return options.fields.reduce((currentColumns, field) => {
      const column2 = columns.find((col) => col.field === field);
      if (column2) {
        currentColumns.push(column2);
      }
      return currentColumns;
    }, []);
  }
  const validColumns = options.allColumns ? columns : gridVisibleColumnDefinitionsSelector(apiRef);
  return validColumns.filter((column2) => !column2.disableExport);
};
const defaultGetRowsToExport = ({
  apiRef
}) => {
  var _pinnedRows$top, _pinnedRows$bottom;
  const filteredSortedRowIds = gridFilteredSortedRowIdsSelector(apiRef);
  const rowTree = gridRowTreeSelector(apiRef);
  const selectedRows = apiRef.current.getSelectedRows();
  const bodyRows = filteredSortedRowIds.filter((id2) => rowTree[id2].type !== "footer");
  const pinnedRows = gridPinnedRowsSelector(apiRef);
  const topPinnedRowsIds = (pinnedRows == null || (_pinnedRows$top = pinnedRows.top) == null ? void 0 : _pinnedRows$top.map((row) => row.id)) || [];
  const bottomPinnedRowsIds = (pinnedRows == null || (_pinnedRows$bottom = pinnedRows.bottom) == null ? void 0 : _pinnedRows$bottom.map((row) => row.id)) || [];
  bodyRows.unshift(...topPinnedRowsIds);
  bodyRows.push(...bottomPinnedRowsIds);
  if (selectedRows.size > 0) {
    return bodyRows.filter((id2) => selectedRows.has(id2));
  }
  return bodyRows;
};
const useGridCsvExport = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridCsvExport");
  const ignoreValueFormatterProp = props.unstable_ignoreValueFormatterDuringExport;
  const ignoreValueFormatter = (typeof ignoreValueFormatterProp === "object" ? ignoreValueFormatterProp == null ? void 0 : ignoreValueFormatterProp.csvExport : ignoreValueFormatterProp) || false;
  const getDataAsCsv = reactExports.useCallback((options = {}) => {
    var _options$getRowsToExp, _options$includeHeade, _options$includeColum;
    logger.debug(`Get data as CSV`);
    const exportedColumns = getColumnsToExport({
      apiRef,
      options
    });
    const getRowsToExport = (_options$getRowsToExp = options.getRowsToExport) != null ? _options$getRowsToExp : defaultGetRowsToExport;
    const exportedRowIds = getRowsToExport({
      apiRef
    });
    return buildCSV({
      columns: exportedColumns,
      rowIds: exportedRowIds,
      delimiterCharacter: options.delimiter || ",",
      includeHeaders: (_options$includeHeade = options.includeHeaders) != null ? _options$includeHeade : true,
      includeColumnGroupsHeaders: (_options$includeColum = options.includeColumnGroupsHeaders) != null ? _options$includeColum : true,
      ignoreValueFormatter,
      apiRef
    });
  }, [logger, apiRef, ignoreValueFormatter]);
  const exportDataAsCsv = reactExports.useCallback((options) => {
    logger.debug(`Export data as CSV`);
    const csv = getDataAsCsv(options);
    const blob = new Blob([options != null && options.utf8WithBom ? new Uint8Array([239, 187, 191]) : "", csv], {
      type: "text/csv"
    });
    exportAs(blob, "csv", options == null ? void 0 : options.fileName);
  }, [logger, getDataAsCsv]);
  const csvExportApi = {
    getDataAsCsv,
    exportDataAsCsv
  };
  useGridApiMethod(apiRef, csvExportApi, "public");
  const addExportMenuButtons = reactExports.useCallback((initialValue, options) => {
    var _options$csvOptions;
    if ((_options$csvOptions = options.csvOptions) != null && _options$csvOptions.disableToolbarButton) {
      return initialValue;
    }
    return [...initialValue, {
      component: /* @__PURE__ */ jsxRuntimeExports.jsx(GridCsvExportMenuItem, {
        options: options.csvOptions
      }),
      componentName: "csvExport"
    }];
  }, []);
  useGridRegisterPipeProcessor(apiRef, "exportMenu", addExportMenuButtons);
};
const paginationStateInitializer = (state, props) => {
  var _props$paginationMode, _props$initialState;
  const paginationModel = _extends$2({}, getDefaultGridPaginationModel(props.autoPageSize), (_props$paginationMode = props.paginationModel) != null ? _props$paginationMode : (_props$initialState = props.initialState) == null || (_props$initialState = _props$initialState.pagination) == null ? void 0 : _props$initialState.paginationModel);
  throwIfPageSizeExceedsTheLimit(paginationModel.pageSize, props.signature);
  return _extends$2({}, state, {
    pagination: {
      paginationModel
    }
  });
};
const mergeStateWithPaginationModel = (rowCount, signature, paginationModelProp) => (paginationState) => {
  var _paginationModelProp$;
  let paginationModel = paginationState.paginationModel;
  const pageSize2 = (_paginationModelProp$ = paginationModelProp == null ? void 0 : paginationModelProp.pageSize) != null ? _paginationModelProp$ : paginationModel.pageSize;
  const pageCount = getPageCount(rowCount, pageSize2);
  if (paginationModelProp && ((paginationModelProp == null ? void 0 : paginationModelProp.page) !== paginationModel.page || (paginationModelProp == null ? void 0 : paginationModelProp.pageSize) !== paginationModel.pageSize)) {
    paginationModel = paginationModelProp;
  }
  const validPage = getValidPage(paginationModel.page, pageCount);
  if (validPage !== paginationModel.page) {
    paginationModel = _extends$2({}, paginationModel, {
      page: validPage
    });
  }
  throwIfPageSizeExceedsTheLimit(paginationModel.pageSize, signature);
  return {
    paginationModel
  };
};
const useGridPagination = (apiRef, props) => {
  var _props$initialState3;
  const logger = useGridLogger(apiRef, "useGridPagination");
  const visibleTopLevelRowCount = useGridSelector(apiRef, gridFilteredTopLevelRowCountSelector);
  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);
  const rowHeight = Math.floor(props.rowHeight * densityFactor);
  apiRef.current.registerControlState({
    stateId: "pagination",
    propModel: props.paginationModel,
    propOnChange: props.onPaginationModelChange,
    stateSelector: gridPaginationModelSelector,
    changeEvent: "paginationModelChange"
  });
  const setPage = reactExports.useCallback((page) => {
    const currentModel = gridPaginationModelSelector(apiRef);
    if (page === currentModel.page) {
      return;
    }
    logger.debug(`Setting page to ${page}`);
    apiRef.current.setPaginationModel({
      page,
      pageSize: currentModel.pageSize
    });
  }, [apiRef, logger]);
  const setPageSize = reactExports.useCallback((pageSize2) => {
    const currentModel = gridPaginationModelSelector(apiRef);
    if (pageSize2 === currentModel.pageSize) {
      return;
    }
    logger.debug(`Setting page size to ${pageSize2}`);
    apiRef.current.setPaginationModel({
      pageSize: pageSize2,
      page: currentModel.page
    });
  }, [apiRef, logger]);
  const setPaginationModel = reactExports.useCallback((paginationModel) => {
    var _props$rowCount;
    const currentModel = gridPaginationModelSelector(apiRef);
    if (paginationModel === currentModel) {
      return;
    }
    logger.debug("Setting 'paginationModel' to", paginationModel);
    apiRef.current.updateControlState("pagination", mergeStateWithPaginationModel((_props$rowCount = props.rowCount) != null ? _props$rowCount : visibleTopLevelRowCount, props.signature, paginationModel), "setPaginationModel");
    apiRef.current.forceUpdate();
  }, [apiRef, logger, props.rowCount, props.signature, visibleTopLevelRowCount]);
  const pageApi = {
    setPage,
    setPageSize,
    setPaginationModel
  };
  useGridApiMethod(apiRef, pageApi, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _props$initialState2;
    const paginationModel = gridPaginationModelSelector(apiRef);
    const shouldExportPaginationModel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the `paginationModel` is controlled
      props.paginationModel != null || // Always export if the `paginationModel` has been initialized
      ((_props$initialState2 = props.initialState) == null || (_props$initialState2 = _props$initialState2.pagination) == null ? void 0 : _props$initialState2.paginationModel) != null || // Export if `page` or `pageSize` is not equal to the default value
      paginationModel.page !== 0 && paginationModel.pageSize !== defaultPageSize(props.autoPageSize)
    );
    if (!shouldExportPaginationModel) {
      return prevState;
    }
    return _extends$2({}, prevState, {
      pagination: _extends$2({}, prevState.pagination, {
        paginationModel
      })
    });
  }, [apiRef, props.paginationModel, (_props$initialState3 = props.initialState) == null || (_props$initialState3 = _props$initialState3.pagination) == null ? void 0 : _props$initialState3.paginationModel, props.autoPageSize]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _context$stateToResto, _context$stateToResto2, _props$rowCount2;
    const paginationModel = (_context$stateToResto = context.stateToRestore.pagination) != null && _context$stateToResto.paginationModel ? _extends$2({}, getDefaultGridPaginationModel(props.autoPageSize), (_context$stateToResto2 = context.stateToRestore.pagination) == null ? void 0 : _context$stateToResto2.paginationModel) : gridPaginationModelSelector(apiRef);
    apiRef.current.updateControlState("pagination", mergeStateWithPaginationModel((_props$rowCount2 = props.rowCount) != null ? _props$rowCount2 : visibleTopLevelRowCount, props.signature, paginationModel), "stateRestorePreProcessing");
    return params;
  }, [apiRef, props.autoPageSize, props.rowCount, props.signature, visibleTopLevelRowCount]);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  const handlePaginationModelChange = () => {
    var _apiRef$current$virtu;
    const paginationModel = gridPaginationModelSelector(apiRef);
    if ((_apiRef$current$virtu = apiRef.current.virtualScrollerRef) != null && _apiRef$current$virtu.current) {
      apiRef.current.scrollToIndexes({
        rowIndex: paginationModel.page * paginationModel.pageSize
      });
    }
    apiRef.current.forceUpdate();
  };
  const handleUpdateAutoPageSize = reactExports.useCallback(() => {
    const dimensions = apiRef.current.getRootDimensions();
    if (!props.autoPageSize || !dimensions) {
      return;
    }
    const pinnedRowsHeight = calculatePinnedRowsHeight(apiRef);
    const maximumPageSizeWithoutScrollBar = Math.floor((dimensions.viewportInnerSize.height - pinnedRowsHeight.top - pinnedRowsHeight.bottom) / rowHeight);
    apiRef.current.setPageSize(maximumPageSizeWithoutScrollBar);
  }, [apiRef, props.autoPageSize, rowHeight]);
  useGridApiEventHandler(apiRef, "viewportInnerSizeChange", handleUpdateAutoPageSize);
  useGridApiEventHandler(apiRef, "paginationModelChange", handlePaginationModelChange);
  reactExports.useEffect(() => {
  }, [props.rowCount, props.paginationMode]);
  reactExports.useEffect(() => {
    var _props$rowCount3;
    apiRef.current.updateControlState("pagination", mergeStateWithPaginationModel((_props$rowCount3 = props.rowCount) != null ? _props$rowCount3 : visibleTopLevelRowCount, props.signature, props.paginationModel));
  }, [apiRef, props.paginationModel, props.rowCount, props.paginationMode, visibleTopLevelRowCount, props.signature]);
  reactExports.useEffect(() => {
    handleUpdateAutoPageSize();
  }, [handleUpdateAutoPageSize]);
};
function raf() {
  return new Promise((resolve2) => {
    requestAnimationFrame(() => {
      resolve2();
    });
  });
}
function buildPrintWindow(title) {
  const iframeEl = document.createElement("iframe");
  iframeEl.style.position = "absolute";
  iframeEl.style.width = "0px";
  iframeEl.style.height = "0px";
  iframeEl.title = title || document.title;
  return iframeEl;
}
const useGridPrintExport = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridPrintExport");
  const doc = reactExports.useRef(null);
  const previousGridState = reactExports.useRef(null);
  const previousColumnVisibility = reactExports.useRef({});
  const previousRows = reactExports.useRef([]);
  reactExports.useEffect(() => {
    doc.current = ownerDocument(apiRef.current.rootElementRef.current);
  }, [apiRef]);
  const updateGridColumnsForPrint = reactExports.useCallback((fields, allColumns, includeCheckboxes) => new Promise((resolve2) => {
    const exportedColumnFields = getColumnsToExport({
      apiRef,
      options: {
        fields,
        allColumns
      }
    }).map((column2) => column2.field);
    const columns = gridColumnDefinitionsSelector(apiRef);
    const newColumnVisibilityModel = {};
    columns.forEach((column2) => {
      newColumnVisibilityModel[column2.field] = exportedColumnFields.includes(column2.field);
    });
    if (includeCheckboxes) {
      newColumnVisibilityModel[GRID_CHECKBOX_SELECTION_COL_DEF.field] = true;
    }
    apiRef.current.setColumnVisibilityModel(newColumnVisibilityModel);
    resolve2();
  }), [apiRef]);
  const updateGridRowsForPrint = reactExports.useCallback((getRowsToExport) => {
    const rowsToExportIds = getRowsToExport({
      apiRef
    });
    const newRows = rowsToExportIds.map((id2) => apiRef.current.getRow(id2));
    apiRef.current.setRows(newRows);
  }, [apiRef]);
  const handlePrintWindowLoad = reactExports.useCallback((printWindow, options) => {
    var _querySelector, _querySelector2;
    const normalizeOptions = _extends$2({
      copyStyles: true,
      hideToolbar: false,
      hideFooter: false,
      includeCheckboxes: false
    }, options);
    const printDoc = printWindow.contentDocument;
    if (!printDoc) {
      return;
    }
    const rowsMeta = gridRowsMetaSelector(apiRef.current.state);
    const gridRootElement = apiRef.current.rootElementRef.current;
    const gridClone = gridRootElement.cloneNode(true);
    const gridMain = gridClone.querySelector(`.${gridClasses.main}`);
    gridMain.style.overflow = "visible";
    gridClone.style.contain = "size";
    const columnHeaders = gridClone.querySelector(`.${gridClasses.columnHeaders}`);
    const columnHeadersInner = columnHeaders.querySelector(`.${gridClasses.columnHeadersInner}`);
    columnHeadersInner.style.width = "100%";
    let gridToolbarElementHeight = ((_querySelector = gridRootElement.querySelector(`.${gridClasses.toolbarContainer}`)) == null ? void 0 : _querySelector.offsetHeight) || 0;
    let gridFooterElementHeight = ((_querySelector2 = gridRootElement.querySelector(`.${gridClasses.footerContainer}`)) == null ? void 0 : _querySelector2.offsetHeight) || 0;
    if (normalizeOptions.hideToolbar) {
      var _gridClone$querySelec;
      (_gridClone$querySelec = gridClone.querySelector(`.${gridClasses.toolbarContainer}`)) == null || _gridClone$querySelec.remove();
      gridToolbarElementHeight = 0;
    }
    if (normalizeOptions.hideFooter) {
      var _gridClone$querySelec2;
      (_gridClone$querySelec2 = gridClone.querySelector(`.${gridClasses.footerContainer}`)) == null || _gridClone$querySelec2.remove();
      gridFooterElementHeight = 0;
    }
    const computedTotalHeight = rowsMeta.currentPageTotalHeight + getTotalHeaderHeight(apiRef, props.columnHeaderHeight) + gridToolbarElementHeight + gridFooterElementHeight;
    gridClone.style.height = `${computedTotalHeight}px`;
    gridClone.style.boxSizing = "content-box";
    if (options != null && options.getRowsToExport) {
      const gridFooterElement = gridClone.querySelector(`.${gridClasses.footerContainer}`);
      gridFooterElement.style.position = "absolute";
      gridFooterElement.style.width = "100%";
      gridFooterElement.style.top = `${computedTotalHeight - gridFooterElementHeight}px`;
    }
    const container = document.createElement("div");
    container.appendChild(gridClone);
    printDoc.body.innerHTML = container.innerHTML;
    const defaultPageStyle = typeof normalizeOptions.pageStyle === "function" ? normalizeOptions.pageStyle() : normalizeOptions.pageStyle;
    if (typeof defaultPageStyle === "string") {
      const styleElement = printDoc.createElement("style");
      styleElement.appendChild(printDoc.createTextNode(defaultPageStyle));
      printDoc.head.appendChild(styleElement);
    }
    if (normalizeOptions.bodyClassName) {
      printDoc.body.classList.add(...normalizeOptions.bodyClassName.split(" "));
    }
    const stylesheetLoadPromises = [];
    if (normalizeOptions.copyStyles) {
      const rootCandidate = gridRootElement.getRootNode();
      const root2 = rootCandidate.constructor.name === "ShadowRoot" ? rootCandidate : doc.current;
      const headStyleElements = root2.querySelectorAll("style, link[rel='stylesheet']");
      for (let i2 = 0; i2 < headStyleElements.length; i2 += 1) {
        const node2 = headStyleElements[i2];
        if (node2.tagName === "STYLE") {
          const newHeadStyleElements = printDoc.createElement(node2.tagName);
          const sheet = node2.sheet;
          if (sheet) {
            let styleCSS = "";
            for (let j2 = 0; j2 < sheet.cssRules.length; j2 += 1) {
              if (typeof sheet.cssRules[j2].cssText === "string") {
                styleCSS += `${sheet.cssRules[j2].cssText}\r
`;
              }
            }
            newHeadStyleElements.appendChild(printDoc.createTextNode(styleCSS));
            printDoc.head.appendChild(newHeadStyleElements);
          }
        } else if (node2.getAttribute("href")) {
          const newHeadStyleElements = printDoc.createElement(node2.tagName);
          for (let j2 = 0; j2 < node2.attributes.length; j2 += 1) {
            const attr = node2.attributes[j2];
            if (attr) {
              newHeadStyleElements.setAttribute(attr.nodeName, attr.nodeValue || "");
            }
          }
          stylesheetLoadPromises.push(new Promise((resolve2) => {
            newHeadStyleElements.addEventListener("load", () => resolve2());
          }));
          printDoc.head.appendChild(newHeadStyleElements);
        }
      }
    }
    {
      Promise.all(stylesheetLoadPromises).then(() => {
        printWindow.contentWindow.print();
      });
    }
  }, [apiRef, doc, props.columnHeaderHeight]);
  const handlePrintWindowAfterPrint = reactExports.useCallback((printWindow) => {
    var _previousGridState$cu;
    doc.current.body.removeChild(printWindow);
    apiRef.current.restoreState(previousGridState.current || {});
    if (!((_previousGridState$cu = previousGridState.current) != null && (_previousGridState$cu = _previousGridState$cu.columns) != null && _previousGridState$cu.columnVisibilityModel)) {
      apiRef.current.setColumnVisibilityModel(previousColumnVisibility.current);
    }
    apiRef.current.unstable_setVirtualization(true);
    apiRef.current.setRows(previousRows.current);
    previousGridState.current = null;
    previousColumnVisibility.current = {};
    previousRows.current = [];
  }, [apiRef]);
  const exportDataAsPrint = reactExports.useCallback(async (options) => {
    logger.debug(`Export data as Print`);
    if (!apiRef.current.rootElementRef.current) {
      throw new Error("MUI: No grid root element available.");
    }
    previousGridState.current = apiRef.current.exportState();
    previousColumnVisibility.current = gridColumnVisibilityModelSelector(apiRef);
    previousRows.current = apiRef.current.getSortedRows();
    if (props.pagination) {
      const visibleRowCount = gridExpandedRowCountSelector(apiRef);
      const paginationModel = {
        page: 0,
        pageSize: visibleRowCount
      };
      apiRef.current.updateControlState(
        "pagination",
        // Using signature `DataGridPro` to allow more than 100 rows in the print export
        mergeStateWithPaginationModel(visibleRowCount, "DataGridPro", paginationModel)
      );
      apiRef.current.forceUpdate();
    }
    await updateGridColumnsForPrint(options == null ? void 0 : options.fields, options == null ? void 0 : options.allColumns, options == null ? void 0 : options.includeCheckboxes);
    if (options != null && options.getRowsToExport) {
      updateGridRowsForPrint(options.getRowsToExport);
    }
    apiRef.current.unstable_setVirtualization(false);
    await raf();
    const printWindow = buildPrintWindow(options == null ? void 0 : options.fileName);
    {
      printWindow.onload = () => {
        handlePrintWindowLoad(printWindow, options);
        const mediaQueryList = printWindow.contentWindow.matchMedia("print");
        mediaQueryList.addEventListener("change", (mql) => {
          const isAfterPrint = mql.matches === false;
          if (isAfterPrint) {
            handlePrintWindowAfterPrint(printWindow);
          }
        });
      };
      doc.current.body.appendChild(printWindow);
    }
  }, [props, logger, apiRef, handlePrintWindowLoad, handlePrintWindowAfterPrint, updateGridColumnsForPrint, updateGridRowsForPrint]);
  const printExportApi = {
    exportDataAsPrint
  };
  useGridApiMethod(apiRef, printExportApi, "public");
  const addExportMenuButtons = reactExports.useCallback((initialValue, options) => {
    var _options$printOptions;
    if ((_options$printOptions = options.printOptions) != null && _options$printOptions.disableToolbarButton) {
      return initialValue;
    }
    return [...initialValue, {
      component: /* @__PURE__ */ jsxRuntimeExports.jsx(GridPrintExportMenuItem, {
        options: options.printOptions
      }),
      componentName: "printExport"
    }];
  }, []);
  useGridRegisterPipeProcessor(apiRef, "exportMenu", addExportMenuButtons);
};
const globalScope = typeof window === "undefined" ? globalThis : window;
const evalCode = globalScope[atob("ZXZhbA==")];
let hasEval;
try {
  hasEval = evalCode("true");
} catch (_2) {
  hasEval = false;
}
const cleanFilterItem = (item, apiRef) => {
  const cleanItem = _extends$2({}, item);
  if (cleanItem.id == null) {
    cleanItem.id = Math.round(Math.random() * 1e5);
  }
  if (cleanItem.operator == null) {
    const column2 = gridColumnLookupSelector(apiRef)[cleanItem.field];
    cleanItem.operator = column2 && column2.filterOperators[0].value;
  }
  return cleanItem;
};
const filterModelDisableMultiColumnsFilteringWarning = buildWarning$1(["MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.", "If you are using the community version of the `DataGrid`, this prop is always `true`."], "error");
const filterModelMissingItemIdWarning = buildWarning$1("MUI: The `id` field is required on `filterModel.items` when you use multiple filters.", "error");
const filterModelMissingItemOperatorWarning = buildWarning$1("MUI: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.", "error");
const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {
  const hasSeveralItems = model.items.length > 1;
  let items;
  if (hasSeveralItems && disableMultipleColumnsFiltering) {
    filterModelDisableMultiColumnsFilteringWarning();
    items = [model.items[0]];
  } else {
    items = model.items;
  }
  const hasItemsWithoutIds = hasSeveralItems && items.some((item) => item.id == null);
  const hasItemWithoutOperator = items.some((item) => item.operator == null);
  if (hasItemsWithoutIds) {
    filterModelMissingItemIdWarning();
  }
  if (hasItemWithoutOperator) {
    filterModelMissingItemOperatorWarning();
  }
  if (hasItemWithoutOperator || hasItemsWithoutIds) {
    return _extends$2({}, model, {
      items: items.map((item) => cleanFilterItem(item, apiRef))
    });
  }
  if (model.items !== items) {
    return _extends$2({}, model, {
      items
    });
  }
  return model;
};
const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => (filteringState) => _extends$2({}, filteringState, {
  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)
});
const getFilterCallbackFromItem = (filterItem, apiRef) => {
  if (!filterItem.field || !filterItem.operator) {
    return null;
  }
  const column2 = apiRef.current.getColumn(filterItem.field);
  if (!column2) {
    return null;
  }
  let parsedValue;
  if (column2.valueParser) {
    var _filterItem$value;
    const parser = column2.valueParser;
    parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map((x2) => parser(x2)) : parser(filterItem.value);
  } else {
    parsedValue = filterItem.value;
  }
  const newFilterItem = _extends$2({}, filterItem, {
    value: parsedValue
  });
  const filterOperators = column2.filterOperators;
  if (!(filterOperators != null && filterOperators.length)) {
    throw new Error(`MUI: No filter operators found for column '${column2.field}'.`);
  }
  const filterOperator = filterOperators.find((operator) => operator.value === newFilterItem.operator);
  if (!filterOperator) {
    throw new Error(`MUI: No filter operator found for column '${column2.field}' and operator value '${newFilterItem.operator}'.`);
  }
  const hasUserFunctionLegacy = !isInternalFilter(filterOperator.getApplyFilterFn);
  const hasUserFunctionV7 = !isInternalFilter(filterOperator.getApplyFilterFnV7);
  if (filterOperator.getApplyFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {
    const applyFilterOnRow2 = filterOperator.getApplyFilterFnV7(newFilterItem, column2);
    if (typeof applyFilterOnRow2 !== "function") {
      return null;
    }
    return {
      v7: true,
      item: newFilterItem,
      fn: (row) => {
        const value = apiRef.current.getRowValue(row, column2);
        return applyFilterOnRow2(value, row, column2, apiRef);
      }
    };
  }
  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column2);
  if (typeof applyFilterOnRow !== "function") {
    return null;
  }
  return {
    v7: false,
    item: newFilterItem,
    fn: (rowId) => {
      const params = apiRef.current.getCellParams(rowId, newFilterItem.field);
      GLOBAL_API_REF.current = apiRef;
      const result = applyFilterOnRow(params);
      GLOBAL_API_REF.current = null;
      return result;
    }
  };
};
let filterItemsApplierId = 1;
const buildAggregatedFilterItemsApplier = (getRowId, filterModel, apiRef, disableEval) => {
  const {
    items
  } = filterModel;
  const appliers = items.map((item) => getFilterCallbackFromItem(item, apiRef)).filter((callback) => !!callback);
  if (appliers.length === 0) {
    return null;
  }
  if (!hasEval || disableEval) {
    return (row, shouldApplyFilter) => {
      const resultPerItemId = {};
      for (let i2 = 0; i2 < appliers.length; i2 += 1) {
        const applier = appliers[i2];
        if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {
          resultPerItemId[applier.item.id] = applier.v7 ? applier.fn(row) : applier.fn(getRowId ? getRowId(row) : row.id);
        }
      }
      return resultPerItemId;
    };
  }
  const filterItemTemplate = `(function filterItem$$(appliers, row, shouldApplyFilter) {
      ${appliers.map((applier, i2) => `const shouldApply${i2} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join("\n")}

      const result$$ = {
      ${appliers.map((applier, i2) => `${JSON.stringify(String(applier.item.id))}:
          !shouldApply${i2} ?
            false :
            ${applier.v7 ? `appliers[${i2}].fn(row)` : `appliers[${i2}].fn(${getRowId ? "getRowId(row)" : "row.id"})`},
      `).join("\n")}};

      return result$$;
    })`;
  const filterItemCore = evalCode(filterItemTemplate.replaceAll("$$", String(filterItemsApplierId)));
  const filterItem = (row, shouldApplyItem) => {
    return filterItemCore(appliers, row, shouldApplyItem);
  };
  filterItemsApplierId += 1;
  return filterItem;
};
const buildAggregatedQuickFilterApplier = (getRowId, filterModel, apiRef) => {
  var _filterModel$quickFil, _filterModel$quickFil2, _filterModel$quickFil3;
  const quickFilterValues = (_filterModel$quickFil = (_filterModel$quickFil2 = filterModel.quickFilterValues) == null ? void 0 : _filterModel$quickFil2.filter(Boolean)) != null ? _filterModel$quickFil : [];
  if (quickFilterValues.length === 0) {
    return null;
  }
  const quickFilterExcludeHiddenColumns = (_filterModel$quickFil3 = filterModel.quickFilterExcludeHiddenColumns) != null ? _filterModel$quickFil3 : false;
  const columnFields = quickFilterExcludeHiddenColumns ? gridVisibleColumnFieldsSelector(apiRef) : gridColumnFieldsSelector(apiRef);
  const appliersPerField = [];
  columnFields.forEach((field) => {
    const column2 = apiRef.current.getColumn(field);
    const getApplyQuickFilterFn = column2 == null ? void 0 : column2.getApplyQuickFilterFn;
    const getApplyQuickFilterFnV7 = column2 == null ? void 0 : column2.getApplyQuickFilterFnV7;
    const hasUserFunctionLegacy = !isInternalFilter(getApplyQuickFilterFn);
    const hasUserFunctionV7 = !isInternalFilter(getApplyQuickFilterFnV7);
    if (getApplyQuickFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {
      appliersPerField.push({
        column: column2,
        appliers: quickFilterValues.map((value) => ({
          v7: true,
          fn: getApplyQuickFilterFnV7(value, column2, apiRef)
        }))
      });
    } else if (getApplyQuickFilterFn) {
      appliersPerField.push({
        column: column2,
        appliers: quickFilterValues.map((value) => ({
          v7: false,
          fn: getApplyQuickFilterFn(value, column2, apiRef)
        }))
      });
    }
  });
  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {
    const result = {};
    const usedCellParams = {};
    outer:
      for (let v2 = 0; v2 < quickFilterValues.length; v2 += 1) {
        const filterValue = quickFilterValues[v2];
        for (let i2 = 0; i2 < appliersPerField.length; i2 += 1) {
          const {
            column: column2,
            appliers
          } = appliersPerField[i2];
          const {
            field
          } = column2;
          if (shouldApplyFilter && !shouldApplyFilter(field)) {
            continue;
          }
          const applier = appliers[v2];
          const value = apiRef.current.getRowValue(row, column2);
          if (applier.fn === null) {
            continue;
          }
          if (applier.v7) {
            const isMatching = applier.fn(value, row, column2, apiRef);
            if (isMatching) {
              result[filterValue] = true;
              continue outer;
            }
          } else {
            var _usedCellParams$field;
            const cellParams = (_usedCellParams$field = usedCellParams[field]) != null ? _usedCellParams$field : apiRef.current.getCellParams(getRowId ? getRowId(row) : row.id, field);
            usedCellParams[field] = cellParams;
            const isMatching = applier.fn(cellParams);
            if (isMatching) {
              result[filterValue] = true;
              continue outer;
            }
          }
        }
        result[filterValue] = false;
      }
    return result;
  };
};
const buildAggregatedFilterApplier = (getRowId, filterModel, apiRef, disableEval) => {
  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(getRowId, filterModel, apiRef, disableEval);
  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(getRowId, filterModel, apiRef);
  return function isRowMatchingFilters(row, shouldApplyFilter, result) {
    var _isRowMatchingFilterI, _isRowMatchingQuickFi;
    result.passingFilterItems = (_isRowMatchingFilterI = isRowMatchingFilterItems == null ? void 0 : isRowMatchingFilterItems(row, shouldApplyFilter)) != null ? _isRowMatchingFilterI : null;
    result.passingQuickFilterValues = (_isRowMatchingQuickFi = isRowMatchingQuickFilter == null ? void 0 : isRowMatchingQuickFilter(row, shouldApplyFilter)) != null ? _isRowMatchingQuickFi : null;
  };
};
const isNotNull = (result) => result != null;
const filterModelItems = (cache2, apiRef, items) => {
  if (!cache2.cleanedFilterItems) {
    cache2.cleanedFilterItems = items.filter((item) => getFilterCallbackFromItem(item, apiRef) !== null);
  }
  return cache2.cleanedFilterItems;
};
const passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache2) => {
  const cleanedFilterItems = filterModelItems(cache2, apiRef, filterModel.items);
  const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);
  const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);
  if (cleanedFilterItemResults.length > 0) {
    var _filterModel$logicOpe;
    const filterItemPredicate = (item) => {
      return cleanedFilterItemResults.some((filterItemResult) => filterItemResult[item.id]);
    };
    const logicOperator = (_filterModel$logicOpe = filterModel.logicOperator) != null ? _filterModel$logicOpe : getDefaultGridFilterModel().logicOperator;
    if (logicOperator === GridLogicOperator.And) {
      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);
      if (!passesAllFilters) {
        return false;
      }
    } else {
      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);
      if (!passesSomeFilters) {
        return false;
      }
    }
  }
  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {
    var _filterModel$quickFil4;
    const quickFilterValuePredicate = (value) => {
      return cleanedQuickFilterResults.some((quickFilterValueResult) => quickFilterValueResult[value]);
    };
    const quickFilterLogicOperator = (_filterModel$quickFil4 = filterModel.quickFilterLogicOperator) != null ? _filterModel$quickFil4 : getDefaultGridFilterModel().quickFilterLogicOperator;
    if (quickFilterLogicOperator === GridLogicOperator.And) {
      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);
      if (!passesAllQuickFilterValues) {
        return false;
      }
    } else {
      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);
      if (!passesSomeQuickFilterValues) {
        return false;
      }
    }
  }
  return true;
};
const filterStateInitializer = (state, props, apiRef) => {
  var _ref, _props$filterModel, _props$initialState;
  const filterModel = (_ref = (_props$filterModel = props.filterModel) != null ? _props$filterModel : (_props$initialState = props.initialState) == null || (_props$initialState = _props$initialState.filter) == null ? void 0 : _props$initialState.filterModel) != null ? _ref : getDefaultGridFilterModel();
  return _extends$2({}, state, {
    filter: {
      filterModel: sanitizeFilterModel(filterModel, props.disableMultipleColumnsFiltering, apiRef),
      filteredRowsLookup: {},
      filteredDescendantCountLookup: {}
    },
    visibleRowsLookup: {}
  });
};
const getVisibleRowsLookup = (params) => {
  return params.filteredRowsLookup;
};
function getVisibleRowsLookupState(apiRef, state) {
  return apiRef.current.applyStrategyProcessor("visibleRowsLookupCreation", {
    tree: state.rows.tree,
    filteredRowsLookup: state.filter.filteredRowsLookup
  });
}
function createMemoizedValues() {
  return defaultMemoize(Object.values);
}
const useGridFilter = (apiRef, props) => {
  var _props$initialState3, _props$slotProps2;
  const logger = useGridLogger(apiRef, "useGridFilter");
  apiRef.current.registerControlState({
    stateId: "filter",
    propModel: props.filterModel,
    propOnChange: props.onFilterModelChange,
    stateSelector: gridFilterModelSelector,
    changeEvent: "filterModelChange"
  });
  const updateFilteredRows = reactExports.useCallback(() => {
    apiRef.current.setState((state) => {
      const filterModel = gridFilterModelSelector(state, apiRef.current.instanceId);
      const isRowMatchingFilters = props.filterMode === "client" ? buildAggregatedFilterApplier(props.getRowId, filterModel, apiRef, props.disableEval) : null;
      const filteringResult = apiRef.current.applyStrategyProcessor("filtering", {
        isRowMatchingFilters,
        filterModel: filterModel != null ? filterModel : getDefaultGridFilterModel()
      });
      const newState = _extends$2({}, state, {
        filter: _extends$2({}, state.filter, filteringResult)
      });
      const visibleRowsLookupState = getVisibleRowsLookupState(apiRef, newState);
      return _extends$2({}, newState, {
        visibleRowsLookup: visibleRowsLookupState
      });
    });
    apiRef.current.publishEvent("filteredRowsSet");
  }, [apiRef, props.filterMode, props.getRowId, props.disableEval]);
  const addColumnMenuItem = reactExports.useCallback((columnMenuItems, colDef) => {
    if (colDef == null || colDef.filterable === false || props.disableColumnFilter) {
      return columnMenuItems;
    }
    return [...columnMenuItems, "columnMenuFilterItem"];
  }, [props.disableColumnFilter]);
  const applyFilters = reactExports.useCallback(() => {
    updateFilteredRows();
    apiRef.current.forceUpdate();
  }, [apiRef, updateFilteredRows]);
  const upsertFilterItem = reactExports.useCallback((item) => {
    const filterModel = gridFilterModelSelector(apiRef);
    const items = [...filterModel.items];
    const itemIndex = items.findIndex((filterItem) => filterItem.id === item.id);
    if (itemIndex === -1) {
      items.push(item);
    } else {
      items[itemIndex] = item;
    }
    apiRef.current.setFilterModel(_extends$2({}, filterModel, {
      items
    }), "upsertFilterItem");
  }, [apiRef]);
  const upsertFilterItems = reactExports.useCallback((items) => {
    const filterModel = gridFilterModelSelector(apiRef);
    const existingItems = [...filterModel.items];
    items.forEach((item) => {
      const itemIndex = items.findIndex((filterItem) => filterItem.id === item.id);
      if (itemIndex === -1) {
        existingItems.push(item);
      } else {
        existingItems[itemIndex] = item;
      }
    });
    apiRef.current.setFilterModel(_extends$2({}, filterModel, {
      items
    }), "upsertFilterItems");
  }, [apiRef]);
  const deleteFilterItem = reactExports.useCallback((itemToDelete) => {
    const filterModel = gridFilterModelSelector(apiRef);
    const items = filterModel.items.filter((item) => item.id !== itemToDelete.id);
    if (items.length === filterModel.items.length) {
      return;
    }
    apiRef.current.setFilterModel(_extends$2({}, filterModel, {
      items
    }), "deleteFilterItem");
  }, [apiRef]);
  const showFilterPanel = reactExports.useCallback((targetColumnField, panelId, labelId) => {
    logger.debug("Displaying filter panel");
    if (targetColumnField) {
      const filterModel = gridFilterModelSelector(apiRef);
      const filterItemsWithValue = filterModel.items.filter((item) => {
        var _column$filterOperato;
        if (item.value !== void 0) {
          if (Array.isArray(item.value) && item.value.length === 0) {
            return false;
          }
          return true;
        }
        const column2 = apiRef.current.getColumn(item.field);
        const filterOperator = (_column$filterOperato = column2.filterOperators) == null ? void 0 : _column$filterOperato.find((operator) => operator.value === item.operator);
        const requiresFilterValue = typeof (filterOperator == null ? void 0 : filterOperator.requiresFilterValue) === "undefined" ? true : filterOperator == null ? void 0 : filterOperator.requiresFilterValue;
        if (requiresFilterValue) {
          return false;
        }
        return true;
      });
      let newFilterItems;
      const filterItemOnTarget = filterItemsWithValue.find((item) => item.field === targetColumnField);
      const targetColumn = apiRef.current.getColumn(targetColumnField);
      if (filterItemOnTarget) {
        newFilterItems = filterItemsWithValue;
      } else if (props.disableMultipleColumnsFiltering) {
        newFilterItems = [cleanFilterItem({
          field: targetColumnField,
          operator: targetColumn.filterOperators[0].value
        }, apiRef)];
      } else {
        newFilterItems = [...filterItemsWithValue, cleanFilterItem({
          field: targetColumnField,
          operator: targetColumn.filterOperators[0].value
        }, apiRef)];
      }
      apiRef.current.setFilterModel(_extends$2({}, filterModel, {
        items: newFilterItems
      }));
    }
    apiRef.current.showPreferences(GridPreferencePanelsValue.filters, panelId, labelId);
  }, [apiRef, logger, props.disableMultipleColumnsFiltering]);
  const hideFilterPanel = reactExports.useCallback(() => {
    logger.debug("Hiding filter panel");
    apiRef.current.hidePreferences();
  }, [apiRef, logger]);
  const setFilterLogicOperator = reactExports.useCallback((logicOperator) => {
    const filterModel = gridFilterModelSelector(apiRef);
    if (filterModel.logicOperator === logicOperator) {
      return;
    }
    apiRef.current.setFilterModel(_extends$2({}, filterModel, {
      logicOperator
    }), "changeLogicOperator");
  }, [apiRef]);
  const setQuickFilterValues = reactExports.useCallback((values2) => {
    const filterModel = gridFilterModelSelector(apiRef);
    if (isDeepEqual(filterModel.quickFilterValues, values2)) {
      return;
    }
    apiRef.current.setFilterModel(_extends$2({}, filterModel, {
      quickFilterValues: [...values2]
    }));
  }, [apiRef]);
  const setFilterModel = reactExports.useCallback((model, reason) => {
    const currentModel = gridFilterModelSelector(apiRef);
    if (currentModel !== model) {
      logger.debug("Setting filter model");
      apiRef.current.updateControlState("filter", mergeStateWithFilterModel(model, props.disableMultipleColumnsFiltering, apiRef), reason);
      apiRef.current.unstable_applyFilters();
    }
  }, [apiRef, logger, props.disableMultipleColumnsFiltering]);
  const filterApi = {
    setFilterLogicOperator,
    unstable_applyFilters: applyFilters,
    deleteFilterItem,
    upsertFilterItem,
    upsertFilterItems,
    setFilterModel,
    showFilterPanel,
    hideFilterPanel,
    setQuickFilterValues
  };
  useGridApiMethod(apiRef, filterApi, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _props$initialState2;
    const filterModelToExport = gridFilterModelSelector(apiRef);
    const shouldExportFilterModel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the model is controlled
      props.filterModel != null || // Always export if the model has been initialized
      ((_props$initialState2 = props.initialState) == null || (_props$initialState2 = _props$initialState2.filter) == null ? void 0 : _props$initialState2.filterModel) != null || // Export if the model is not equal to the default value
      !isDeepEqual(filterModelToExport, getDefaultGridFilterModel())
    );
    if (!shouldExportFilterModel) {
      return prevState;
    }
    return _extends$2({}, prevState, {
      filter: {
        filterModel: filterModelToExport
      }
    });
  }, [apiRef, props.filterModel, (_props$initialState3 = props.initialState) == null || (_props$initialState3 = _props$initialState3.filter) == null ? void 0 : _props$initialState3.filterModel]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _context$stateToResto;
    const filterModel = (_context$stateToResto = context.stateToRestore.filter) == null ? void 0 : _context$stateToResto.filterModel;
    if (filterModel == null) {
      return params;
    }
    apiRef.current.updateControlState("filter", mergeStateWithFilterModel(filterModel, props.disableMultipleColumnsFiltering, apiRef), "restoreState");
    return _extends$2({}, params, {
      callbacks: [...params.callbacks, apiRef.current.unstable_applyFilters]
    });
  }, [apiRef, props.disableMultipleColumnsFiltering]);
  const preferencePanelPreProcessing = reactExports.useCallback((initialValue, value) => {
    if (value === GridPreferencePanelsValue.filters) {
      var _props$slotProps;
      const FilterPanel = props.slots.filterPanel;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FilterPanel, _extends$2({}, (_props$slotProps = props.slotProps) == null ? void 0 : _props$slotProps.filterPanel));
    }
    return initialValue;
  }, [props.slots.filterPanel, (_props$slotProps2 = props.slotProps) == null ? void 0 : _props$slotProps2.filterPanel]);
  const {
    getRowId
  } = props;
  const getRowsRef = useLazyRef(createMemoizedValues);
  const flatFilteringMethod = reactExports.useCallback((params) => {
    if (props.filterMode !== "client" || !params.isRowMatchingFilters) {
      return {
        filteredRowsLookup: {},
        filteredDescendantCountLookup: {}
      };
    }
    const dataRowIdToModelLookup = gridRowsLookupSelector(apiRef);
    const filteredRowsLookup = {};
    const {
      isRowMatchingFilters
    } = params;
    const filterCache = {};
    const result = {
      passingFilterItems: null,
      passingQuickFilterValues: null
    };
    const rows2 = getRowsRef.current(apiRef.current.state.rows.dataRowIdToModelLookup);
    for (let i2 = 0; i2 < rows2.length; i2 += 1) {
      const row = rows2[i2];
      const id2 = getRowId ? getRowId(row) : row.id;
      isRowMatchingFilters(row, void 0, result);
      const isRowPassing = passFilterLogic([result.passingFilterItems], [result.passingQuickFilterValues], params.filterModel, apiRef, filterCache);
      filteredRowsLookup[id2] = isRowPassing;
    }
    const footerId = "auto-generated-group-footer-root";
    const footer = dataRowIdToModelLookup[footerId];
    if (footer) {
      filteredRowsLookup[footerId] = true;
    }
    return {
      filteredRowsLookup,
      filteredDescendantCountLookup: {}
    };
  }, [apiRef, props.filterMode, getRowId, getRowsRef]);
  useGridRegisterPipeProcessor(apiRef, "columnMenu", addColumnMenuItem);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  useGridRegisterPipeProcessor(apiRef, "preferencePanel", preferencePanelPreProcessing);
  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, "filtering", flatFilteringMethod);
  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, "visibleRowsLookupCreation", getVisibleRowsLookup);
  const handleColumnsChange = reactExports.useCallback(() => {
    logger.debug("onColUpdated - GridColumns changed, applying filters");
    const filterModel = gridFilterModelSelector(apiRef);
    const filterableColumnsLookup = gridFilterableColumnLookupSelector(apiRef);
    const newFilterItems = filterModel.items.filter((item) => item.field && filterableColumnsLookup[item.field]);
    if (newFilterItems.length < filterModel.items.length) {
      apiRef.current.setFilterModel(_extends$2({}, filterModel, {
        items: newFilterItems
      }));
    }
  }, [apiRef, logger]);
  const handleStrategyProcessorChange = reactExports.useCallback((methodName) => {
    if (methodName === "filtering") {
      apiRef.current.unstable_applyFilters();
    }
  }, [apiRef]);
  const updateVisibleRowsLookupState = reactExports.useCallback(() => {
    apiRef.current.setState((state) => {
      return _extends$2({}, state, {
        visibleRowsLookup: getVisibleRowsLookupState(apiRef, state)
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  useGridApiEventHandler(apiRef, "rowsSet", updateFilteredRows);
  useGridApiEventHandler(apiRef, "columnsChange", handleColumnsChange);
  useGridApiEventHandler(apiRef, "activeStrategyProcessorChange", handleStrategyProcessorChange);
  useGridApiEventHandler(apiRef, "rowExpansionChange", updateVisibleRowsLookupState);
  useGridApiEventHandler(apiRef, "columnVisibilityModelChange", () => {
    const filterModel = gridFilterModelSelector(apiRef);
    if (filterModel.quickFilterValues && filterModel.quickFilterExcludeHiddenColumns) {
      apiRef.current.unstable_applyFilters();
    }
  });
  useFirstRender(() => {
    apiRef.current.unstable_applyFilters();
  });
  useEnhancedEffect$1(() => {
    if (props.filterModel !== void 0) {
      apiRef.current.setFilterModel(props.filterModel);
    }
  }, [apiRef, logger, props.filterModel]);
};
const focusStateInitializer = (state) => _extends$2({}, state, {
  focus: {
    cell: null,
    columnHeader: null,
    columnHeaderFilter: null,
    columnGroupHeader: null
  },
  tabIndex: {
    cell: null,
    columnHeader: null,
    columnHeaderFilter: null,
    columnGroupHeader: null
  }
});
const useGridFocus = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridFocus");
  const lastClickedCell = reactExports.useRef(null);
  const publishCellFocusOut = reactExports.useCallback((cell, event) => {
    if (cell) {
      if (apiRef.current.getRow(cell.id)) {
        apiRef.current.publishEvent("cellFocusOut", apiRef.current.getCellParams(cell.id, cell.field), event);
      }
    }
  }, [apiRef]);
  const setCellFocus = reactExports.useCallback((id2, field) => {
    const focusedCell = gridFocusCellSelector(apiRef);
    if ((focusedCell == null ? void 0 : focusedCell.id) === id2 && (focusedCell == null ? void 0 : focusedCell.field) === field) {
      return;
    }
    apiRef.current.setState((state) => {
      logger.debug(`Focusing on cell with id=${id2} and field=${field}`);
      return _extends$2({}, state, {
        tabIndex: {
          cell: {
            id: id2,
            field
          },
          columnHeader: null,
          columnHeaderFilter: null,
          columnGroupHeader: null
        },
        focus: {
          cell: {
            id: id2,
            field
          },
          columnHeader: null,
          columnHeaderFilter: null,
          columnGroupHeader: null
        }
      });
    });
    apiRef.current.forceUpdate();
    if (!apiRef.current.getRow(id2)) {
      return;
    }
    if (focusedCell) {
      publishCellFocusOut(focusedCell, {});
    }
    apiRef.current.publishEvent("cellFocusIn", apiRef.current.getCellParams(id2, field));
  }, [apiRef, logger, publishCellFocusOut]);
  const setColumnHeaderFocus = reactExports.useCallback((field, event = {}) => {
    const cell = gridFocusCellSelector(apiRef);
    publishCellFocusOut(cell, event);
    apiRef.current.setState((state) => {
      logger.debug(`Focusing on column header with colIndex=${field}`);
      return _extends$2({}, state, {
        tabIndex: {
          columnHeader: {
            field
          },
          columnHeaderFilter: null,
          cell: null,
          columnGroupHeader: null
        },
        focus: {
          columnHeader: {
            field
          },
          columnHeaderFilter: null,
          cell: null,
          columnGroupHeader: null
        }
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef, logger, publishCellFocusOut]);
  const setColumnHeaderFilterFocus = reactExports.useCallback((field, event = {}) => {
    const cell = gridFocusCellSelector(apiRef);
    publishCellFocusOut(cell, event);
    apiRef.current.setState((state) => {
      logger.debug(`Focusing on column header filter with colIndex=${field}`);
      return _extends$2({}, state, {
        tabIndex: {
          columnHeader: null,
          columnHeaderFilter: {
            field
          },
          cell: null,
          columnGroupHeader: null
        },
        focus: {
          columnHeader: null,
          columnHeaderFilter: {
            field
          },
          cell: null,
          columnGroupHeader: null
        }
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef, logger, publishCellFocusOut]);
  const setColumnGroupHeaderFocus = reactExports.useCallback((field, depth, event = {}) => {
    const cell = gridFocusCellSelector(apiRef);
    if (cell) {
      apiRef.current.publishEvent("cellFocusOut", apiRef.current.getCellParams(cell.id, cell.field), event);
    }
    apiRef.current.setState((state) => {
      return _extends$2({}, state, {
        tabIndex: {
          columnGroupHeader: {
            field,
            depth
          },
          columnHeader: null,
          columnHeaderFilter: null,
          cell: null
        },
        focus: {
          columnGroupHeader: {
            field,
            depth
          },
          columnHeader: null,
          columnHeaderFilter: null,
          cell: null
        }
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const getColumnGroupHeaderFocus = reactExports.useCallback(() => unstable_gridFocusColumnGroupHeaderSelector(apiRef), [apiRef]);
  const moveFocusToRelativeCell = reactExports.useCallback((id2, field, direction2) => {
    let columnIndexToFocus = apiRef.current.getColumnIndex(field);
    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
    const currentPage = getVisibleRows(apiRef, {
      pagination: props.pagination,
      paginationMode: props.paginationMode
    });
    const pinnedRows = gridPinnedRowsSelector(apiRef);
    const currentPageRows = [].concat(pinnedRows.top || [], currentPage.rows, pinnedRows.bottom || []);
    let rowIndexToFocus = currentPageRows.findIndex((row) => row.id === id2);
    if (direction2 === "right") {
      columnIndexToFocus += 1;
    } else if (direction2 === "left") {
      columnIndexToFocus -= 1;
    } else {
      rowIndexToFocus += 1;
    }
    if (columnIndexToFocus >= visibleColumns.length) {
      rowIndexToFocus += 1;
      if (rowIndexToFocus < currentPageRows.length) {
        columnIndexToFocus = 0;
      }
    } else if (columnIndexToFocus < 0) {
      rowIndexToFocus -= 1;
      if (rowIndexToFocus >= 0) {
        columnIndexToFocus = visibleColumns.length - 1;
      }
    }
    rowIndexToFocus = clamp(rowIndexToFocus, 0, currentPageRows.length - 1);
    const rowToFocus = currentPageRows[rowIndexToFocus];
    if (!rowToFocus) {
      return;
    }
    const colSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowToFocus.id, columnIndexToFocus);
    if (colSpanInfo && colSpanInfo.spannedByColSpan) {
      if (direction2 === "left" || direction2 === "below") {
        columnIndexToFocus = colSpanInfo.leftVisibleCellIndex;
      } else if (direction2 === "right") {
        columnIndexToFocus = colSpanInfo.rightVisibleCellIndex;
      }
    }
    columnIndexToFocus = clamp(columnIndexToFocus, 0, visibleColumns.length - 1);
    const columnToFocus = visibleColumns[columnIndexToFocus];
    apiRef.current.setCellFocus(rowToFocus.id, columnToFocus.field);
  }, [apiRef, props.pagination, props.paginationMode]);
  const handleCellDoubleClick = reactExports.useCallback(({
    id: id2,
    field
  }) => {
    apiRef.current.setCellFocus(id2, field);
  }, [apiRef]);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (event.key === "Enter" || event.key === "Tab" || event.key === "Shift" || isNavigationKey(event.key)) {
      return;
    }
    apiRef.current.setCellFocus(params.id, params.field);
  }, [apiRef]);
  const handleColumnHeaderFocus = reactExports.useCallback(({
    field
  }, event) => {
    if (event.target !== event.currentTarget) {
      return;
    }
    apiRef.current.setColumnHeaderFocus(field, event);
  }, [apiRef]);
  const handleColumnGroupHeaderFocus = reactExports.useCallback(({
    fields,
    depth
  }, event) => {
    if (event.target !== event.currentTarget) {
      return;
    }
    const focusedColumnGroup = unstable_gridFocusColumnGroupHeaderSelector(apiRef);
    if (focusedColumnGroup !== null && focusedColumnGroup.depth === depth && fields.includes(focusedColumnGroup.field)) {
      return;
    }
    apiRef.current.setColumnGroupHeaderFocus(fields[0], depth, event);
  }, [apiRef]);
  const handleBlur = reactExports.useCallback((_2, event) => {
    var _event$relatedTarget;
    if ((_event$relatedTarget = event.relatedTarget) != null && _event$relatedTarget.className.includes(gridClasses.columnHeader)) {
      return;
    }
    logger.debug(`Clearing focus`);
    apiRef.current.setState((state) => _extends$2({}, state, {
      focus: {
        cell: null,
        columnHeader: null,
        columnHeaderFilter: null,
        columnGroupHeader: null
      }
    }));
  }, [logger, apiRef]);
  const handleCellMouseDown = reactExports.useCallback((params) => {
    lastClickedCell.current = params;
  }, []);
  const handleDocumentClick = reactExports.useCallback((event) => {
    const cellParams = lastClickedCell.current;
    lastClickedCell.current = null;
    const focusedCell = gridFocusCellSelector(apiRef);
    const canUpdateFocus = apiRef.current.unstable_applyPipeProcessors("canUpdateFocus", true, {
      event,
      cell: cellParams
    });
    if (!canUpdateFocus) {
      return;
    }
    if (!focusedCell) {
      if (cellParams) {
        apiRef.current.setCellFocus(cellParams.id, cellParams.field);
      }
      return;
    }
    if ((cellParams == null ? void 0 : cellParams.id) === focusedCell.id && (cellParams == null ? void 0 : cellParams.field) === focusedCell.field) {
      return;
    }
    const cellElement = apiRef.current.getCellElement(focusedCell.id, focusedCell.field);
    if (cellElement != null && cellElement.contains(event.target)) {
      return;
    }
    if (cellParams) {
      apiRef.current.setCellFocus(cellParams.id, cellParams.field);
    } else {
      apiRef.current.setState((state) => _extends$2({}, state, {
        focus: {
          cell: null,
          columnHeader: null,
          columnHeaderFilter: null,
          columnGroupHeader: null
        }
      }));
      apiRef.current.forceUpdate();
      publishCellFocusOut(focusedCell, event);
    }
  }, [apiRef, publishCellFocusOut]);
  const handleCellModeChange = reactExports.useCallback((params) => {
    if (params.cellMode === "view") {
      return;
    }
    const cell = gridFocusCellSelector(apiRef);
    if ((cell == null ? void 0 : cell.id) !== params.id || (cell == null ? void 0 : cell.field) !== params.field) {
      apiRef.current.setCellFocus(params.id, params.field);
    }
  }, [apiRef]);
  const handleRowSet = reactExports.useCallback(() => {
    const cell = gridFocusCellSelector(apiRef);
    if (cell && !apiRef.current.getRow(cell.id)) {
      apiRef.current.setState((state) => _extends$2({}, state, {
        focus: {
          cell: null,
          columnHeader: null,
          columnHeaderFilter: null,
          columnGroupHeader: null
        }
      }));
    }
  }, [apiRef]);
  const handlePaginationModelChange = useEventCallback$1(() => {
    const currentFocusedCell = gridFocusCellSelector(apiRef);
    if (!currentFocusedCell) {
      return;
    }
    const currentPage = getVisibleRows(apiRef, {
      pagination: props.pagination,
      paginationMode: props.paginationMode
    });
    const rowIsInCurrentPage = currentPage.rows.find((row) => row.id === currentFocusedCell.id);
    if (rowIsInCurrentPage) {
      return;
    }
    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
    apiRef.current.setState((state) => {
      return _extends$2({}, state, {
        tabIndex: {
          cell: {
            id: currentPage.rows[0].id,
            field: visibleColumns[0].field
          },
          columnGroupHeader: null,
          columnHeader: null,
          columnHeaderFilter: null
        }
      });
    });
  });
  const focusApi = {
    setCellFocus,
    setColumnHeaderFocus,
    setColumnHeaderFilterFocus
  };
  const focusPrivateApi = {
    moveFocusToRelativeCell,
    setColumnGroupHeaderFocus,
    getColumnGroupHeaderFocus
  };
  useGridApiMethod(apiRef, focusApi, "public");
  useGridApiMethod(apiRef, focusPrivateApi, "private");
  reactExports.useEffect(() => {
    const doc = ownerDocument(apiRef.current.rootElementRef.current);
    doc.addEventListener("mouseup", handleDocumentClick);
    return () => {
      doc.removeEventListener("mouseup", handleDocumentClick);
    };
  }, [apiRef, handleDocumentClick]);
  useGridApiEventHandler(apiRef, "columnHeaderBlur", handleBlur);
  useGridApiEventHandler(apiRef, "cellDoubleClick", handleCellDoubleClick);
  useGridApiEventHandler(apiRef, "cellMouseDown", handleCellMouseDown);
  useGridApiEventHandler(apiRef, "cellKeyDown", handleCellKeyDown);
  useGridApiEventHandler(apiRef, "cellModeChange", handleCellModeChange);
  useGridApiEventHandler(apiRef, "columnHeaderFocus", handleColumnHeaderFocus);
  useGridApiEventHandler(apiRef, "columnGroupHeaderFocus", handleColumnGroupHeaderFocus);
  useGridApiEventHandler(apiRef, "rowsSet", handleRowSet);
  useGridApiEventHandler(apiRef, "paginationModelChange", handlePaginationModelChange);
};
function enrichPageRowsWithPinnedRows(apiRef, rows2) {
  const pinnedRows = gridPinnedRowsSelector(apiRef) || {};
  return [...pinnedRows.top || [], ...rows2, ...pinnedRows.bottom || []];
}
const getLeftColumnIndex = ({
  currentColIndex,
  firstColIndex,
  lastColIndex,
  direction: direction2
}) => {
  if (direction2 === "rtl") {
    if (currentColIndex < lastColIndex) {
      return currentColIndex + 1;
    }
  } else if (direction2 === "ltr") {
    if (currentColIndex > firstColIndex) {
      return currentColIndex - 1;
    }
  }
  return null;
};
const getRightColumnIndex = ({
  currentColIndex,
  firstColIndex,
  lastColIndex,
  direction: direction2
}) => {
  if (direction2 === "rtl") {
    if (currentColIndex > firstColIndex) {
      return currentColIndex - 1;
    }
  } else if (direction2 === "ltr") {
    if (currentColIndex < lastColIndex) {
      return currentColIndex + 1;
    }
  }
  return null;
};
const useGridKeyboardNavigation = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridKeyboardNavigation");
  const initialCurrentPageRows = useGridVisibleRows(apiRef, props).rows;
  const theme2 = useTheme();
  const currentPageRows = reactExports.useMemo(() => enrichPageRowsWithPinnedRows(apiRef, initialCurrentPageRows), [apiRef, initialCurrentPageRows]);
  const headerFilteringEnabled = (
    // @ts-expect-error // TODO move relevant code to the `DataGridPro`
    props.signature !== "DataGrid" && props.unstable_headerFilters
  );
  const goToCell = reactExports.useCallback((colIndex, rowId, closestColumnToUse = "left") => {
    const visibleSortedRows = gridExpandedSortedRowEntriesSelector(apiRef);
    const nextCellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, colIndex);
    if (nextCellColSpanInfo && nextCellColSpanInfo.spannedByColSpan) {
      if (closestColumnToUse === "left") {
        colIndex = nextCellColSpanInfo.leftVisibleCellIndex;
      } else if (closestColumnToUse === "right") {
        colIndex = nextCellColSpanInfo.rightVisibleCellIndex;
      }
    }
    const rowIndexRelativeToAllRows = visibleSortedRows.findIndex((row) => row.id === rowId);
    logger.debug(`Navigating to cell row ${rowIndexRelativeToAllRows}, col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex,
      rowIndex: rowIndexRelativeToAllRows
    });
    const field = apiRef.current.getVisibleColumns()[colIndex].field;
    apiRef.current.setCellFocus(rowId, field);
  }, [apiRef, logger]);
  const goToHeader = reactExports.useCallback((colIndex, event) => {
    logger.debug(`Navigating to header col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex
    });
    const field = apiRef.current.getVisibleColumns()[colIndex].field;
    apiRef.current.setColumnHeaderFocus(field, event);
  }, [apiRef, logger]);
  const goToHeaderFilter = reactExports.useCallback((colIndex, event) => {
    logger.debug(`Navigating to header filter col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex
    });
    const field = apiRef.current.getVisibleColumns()[colIndex].field;
    apiRef.current.setColumnHeaderFilterFocus(field, event);
  }, [apiRef, logger]);
  const goToGroupHeader = reactExports.useCallback((colIndex, depth, event) => {
    logger.debug(`Navigating to header col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex
    });
    const {
      field
    } = apiRef.current.getVisibleColumns()[colIndex];
    apiRef.current.setColumnGroupHeaderFocus(field, depth, event);
  }, [apiRef, logger]);
  const getRowIdFromIndex = reactExports.useCallback((rowIndex) => {
    var _currentPageRows$rowI;
    return (_currentPageRows$rowI = currentPageRows[rowIndex]) == null ? void 0 : _currentPageRows$rowI.id;
  }, [currentPageRows]);
  const handleColumnHeaderKeyDown = reactExports.useCallback((params, event) => {
    const headerTitleNode = event.currentTarget.querySelector(`.${gridClasses.columnHeaderTitleContainerContent}`);
    const isFromInsideContent = !!headerTitleNode && headerTitleNode.contains(event.target);
    if (isFromInsideContent && params.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field) {
      return;
    }
    const dimensions = apiRef.current.getRootDimensions();
    if (!dimensions) {
      return;
    }
    const viewportPageSize = apiRef.current.getViewportPageSize();
    const colIndexBefore = params.field ? apiRef.current.getColumnIndex(params.field) : 0;
    const firstRowIndexInPage = currentPageRows.length > 0 ? 0 : null;
    const lastRowIndexInPage = currentPageRows.length - 1;
    const firstColIndex = 0;
    const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;
    const columnGroupMaxDepth = gridColumnGroupsHeaderMaxDepthSelector(apiRef);
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown": {
        if (firstRowIndexInPage !== null) {
          if (headerFilteringEnabled) {
            goToHeaderFilter(colIndexBefore, event);
          } else {
            goToCell(colIndexBefore, getRowIdFromIndex(firstRowIndexInPage));
          }
        }
        break;
      }
      case "ArrowRight": {
        const rightColIndex = getRightColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          direction: theme2.direction
        });
        if (rightColIndex !== null) {
          goToHeader(rightColIndex, event);
        }
        break;
      }
      case "ArrowLeft": {
        const leftColIndex = getLeftColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          direction: theme2.direction
        });
        if (leftColIndex !== null) {
          goToHeader(leftColIndex, event);
        }
        break;
      }
      case "ArrowUp": {
        if (columnGroupMaxDepth > 0) {
          goToGroupHeader(colIndexBefore, columnGroupMaxDepth - 1, event);
        }
        break;
      }
      case "PageDown": {
        if (firstRowIndexInPage !== null && lastRowIndexInPage !== null) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "Home": {
        goToHeader(firstColIndex, event);
        break;
      }
      case "End": {
        goToHeader(lastColIndex, event);
        break;
      }
      case "Enter": {
        if (event.ctrlKey || event.metaKey) {
          apiRef.current.toggleColumnMenu(params.field);
        }
        break;
      }
      case " ": {
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPageRows.length, headerFilteringEnabled, goToHeaderFilter, goToCell, getRowIdFromIndex, theme2.direction, goToHeader, goToGroupHeader]);
  const handleHeaderFilterKeyDown = reactExports.useCallback((params, event) => {
    const dimensions = apiRef.current.getRootDimensions();
    if (!dimensions) {
      return;
    }
    const isEditing = unstable_gridHeaderFilteringEditFieldSelector(apiRef) === params.field;
    const isHeaderMenuOpen = unstable_gridHeaderFilteringMenuSelector(apiRef) === params.field;
    if (isEditing || isHeaderMenuOpen || !isNavigationKey(event.key)) {
      return;
    }
    const viewportPageSize = apiRef.current.getViewportPageSize();
    const colIndexBefore = params.field ? apiRef.current.getColumnIndex(params.field) : 0;
    const firstRowIndexInPage = 0;
    const lastRowIndexInPage = currentPageRows.length - 1;
    const firstColIndex = 0;
    const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown": {
        const rowId = getRowIdFromIndex(firstRowIndexInPage);
        if (rowId != null) {
          goToCell(colIndexBefore, rowId);
        }
        break;
      }
      case "ArrowRight": {
        const rightColIndex = getRightColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          direction: theme2.direction
        });
        if (rightColIndex !== null) {
          goToHeaderFilter(rightColIndex, event);
        }
        break;
      }
      case "ArrowLeft": {
        const leftColIndex = getLeftColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          direction: theme2.direction
        });
        if (leftColIndex !== null) {
          goToHeaderFilter(leftColIndex, event);
        } else {
          apiRef.current.setColumnHeaderFilterFocus(params.field, event);
        }
        break;
      }
      case "ArrowUp": {
        goToHeader(colIndexBefore, event);
        break;
      }
      case "PageDown": {
        if (lastRowIndexInPage !== null) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "Home": {
        goToHeaderFilter(firstColIndex, event);
        break;
      }
      case "End": {
        goToHeaderFilter(lastColIndex, event);
        break;
      }
      case " ": {
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPageRows.length, goToHeaderFilter, theme2.direction, goToHeader, goToCell, getRowIdFromIndex]);
  const handleColumnGroupHeaderKeyDown = reactExports.useCallback((params, event) => {
    const dimensions = apiRef.current.getRootDimensions();
    if (!dimensions) {
      return;
    }
    const focusedColumnGroup = unstable_gridFocusColumnGroupHeaderSelector(apiRef);
    if (focusedColumnGroup === null) {
      return;
    }
    const {
      field: currentField,
      depth: currentDepth
    } = focusedColumnGroup;
    const {
      fields,
      depth,
      maxDepth
    } = params;
    const viewportPageSize = apiRef.current.getViewportPageSize();
    const currentColIndex = apiRef.current.getColumnIndex(currentField);
    const colIndexBefore = currentField ? apiRef.current.getColumnIndex(currentField) : 0;
    const firstRowIndexInPage = 0;
    const lastRowIndexInPage = currentPageRows.length - 1;
    const firstColIndex = 0;
    const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown": {
        if (depth === maxDepth - 1) {
          goToHeader(currentColIndex, event);
        } else {
          goToGroupHeader(currentColIndex, currentDepth + 1, event);
        }
        break;
      }
      case "ArrowUp": {
        if (depth > 0) {
          goToGroupHeader(currentColIndex, currentDepth - 1, event);
        }
        break;
      }
      case "ArrowRight": {
        const remainingRightColumns = fields.length - fields.indexOf(currentField) - 1;
        if (currentColIndex + remainingRightColumns + 1 <= lastColIndex) {
          goToGroupHeader(currentColIndex + remainingRightColumns + 1, currentDepth, event);
        }
        break;
      }
      case "ArrowLeft": {
        const remainingLeftColumns = fields.indexOf(currentField);
        if (currentColIndex - remainingLeftColumns - 1 >= firstColIndex) {
          goToGroupHeader(currentColIndex - remainingLeftColumns - 1, currentDepth, event);
        }
        break;
      }
      case "PageDown": {
        if (lastRowIndexInPage !== null) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "Home": {
        goToGroupHeader(firstColIndex, currentDepth, event);
        break;
      }
      case "End": {
        goToGroupHeader(lastColIndex, currentDepth, event);
        break;
      }
      case " ": {
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPageRows.length, goToHeader, goToGroupHeader, goToCell, getRowIdFromIndex]);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    const cellParams = apiRef.current.getCellParams(params.id, params.field);
    if (cellParams.cellMode === GridCellModes.Edit || !isNavigationKey(event.key)) {
      return;
    }
    const canUpdateFocus = apiRef.current.unstable_applyPipeProcessors("canUpdateFocus", true, {
      event,
      cell: cellParams
    });
    if (!canUpdateFocus) {
      return;
    }
    const dimensions = apiRef.current.getRootDimensions();
    if (currentPageRows.length === 0 || !dimensions) {
      return;
    }
    const direction2 = theme2.direction;
    const viewportPageSize = apiRef.current.getViewportPageSize();
    const colIndexBefore = params.field ? apiRef.current.getColumnIndex(params.field) : 0;
    const rowIndexBefore = currentPageRows.findIndex((row) => row.id === params.id);
    const firstRowIndexInPage = 0;
    const lastRowIndexInPage = currentPageRows.length - 1;
    const firstColIndex = 0;
    const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown": {
        if (rowIndexBefore < lastRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(rowIndexBefore + 1));
        }
        break;
      }
      case "ArrowUp": {
        if (rowIndexBefore > firstRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(rowIndexBefore - 1));
        } else if (headerFilteringEnabled) {
          goToHeaderFilter(colIndexBefore, event);
        } else {
          goToHeader(colIndexBefore, event);
        }
        break;
      }
      case "ArrowRight": {
        const rightColIndex = getRightColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          direction: direction2
        });
        if (rightColIndex !== null) {
          goToCell(rightColIndex, getRowIdFromIndex(rowIndexBefore), direction2 === "rtl" ? "left" : "right");
        }
        break;
      }
      case "ArrowLeft": {
        const leftColIndex = getLeftColumnIndex({
          currentColIndex: colIndexBefore,
          firstColIndex,
          lastColIndex,
          direction: direction2
        });
        if (leftColIndex !== null) {
          goToCell(leftColIndex, getRowIdFromIndex(rowIndexBefore), direction2 === "rtl" ? "right" : "left");
        }
        break;
      }
      case "Tab": {
        if (event.shiftKey && colIndexBefore > firstColIndex) {
          goToCell(colIndexBefore - 1, getRowIdFromIndex(rowIndexBefore), "left");
        } else if (!event.shiftKey && colIndexBefore < lastColIndex) {
          goToCell(colIndexBefore + 1, getRowIdFromIndex(rowIndexBefore), "right");
        }
        break;
      }
      case " ": {
        const field = params.field;
        if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
          break;
        }
        const colDef = params.colDef;
        if (colDef && colDef.type === "treeDataGroup") {
          break;
        }
        if (!event.shiftKey && rowIndexBefore < lastRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(rowIndexBefore + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "PageDown": {
        if (rowIndexBefore < lastRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(Math.min(rowIndexBefore + viewportPageSize, lastRowIndexInPage)));
        }
        break;
      }
      case "PageUp": {
        const nextRowIndex = Math.max(rowIndexBefore - viewportPageSize, firstRowIndexInPage);
        if (nextRowIndex !== rowIndexBefore && nextRowIndex >= firstRowIndexInPage) {
          goToCell(colIndexBefore, getRowIdFromIndex(nextRowIndex));
        } else {
          goToHeader(colIndexBefore, event);
        }
        break;
      }
      case "Home": {
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          goToCell(firstColIndex, getRowIdFromIndex(firstRowIndexInPage));
        } else {
          goToCell(firstColIndex, getRowIdFromIndex(rowIndexBefore));
        }
        break;
      }
      case "End": {
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          goToCell(lastColIndex, getRowIdFromIndex(lastRowIndexInPage));
        } else {
          goToCell(lastColIndex, getRowIdFromIndex(rowIndexBefore));
        }
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPageRows, theme2.direction, goToCell, getRowIdFromIndex, headerFilteringEnabled, goToHeaderFilter, goToHeader]);
  const checkIfCanStartEditing = reactExports.useCallback((initialValue, {
    event
  }) => {
    if (event.key === " ") {
      return false;
    }
    return initialValue;
  }, []);
  useGridRegisterPipeProcessor(apiRef, "canStartEditing", checkIfCanStartEditing);
  useGridApiEventHandler(apiRef, "columnHeaderKeyDown", handleColumnHeaderKeyDown);
  useGridApiEventHandler(apiRef, "headerFilterKeyDown", handleHeaderFilterKeyDown);
  useGridApiEventHandler(apiRef, "columnGroupHeaderKeyDown", handleColumnGroupHeaderKeyDown);
  useGridApiEventHandler(apiRef, "cellKeyDown", handleCellKeyDown);
};
const preferencePanelStateInitializer = (state, props) => {
  var _props$initialState$p, _props$initialState;
  return _extends$2({}, state, {
    preferencePanel: (_props$initialState$p = (_props$initialState = props.initialState) == null ? void 0 : _props$initialState.preferencePanel) != null ? _props$initialState$p : {
      open: false
    }
  });
};
const useGridPreferencesPanel = (apiRef, props) => {
  var _props$initialState3;
  const logger = useGridLogger(apiRef, "useGridPreferencesPanel");
  const hideTimeout = reactExports.useRef();
  const immediateTimeout = reactExports.useRef();
  const hidePreferences = reactExports.useCallback(() => {
    logger.debug("Hiding Preferences Panel");
    const preferencePanelState = gridPreferencePanelStateSelector(apiRef.current.state);
    if (preferencePanelState.openedPanelValue) {
      apiRef.current.publishEvent("preferencePanelClose", {
        openedPanelValue: preferencePanelState.openedPanelValue
      });
    }
    apiRef.current.setState((state) => _extends$2({}, state, {
      preferencePanel: {
        open: false
      }
    }));
    apiRef.current.forceUpdate();
  }, [apiRef, logger]);
  const doNotHidePanel = reactExports.useCallback(() => {
    immediateTimeout.current = setTimeout(() => clearTimeout(hideTimeout.current), 0);
  }, []);
  const hidePreferencesDelayed = reactExports.useCallback(() => {
    hideTimeout.current = setTimeout(hidePreferences, 100);
  }, [hidePreferences]);
  const showPreferences = reactExports.useCallback((newValue, panelId, labelId) => {
    logger.debug("Opening Preferences Panel");
    doNotHidePanel();
    apiRef.current.setState((state) => _extends$2({}, state, {
      preferencePanel: _extends$2({}, state.preferencePanel, {
        open: true,
        openedPanelValue: newValue,
        panelId,
        labelId
      })
    }));
    apiRef.current.publishEvent("preferencePanelOpen", {
      openedPanelValue: newValue
    });
    apiRef.current.forceUpdate();
  }, [logger, doNotHidePanel, apiRef]);
  useGridApiMethod(apiRef, {
    showPreferences,
    hidePreferences: hidePreferencesDelayed
  }, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _props$initialState2;
    const preferencePanelToExport = gridPreferencePanelStateSelector(apiRef.current.state);
    const shouldExportPreferencePanel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the panel was initialized
      ((_props$initialState2 = props.initialState) == null ? void 0 : _props$initialState2.preferencePanel) != null || // Always export if the panel is opened
      preferencePanelToExport.open
    );
    if (!shouldExportPreferencePanel) {
      return prevState;
    }
    return _extends$2({}, prevState, {
      preferencePanel: preferencePanelToExport
    });
  }, [apiRef, (_props$initialState3 = props.initialState) == null ? void 0 : _props$initialState3.preferencePanel]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    const preferencePanel = context.stateToRestore.preferencePanel;
    if (preferencePanel != null) {
      apiRef.current.setState((state) => _extends$2({}, state, {
        preferencePanel
      }));
    }
    return params;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(hideTimeout.current);
      clearTimeout(immediateTimeout.current);
    };
  }, []);
};
const _excluded$y = ["id", "field"], _excluded2$8 = ["id", "field"];
const missingOnProcessRowUpdateErrorWarning$1 = buildWarning$1(["MUI: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.", "To handle the error pass a callback to the `onProcessRowUpdateError` prop, e.g. `<DataGrid onProcessRowUpdateError={(error) => ...} />`.", "For more detail, see http://mui.com/components/data-grid/editing/#server-side-persistence."], "error");
const useGridCellEditing = (apiRef, props) => {
  const [cellModesModel, setCellModesModel] = reactExports.useState({});
  const cellModesModelRef = reactExports.useRef(cellModesModel);
  const prevCellModesModel = reactExports.useRef({});
  const {
    processRowUpdate,
    onProcessRowUpdateError,
    cellModesModel: cellModesModelProp,
    onCellModesModelChange
  } = props;
  const runIfEditModeIsCell = (callback) => (...args) => {
    if (props.editMode === GridEditModes.Cell) {
      callback(...args);
    }
  };
  const throwIfNotEditable = reactExports.useCallback((id2, field) => {
    const params = apiRef.current.getCellParams(id2, field);
    if (!apiRef.current.isCellEditable(params)) {
      throw new Error(`MUI: The cell with id=${id2} and field=${field} is not editable.`);
    }
  }, [apiRef]);
  const throwIfNotInMode = reactExports.useCallback((id2, field, mode) => {
    if (apiRef.current.getCellMode(id2, field) !== mode) {
      throw new Error(`MUI: The cell with id=${id2} and field=${field} is not in ${mode} mode.`);
    }
  }, [apiRef]);
  const handleCellDoubleClick = reactExports.useCallback((params, event) => {
    if (!params.isEditable) {
      return;
    }
    if (params.cellMode === GridCellModes.Edit) {
      return;
    }
    const newParams = _extends$2({}, params, {
      reason: GridCellEditStartReasons.cellDoubleClick
    });
    apiRef.current.publishEvent("cellEditStart", newParams, event);
  }, [apiRef]);
  const handleCellFocusOut = reactExports.useCallback((params, event) => {
    if (params.cellMode === GridCellModes.View) {
      return;
    }
    if (apiRef.current.getCellMode(params.id, params.field) === GridCellModes.View) {
      return;
    }
    const newParams = _extends$2({}, params, {
      reason: GridCellEditStopReasons.cellFocusOut
    });
    apiRef.current.publishEvent("cellEditStop", newParams, event);
  }, [apiRef]);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (params.cellMode === GridCellModes.Edit) {
      if (event.which === 229) {
        return;
      }
      let reason;
      if (event.key === "Escape") {
        reason = GridCellEditStopReasons.escapeKeyDown;
      } else if (event.key === "Enter") {
        reason = GridCellEditStopReasons.enterKeyDown;
      } else if (event.key === "Tab") {
        reason = event.shiftKey ? GridCellEditStopReasons.shiftTabKeyDown : GridCellEditStopReasons.tabKeyDown;
        event.preventDefault();
      }
      if (reason) {
        const newParams = _extends$2({}, params, {
          reason
        });
        apiRef.current.publishEvent("cellEditStop", newParams, event);
      }
    } else if (params.isEditable) {
      let reason;
      const canStartEditing = apiRef.current.unstable_applyPipeProcessors("canStartEditing", true, {
        event,
        cellParams: params,
        editMode: "cell"
      });
      if (!canStartEditing) {
        return;
      }
      if (isPrintableKey(event)) {
        reason = GridCellEditStartReasons.printableKeyDown;
      } else if ((event.ctrlKey || event.metaKey) && event.key === "v") {
        reason = GridCellEditStartReasons.printableKeyDown;
      } else if (event.key === "Enter") {
        reason = GridCellEditStartReasons.enterKeyDown;
      } else if (event.key === "Delete" || event.key === "Backspace") {
        reason = GridCellEditStartReasons.deleteKeyDown;
      }
      if (reason) {
        const newParams = _extends$2({}, params, {
          reason,
          key: event.key
        });
        apiRef.current.publishEvent("cellEditStart", newParams, event);
      }
    }
  }, [apiRef]);
  const handleCellEditStart = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      reason,
      key,
      colDef
    } = params;
    const startCellEditModeParams = {
      id: id2,
      field
    };
    if (reason === GridCellEditStartReasons.printableKeyDown) {
      if (reactExports.version.startsWith("17")) {
        startCellEditModeParams.deleteValue = true;
      } else {
        const initialValue = colDef.valueParser ? colDef.valueParser(key) : key;
        startCellEditModeParams.initialValue = initialValue;
      }
    } else if (reason === GridCellEditStartReasons.deleteKeyDown) {
      startCellEditModeParams.deleteValue = true;
    }
    apiRef.current.startCellEditMode(startCellEditModeParams);
  }, [apiRef]);
  const handleCellEditStop = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      reason
    } = params;
    apiRef.current.runPendingEditCellValueMutation(id2, field);
    let cellToFocusAfter;
    if (reason === GridCellEditStopReasons.enterKeyDown) {
      cellToFocusAfter = "below";
    } else if (reason === GridCellEditStopReasons.tabKeyDown) {
      cellToFocusAfter = "right";
    } else if (reason === GridCellEditStopReasons.shiftTabKeyDown) {
      cellToFocusAfter = "left";
    }
    const ignoreModifications = reason === "escapeKeyDown";
    apiRef.current.stopCellEditMode({
      id: id2,
      field,
      ignoreModifications,
      cellToFocusAfter
    });
  }, [apiRef]);
  useGridApiEventHandler(apiRef, "cellDoubleClick", runIfEditModeIsCell(handleCellDoubleClick));
  useGridApiEventHandler(apiRef, "cellFocusOut", runIfEditModeIsCell(handleCellFocusOut));
  useGridApiEventHandler(apiRef, "cellKeyDown", runIfEditModeIsCell(handleCellKeyDown));
  useGridApiEventHandler(apiRef, "cellEditStart", runIfEditModeIsCell(handleCellEditStart));
  useGridApiEventHandler(apiRef, "cellEditStop", runIfEditModeIsCell(handleCellEditStop));
  useGridApiOptionHandler(apiRef, "cellEditStart", props.onCellEditStart);
  useGridApiOptionHandler(apiRef, "cellEditStop", props.onCellEditStop);
  const getCellMode = reactExports.useCallback((id2, field) => {
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const isEditing = editingState[id2] && editingState[id2][field];
    return isEditing ? GridCellModes.Edit : GridCellModes.View;
  }, [apiRef]);
  const updateCellModesModel = useEventCallback$1((newModel) => {
    const isNewModelDifferentFromProp = newModel !== props.cellModesModel;
    if (onCellModesModelChange && isNewModelDifferentFromProp) {
      onCellModesModelChange(newModel, {});
    }
    if (props.cellModesModel && isNewModelDifferentFromProp) {
      return;
    }
    setCellModesModel(newModel);
    cellModesModelRef.current = newModel;
    apiRef.current.publishEvent("cellModesModelChange", newModel);
  });
  const updateFieldInCellModesModel = reactExports.useCallback((id2, field, newProps) => {
    const newModel = _extends$2({}, cellModesModelRef.current);
    if (newProps !== null) {
      newModel[id2] = _extends$2({}, newModel[id2], {
        [field]: _extends$2({}, newProps)
      });
    } else {
      const _newModel$id = newModel[id2], otherFields = _objectWithoutPropertiesLoose$1(_newModel$id, [field].map(_toPropertyKey$1));
      newModel[id2] = otherFields;
      if (Object.keys(newModel[id2]).length === 0) {
        delete newModel[id2];
      }
    }
    updateCellModesModel(newModel);
  }, [updateCellModesModel]);
  const updateOrDeleteFieldState = reactExports.useCallback((id2, field, newProps) => {
    apiRef.current.setState((state) => {
      const newEditingState = _extends$2({}, state.editRows);
      if (newProps !== null) {
        newEditingState[id2] = _extends$2({}, newEditingState[id2], {
          [field]: _extends$2({}, newProps)
        });
      } else {
        delete newEditingState[id2][field];
        if (Object.keys(newEditingState[id2]).length === 0) {
          delete newEditingState[id2];
        }
      }
      return _extends$2({}, state, {
        editRows: newEditingState
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const startCellEditMode = reactExports.useCallback((params) => {
    const {
      id: id2,
      field
    } = params, other = _objectWithoutPropertiesLoose$1(params, _excluded$y);
    throwIfNotEditable(id2, field);
    throwIfNotInMode(id2, field, GridCellModes.View);
    updateFieldInCellModesModel(id2, field, _extends$2({
      mode: GridCellModes.Edit
    }, other));
  }, [throwIfNotEditable, throwIfNotInMode, updateFieldInCellModesModel]);
  const updateStateToStartCellEditMode = useEventCallback$1((params) => {
    const {
      id: id2,
      field,
      deleteValue,
      initialValue
    } = params;
    let newValue = apiRef.current.getCellValue(id2, field);
    let unstable_updateValueOnRender = false;
    if (deleteValue || initialValue) {
      newValue = deleteValue ? "" : initialValue;
      unstable_updateValueOnRender = true;
    }
    const newProps = {
      value: newValue,
      error: false,
      isProcessingProps: false,
      unstable_updateValueOnRender
    };
    updateOrDeleteFieldState(id2, field, newProps);
    apiRef.current.setCellFocus(id2, field);
  });
  const stopCellEditMode = reactExports.useCallback((params) => {
    const {
      id: id2,
      field
    } = params, other = _objectWithoutPropertiesLoose$1(params, _excluded2$8);
    throwIfNotInMode(id2, field, GridCellModes.Edit);
    updateFieldInCellModesModel(id2, field, _extends$2({
      mode: GridCellModes.View
    }, other));
  }, [throwIfNotInMode, updateFieldInCellModesModel]);
  const updateStateToStopCellEditMode = useEventCallback$1(async (params) => {
    const {
      id: id2,
      field,
      ignoreModifications,
      cellToFocusAfter = "none"
    } = params;
    throwIfNotInMode(id2, field, GridCellModes.Edit);
    apiRef.current.runPendingEditCellValueMutation(id2, field);
    const finishCellEditMode = () => {
      updateOrDeleteFieldState(id2, field, null);
      updateFieldInCellModesModel(id2, field, null);
      if (cellToFocusAfter !== "none") {
        apiRef.current.moveFocusToRelativeCell(id2, field, cellToFocusAfter);
      }
    };
    if (ignoreModifications) {
      finishCellEditMode();
      return;
    }
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const {
      error,
      isProcessingProps
    } = editingState[id2][field];
    if (error || isProcessingProps) {
      prevCellModesModel.current[id2][field].mode = GridCellModes.Edit;
      updateFieldInCellModesModel(id2, field, {
        mode: GridCellModes.Edit
      });
      return;
    }
    const rowUpdate = apiRef.current.getRowWithUpdatedValuesFromCellEditing(id2, field);
    if (processRowUpdate) {
      const handleError = (errorThrown) => {
        prevCellModesModel.current[id2][field].mode = GridCellModes.Edit;
        updateFieldInCellModesModel(id2, field, {
          mode: GridCellModes.Edit
        });
        if (onProcessRowUpdateError) {
          onProcessRowUpdateError(errorThrown);
        } else {
          missingOnProcessRowUpdateErrorWarning$1();
        }
      };
      try {
        const row = apiRef.current.getRow(id2);
        Promise.resolve(processRowUpdate(rowUpdate, row)).then((finalRowUpdate) => {
          apiRef.current.updateRows([finalRowUpdate]);
          finishCellEditMode();
        }).catch(handleError);
      } catch (errorThrown) {
        handleError(errorThrown);
      }
    } else {
      apiRef.current.updateRows([rowUpdate]);
      finishCellEditMode();
    }
  });
  const setCellEditingEditCellValue = reactExports.useCallback(async (params) => {
    var _editingState$id;
    const {
      id: id2,
      field,
      value,
      debounceMs,
      unstable_skipValueParser: skipValueParser
    } = params;
    throwIfNotEditable(id2, field);
    throwIfNotInMode(id2, field, GridCellModes.Edit);
    const column2 = apiRef.current.getColumn(field);
    const row = apiRef.current.getRow(id2);
    let parsedValue = value;
    if (column2.valueParser && !skipValueParser) {
      parsedValue = column2.valueParser(value, apiRef.current.getCellParams(id2, field));
    }
    let editingState = gridEditRowsStateSelector(apiRef.current.state);
    let newProps = _extends$2({}, editingState[id2][field], {
      value: parsedValue,
      changeReason: debounceMs ? "debouncedSetEditCellValue" : "setEditCellValue"
    });
    if (column2.preProcessEditCellProps) {
      const hasChanged = value !== editingState[id2][field].value;
      newProps = _extends$2({}, newProps, {
        isProcessingProps: true
      });
      updateOrDeleteFieldState(id2, field, newProps);
      newProps = await Promise.resolve(column2.preProcessEditCellProps({
        id: id2,
        row,
        props: newProps,
        hasChanged
      }));
    }
    if (apiRef.current.getCellMode(id2, field) === GridCellModes.View) {
      return false;
    }
    editingState = gridEditRowsStateSelector(apiRef.current.state);
    newProps = _extends$2({}, newProps, {
      isProcessingProps: false
    });
    newProps.value = column2.preProcessEditCellProps ? editingState[id2][field].value : parsedValue;
    updateOrDeleteFieldState(id2, field, newProps);
    editingState = gridEditRowsStateSelector(apiRef.current.state);
    return !((_editingState$id = editingState[id2]) != null && (_editingState$id = _editingState$id[field]) != null && _editingState$id.error);
  }, [apiRef, throwIfNotEditable, throwIfNotInMode, updateOrDeleteFieldState]);
  const getRowWithUpdatedValuesFromCellEditing = reactExports.useCallback((id2, field) => {
    const column2 = apiRef.current.getColumn(field);
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const row = apiRef.current.getRow(id2);
    if (!editingState[id2] || !editingState[id2][field]) {
      return apiRef.current.getRow(id2);
    }
    const {
      value
    } = editingState[id2][field];
    return column2.valueSetter ? column2.valueSetter({
      value,
      row
    }) : _extends$2({}, row, {
      [field]: value
    });
  }, [apiRef]);
  const editingApi = {
    getCellMode,
    startCellEditMode,
    stopCellEditMode
  };
  const editingPrivateApi = {
    setCellEditingEditCellValue,
    getRowWithUpdatedValuesFromCellEditing
  };
  useGridApiMethod(apiRef, editingApi, "public");
  useGridApiMethod(apiRef, editingPrivateApi, "private");
  reactExports.useEffect(() => {
    if (cellModesModelProp) {
      updateCellModesModel(cellModesModelProp);
    }
  }, [cellModesModelProp, updateCellModesModel]);
  reactExports.useEffect(() => {
    const idToIdLookup = gridRowsDataRowIdToIdLookupSelector(apiRef);
    const copyOfPrevCellModes = prevCellModesModel.current;
    prevCellModesModel.current = deepClone(cellModesModel);
    Object.entries(cellModesModel).forEach(([id2, fields]) => {
      Object.entries(fields).forEach(([field, params]) => {
        var _copyOfPrevCellModes$, _idToIdLookup$id;
        const prevMode = ((_copyOfPrevCellModes$ = copyOfPrevCellModes[id2]) == null || (_copyOfPrevCellModes$ = _copyOfPrevCellModes$[field]) == null ? void 0 : _copyOfPrevCellModes$.mode) || GridCellModes.View;
        const originalId = (_idToIdLookup$id = idToIdLookup[id2]) != null ? _idToIdLookup$id : id2;
        if (params.mode === GridCellModes.Edit && prevMode === GridCellModes.View) {
          updateStateToStartCellEditMode(_extends$2({
            id: originalId,
            field
          }, params));
        } else if (params.mode === GridCellModes.View && prevMode === GridCellModes.Edit) {
          updateStateToStopCellEditMode(_extends$2({
            id: originalId,
            field
          }, params));
        }
      });
    });
  }, [apiRef, cellModesModel, updateStateToStartCellEditMode, updateStateToStopCellEditMode]);
};
const _excluded$x = ["id"], _excluded2$7 = ["id"];
const missingOnProcessRowUpdateErrorWarning = buildWarning$1(["MUI: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.", "To handle the error pass a callback to the `onProcessRowUpdateError` prop, e.g. `<DataGrid onProcessRowUpdateError={(error) => ...} />`.", "For more detail, see http://mui.com/components/data-grid/editing/#server-side-persistence."], "error");
const useGridRowEditing = (apiRef, props) => {
  const [rowModesModel, setRowModesModel] = reactExports.useState({});
  const rowModesModelRef = reactExports.useRef(rowModesModel);
  const prevRowModesModel = reactExports.useRef({});
  const focusTimeout = reactExports.useRef(null);
  const nextFocusedCell = reactExports.useRef(null);
  const {
    processRowUpdate,
    onProcessRowUpdateError,
    rowModesModel: rowModesModelProp,
    onRowModesModelChange
  } = props;
  const runIfEditModeIsRow = (callback) => (...args) => {
    if (props.editMode === GridEditModes.Row) {
      callback(...args);
    }
  };
  const throwIfNotEditable = reactExports.useCallback((id2, field) => {
    const params = apiRef.current.getCellParams(id2, field);
    if (!apiRef.current.isCellEditable(params)) {
      throw new Error(`MUI: The cell with id=${id2} and field=${field} is not editable.`);
    }
  }, [apiRef]);
  const throwIfNotInMode = reactExports.useCallback((id2, mode) => {
    if (apiRef.current.getRowMode(id2) !== mode) {
      throw new Error(`MUI: The row with id=${id2} is not in ${mode} mode.`);
    }
  }, [apiRef]);
  const handleCellDoubleClick = reactExports.useCallback((params, event) => {
    if (!params.isEditable) {
      return;
    }
    if (apiRef.current.getRowMode(params.id) === GridRowModes.Edit) {
      return;
    }
    const rowParams = apiRef.current.getRowParams(params.id);
    const newParams = _extends$2({}, rowParams, {
      field: params.field,
      reason: GridRowEditStartReasons.cellDoubleClick
    });
    apiRef.current.publishEvent("rowEditStart", newParams, event);
  }, [apiRef]);
  const handleCellFocusIn = reactExports.useCallback((params) => {
    nextFocusedCell.current = params;
  }, []);
  const handleCellFocusOut = reactExports.useCallback((params, event) => {
    if (!params.isEditable) {
      return;
    }
    if (apiRef.current.getRowMode(params.id) === GridRowModes.View) {
      return;
    }
    nextFocusedCell.current = null;
    focusTimeout.current = setTimeout(() => {
      var _nextFocusedCell$curr;
      focusTimeout.current = null;
      if (((_nextFocusedCell$curr = nextFocusedCell.current) == null ? void 0 : _nextFocusedCell$curr.id) !== params.id) {
        if (!apiRef.current.getRow(params.id)) {
          return;
        }
        if (apiRef.current.getRowMode(params.id) === GridRowModes.View) {
          return;
        }
        const rowParams = apiRef.current.getRowParams(params.id);
        const newParams = _extends$2({}, rowParams, {
          field: params.field,
          reason: GridRowEditStopReasons.rowFocusOut
        });
        apiRef.current.publishEvent("rowEditStop", newParams, event);
      }
    });
  }, [apiRef]);
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(focusTimeout.current);
    };
  }, []);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (params.cellMode === GridRowModes.Edit) {
      if (event.which === 229) {
        return;
      }
      let reason;
      if (event.key === "Escape") {
        reason = GridRowEditStopReasons.escapeKeyDown;
      } else if (event.key === "Enter") {
        reason = GridRowEditStopReasons.enterKeyDown;
      } else if (event.key === "Tab") {
        const columnFields = gridVisibleColumnFieldsSelector(apiRef).filter((field) => {
          const column2 = apiRef.current.getColumn(field);
          if (column2.type === GRID_ACTIONS_COLUMN_TYPE) {
            return true;
          }
          return apiRef.current.isCellEditable(apiRef.current.getCellParams(params.id, field));
        });
        if (event.shiftKey) {
          if (params.field === columnFields[0]) {
            reason = GridRowEditStopReasons.shiftTabKeyDown;
          }
        } else if (params.field === columnFields[columnFields.length - 1]) {
          reason = GridRowEditStopReasons.tabKeyDown;
        }
        event.preventDefault();
        if (!reason) {
          const index2 = columnFields.findIndex((field) => field === params.field);
          const nextFieldToFocus = columnFields[event.shiftKey ? index2 - 1 : index2 + 1];
          apiRef.current.setCellFocus(params.id, nextFieldToFocus);
        }
      }
      if (reason) {
        const newParams = _extends$2({}, apiRef.current.getRowParams(params.id), {
          reason,
          field: params.field
        });
        apiRef.current.publishEvent("rowEditStop", newParams, event);
      }
    } else if (params.isEditable) {
      let reason;
      const canStartEditing = apiRef.current.unstable_applyPipeProcessors("canStartEditing", true, {
        event,
        cellParams: params,
        editMode: "row"
      });
      if (!canStartEditing) {
        return;
      }
      if (isPrintableKey(event)) {
        reason = GridRowEditStartReasons.printableKeyDown;
      } else if ((event.ctrlKey || event.metaKey) && event.key === "v") {
        reason = GridRowEditStartReasons.printableKeyDown;
      } else if (event.key === "Enter") {
        reason = GridRowEditStartReasons.enterKeyDown;
      } else if (event.key === "Delete" || event.key === "Backspace") {
        reason = GridRowEditStartReasons.deleteKeyDown;
      }
      if (reason) {
        const rowParams = apiRef.current.getRowParams(params.id);
        const newParams = _extends$2({}, rowParams, {
          field: params.field,
          key: event.key,
          reason
        });
        apiRef.current.publishEvent("rowEditStart", newParams, event);
      }
    }
  }, [apiRef]);
  const handleRowEditStart = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      reason,
      key,
      columns
    } = params;
    const startRowEditModeParams = {
      id: id2,
      fieldToFocus: field
    };
    if (reason === GridRowEditStartReasons.printableKeyDown) {
      if (reactExports.version.startsWith("17")) {
        startRowEditModeParams.deleteValue = !!field;
      } else {
        const colDef = columns.find((col) => col.field === field);
        startRowEditModeParams.initialValue = colDef.valueParser ? colDef.valueParser(key) : key;
      }
    } else if (reason === GridRowEditStartReasons.deleteKeyDown) {
      startRowEditModeParams.deleteValue = !!field;
    }
    apiRef.current.startRowEditMode(startRowEditModeParams);
  }, [apiRef]);
  const handleRowEditStop = reactExports.useCallback((params) => {
    const {
      id: id2,
      reason,
      field
    } = params;
    apiRef.current.runPendingEditCellValueMutation(id2);
    let cellToFocusAfter;
    if (reason === GridRowEditStopReasons.enterKeyDown) {
      cellToFocusAfter = "below";
    } else if (reason === GridRowEditStopReasons.tabKeyDown) {
      cellToFocusAfter = "right";
    } else if (reason === GridRowEditStopReasons.shiftTabKeyDown) {
      cellToFocusAfter = "left";
    }
    const ignoreModifications = reason === "escapeKeyDown";
    apiRef.current.stopRowEditMode({
      id: id2,
      ignoreModifications,
      field,
      cellToFocusAfter
    });
  }, [apiRef]);
  useGridApiEventHandler(apiRef, "cellDoubleClick", runIfEditModeIsRow(handleCellDoubleClick));
  useGridApiEventHandler(apiRef, "cellFocusIn", runIfEditModeIsRow(handleCellFocusIn));
  useGridApiEventHandler(apiRef, "cellFocusOut", runIfEditModeIsRow(handleCellFocusOut));
  useGridApiEventHandler(apiRef, "cellKeyDown", runIfEditModeIsRow(handleCellKeyDown));
  useGridApiEventHandler(apiRef, "rowEditStart", runIfEditModeIsRow(handleRowEditStart));
  useGridApiEventHandler(apiRef, "rowEditStop", runIfEditModeIsRow(handleRowEditStop));
  useGridApiOptionHandler(apiRef, "rowEditStart", props.onRowEditStart);
  useGridApiOptionHandler(apiRef, "rowEditStop", props.onRowEditStop);
  const getRowMode = reactExports.useCallback((id2) => {
    if (props.editMode === GridEditModes.Cell) {
      return GridRowModes.View;
    }
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const isEditing = editingState[id2] && Object.keys(editingState[id2]).length > 0;
    return isEditing ? GridRowModes.Edit : GridRowModes.View;
  }, [apiRef, props.editMode]);
  const updateRowModesModel = useEventCallback$1((newModel) => {
    const isNewModelDifferentFromProp = newModel !== props.rowModesModel;
    if (onRowModesModelChange && isNewModelDifferentFromProp) {
      onRowModesModelChange(newModel, {});
    }
    if (props.rowModesModel && isNewModelDifferentFromProp) {
      return;
    }
    setRowModesModel(newModel);
    rowModesModelRef.current = newModel;
    apiRef.current.publishEvent("rowModesModelChange", newModel);
  });
  const updateRowInRowModesModel = reactExports.useCallback((id2, newProps) => {
    const newModel = _extends$2({}, rowModesModelRef.current);
    if (newProps !== null) {
      newModel[id2] = _extends$2({}, newProps);
    } else {
      delete newModel[id2];
    }
    updateRowModesModel(newModel);
  }, [updateRowModesModel]);
  const updateOrDeleteRowState = reactExports.useCallback((id2, newProps) => {
    apiRef.current.setState((state) => {
      const newEditingState = _extends$2({}, state.editRows);
      if (newProps !== null) {
        newEditingState[id2] = newProps;
      } else {
        delete newEditingState[id2];
      }
      return _extends$2({}, state, {
        editRows: newEditingState
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const updateOrDeleteFieldState = reactExports.useCallback((id2, field, newProps) => {
    apiRef.current.setState((state) => {
      const newEditingState = _extends$2({}, state.editRows);
      if (newProps !== null) {
        newEditingState[id2] = _extends$2({}, newEditingState[id2], {
          [field]: _extends$2({}, newProps)
        });
      } else {
        delete newEditingState[id2][field];
        if (Object.keys(newEditingState[id2]).length === 0) {
          delete newEditingState[id2];
        }
      }
      return _extends$2({}, state, {
        editRows: newEditingState
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const startRowEditMode = reactExports.useCallback((params) => {
    const {
      id: id2
    } = params, other = _objectWithoutPropertiesLoose$1(params, _excluded$x);
    throwIfNotInMode(id2, GridRowModes.View);
    updateRowInRowModesModel(id2, _extends$2({
      mode: GridRowModes.Edit
    }, other));
  }, [throwIfNotInMode, updateRowInRowModesModel]);
  const updateStateToStartRowEditMode = useEventCallback$1((params) => {
    const {
      id: id2,
      fieldToFocus,
      deleteValue,
      initialValue
    } = params;
    const columnFields = gridColumnFieldsSelector(apiRef);
    const newProps = columnFields.reduce((acc, field) => {
      const cellParams = apiRef.current.getCellParams(id2, field);
      if (!cellParams.isEditable) {
        return acc;
      }
      let newValue = apiRef.current.getCellValue(id2, field);
      let unstable_updateValueOnRender = false;
      if (fieldToFocus === field && (deleteValue || initialValue)) {
        newValue = deleteValue ? "" : initialValue;
        unstable_updateValueOnRender = true;
      }
      acc[field] = {
        value: newValue,
        error: false,
        isProcessingProps: false,
        unstable_updateValueOnRender
      };
      return acc;
    }, {});
    updateOrDeleteRowState(id2, newProps);
    if (fieldToFocus) {
      apiRef.current.setCellFocus(id2, fieldToFocus);
    }
  });
  const stopRowEditMode = reactExports.useCallback((params) => {
    const {
      id: id2
    } = params, other = _objectWithoutPropertiesLoose$1(params, _excluded2$7);
    throwIfNotInMode(id2, GridRowModes.Edit);
    updateRowInRowModesModel(id2, _extends$2({
      mode: GridRowModes.View
    }, other));
  }, [throwIfNotInMode, updateRowInRowModesModel]);
  const updateStateToStopRowEditMode = useEventCallback$1((params) => {
    const {
      id: id2,
      ignoreModifications,
      field: focusedField,
      cellToFocusAfter = "none"
    } = params;
    apiRef.current.runPendingEditCellValueMutation(id2);
    const finishRowEditMode = () => {
      if (cellToFocusAfter !== "none" && focusedField) {
        apiRef.current.moveFocusToRelativeCell(id2, focusedField, cellToFocusAfter);
      }
      updateOrDeleteRowState(id2, null);
      updateRowInRowModesModel(id2, null);
    };
    if (ignoreModifications) {
      finishRowEditMode();
      return;
    }
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const row = apiRef.current.getRow(id2);
    const isSomeFieldProcessingProps = Object.values(editingState[id2]).some((fieldProps) => fieldProps.isProcessingProps);
    if (isSomeFieldProcessingProps) {
      prevRowModesModel.current[id2].mode = GridRowModes.Edit;
      return;
    }
    const hasSomeFieldWithError = Object.values(editingState[id2]).some((fieldProps) => fieldProps.error);
    if (hasSomeFieldWithError) {
      prevRowModesModel.current[id2].mode = GridRowModes.Edit;
      updateRowInRowModesModel(id2, {
        mode: GridRowModes.Edit
      });
      return;
    }
    const rowUpdate = apiRef.current.getRowWithUpdatedValuesFromRowEditing(id2);
    if (processRowUpdate) {
      const handleError = (errorThrown) => {
        prevRowModesModel.current[id2].mode = GridRowModes.Edit;
        updateRowInRowModesModel(id2, {
          mode: GridRowModes.Edit
        });
        if (onProcessRowUpdateError) {
          onProcessRowUpdateError(errorThrown);
        } else {
          missingOnProcessRowUpdateErrorWarning();
        }
      };
      try {
        Promise.resolve(processRowUpdate(rowUpdate, row)).then((finalRowUpdate) => {
          apiRef.current.updateRows([finalRowUpdate]);
          finishRowEditMode();
        }).catch(handleError);
      } catch (errorThrown) {
        handleError(errorThrown);
      }
    } else {
      apiRef.current.updateRows([rowUpdate]);
      finishRowEditMode();
    }
  });
  const setRowEditingEditCellValue = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      value,
      debounceMs,
      unstable_skipValueParser: skipValueParser
    } = params;
    throwIfNotEditable(id2, field);
    const column2 = apiRef.current.getColumn(field);
    const row = apiRef.current.getRow(id2);
    let parsedValue = value;
    if (column2.valueParser && !skipValueParser) {
      parsedValue = column2.valueParser(value, apiRef.current.getCellParams(id2, field));
    }
    let editingState = gridEditRowsStateSelector(apiRef.current.state);
    let newProps = _extends$2({}, editingState[id2][field], {
      value: parsedValue,
      changeReason: debounceMs ? "debouncedSetEditCellValue" : "setEditCellValue"
    });
    if (!column2.preProcessEditCellProps) {
      updateOrDeleteFieldState(id2, field, newProps);
    }
    return new Promise((resolve2) => {
      const promises = [];
      if (column2.preProcessEditCellProps) {
        const hasChanged = newProps.value !== editingState[id2][field].value;
        newProps = _extends$2({}, newProps, {
          isProcessingProps: true
        });
        updateOrDeleteFieldState(id2, field, newProps);
        const _editingState$id = editingState[id2], otherFieldsProps = _objectWithoutPropertiesLoose$1(_editingState$id, [field].map(_toPropertyKey$1));
        const promise2 = Promise.resolve(column2.preProcessEditCellProps({
          id: id2,
          row,
          props: newProps,
          hasChanged,
          otherFieldsProps
        })).then((processedProps) => {
          if (apiRef.current.getRowMode(id2) === GridRowModes.View) {
            resolve2(false);
            return;
          }
          editingState = gridEditRowsStateSelector(apiRef.current.state);
          processedProps = _extends$2({}, processedProps, {
            isProcessingProps: false
          });
          processedProps.value = column2.preProcessEditCellProps ? editingState[id2][field].value : parsedValue;
          updateOrDeleteFieldState(id2, field, processedProps);
        });
        promises.push(promise2);
      }
      Object.entries(editingState[id2]).forEach(([thisField, fieldProps]) => {
        if (thisField === field) {
          return;
        }
        const fieldColumn = apiRef.current.getColumn(thisField);
        if (!fieldColumn.preProcessEditCellProps) {
          return;
        }
        fieldProps = _extends$2({}, fieldProps, {
          isProcessingProps: true
        });
        updateOrDeleteFieldState(id2, thisField, fieldProps);
        editingState = gridEditRowsStateSelector(apiRef.current.state);
        const _editingState$id2 = editingState[id2], otherFieldsProps = _objectWithoutPropertiesLoose$1(_editingState$id2, [thisField].map(_toPropertyKey$1));
        const promise2 = Promise.resolve(fieldColumn.preProcessEditCellProps({
          id: id2,
          row,
          props: fieldProps,
          hasChanged: false,
          otherFieldsProps
        })).then((processedProps) => {
          if (apiRef.current.getRowMode(id2) === GridRowModes.View) {
            resolve2(false);
            return;
          }
          processedProps = _extends$2({}, processedProps, {
            isProcessingProps: false
          });
          updateOrDeleteFieldState(id2, thisField, processedProps);
        });
        promises.push(promise2);
      });
      Promise.all(promises).then(() => {
        if (apiRef.current.getRowMode(id2) === GridRowModes.Edit) {
          editingState = gridEditRowsStateSelector(apiRef.current.state);
          resolve2(!editingState[id2][field].error);
        } else {
          resolve2(false);
        }
      });
    });
  }, [apiRef, throwIfNotEditable, updateOrDeleteFieldState]);
  const getRowWithUpdatedValuesFromRowEditing = reactExports.useCallback((id2) => {
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    const row = apiRef.current.getRow(id2);
    if (!editingState[id2]) {
      return apiRef.current.getRow(id2);
    }
    let rowUpdate = _extends$2({}, row);
    Object.entries(editingState[id2]).forEach(([field, fieldProps]) => {
      const column2 = apiRef.current.getColumn(field);
      if (column2.valueSetter) {
        rowUpdate = column2.valueSetter({
          value: fieldProps.value,
          row: rowUpdate
        });
      } else {
        rowUpdate[field] = fieldProps.value;
      }
    });
    return rowUpdate;
  }, [apiRef]);
  const editingApi = {
    getRowMode,
    startRowEditMode,
    stopRowEditMode
  };
  const editingPrivateApi = {
    setRowEditingEditCellValue,
    getRowWithUpdatedValuesFromRowEditing
  };
  useGridApiMethod(apiRef, editingApi, "public");
  useGridApiMethod(apiRef, editingPrivateApi, "private");
  reactExports.useEffect(() => {
    if (rowModesModelProp) {
      updateRowModesModel(rowModesModelProp);
    }
  }, [rowModesModelProp, updateRowModesModel]);
  reactExports.useEffect(() => {
    const idToIdLookup = gridRowsDataRowIdToIdLookupSelector(apiRef);
    const copyOfPrevRowModesModel = prevRowModesModel.current;
    prevRowModesModel.current = deepClone(rowModesModel);
    Object.entries(rowModesModel).forEach(([id2, params]) => {
      var _copyOfPrevRowModesMo, _idToIdLookup$id;
      const prevMode = ((_copyOfPrevRowModesMo = copyOfPrevRowModesModel[id2]) == null ? void 0 : _copyOfPrevRowModesMo.mode) || GridRowModes.View;
      const originalId = (_idToIdLookup$id = idToIdLookup[id2]) != null ? _idToIdLookup$id : id2;
      if (params.mode === GridRowModes.Edit && prevMode === GridRowModes.View) {
        updateStateToStartRowEditMode(_extends$2({
          id: originalId
        }, params));
      } else if (params.mode === GridRowModes.View && prevMode === GridRowModes.Edit) {
        updateStateToStopRowEditMode(_extends$2({
          id: originalId
        }, params));
      }
    });
  }, [apiRef, rowModesModel, updateStateToStartRowEditMode, updateStateToStopRowEditMode]);
};
const editingStateInitializer = (state) => _extends$2({}, state, {
  editRows: {}
});
const useGridEditing = (apiRef, props) => {
  useGridCellEditing(apiRef, props);
  useGridRowEditing(apiRef, props);
  const debounceMap = reactExports.useRef({});
  const {
    isCellEditable: isCellEditableProp
  } = props;
  const isCellEditable = reactExports.useCallback((params) => {
    if (isAutoGeneratedRow(params.rowNode)) {
      return false;
    }
    if (!params.colDef.editable) {
      return false;
    }
    if (!params.colDef.renderEditCell) {
      return false;
    }
    if (isCellEditableProp) {
      return isCellEditableProp(params);
    }
    return true;
  }, [isCellEditableProp]);
  const maybeDebounce = (id2, field, debounceMs, callback) => {
    if (!debounceMs) {
      callback();
      return;
    }
    if (!debounceMap.current[id2]) {
      debounceMap.current[id2] = {};
    }
    if (debounceMap.current[id2][field]) {
      const [timeout2] = debounceMap.current[id2][field];
      clearTimeout(timeout2);
    }
    const runImmediately = () => {
      const [timeout2] = debounceMap.current[id2][field];
      clearTimeout(timeout2);
      callback();
      delete debounceMap.current[id2][field];
    };
    const timeout = setTimeout(() => {
      callback();
      delete debounceMap.current[id2][field];
    }, debounceMs);
    debounceMap.current[id2][field] = [timeout, runImmediately];
  };
  reactExports.useEffect(() => {
    const debounces = debounceMap.current;
    return () => {
      Object.entries(debounces).forEach(([id2, fields]) => {
        Object.keys(fields).forEach((field) => {
          const [timeout] = debounces[id2][field];
          clearTimeout(timeout);
          delete debounces[id2][field];
        });
      });
    };
  }, []);
  const runPendingEditCellValueMutation = reactExports.useCallback((id2, field) => {
    if (!debounceMap.current[id2]) {
      return;
    }
    if (!field) {
      Object.keys(debounceMap.current[id2]).forEach((debouncedField) => {
        const [, runCallback] = debounceMap.current[id2][debouncedField];
        runCallback();
      });
    } else if (debounceMap.current[id2][field]) {
      const [, runCallback] = debounceMap.current[id2][field];
      runCallback();
    }
  }, []);
  const setEditCellValue = reactExports.useCallback((params) => {
    const {
      id: id2,
      field,
      debounceMs
    } = params;
    return new Promise((resolve2) => {
      maybeDebounce(id2, field, debounceMs, async () => {
        const setEditCellValueToCall = props.editMode === GridEditModes.Row ? apiRef.current.setRowEditingEditCellValue : apiRef.current.setCellEditingEditCellValue;
        if (apiRef.current.getCellMode(id2, field) === GridCellModes.Edit) {
          const result = await setEditCellValueToCall(params);
          resolve2(result);
        }
      });
    });
  }, [apiRef, props.editMode]);
  const getRowWithUpdatedValues = reactExports.useCallback((id2, field) => {
    return props.editMode === GridEditModes.Cell ? apiRef.current.getRowWithUpdatedValuesFromCellEditing(id2, field) : apiRef.current.getRowWithUpdatedValuesFromRowEditing(id2);
  }, [apiRef, props.editMode]);
  const getEditCellMeta = reactExports.useCallback((id2, field) => {
    var _editingState$id$fiel, _editingState$id;
    const editingState = gridEditRowsStateSelector(apiRef.current.state);
    return (_editingState$id$fiel = (_editingState$id = editingState[id2]) == null ? void 0 : _editingState$id[field]) != null ? _editingState$id$fiel : null;
  }, [apiRef]);
  const editingSharedApi = {
    isCellEditable,
    setEditCellValue,
    getRowWithUpdatedValues,
    unstable_getEditCellMeta: getEditCellMeta
  };
  const editingSharedPrivateApi = {
    runPendingEditCellValueMutation
  };
  useGridApiMethod(apiRef, editingSharedApi, "public");
  useGridApiMethod(apiRef, editingSharedPrivateApi, "private");
};
const rowsStateInitializer = (state, props, apiRef) => {
  apiRef.current.caches.rows = createRowsInternalCache({
    rows: props.rows,
    getRowId: props.getRowId,
    loading: props.loading,
    rowCount: props.rowCount
  });
  return _extends$2({}, state, {
    rows: getRowsStateFromCache({
      apiRef,
      rowCountProp: props.rowCount,
      loadingProp: props.loading,
      previousTree: null,
      previousTreeDepths: null
    })
  });
};
const useGridRows = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridRows");
  const currentPage = useGridVisibleRows(apiRef, props);
  const lastUpdateMs = reactExports.useRef(Date.now());
  const timeout = useTimeout();
  const getRow = reactExports.useCallback((id2) => {
    const model = gridRowsLookupSelector(apiRef)[id2];
    if (model) {
      return model;
    }
    const node2 = apiRef.current.getRowNode(id2);
    if (node2 && isAutoGeneratedRow(node2)) {
      return {
        [GRID_ID_AUTOGENERATED]: id2
      };
    }
    return null;
  }, [apiRef]);
  const getRowIdProp = props.getRowId;
  const getRowId = reactExports.useCallback((row) => {
    if (GRID_ID_AUTOGENERATED in row) {
      return row[GRID_ID_AUTOGENERATED];
    }
    if (getRowIdProp) {
      return getRowIdProp(row);
    }
    return row.id;
  }, [getRowIdProp]);
  const lookup2 = reactExports.useMemo(() => currentPage.rows.reduce((acc, {
    id: id2
  }, index2) => {
    acc[id2] = index2;
    return acc;
  }, {}), [currentPage.rows]);
  const throttledRowsChange = reactExports.useCallback(({
    cache: cache2,
    throttle
  }) => {
    const run = () => {
      lastUpdateMs.current = Date.now();
      apiRef.current.setState((state) => _extends$2({}, state, {
        rows: getRowsStateFromCache({
          apiRef,
          rowCountProp: props.rowCount,
          loadingProp: props.loading,
          previousTree: gridRowTreeSelector(apiRef),
          previousTreeDepths: gridRowTreeDepthsSelector(apiRef)
        })
      }));
      apiRef.current.publishEvent("rowsSet");
      apiRef.current.forceUpdate();
    };
    timeout.clear();
    apiRef.current.caches.rows = cache2;
    if (!throttle) {
      run();
      return;
    }
    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);
    if (throttleRemainingTimeMs > 0) {
      timeout.start(throttleRemainingTimeMs, run);
      return;
    }
    run();
  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef, timeout]);
  const setRows = reactExports.useCallback((rows2) => {
    logger.debug(`Updating all rows, new length ${rows2.length}`);
    const cache2 = createRowsInternalCache({
      rows: rows2,
      getRowId: props.getRowId,
      loading: props.loading,
      rowCount: props.rowCount
    });
    const prevCache = apiRef.current.caches.rows;
    cache2.rowsBeforePartialUpdates = prevCache.rowsBeforePartialUpdates;
    throttledRowsChange({
      cache: cache2,
      throttle: true
    });
  }, [logger, props.getRowId, props.loading, props.rowCount, throttledRowsChange, apiRef]);
  const updateRows = reactExports.useCallback((updates) => {
    if (props.signature === GridSignature.DataGrid && updates.length > 1) {
      throw new Error(["MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));
    }
    const nonPinnedRowsUpdates = [];
    updates.forEach((update2) => {
      const id2 = getRowIdFromRowModel(update2, props.getRowId, "A row was provided without id when calling updateRows():");
      const rowNode = apiRef.current.getRowNode(id2);
      if ((rowNode == null ? void 0 : rowNode.type) === "pinnedRow") {
        const pinnedRowsCache = apiRef.current.caches.pinnedRows;
        const prevModel = pinnedRowsCache.idLookup[id2];
        if (prevModel) {
          pinnedRowsCache.idLookup[id2] = _extends$2({}, prevModel, update2);
        }
      } else {
        nonPinnedRowsUpdates.push(update2);
      }
    });
    const cache2 = updateCacheWithNewRows({
      updates: nonPinnedRowsUpdates,
      getRowId: props.getRowId,
      previousCache: apiRef.current.caches.rows
    });
    throttledRowsChange({
      cache: cache2,
      throttle: true
    });
  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);
  const getRowModels = reactExports.useCallback(() => {
    const dataRows = gridDataRowIdsSelector(apiRef);
    const idRowsLookup = gridRowsLookupSelector(apiRef);
    return new Map(dataRows.map((id2) => {
      var _idRowsLookup$id;
      return [id2, (_idRowsLookup$id = idRowsLookup[id2]) != null ? _idRowsLookup$id : {}];
    }));
  }, [apiRef]);
  const getRowsCount = reactExports.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);
  const getAllRowIds = reactExports.useCallback(() => gridDataRowIdsSelector(apiRef), [apiRef]);
  const getRowIndexRelativeToVisibleRows = reactExports.useCallback((id2) => lookup2[id2], [lookup2]);
  const setRowChildrenExpansion = reactExports.useCallback((id2, isExpanded) => {
    const currentNode = apiRef.current.getRowNode(id2);
    if (!currentNode) {
      throw new Error(`MUI: No row with id #${id2} found`);
    }
    if (currentNode.type !== "group") {
      throw new Error("MUI: Only group nodes can be expanded or collapsed");
    }
    const newNode = _extends$2({}, currentNode, {
      childrenExpanded: isExpanded
    });
    apiRef.current.setState((state) => {
      return _extends$2({}, state, {
        rows: _extends$2({}, state.rows, {
          tree: _extends$2({}, state.rows.tree, {
            [id2]: newNode
          })
        })
      });
    });
    apiRef.current.forceUpdate();
    apiRef.current.publishEvent("rowExpansionChange", newNode);
  }, [apiRef]);
  const getRowNode = reactExports.useCallback((id2) => {
    var _ref;
    return (_ref = gridRowTreeSelector(apiRef)[id2]) != null ? _ref : null;
  }, [apiRef]);
  const getRowGroupChildren = reactExports.useCallback(({
    skipAutoGeneratedRows = true,
    groupId,
    applySorting,
    applyFiltering
  }) => {
    const tree = gridRowTreeSelector(apiRef);
    let children;
    if (applySorting) {
      const groupNode = tree[groupId];
      if (!groupNode) {
        return [];
      }
      const sortedRowIds = gridSortedRowIdsSelector(apiRef);
      children = [];
      const startIndex = sortedRowIds.findIndex((id2) => id2 === groupId) + 1;
      for (let index2 = startIndex; index2 < sortedRowIds.length && tree[sortedRowIds[index2]].depth > groupNode.depth; index2 += 1) {
        const id2 = sortedRowIds[index2];
        if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[id2])) {
          children.push(id2);
        }
      }
    } else {
      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);
    }
    if (applyFiltering) {
      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);
      children = children.filter((childId) => filteredRowsLookup[childId] !== false);
    }
    return children;
  }, [apiRef]);
  const setRowIndex = reactExports.useCallback((rowId, targetIndex) => {
    const node2 = apiRef.current.getRowNode(rowId);
    if (!node2) {
      throw new Error(`MUI: No row with id #${rowId} found`);
    }
    if (node2.parent !== GRID_ROOT_GROUP_ID) {
      throw new Error(`MUI: The row reordering do not support reordering of grouped rows yet`);
    }
    if (node2.type !== "leaf") {
      throw new Error(`MUI: The row reordering do not support reordering of footer or grouping rows`);
    }
    apiRef.current.setState((state) => {
      const group = gridRowTreeSelector(state, apiRef.current.instanceId)[GRID_ROOT_GROUP_ID];
      const allRows = group.children;
      const oldIndex = allRows.findIndex((row) => row === rowId);
      if (oldIndex === -1 || oldIndex === targetIndex) {
        return state;
      }
      logger.debug(`Moving row ${rowId} to index ${targetIndex}`);
      const updatedRows = [...allRows];
      updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);
      return _extends$2({}, state, {
        rows: _extends$2({}, state.rows, {
          tree: _extends$2({}, state.rows.tree, {
            [GRID_ROOT_GROUP_ID]: _extends$2({}, group, {
              children: updatedRows
            })
          })
        })
      });
    });
    apiRef.current.publishEvent("rowsSet");
  }, [apiRef, logger]);
  const replaceRows = reactExports.useCallback((firstRowToRender, newRows) => {
    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {
      throw new Error(["MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));
    }
    if (newRows.length === 0) {
      return;
    }
    const treeDepth = gridRowMaximumTreeDepthSelector(apiRef);
    if (treeDepth > 1) {
      throw new Error("`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping");
    }
    const tree = _extends$2({}, gridRowTreeSelector(apiRef));
    const dataRowIdToModelLookup = _extends$2({}, gridRowsLookupSelector(apiRef));
    const dataRowIdToIdLookup = _extends$2({}, gridRowsDataRowIdToIdLookupSelector(apiRef));
    const rootGroup = tree[GRID_ROOT_GROUP_ID];
    const rootGroupChildren = [...rootGroup.children];
    for (let i2 = 0; i2 < newRows.length; i2 += 1) {
      const rowModel = newRows[i2];
      const rowId = getRowIdFromRowModel(rowModel, props.getRowId, "A row was provided without id when calling replaceRows().");
      const [replacedRowId] = rootGroupChildren.splice(firstRowToRender + i2, 1, rowId);
      delete dataRowIdToModelLookup[replacedRowId];
      delete dataRowIdToIdLookup[replacedRowId];
      delete tree[replacedRowId];
      const rowTreeNodeConfig = {
        id: rowId,
        depth: 0,
        parent: GRID_ROOT_GROUP_ID,
        type: "leaf",
        groupingKey: null
      };
      dataRowIdToModelLookup[rowId] = rowModel;
      dataRowIdToIdLookup[rowId] = rowId;
      tree[rowId] = rowTreeNodeConfig;
    }
    tree[GRID_ROOT_GROUP_ID] = _extends$2({}, rootGroup, {
      children: rootGroupChildren
    });
    const dataRowIds = rootGroupChildren.filter((childId) => tree[childId].type === "leaf");
    apiRef.current.caches.rows.dataRowIdToModelLookup = dataRowIdToModelLookup;
    apiRef.current.caches.rows.dataRowIdToIdLookup = dataRowIdToIdLookup;
    apiRef.current.setState((state) => _extends$2({}, state, {
      rows: _extends$2({}, state.rows, {
        dataRowIdToModelLookup,
        dataRowIdToIdLookup,
        dataRowIds,
        tree
      })
    }));
    apiRef.current.publishEvent("rowsSet");
  }, [apiRef, props.signature, props.getRowId]);
  const rowApi = {
    getRow,
    getRowId,
    getRowModels,
    getRowsCount,
    getAllRowIds,
    setRows,
    updateRows,
    getRowNode,
    getRowIndexRelativeToVisibleRows,
    unstable_replaceRows: replaceRows
  };
  const rowProApi = {
    setRowIndex,
    setRowChildrenExpansion,
    getRowGroupChildren
  };
  const groupRows = reactExports.useCallback(() => {
    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);
    let cache2;
    if (apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows) {
      cache2 = _extends$2({}, apiRef.current.caches.rows, {
        updates: {
          type: "full",
          rows: gridDataRowIdsSelector(apiRef)
        }
      });
    } else {
      cache2 = createRowsInternalCache({
        rows: props.rows,
        getRowId: props.getRowId,
        loading: props.loading,
        rowCount: props.rowCount
      });
    }
    throttledRowsChange({
      cache: cache2,
      throttle: false
    });
  }, [logger, apiRef, props.rows, props.getRowId, props.loading, props.rowCount, throttledRowsChange]);
  const handleStrategyProcessorChange = reactExports.useCallback((methodName) => {
    if (methodName === "rowTreeCreation") {
      groupRows();
    }
  }, [groupRows]);
  const handleStrategyActivityChange = reactExports.useCallback(() => {
    if (apiRef.current.getActiveStrategy("rowTree") !== gridRowGroupingNameSelector(apiRef)) {
      groupRows();
    }
  }, [apiRef, groupRows]);
  useGridApiEventHandler(apiRef, "activeStrategyProcessorChange", handleStrategyProcessorChange);
  useGridApiEventHandler(apiRef, "strategyAvailabilityChange", handleStrategyActivityChange);
  const applyHydrateRowsProcessor = reactExports.useCallback(() => {
    apiRef.current.setState((state) => {
      const response = apiRef.current.unstable_applyPipeProcessors("hydrateRows", {
        tree: gridRowTreeSelector(state, apiRef.current.instanceId),
        treeDepths: gridRowTreeDepthsSelector(state, apiRef.current.instanceId),
        dataRowIds: gridDataRowIdsSelector(state, apiRef.current.instanceId),
        dataRowIdToModelLookup: gridRowsLookupSelector(state, apiRef.current.instanceId),
        dataRowIdToIdLookup: gridRowsDataRowIdToIdLookupSelector(state, apiRef.current.instanceId)
      });
      return _extends$2({}, state, {
        rows: _extends$2({}, state.rows, response, {
          totalTopLevelRowCount: getTopLevelRowCount({
            tree: response.tree,
            rowCountProp: props.rowCount
          })
        })
      });
    });
    apiRef.current.publishEvent("rowsSet");
    apiRef.current.forceUpdate();
  }, [apiRef, props.rowCount]);
  useGridRegisterPipeApplier(apiRef, "hydrateRows", applyHydrateRowsProcessor);
  useGridApiMethod(apiRef, rowApi, "public");
  useGridApiMethod(apiRef, rowProApi, props.signature === GridSignature.DataGrid ? "private" : "public");
  const isFirstRender = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    const areNewRowsAlreadyInState = apiRef.current.caches.rows.rowsBeforePartialUpdates === props.rows;
    const isNewLoadingAlreadyInState = apiRef.current.caches.rows.loadingPropBeforePartialUpdates === props.loading;
    const isNewRowCountAlreadyInState = apiRef.current.caches.rows.rowCountPropBeforePartialUpdates === props.rowCount;
    if (areNewRowsAlreadyInState) {
      if (!isNewLoadingAlreadyInState) {
        apiRef.current.setState((state) => _extends$2({}, state, {
          rows: _extends$2({}, state.rows, {
            loading: props.loading
          })
        }));
        apiRef.current.caches.rows.loadingPropBeforePartialUpdates = props.loading;
        apiRef.current.forceUpdate();
      }
      if (!isNewRowCountAlreadyInState) {
        apiRef.current.setState((state) => _extends$2({}, state, {
          rows: _extends$2({}, state.rows, {
            totalRowCount: Math.max(props.rowCount || 0, state.rows.totalRowCount),
            totalTopLevelRowCount: Math.max(props.rowCount || 0, state.rows.totalTopLevelRowCount)
          })
        }));
        apiRef.current.caches.rows.rowCountPropBeforePartialUpdates = props.rowCount;
        apiRef.current.forceUpdate();
      }
      return;
    }
    logger.debug(`Updating all rows, new length ${props.rows.length}`);
    throttledRowsChange({
      cache: createRowsInternalCache({
        rows: props.rows,
        getRowId: props.getRowId,
        loading: props.loading,
        rowCount: props.rowCount
      }),
      throttle: false
    });
  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);
};
const createFlatRowTree = (rows2) => {
  const tree = {
    [GRID_ROOT_GROUP_ID]: _extends$2({}, buildRootGroup(), {
      children: rows2
    })
  };
  for (let i2 = 0; i2 < rows2.length; i2 += 1) {
    const rowId = rows2[i2];
    tree[rowId] = {
      id: rowId,
      depth: 0,
      parent: GRID_ROOT_GROUP_ID,
      type: "leaf",
      groupingKey: null
    };
  }
  return {
    groupingName: GRID_DEFAULT_STRATEGY,
    tree,
    treeDepths: {
      0: rows2.length
    },
    dataRowIds: rows2
  };
};
const updateFlatRowTree = ({
  previousTree,
  actions
}) => {
  const tree = _extends$2({}, previousTree);
  const idsToRemoveFromRootGroup = {};
  for (let i2 = 0; i2 < actions.remove.length; i2 += 1) {
    const idToDelete = actions.remove[i2];
    idsToRemoveFromRootGroup[idToDelete] = true;
    delete tree[idToDelete];
  }
  for (let i2 = 0; i2 < actions.insert.length; i2 += 1) {
    const idToInsert = actions.insert[i2];
    tree[idToInsert] = {
      id: idToInsert,
      depth: 0,
      parent: GRID_ROOT_GROUP_ID,
      type: "leaf",
      groupingKey: null
    };
  }
  const rootGroup = tree[GRID_ROOT_GROUP_ID];
  let rootGroupChildren = [...rootGroup.children, ...actions.insert];
  if (Object.values(idsToRemoveFromRootGroup).length) {
    rootGroupChildren = rootGroupChildren.filter((id2) => !idsToRemoveFromRootGroup[id2]);
  }
  tree[GRID_ROOT_GROUP_ID] = _extends$2({}, rootGroup, {
    children: rootGroupChildren
  });
  return {
    groupingName: GRID_DEFAULT_STRATEGY,
    tree,
    treeDepths: {
      0: rootGroupChildren.length
    },
    dataRowIds: rootGroupChildren
  };
};
const flatRowTreeCreationMethod = (params) => {
  if (params.updates.type === "full") {
    return createFlatRowTree(params.updates.rows);
  }
  return updateFlatRowTree({
    previousTree: params.previousTree,
    actions: params.updates.actions
  });
};
const useGridRowsPreProcessors = (apiRef) => {
  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, "rowTreeCreation", flatRowTreeCreationMethod);
};
const getSelectionModelPropValue = (selectionModelProp, prevSelectionModel) => {
  if (selectionModelProp == null) {
    return selectionModelProp;
  }
  if (Array.isArray(selectionModelProp)) {
    return selectionModelProp;
  }
  if (prevSelectionModel && prevSelectionModel[0] === selectionModelProp) {
    return prevSelectionModel;
  }
  return [selectionModelProp];
};
const rowSelectionStateInitializer = (state, props) => {
  var _getSelectionModelPro;
  return _extends$2({}, state, {
    rowSelection: props.rowSelection ? (_getSelectionModelPro = getSelectionModelPropValue(props.rowSelectionModel)) != null ? _getSelectionModelPro : [] : []
  });
};
const useGridRowSelection = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridSelection");
  const runIfRowSelectionIsEnabled = (callback) => (...args) => {
    if (props.rowSelection) {
      callback(...args);
    }
  };
  const propRowSelectionModel = reactExports.useMemo(() => {
    return getSelectionModelPropValue(props.rowSelectionModel, gridRowSelectionStateSelector(apiRef.current.state));
  }, [apiRef, props.rowSelectionModel]);
  const lastRowToggled = reactExports.useRef(null);
  apiRef.current.registerControlState({
    stateId: "rowSelection",
    propModel: propRowSelectionModel,
    propOnChange: props.onRowSelectionModelChange,
    stateSelector: gridRowSelectionStateSelector,
    changeEvent: "rowSelectionChange"
  });
  const {
    checkboxSelection,
    disableMultipleRowSelection,
    disableRowSelectionOnClick,
    isRowSelectable: propIsRowSelectable
  } = props;
  const canHaveMultipleSelection = !disableMultipleRowSelection || checkboxSelection;
  const visibleRows = useGridVisibleRows(apiRef, props);
  const expandMouseRowRangeSelection = reactExports.useCallback((id2) => {
    var _lastRowToggled$curre;
    let endId = id2;
    const startId = (_lastRowToggled$curre = lastRowToggled.current) != null ? _lastRowToggled$curre : id2;
    const isSelected = apiRef.current.isRowSelected(id2);
    if (isSelected) {
      const visibleRowIds = gridExpandedSortedRowIdsSelector(apiRef);
      const startIndex = visibleRowIds.findIndex((rowId) => rowId === startId);
      const endIndex = visibleRowIds.findIndex((rowId) => rowId === endId);
      if (startIndex === endIndex) {
        return;
      }
      if (startIndex > endIndex) {
        endId = visibleRowIds[endIndex + 1];
      } else {
        endId = visibleRowIds[endIndex - 1];
      }
    }
    lastRowToggled.current = id2;
    apiRef.current.selectRowRange({
      startId,
      endId
    }, !isSelected);
  }, [apiRef]);
  const setRowSelectionModel = reactExports.useCallback((model) => {
    if (props.signature === GridSignature.DataGrid && !props.checkboxSelection && Array.isArray(model) && model.length > 1) {
      throw new Error(["MUI: `rowSelectionModel` can only contain 1 item in DataGrid.", "You need to upgrade to DataGridPro or DataGridPremium component to unlock multiple selection."].join("\n"));
    }
    const currentModel = gridRowSelectionStateSelector(apiRef.current.state);
    if (currentModel !== model) {
      logger.debug(`Setting selection model`);
      apiRef.current.setState((state) => _extends$2({}, state, {
        rowSelection: props.rowSelection ? model : []
      }));
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger, props.rowSelection, props.signature, props.checkboxSelection]);
  const isRowSelected = reactExports.useCallback((id2) => gridRowSelectionStateSelector(apiRef.current.state).includes(id2), [apiRef]);
  const isRowSelectable = reactExports.useCallback((id2) => {
    if (propIsRowSelectable && !propIsRowSelectable(apiRef.current.getRowParams(id2))) {
      return false;
    }
    const rowNode = apiRef.current.getRowNode(id2);
    if ((rowNode == null ? void 0 : rowNode.type) === "footer" || (rowNode == null ? void 0 : rowNode.type) === "pinnedRow") {
      return false;
    }
    return true;
  }, [apiRef, propIsRowSelectable]);
  const getSelectedRows = reactExports.useCallback(() => selectedGridRowsSelector(apiRef), [apiRef]);
  const selectRow = reactExports.useCallback((id2, isSelected = true, resetSelection = false) => {
    if (!apiRef.current.isRowSelectable(id2)) {
      return;
    }
    lastRowToggled.current = id2;
    if (resetSelection) {
      logger.debug(`Setting selection for row ${id2}`);
      apiRef.current.setRowSelectionModel(isSelected ? [id2] : []);
    } else {
      logger.debug(`Toggling selection for row ${id2}`);
      const selection = gridRowSelectionStateSelector(apiRef.current.state);
      const newSelection = selection.filter((el2) => el2 !== id2);
      if (isSelected) {
        newSelection.push(id2);
      }
      const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;
      if (isSelectionValid) {
        apiRef.current.setRowSelectionModel(newSelection);
      }
    }
  }, [apiRef, logger, canHaveMultipleSelection]);
  const selectRows = reactExports.useCallback((ids, isSelected = true, resetSelection = false) => {
    logger.debug(`Setting selection for several rows`);
    const selectableIds = ids.filter((id2) => apiRef.current.isRowSelectable(id2));
    let newSelection;
    if (resetSelection) {
      newSelection = isSelected ? selectableIds : [];
    } else {
      const selectionLookup = _extends$2({}, selectedIdsLookupSelector(apiRef));
      selectableIds.forEach((id2) => {
        if (isSelected) {
          selectionLookup[id2] = id2;
        } else {
          delete selectionLookup[id2];
        }
      });
      newSelection = Object.values(selectionLookup);
    }
    const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;
    if (isSelectionValid) {
      apiRef.current.setRowSelectionModel(newSelection);
    }
  }, [apiRef, logger, canHaveMultipleSelection]);
  const selectRowRange = reactExports.useCallback(({
    startId,
    endId
  }, isSelected = true, resetSelection = false) => {
    if (!apiRef.current.getRow(startId) || !apiRef.current.getRow(endId)) {
      return;
    }
    logger.debug(`Expanding selection from row ${startId} to row ${endId}`);
    const allPagesRowIds = gridExpandedSortedRowIdsSelector(apiRef);
    const startIndex = allPagesRowIds.indexOf(startId);
    const endIndex = allPagesRowIds.indexOf(endId);
    const [start2, end2] = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex];
    const rowsBetweenStartAndEnd = allPagesRowIds.slice(start2, end2 + 1);
    apiRef.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);
  }, [apiRef, logger]);
  const selectionPublicApi = {
    selectRow,
    setRowSelectionModel,
    getSelectedRows,
    isRowSelected,
    isRowSelectable
  };
  const selectionPrivateApi = {
    selectRows,
    selectRowRange
  };
  useGridApiMethod(apiRef, selectionPublicApi, "public");
  useGridApiMethod(apiRef, selectionPrivateApi, props.signature === GridSignature.DataGrid ? "private" : "public");
  const removeOutdatedSelection = reactExports.useCallback(() => {
    if (props.keepNonExistentRowsSelected) {
      return;
    }
    const currentSelection = gridRowSelectionStateSelector(apiRef.current.state);
    const rowsLookup = gridRowsLookupSelector(apiRef);
    const selectionLookup = _extends$2({}, selectedIdsLookupSelector(apiRef));
    let hasChanged = false;
    currentSelection.forEach((id2) => {
      if (!rowsLookup[id2]) {
        delete selectionLookup[id2];
        hasChanged = true;
      }
    });
    if (hasChanged) {
      apiRef.current.setRowSelectionModel(Object.values(selectionLookup));
    }
  }, [apiRef, props.keepNonExistentRowsSelected]);
  const handleSingleRowSelection = reactExports.useCallback((id2, event) => {
    const hasCtrlKey = event.metaKey || event.ctrlKey;
    const isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !isKeyboardEvent$1(event);
    const resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;
    const isSelected = apiRef.current.isRowSelected(id2);
    if (resetSelection) {
      apiRef.current.selectRow(id2, !isMultipleSelectionDisabled ? !isSelected : true, true);
    } else {
      apiRef.current.selectRow(id2, !isSelected, false);
    }
  }, [apiRef, canHaveMultipleSelection, checkboxSelection]);
  const handleRowClick = reactExports.useCallback((params, event) => {
    var _closest;
    if (disableRowSelectionOnClick) {
      return;
    }
    const field = (_closest = event.target.closest(`.${gridClasses.cell}`)) == null ? void 0 : _closest.getAttribute("data-field");
    if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {
      return;
    }
    if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {
      return;
    }
    if (field) {
      const column2 = apiRef.current.getColumn(field);
      if ((column2 == null ? void 0 : column2.type) === GRID_ACTIONS_COLUMN_TYPE) {
        return;
      }
    }
    const rowNode = apiRef.current.getRowNode(params.id);
    if (rowNode.type === "pinnedRow") {
      return;
    }
    if (event.shiftKey && (canHaveMultipleSelection || checkboxSelection)) {
      expandMouseRowRangeSelection(params.id);
    } else {
      handleSingleRowSelection(params.id, event);
    }
  }, [disableRowSelectionOnClick, canHaveMultipleSelection, checkboxSelection, apiRef, expandMouseRowRangeSelection, handleSingleRowSelection]);
  const preventSelectionOnShift = reactExports.useCallback((params, event) => {
    if (canHaveMultipleSelection && event.shiftKey) {
      var _window$getSelection;
      (_window$getSelection = window.getSelection()) == null || _window$getSelection.removeAllRanges();
    }
  }, [canHaveMultipleSelection]);
  const handleRowSelectionCheckboxChange = reactExports.useCallback((params, event) => {
    if (event.nativeEvent.shiftKey) {
      expandMouseRowRangeSelection(params.id);
    } else {
      apiRef.current.selectRow(params.id, params.value);
    }
  }, [apiRef, expandMouseRowRangeSelection]);
  const handleHeaderSelectionCheckboxChange = reactExports.useCallback((params) => {
    const shouldLimitSelectionToCurrentPage = props.checkboxSelectionVisibleOnly && props.pagination;
    const rowsToBeSelected = shouldLimitSelectionToCurrentPage ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridExpandedSortedRowIdsSelector(apiRef);
    apiRef.current.selectRows(rowsToBeSelected, params.value);
  }, [apiRef, props.checkboxSelectionVisibleOnly, props.pagination]);
  const handleCellKeyDown = reactExports.useCallback((params, event) => {
    if (apiRef.current.getCellMode(params.id, params.field) === GridCellModes.Edit) {
      return;
    }
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    if (isNavigationKey(event.key) && event.shiftKey) {
      const focusCell = gridFocusCellSelector(apiRef);
      if (focusCell && focusCell.id !== params.id) {
        event.preventDefault();
        const isNextRowSelected = apiRef.current.isRowSelected(focusCell.id);
        if (!canHaveMultipleSelection) {
          apiRef.current.selectRow(focusCell.id, !isNextRowSelected, true);
          return;
        }
        const newRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(focusCell.id);
        const previousRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(params.id);
        let start2;
        let end2;
        if (newRowIndex > previousRowIndex) {
          if (isNextRowSelected) {
            start2 = previousRowIndex;
            end2 = newRowIndex - 1;
          } else {
            start2 = previousRowIndex;
            end2 = newRowIndex;
          }
        } else {
          if (isNextRowSelected) {
            start2 = newRowIndex + 1;
            end2 = previousRowIndex;
          } else {
            start2 = newRowIndex;
            end2 = previousRowIndex;
          }
        }
        const rowsBetweenStartAndEnd = visibleRows.rows.slice(start2, end2 + 1).map((row) => row.id);
        apiRef.current.selectRows(rowsBetweenStartAndEnd, !isNextRowSelected);
        return;
      }
    }
    if (event.key === " " && event.shiftKey) {
      event.preventDefault();
      handleSingleRowSelection(params.id, event);
      return;
    }
    if (event.key === "a" && (event.ctrlKey || event.metaKey)) {
      event.preventDefault();
      selectRows(apiRef.current.getAllRowIds(), true);
    }
  }, [apiRef, handleSingleRowSelection, selectRows, visibleRows.rows, canHaveMultipleSelection]);
  useGridApiEventHandler(apiRef, "sortedRowsSet", runIfRowSelectionIsEnabled(removeOutdatedSelection));
  useGridApiEventHandler(apiRef, "rowClick", runIfRowSelectionIsEnabled(handleRowClick));
  useGridApiEventHandler(apiRef, "rowSelectionCheckboxChange", runIfRowSelectionIsEnabled(handleRowSelectionCheckboxChange));
  useGridApiEventHandler(apiRef, "headerSelectionCheckboxChange", handleHeaderSelectionCheckboxChange);
  useGridApiEventHandler(apiRef, "cellMouseDown", runIfRowSelectionIsEnabled(preventSelectionOnShift));
  useGridApiEventHandler(apiRef, "cellKeyDown", runIfRowSelectionIsEnabled(handleCellKeyDown));
  reactExports.useEffect(() => {
    if (propRowSelectionModel !== void 0) {
      apiRef.current.setRowSelectionModel(propRowSelectionModel);
    }
  }, [apiRef, propRowSelectionModel, props.rowSelection]);
  reactExports.useEffect(() => {
    if (!props.rowSelection) {
      apiRef.current.setRowSelectionModel([]);
    }
  }, [apiRef, props.rowSelection]);
  const isStateControlled = propRowSelectionModel != null;
  reactExports.useEffect(() => {
    if (isStateControlled || !props.rowSelection) {
      return;
    }
    const currentSelection = gridRowSelectionStateSelector(apiRef.current.state);
    if (isRowSelectable) {
      const newSelection = currentSelection.filter((id2) => isRowSelectable(id2));
      if (newSelection.length < currentSelection.length) {
        apiRef.current.setRowSelectionModel(newSelection);
      }
    }
  }, [apiRef, isRowSelectable, isStateControlled, props.rowSelection]);
  reactExports.useEffect(() => {
    if (!props.rowSelection || isStateControlled) {
      return;
    }
    const currentSelection = gridRowSelectionStateSelector(apiRef.current.state);
    if (!canHaveMultipleSelection && currentSelection.length > 1) {
      apiRef.current.setRowSelectionModel([]);
    }
  }, [apiRef, canHaveMultipleSelection, checkboxSelection, isStateControlled, props.rowSelection]);
};
const GRID_DEFAULT_LOCALE_TEXT = {
  // Root
  noRowsLabel: "No rows",
  noResultsOverlayLabel: "No results found.",
  // Density selector toolbar button text
  toolbarDensity: "Density",
  toolbarDensityLabel: "Density",
  toolbarDensityCompact: "Compact",
  toolbarDensityStandard: "Standard",
  toolbarDensityComfortable: "Comfortable",
  // Columns selector toolbar button text
  toolbarColumns: "Columns",
  toolbarColumnsLabel: "Select columns",
  // Filters toolbar button text
  toolbarFilters: "Filters",
  toolbarFiltersLabel: "Show filters",
  toolbarFiltersTooltipHide: "Hide filters",
  toolbarFiltersTooltipShow: "Show filters",
  toolbarFiltersTooltipActive: (count) => count !== 1 ? `${count} active filters` : `${count} active filter`,
  // Quick filter toolbar field
  toolbarQuickFilterPlaceholder: "Search…",
  toolbarQuickFilterLabel: "Search",
  toolbarQuickFilterDeleteIconLabel: "Clear",
  // Export selector toolbar button text
  toolbarExport: "Export",
  toolbarExportLabel: "Export",
  toolbarExportCSV: "Download as CSV",
  toolbarExportPrint: "Print",
  toolbarExportExcel: "Download as Excel",
  // Columns panel text
  columnsPanelTextFieldLabel: "Find column",
  columnsPanelTextFieldPlaceholder: "Column title",
  columnsPanelDragIconLabel: "Reorder column",
  columnsPanelShowAllButton: "Show all",
  columnsPanelHideAllButton: "Hide all",
  // Filter panel text
  filterPanelAddFilter: "Add filter",
  filterPanelRemoveAll: "Remove all",
  filterPanelDeleteIconLabel: "Delete",
  filterPanelLogicOperator: "Logic operator",
  filterPanelOperator: "Operator",
  filterPanelOperatorAnd: "And",
  filterPanelOperatorOr: "Or",
  filterPanelColumns: "Columns",
  filterPanelInputLabel: "Value",
  filterPanelInputPlaceholder: "Filter value",
  // Filter operators text
  filterOperatorContains: "contains",
  filterOperatorEquals: "equals",
  filterOperatorStartsWith: "starts with",
  filterOperatorEndsWith: "ends with",
  filterOperatorIs: "is",
  filterOperatorNot: "is not",
  filterOperatorAfter: "is after",
  filterOperatorOnOrAfter: "is on or after",
  filterOperatorBefore: "is before",
  filterOperatorOnOrBefore: "is on or before",
  filterOperatorIsEmpty: "is empty",
  filterOperatorIsNotEmpty: "is not empty",
  filterOperatorIsAnyOf: "is any of",
  "filterOperator=": "=",
  "filterOperator!=": "!=",
  "filterOperator>": ">",
  "filterOperator>=": ">=",
  "filterOperator<": "<",
  "filterOperator<=": "<=",
  // Header filter operators text
  headerFilterOperatorContains: "Contains",
  headerFilterOperatorEquals: "Equals",
  headerFilterOperatorStartsWith: "Starts with",
  headerFilterOperatorEndsWith: "Ends with",
  headerFilterOperatorIs: "Is",
  headerFilterOperatorNot: "Is not",
  headerFilterOperatorAfter: "Is after",
  headerFilterOperatorOnOrAfter: "Is on or after",
  headerFilterOperatorBefore: "Is before",
  headerFilterOperatorOnOrBefore: "Is on or before",
  headerFilterOperatorIsEmpty: "Is empty",
  headerFilterOperatorIsNotEmpty: "Is not empty",
  headerFilterOperatorIsAnyOf: "Is any of",
  "headerFilterOperator=": "Equals",
  "headerFilterOperator!=": "Not equals",
  "headerFilterOperator>": "Greater than",
  "headerFilterOperator>=": "Greater than or equal to",
  "headerFilterOperator<": "Less than",
  "headerFilterOperator<=": "Less than or equal to",
  // Filter values text
  filterValueAny: "any",
  filterValueTrue: "true",
  filterValueFalse: "false",
  // Column menu text
  columnMenuLabel: "Menu",
  columnMenuShowColumns: "Show columns",
  columnMenuManageColumns: "Manage columns",
  columnMenuFilter: "Filter",
  columnMenuHideColumn: "Hide column",
  columnMenuUnsort: "Unsort",
  columnMenuSortAsc: "Sort by ASC",
  columnMenuSortDesc: "Sort by DESC",
  // Column header text
  columnHeaderFiltersTooltipActive: (count) => count !== 1 ? `${count} active filters` : `${count} active filter`,
  columnHeaderFiltersLabel: "Show filters",
  columnHeaderSortIconLabel: "Sort",
  // Rows selected footer text
  footerRowSelected: (count) => count !== 1 ? `${count.toLocaleString()} rows selected` : `${count.toLocaleString()} row selected`,
  // Total row amount footer text
  footerTotalRows: "Total Rows:",
  // Total visible row amount footer text
  footerTotalVisibleRows: (visibleCount, totalCount) => `${visibleCount.toLocaleString()} of ${totalCount.toLocaleString()}`,
  // Checkbox selection text
  checkboxSelectionHeaderName: "Checkbox selection",
  checkboxSelectionSelectAllRows: "Select all rows",
  checkboxSelectionUnselectAllRows: "Unselect all rows",
  checkboxSelectionSelectRow: "Select row",
  checkboxSelectionUnselectRow: "Unselect row",
  // Boolean cell text
  booleanCellTrueLabel: "yes",
  booleanCellFalseLabel: "no",
  // Actions cell more text
  actionsCellMore: "more",
  // Column pinning text
  pinToLeft: "Pin to left",
  pinToRight: "Pin to right",
  unpin: "Unpin",
  // Tree Data
  treeDataGroupingHeaderName: "Group",
  treeDataExpand: "see children",
  treeDataCollapse: "hide children",
  // Grouping columns
  groupingColumnHeaderName: "Group",
  groupColumn: (name) => `Group by ${name}`,
  unGroupColumn: (name) => `Stop grouping by ${name}`,
  // Master/detail
  detailPanelToggle: "Detail panel toggle",
  expandDetailPanel: "Expand",
  collapseDetailPanel: "Collapse",
  // Used core components translation keys
  MuiTablePagination: {},
  // Row reordering text
  rowReorderingHeaderName: "Row reordering",
  // Aggregation
  aggregationMenuItemHeader: "Aggregation",
  aggregationFunctionLabelSum: "sum",
  aggregationFunctionLabelAvg: "avg",
  aggregationFunctionLabelMin: "min",
  aggregationFunctionLabelMax: "max",
  aggregationFunctionLabelSize: "size"
};
const useUtilityClasses$m = (ownerState) => {
  const {
    classes
  } = ownerState;
  return reactExports.useMemo(() => {
    const slots = {
      cellCheckbox: ["cellCheckbox"],
      columnHeaderCheckbox: ["columnHeaderCheckbox"]
    };
    return composeClasses(slots, getDataGridUtilityClass, classes);
  }, [classes]);
};
const useGridRowSelectionPreProcessors = (apiRef, props) => {
  const ownerState = {
    classes: props.classes
  };
  const classes = useUtilityClasses$m(ownerState);
  const updateSelectionColumn = reactExports.useCallback((columnsState) => {
    const selectionColumn = _extends$2({}, GRID_CHECKBOX_SELECTION_COL_DEF, {
      cellClassName: classes.cellCheckbox,
      headerClassName: classes.columnHeaderCheckbox,
      headerName: apiRef.current.getLocaleText("checkboxSelectionHeaderName")
    });
    const shouldHaveSelectionColumn = props.checkboxSelection;
    const haveSelectionColumn = columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD] != null;
    if (shouldHaveSelectionColumn && !haveSelectionColumn) {
      columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD] = selectionColumn;
      columnsState.orderedFields = [GRID_CHECKBOX_SELECTION_FIELD, ...columnsState.orderedFields];
    } else if (!shouldHaveSelectionColumn && haveSelectionColumn) {
      delete columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD];
      columnsState.orderedFields = columnsState.orderedFields.filter((field) => field !== GRID_CHECKBOX_SELECTION_FIELD);
    } else if (shouldHaveSelectionColumn && haveSelectionColumn) {
      columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD] = _extends$2({}, selectionColumn, columnsState.lookup[GRID_CHECKBOX_SELECTION_FIELD]);
    }
    return columnsState;
  }, [apiRef, classes, props.checkboxSelection]);
  useGridRegisterPipeProcessor(apiRef, "hydrateColumns", updateSelectionColumn);
};
const sortingStateInitializer = (state, props) => {
  var _ref, _props$sortModel, _props$initialState;
  const sortModel = (_ref = (_props$sortModel = props.sortModel) != null ? _props$sortModel : (_props$initialState = props.initialState) == null || (_props$initialState = _props$initialState.sorting) == null ? void 0 : _props$initialState.sortModel) != null ? _ref : [];
  return _extends$2({}, state, {
    sorting: {
      sortModel: sanitizeSortModel(sortModel, props.disableMultipleColumnsSorting),
      sortedRows: []
    }
  });
};
const useGridSorting = (apiRef, props) => {
  var _props$initialState3;
  const logger = useGridLogger(apiRef, "useGridSorting");
  apiRef.current.registerControlState({
    stateId: "sortModel",
    propModel: props.sortModel,
    propOnChange: props.onSortModelChange,
    stateSelector: gridSortModelSelector,
    changeEvent: "sortModelChange"
  });
  const upsertSortModel = reactExports.useCallback((field, sortItem) => {
    const sortModel = gridSortModelSelector(apiRef);
    const existingIdx = sortModel.findIndex((c2) => c2.field === field);
    let newSortModel = [...sortModel];
    if (existingIdx > -1) {
      if (!sortItem) {
        newSortModel.splice(existingIdx, 1);
      } else {
        newSortModel.splice(existingIdx, 1, sortItem);
      }
    } else {
      newSortModel = [...sortModel, sortItem];
    }
    return newSortModel;
  }, [apiRef]);
  const createSortItem = reactExports.useCallback((col, directionOverride) => {
    var _col$sortingOrder2;
    const sortModel = gridSortModelSelector(apiRef);
    const existing = sortModel.find((c2) => c2.field === col.field);
    if (existing) {
      var _col$sortingOrder;
      const nextSort = directionOverride === void 0 ? getNextGridSortDirection((_col$sortingOrder = col.sortingOrder) != null ? _col$sortingOrder : props.sortingOrder, existing.sort) : directionOverride;
      return nextSort == null ? void 0 : _extends$2({}, existing, {
        sort: nextSort
      });
    }
    return {
      field: col.field,
      sort: directionOverride === void 0 ? getNextGridSortDirection((_col$sortingOrder2 = col.sortingOrder) != null ? _col$sortingOrder2 : props.sortingOrder) : directionOverride
    };
  }, [apiRef, props.sortingOrder]);
  const addColumnMenuItem = reactExports.useCallback((columnMenuItems, colDef) => {
    if (colDef == null || colDef.sortable === false) {
      return columnMenuItems;
    }
    const sortingOrder = colDef.sortingOrder || props.sortingOrder;
    if (sortingOrder.some((item) => !!item)) {
      return [...columnMenuItems, "columnMenuSortItem"];
    }
    return columnMenuItems;
  }, [props.sortingOrder]);
  const applySorting = reactExports.useCallback(() => {
    apiRef.current.setState((state) => {
      if (props.sortingMode === "server") {
        logger.debug("Skipping sorting rows as sortingMode = server");
        return _extends$2({}, state, {
          sorting: _extends$2({}, state.sorting, {
            sortedRows: getTreeNodeDescendants(gridRowTreeSelector(apiRef), GRID_ROOT_GROUP_ID, false)
          })
        });
      }
      const sortModel = gridSortModelSelector(state, apiRef.current.instanceId);
      const sortRowList = buildAggregatedSortingApplier(sortModel, apiRef);
      const sortedRows = apiRef.current.applyStrategyProcessor("sorting", {
        sortRowList
      });
      return _extends$2({}, state, {
        sorting: _extends$2({}, state.sorting, {
          sortedRows
        })
      });
    });
    apiRef.current.publishEvent("sortedRowsSet");
    apiRef.current.forceUpdate();
  }, [apiRef, logger, props.sortingMode]);
  const setSortModel = reactExports.useCallback((model) => {
    const currentModel = gridSortModelSelector(apiRef);
    if (currentModel !== model) {
      logger.debug(`Setting sort model`);
      apiRef.current.setState(mergeStateWithSortModel(model, props.disableMultipleColumnsSorting));
      apiRef.current.forceUpdate();
      apiRef.current.applySorting();
    }
  }, [apiRef, logger, props.disableMultipleColumnsSorting]);
  const sortColumn = reactExports.useCallback((column2, direction2, allowMultipleSorting) => {
    if (!column2.sortable) {
      return;
    }
    const sortItem = createSortItem(column2, direction2);
    let sortModel;
    if (!allowMultipleSorting || props.disableMultipleColumnsSorting) {
      sortModel = !sortItem ? [] : [sortItem];
    } else {
      sortModel = upsertSortModel(column2.field, sortItem);
    }
    apiRef.current.setSortModel(sortModel);
  }, [apiRef, upsertSortModel, createSortItem, props.disableMultipleColumnsSorting]);
  const getSortModel = reactExports.useCallback(() => gridSortModelSelector(apiRef), [apiRef]);
  const getSortedRows = reactExports.useCallback(() => {
    const sortedRows = gridSortedRowEntriesSelector(apiRef);
    return sortedRows.map((row) => row.model);
  }, [apiRef]);
  const getSortedRowIds = reactExports.useCallback(() => gridSortedRowIdsSelector(apiRef), [apiRef]);
  const getRowIdFromRowIndex = reactExports.useCallback((index2) => apiRef.current.getSortedRowIds()[index2], [apiRef]);
  const sortApi = {
    getSortModel,
    getSortedRows,
    getSortedRowIds,
    getRowIdFromRowIndex,
    setSortModel,
    sortColumn,
    applySorting
  };
  useGridApiMethod(apiRef, sortApi, "public");
  const stateExportPreProcessing = reactExports.useCallback((prevState, context) => {
    var _props$initialState2;
    const sortModelToExport = gridSortModelSelector(apiRef);
    const shouldExportSortModel = (
      // Always export if the `exportOnlyDirtyModels` property is not activated
      !context.exportOnlyDirtyModels || // Always export if the model is controlled
      props.sortModel != null || // Always export if the model has been initialized
      ((_props$initialState2 = props.initialState) == null || (_props$initialState2 = _props$initialState2.sorting) == null ? void 0 : _props$initialState2.sortModel) != null || // Export if the model is not empty
      sortModelToExport.length > 0
    );
    if (!shouldExportSortModel) {
      return prevState;
    }
    return _extends$2({}, prevState, {
      sorting: {
        sortModel: sortModelToExport
      }
    });
  }, [apiRef, props.sortModel, (_props$initialState3 = props.initialState) == null || (_props$initialState3 = _props$initialState3.sorting) == null ? void 0 : _props$initialState3.sortModel]);
  const stateRestorePreProcessing = reactExports.useCallback((params, context) => {
    var _context$stateToResto;
    const sortModel = (_context$stateToResto = context.stateToRestore.sorting) == null ? void 0 : _context$stateToResto.sortModel;
    if (sortModel == null) {
      return params;
    }
    apiRef.current.setState(mergeStateWithSortModel(sortModel, props.disableMultipleColumnsSorting));
    return _extends$2({}, params, {
      callbacks: [...params.callbacks, apiRef.current.applySorting]
    });
  }, [apiRef, props.disableMultipleColumnsSorting]);
  const flatSortingMethod = reactExports.useCallback((params) => {
    const rowTree = gridRowTreeSelector(apiRef);
    const rootGroupNode = rowTree[GRID_ROOT_GROUP_ID];
    const sortedChildren = params.sortRowList ? params.sortRowList(rootGroupNode.children.map((childId) => rowTree[childId])) : [...rootGroupNode.children];
    if (rootGroupNode.footerId != null) {
      sortedChildren.push(rootGroupNode.footerId);
    }
    return sortedChildren;
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPipeProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  useGridRegisterStrategyProcessor(apiRef, GRID_DEFAULT_STRATEGY, "sorting", flatSortingMethod);
  const handleColumnHeaderClick = reactExports.useCallback(({
    colDef
  }, event) => {
    const allowMultipleSorting = event.shiftKey || event.metaKey || event.ctrlKey;
    sortColumn(colDef, void 0, allowMultipleSorting);
  }, [sortColumn]);
  const handleColumnHeaderKeyDown = reactExports.useCallback(({
    colDef
  }, event) => {
    if (isEnterKey(event.key) && !event.ctrlKey && !event.metaKey) {
      sortColumn(colDef, void 0, event.shiftKey);
    }
  }, [sortColumn]);
  const handleColumnsChange = reactExports.useCallback(() => {
    const sortModel = gridSortModelSelector(apiRef);
    const latestColumns = gridColumnLookupSelector(apiRef);
    if (sortModel.length > 0) {
      const newModel = sortModel.filter((sortItem) => latestColumns[sortItem.field]);
      if (newModel.length < sortModel.length) {
        apiRef.current.setSortModel(newModel);
      }
    }
  }, [apiRef]);
  const handleStrategyProcessorChange = reactExports.useCallback((methodName) => {
    if (methodName === "sorting") {
      apiRef.current.applySorting();
    }
  }, [apiRef]);
  useGridRegisterPipeProcessor(apiRef, "columnMenu", addColumnMenuItem);
  useGridApiEventHandler(apiRef, "columnHeaderClick", handleColumnHeaderClick);
  useGridApiEventHandler(apiRef, "columnHeaderKeyDown", handleColumnHeaderKeyDown);
  useGridApiEventHandler(apiRef, "rowsSet", apiRef.current.applySorting);
  useGridApiEventHandler(apiRef, "columnsChange", handleColumnsChange);
  useGridApiEventHandler(apiRef, "activeStrategyProcessorChange", handleStrategyProcessorChange);
  useFirstRender(() => {
    apiRef.current.applySorting();
  });
  useEnhancedEffect$1(() => {
    if (props.sortModel !== void 0) {
      apiRef.current.setSortModel(props.sortModel);
    }
  }, [apiRef, props.sortModel]);
};
function scrollIntoView(dimensions) {
  const {
    clientHeight,
    scrollTop,
    offsetHeight,
    offsetTop
  } = dimensions;
  const elementBottom = offsetTop + offsetHeight;
  if (offsetHeight > clientHeight) {
    return offsetTop;
  }
  if (elementBottom - clientHeight > scrollTop) {
    return elementBottom - clientHeight;
  }
  if (offsetTop < scrollTop) {
    return offsetTop;
  }
  return void 0;
}
const useGridScroll = (apiRef, props) => {
  const theme2 = useTheme();
  const logger = useGridLogger(apiRef, "useGridScroll");
  const colRef = apiRef.current.columnHeadersElementRef;
  const virtualScrollerRef = apiRef.current.virtualScrollerRef;
  const visibleSortedRows = useGridSelector(apiRef, gridExpandedSortedRowEntriesSelector);
  const scrollToIndexes = reactExports.useCallback((params) => {
    const totalRowCount = gridRowCountSelector(apiRef);
    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
    const scrollToHeader = params.rowIndex == null;
    if (!scrollToHeader && totalRowCount === 0 || visibleColumns.length === 0) {
      return false;
    }
    logger.debug(`Scrolling to cell at row ${params.rowIndex}, col: ${params.colIndex} `);
    let scrollCoordinates = {};
    if (params.colIndex != null) {
      const columnPositions = gridColumnPositionsSelector(apiRef);
      let cellWidth;
      if (typeof params.rowIndex !== "undefined") {
        var _visibleSortedRows$pa;
        const rowId = (_visibleSortedRows$pa = visibleSortedRows[params.rowIndex]) == null ? void 0 : _visibleSortedRows$pa.id;
        const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, params.colIndex);
        if (cellColSpanInfo && !cellColSpanInfo.spannedByColSpan) {
          cellWidth = cellColSpanInfo.cellProps.width;
        }
      }
      if (typeof cellWidth === "undefined") {
        cellWidth = visibleColumns[params.colIndex].computedWidth;
      }
      scrollCoordinates.left = scrollIntoView({
        clientHeight: virtualScrollerRef.current.clientWidth,
        scrollTop: Math.abs(virtualScrollerRef.current.scrollLeft),
        offsetHeight: cellWidth,
        offsetTop: columnPositions[params.colIndex]
      });
    }
    if (params.rowIndex != null) {
      var _querySelector, _querySelector2;
      const rowsMeta = gridRowsMetaSelector(apiRef.current.state);
      const page = gridPageSelector(apiRef);
      const pageSize2 = gridPageSizeSelector(apiRef);
      const elementIndex = !props.pagination ? params.rowIndex : params.rowIndex - page * pageSize2;
      const targetOffsetHeight = rowsMeta.positions[elementIndex + 1] ? rowsMeta.positions[elementIndex + 1] - rowsMeta.positions[elementIndex] : rowsMeta.currentPageTotalHeight - rowsMeta.positions[elementIndex];
      const topPinnedRowsHeight = ((_querySelector = virtualScrollerRef.current.querySelector(`.${gridClasses["pinnedRows--top"]}`)) == null ? void 0 : _querySelector.clientHeight) || 0;
      const bottomPinnedRowsHeight = ((_querySelector2 = virtualScrollerRef.current.querySelector(`.${gridClasses["pinnedRows--bottom"]}`)) == null ? void 0 : _querySelector2.clientHeight) || 0;
      scrollCoordinates.top = scrollIntoView({
        clientHeight: virtualScrollerRef.current.clientHeight - topPinnedRowsHeight - bottomPinnedRowsHeight,
        scrollTop: virtualScrollerRef.current.scrollTop,
        offsetHeight: targetOffsetHeight,
        offsetTop: rowsMeta.positions[elementIndex]
      });
    }
    scrollCoordinates = apiRef.current.unstable_applyPipeProcessors("scrollToIndexes", scrollCoordinates, params);
    if (typeof scrollCoordinates.left !== void 0 || typeof scrollCoordinates.top !== void 0) {
      apiRef.current.scroll(scrollCoordinates);
      return true;
    }
    return false;
  }, [logger, apiRef, virtualScrollerRef, props.pagination, visibleSortedRows]);
  const scroll = reactExports.useCallback((params) => {
    if (virtualScrollerRef.current && params.left != null && colRef.current) {
      const direction2 = theme2.direction === "rtl" ? -1 : 1;
      colRef.current.scrollLeft = params.left;
      virtualScrollerRef.current.scrollLeft = direction2 * params.left;
      logger.debug(`Scrolling left: ${params.left}`);
    }
    if (virtualScrollerRef.current && params.top != null) {
      virtualScrollerRef.current.scrollTop = params.top;
      logger.debug(`Scrolling top: ${params.top}`);
    }
    logger.debug(`Scrolling, updating container, and viewport`);
  }, [virtualScrollerRef, theme2.direction, colRef, logger]);
  const getScrollPosition = reactExports.useCallback(() => {
    if (!(virtualScrollerRef != null && virtualScrollerRef.current)) {
      return {
        top: 0,
        left: 0
      };
    }
    return {
      top: virtualScrollerRef.current.scrollTop,
      left: virtualScrollerRef.current.scrollLeft
    };
  }, [virtualScrollerRef]);
  const scrollApi = {
    scroll,
    scrollToIndexes,
    getScrollPosition
  };
  useGridApiMethod(apiRef, scrollApi, "public");
};
function useGridEvents(apiRef, props) {
  useGridApiOptionHandler(apiRef, "columnHeaderClick", props.onColumnHeaderClick);
  useGridApiOptionHandler(apiRef, "columnHeaderDoubleClick", props.onColumnHeaderDoubleClick);
  useGridApiOptionHandler(apiRef, "columnHeaderOver", props.onColumnHeaderOver);
  useGridApiOptionHandler(apiRef, "columnHeaderOut", props.onColumnHeaderOut);
  useGridApiOptionHandler(apiRef, "columnHeaderEnter", props.onColumnHeaderEnter);
  useGridApiOptionHandler(apiRef, "columnHeaderLeave", props.onColumnHeaderLeave);
  useGridApiOptionHandler(apiRef, "cellClick", props.onCellClick);
  useGridApiOptionHandler(apiRef, "cellDoubleClick", props.onCellDoubleClick);
  useGridApiOptionHandler(apiRef, "cellKeyDown", props.onCellKeyDown);
  useGridApiOptionHandler(apiRef, "preferencePanelClose", props.onPreferencePanelClose);
  useGridApiOptionHandler(apiRef, "preferencePanelOpen", props.onPreferencePanelOpen);
  useGridApiOptionHandler(apiRef, "menuOpen", props.onMenuOpen);
  useGridApiOptionHandler(apiRef, "menuClose", props.onMenuClose);
  useGridApiOptionHandler(apiRef, "rowDoubleClick", props.onRowDoubleClick);
  useGridApiOptionHandler(apiRef, "rowClick", props.onRowClick);
  useGridApiOptionHandler(apiRef, "stateChange", props.onStateChange);
}
const hasScroll = ({
  content: content2,
  container,
  scrollBarSize
}) => {
  const hasScrollXIfNoYScrollBar = content2.width > container.width;
  const hasScrollYIfNoXScrollBar = content2.height > container.height;
  let hasScrollX = false;
  let hasScrollY = false;
  if (hasScrollXIfNoYScrollBar || hasScrollYIfNoXScrollBar) {
    hasScrollX = hasScrollXIfNoYScrollBar;
    hasScrollY = content2.height + (hasScrollX ? scrollBarSize : 0) > container.height;
    if (hasScrollY) {
      hasScrollX = content2.width + scrollBarSize > container.width;
    }
  }
  return {
    hasScrollX,
    hasScrollY
  };
};
function useGridDimensions(apiRef, props) {
  const logger = useGridLogger(apiRef, "useResizeContainer");
  const errorShown = reactExports.useRef(false);
  const rootDimensionsRef = reactExports.useRef(null);
  const fullDimensionsRef = reactExports.useRef(null);
  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);
  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);
  const rowHeight = Math.floor(props.rowHeight * densityFactor);
  const totalHeaderHeight = getTotalHeaderHeight(apiRef, props.columnHeaderHeight);
  const updateGridDimensionsRef = reactExports.useCallback(() => {
    var _apiRef$current$rootE;
    const rootElement = (_apiRef$current$rootE = apiRef.current.rootElementRef) == null ? void 0 : _apiRef$current$rootE.current;
    const columnsTotalWidth = gridColumnsTotalWidthSelector(apiRef);
    const pinnedRowsHeight = calculatePinnedRowsHeight(apiRef);
    if (!rootDimensionsRef.current) {
      return;
    }
    let scrollBarSize;
    if (props.scrollbarSize != null) {
      scrollBarSize = props.scrollbarSize;
    } else if (!columnsTotalWidth || !rootElement) {
      scrollBarSize = 0;
    } else {
      const doc = ownerDocument(rootElement);
      const scrollDiv = doc.createElement("div");
      scrollDiv.style.width = "99px";
      scrollDiv.style.height = "99px";
      scrollDiv.style.position = "absolute";
      scrollDiv.style.overflow = "scroll";
      scrollDiv.className = "scrollDiv";
      rootElement.appendChild(scrollDiv);
      scrollBarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      rootElement.removeChild(scrollDiv);
    }
    let viewportOuterSize;
    let hasScrollX;
    let hasScrollY;
    if (props.autoHeight) {
      hasScrollY = false;
      hasScrollX = Math.round(columnsTotalWidth) > Math.round(rootDimensionsRef.current.width);
      viewportOuterSize = {
        width: rootDimensionsRef.current.width,
        height: rowsMeta.currentPageTotalHeight + (hasScrollX ? scrollBarSize : 0)
      };
    } else {
      viewportOuterSize = {
        width: rootDimensionsRef.current.width,
        height: Math.max(rootDimensionsRef.current.height - totalHeaderHeight, 0)
      };
      const scrollInformation = hasScroll({
        content: {
          width: Math.round(columnsTotalWidth),
          height: rowsMeta.currentPageTotalHeight
        },
        container: {
          width: Math.round(viewportOuterSize.width),
          height: viewportOuterSize.height - pinnedRowsHeight.top - pinnedRowsHeight.bottom
        },
        scrollBarSize
      });
      hasScrollY = scrollInformation.hasScrollY;
      hasScrollX = scrollInformation.hasScrollX;
    }
    const viewportInnerSize = {
      width: viewportOuterSize.width - (hasScrollY ? scrollBarSize : 0),
      height: viewportOuterSize.height - (hasScrollX ? scrollBarSize : 0)
    };
    const newFullDimensions = {
      viewportOuterSize,
      viewportInnerSize,
      hasScrollX,
      hasScrollY,
      scrollBarSize
    };
    const prevDimensions = fullDimensionsRef.current;
    fullDimensionsRef.current = newFullDimensions;
    if (newFullDimensions.viewportInnerSize.width !== (prevDimensions == null ? void 0 : prevDimensions.viewportInnerSize.width) || newFullDimensions.viewportInnerSize.height !== (prevDimensions == null ? void 0 : prevDimensions.viewportInnerSize.height)) {
      apiRef.current.publishEvent("viewportInnerSizeChange", newFullDimensions.viewportInnerSize);
    }
  }, [apiRef, props.scrollbarSize, props.autoHeight, rowsMeta.currentPageTotalHeight, totalHeaderHeight]);
  const [savedSize, setSavedSize] = reactExports.useState();
  const debouncedSetSavedSize = reactExports.useMemo(() => debounce$1(setSavedSize, 60), []);
  const previousSize = reactExports.useRef();
  useEnhancedEffect$1(() => {
    if (savedSize) {
      updateGridDimensionsRef();
      apiRef.current.publishEvent("debouncedResize", rootDimensionsRef.current);
    }
  }, [apiRef, savedSize, updateGridDimensionsRef]);
  const resize = reactExports.useCallback(() => {
    apiRef.current.computeSizeAndPublishResizeEvent();
  }, [apiRef]);
  const getRootDimensions = reactExports.useCallback(() => fullDimensionsRef.current, []);
  const getViewportPageSize = reactExports.useCallback(() => {
    const dimensions = apiRef.current.getRootDimensions();
    if (!dimensions) {
      return 0;
    }
    const currentPage = getVisibleRows(apiRef, {
      pagination: props.pagination,
      paginationMode: props.paginationMode
    });
    if (props.getRowHeight) {
      const renderContext = apiRef.current.getRenderContext();
      const viewportPageSize = renderContext.lastRowIndex - renderContext.firstRowIndex;
      return Math.min(viewportPageSize - 1, currentPage.rows.length);
    }
    const maximumPageSizeWithoutScrollBar = Math.floor(dimensions.viewportInnerSize.height / rowHeight);
    return Math.min(maximumPageSizeWithoutScrollBar, currentPage.rows.length);
  }, [apiRef, props.pagination, props.paginationMode, props.getRowHeight, rowHeight]);
  const computeSizeAndPublishResizeEvent = reactExports.useCallback(() => {
    var _apiRef$current$mainE, _previousSize$current, _previousSize$current2;
    const mainEl = (_apiRef$current$mainE = apiRef.current.mainElementRef) == null ? void 0 : _apiRef$current$mainE.current;
    if (!mainEl) {
      return;
    }
    const win = ownerWindow(mainEl);
    const computedStyle = win.getComputedStyle(mainEl);
    const height2 = parseFloat(computedStyle.height) || 0;
    const width2 = parseFloat(computedStyle.width) || 0;
    const hasHeightChanged = height2 !== ((_previousSize$current = previousSize.current) == null ? void 0 : _previousSize$current.height);
    const hasWidthChanged = width2 !== ((_previousSize$current2 = previousSize.current) == null ? void 0 : _previousSize$current2.width);
    if (!previousSize.current || hasHeightChanged || hasWidthChanged) {
      const size = {
        width: width2,
        height: height2
      };
      apiRef.current.publishEvent("resize", size);
      previousSize.current = size;
    }
  }, [apiRef]);
  const dimensionsApi = {
    resize,
    getRootDimensions
  };
  const dimensionsPrivateApi = {
    getViewportPageSize,
    updateGridDimensionsRef,
    computeSizeAndPublishResizeEvent
  };
  useGridApiMethod(apiRef, dimensionsApi, "public");
  useGridApiMethod(apiRef, dimensionsPrivateApi, "private");
  const isFirstSizing = reactExports.useRef(true);
  const handleResize = reactExports.useCallback((size) => {
    rootDimensionsRef.current = size;
    const isJSDOM = /jsdom/.test(window.navigator.userAgent);
    if (size.height === 0 && !errorShown.current && !props.autoHeight && !isJSDOM) {
      logger.error(["The parent DOM element of the data grid has an empty height.", "Please make sure that this element has an intrinsic height.", "The grid displays with a height of 0px.", "", "More details: https://mui.com/r/x-data-grid-no-dimensions."].join("\n"));
      errorShown.current = true;
    }
    if (size.width === 0 && !errorShown.current && !isJSDOM) {
      logger.error(["The parent DOM element of the data grid has an empty width.", "Please make sure that this element has an intrinsic width.", "The grid displays with a width of 0px.", "", "More details: https://mui.com/r/x-data-grid-no-dimensions."].join("\n"));
      errorShown.current = true;
    }
    if (isFirstSizing.current) {
      setSavedSize(size);
      isFirstSizing.current = false;
      return;
    }
    debouncedSetSavedSize(size);
  }, [props.autoHeight, debouncedSetSavedSize, logger]);
  useEnhancedEffect$1(() => updateGridDimensionsRef(), [updateGridDimensionsRef]);
  useGridApiOptionHandler(apiRef, "sortedRowsSet", updateGridDimensionsRef);
  useGridApiOptionHandler(apiRef, "paginationModelChange", updateGridDimensionsRef);
  useGridApiOptionHandler(apiRef, "columnsChange", updateGridDimensionsRef);
  useGridApiEventHandler(apiRef, "resize", handleResize);
  useGridApiOptionHandler(apiRef, "debouncedResize", props.onResize);
}
const _excluded$w = ["style"], _excluded2$6 = ["style"];
function binarySearch(offset2, positions, sliceStart = 0, sliceEnd = positions.length) {
  if (positions.length <= 0) {
    return -1;
  }
  if (sliceStart >= sliceEnd) {
    return sliceStart;
  }
  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);
  const itemOffset = positions[pivot];
  return offset2 <= itemOffset ? binarySearch(offset2, positions, sliceStart, pivot) : binarySearch(offset2, positions, pivot + 1, sliceEnd);
}
function exponentialSearch(offset2, positions, index2) {
  let interval = 1;
  while (index2 < positions.length && Math.abs(positions[index2]) < offset2) {
    index2 += interval;
    interval *= 2;
  }
  return binarySearch(offset2, positions, Math.floor(index2 / 2), Math.min(index2, positions.length));
}
const getRenderableIndexes = ({
  firstIndex,
  lastIndex,
  buffer,
  minFirstIndex,
  maxLastIndex
}) => {
  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];
};
const areRenderContextsEqual = (context1, context2) => {
  if (context1 === context2) {
    return true;
  }
  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;
};
const MEMOIZE_OPTIONS = {
  maxSize: 3
};
const useGridVirtualScroller = (props) => {
  var _currentPage$range3, _currentPage$range4;
  const apiRef = useGridPrivateApiContext();
  const rootProps = useGridRootProps();
  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const enabled = useGridSelector(apiRef, gridVirtualizationEnabledSelector);
  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector);
  const {
    ref,
    onRenderZonePositioning,
    renderZoneMinColumnIndex = 0,
    renderZoneMaxColumnIndex = visibleColumns.length,
    getRowProps
  } = props;
  const theme2 = useTheme();
  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);
  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);
  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);
  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);
  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);
  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);
  const currentPage = useGridVisibleRows(apiRef, rootProps);
  const renderZoneRef = reactExports.useRef(null);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, rootRef);
  const [renderContext, setRenderContextState] = reactExports.useState(null);
  const prevRenderContext = reactExports.useRef(renderContext);
  const scrollPosition = reactExports.useRef({
    top: 0,
    left: 0
  });
  const [containerDimensions, setContainerDimensions] = reactExports.useState({
    width: null,
    height: null
  });
  const prevTotalWidth = reactExports.useRef(columnsTotalWidth);
  const [hoveredRowId, setHoveredRowId] = reactExports.useState(null);
  const rowStyleCache = reactExports.useRef(/* @__PURE__ */ Object.create(null));
  const prevGetRowProps = reactExports.useRef();
  const prevRootRowStyle = reactExports.useRef();
  const getRenderedColumnsRef = reactExports.useRef(defaultMemoize((columns, firstColumnToRender, lastColumnToRender, minFirstColumn, maxLastColumn, indexOfColumnWithFocusedCell2) => {
    let focusedCellColumnIndexNotInRange;
    const renderedColumns = columns.slice(firstColumnToRender, lastColumnToRender);
    if (indexOfColumnWithFocusedCell2 > -1) {
      if (firstColumnToRender > indexOfColumnWithFocusedCell2 && indexOfColumnWithFocusedCell2 >= minFirstColumn) {
        focusedCellColumnIndexNotInRange = indexOfColumnWithFocusedCell2;
      } else if (lastColumnToRender < indexOfColumnWithFocusedCell2 && indexOfColumnWithFocusedCell2 < maxLastColumn) {
        focusedCellColumnIndexNotInRange = indexOfColumnWithFocusedCell2;
      }
    }
    return {
      focusedCellColumnIndexNotInRange,
      renderedColumns
    };
  }, MEMOIZE_OPTIONS));
  const indexOfColumnWithFocusedCell = reactExports.useMemo(() => {
    if (cellFocus !== null) {
      return visibleColumns.findIndex((column2) => column2.field === cellFocus.field);
    }
    return -1;
  }, [cellFocus, visibleColumns]);
  const getNearestIndexToRender = reactExports.useCallback((offset2) => {
    var _currentPage$range, _currentPage$range2;
    const lastMeasuredIndexRelativeToAllRows = apiRef.current.getLastMeasuredRowIndex();
    let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;
    if ((_currentPage$range = currentPage.range) != null && _currentPage$range.lastRowIndex && !allRowsMeasured) {
      allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= currentPage.range.lastRowIndex;
    }
    const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (((_currentPage$range2 = currentPage.range) == null ? void 0 : _currentPage$range2.firstRowIndex) || 0), 0, rowsMeta.positions.length);
    if (allRowsMeasured || rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset2) {
      return binarySearch(offset2, rowsMeta.positions);
    }
    return exponentialSearch(offset2, rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage);
  }, [apiRef, (_currentPage$range3 = currentPage.range) == null ? void 0 : _currentPage$range3.firstRowIndex, (_currentPage$range4 = currentPage.range) == null ? void 0 : _currentPage$range4.lastRowIndex, rowsMeta.positions]);
  const computeRenderContext = reactExports.useCallback(() => {
    if (!enabled) {
      return {
        firstRowIndex: 0,
        lastRowIndex: currentPage.rows.length,
        firstColumnIndex: 0,
        lastColumnIndex: visibleColumns.length
      };
    }
    const {
      top: top2,
      left: left2
    } = scrollPosition.current;
    const firstRowIndex = Math.min(getNearestIndexToRender(top2), rowsMeta.positions.length - 1);
    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getNearestIndexToRender(top2 + containerDimensions.height);
    let firstColumnIndex = 0;
    let lastColumnIndex = columnPositions.length;
    if (enabledForColumns) {
      let hasRowWithAutoHeight = false;
      const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
        firstIndex: firstRowIndex,
        lastIndex: lastRowIndex,
        minFirstIndex: 0,
        maxLastIndex: currentPage.rows.length,
        buffer: rootProps.rowBuffer
      });
      for (let i2 = firstRowToRender; i2 < lastRowToRender && !hasRowWithAutoHeight; i2 += 1) {
        const row = currentPage.rows[i2];
        hasRowWithAutoHeight = apiRef.current.rowHasAutoHeight(row.id);
      }
      if (!hasRowWithAutoHeight) {
        firstColumnIndex = binarySearch(Math.abs(left2), columnPositions);
        lastColumnIndex = binarySearch(Math.abs(left2) + containerDimensions.width, columnPositions);
      }
    }
    return {
      firstRowIndex,
      lastRowIndex,
      firstColumnIndex,
      lastColumnIndex
    };
  }, [enabled, enabledForColumns, getNearestIndexToRender, rowsMeta.positions.length, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerDimensions]);
  useEnhancedEffect$1(() => {
    if (enabled) {
      rootRef.current.scrollLeft = 0;
      rootRef.current.scrollTop = 0;
    } else {
      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;
    }
  }, [enabled]);
  useEnhancedEffect$1(() => {
    setContainerDimensions({
      width: rootRef.current.clientWidth,
      height: rootRef.current.clientHeight
    });
  }, [rowsMeta.currentPageTotalHeight]);
  const handleResize = reactExports.useCallback(() => {
    if (rootRef.current) {
      setContainerDimensions({
        width: rootRef.current.clientWidth,
        height: rootRef.current.clientHeight
      });
    }
  }, []);
  useGridApiEventHandler(apiRef, "debouncedResize", handleResize);
  const updateRenderZonePosition = reactExports.useCallback((nextRenderContext) => {
    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstRowIndex,
      lastIndex: nextRenderContext.lastRowIndex,
      minFirstIndex: 0,
      maxLastIndex: currentPage.rows.length,
      buffer: rootProps.rowBuffer
    });
    const [initialFirstColumnToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstColumnIndex,
      lastIndex: nextRenderContext.lastColumnIndex,
      minFirstIndex: renderZoneMinColumnIndex,
      maxLastIndex: renderZoneMaxColumnIndex,
      buffer: rootProps.columnBuffer
    });
    const firstColumnToRender = getFirstNonSpannedColumnToRender({
      firstColumnToRender: initialFirstColumnToRender,
      apiRef,
      firstRowToRender,
      lastRowToRender,
      visibleRows: currentPage.rows
    });
    const direction2 = theme2.direction === "ltr" ? 1 : -1;
    const top2 = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];
    const left2 = direction2 * gridColumnPositionsSelector(apiRef)[firstColumnToRender];
    renderZoneRef.current.style.transform = `translate3d(${left2}px, ${top2}px, 0px)`;
    if (typeof onRenderZonePositioning === "function") {
      onRenderZonePositioning({
        top: top2,
        left: left2
      });
    }
  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer, theme2.direction]);
  const getRenderContext = reactExports.useCallback(() => prevRenderContext.current, []);
  const setRenderContext = reactExports.useCallback((nextRenderContext) => {
    if (prevRenderContext.current && areRenderContextsEqual(nextRenderContext, prevRenderContext.current)) {
      updateRenderZonePosition(nextRenderContext);
      return;
    }
    setRenderContextState(nextRenderContext);
    updateRenderZonePosition(nextRenderContext);
    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstRowIndex,
      lastIndex: nextRenderContext.lastRowIndex,
      minFirstIndex: 0,
      maxLastIndex: currentPage.rows.length,
      buffer: rootProps.rowBuffer
    });
    apiRef.current.publishEvent("renderedRowsIntervalChange", {
      firstRowToRender,
      lastRowToRender
    });
    prevRenderContext.current = nextRenderContext;
  }, [apiRef, setRenderContextState, prevRenderContext, currentPage.rows.length, rootProps.rowBuffer, updateRenderZonePosition]);
  useEnhancedEffect$1(() => {
    if (containerDimensions.width == null) {
      return;
    }
    const initialRenderContext = computeRenderContext();
    setRenderContext(initialRenderContext);
    const {
      top: top2,
      left: left2
    } = scrollPosition.current;
    const params = {
      top: top2,
      left: left2,
      renderContext: initialRenderContext
    };
    apiRef.current.publishEvent("scrollPositionChange", params);
  }, [apiRef, computeRenderContext, containerDimensions.width, setRenderContext]);
  const handleScroll = useEventCallback$1((event) => {
    const {
      scrollTop,
      scrollLeft
    } = event.currentTarget;
    scrollPosition.current.top = scrollTop;
    scrollPosition.current.left = scrollLeft;
    if (!prevRenderContext.current || scrollTop < 0) {
      return;
    }
    if (theme2.direction === "ltr") {
      if (scrollLeft < 0) {
        return;
      }
    }
    if (theme2.direction === "rtl") {
      if (scrollLeft > 0) {
        return;
      }
    }
    const nextRenderContext = enabled ? computeRenderContext() : prevRenderContext.current;
    const topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);
    const bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);
    const topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);
    const bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);
    const shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth;
    apiRef.current.publishEvent("scrollPositionChange", {
      top: scrollTop,
      left: scrollLeft,
      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current
    }, event);
    if (shouldSetState) {
      reactDomExports.flushSync(() => {
        setRenderContext(nextRenderContext);
      });
      prevTotalWidth.current = columnsTotalWidth;
    }
  });
  const handleWheel = useEventCallback$1((event) => {
    apiRef.current.publishEvent("virtualScrollerWheel", {}, event);
  });
  const handleTouchMove = useEventCallback$1((event) => {
    apiRef.current.publishEvent("virtualScrollerTouchMove", {}, event);
  });
  const indexOfRowWithFocusedCell = reactExports.useMemo(() => {
    if (cellFocus !== null) {
      return currentPage.rows.findIndex((row) => row.id === cellFocus.id);
    }
    return -1;
  }, [cellFocus, currentPage.rows]);
  useGridApiEventHandler(apiRef, "rowMouseEnter", (params) => {
    var _params$id;
    setHoveredRowId((_params$id = params.id) != null ? _params$id : null);
  });
  useGridApiEventHandler(apiRef, "rowMouseLeave", () => {
    setHoveredRowId(null);
  });
  const getRows = (params = {
    renderContext
  }) => {
    var _rootProps$slotProps;
    const {
      onRowRender,
      renderContext: nextRenderContext,
      minFirstColumn = renderZoneMinColumnIndex,
      maxLastColumn = renderZoneMaxColumnIndex,
      availableSpace = containerDimensions.width,
      rowIndexOffset = 0,
      position: position2 = "center"
    } = params;
    if (!nextRenderContext || availableSpace == null) {
      return null;
    }
    const rowBuffer = enabled ? rootProps.rowBuffer : 0;
    const columnBuffer = enabled ? rootProps.columnBuffer : 0;
    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstRowIndex,
      lastIndex: nextRenderContext.lastRowIndex,
      minFirstIndex: 0,
      maxLastIndex: currentPage.rows.length,
      buffer: rowBuffer
    });
    const renderedRows = [];
    if (params.rows) {
      params.rows.forEach((row) => {
        renderedRows.push(row);
        apiRef.current.calculateColSpan({
          rowId: row.id,
          minFirstColumn,
          maxLastColumn,
          columns: visibleColumns
        });
      });
    } else {
      if (!currentPage.range) {
        return null;
      }
      for (let i2 = firstRowToRender; i2 < lastRowToRender; i2 += 1) {
        const row = currentPage.rows[i2];
        renderedRows.push(row);
        apiRef.current.calculateColSpan({
          rowId: row.id,
          minFirstColumn,
          maxLastColumn,
          columns: visibleColumns
        });
      }
    }
    let isRowWithFocusedCellNotInRange = false;
    if (indexOfRowWithFocusedCell > -1) {
      const rowWithFocusedCell = currentPage.rows[indexOfRowWithFocusedCell];
      if (firstRowToRender > indexOfRowWithFocusedCell || lastRowToRender < indexOfRowWithFocusedCell) {
        isRowWithFocusedCellNotInRange = true;
        if (indexOfRowWithFocusedCell > firstRowToRender) {
          renderedRows.push(rowWithFocusedCell);
        } else {
          renderedRows.unshift(rowWithFocusedCell);
        }
        apiRef.current.calculateColSpan({
          rowId: rowWithFocusedCell.id,
          minFirstColumn,
          maxLastColumn,
          columns: visibleColumns
        });
      }
    }
    const [initialFirstColumnToRender, lastColumnToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstColumnIndex,
      lastIndex: nextRenderContext.lastColumnIndex,
      minFirstIndex: minFirstColumn,
      maxLastIndex: maxLastColumn,
      buffer: columnBuffer
    });
    const firstColumnToRender = getFirstNonSpannedColumnToRender({
      firstColumnToRender: initialFirstColumnToRender,
      apiRef,
      firstRowToRender,
      lastRowToRender,
      visibleRows: currentPage.rows
    });
    let isColumnWihFocusedCellNotInRange = false;
    if (firstColumnToRender > indexOfColumnWithFocusedCell || lastColumnToRender < indexOfColumnWithFocusedCell) {
      isColumnWihFocusedCellNotInRange = true;
    }
    const {
      focusedCellColumnIndexNotInRange,
      renderedColumns
    } = getRenderedColumnsRef.current(visibleColumns, firstColumnToRender, lastColumnToRender, minFirstColumn, maxLastColumn, isColumnWihFocusedCellNotInRange ? indexOfColumnWithFocusedCell : -1);
    const _ref = ((_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.row) || {}, {
      style: rootRowStyle
    } = _ref, rootRowProps = _objectWithoutPropertiesLoose$1(_ref, _excluded$w);
    const invalidatesCachedRowStyle = prevGetRowProps.current !== getRowProps || prevRootRowStyle.current !== rootRowStyle;
    if (invalidatesCachedRowStyle) {
      rowStyleCache.current = /* @__PURE__ */ Object.create(null);
    }
    const rows2 = [];
    for (let i2 = 0; i2 < renderedRows.length; i2 += 1) {
      var _currentPage$range5;
      const {
        id: id2,
        model
      } = renderedRows[i2];
      const isRowNotVisible = isRowWithFocusedCellNotInRange && cellFocus.id === id2;
      const lastVisibleRowIndex = isRowWithFocusedCellNotInRange ? firstRowToRender + i2 === currentPage.rows.length : firstRowToRender + i2 === currentPage.rows.length - 1;
      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id2) ? apiRef.current.unstable_getRowHeight(id2) : "auto";
      let isSelected;
      if (selectedRowsLookup[id2] == null) {
        isSelected = false;
      } else {
        isSelected = apiRef.current.isRowSelectable(id2);
      }
      if (onRowRender) {
        onRowRender(id2);
      }
      const focusedCell = cellFocus !== null && cellFocus.id === id2 ? cellFocus.field : null;
      const columnWithFocusedCellNotInRange = focusedCellColumnIndexNotInRange !== void 0 && visibleColumns[focusedCellColumnIndexNotInRange];
      const renderedColumnsWithFocusedCell = columnWithFocusedCellNotInRange && focusedCell ? [columnWithFocusedCellNotInRange, ...renderedColumns] : renderedColumns;
      let tabbableCell = null;
      if (cellTabIndex !== null && cellTabIndex.id === id2) {
        const cellParams = apiRef.current.getCellParams(id2, cellTabIndex.field);
        tabbableCell = cellParams.cellMode === "view" ? cellTabIndex.field : null;
      }
      const _ref2 = typeof getRowProps === "function" && getRowProps(id2, model) || {}, {
        style: rowStyle
      } = _ref2, rowProps = _objectWithoutPropertiesLoose$1(_ref2, _excluded2$6);
      if (!rowStyleCache.current[id2]) {
        const style2 = _extends$2({}, rowStyle, rootRowStyle);
        rowStyleCache.current[id2] = style2;
      }
      rows2.push(/* @__PURE__ */ jsxRuntimeExports.jsx(rootProps.slots.row, _extends$2({
        row: model,
        rowId: id2,
        focusedCellColumnIndexNotInRange,
        isNotVisible: isRowNotVisible,
        rowHeight: baseRowHeight,
        focusedCell,
        tabbableCell,
        renderedColumns: renderedColumnsWithFocusedCell,
        visibleColumns,
        firstColumnToRender,
        lastColumnToRender,
        selected: isSelected,
        index: rowIndexOffset + ((currentPage == null || (_currentPage$range5 = currentPage.range) == null ? void 0 : _currentPage$range5.firstRowIndex) || 0) + firstRowToRender + i2,
        containerWidth: availableSpace,
        isLastVisible: lastVisibleRowIndex,
        position: position2
      }, rowProps, rootRowProps, {
        hovered: hoveredRowId === id2,
        style: rowStyleCache.current[id2]
      }), id2));
    }
    prevGetRowProps.current = getRowProps;
    prevRootRowStyle.current = rootRowStyle;
    return rows2;
  };
  const needsHorizontalScrollbar = containerDimensions.width && columnsTotalWidth >= containerDimensions.width;
  const contentSize = reactExports.useMemo(() => {
    const height2 = Math.max(rowsMeta.currentPageTotalHeight, 1);
    let shouldExtendContent = false;
    if (rootRef != null && rootRef.current && height2 <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {
      shouldExtendContent = true;
    }
    const size = {
      width: needsHorizontalScrollbar ? columnsTotalWidth : "auto",
      height: height2,
      minHeight: shouldExtendContent ? "100%" : "auto"
    };
    if (rootProps.autoHeight && currentPage.rows.length === 0) {
      size.height = getMinimalContentHeight(apiRef, rootProps.rowHeight);
    }
    return size;
  }, [apiRef, rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, needsHorizontalScrollbar, rootProps.autoHeight, rootProps.rowHeight, currentPage.rows.length]);
  reactExports.useEffect(() => {
    apiRef.current.publishEvent("virtualScrollerContentSizeChange");
  }, [apiRef, contentSize]);
  const rootStyle = reactExports.useMemo(() => {
    const style2 = {};
    if (!needsHorizontalScrollbar) {
      style2.overflowX = "hidden";
    }
    if (rootProps.autoHeight) {
      style2.overflowY = "hidden";
    }
    return style2;
  }, [needsHorizontalScrollbar, rootProps.autoHeight]);
  apiRef.current.register("private", {
    getRenderContext
  });
  return {
    renderContext,
    updateRenderZonePosition,
    getRows,
    getRootProps: (inputProps = {}) => _extends$2({
      ref: handleRef,
      onScroll: handleScroll,
      onWheel: handleWheel,
      onTouchMove: handleTouchMove
    }, inputProps, {
      style: inputProps.style ? _extends$2({}, inputProps.style, rootStyle) : rootStyle,
      role: "presentation"
    }),
    getContentProps: ({
      style: style2
    } = {}) => ({
      style: style2 ? _extends$2({}, style2, contentSize) : contentSize,
      role: "presentation"
    }),
    getRenderZoneProps: () => ({
      ref: renderZoneRef,
      role: "rowgroup"
    })
  };
};
const useUtilityClasses$l = (ownerState) => {
  const {
    classes,
    headerAlign,
    isDragging,
    showColumnBorder,
    groupId
  } = ownerState;
  const slots = {
    root: ["columnHeader", headerAlign === "left" && "columnHeader--alignLeft", headerAlign === "center" && "columnHeader--alignCenter", headerAlign === "right" && "columnHeader--alignRight", isDragging && "columnHeader--moving", showColumnBorder && "columnHeader--showColumnBorder", showColumnBorder && "columnHeader--withRightBorder", "withBorderColor", groupId === null ? "columnHeader--emptyGroup" : "columnHeader--filledGroup"],
    draggableContainer: ["columnHeaderDraggableContainer"],
    titleContainer: ["columnHeaderTitleContainer", "withBorderColor"],
    titleContainerContent: ["columnHeaderTitleContainerContent"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
function GridColumnGroupHeader(props) {
  var _columnGroupsLookup$g;
  const {
    groupId,
    width: width2,
    depth,
    maxDepth,
    fields,
    height: height2,
    colIndex,
    hasFocus,
    tabIndex,
    isLastColumn
  } = props;
  const rootProps = useGridRootProps();
  const headerCellRef = reactExports.useRef(null);
  const apiRef = useGridApiContext();
  const columnGroupsLookup = useGridSelector(apiRef, gridColumnGroupsLookupSelector);
  const group = groupId ? columnGroupsLookup[groupId] : {};
  const {
    headerName = groupId != null ? groupId : "",
    description = "",
    headerAlign = void 0
  } = group;
  let headerComponent;
  const render = groupId && ((_columnGroupsLookup$g = columnGroupsLookup[groupId]) == null ? void 0 : _columnGroupsLookup$g.renderHeaderGroup);
  const renderParams = reactExports.useMemo(() => ({
    groupId,
    headerName,
    description,
    depth,
    maxDepth,
    fields,
    colIndex,
    isLastColumn
  }), [groupId, headerName, description, depth, maxDepth, fields, colIndex, isLastColumn]);
  if (groupId && render) {
    headerComponent = render(renderParams);
  }
  const showColumnBorder = rootProps.showColumnVerticalBorder;
  const ownerState = _extends$2({}, props, {
    classes: rootProps.classes,
    showColumnBorder,
    headerAlign,
    depth,
    isDragging: false
  });
  const label = headerName != null ? headerName : groupId;
  const id2 = useId();
  const elementId = groupId === null ? `empty-group-cell-${id2}` : groupId;
  const classes = useUtilityClasses$l(ownerState);
  reactExports.useLayoutEffect(() => {
    if (hasFocus) {
      const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
      const elementToFocus = focusableElement || headerCellRef.current;
      elementToFocus == null || elementToFocus.focus();
    }
  }, [apiRef, hasFocus]);
  const publish = reactExports.useCallback(
    (eventName) => (event) => {
      if (!event.currentTarget.contains(event.target)) {
        return;
      }
      apiRef.current.publishEvent(eventName, renderParams, event);
    },
    // For now this is stupid, because renderParams change all the time.
    // Need to move it's computation in the api, such that for a given depth+columnField, I can get the group parameters
    [apiRef, renderParams]
  );
  const mouseEventsHandlers = reactExports.useMemo(() => ({
    onKeyDown: publish("columnGroupHeaderKeyDown"),
    onFocus: publish("columnGroupHeaderFocus"),
    onBlur: publish("columnGroupHeaderBlur")
  }), [publish]);
  const headerClassName = typeof group.headerClassName === "function" ? group.headerClassName(renderParams) : group.headerClassName;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridGenericColumnHeaderItem, _extends$2({
    ref: headerCellRef,
    classes,
    columnMenuOpen: false,
    colIndex,
    height: height2,
    isResizing: false,
    sortDirection: null,
    hasFocus: false,
    tabIndex,
    isDraggable: false,
    headerComponent,
    headerClassName,
    description,
    elementId,
    width: width2,
    columnMenuIconButton: null,
    columnTitleIconButtons: null,
    resizable: false,
    label,
    "aria-colspan": fields.length,
    "data-fields": `|-${fields.join("-|-")}-|`
  }, mouseEventsHandlers));
}
const GridColumnHeaderRow = styled$1("div", {
  name: "MuiDataGrid",
  slot: "ColumnHeaderRow",
  overridesResolver: (props, styles2) => styles2.columnHeaderRow
})(() => ({
  display: "flex"
}));
function isUIEvent(event) {
  return !!event.target;
}
const useGridColumnHeaders = (props) => {
  const {
    innerRef: innerRefProp,
    minColumnIndex = 0,
    visibleColumns,
    sortColumnLookup,
    filterColumnLookup,
    columnPositions,
    columnHeaderTabIndexState,
    columnGroupHeaderTabIndexState,
    columnHeaderFocus,
    columnGroupHeaderFocus,
    densityFactor,
    headerGroupingMaxDepth,
    columnMenuState,
    columnVisibility,
    columnGroupsHeaderStructure,
    hasOtherElementInTabSequence
  } = props;
  const theme2 = useTheme();
  const [dragCol, setDragCol] = reactExports.useState("");
  const [resizeCol, setResizeCol] = reactExports.useState("");
  const apiRef = useGridPrivateApiContext();
  const hasVirtualization = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector);
  const rootProps = useGridRootProps();
  const innerRef = reactExports.useRef(null);
  const handleInnerRef = useForkRef(innerRefProp, innerRef);
  const [renderContext, setRenderContextRaw] = reactExports.useState(null);
  const prevRenderContext = reactExports.useRef(renderContext);
  const prevScrollLeft = reactExports.useRef(0);
  const currentPage = useGridVisibleRows(apiRef, rootProps);
  const totalHeaderHeight = getTotalHeaderHeight(apiRef, rootProps.columnHeaderHeight);
  const headerHeight = Math.floor(rootProps.columnHeaderHeight * densityFactor);
  const setRenderContext = reactExports.useCallback((nextRenderContext) => {
    if (renderContext && nextRenderContext && areRenderContextsEqual(renderContext, nextRenderContext)) {
      return;
    }
    setRenderContextRaw(nextRenderContext);
  }, [renderContext]);
  reactExports.useEffect(() => {
    apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
  }, [apiRef]);
  const getFirstColumnIndexToRenderRef = reactExports.useRef(defaultMemoize(getFirstColumnIndexToRender, {
    equalityCheck: (a2, b2) => ["firstColumnIndex", "minColumnIndex", "columnBuffer"].every((key) => a2[key] === b2[key])
  }));
  const updateInnerPosition = reactExports.useCallback((nextRenderContext) => {
    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstRowIndex,
      lastIndex: nextRenderContext.lastRowIndex,
      minFirstIndex: 0,
      maxLastIndex: currentPage.rows.length,
      buffer: rootProps.rowBuffer
    });
    const firstColumnToRender = getFirstColumnIndexToRenderRef.current({
      firstColumnIndex: nextRenderContext.firstColumnIndex,
      minColumnIndex,
      columnBuffer: rootProps.columnBuffer,
      firstRowToRender,
      lastRowToRender,
      apiRef,
      visibleRows: currentPage.rows
    });
    const direction2 = theme2.direction === "ltr" ? 1 : -1;
    const offset2 = firstColumnToRender > 0 ? prevScrollLeft.current - direction2 * columnPositions[firstColumnToRender] : prevScrollLeft.current;
    innerRef.current.style.transform = `translate3d(${-offset2}px, 0px, 0px)`;
  }, [columnPositions, minColumnIndex, rootProps.columnBuffer, apiRef, currentPage.rows, rootProps.rowBuffer, theme2.direction]);
  reactExports.useLayoutEffect(() => {
    if (renderContext) {
      updateInnerPosition(renderContext);
    }
  }, [renderContext, updateInnerPosition]);
  const handleScroll = reactExports.useCallback(({
    left: left2,
    renderContext: nextRenderContext = null
  }, event) => {
    var _prevRenderContext$cu, _prevRenderContext$cu2;
    if (!innerRef.current) {
      return;
    }
    if (prevScrollLeft.current === left2 && ((_prevRenderContext$cu = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu.firstColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.firstColumnIndex) && ((_prevRenderContext$cu2 = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu2.lastColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.lastColumnIndex)) {
      return;
    }
    prevScrollLeft.current = left2;
    let canUpdateInnerPosition = false;
    if (nextRenderContext !== prevRenderContext.current || !prevRenderContext.current) {
      if (isUIEvent(event)) {
        reactDomExports.flushSync(() => {
          setRenderContext(nextRenderContext);
        });
        canUpdateInnerPosition = true;
      } else {
        setRenderContext(nextRenderContext);
      }
      prevRenderContext.current = nextRenderContext;
    } else {
      canUpdateInnerPosition = true;
    }
    if (nextRenderContext && canUpdateInnerPosition) {
      updateInnerPosition(nextRenderContext);
    }
  }, [updateInnerPosition, setRenderContext]);
  const handleColumnResizeStart = reactExports.useCallback((params) => setResizeCol(params.field), []);
  const handleColumnResizeStop = reactExports.useCallback(() => setResizeCol(""), []);
  const handleColumnReorderStart = reactExports.useCallback((params) => setDragCol(params.field), []);
  const handleColumnReorderStop = reactExports.useCallback(() => setDragCol(""), []);
  useGridApiEventHandler(apiRef, "columnResizeStart", handleColumnResizeStart);
  useGridApiEventHandler(apiRef, "columnResizeStop", handleColumnResizeStop);
  useGridApiEventHandler(apiRef, "columnHeaderDragStart", handleColumnReorderStart);
  useGridApiEventHandler(apiRef, "columnHeaderDragEnd", handleColumnReorderStop);
  useGridApiEventHandler(apiRef, "scrollPositionChange", handleScroll);
  const getColumnsToRender = (params) => {
    const {
      renderContext: nextRenderContext = renderContext,
      minFirstColumn = minColumnIndex,
      maxLastColumn = visibleColumns.length
    } = params || {};
    if (!nextRenderContext) {
      return null;
    }
    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstRowIndex,
      lastIndex: nextRenderContext.lastRowIndex,
      minFirstIndex: 0,
      maxLastIndex: currentPage.rows.length,
      buffer: rootProps.rowBuffer
    });
    const firstColumnToRender = !hasVirtualization ? 0 : getFirstColumnIndexToRenderRef.current({
      firstColumnIndex: nextRenderContext.firstColumnIndex,
      minColumnIndex: minFirstColumn,
      columnBuffer: rootProps.columnBuffer,
      apiRef,
      firstRowToRender,
      lastRowToRender,
      visibleRows: currentPage.rows
    });
    const lastColumnToRender = !hasVirtualization ? maxLastColumn : Math.min(nextRenderContext.lastColumnIndex + rootProps.columnBuffer, maxLastColumn);
    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);
    return {
      renderedColumns,
      firstColumnToRender,
      lastColumnToRender,
      minFirstColumn,
      maxLastColumn
    };
  };
  const getColumnHeaders = (params, other = {}) => {
    const columnsToRender = getColumnsToRender(params);
    if (columnsToRender == null) {
      return null;
    }
    const {
      renderedColumns,
      firstColumnToRender
    } = columnsToRender;
    const columns = [];
    for (let i2 = 0; i2 < renderedColumns.length; i2 += 1) {
      const colDef = renderedColumns[i2];
      const columnIndex = firstColumnToRender + i2;
      const isFirstColumn = columnIndex === 0;
      const tabIndex = columnHeaderTabIndexState !== null && columnHeaderTabIndexState.field === colDef.field || isFirstColumn && !hasOtherElementInTabSequence ? 0 : -1;
      const hasFocus = columnHeaderFocus !== null && columnHeaderFocus.field === colDef.field;
      const open2 = columnMenuState.open && columnMenuState.field === colDef.field;
      columns.push(/* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderItem, _extends$2({}, sortColumnLookup[colDef.field], {
        columnMenuOpen: open2,
        filterItemsCounter: filterColumnLookup[colDef.field] && filterColumnLookup[colDef.field].length,
        headerHeight,
        isDragging: colDef.field === dragCol,
        colDef,
        colIndex: columnIndex,
        isResizing: resizeCol === colDef.field,
        hasFocus,
        tabIndex
      }, other), colDef.field));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderRow, {
      role: "row",
      "aria-rowindex": headerGroupingMaxDepth + 1,
      ownerState: rootProps,
      children: columns
    });
  };
  const getColumnGroupHeaders = (params) => {
    if (headerGroupingMaxDepth === 0) {
      return null;
    }
    const columnsToRender = getColumnsToRender(params);
    if (columnsToRender == null || columnsToRender.renderedColumns.length === 0) {
      return null;
    }
    const {
      firstColumnToRender,
      lastColumnToRender
    } = columnsToRender;
    const columns = [];
    const headerToRender = [];
    for (let depth = 0; depth < headerGroupingMaxDepth; depth += 1) {
      var _apiRef$current$unsta, _apiRef$current$unsta2;
      const rowStructure = columnGroupsHeaderStructure[depth];
      const firstColumnFieldToRender = visibleColumns[firstColumnToRender].field;
      const firstGroupToRender = (_apiRef$current$unsta = apiRef.current.unstable_getColumnGroupPath(firstColumnFieldToRender)[depth]) != null ? _apiRef$current$unsta : null;
      const firstGroupIndex = rowStructure.findIndex(({
        groupId,
        columnFields
      }) => groupId === firstGroupToRender && columnFields.includes(firstColumnFieldToRender));
      const lastColumnFieldToRender = visibleColumns[lastColumnToRender - 1].field;
      const lastGroupToRender = (_apiRef$current$unsta2 = apiRef.current.unstable_getColumnGroupPath(lastColumnFieldToRender)[depth]) != null ? _apiRef$current$unsta2 : null;
      const lastGroupIndex = rowStructure.findIndex(({
        groupId,
        columnFields
      }) => groupId === lastGroupToRender && columnFields.includes(lastColumnFieldToRender));
      const visibleColumnGroupHeader = rowStructure.slice(firstGroupIndex, lastGroupIndex + 1).map((groupStructure) => {
        return _extends$2({}, groupStructure, {
          columnFields: groupStructure.columnFields.filter((field) => columnVisibility[field] !== false)
        });
      }).filter((groupStructure) => groupStructure.columnFields.length > 0);
      const firstVisibleColumnIndex = visibleColumnGroupHeader[0].columnFields.indexOf(firstColumnFieldToRender);
      const hiddenGroupColumns = visibleColumnGroupHeader[0].columnFields.slice(0, firstVisibleColumnIndex);
      const leftOverflow = hiddenGroupColumns.reduce((acc, field) => {
        var _column$computedWidth;
        const column2 = apiRef.current.getColumn(field);
        return acc + ((_column$computedWidth = column2.computedWidth) != null ? _column$computedWidth : 0);
      }, 0);
      let columnIndex = firstColumnToRender;
      const elements = visibleColumnGroupHeader.map(({
        groupId,
        columnFields
      }) => {
        const hasFocus = columnGroupHeaderFocus !== null && columnGroupHeaderFocus.depth === depth && columnFields.includes(columnGroupHeaderFocus.field);
        const tabIndex = columnGroupHeaderTabIndexState !== null && columnGroupHeaderTabIndexState.depth === depth && columnFields.includes(columnGroupHeaderTabIndexState.field) ? 0 : -1;
        const headerInfo = {
          groupId,
          width: columnFields.reduce((acc, field) => acc + apiRef.current.getColumn(field).computedWidth, 0),
          fields: columnFields,
          colIndex: columnIndex,
          hasFocus,
          tabIndex
        };
        columnIndex += columnFields.length;
        return headerInfo;
      });
      headerToRender.push({
        leftOverflow,
        elements
      });
    }
    headerToRender.forEach((depthInfo, depthIndex) => {
      columns.push(/* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeaderRow, {
        style: {
          height: `${headerHeight}px`,
          transform: `translateX(-${depthInfo.leftOverflow}px)`
        },
        role: "row",
        "aria-rowindex": depthIndex + 1,
        ownerState: rootProps,
        children: depthInfo.elements.map(({
          groupId,
          width: width2,
          fields,
          colIndex,
          hasFocus,
          tabIndex
        }, groupIndex) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnGroupHeader, {
            groupId,
            width: width2,
            fields,
            colIndex,
            depth: depthIndex,
            isLastColumn: colIndex === visibleColumns.length - fields.length,
            maxDepth: headerToRender.length,
            height: headerHeight,
            hasFocus,
            tabIndex
          }, groupIndex);
        })
      }, depthIndex));
    });
    return columns;
  };
  const rootStyle = {
    minHeight: totalHeaderHeight,
    maxHeight: totalHeaderHeight,
    lineHeight: `${headerHeight}px`
  };
  return {
    renderContext,
    getColumnHeaders,
    getColumnsToRender,
    getColumnGroupHeaders,
    isDragging: !!dragCol,
    getRootProps: (other = {}) => _extends$2({
      style: rootStyle
    }, other),
    getInnerProps: () => ({
      ref: handleInnerRef,
      role: "rowgroup"
    }),
    headerHeight
  };
};
const _excluded$v = ["className"];
const useUtilityClasses$k = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["columnHeaders", "withBorderColor"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridColumnHeadersRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "ColumnHeaders",
  overridesResolver: (props, styles2) => styles2.columnHeaders
})({
  position: "relative",
  overflow: "hidden",
  display: "flex",
  alignItems: "center",
  boxSizing: "border-box",
  borderBottom: "1px solid",
  borderTopLeftRadius: "var(--unstable_DataGrid-radius)",
  borderTopRightRadius: "var(--unstable_DataGrid-radius)"
});
const GridBaseColumnHeaders = /* @__PURE__ */ reactExports.forwardRef(function GridColumnHeaders(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$v);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$k(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeadersRoot, _extends$2({
    ref,
    className: clsx(className, classes.root),
    ownerState: rootProps
  }, other, {
    role: "presentation"
  }));
});
const _excluded$u = ["isDragging", "className"];
const useUtilityClasses$j = (ownerState) => {
  const {
    isDragging,
    hasScrollX,
    classes
  } = ownerState;
  const slots = {
    root: ["columnHeadersInner", isDragging && "columnHeaderDropZone", hasScrollX && "columnHeadersInner--scrollable"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const GridColumnHeadersInnerRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "columnHeadersInner",
  overridesResolver: (props, styles2) => [{
    [`&.${gridClasses.columnHeaderDropZone}`]: styles2.columnHeaderDropZone
  }, styles2.columnHeadersInner]
})(() => ({
  display: "flex",
  alignItems: "flex-start",
  flexDirection: "column",
  [`&.${gridClasses.columnHeaderDropZone} .${gridClasses.columnHeaderDraggableContainer}`]: {
    cursor: "move"
  },
  [`&.${gridClasses["columnHeadersInner--scrollable"]} .${gridClasses.columnHeader}:last-child`]: {
    borderRight: "none"
  }
}));
const GridColumnHeadersInner = /* @__PURE__ */ reactExports.forwardRef(function GridColumnHeadersInner2(props, ref) {
  var _apiRef$current$getRo, _apiRef$current$getRo2;
  const {
    isDragging,
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$u);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$2({}, rootProps, {
    isDragging,
    hasScrollX: (_apiRef$current$getRo = (_apiRef$current$getRo2 = apiRef.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo2.hasScrollX) != null ? _apiRef$current$getRo : false
  });
  const classes = useUtilityClasses$j(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridColumnHeadersInnerRoot, _extends$2({
    ref,
    className: clsx(className, classes.root),
    ownerState
  }, other));
});
const _excluded$t = ["innerRef", "className", "visibleColumns", "sortColumnLookup", "filterColumnLookup", "columnPositions", "columnHeaderTabIndexState", "columnGroupHeaderTabIndexState", "columnHeaderFocus", "columnGroupHeaderFocus", "densityFactor", "headerGroupingMaxDepth", "columnMenuState", "columnVisibility", "columnGroupsHeaderStructure", "hasOtherElementInTabSequence"];
const GridColumnHeaders2 = /* @__PURE__ */ reactExports.forwardRef(function GridColumnsHeaders(props, ref) {
  const {
    innerRef,
    visibleColumns,
    sortColumnLookup,
    filterColumnLookup,
    columnPositions,
    columnHeaderTabIndexState,
    columnGroupHeaderTabIndexState,
    columnHeaderFocus,
    columnGroupHeaderFocus,
    densityFactor,
    headerGroupingMaxDepth,
    columnMenuState,
    columnVisibility,
    columnGroupsHeaderStructure,
    hasOtherElementInTabSequence
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$t);
  const {
    isDragging,
    getRootProps,
    getInnerProps,
    getColumnHeaders,
    getColumnGroupHeaders
  } = useGridColumnHeaders({
    innerRef,
    visibleColumns,
    sortColumnLookup,
    filterColumnLookup,
    columnPositions,
    columnHeaderTabIndexState,
    columnGroupHeaderTabIndexState,
    columnHeaderFocus,
    columnGroupHeaderFocus,
    densityFactor,
    headerGroupingMaxDepth,
    columnMenuState,
    columnVisibility,
    columnGroupsHeaderStructure,
    hasOtherElementInTabSequence
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridBaseColumnHeaders, _extends$2({
    ref
  }, getRootProps(other), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GridColumnHeadersInner, _extends$2({
      isDragging
    }, getInnerProps(), {
      children: [getColumnGroupHeaders(), getColumnHeaders()]
    }))
  }));
});
const MemoizedGridColumnHeaders = fastMemo(GridColumnHeaders2);
const GridNoResultsOverlay = /* @__PURE__ */ reactExports.forwardRef(function GridNoResultsOverlay2(props, ref) {
  const apiRef = useGridApiContext();
  const noResultsOverlayLabel = apiRef.current.getLocaleText("noResultsOverlayLabel");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlay, _extends$2({
    ref
  }, props, {
    children: noResultsOverlayLabel
  }));
});
const _excluded$s = ["sortingOrder"];
const GridColumnUnsortedIcon = /* @__PURE__ */ reactExports.memo(function GridColumnHeaderSortIcon2(props) {
  const {
    sortingOrder
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$s);
  const rootProps = useGridRootProps();
  const [nextSortDirection] = sortingOrder;
  const Icon = nextSortDirection === "asc" ? rootProps.slots.columnSortedAscendingIcon : rootProps.slots.columnSortedDescendingIcon;
  return Icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, _extends$2({}, other)) : null;
});
const _excluded$r = ["native"];
function MUISelectOption(_ref) {
  let {
    native
  } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$r);
  if (native) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("option", _extends$2({}, props));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, _extends$2({}, props));
}
const iconSlots = {
  BooleanCellTrueIcon: GridCheckIcon,
  BooleanCellFalseIcon: GridCloseIcon,
  ColumnMenuIcon: GridTripleDotsVerticalIcon,
  OpenFilterButtonIcon: GridFilterListIcon,
  FilterPanelDeleteIcon: GridCloseIcon,
  ColumnFilteredIcon: GridFilterAltIcon,
  ColumnSelectorIcon: GridColumnIcon,
  ColumnUnsortedIcon: GridColumnUnsortedIcon,
  ColumnSortedAscendingIcon: GridArrowUpwardIcon,
  ColumnSortedDescendingIcon: GridArrowDownwardIcon,
  ColumnResizeIcon: GridSeparatorIcon,
  DensityCompactIcon: GridViewHeadlineIcon,
  DensityStandardIcon: GridTableRowsIcon,
  DensityComfortableIcon: GridViewStreamIcon,
  ExportIcon: GridSaveAltIcon,
  MoreActionsIcon: GridMoreVertIcon,
  TreeDataCollapseIcon: GridExpandMoreIcon,
  TreeDataExpandIcon: GridKeyboardArrowRight,
  GroupingCriteriaCollapseIcon: GridExpandMoreIcon,
  GroupingCriteriaExpandIcon: GridKeyboardArrowRight,
  DetailPanelExpandIcon: GridAddIcon,
  DetailPanelCollapseIcon: GridRemoveIcon,
  RowReorderIcon: GridDragIcon,
  QuickFilterIcon: GridSearchIcon,
  QuickFilterClearIcon: GridCloseIcon,
  ColumnMenuHideIcon: GridVisibilityOffIcon,
  ColumnMenuSortAscendingIcon: GridArrowUpwardIcon,
  ColumnMenuSortDescendingIcon: GridArrowDownwardIcon,
  ColumnMenuFilterIcon: GridFilterAltIcon,
  ColumnMenuManageColumnsIcon: GridViewColumnIcon,
  ColumnMenuClearIcon: GridClearIcon,
  LoadIcon: GridLoadIcon,
  FilterPanelAddIcon: GridAddIcon,
  FilterPanelRemoveAllIcon: GridDeleteForeverIcon,
  ColumnReorderIcon: GridDragIcon
};
const materialSlots = _extends$2({}, iconSlots, {
  BaseCheckbox: MUICheckbox,
  BaseTextField: TextField$1,
  BaseFormControl: FormControl$1,
  BaseSelect: Select$1,
  BaseSwitch: MUISwitch,
  BaseButton: Button$1,
  BaseIconButton: IconButton$1,
  BaseInputAdornment: InputAdornment$1,
  BaseTooltip: MUITooltip,
  BasePopper: MuiPopper,
  BaseInputLabel: MUIInputLabel,
  BaseSelectOption: MUISelectOption,
  BaseChip: Chip$1
});
const materialSlots$1 = materialSlots;
const DATA_GRID_DEFAULT_SLOTS_COMPONENTS = _extends$2({}, materialSlots$1, {
  Cell: MemoizedGridCellV7,
  SkeletonCell: GridSkeletonCell,
  ColumnHeaderFilterIconButton: GridColumnHeaderFilterIconButton,
  ColumnMenu: GridColumnMenu,
  ColumnHeaders: MemoizedGridColumnHeaders,
  Footer: GridFooter,
  FooterRowCount: GridRowCount,
  Toolbar: null,
  PreferencesPanel: GridPreferencesPanel,
  LoadingOverlay: GridLoadingOverlay,
  NoResultsOverlay: GridNoResultsOverlay,
  NoRowsOverlay: GridNoRowsOverlay,
  Pagination: GridPagination,
  FilterPanel: GridFilterPanel,
  ColumnsPanel: GridColumnsPanel,
  Panel: GridPanel,
  Row: MemoizedGridRow
});
const uncapitalizeObjectKeys$1 = (capitalizedObject) => {
  if (capitalizedObject === void 0) {
    return void 0;
  }
  return Object.keys(capitalizedObject).reduce((acc, key) => _extends$2({}, acc, {
    [`${key.charAt(0).toLowerCase()}${key.slice(1)}`]: capitalizedObject[key]
  }), {});
};
function computeSlots({
  defaultSlots: defaultSlots2,
  slots,
  components
}) {
  const overrides = slots != null ? slots : components ? uncapitalizeObjectKeys$1(components) : null;
  if (!overrides || Object.keys(overrides).length === 0) {
    return defaultSlots2;
  }
  return _extends$2({}, defaultSlots2, overrides);
}
const _excluded$q = ["components", "componentsProps"];
function groupForwardedProps(props) {
  var _props$forwardedProps;
  const keys3 = Object.keys(props);
  if (!keys3.some((key) => key.startsWith("aria-") || key.startsWith("data-"))) {
    return props;
  }
  const newProps = {};
  const forwardedProps = (_props$forwardedProps = props.forwardedProps) != null ? _props$forwardedProps : {};
  for (let i2 = 0; i2 < keys3.length; i2 += 1) {
    const key = keys3[i2];
    if (key.startsWith("aria-") || key.startsWith("data-")) {
      forwardedProps[key] = props[key];
    } else {
      newProps[key] = props[key];
    }
  }
  newProps.forwardedProps = forwardedProps;
  return newProps;
}
function useProps(allProps) {
  return reactExports.useMemo(() => {
    const {
      components,
      componentsProps
    } = allProps, themedProps = _objectWithoutPropertiesLoose$1(allProps, _excluded$q);
    return [components, componentsProps, groupForwardedProps(themedProps)];
  }, [allProps]);
}
const DATA_GRID_FORCED_PROPS = {
  disableMultipleColumnsFiltering: true,
  disableMultipleColumnsSorting: true,
  disableMultipleRowSelection: true,
  throttleRowsMs: void 0,
  hideFooterRowCount: false,
  pagination: true,
  checkboxSelectionVisibleOnly: false,
  disableColumnReorder: true,
  disableColumnResize: true,
  keepColumnPositionIfDraggedOutside: false,
  signature: "DataGrid"
};
const DATA_GRID_PROPS_DEFAULT_VALUES = {
  autoHeight: false,
  autoPageSize: false,
  checkboxSelection: false,
  checkboxSelectionVisibleOnly: false,
  columnBuffer: 3,
  rowBuffer: 3,
  columnThreshold: 3,
  rowThreshold: 3,
  rowSelection: true,
  density: "standard",
  disableColumnFilter: false,
  disableColumnMenu: false,
  disableColumnSelector: false,
  disableDensitySelector: false,
  disableEval: false,
  disableMultipleColumnsFiltering: false,
  disableMultipleRowSelection: false,
  disableMultipleColumnsSorting: false,
  disableRowSelectionOnClick: false,
  disableVirtualization: false,
  editMode: GridEditModes.Cell,
  filterMode: "client",
  filterDebounceMs: 150,
  columnHeaderHeight: 56,
  hideFooter: false,
  hideFooterPagination: false,
  hideFooterRowCount: false,
  hideFooterSelectedRowCount: false,
  logger: console,
  logLevel: "error",
  pagination: false,
  paginationMode: "client",
  rowHeight: 52,
  pageSizeOptions: [25, 50, 100],
  rowSpacingType: "margin",
  showCellVerticalBorder: false,
  showColumnVerticalBorder: false,
  sortingOrder: ["asc", "desc", null],
  sortingMode: "client",
  throttleRowsMs: 0,
  disableColumnReorder: false,
  disableColumnResize: false,
  keepNonExistentRowsSelected: false,
  keepColumnPositionIfDraggedOutside: false,
  unstable_ignoreValueFormatterDuringExport: false,
  clipboardCopyCellDelimiter: "	"
};
const defaultSlots = uncapitalizeObjectKeys$1(DATA_GRID_DEFAULT_SLOTS_COMPONENTS);
const useDataGridProps = (inProps) => {
  const [components, componentsProps, themedProps] = useProps(useThemeProps({
    props: inProps,
    name: "MuiDataGrid"
  }));
  const localeText = reactExports.useMemo(() => _extends$2({}, GRID_DEFAULT_LOCALE_TEXT, themedProps.localeText), [themedProps.localeText]);
  const slots = reactExports.useMemo(() => computeSlots({
    defaultSlots,
    slots: themedProps.slots,
    components
  }), [components, themedProps.slots]);
  return reactExports.useMemo(() => {
    var _themedProps$slotProp;
    return _extends$2({}, DATA_GRID_PROPS_DEFAULT_VALUES, themedProps, {
      localeText,
      slots,
      slotProps: (_themedProps$slotProp = themedProps.slotProps) != null ? _themedProps$slotProp : componentsProps
    }, DATA_GRID_FORCED_PROPS);
  }, [themedProps, localeText, slots, componentsProps]);
};
const rowsMetaStateInitializer = (state) => _extends$2({}, state, {
  rowsMeta: {
    currentPageTotalHeight: 0,
    positions: []
  }
});
const getValidRowHeight = (rowHeightProp, defaultRowHeight, warningMessage) => {
  if (typeof rowHeightProp === "number" && rowHeightProp > 0) {
    return rowHeightProp;
  }
  return defaultRowHeight;
};
const useGridRowsMeta = (apiRef, props) => {
  const {
    getRowHeight: getRowHeightProp,
    getRowSpacing,
    getEstimatedRowHeight
  } = props;
  const rowsHeightLookup = reactExports.useRef(/* @__PURE__ */ Object.create(null));
  const lastMeasuredRowIndex = reactExports.useRef(-1);
  const hasRowWithAutoHeight = reactExports.useRef(false);
  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);
  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);
  const paginationState = useGridSelector(apiRef, gridPaginationSelector);
  const sortModel = useGridSelector(apiRef, gridSortModelSelector);
  const currentPage = useGridVisibleRows(apiRef, props);
  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);
  const validRowHeight = getValidRowHeight(props.rowHeight, DATA_GRID_PROPS_DEFAULT_VALUES.rowHeight);
  const rowHeight = Math.floor(validRowHeight * densityFactor);
  const hydrateRowsMeta = reactExports.useCallback(() => {
    var _pinnedRows$top, _pinnedRows$bottom;
    hasRowWithAutoHeight.current = false;
    const calculateRowProcessedSizes = (row) => {
      if (!rowsHeightLookup.current[row.id]) {
        rowsHeightLookup.current[row.id] = {
          sizes: {
            baseCenter: rowHeight
          },
          isResized: false,
          autoHeight: false,
          needsFirstMeasurement: true
          // Assume all rows will need to be measured by default
        };
      }
      const {
        isResized,
        needsFirstMeasurement,
        sizes
      } = rowsHeightLookup.current[row.id];
      let baseRowHeight = typeof rowHeight === "number" && rowHeight > 0 ? rowHeight : 52;
      const existingBaseRowHeight = sizes.baseCenter;
      if (isResized) {
        baseRowHeight = existingBaseRowHeight;
      } else if (getRowHeightProp) {
        const rowHeightFromUser = getRowHeightProp(_extends$2({}, row, {
          densityFactor
        }));
        if (rowHeightFromUser === "auto") {
          if (needsFirstMeasurement) {
            const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends$2({}, row, {
              densityFactor
            })) : rowHeight;
            baseRowHeight = estimatedRowHeight != null ? estimatedRowHeight : rowHeight;
          } else {
            baseRowHeight = existingBaseRowHeight;
          }
          hasRowWithAutoHeight.current = true;
          rowsHeightLookup.current[row.id].autoHeight = true;
        } else {
          baseRowHeight = getValidRowHeight(rowHeightFromUser, rowHeight);
          rowsHeightLookup.current[row.id].needsFirstMeasurement = false;
          rowsHeightLookup.current[row.id].autoHeight = false;
        }
      } else {
        rowsHeightLookup.current[row.id].needsFirstMeasurement = false;
      }
      const initialHeights = {};
      for (const key in sizes) {
        if (/^base[A-Z]/.test(key)) {
          initialHeights[key] = sizes[key];
        }
      }
      initialHeights.baseCenter = baseRowHeight;
      if (getRowSpacing) {
        var _spacing$top, _spacing$bottom;
        const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);
        const spacing = getRowSpacing(_extends$2({}, row, {
          isFirstVisible: indexRelativeToCurrentPage === 0,
          isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,
          indexRelativeToCurrentPage
        }));
        initialHeights.spacingTop = (_spacing$top = spacing.top) != null ? _spacing$top : 0;
        initialHeights.spacingBottom = (_spacing$bottom = spacing.bottom) != null ? _spacing$bottom : 0;
      }
      const processedSizes = apiRef.current.unstable_applyPipeProcessors("rowHeight", initialHeights, row);
      rowsHeightLookup.current[row.id].sizes = processedSizes;
      return processedSizes;
    };
    const positions = [];
    const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {
      positions.push(acc);
      let maximumBaseSize = 0;
      let otherSizes = 0;
      const processedSizes = calculateRowProcessedSizes(row);
      for (const key in processedSizes) {
        const value = processedSizes[key];
        if (/^base[A-Z]/.test(key)) {
          maximumBaseSize = value > maximumBaseSize ? value : maximumBaseSize;
        } else {
          otherSizes += value;
        }
      }
      return acc + maximumBaseSize + otherSizes;
    }, 0);
    pinnedRows == null || (_pinnedRows$top = pinnedRows.top) == null || _pinnedRows$top.forEach((row) => {
      calculateRowProcessedSizes(row);
    });
    pinnedRows == null || (_pinnedRows$bottom = pinnedRows.bottom) == null || _pinnedRows$bottom.forEach((row) => {
      calculateRowProcessedSizes(row);
    });
    apiRef.current.setState((state) => {
      return _extends$2({}, state, {
        rowsMeta: {
          currentPageTotalHeight,
          positions
        }
      });
    });
    if (!hasRowWithAutoHeight.current) {
      lastMeasuredRowIndex.current = Infinity;
    }
    apiRef.current.forceUpdate();
  }, [apiRef, currentPage.rows, rowHeight, getRowHeightProp, getRowSpacing, getEstimatedRowHeight, pinnedRows, densityFactor]);
  const getRowHeight = reactExports.useCallback((rowId) => {
    const height2 = rowsHeightLookup.current[rowId];
    return height2 ? height2.sizes.baseCenter : rowHeight;
  }, [rowHeight]);
  const getRowInternalSizes = (rowId) => {
    var _rowsHeightLookup$cur;
    return (_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.sizes;
  };
  const setRowHeight = reactExports.useCallback((id2, height2) => {
    rowsHeightLookup.current[id2].sizes.baseCenter = height2;
    rowsHeightLookup.current[id2].isResized = true;
    rowsHeightLookup.current[id2].needsFirstMeasurement = false;
    hydrateRowsMeta();
  }, [hydrateRowsMeta]);
  const debouncedHydrateRowsMeta = reactExports.useMemo(() => debounce$1(hydrateRowsMeta), [hydrateRowsMeta]);
  const storeMeasuredRowHeight = reactExports.useCallback((id2, height2, position2) => {
    if (!rowsHeightLookup.current[id2] || !rowsHeightLookup.current[id2].autoHeight) {
      return;
    }
    const needsHydration = rowsHeightLookup.current[id2].sizes[`base${capitalize$1(position2)}`] !== height2;
    rowsHeightLookup.current[id2].needsFirstMeasurement = false;
    rowsHeightLookup.current[id2].sizes[`base${capitalize$1(position2)}`] = height2;
    if (needsHydration) {
      debouncedHydrateRowsMeta();
    }
  }, [debouncedHydrateRowsMeta]);
  const rowHasAutoHeight = reactExports.useCallback((id2) => {
    var _rowsHeightLookup$cur2;
    return ((_rowsHeightLookup$cur2 = rowsHeightLookup.current[id2]) == null ? void 0 : _rowsHeightLookup$cur2.autoHeight) || false;
  }, []);
  const getLastMeasuredRowIndex = reactExports.useCallback(() => {
    return lastMeasuredRowIndex.current;
  }, []);
  const setLastMeasuredRowIndex = reactExports.useCallback((index2) => {
    if (hasRowWithAutoHeight.current && index2 > lastMeasuredRowIndex.current) {
      lastMeasuredRowIndex.current = index2;
    }
  }, []);
  const resetRowHeights = reactExports.useCallback(() => {
    rowsHeightLookup.current = {};
    hydrateRowsMeta();
  }, [hydrateRowsMeta]);
  reactExports.useEffect(() => {
    hydrateRowsMeta();
  }, [rowHeight, filterModel, paginationState, sortModel, hydrateRowsMeta]);
  useGridRegisterPipeApplier(apiRef, "rowHeight", hydrateRowsMeta);
  const rowsMetaApi = {
    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,
    unstable_getRowHeight: getRowHeight,
    unstable_getRowInternalSizes: getRowInternalSizes,
    unstable_setRowHeight: setRowHeight,
    unstable_storeRowHeightMeasurement: storeMeasuredRowHeight,
    resetRowHeights
  };
  const rowsMetaPrivateApi = {
    getLastMeasuredRowIndex,
    rowHasAutoHeight
  };
  useGridApiMethod(apiRef, rowsMetaApi, "public");
  useGridApiMethod(apiRef, rowsMetaPrivateApi, "private");
};
const useGridStatePersistence = (apiRef) => {
  const exportState = reactExports.useCallback((params = {}) => {
    const stateToExport = apiRef.current.unstable_applyPipeProcessors("exportState", {}, params);
    return stateToExport;
  }, [apiRef]);
  const restoreState = reactExports.useCallback((stateToRestore) => {
    const response = apiRef.current.unstable_applyPipeProcessors("restoreState", {
      callbacks: []
    }, {
      stateToRestore
    });
    response.callbacks.forEach((callback) => {
      callback();
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const statePersistenceApi = {
    exportState,
    restoreState
  };
  useGridApiMethod(apiRef, statePersistenceApi, "public");
};
const useGridColumnSpanning = (apiRef) => {
  const lookup2 = reactExports.useRef({});
  const setCellColSpanInfo = reactExports.useCallback((rowId, columnIndex, cellColSpanInfo) => {
    const sizes = lookup2.current;
    if (!sizes[rowId]) {
      sizes[rowId] = {};
    }
    sizes[rowId][columnIndex] = cellColSpanInfo;
  }, []);
  const getCellColSpanInfo = reactExports.useCallback((rowId, columnIndex) => {
    var _lookup$current$rowId;
    return (_lookup$current$rowId = lookup2.current[rowId]) == null ? void 0 : _lookup$current$rowId[columnIndex];
  }, []);
  const calculateCellColSpan = reactExports.useCallback((params) => {
    const {
      columnIndex,
      rowId,
      minFirstColumnIndex,
      maxLastColumnIndex,
      columns
    } = params;
    const columnsLength = columns.length;
    const column2 = columns[columnIndex];
    const colSpan = typeof column2.colSpan === "function" ? column2.colSpan(apiRef.current.getCellParams(rowId, column2.field)) : column2.colSpan;
    if (!colSpan || colSpan === 1) {
      setCellColSpanInfo(rowId, columnIndex, {
        spannedByColSpan: false,
        cellProps: {
          colSpan: 1,
          width: column2.computedWidth
        }
      });
      return {
        colSpan: 1
      };
    }
    let width2 = column2.computedWidth;
    for (let j2 = 1; j2 < colSpan; j2 += 1) {
      const nextColumnIndex = columnIndex + j2;
      if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {
        const nextColumn = columns[nextColumnIndex];
        width2 += nextColumn.computedWidth;
        setCellColSpanInfo(rowId, columnIndex + j2, {
          spannedByColSpan: true,
          rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),
          leftVisibleCellIndex: columnIndex
        });
      }
      setCellColSpanInfo(rowId, columnIndex, {
        spannedByColSpan: false,
        cellProps: {
          colSpan,
          width: width2
        }
      });
    }
    return {
      colSpan
    };
  }, [apiRef, setCellColSpanInfo]);
  const calculateColSpan = reactExports.useCallback(({
    rowId,
    minFirstColumn,
    maxLastColumn,
    columns
  }) => {
    for (let i2 = minFirstColumn; i2 < maxLastColumn; i2 += 1) {
      const cellProps = calculateCellColSpan({
        columnIndex: i2,
        rowId,
        minFirstColumnIndex: minFirstColumn,
        maxLastColumnIndex: maxLastColumn,
        columns
      });
      if (cellProps.colSpan > 1) {
        i2 += cellProps.colSpan - 1;
      }
    }
  }, [calculateCellColSpan]);
  const columnSpanningPublicApi = {
    unstable_getCellColSpanInfo: getCellColSpanInfo
  };
  const columnSpanningPrivateApi = {
    calculateColSpan
  };
  useGridApiMethod(apiRef, columnSpanningPublicApi, "public");
  useGridApiMethod(apiRef, columnSpanningPrivateApi, "private");
  const handleColumnReorderChange = reactExports.useCallback(() => {
    lookup2.current = {};
  }, []);
  useGridApiEventHandler(apiRef, "columnOrderChange", handleColumnReorderChange);
};
const recurrentUnwrapGroupingColumnModel = (columnGroupNode, parents, unwrappedGroupingModelToComplete) => {
  if (isLeaf(columnGroupNode)) {
    if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== void 0) {
      throw new Error([`MUI: columnGroupingModel contains duplicated field`, `column field ${columnGroupNode.field} occurs two times in the grouping model:`, `- ${unwrappedGroupingModelToComplete[columnGroupNode.field].join(" > ")}`, `- ${parents.join(" > ")}`].join("\n"));
    }
    unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;
    return;
  }
  const {
    groupId,
    children
  } = columnGroupNode;
  children.forEach((child) => {
    recurrentUnwrapGroupingColumnModel(child, [...parents, groupId], unwrappedGroupingModelToComplete);
  });
};
const unwrapGroupingColumnModel = (columnGroupingModel) => {
  if (!columnGroupingModel) {
    return {};
  }
  const unwrappedSubTree = {};
  columnGroupingModel.forEach((columnGroupNode) => {
    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);
  });
  return unwrappedSubTree;
};
const getColumnGroupsHeaderStructure = (orderedColumns, unwrappedGroupingModel) => {
  const getParents = (field) => {
    var _unwrappedGroupingMod;
    return (_unwrappedGroupingMod = unwrappedGroupingModel[field]) != null ? _unwrappedGroupingMod : [];
  };
  const groupingHeaderStructure = [];
  const maxDepth = Math.max(...orderedColumns.map((field) => getParents(field).length));
  const haveSameParents = (field1, field2, depth) => isDeepEqual(getParents(field1).slice(0, depth + 1), getParents(field2).slice(0, depth + 1));
  for (let depth = 0; depth < maxDepth; depth += 1) {
    const depthStructure = orderedColumns.reduce((structure, newField) => {
      var _getParents$depth;
      const groupId = (_getParents$depth = getParents(newField)[depth]) != null ? _getParents$depth : null;
      if (structure.length === 0) {
        return [{
          columnFields: [newField],
          groupId
        }];
      }
      const lastGroup = structure[structure.length - 1];
      const prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];
      const prevGroupId = lastGroup.groupId;
      if (prevGroupId !== groupId || !haveSameParents(prevField, newField, depth)) {
        return [...structure, {
          columnFields: [newField],
          groupId
        }];
      }
      return [...structure.slice(0, structure.length - 1), {
        columnFields: [...lastGroup.columnFields, newField],
        groupId
      }];
    }, []);
    groupingHeaderStructure.push(depthStructure);
  }
  return groupingHeaderStructure;
};
const _excluded$p = ["groupId", "children"];
const createGroupLookup = (columnGroupingModel) => {
  let groupLookup = {};
  columnGroupingModel.forEach((node2) => {
    if (isLeaf(node2)) {
      return;
    }
    const {
      groupId,
      children
    } = node2, other = _objectWithoutPropertiesLoose$1(node2, _excluded$p);
    if (!groupId) {
      throw new Error("MUI: An element of the columnGroupingModel does not have either `field` or `groupId`.");
    }
    if (!children) {
      console.warn(`MUI: group groupId=${groupId} has no children.`);
    }
    const groupParam = _extends$2({}, other, {
      groupId
    });
    const subTreeLookup = createGroupLookup(children);
    if (subTreeLookup[groupId] !== void 0 || groupLookup[groupId] !== void 0) {
      throw new Error(`MUI: The groupId ${groupId} is used multiple times in the columnGroupingModel.`);
    }
    groupLookup = _extends$2({}, groupLookup, subTreeLookup, {
      [groupId]: groupParam
    });
  });
  return _extends$2({}, groupLookup);
};
const columnGroupsStateInitializer = (state, props, apiRef) => {
  var _props$experimentalFe, _props$columnGrouping, _props$columnGrouping2;
  if (!((_props$experimentalFe = props.experimentalFeatures) != null && _props$experimentalFe.columnGrouping)) {
    return state;
  }
  const columnFields = gridColumnFieldsSelector(apiRef);
  const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);
  const groupLookup = createGroupLookup((_props$columnGrouping = props.columnGroupingModel) != null ? _props$columnGrouping : []);
  const unwrappedGroupingModel = unwrapGroupingColumnModel((_props$columnGrouping2 = props.columnGroupingModel) != null ? _props$columnGrouping2 : []);
  const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(columnFields, unwrappedGroupingModel);
  const maxDepth = visibleColumnFields.length === 0 ? 0 : Math.max(...visibleColumnFields.map((field) => {
    var _unwrappedGroupingMod, _unwrappedGroupingMod2;
    return (_unwrappedGroupingMod = (_unwrappedGroupingMod2 = unwrappedGroupingModel[field]) == null ? void 0 : _unwrappedGroupingMod2.length) != null ? _unwrappedGroupingMod : 0;
  }));
  return _extends$2({}, state, {
    columnGrouping: {
      lookup: groupLookup,
      unwrappedGroupingModel,
      headerStructure: columnGroupsHeaderStructure,
      maxDepth
    }
  });
};
const useGridColumnGrouping = (apiRef, props) => {
  var _props$experimentalFe3;
  const getColumnGroupPath = reactExports.useCallback((field) => {
    var _unwrappedGroupingMod3;
    const unwrappedGroupingModel = gridColumnGroupsUnwrappedModelSelector(apiRef);
    return (_unwrappedGroupingMod3 = unwrappedGroupingModel[field]) != null ? _unwrappedGroupingMod3 : [];
  }, [apiRef]);
  const getAllGroupDetails = reactExports.useCallback(() => {
    const columnGroupLookup = gridColumnGroupsLookupSelector(apiRef);
    return columnGroupLookup;
  }, [apiRef]);
  const columnGroupingApi = {
    unstable_getColumnGroupPath: getColumnGroupPath,
    unstable_getAllGroupDetails: getAllGroupDetails
  };
  useGridApiMethod(apiRef, columnGroupingApi, "public");
  const handleColumnIndexChange = reactExports.useCallback(() => {
    var _props$columnGrouping3;
    const unwrappedGroupingModel = unwrapGroupingColumnModel((_props$columnGrouping3 = props.columnGroupingModel) != null ? _props$columnGrouping3 : []);
    apiRef.current.setState((state) => {
      var _state$columns$ordere, _state$columns;
      const orderedFields = (_state$columns$ordere = (_state$columns = state.columns) == null ? void 0 : _state$columns.orderedFields) != null ? _state$columns$ordere : [];
      const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(orderedFields, unwrappedGroupingModel);
      return _extends$2({}, state, {
        columnGrouping: _extends$2({}, state.columnGrouping, {
          headerStructure: columnGroupsHeaderStructure
        })
      });
    });
  }, [apiRef, props.columnGroupingModel]);
  const updateColumnGroupingState = reactExports.useCallback((columnGroupingModel) => {
    var _props$experimentalFe2;
    if (!((_props$experimentalFe2 = props.experimentalFeatures) != null && _props$experimentalFe2.columnGrouping)) {
      return;
    }
    const columnFields = gridColumnFieldsSelector(apiRef);
    const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);
    const groupLookup = createGroupLookup(columnGroupingModel != null ? columnGroupingModel : []);
    const unwrappedGroupingModel = unwrapGroupingColumnModel(columnGroupingModel != null ? columnGroupingModel : []);
    const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(columnFields, unwrappedGroupingModel);
    const maxDepth = visibleColumnFields.length === 0 ? 0 : Math.max(...visibleColumnFields.map((field) => {
      var _unwrappedGroupingMod4, _unwrappedGroupingMod5;
      return (_unwrappedGroupingMod4 = (_unwrappedGroupingMod5 = unwrappedGroupingModel[field]) == null ? void 0 : _unwrappedGroupingMod5.length) != null ? _unwrappedGroupingMod4 : 0;
    }));
    apiRef.current.setState((state) => {
      return _extends$2({}, state, {
        columnGrouping: {
          lookup: groupLookup,
          unwrappedGroupingModel,
          headerStructure: columnGroupsHeaderStructure,
          maxDepth
        }
      });
    });
  }, [apiRef, (_props$experimentalFe3 = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe3.columnGrouping]);
  useGridApiEventHandler(apiRef, "columnIndexChange", handleColumnIndexChange);
  useGridApiEventHandler(apiRef, "columnsChange", () => {
    updateColumnGroupingState(props.columnGroupingModel);
  });
  useGridApiEventHandler(apiRef, "columnVisibilityModelChange", () => {
    updateColumnGroupingState(props.columnGroupingModel);
  });
  reactExports.useEffect(() => {
    updateColumnGroupingState(props.columnGroupingModel);
  }, [updateColumnGroupingState, props.columnGroupingModel]);
};
const useDataGridComponent = (inputApiRef, props) => {
  const apiRef = useGridInitialization(inputApiRef, props);
  useGridRowSelectionPreProcessors(apiRef, props);
  useGridRowsPreProcessors(apiRef);
  useGridInitializeState(rowSelectionStateInitializer, apiRef, props);
  useGridInitializeState(columnsStateInitializer, apiRef, props);
  useGridInitializeState(rowsStateInitializer, apiRef, props);
  useGridInitializeState(editingStateInitializer, apiRef, props);
  useGridInitializeState(focusStateInitializer, apiRef, props);
  useGridInitializeState(sortingStateInitializer, apiRef, props);
  useGridInitializeState(preferencePanelStateInitializer, apiRef, props);
  useGridInitializeState(filterStateInitializer, apiRef, props);
  useGridInitializeState(densityStateInitializer, apiRef, props);
  useGridInitializeState(paginationStateInitializer, apiRef, props);
  useGridInitializeState(rowsMetaStateInitializer, apiRef, props);
  useGridInitializeState(columnMenuStateInitializer, apiRef, props);
  useGridInitializeState(columnGroupsStateInitializer, apiRef, props);
  useGridInitializeState(virtualizationStateInitializer, apiRef, props);
  useGridKeyboardNavigation(apiRef, props);
  useGridRowSelection(apiRef, props);
  useGridColumns(apiRef, props);
  useGridRows(apiRef, props);
  useGridParamsApi(apiRef, props);
  useGridColumnSpanning(apiRef);
  useGridColumnGrouping(apiRef, props);
  useGridEditing(apiRef, props);
  useGridFocus(apiRef, props);
  useGridPreferencesPanel(apiRef, props);
  useGridFilter(apiRef, props);
  useGridSorting(apiRef, props);
  useGridDensity(apiRef, props);
  useGridPagination(apiRef, props);
  useGridRowsMeta(apiRef, props);
  useGridScroll(apiRef, props);
  useGridColumnMenu(apiRef);
  useGridCsvExport(apiRef, props);
  useGridPrintExport(apiRef, props);
  useGridClipboard(apiRef, props);
  useGridDimensions(apiRef, props);
  useGridEvents(apiRef, props);
  useGridStatePersistence(apiRef);
  useGridVirtualization(apiRef, props);
  return apiRef;
};
const useUtilityClasses$i = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["virtualScroller"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const VirtualScrollerRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "VirtualScroller",
  overridesResolver: (props, styles2) => styles2.virtualScroller
})({
  overflow: "auto",
  height: "100%",
  // See https://github.com/mui/mui-x/issues/4360
  position: "relative",
  "@media print": {
    overflow: "hidden"
  }
});
const GridVirtualScroller = /* @__PURE__ */ reactExports.forwardRef(function GridVirtualScroller2(props, ref) {
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$i(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualScrollerRoot, _extends$2({
    ref
  }, props, {
    className: clsx(classes.root, props.className),
    ownerState: rootProps
  }));
});
const useUtilityClasses$h = (props, overflowedContent) => {
  const {
    classes
  } = props;
  const slots = {
    root: ["virtualScrollerContent", overflowedContent && "virtualScrollerContent--overflowed"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const VirtualScrollerContentRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "VirtualScrollerContent",
  overridesResolver: (props, styles2) => styles2.virtualScrollerContent
})({});
const GridVirtualScrollerContent = /* @__PURE__ */ reactExports.forwardRef(function GridVirtualScrollerContent2(props, ref) {
  var _props$style;
  const rootProps = useGridRootProps();
  const overflowedContent = !rootProps.autoHeight && ((_props$style = props.style) == null ? void 0 : _props$style.minHeight) === "auto";
  const classes = useUtilityClasses$h(rootProps, overflowedContent);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualScrollerContentRoot, _extends$2({
    ref
  }, props, {
    ownerState: rootProps,
    className: clsx(classes.root, props.className)
  }));
});
const _excluded$o = ["className"];
const useUtilityClasses$g = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["virtualScrollerRenderZone"]
  };
  return composeClasses(slots, getDataGridUtilityClass, classes);
};
const VirtualScrollerRenderZoneRoot = styled$3("div", {
  name: "MuiDataGrid",
  slot: "VirtualScrollerRenderZone",
  overridesResolver: (props, styles2) => styles2.virtualScrollerRenderZone
})({
  position: "absolute",
  display: "flex",
  // Prevents margin collapsing when using `getRowSpacing`
  flexDirection: "column"
});
const GridVirtualScrollerRenderZone = /* @__PURE__ */ reactExports.forwardRef(function GridVirtualScrollerRenderZone2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$o);
  const rootProps = useGridRootProps();
  const classes = useUtilityClasses$g(rootProps);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualScrollerRenderZoneRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState: rootProps
  }, other));
});
const _excluded$n = ["className"];
const DataGridVirtualScroller = /* @__PURE__ */ reactExports.forwardRef(function DataGridVirtualScroller2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$n);
  const {
    getRootProps,
    getContentProps,
    getRenderZoneProps,
    getRows
  } = useGridVirtualScroller({
    ref
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GridVirtualScroller, _extends$2({
    className
  }, getRootProps(other), {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridOverlays, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(GridVirtualScrollerContent, _extends$2({}, getContentProps(), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridVirtualScrollerRenderZone, _extends$2({}, getRenderZoneProps(), {
        children: getRows()
      }))
    }))]
  }));
});
const DataGridRaw = /* @__PURE__ */ reactExports.forwardRef(function DataGrid(inProps, ref) {
  const props = useDataGridProps(inProps);
  const privateApiRef = useDataGridComponent(props.apiRef, props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridContextProvider, {
    privateApiRef,
    props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GridRoot, _extends$2({
      className: props.className,
      style: props.style,
      sx: props.sx,
      ref
    }, props.forwardedProps, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GridHeader, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(GridBody, {
        VirtualScrollerComponent: DataGridVirtualScroller
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(GridFooterPlaceholder, {})]
    }))
  });
});
const DataGrid2 = /* @__PURE__ */ reactExports.memo(DataGridRaw);
DATA_GRID_PROPS_DEFAULT_VALUES.filterDebounceMs;
DATA_GRID_PROPS_DEFAULT_VALUES.filterDebounceMs;
DataGridRaw.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The ref object that allows grid manipulation. Can be instantiated with `useGridApiRef()`.
   */
  apiRef: PropTypes.shape({
    current: PropTypes.object.isRequired
  }),
  /**
   * The label of the grid.
   */
  "aria-label": PropTypes.string,
  /**
   * The id of the element containing a label for the grid.
   */
  "aria-labelledby": PropTypes.string,
  /**
   * If `true`, the grid height is dynamic and follow the number of rows in the grid.
   * @default false
   */
  autoHeight: PropTypes.bool,
  /**
   * If `true`, the pageSize is calculated according to the container size and the max number of rows to avoid rendering a vertical scroll bar.
   * @default false
   */
  autoPageSize: PropTypes.bool,
  /**
   * Controls the modes of the cells.
   */
  cellModesModel: PropTypes.object,
  /**
   * If `true`, the grid get a first column with a checkbox that allows to select rows.
   * @default false
   */
  checkboxSelection: PropTypes.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * The character used to separate cell values when copying to the clipboard.
   * @default '\t'
   */
  clipboardCopyCellDelimiter: PropTypes.string,
  /**
   * Number of extra columns to be rendered before/after the visible slice.
   * @default 3
   */
  columnBuffer: PropTypes.number,
  columnGroupingModel: PropTypes.arrayOf(PropTypes.object),
  /**
   * Sets the height in pixel of the column headers in the grid.
   * @default 56
   */
  columnHeaderHeight: PropTypes.number,
  /**
   * Set of columns of type [[GridColDef[]]].
   */
  columns: chainPropTypes(PropTypes.array.isRequired),
  /**
   * Number of rows from the `columnBuffer` that can be visible before a new slice is rendered.
   * @default 3
   */
  columnThreshold: PropTypes.number,
  /**
   * Set the column visibility model of the grid.
   * If defined, the grid will ignore the `hide` property in [[GridColDef]].
   */
  columnVisibilityModel: PropTypes.object,
  /**
   * Overridable components.
   * @deprecated Use `slots` instead.
   */
  components: PropTypes.object,
  /**
   * Overridable components props dynamically passed to the component at rendering.
   * @deprecated Use the `slotProps` prop instead.
   */
  componentsProps: PropTypes.object,
  /**
   * Set the density of the grid.
   * @default "standard"
   */
  density: PropTypes.oneOf(["comfortable", "compact", "standard"]),
  /**
   * If `true`, column filters are disabled.
   * @default false
   */
  disableColumnFilter: PropTypes.bool,
  /**
   * If `true`, the column menu is disabled.
   * @default false
   */
  disableColumnMenu: PropTypes.bool,
  /**
   * If `true`, hiding/showing columns is disabled.
   * @default false
   */
  disableColumnSelector: PropTypes.bool,
  /**
   * If `true`, the density selector is disabled.
   * @default false
   */
  disableDensitySelector: PropTypes.bool,
  /**
   * If `true`, `eval()` is not used for performance optimization.
   * @default false
   * @ignore - do not document
   */
  disableEval: PropTypes.bool,
  /**
   * If `true`, the selection on click on a row or cell is disabled.
   * @default false
   */
  disableRowSelectionOnClick: PropTypes.bool,
  /**
   * If `true`, the virtualization is disabled.
   * @default false
   */
  disableVirtualization: PropTypes.bool,
  /**
   * Controls whether to use the cell or row editing.
   * @default "cell"
   */
  editMode: PropTypes.oneOf(["cell", "row"]),
  /**
   * Unstable features, breaking changes might be introduced.
   * For each feature, if the flag is not explicitly set to `true`, the feature will be fully disabled and any property / method call will not have any effect.
   */
  experimentalFeatures: PropTypes.shape({
    ariaV7: PropTypes.bool,
    columnGrouping: PropTypes.bool,
    warnIfFocusStateIsNotSynced: PropTypes.bool
  }),
  /**
   * The milliseconds delay to wait after a keystroke before triggering filtering.
   * @default 150
   */
  filterDebounceMs: PropTypes.number,
  /**
   * Filtering can be processed on the server or client-side.
   * Set it to 'server' if you would like to handle filtering on the server-side.
   * @default "client"
   */
  filterMode: PropTypes.oneOf(["client", "server"]),
  /**
   * Set the filter model of the grid.
   */
  filterModel: PropTypes.shape({
    items: PropTypes.arrayOf(PropTypes.shape({
      field: PropTypes.string.isRequired,
      id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
      operator: PropTypes.string.isRequired,
      value: PropTypes.any
    })).isRequired,
    logicOperator: PropTypes.oneOf(["and", "or"]),
    quickFilterExcludeHiddenColumns: PropTypes.bool,
    quickFilterLogicOperator: PropTypes.oneOf(["and", "or"]),
    quickFilterValues: PropTypes.array
  }),
  /**
   * Forwarded props for the grid root element.
   * @ignore - do not document.
   */
  forwardedProps: PropTypes.object,
  /**
   * Function that applies CSS classes dynamically on cells.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @returns {string} The CSS class to apply to the cell.
   */
  getCellClassName: PropTypes.func,
  /**
   * Function that returns the element to render in row detail.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @returns {React.JSX.Element} The row detail element.
   */
  getDetailPanelContent: PropTypes.func,
  /**
   * Function that returns the estimated height for a row.
   * Only works if dynamic row height is used.
   * Once the row height is measured this value is discarded.
   * @param {GridRowHeightParams} params With all properties from [[GridRowHeightParams]].
   * @returns {number | null} The estimated row height value. If `null` or `undefined` then the default row height, based on the density, is applied.
   */
  getEstimatedRowHeight: PropTypes.func,
  /**
   * Function that applies CSS classes dynamically on rows.
   * @param {GridRowClassNameParams} params With all properties from [[GridRowClassNameParams]].
   * @returns {string} The CSS class to apply to the row.
   */
  getRowClassName: PropTypes.func,
  /**
   * Function that sets the row height per row.
   * @param {GridRowHeightParams} params With all properties from [[GridRowHeightParams]].
   * @returns {GridRowHeightReturnValue} The row height value. If `null` or `undefined` then the default row height is applied. If "auto" then the row height is calculated based on the content.
   */
  getRowHeight: PropTypes.func,
  /**
   * Return the id of a given [[GridRowModel]].
   */
  getRowId: PropTypes.func,
  /**
   * Function that allows to specify the spacing between rows.
   * @param {GridRowSpacingParams} params With all properties from [[GridRowSpacingParams]].
   * @returns {GridRowSpacing} The row spacing values.
   */
  getRowSpacing: PropTypes.func,
  /**
   * If `true`, the footer component is hidden.
   * @default false
   */
  hideFooter: PropTypes.bool,
  /**
   * If `true`, the pagination component in the footer is hidden.
   * @default false
   */
  hideFooterPagination: PropTypes.bool,
  /**
   * If `true`, the selected row count in the footer is hidden.
   * @default false
   */
  hideFooterSelectedRowCount: PropTypes.bool,
  /**
   * The initial state of the DataGrid.
   * The data in it will be set in the state on initialization but will not be controlled.
   * If one of the data in `initialState` is also being controlled, then the control state wins.
   */
  initialState: PropTypes.object,
  /**
   * Callback fired when a cell is rendered, returns true if the cell is editable.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @returns {boolean} A boolean indicating if the cell is editable.
   */
  isCellEditable: PropTypes.func,
  /**
   * Determines if a row can be selected.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @returns {boolean} A boolean indicating if the cell is selectable.
   */
  isRowSelectable: PropTypes.func,
  /**
   * If `true`, the selection model will retain selected rows that do not exist.
   * Useful when using server side pagination and row selections need to be retained
   * when changing pages.
   * @default false
   */
  keepNonExistentRowsSelected: PropTypes.bool,
  /**
   * If `true`, a  loading overlay is displayed.
   */
  loading: PropTypes.bool,
  /**
   * Set the locale text of the grid.
   * You can find all the translation keys supported in [the source](https://github.com/mui/mui-x/blob/HEAD/packages/grid/x-data-grid/src/constants/localeTextConstants.ts) in the GitHub repository.
   */
  localeText: PropTypes.object,
  /**
   * Pass a custom logger in the components that implements the [[Logger]] interface.
   * @default console
   */
  logger: PropTypes.shape({
    debug: PropTypes.func.isRequired,
    error: PropTypes.func.isRequired,
    info: PropTypes.func.isRequired,
    warn: PropTypes.func.isRequired
  }),
  /**
   * Allows to pass the logging level or false to turn off logging.
   * @default "error" ("warn" in dev mode)
   */
  logLevel: PropTypes.oneOf(["debug", "error", "info", "warn", false]),
  /**
   * Nonce of the inline styles for [Content Security Policy](https://www.w3.org/TR/2016/REC-CSP2-20161215/#script-src-the-nonce-attribute).
   */
  nonce: PropTypes.string,
  /**
   * Callback fired when any cell is clicked.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellClick: PropTypes.func,
  /**
   * Callback fired when a double click event comes from a cell element.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellDoubleClick: PropTypes.func,
  /**
   * Callback fired when the cell turns to edit mode.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
   */
  onCellEditStart: PropTypes.func,
  /**
   * Callback fired when the cell turns to view mode.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
   */
  onCellEditStop: PropTypes.func,
  /**
   * Callback fired when a keydown event comes from a cell element.
   * @param {GridCellParams} params With all properties from [[GridCellParams]].
   * @param {MuiEvent<React.KeyboardEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellKeyDown: PropTypes.func,
  /**
   * Callback fired when the `cellModesModel` prop changes.
   * @param {GridCellModesModel} cellModesModel Object containing which cells are in "edit" mode.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onCellModesModelChange: PropTypes.func,
  /**
   * Callback called when the data is copied to the clipboard.
   * @param {string} data The data copied to the clipboard.
   */
  onClipboardCopy: PropTypes.func,
  /**
   * Callback fired when a click event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderClick: PropTypes.func,
  /**
   * Callback fired when a double click event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderDoubleClick: PropTypes.func,
  /**
   * Callback fired when a mouse enter event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderEnter: PropTypes.func,
  /**
   * Callback fired when a mouse leave event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderLeave: PropTypes.func,
  /**
   * Callback fired when a mouseout event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderOut: PropTypes.func,
  /**
   * Callback fired when a mouseover event comes from a column header element.
   * @param {GridColumnHeaderParams} params With all properties from [[GridColumnHeaderParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnHeaderOver: PropTypes.func,
  /**
   * Callback fired when a column is reordered.
   * @param {GridColumnOrderChangeParams} params With all properties from [[GridColumnOrderChangeParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnOrderChange: PropTypes.func,
  /**
   * Callback fired when the column visibility model changes.
   * @param {GridColumnVisibilityModel} model The new model.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onColumnVisibilityModelChange: PropTypes.func,
  /**
   * Callback fired when the Filter model changes before the filters are applied.
   * @param {GridFilterModel} model With all properties from [[GridFilterModel]].
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onFilterModelChange: PropTypes.func,
  /**
   * Callback fired when the menu is closed.
   * @param {GridMenuParams} params With all properties from [[GridMenuParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onMenuClose: PropTypes.func,
  /**
   * Callback fired when the menu is opened.
   * @param {GridMenuParams} params With all properties from [[GridMenuParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onMenuOpen: PropTypes.func,
  /**
   * Callback fired when the pagination model has changed.
   * @param {GridPaginationModel} model Updated pagination model.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPaginationModelChange: PropTypes.func,
  /**
   * Callback fired when the preferences panel is closed.
   * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPreferencePanelClose: PropTypes.func,
  /**
   * Callback fired when the preferences panel is opened.
   * @param {GridPreferencePanelParams} params With all properties from [[GridPreferencePanelParams]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onPreferencePanelOpen: PropTypes.func,
  /**
   * Callback called when `processRowUpdate` throws an error or rejects.
   * @param {any} error The error thrown.
   */
  onProcessRowUpdateError: PropTypes.func,
  /**
   * Callback fired when the grid is resized.
   * @param {ElementSize} containerSize With all properties from [[ElementSize]].
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onResize: PropTypes.func,
  /**
   * Callback fired when a row is clicked.
   * Not called if the target clicked is an interactive element added by the built-in columns.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowClick: PropTypes.func,
  /**
   * Callback fired when a double click event comes from a row container element.
   * @param {GridRowParams} params With all properties from [[RowParams]].
   * @param {MuiEvent<React.MouseEvent>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowDoubleClick: PropTypes.func,
  /**
   * Callback fired when the row changes are committed.
   * @param {GridRowId} id The row id.
   * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
   */
  onRowEditCommit: PropTypes.func,
  /**
   * Callback fired when the row turns to edit mode.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @param {MuiEvent<React.KeyboardEvent | React.MouseEvent>} event The event that caused this prop to be called.
   */
  onRowEditStart: PropTypes.func,
  /**
   * Callback fired when the row turns to view mode.
   * @param {GridRowParams} params With all properties from [[GridRowParams]].
   * @param {MuiEvent<MuiBaseEvent>} event The event that caused this prop to be called.
   */
  onRowEditStop: PropTypes.func,
  /**
   * Callback fired when the `rowModesModel` prop changes.
   * @param {GridRowModesModel} rowModesModel Object containing which rows are in "edit" mode.
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowModesModelChange: PropTypes.func,
  /**
   * Callback fired when the selection state of one or multiple rows changes.
   * @param {GridRowSelectionModel} rowSelectionModel With all the row ids [[GridSelectionModel]].
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onRowSelectionModelChange: PropTypes.func,
  /**
   * Callback fired when the sort model changes before a column is sorted.
   * @param {GridSortModel} model With all properties from [[GridSortModel]].
   * @param {GridCallbackDetails} details Additional details for this callback.
   */
  onSortModelChange: PropTypes.func,
  /**
   * Callback fired when the state of the grid is updated.
   * @param {GridState} state The new state.
   * @param {MuiEvent<{}>} event The event object.
   * @param {GridCallbackDetails} details Additional details for this callback.
   * @ignore - do not document.
   */
  onStateChange: PropTypes.func,
  /**
   * Select the pageSize dynamically using the component UI.
   * @default [25, 50, 100]
   */
  pageSizeOptions: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
    label: PropTypes.string.isRequired,
    value: PropTypes.number.isRequired
  })]).isRequired),
  pagination: (props) => {
    if (props.pagination === false) {
      return new Error(["MUI: `<DataGrid pagination={false} />` is not a valid prop.", "Infinite scrolling is not available in the MIT version.", "", "You need to upgrade to DataGridPro or DataGridPremium component to disable the pagination."].join("\n"));
    }
    return null;
  },
  /**
   * Pagination can be processed on the server or client-side.
   * Set it to 'client' if you would like to handle the pagination on the client-side.
   * Set it to 'server' if you would like to handle the pagination on the server-side.
   * @default "client"
   */
  paginationMode: PropTypes.oneOf(["client", "server"]),
  /**
   * The pagination model of type [[GridPaginationModel]] which refers to current `page` and `pageSize`.
   */
  paginationModel: PropTypes.shape({
    page: PropTypes.number.isRequired,
    pageSize: PropTypes.number.isRequired
  }),
  /**
   * Callback called before updating a row with new values in the row and cell editing.
   * @template R
   * @param {R} newRow Row object with the new values.
   * @param {R} oldRow Row object with the old values.
   * @returns {Promise<R> | R} The final values to update the row.
   */
  processRowUpdate: PropTypes.func,
  /**
   * Number of extra rows to be rendered before/after the visible slice.
   * @default 3
   */
  rowBuffer: PropTypes.number,
  /**
   * Set the total number of rows, if it is different from the length of the value `rows` prop.
   * If some rows have children (for instance in the tree data), this number represents the amount of top level rows.
   */
  rowCount: PropTypes.number,
  /**
   * Sets the height in pixel of a row in the grid.
   * @default 52
   */
  rowHeight: PropTypes.number,
  /**
   * Controls the modes of the rows.
   */
  rowModesModel: PropTypes.object,
  /**
   * Set of rows of type [[GridRowsProp]].
   */
  rows: PropTypes.arrayOf(PropTypes.object).isRequired,
  /**
   * If `false`, the row selection mode is disabled.
   * @default true
   */
  rowSelection: PropTypes.bool,
  /**
   * Sets the row selection model of the grid.
   */
  rowSelectionModel: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired), PropTypes.number, PropTypes.string]),
  /**
   * Sets the type of space between rows added by `getRowSpacing`.
   * @default "margin"
   */
  rowSpacingType: PropTypes.oneOf(["border", "margin"]),
  /**
   * Number of rows from the `rowBuffer` that can be visible before a new slice is rendered.
   * @default 3
   */
  rowThreshold: PropTypes.number,
  /**
   * Override the height/width of the grid inner scrollbar.
   */
  scrollbarSize: PropTypes.number,
  /**
   * If `true`, the vertical borders of the cells are displayed.
   * @default false
   */
  showCellVerticalBorder: PropTypes.bool,
  /**
   * If `true`, the right border of the column headers are displayed.
   * @default false
   */
  showColumnVerticalBorder: PropTypes.bool,
  /**
   * Overridable components props dynamically passed to the component at rendering.
   */
  slotProps: PropTypes.object,
  /**
   * Overridable components.
   */
  slots: PropTypes.object,
  /**
   * Sorting can be processed on the server or client-side.
   * Set it to 'client' if you would like to handle sorting on the client-side.
   * Set it to 'server' if you would like to handle sorting on the server-side.
   * @default "client"
   */
  sortingMode: PropTypes.oneOf(["client", "server"]),
  /**
   * The order of the sorting sequence.
   * @default ['asc', 'desc', null]
   */
  sortingOrder: PropTypes.arrayOf(PropTypes.oneOf(["asc", "desc"])),
  /**
   * Set the sort model of the grid.
   */
  sortModel: PropTypes.arrayOf(PropTypes.shape({
    field: PropTypes.string.isRequired,
    sort: PropTypes.oneOf(["asc", "desc"])
  })),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * If `true`, the grid will not use `valueFormatter` when exporting to CSV or copying to clipboard.
   * If an object is provided, you can choose to ignore the `valueFormatter` for CSV export or clipboard export.
   * @default: false
   */
  unstable_ignoreValueFormatterDuringExport: PropTypes.oneOfType([PropTypes.shape({
    clipboardExport: PropTypes.bool,
    csvExport: PropTypes.bool
  }), PropTypes.bool])
};
const StyledGridOverlay = styled$1("div")(({ theme: theme2 }) => ({
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  height: "100%",
  "& .ant-empty-img-1": {
    fill: theme2.palette.mode === "light" ? "#aeb8c2" : "#262626"
  },
  "& .ant-empty-img-2": {
    fill: theme2.palette.mode === "light" ? "#f5f5f7" : "#595959"
  },
  "& .ant-empty-img-3": {
    fill: theme2.palette.mode === "light" ? "#dce0e6" : "#434343"
  },
  "& .ant-empty-img-4": {
    fill: theme2.palette.mode === "light" ? "#fff" : "#1c1c1c"
  },
  "& .ant-empty-img-5": {
    fillOpacity: theme2.palette.mode === "light" ? "0.8" : "0.08",
    fill: theme2.palette.mode === "light" ? "#f5f5f5" : "#fff"
  }
}));
function CustomNoRowsOverlay() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(StyledGridOverlay, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "svg",
      {
        width: "120",
        height: "100",
        viewBox: "0 0 184 152",
        "aria-hidden": true,
        focusable: "false",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "none", fillRule: "evenodd", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { transform: "translate(24 31.67)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "ellipse",
              {
                className: "ant-empty-img-5",
                cx: "67.797",
                cy: "106.89",
                rx: "67.797",
                ry: "12.668"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                className: "ant-empty-img-1",
                d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                className: "ant-empty-img-2",
                d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                className: "ant-empty-img-3",
                d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              className: "ant-empty-img-3",
              d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: "ant-empty-img-4", transform: "translate(149.65 15.383)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("ellipse", { cx: "20.654", cy: "3.167", rx: "2.849", ry: "2.815" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z" })
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { mt: 1 }, children: "No Rows" })
  ] });
}
function CustomerTable() {
  const [deviceType, setDeviceType] = reactExports.useState("tablet");
  const [allCustomers, setAllCustomers] = reactExports.useState([]);
  const theme2 = useTheme();
  const tablet = useMediaQuery(theme2.breakpoints.down("sm"));
  const customers = useSelector(
    (state) => state.customers.customers
  );
  reactExports.useEffect(() => {
    if (tablet) {
      setDeviceType("tablet");
    } else {
      setDeviceType("pc");
    }
  }, []);
  reactExports.useEffect(() => {
    if (customers) {
      const filterOut = customers?.filter((item) => item?.type === "customer");
      setAllCustomers(filterOut);
    }
  }, [customers]);
  const columnsSmall = [
    {
      field: "id",
      headerName: "No",
      width: 100,
      renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "#",
        params?.row?.id
      ] })
    },
    {
      field: "name",
      headerName: "Full Name",
      width: 100
    },
    {
      field: "contact_id",
      headerName: "Contact ID",
      width: 100
    },
    {
      field: "email",
      headerName: "Email Address",
      width: 156
    },
    {
      field: "mobile",
      headerName: "Phone number",
      width: 110
    },
    {
      field: "credit_limit",
      headerName: "Credit Limit",
      width: 115
    }
  ];
  const columns = [
    {
      field: "id",
      headerName: "No",
      width: 120,
      renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "#",
        params?.row?.id
      ] })
    },
    {
      field: "name",
      headerName: "Full Name",
      width: 200,
      renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "body2", textTransform: "capitalize", children: params?.row?.name })
    },
    {
      field: "contact_id",
      headerName: "Contact ID",
      width: 150
    },
    {
      field: "email",
      headerName: "Email Address",
      width: 300,
      renderCell: (params) => /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "body2", textTransform: "lowercase", children: params?.row?.email })
    },
    {
      field: "mobile",
      headerName: "Phone number",
      width: 200
    },
    {
      field: "credit_limit",
      headerName: "Credit Limit",
      width: 210
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "73vh", width: "100%" }, children: allCustomers && /* @__PURE__ */ jsxRuntimeExports.jsx(
    DataGrid2,
    {
      sx: { padding: 1 },
      rows: allCustomers,
      columns: deviceType === "tablet" ? columnsSmall : columns,
      density: "compact",
      rowHeight: 86,
      disableColumnFilter: true,
      components: {
        // Toolbar: CustomToolbar,
        NoRowsOverlay: CustomNoRowsOverlay
      }
    }
  ) });
}
const Customers = () => {
  const navigate = useNavigate();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { height: "100vh", width: "100vw", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        pl: 3,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              display: "flex",
              flexDirection: "row",
              justifyContent: "start",
              alignItems: "center",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => navigate("/dashboard/"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBack, { sx: { color: "black" } }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 21, fontWeight: 800, px: 1, children: "Customers" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              variant: "contained",
              sx: { mx: 4 },
              startIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(AddCircleOutlineOutlined, {}),
              onClick: () => navigate("/dashboard/customers/new"),
              children: "Add New Customer"
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { m: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomerTable, {}) })
  ] });
};
const Support = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Support" });
};
var dayjs_min = { exports: {} };
(function(module2, exports2) {
  !function(t3, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    var t3 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t4) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t4 % 100;
      return "[" + t4 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = function(t4, e3, n3) {
      var r3 = String(t4);
      return !r3 || r3.length >= e3 ? t4 : "" + Array(e3 + 1 - r3.length).join(n3) + t4;
    }, v2 = { s: m2, z: function(t4) {
      var e3 = -t4.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
    }, m: function t4(e3, n3) {
      if (e3.date() < n3.date())
        return -t4(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
      return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
    }, a: function(t4) {
      return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
    }, p: function(t4) {
      return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t4] || String(t4 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t4) {
      return void 0 === t4;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = "$isDayjsObject", S2 = function(t4) {
      return t4 instanceof _2 || !(!t4 || !t4[p2]);
    }, w2 = function t4(e3, n3, r3) {
      var i3;
      if (!e3)
        return g2;
      if ("string" == typeof e3) {
        var s3 = e3.toLowerCase();
        D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
        var u3 = e3.split("-");
        if (!i3 && u3.length > 1)
          return t4(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i3 = a3;
      }
      return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
    }, O2 = function(t4, e3) {
      if (S2(t4))
        return t4.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t4, n3.args = arguments, new _2(n3);
    }, b2 = v2;
    b2.l = w2, b2.i = S2, b2.w = function(t4, e3) {
      return O2(t4, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M3(t4) {
        this.$L = w2(t4.locale, null, true), this.parse(t4), this.$x = this.$x || t4.x || {}, this[p2] = true;
      }
      var m3 = M3.prototype;
      return m3.parse = function(t4) {
        this.$d = function(t5) {
          var e3 = t5.date, n3 = t5.utc;
          if (null === e3)
            return /* @__PURE__ */ new Date(NaN);
          if (b2.u(e3))
            return /* @__PURE__ */ new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($2);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t4), this.init();
      }, m3.init = function() {
        var t4 = this.$d;
        this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
      }, m3.$utils = function() {
        return b2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t4, e3) {
        var n3 = O2(t4);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t4, e3) {
        return O2(t4) < this.startOf(e3);
      }, m3.isBefore = function(t4, e3) {
        return this.endOf(e3) < O2(t4);
      }, m3.$g = function(t4, e3, n3) {
        return b2.u(t4) ? this[e3] : this.set(n3, t4);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t4, e3) {
        var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t4), l3 = function(t5, e4) {
          var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t5) : new Date(n3.$y, e4, t5), n3);
          return r3 ? i3 : i3.endOf(a2);
        }, $3 = function(t5, e4) {
          return b2.w(n3.toDate()[t5].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M4) : l3(0, M4 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
          case a2:
          case d2:
            return $3(v3 + "Hours", 0);
          case u2:
            return $3(v3 + "Minutes", 1);
          case s2:
            return $3(v3 + "Seconds", 2);
          case i2:
            return $3(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t4) {
        return this.startOf(t4, false);
      }, m3.$set = function(t4, e3) {
        var n3, o3 = b2.p(t4), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($3), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($3);
        return this.init(), this;
      }, m3.set = function(t4, e3) {
        return this.clone().$set(t4, e3);
      }, m3.get = function(t4) {
        return this[b2.p(t4)]();
      }, m3.add = function(r3, f3) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $3 = b2.p(f3), y3 = function(t4) {
          var e3 = O2(l3);
          return b2.w(e3.date(e3.date() + Math.round(t4 * r3)), l3);
        };
        if ($3 === c2)
          return this.set(c2, this.$M + r3);
        if ($3 === h2)
          return this.set(h2, this.$y + r3);
        if ($3 === a2)
          return y3(1);
        if ($3 === o2)
          return y3(7);
        var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t3, d3)[$3] || 1, m4 = this.$d.getTime() + r3 * M4;
        return b2.w(m4, this);
      }, m3.subtract = function(t4, e3) {
        return this.add(-1 * t4, e3);
      }, m3.format = function(t4) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r3 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t5, n4, i4, s4) {
          return t5 && (t5[n4] || t5(e3, r3)) || i4[n4].slice(0, s4);
        }, d3 = function(t5) {
          return b2.s(s3 % 12 || 12, t5, "0");
        }, $3 = f3 || function(t5, e4, n4) {
          var r4 = t5 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t5, r4) {
          return r4 || function(t6) {
            switch (t6) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b2.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b2.s(a3 + 1, 2, "0");
              case "MMM":
                return h3(n3.monthsShort, a3, c3, 3);
              case "MMMM":
                return h3(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n3.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h3(n3.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s3);
              case "HH":
                return b2.s(s3, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $3(s3, u3, true);
              case "A":
                return $3(s3, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b2.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b2.s(e3.$s, 2, "0");
              case "SSS":
                return b2.s(e3.$ms, 3, "0");
              case "Z":
                return i3;
            }
            return null;
          }(t5) || i3.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, l3) {
        var $3, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
          return b2.m(y3, m4);
        };
        switch (M4) {
          case h2:
            $3 = D3() / 12;
            break;
          case c2:
            $3 = D3();
            break;
          case f2:
            $3 = D3() / 3;
            break;
          case o2:
            $3 = (g3 - v3) / 6048e5;
            break;
          case a2:
            $3 = (g3 - v3) / 864e5;
            break;
          case u2:
            $3 = g3 / n2;
            break;
          case s2:
            $3 = g3 / e2;
            break;
          case i2:
            $3 = g3 / t3;
            break;
          default:
            $3 = g3;
        }
        return l3 ? $3 : b2.a($3);
      }, m3.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t4, e3) {
        if (!t4)
          return this.$L;
        var n3 = this.clone(), r3 = w2(t4, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m3.clone = function() {
        return b2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), k2 = _2.prototype;
    return O2.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t4) {
      k2[t4[1]] = function(e3) {
        return this.$g(e3, t4[0], t4[1]);
      };
    }), O2.extend = function(t4, e3) {
      return t4.$i || (t4(e3, _2, O2), t4.$i = true), O2;
    }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t4) {
      return O2(1e3 * t4);
    }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const defaultDayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var weekOfYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t3) {
    module2.exports = t3();
  }(commonjsGlobal, function() {
    var e2 = "week", t3 = "year";
    return function(i2, n2, r2) {
      var f2 = n2.prototype;
      f2.week = function(i3) {
        if (void 0 === i3 && (i3 = null), null !== i3)
          return this.add(7 * (i3 - this.week()), "day");
        var n3 = this.$locale().yearStart || 1;
        if (11 === this.month() && this.date() > 25) {
          var f3 = r2(this).startOf(t3).add(1, t3).date(n3), s2 = r2(this).endOf(e2);
          if (f3.isBefore(s2))
            return 1;
        }
        var a2 = r2(this).startOf(t3).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a2, e2, true);
        return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
      }, f2.weeks = function(e3) {
        return void 0 === e3 && (e3 = null), this.week(e3);
      };
    };
  });
})(weekOfYear$1);
var weekOfYearExports = weekOfYear$1.exports;
const weekOfYear = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
var customParseFormat = { exports: {} };
(function(module2, exports2) {
  !function(e2, t3) {
    module2.exports = t3();
  }(commonjsGlobal, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t3 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i2 = /\d*[^-_:/,()\s\d]+/, o2 = {}, s2 = function(e3) {
      return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
    };
    var a2 = function(e3) {
      return function(t4) {
        this[e3] = +t4;
      };
    }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
      (this.zone || (this.zone = {})).offset = function(e4) {
        if (!e4)
          return 0;
        if ("Z" === e4)
          return 0;
        var t4 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t4[1] + (+t4[2] || 0);
        return 0 === n3 ? 0 : "+" === t4[0] ? -n3 : n3;
      }(e3);
    }], h2 = function(e3) {
      var t4 = o2[e3];
      return t4 && (t4.indexOf ? t4 : t4.s.concat(t4.f));
    }, u2 = function(e3, t4) {
      var n3, r3 = o2.meridiem;
      if (r3) {
        for (var i3 = 1; i3 <= 24; i3 += 1)
          if (e3.indexOf(r3(i3, 0, t4)) > -1) {
            n3 = i3 > 12;
            break;
          }
      } else
        n3 = e3 === (t4 ? "pm" : "PM");
      return n3;
    }, d2 = { A: [i2, function(e3) {
      this.afternoon = u2(e3, false);
    }], a: [i2, function(e3) {
      this.afternoon = u2(e3, true);
    }], S: [/\d/, function(e3) {
      this.milliseconds = 100 * +e3;
    }], SS: [n2, function(e3) {
      this.milliseconds = 10 * +e3;
    }], SSS: [/\d{3}/, function(e3) {
      this.milliseconds = +e3;
    }], s: [r2, a2("seconds")], ss: [r2, a2("seconds")], m: [r2, a2("minutes")], mm: [r2, a2("minutes")], H: [r2, a2("hours")], h: [r2, a2("hours")], HH: [r2, a2("hours")], hh: [r2, a2("hours")], D: [r2, a2("day")], DD: [n2, a2("day")], Do: [i2, function(e3) {
      var t4 = o2.ordinal, n3 = e3.match(/\d+/);
      if (this.day = n3[0], t4)
        for (var r3 = 1; r3 <= 31; r3 += 1)
          t4(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
    }], M: [r2, a2("month")], MM: [n2, a2("month")], MMM: [i2, function(e3) {
      var t4 = h2("months"), n3 = (h2("monthsShort") || t4.map(function(e4) {
        return e4.slice(0, 3);
      })).indexOf(e3) + 1;
      if (n3 < 1)
        throw new Error();
      this.month = n3 % 12 || n3;
    }], MMMM: [i2, function(e3) {
      var t4 = h2("months").indexOf(e3) + 1;
      if (t4 < 1)
        throw new Error();
      this.month = t4 % 12 || t4;
    }], Y: [/[+-]?\d+/, a2("year")], YY: [n2, function(e3) {
      this.year = s2(e3);
    }], YYYY: [/\d{4}/, a2("year")], Z: f2, ZZ: f2 };
    function c2(n3) {
      var r3, i3;
      r3 = n3, i3 = o2 && o2.formats;
      for (var s3 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t4, n4, r4) {
        var o3 = r4 && r4.toUpperCase();
        return n4 || i3[r4] || e2[r4] || i3[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t5, n5) {
          return t5 || n5.slice(1);
        });
      })).match(t3), a3 = s3.length, f3 = 0; f3 < a3; f3 += 1) {
        var h3 = s3[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
        s3[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
      }
      return function(e3) {
        for (var t4 = {}, n4 = 0, r4 = 0; n4 < a3; n4 += 1) {
          var i4 = s3[n4];
          if ("string" == typeof i4)
            r4 += i4.length;
          else {
            var o3 = i4.regex, f4 = i4.parser, h4 = e3.slice(r4), u4 = o3.exec(h4)[0];
            f4.call(t4, u4), e3 = e3.replace(u4, "");
          }
        }
        return function(e4) {
          var t5 = e4.afternoon;
          if (void 0 !== t5) {
            var n5 = e4.hours;
            t5 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
          }
        }(t4), t4;
      };
    }
    return function(e3, t4, n3) {
      n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s2 = e3.parseTwoDigitYear);
      var r3 = t4.prototype, i3 = r3.parse;
      r3.parse = function(e4) {
        var t5 = e4.date, r4 = e4.utc, s3 = e4.args;
        this.$u = r4;
        var a3 = s3[1];
        if ("string" == typeof a3) {
          var f3 = true === s3[2], h3 = true === s3[3], u3 = f3 || h3, d3 = s3[2];
          h3 && (d3 = s3[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n3.Ls[d3]), this.$d = function(e5, t6, n4) {
            try {
              if (["x", "X"].indexOf(t6) > -1)
                return new Date(("X" === t6 ? 1e3 : 1) * e5);
              var r5 = c2(t6)(e5), i4 = r5.year, o3 = r5.month, s4 = r5.day, a4 = r5.hours, f4 = r5.minutes, h4 = r5.seconds, u4 = r5.milliseconds, d4 = r5.zone, l3 = /* @__PURE__ */ new Date(), m3 = s4 || (i4 || o3 ? 1 : l3.getDate()), M3 = i4 || l3.getFullYear(), Y2 = 0;
              i4 && !o3 || (Y2 = o3 > 0 ? o3 - 1 : l3.getMonth());
              var p2 = a4 || 0, v2 = f4 || 0, D2 = h4 || 0, g2 = u4 || 0;
              return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2 + 60 * d4.offset * 1e3)) : n4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2)) : new Date(M3, Y2, m3, p2, v2, D2, g2);
            } catch (e6) {
              return /* @__PURE__ */ new Date("");
            }
          }(t5, a3, r4), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t5 != this.format(a3) && (this.$d = /* @__PURE__ */ new Date("")), o2 = {};
        } else if (a3 instanceof Array)
          for (var l2 = a3.length, m2 = 1; m2 <= l2; m2 += 1) {
            s3[1] = a3[m2 - 1];
            var M2 = n3.apply(this, s3);
            if (M2.isValid()) {
              this.$d = M2.$d, this.$L = M2.$L, this.init();
              break;
            }
            m2 === l2 && (this.$d = /* @__PURE__ */ new Date(""));
          }
        else
          i3.call(this, e4);
      };
    };
  });
})(customParseFormat);
var customParseFormatExports = customParseFormat.exports;
const customParseFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
var localizedFormat = { exports: {} };
(function(module2, exports2) {
  !function(e2, t3) {
    module2.exports = t3();
  }(commonjsGlobal, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(t3, o2, n2) {
      var r2 = o2.prototype, i2 = r2.format;
      n2.en.formats = e2, r2.format = function(t4) {
        void 0 === t4 && (t4 = "YYYY-MM-DDTHH:mm:ssZ");
        var o3 = this.$locale().formats, n3 = function(t5, o4) {
          return t5.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t6, n4, r3) {
            var i3 = r3 && r3.toUpperCase();
            return n4 || o4[r3] || e2[r3] || o4[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t7, o5) {
              return t7 || o5.slice(1);
            });
          });
        }(t4, void 0 === o3 ? {} : o3);
        return i2.call(this, n3);
      };
    };
  });
})(localizedFormat);
var localizedFormatExports = localizedFormat.exports;
const localizedFormatPlugin = /* @__PURE__ */ getDefaultExportFromCjs(localizedFormatExports);
var isBetween = { exports: {} };
(function(module2, exports2) {
  !function(e2, i2) {
    module2.exports = i2();
  }(commonjsGlobal, function() {
    return function(e2, i2, t3) {
      i2.prototype.isBetween = function(e3, i3, s2, f2) {
        var n2 = t3(e3), o2 = t3(i3), r2 = "(" === (f2 = f2 || "()")[0], u2 = ")" === f2[1];
        return (r2 ? this.isAfter(n2, s2) : !this.isBefore(n2, s2)) && (u2 ? this.isBefore(o2, s2) : !this.isAfter(o2, s2)) || (r2 ? this.isBefore(n2, s2) : !this.isAfter(n2, s2)) && (u2 ? this.isAfter(o2, s2) : !this.isBefore(o2, s2));
      };
    };
  });
})(isBetween);
var isBetweenExports = isBetween.exports;
const isBetweenPlugin = /* @__PURE__ */ getDefaultExportFromCjs(isBetweenExports);
const buildWarning = (message, gravity = "warning") => {
  let alreadyWarned = false;
  const cleanMessage = Array.isArray(message) ? message.join("\n") : message;
  return () => {
    if (!alreadyWarned) {
      alreadyWarned = true;
      if (gravity === "error") {
        console.error(cleanMessage);
      } else {
        console.warn(cleanMessage);
      }
    }
  };
};
defaultDayjs.extend(customParseFormatPlugin);
defaultDayjs.extend(localizedFormatPlugin);
defaultDayjs.extend(isBetweenPlugin);
const localeNotFoundWarning = buildWarning(["Your locale has not been found.", "Either the locale key is not a supported one. Locales supported by dayjs are available here: https://github.com/iamkun/dayjs/tree/dev/src/locale", "Or you forget to import the locale from 'dayjs/locale/{localeUsed}'", "fallback on English locale"]);
const formatTokenMap = {
  // Year
  YY: "year",
  YYYY: {
    sectionType: "year",
    contentType: "digit",
    maxLength: 4
  },
  // Month
  M: {
    sectionType: "month",
    contentType: "digit",
    maxLength: 2
  },
  MM: "month",
  MMM: {
    sectionType: "month",
    contentType: "letter"
  },
  MMMM: {
    sectionType: "month",
    contentType: "letter"
  },
  // Day of the month
  D: {
    sectionType: "day",
    contentType: "digit",
    maxLength: 2
  },
  DD: "day",
  Do: {
    sectionType: "day",
    contentType: "digit-with-letter"
  },
  // Day of the week
  d: {
    sectionType: "weekDay",
    contentType: "digit",
    maxLength: 2
  },
  dd: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  ddd: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  dddd: {
    sectionType: "weekDay",
    contentType: "letter"
  },
  // Meridiem
  A: "meridiem",
  a: "meridiem",
  // Hours
  H: {
    sectionType: "hours",
    contentType: "digit",
    maxLength: 2
  },
  HH: "hours",
  h: {
    sectionType: "hours",
    contentType: "digit",
    maxLength: 2
  },
  hh: "hours",
  // Minutes
  m: {
    sectionType: "minutes",
    contentType: "digit",
    maxLength: 2
  },
  mm: "minutes",
  // Seconds
  s: {
    sectionType: "seconds",
    contentType: "digit",
    maxLength: 2
  },
  ss: "seconds"
};
const defaultFormats = {
  year: "YYYY",
  month: "MMMM",
  monthShort: "MMM",
  dayOfMonth: "D",
  weekday: "dddd",
  weekdayShort: "ddd",
  hours24h: "HH",
  hours12h: "hh",
  meridiem: "A",
  minutes: "mm",
  seconds: "ss",
  fullDate: "ll",
  fullDateWithWeekday: "dddd, LL",
  keyboardDate: "L",
  shortDate: "MMM D",
  normalDate: "D MMMM",
  normalDateWithWeekday: "ddd, MMM D",
  monthAndYear: "MMMM YYYY",
  monthAndDate: "MMMM D",
  fullTime: "LT",
  fullTime12h: "hh:mm A",
  fullTime24h: "HH:mm",
  fullDateTime: "lll",
  fullDateTime12h: "ll hh:mm A",
  fullDateTime24h: "ll HH:mm",
  keyboardDateTime: "L LT",
  keyboardDateTime12h: "L hh:mm A",
  keyboardDateTime24h: "L HH:mm"
};
const MISSING_UTC_PLUGIN = ["Missing UTC plugin", "To be able to use UTC or timezones, you have to enable the `utc` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join("\n");
const MISSING_TIMEZONE_PLUGIN = ["Missing timezone plugin", "To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin", "Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join("\n");
const withLocale = (dayjs, locale) => !locale ? dayjs : (...args) => dayjs(...args).locale(locale);
class AdapterDayjs {
  constructor({
    locale: _locale,
    formats,
    instance
  } = {}) {
    var _this$rawDayJsInstanc;
    this.isMUIAdapter = true;
    this.isTimezoneCompatible = true;
    this.lib = "dayjs";
    this.rawDayJsInstance = void 0;
    this.dayjs = void 0;
    this.locale = void 0;
    this.formats = void 0;
    this.escapedCharacters = {
      start: "[",
      end: "]"
    };
    this.formatTokenMap = formatTokenMap;
    this.setLocaleToValue = (value) => {
      const expectedLocale = this.getCurrentLocaleCode();
      if (expectedLocale === value.locale()) {
        return value;
      }
      return value.locale(expectedLocale);
    };
    this.hasUTCPlugin = () => typeof defaultDayjs.utc !== "undefined";
    this.hasTimezonePlugin = () => typeof defaultDayjs.tz !== "undefined";
    this.isSame = (value, comparing, comparisonTemplate) => {
      const comparingInValueTimezone = this.setTimezone(comparing, this.getTimezone(value));
      return value.format(comparisonTemplate) === comparingInValueTimezone.format(comparisonTemplate);
    };
    this.cleanTimezone = (timezone) => {
      switch (timezone) {
        case "default": {
          return void 0;
        }
        case "system": {
          return defaultDayjs.tz.guess();
        }
        default: {
          return timezone;
        }
      }
    };
    this.createSystemDate = (value) => {
      if (this.rawDayJsInstance) {
        return this.rawDayJsInstance(value);
      }
      if (this.hasUTCPlugin() && this.hasTimezonePlugin()) {
        const timezone = defaultDayjs.tz.guess();
        if (timezone !== "UTC") {
          return defaultDayjs.tz(value, timezone);
        }
        return defaultDayjs(value);
      }
      return defaultDayjs(value);
    };
    this.createUTCDate = (value) => {
      if (!this.hasUTCPlugin()) {
        throw new Error(MISSING_UTC_PLUGIN);
      }
      return defaultDayjs.utc(value);
    };
    this.createTZDate = (value, timezone) => {
      if (!this.hasUTCPlugin()) {
        throw new Error(MISSING_UTC_PLUGIN);
      }
      if (!this.hasTimezonePlugin()) {
        throw new Error(MISSING_TIMEZONE_PLUGIN);
      }
      const keepLocalTime = value !== void 0 && !value.endsWith("Z");
      return defaultDayjs(value).tz(this.cleanTimezone(timezone), keepLocalTime);
    };
    this.getLocaleFormats = () => {
      const locales = defaultDayjs.Ls;
      const locale = this.locale || "en";
      let localeObject = locales[locale];
      if (localeObject === void 0) {
        localeNotFoundWarning();
        localeObject = locales.en;
      }
      return localeObject.formats;
    };
    this.adjustOffset = (value) => {
      if (!this.hasTimezonePlugin()) {
        return value;
      }
      const timezone = this.getTimezone(value);
      if (timezone !== "UTC") {
        var _fixedValue$$offset, _value$$offset;
        const fixedValue = value.tz(this.cleanTimezone(timezone), true);
        if (((_fixedValue$$offset = fixedValue.$offset) != null ? _fixedValue$$offset : 0) === ((_value$$offset = value.$offset) != null ? _value$$offset : 0)) {
          return value;
        }
        return fixedValue;
      }
      return value;
    };
    this.date = (value) => {
      if (value === null) {
        return null;
      }
      return this.dayjs(value);
    };
    this.dateWithTimezone = (value, timezone) => {
      if (value === null) {
        return null;
      }
      let parsedValue;
      if (timezone === "UTC") {
        parsedValue = this.createUTCDate(value);
      } else if (timezone === "system" || timezone === "default" && !this.hasTimezonePlugin()) {
        parsedValue = this.createSystemDate(value);
      } else {
        parsedValue = this.createTZDate(value, timezone);
      }
      if (this.locale === void 0) {
        return parsedValue;
      }
      return parsedValue.locale(this.locale);
    };
    this.getTimezone = (value) => {
      if (this.hasUTCPlugin() && value.isUTC()) {
        return "UTC";
      }
      if (this.hasTimezonePlugin()) {
        var _value$$x;
        const zone = (_value$$x = value.$x) == null ? void 0 : _value$$x.$timezone;
        return zone != null ? zone : "system";
      }
      return "system";
    };
    this.setTimezone = (value, timezone) => {
      if (this.getTimezone(value) === timezone) {
        return value;
      }
      if (timezone === "UTC") {
        if (!this.hasUTCPlugin()) {
          throw new Error(MISSING_UTC_PLUGIN);
        }
        return value.utc();
      }
      if (timezone === "system") {
        return value.local();
      }
      if (!this.hasTimezonePlugin()) {
        if (timezone === "default") {
          return value;
        }
        throw new Error(MISSING_TIMEZONE_PLUGIN);
      }
      return defaultDayjs.tz(value, this.cleanTimezone(timezone));
    };
    this.toJsDate = (value) => {
      return value.toDate();
    };
    this.parseISO = (isoString) => {
      return this.dayjs(isoString);
    };
    this.toISO = (value) => {
      return value.toISOString();
    };
    this.parse = (value, format2) => {
      if (value === "") {
        return null;
      }
      return this.dayjs(value, format2, this.locale, true);
    };
    this.getCurrentLocaleCode = () => {
      return this.locale || "en";
    };
    this.is12HourCycleInCurrentLocale = () => {
      return /A|a/.test(this.getLocaleFormats().LT || "");
    };
    this.expandFormat = (format2) => {
      const localeFormats = this.getLocaleFormats();
      const t3 = (formatBis) => formatBis.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (_2, a2, b2) => a2 || b2.slice(1));
      return format2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (_2, a2, b2) => {
        const B3 = b2 && b2.toUpperCase();
        return a2 || localeFormats[b2] || t3(localeFormats[B3]);
      });
    };
    this.getFormatHelperText = (format2) => {
      return this.expandFormat(format2).replace(/a/gi, "(a|p)m").toLocaleLowerCase();
    };
    this.isNull = (value) => {
      return value === null;
    };
    this.isValid = (value) => {
      return this.dayjs(value).isValid();
    };
    this.format = (value, formatKey) => {
      return this.formatByString(value, this.formats[formatKey]);
    };
    this.formatByString = (value, formatString) => {
      return this.dayjs(value).format(formatString);
    };
    this.formatNumber = (numberToFormat) => {
      return numberToFormat;
    };
    this.getDiff = (value, comparing, unit) => {
      return value.diff(comparing, unit);
    };
    this.isEqual = (value, comparing) => {
      if (value === null && comparing === null) {
        return true;
      }
      return this.dayjs(value).toDate().getTime() === this.dayjs(comparing).toDate().getTime();
    };
    this.isSameYear = (value, comparing) => {
      return this.isSame(value, comparing, "YYYY");
    };
    this.isSameMonth = (value, comparing) => {
      return this.isSame(value, comparing, "YYYY-MM");
    };
    this.isSameDay = (value, comparing) => {
      return this.isSame(value, comparing, "YYYY-MM-DD");
    };
    this.isSameHour = (value, comparing) => {
      return value.isSame(comparing, "hour");
    };
    this.isAfter = (value, comparing) => {
      return value > comparing;
    };
    this.isAfterYear = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isAfter(comparing, "year");
      }
      return !this.isSameYear(value, comparing) && value.utc() > comparing.utc();
    };
    this.isAfterDay = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isAfter(comparing, "day");
      }
      return !this.isSameDay(value, comparing) && value.utc() > comparing.utc();
    };
    this.isBefore = (value, comparing) => {
      return value < comparing;
    };
    this.isBeforeYear = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isBefore(comparing, "year");
      }
      return !this.isSameYear(value, comparing) && value.utc() < comparing.utc();
    };
    this.isBeforeDay = (value, comparing) => {
      if (!this.hasUTCPlugin()) {
        return value.isBefore(comparing, "day");
      }
      return !this.isSameDay(value, comparing) && value.utc() < comparing.utc();
    };
    this.isWithinRange = (value, [start2, end2]) => {
      return value >= start2 && value <= end2;
    };
    this.startOfYear = (value) => {
      return this.adjustOffset(value.startOf("year"));
    };
    this.startOfMonth = (value) => {
      return this.adjustOffset(value.startOf("month"));
    };
    this.startOfWeek = (value) => {
      return this.adjustOffset(value.startOf("week"));
    };
    this.startOfDay = (value) => {
      return this.adjustOffset(value.startOf("day"));
    };
    this.endOfYear = (value) => {
      return this.adjustOffset(value.endOf("year"));
    };
    this.endOfMonth = (value) => {
      return this.adjustOffset(value.endOf("month"));
    };
    this.endOfWeek = (value) => {
      return this.adjustOffset(value.endOf("week"));
    };
    this.endOfDay = (value) => {
      return this.adjustOffset(value.endOf("day"));
    };
    this.addYears = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "year") : value.add(amount, "year"));
    };
    this.addMonths = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "month") : value.add(amount, "month"));
    };
    this.addWeeks = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "week") : value.add(amount, "week"));
    };
    this.addDays = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "day") : value.add(amount, "day"));
    };
    this.addHours = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "hour") : value.add(amount, "hour"));
    };
    this.addMinutes = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "minute") : value.add(amount, "minute"));
    };
    this.addSeconds = (value, amount) => {
      return this.adjustOffset(amount < 0 ? value.subtract(Math.abs(amount), "second") : value.add(amount, "second"));
    };
    this.getYear = (value) => {
      return value.year();
    };
    this.getMonth = (value) => {
      return value.month();
    };
    this.getDate = (value) => {
      return value.date();
    };
    this.getHours = (value) => {
      return value.hour();
    };
    this.getMinutes = (value) => {
      return value.minute();
    };
    this.getSeconds = (value) => {
      return value.second();
    };
    this.getMilliseconds = (value) => {
      return value.millisecond();
    };
    this.setYear = (value, year) => {
      return this.adjustOffset(value.set("year", year));
    };
    this.setMonth = (value, month) => {
      return this.adjustOffset(value.set("month", month));
    };
    this.setDate = (value, date2) => {
      return this.adjustOffset(value.set("date", date2));
    };
    this.setHours = (value, hours) => {
      return this.adjustOffset(value.set("hour", hours));
    };
    this.setMinutes = (value, minutes) => {
      return this.adjustOffset(value.set("minute", minutes));
    };
    this.setSeconds = (value, seconds) => {
      return this.adjustOffset(value.set("second", seconds));
    };
    this.setMilliseconds = (value, milliseconds) => {
      return this.adjustOffset(value.set("millisecond", milliseconds));
    };
    this.getDaysInMonth = (value) => {
      return value.daysInMonth();
    };
    this.getNextMonth = (value) => {
      return this.addMonths(value, 1);
    };
    this.getPreviousMonth = (value) => {
      return this.addMonths(value, -1);
    };
    this.getMonthArray = (value) => {
      const firstMonth = value.startOf("year");
      const monthArray = [firstMonth];
      while (monthArray.length < 12) {
        const prevMonth = monthArray[monthArray.length - 1];
        monthArray.push(this.addMonths(prevMonth, 1));
      }
      return monthArray;
    };
    this.mergeDateAndTime = (dateParam, timeParam) => {
      return dateParam.hour(timeParam.hour()).minute(timeParam.minute()).second(timeParam.second());
    };
    this.getWeekdays = () => {
      const start2 = this.dayjs().startOf("week");
      return [0, 1, 2, 3, 4, 5, 6].map((diff) => this.formatByString(this.addDays(start2, diff), "dd"));
    };
    this.getWeekArray = (value) => {
      const cleanValue = this.setLocaleToValue(value);
      const start2 = cleanValue.startOf("month").startOf("week");
      const end2 = cleanValue.endOf("month").endOf("week");
      let count = 0;
      let current = start2;
      const nestedWeeks = [];
      while (current < end2) {
        const weekNumber = Math.floor(count / 7);
        nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
        nestedWeeks[weekNumber].push(current);
        current = this.addDays(current, 1);
        count += 1;
      }
      return nestedWeeks;
    };
    this.getWeekNumber = (value) => {
      return value.week();
    };
    this.getYearRange = (start2, end2) => {
      const startDate = start2.startOf("year");
      const endDate = end2.endOf("year");
      const years = [];
      let current = startDate;
      while (current < endDate) {
        years.push(current);
        current = this.addYears(current, 1);
      }
      return years;
    };
    this.getMeridiemText = (ampm) => {
      return ampm === "am" ? "AM" : "PM";
    };
    this.rawDayJsInstance = instance;
    this.dayjs = withLocale((_this$rawDayJsInstanc = this.rawDayJsInstance) != null ? _this$rawDayJsInstanc : defaultDayjs, _locale);
    this.locale = _locale;
    this.formats = _extends$2({}, defaultFormats, formats);
    defaultDayjs.extend(weekOfYear);
  }
}
const _excluded$m = ["localeText"];
const MuiPickersAdapterContext = /* @__PURE__ */ reactExports.createContext(null);
const LocalizationProvider = function LocalizationProvider2(inProps) {
  var _React$useContext;
  const {
    localeText: inLocaleText
  } = inProps, otherInProps = _objectWithoutPropertiesLoose$1(inProps, _excluded$m);
  const {
    utils: parentUtils,
    localeText: parentLocaleText
  } = (_React$useContext = reactExports.useContext(MuiPickersAdapterContext)) != null ? _React$useContext : {
    utils: void 0,
    localeText: void 0
  };
  const props = useThemeProps({
    // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
    // We will then merge this theme value with our value manually
    props: otherInProps,
    name: "MuiLocalizationProvider"
  });
  const {
    children,
    dateAdapter: DateAdapter,
    dateFormats,
    dateLibInstance,
    adapterLocale,
    localeText: themeLocaleText
  } = props;
  const localeText = reactExports.useMemo(() => _extends$2({}, themeLocaleText, parentLocaleText, inLocaleText), [themeLocaleText, parentLocaleText, inLocaleText]);
  const utils2 = reactExports.useMemo(() => {
    if (!DateAdapter) {
      if (parentUtils) {
        return parentUtils;
      }
      return null;
    }
    const adapter = new DateAdapter({
      locale: adapterLocale,
      formats: dateFormats,
      instance: dateLibInstance
    });
    if (!adapter.isMUIAdapter) {
      throw new Error(["MUI: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`", "For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`", "More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join(`
`));
    }
    return adapter;
  }, [DateAdapter, adapterLocale, dateFormats, dateLibInstance, parentUtils]);
  const defaultDates = reactExports.useMemo(() => {
    if (!utils2) {
      return null;
    }
    return {
      minDate: utils2.date("1900-01-01T00:00:00.000"),
      maxDate: utils2.date("2099-12-31T00:00:00.000")
    };
  }, [utils2]);
  const contextValue = reactExports.useMemo(() => {
    return {
      utils: utils2,
      defaultDates,
      localeText
    };
  }, [defaultDates, utils2, localeText]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MuiPickersAdapterContext.Provider, {
    value: contextValue,
    children
  });
};
const areViewsEqual = (views, expectedViews) => {
  if (views.length !== expectedViews.length) {
    return false;
  }
  return expectedViews.every((expectedView) => views.includes(expectedView));
};
const applyDefaultViewProps = ({
  openTo,
  defaultOpenTo,
  views,
  defaultViews
}) => {
  const viewsWithDefault = views != null ? views : defaultViews;
  let openToWithDefault;
  if (openTo != null) {
    openToWithDefault = openTo;
  } else if (viewsWithDefault.includes(defaultOpenTo)) {
    openToWithDefault = defaultOpenTo;
  } else if (viewsWithDefault.length > 0) {
    openToWithDefault = viewsWithDefault[0];
  } else {
    throw new Error("MUI: The `views` prop must contain at least one view");
  }
  return {
    views: viewsWithDefault,
    openTo: openToWithDefault
  };
};
const findClosestEnabledDate = ({
  date: date2,
  disableFuture,
  disablePast,
  maxDate,
  minDate,
  isDateDisabled,
  utils: utils2,
  timezone
}) => {
  const today = utils2.startOfDay(utils2.dateWithTimezone(void 0, timezone));
  if (disablePast && utils2.isBefore(minDate, today)) {
    minDate = today;
  }
  if (disableFuture && utils2.isAfter(maxDate, today)) {
    maxDate = today;
  }
  let forward = date2;
  let backward = date2;
  if (utils2.isBefore(date2, minDate)) {
    forward = minDate;
    backward = null;
  }
  if (utils2.isAfter(date2, maxDate)) {
    if (backward) {
      backward = maxDate;
    }
    forward = null;
  }
  while (forward || backward) {
    if (forward && utils2.isAfter(forward, maxDate)) {
      forward = null;
    }
    if (backward && utils2.isBefore(backward, minDate)) {
      backward = null;
    }
    if (forward) {
      if (!isDateDisabled(forward)) {
        return forward;
      }
      forward = utils2.addDays(forward, 1);
    }
    if (backward) {
      if (!isDateDisabled(backward)) {
        return backward;
      }
      backward = utils2.addDays(backward, -1);
    }
  }
  return null;
};
const replaceInvalidDateByNull = (utils2, value) => value == null || !utils2.isValid(value) ? null : value;
const applyDefaultDate = (utils2, value, defaultValue) => {
  if (value == null || !utils2.isValid(value)) {
    return defaultValue;
  }
  return value;
};
const areDatesEqual = (utils2, a2, b2) => {
  if (!utils2.isValid(a2) && a2 != null && !utils2.isValid(b2) && b2 != null) {
    return true;
  }
  return utils2.isEqual(a2, b2);
};
const getMonthsInYear = (utils2, year) => {
  const firstMonth = utils2.startOfYear(year);
  const months = [firstMonth];
  while (months.length < 12) {
    const prevMonth = months[months.length - 1];
    months.push(utils2.addMonths(prevMonth, 1));
  }
  return months;
};
const mergeDateAndTime = (utils2, dateParam, timeParam) => {
  let mergedDate = dateParam;
  mergedDate = utils2.setHours(mergedDate, utils2.getHours(timeParam));
  mergedDate = utils2.setMinutes(mergedDate, utils2.getMinutes(timeParam));
  mergedDate = utils2.setSeconds(mergedDate, utils2.getSeconds(timeParam));
  return mergedDate;
};
const getTodayDate = (utils2, timezone, valueType) => valueType === "date" ? utils2.startOfDay(utils2.dateWithTimezone(void 0, timezone)) : utils2.dateWithTimezone(void 0, timezone);
const dateViews = ["year", "month", "day"];
const isDatePickerView = (view) => dateViews.includes(view);
const resolveDateFormat = (utils2, {
  format: format2,
  views
}, isInToolbar) => {
  if (format2 != null) {
    return format2;
  }
  const formats = utils2.formats;
  if (areViewsEqual(views, ["year"])) {
    return formats.year;
  }
  if (areViewsEqual(views, ["month"])) {
    return formats.month;
  }
  if (areViewsEqual(views, ["day"])) {
    return formats.dayOfMonth;
  }
  if (areViewsEqual(views, ["month", "year"])) {
    return `${formats.month} ${formats.year}`;
  }
  if (areViewsEqual(views, ["day", "month"])) {
    return `${formats.month} ${formats.dayOfMonth}`;
  }
  if (isInToolbar) {
    return /en/.test(utils2.getCurrentLocaleCode()) ? formats.normalDateWithWeekday : formats.normalDate;
  }
  return formats.keyboardDate;
};
const getWeekdays = (utils2, date2) => {
  const start2 = utils2.startOfWeek(date2);
  return [0, 1, 2, 3, 4, 5, 6].map((diff) => utils2.addDays(start2, diff));
};
const timeViews = ["hours", "minutes", "seconds"];
const isTimeView = (view) => timeViews.includes(view);
const getSecondsInDay = (date2, utils2) => {
  return utils2.getHours(date2) * 3600 + utils2.getMinutes(date2) * 60 + utils2.getSeconds(date2);
};
const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation, utils2) => (dateLeft, dateRight) => {
  if (disableIgnoringDatePartForTimeValidation) {
    return utils2.isAfter(dateLeft, dateRight);
  }
  return getSecondsInDay(dateLeft, utils2) > getSecondsInDay(dateRight, utils2);
};
const SECTION_TYPE_GRANULARITY = {
  year: 1,
  month: 2,
  day: 3,
  hours: 4,
  minutes: 5,
  seconds: 6,
  milliseconds: 7
};
const getSectionTypeGranularity = (sections) => Math.max(...sections.map((section) => {
  var _SECTION_TYPE_GRANULA;
  return (_SECTION_TYPE_GRANULA = SECTION_TYPE_GRANULARITY[section.type]) != null ? _SECTION_TYPE_GRANULA : 1;
}));
const roundDate = (utils2, granularity, date2) => {
  if (granularity === SECTION_TYPE_GRANULARITY.year) {
    return utils2.startOfYear(date2);
  }
  if (granularity === SECTION_TYPE_GRANULARITY.month) {
    return utils2.startOfMonth(date2);
  }
  if (granularity === SECTION_TYPE_GRANULARITY.day) {
    return utils2.startOfDay(date2);
  }
  let roundedDate = date2;
  if (granularity < SECTION_TYPE_GRANULARITY.minutes) {
    roundedDate = utils2.setMinutes(roundedDate, 0);
  }
  if (granularity < SECTION_TYPE_GRANULARITY.seconds) {
    roundedDate = utils2.setSeconds(roundedDate, 0);
  }
  if (granularity < SECTION_TYPE_GRANULARITY.milliseconds) {
    roundedDate = utils2.setMilliseconds(roundedDate, 0);
  }
  return roundedDate;
};
const getDefaultReferenceDate = ({
  props,
  utils: utils2,
  granularity,
  timezone,
  getTodayDate: inGetTodayDate
}) => {
  var _props$disableIgnorin;
  let referenceDate = inGetTodayDate ? inGetTodayDate() : roundDate(utils2, granularity, getTodayDate(utils2, timezone));
  if (props.minDate != null && utils2.isAfterDay(props.minDate, referenceDate)) {
    referenceDate = roundDate(utils2, granularity, props.minDate);
  }
  if (props.maxDate != null && utils2.isBeforeDay(props.maxDate, referenceDate)) {
    referenceDate = roundDate(utils2, granularity, props.maxDate);
  }
  const isAfter = createIsAfterIgnoreDatePart((_props$disableIgnorin = props.disableIgnoringDatePartForTimeValidation) != null ? _props$disableIgnorin : false, utils2);
  if (props.minTime != null && isAfter(props.minTime, referenceDate)) {
    referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.minTime : mergeDateAndTime(utils2, referenceDate, props.minTime));
  }
  if (props.maxTime != null && isAfter(referenceDate, props.maxTime)) {
    referenceDate = roundDate(utils2, granularity, props.disableIgnoringDatePartForTimeValidation ? props.maxTime : mergeDateAndTime(utils2, referenceDate, props.maxTime));
  }
  return referenceDate;
};
const getDateSectionConfigFromFormatToken = (utils2, formatToken) => {
  const config2 = utils2.formatTokenMap[formatToken];
  if (config2 == null) {
    throw new Error([`MUI: The token "${formatToken}" is not supported by the Date and Time Pickers.`, "Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));
  }
  if (typeof config2 === "string") {
    return {
      type: config2,
      contentType: config2 === "meridiem" ? "letter" : "digit",
      maxLength: void 0
    };
  }
  return {
    type: config2.sectionType,
    contentType: config2.contentType,
    maxLength: config2.maxLength
  };
};
const getDeltaFromKeyCode = (keyCode) => {
  switch (keyCode) {
    case "ArrowUp":
      return 1;
    case "ArrowDown":
      return -1;
    case "PageUp":
      return 5;
    case "PageDown":
      return -5;
    default:
      return 0;
  }
};
const getDaysInWeekStr = (utils2, timezone, format2) => {
  const elements = [];
  const now2 = utils2.dateWithTimezone(void 0, timezone);
  const startDate = utils2.startOfWeek(now2);
  const endDate = utils2.endOfWeek(now2);
  let current = startDate;
  while (utils2.isBefore(current, endDate)) {
    elements.push(current);
    current = utils2.addDays(current, 1);
  }
  return elements.map((weekDay) => utils2.formatByString(weekDay, format2));
};
const getLetterEditingOptions = (utils2, timezone, sectionType, format2) => {
  switch (sectionType) {
    case "month": {
      return getMonthsInYear(utils2, utils2.dateWithTimezone(void 0, timezone)).map((month) => utils2.formatByString(month, format2));
    }
    case "weekDay": {
      return getDaysInWeekStr(utils2, timezone, format2);
    }
    case "meridiem": {
      const now2 = utils2.dateWithTimezone(void 0, timezone);
      return [utils2.startOfDay(now2), utils2.endOfDay(now2)].map((date2) => utils2.formatByString(date2, format2));
    }
    default: {
      return [];
    }
  }
};
const cleanLeadingZeros = (utils2, valueStr, size) => {
  let cleanValueStr = valueStr;
  cleanValueStr = Number(cleanValueStr).toString();
  while (cleanValueStr.length < size) {
    cleanValueStr = `0${cleanValueStr}`;
  }
  return cleanValueStr;
};
const cleanDigitSectionValue = (utils2, timezone, value, sectionBoundaries, section) => {
  if (section.type === "day" && section.contentType === "digit-with-letter") {
    const date2 = utils2.setDate(sectionBoundaries.longestMonth, value);
    return utils2.formatByString(date2, section.format);
  }
  const valueStr = value.toString();
  if (section.hasLeadingZerosInInput) {
    return cleanLeadingZeros(utils2, valueStr, section.maxLength);
  }
  return valueStr;
};
const adjustSectionValue = (utils2, timezone, section, keyCode, sectionsValueBoundaries, activeDate, stepsAttributes) => {
  const delta = getDeltaFromKeyCode(keyCode);
  const isStart = keyCode === "Home";
  const isEnd = keyCode === "End";
  const shouldSetAbsolute = section.value === "" || isStart || isEnd;
  const adjustDigitSection = () => {
    const sectionBoundaries = sectionsValueBoundaries[section.type]({
      currentDate: activeDate,
      format: section.format,
      contentType: section.contentType
    });
    const getCleanValue = (value) => cleanDigitSectionValue(utils2, timezone, value, sectionBoundaries, section);
    const step = section.type === "minutes" && stepsAttributes != null && stepsAttributes.minutesStep ? stepsAttributes.minutesStep : 1;
    const currentSectionValue = parseInt(section.value, 10);
    let newSectionValueNumber = currentSectionValue + delta * step;
    if (shouldSetAbsolute) {
      if (section.type === "year" && !isEnd && !isStart) {
        return utils2.formatByString(utils2.dateWithTimezone(void 0, timezone), section.format);
      }
      if (delta > 0 || isStart) {
        newSectionValueNumber = sectionBoundaries.minimum;
      } else {
        newSectionValueNumber = sectionBoundaries.maximum;
      }
    }
    if (newSectionValueNumber % step !== 0) {
      if (delta < 0 || isStart) {
        newSectionValueNumber += step - (step + newSectionValueNumber) % step;
      }
      if (delta > 0 || isEnd) {
        newSectionValueNumber -= newSectionValueNumber % step;
      }
    }
    if (newSectionValueNumber > sectionBoundaries.maximum) {
      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
    }
    if (newSectionValueNumber < sectionBoundaries.minimum) {
      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));
    }
    return getCleanValue(newSectionValueNumber);
  };
  const adjustLetterSection = () => {
    const options = getLetterEditingOptions(utils2, timezone, section.type, section.format);
    if (options.length === 0) {
      return section.value;
    }
    if (shouldSetAbsolute) {
      if (delta > 0 || isStart) {
        return options[0];
      }
      return options[options.length - 1];
    }
    const currentOptionIndex = options.indexOf(section.value);
    const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;
    return options[newOptionIndex];
  };
  if (section.contentType === "digit" || section.contentType === "digit-with-letter") {
    return adjustDigitSection();
  }
  return adjustLetterSection();
};
const getSectionVisibleValue = (section, target) => {
  let value = section.value || section.placeholder;
  const hasLeadingZeros = target === "non-input" ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;
  if (target === "non-input" && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {
    value = Number(value).toString();
  }
  const shouldAddInvisibleSpace = ["input-rtl", "input-ltr"].includes(target) && section.contentType === "digit" && !hasLeadingZeros && value.length === 1;
  if (shouldAddInvisibleSpace) {
    value = `${value}‎`;
  }
  if (target === "input-rtl") {
    value = `⁨${value}⁩`;
  }
  return value;
};
const cleanString = (dirtyString) => dirtyString.replace(/[\u2066\u2067\u2068\u2069]/g, "");
const addPositionPropertiesToSections = (sections, isRTL) => {
  let position2 = 0;
  let positionInInput = isRTL ? 1 : 0;
  const newSections = [];
  for (let i2 = 0; i2 < sections.length; i2 += 1) {
    const section = sections[i2];
    const renderedValue = getSectionVisibleValue(section, isRTL ? "input-rtl" : "input-ltr");
    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;
    const sectionLength = cleanString(sectionStr).length;
    const sectionLengthInInput = sectionStr.length;
    const cleanedValue = cleanString(renderedValue);
    const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;
    const endInInput = startInInput + cleanedValue.length;
    newSections.push(_extends$2({}, section, {
      start: position2,
      end: position2 + sectionLength,
      startInInput,
      endInInput
    }));
    position2 += sectionLength;
    positionInInput += sectionLengthInInput;
  }
  return newSections;
};
const getSectionPlaceholder = (utils2, timezone, localeText, sectionConfig, currentTokenValue) => {
  switch (sectionConfig.type) {
    case "year": {
      return localeText.fieldYearPlaceholder({
        digitAmount: utils2.formatByString(utils2.dateWithTimezone(void 0, timezone), currentTokenValue).length
      });
    }
    case "month": {
      return localeText.fieldMonthPlaceholder({
        contentType: sectionConfig.contentType
      });
    }
    case "day": {
      return localeText.fieldDayPlaceholder();
    }
    case "weekDay": {
      return localeText.fieldWeekDayPlaceholder({
        contentType: sectionConfig.contentType
      });
    }
    case "hours": {
      return localeText.fieldHoursPlaceholder();
    }
    case "minutes": {
      return localeText.fieldMinutesPlaceholder();
    }
    case "seconds": {
      return localeText.fieldSecondsPlaceholder();
    }
    case "meridiem": {
      return localeText.fieldMeridiemPlaceholder();
    }
    default: {
      return currentTokenValue;
    }
  }
};
const changeSectionValueFormat = (utils2, valueStr, currentFormat, newFormat) => {
  return utils2.formatByString(utils2.parse(valueStr, currentFormat), newFormat);
};
const isFourDigitYearFormat = (utils2, timezone, format2) => utils2.formatByString(utils2.dateWithTimezone(void 0, timezone), format2).length === 4;
const doesSectionFormatHaveLeadingZeros = (utils2, timezone, contentType, sectionType, format2) => {
  if (contentType !== "digit") {
    return false;
  }
  const now2 = utils2.dateWithTimezone(void 0, timezone);
  switch (sectionType) {
    case "year": {
      if (isFourDigitYearFormat(utils2, timezone, format2)) {
        const formatted0001 = utils2.formatByString(utils2.setYear(now2, 1), format2);
        return formatted0001 === "0001";
      }
      const formatted2001 = utils2.formatByString(utils2.setYear(now2, 2001), format2);
      return formatted2001 === "01";
    }
    case "month": {
      return utils2.formatByString(utils2.startOfYear(now2), format2).length > 1;
    }
    case "day": {
      return utils2.formatByString(utils2.startOfMonth(now2), format2).length > 1;
    }
    case "weekDay": {
      return utils2.formatByString(utils2.startOfWeek(now2), format2).length > 1;
    }
    case "hours": {
      return utils2.formatByString(utils2.setHours(now2, 1), format2).length > 1;
    }
    case "minutes": {
      return utils2.formatByString(utils2.setMinutes(now2, 1), format2).length > 1;
    }
    case "seconds": {
      return utils2.formatByString(utils2.setMinutes(now2, 1), format2).length > 1;
    }
    default: {
      throw new Error("Invalid section type");
    }
  }
};
const getEscapedPartsFromFormat = (utils2, format2) => {
  const escapedParts = [];
  const {
    start: startChar,
    end: endChar
  } = utils2.escapedCharacters;
  const regExp = new RegExp(`(\\${startChar}[^\\${endChar}]*\\${endChar})+`, "g");
  let match2 = null;
  while (match2 = regExp.exec(format2)) {
    escapedParts.push({
      start: match2.index,
      end: regExp.lastIndex - 1
    });
  }
  return escapedParts;
};
const splitFormatIntoSections = (utils2, timezone, localeText, format2, date2, formatDensity, shouldRespectLeadingZeros, isRTL) => {
  let startSeparator = "";
  const sections = [];
  const now2 = utils2.date();
  const commitToken = (token2) => {
    if (token2 === "") {
      return null;
    }
    const sectionConfig = getDateSectionConfigFromFormatToken(utils2, token2);
    const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone, sectionConfig.contentType, sectionConfig.type, token2);
    const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === "digit";
    const isValidDate = date2 != null && utils2.isValid(date2);
    let sectionValue = isValidDate ? utils2.formatByString(date2, token2) : "";
    let maxLength = null;
    if (hasLeadingZerosInInput) {
      if (hasLeadingZerosInFormat) {
        maxLength = sectionValue === "" ? utils2.formatByString(now2, token2).length : sectionValue.length;
      } else {
        if (sectionConfig.maxLength == null) {
          throw new Error(`MUI: The token ${token2} should have a 'maxDigitNumber' property on it's adapter`);
        }
        maxLength = sectionConfig.maxLength;
        if (isValidDate) {
          sectionValue = cleanLeadingZeros(utils2, sectionValue, maxLength);
        }
      }
    }
    sections.push(_extends$2({}, sectionConfig, {
      format: token2,
      maxLength,
      value: sectionValue,
      placeholder: getSectionPlaceholder(utils2, timezone, localeText, sectionConfig, token2),
      hasLeadingZeros: hasLeadingZerosInFormat,
      hasLeadingZerosInFormat,
      hasLeadingZerosInInput,
      startSeparator: sections.length === 0 ? startSeparator : "",
      endSeparator: "",
      modified: false
    }));
    return null;
  };
  let formatExpansionOverflow = 10;
  let prevFormat = format2;
  let nextFormat = utils2.expandFormat(format2);
  while (nextFormat !== prevFormat) {
    prevFormat = nextFormat;
    nextFormat = utils2.expandFormat(prevFormat);
    formatExpansionOverflow -= 1;
    if (formatExpansionOverflow < 0) {
      throw new Error("MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component");
    }
  }
  const expandedFormat = nextFormat;
  const escapedParts = getEscapedPartsFromFormat(utils2, expandedFormat);
  const isTokenStartRegExp = new RegExp(`^(${Object.keys(utils2.formatTokenMap).sort((a2, b2) => b2.length - a2.length).join("|")})`, "g");
  let currentTokenValue = "";
  for (let i2 = 0; i2 < expandedFormat.length; i2 += 1) {
    const escapedPartOfCurrentChar = escapedParts.find((escapeIndex) => escapeIndex.start <= i2 && escapeIndex.end >= i2);
    const char2 = expandedFormat[i2];
    const isEscapedChar = escapedPartOfCurrentChar != null;
    const potentialToken = `${currentTokenValue}${expandedFormat.slice(i2)}`;
    const regExpMatch = isTokenStartRegExp.test(potentialToken);
    if (!isEscapedChar && char2.match(/([A-Za-z]+)/) && regExpMatch) {
      currentTokenValue = potentialToken.slice(0, isTokenStartRegExp.lastIndex);
      i2 += isTokenStartRegExp.lastIndex - 1;
    } else {
      const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i2 || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i2;
      if (!isEscapeBoundary) {
        commitToken(currentTokenValue);
        currentTokenValue = "";
        if (sections.length === 0) {
          startSeparator += char2;
        } else {
          sections[sections.length - 1].endSeparator += char2;
        }
      }
    }
  }
  commitToken(currentTokenValue);
  return sections.map((section) => {
    const cleanSeparator = (separator) => {
      let cleanedSeparator = separator;
      if (isRTL && cleanedSeparator !== null && cleanedSeparator.includes(" ")) {
        cleanedSeparator = `⁩${cleanedSeparator}⁦`;
      }
      if (formatDensity === "spacious" && ["/", ".", "-"].includes(cleanedSeparator)) {
        cleanedSeparator = ` ${cleanedSeparator} `;
      }
      return cleanedSeparator;
    };
    section.startSeparator = cleanSeparator(section.startSeparator);
    section.endSeparator = cleanSeparator(section.endSeparator);
    return section;
  });
};
const getDateFromDateSections = (utils2, sections) => {
  const shouldSkipWeekDays = sections.some((section) => section.type === "day");
  const sectionFormats = [];
  const sectionValues = [];
  for (let i2 = 0; i2 < sections.length; i2 += 1) {
    const section = sections[i2];
    const shouldSkip = shouldSkipWeekDays && section.type === "weekDay";
    if (!shouldSkip) {
      sectionFormats.push(section.format);
      sectionValues.push(getSectionVisibleValue(section, "non-input"));
    }
  }
  const formatWithoutSeparator = sectionFormats.join(" ");
  const dateWithoutSeparatorStr = sectionValues.join(" ");
  return utils2.parse(dateWithoutSeparatorStr, formatWithoutSeparator);
};
const createDateStrForInputFromSections = (sections, isRTL) => {
  const formattedSections = sections.map((section) => {
    const dateValue = getSectionVisibleValue(section, isRTL ? "input-rtl" : "input-ltr");
    return `${section.startSeparator}${dateValue}${section.endSeparator}`;
  });
  const dateStr = formattedSections.join("");
  if (!isRTL) {
    return dateStr;
  }
  return `⁦${dateStr}⁩`;
};
const getSectionsBoundaries = (utils2, timezone) => {
  const today = utils2.dateWithTimezone(void 0, timezone);
  const endOfYear = utils2.endOfYear(today);
  const endOfDay = utils2.endOfDay(today);
  const {
    maxDaysInMonth,
    longestMonth
  } = getMonthsInYear(utils2, today).reduce((acc, month) => {
    const daysInMonth = utils2.getDaysInMonth(month);
    if (daysInMonth > acc.maxDaysInMonth) {
      return {
        maxDaysInMonth: daysInMonth,
        longestMonth: month
      };
    }
    return acc;
  }, {
    maxDaysInMonth: 0,
    longestMonth: null
  });
  return {
    year: ({
      format: format2
    }) => ({
      minimum: 0,
      maximum: isFourDigitYearFormat(utils2, timezone, format2) ? 9999 : 99
    }),
    month: () => ({
      minimum: 1,
      // Assumption: All years have the same amount of months
      maximum: utils2.getMonth(endOfYear) + 1
    }),
    day: ({
      currentDate
    }) => ({
      minimum: 1,
      maximum: currentDate != null && utils2.isValid(currentDate) ? utils2.getDaysInMonth(currentDate) : maxDaysInMonth,
      longestMonth
    }),
    weekDay: ({
      format: format2,
      contentType
    }) => {
      if (contentType === "digit") {
        const daysInWeek = getDaysInWeekStr(utils2, timezone, format2).map(Number);
        return {
          minimum: Math.min(...daysInWeek),
          maximum: Math.max(...daysInWeek)
        };
      }
      return {
        minimum: 1,
        maximum: 7
      };
    },
    hours: ({
      format: format2
    }) => {
      const lastHourInDay = utils2.getHours(endOfDay);
      const hasMeridiem = utils2.formatByString(utils2.endOfDay(today), format2) !== lastHourInDay.toString();
      if (hasMeridiem) {
        return {
          minimum: 1,
          maximum: Number(utils2.formatByString(utils2.startOfDay(today), format2))
        };
      }
      return {
        minimum: 0,
        maximum: lastHourInDay
      };
    },
    minutes: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of minutes
      maximum: utils2.getMinutes(endOfDay)
    }),
    seconds: () => ({
      minimum: 0,
      // Assumption: All years have the same amount of seconds
      maximum: utils2.getSeconds(endOfDay)
    }),
    meridiem: () => ({
      minimum: 0,
      maximum: 0
    })
  };
};
const transferDateSectionValue = (utils2, timezone, section, dateToTransferFrom, dateToTransferTo) => {
  switch (section.type) {
    case "year": {
      return utils2.setYear(dateToTransferTo, utils2.getYear(dateToTransferFrom));
    }
    case "month": {
      return utils2.setMonth(dateToTransferTo, utils2.getMonth(dateToTransferFrom));
    }
    case "weekDay": {
      const formattedDaysInWeek = getDaysInWeekStr(utils2, timezone, section.format);
      const dayInWeekStrOfActiveDate = utils2.formatByString(dateToTransferFrom, section.format);
      const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);
      const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);
      const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;
      return utils2.addDays(dateToTransferFrom, diff);
    }
    case "day": {
      return utils2.setDate(dateToTransferTo, utils2.getDate(dateToTransferFrom));
    }
    case "meridiem": {
      const isAM = utils2.getHours(dateToTransferFrom) < 12;
      const mergedDateHours = utils2.getHours(dateToTransferTo);
      if (isAM && mergedDateHours >= 12) {
        return utils2.addHours(dateToTransferTo, -12);
      }
      if (!isAM && mergedDateHours < 12) {
        return utils2.addHours(dateToTransferTo, 12);
      }
      return dateToTransferTo;
    }
    case "hours": {
      return utils2.setHours(dateToTransferTo, utils2.getHours(dateToTransferFrom));
    }
    case "minutes": {
      return utils2.setMinutes(dateToTransferTo, utils2.getMinutes(dateToTransferFrom));
    }
    case "seconds": {
      return utils2.setSeconds(dateToTransferTo, utils2.getSeconds(dateToTransferFrom));
    }
    default: {
      return dateToTransferTo;
    }
  }
};
const reliableSectionModificationOrder = {
  year: 1,
  month: 2,
  day: 3,
  weekDay: 4,
  hours: 5,
  minutes: 6,
  seconds: 7,
  meridiem: 8
};
const mergeDateIntoReferenceDate = (utils2, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) => (
  // cloning sections before sort to avoid mutating it
  [...sections].sort((a2, b2) => reliableSectionModificationOrder[a2.type] - reliableSectionModificationOrder[b2.type]).reduce((mergedDate, section) => {
    if (!shouldLimitToEditedSections || section.modified) {
      return transferDateSectionValue(utils2, timezone, section, dateToTransferFrom, mergedDate);
    }
    return mergedDate;
  }, referenceDate)
);
const isAndroid = () => navigator.userAgent.toLowerCase().indexOf("android") > -1;
const getSectionOrder = (sections, isRTL) => {
  const neighbors = {};
  if (!isRTL) {
    sections.forEach((_2, index2) => {
      const leftIndex = index2 === 0 ? null : index2 - 1;
      const rightIndex = index2 === sections.length - 1 ? null : index2 + 1;
      neighbors[index2] = {
        leftIndex,
        rightIndex
      };
    });
    return {
      neighbors,
      startIndex: 0,
      endIndex: sections.length - 1
    };
  }
  const rtl2ltr = {};
  const ltr2rtl = {};
  let groupedSectionsStart = 0;
  let groupedSectionsEnd = 0;
  let RTLIndex = sections.length - 1;
  while (RTLIndex >= 0) {
    groupedSectionsEnd = sections.findIndex(
      // eslint-disable-next-line @typescript-eslint/no-loop-func
      (section, index2) => {
        var _section$endSeparator;
        return index2 >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(" ")) && // Special case where the spaces were not there in the initial input
        section.endSeparator !== " / ";
      }
    );
    if (groupedSectionsEnd === -1) {
      groupedSectionsEnd = sections.length - 1;
    }
    for (let i2 = groupedSectionsEnd; i2 >= groupedSectionsStart; i2 -= 1) {
      ltr2rtl[i2] = RTLIndex;
      rtl2ltr[RTLIndex] = i2;
      RTLIndex -= 1;
    }
    groupedSectionsStart = groupedSectionsEnd + 1;
  }
  sections.forEach((_2, index2) => {
    const rtlIndex = ltr2rtl[index2];
    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];
    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];
    neighbors[index2] = {
      leftIndex,
      rightIndex
    };
  });
  return {
    neighbors,
    startIndex: rtl2ltr[0],
    endIndex: rtl2ltr[sections.length - 1]
  };
};
const _excluded$l = ["value", "referenceDate"];
const singleItemValueManager = {
  emptyValue: null,
  getTodayValue: getTodayDate,
  getInitialReferenceValue: (_ref) => {
    let {
      value,
      referenceDate
    } = _ref, params = _objectWithoutPropertiesLoose$1(_ref, _excluded$l);
    if (value != null && params.utils.isValid(value)) {
      return value;
    }
    if (referenceDate != null) {
      return referenceDate;
    }
    return getDefaultReferenceDate(params);
  },
  cleanValue: replaceInvalidDateByNull,
  areValuesEqual: areDatesEqual,
  isSameError: (a2, b2) => a2 === b2,
  hasError: (error) => error != null,
  defaultErrorState: null,
  getTimezone: (utils2, value) => value == null || !utils2.isValid(value) ? null : utils2.getTimezone(value),
  setTimezone: (utils2, timezone, value) => value == null ? null : utils2.setTimezone(value, timezone)
};
const singleItemFieldValueManager = {
  updateReferenceValue: (utils2, value, prevReferenceValue) => value == null || !utils2.isValid(value) ? prevReferenceValue : value,
  getSectionsFromValue: (utils2, date2, prevSections, isRTL, getSectionsFromDate) => {
    const shouldReUsePrevDateSections = !utils2.isValid(date2) && !!prevSections;
    if (shouldReUsePrevDateSections) {
      return prevSections;
    }
    return addPositionPropertiesToSections(getSectionsFromDate(date2), isRTL);
  },
  getValueStrFromSections: createDateStrForInputFromSections,
  getActiveDateManager: (utils2, state) => ({
    date: state.value,
    referenceDate: state.referenceValue,
    getSections: (sections) => sections,
    getNewValuesFromNewActiveDate: (newActiveDate) => ({
      value: newActiveDate,
      referenceValue: newActiveDate == null || !utils2.isValid(newActiveDate) ? state.referenceValue : newActiveDate
    })
  }),
  parseValueStr: (valueStr, referenceValue, parseDate) => parseDate(valueStr.trim(), referenceValue)
};
const getPickersLocalization = (pickersTranslations) => {
  return {
    components: {
      MuiLocalizationProvider: {
        defaultProps: {
          localeText: _extends$2({}, pickersTranslations)
        }
      }
    }
  };
};
const enUSPickers = {
  // Calendar navigation
  previousMonth: "Previous month",
  nextMonth: "Next month",
  // View navigation
  openPreviousView: "open previous view",
  openNextView: "open next view",
  calendarViewSwitchingButtonAriaLabel: (view) => view === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view",
  // DateRange placeholders
  start: "Start",
  end: "End",
  // Action bar
  cancelButtonLabel: "Cancel",
  clearButtonLabel: "Clear",
  okButtonLabel: "OK",
  todayButtonLabel: "Today",
  // Toolbar titles
  datePickerToolbarTitle: "Select date",
  dateTimePickerToolbarTitle: "Select date & time",
  timePickerToolbarTitle: "Select time",
  dateRangePickerToolbarTitle: "Select date range",
  // Clock labels
  clockLabelText: (view, time2, adapter) => `Select ${view}. ${time2 === null ? "No time selected" : `Selected time is ${adapter.format(time2, "fullTime")}`}`,
  hoursClockNumberText: (hours) => `${hours} hours`,
  minutesClockNumberText: (minutes) => `${minutes} minutes`,
  secondsClockNumberText: (seconds) => `${seconds} seconds`,
  // Digital clock labels
  selectViewText: (view) => `Select ${view}`,
  // Calendar labels
  calendarWeekNumberHeaderLabel: "Week number",
  calendarWeekNumberHeaderText: "#",
  calendarWeekNumberAriaLabelText: (weekNumber) => `Week ${weekNumber}`,
  calendarWeekNumberText: (weekNumber) => `${weekNumber}`,
  // Open picker labels
  openDatePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose date, selected date is ${utils2.format(value, "fullDate")}` : "Choose date",
  openTimePickerDialogue: (value, utils2) => value !== null && utils2.isValid(value) ? `Choose time, selected time is ${utils2.format(value, "fullTime")}` : "Choose time",
  fieldClearLabel: "Clear value",
  // Table labels
  timeTableLabel: "pick time",
  dateTableLabel: "pick date",
  // Field section placeholders
  fieldYearPlaceholder: (params) => "Y".repeat(params.digitAmount),
  fieldMonthPlaceholder: (params) => params.contentType === "letter" ? "MMMM" : "MM",
  fieldDayPlaceholder: () => "DD",
  fieldWeekDayPlaceholder: (params) => params.contentType === "letter" ? "EEEE" : "EE",
  fieldHoursPlaceholder: () => "hh",
  fieldMinutesPlaceholder: () => "mm",
  fieldSecondsPlaceholder: () => "ss",
  fieldMeridiemPlaceholder: () => "aa"
};
const DEFAULT_LOCALE = enUSPickers;
getPickersLocalization(enUSPickers);
const useLocalizationContext = () => {
  const localization = reactExports.useContext(MuiPickersAdapterContext);
  if (localization === null) {
    throw new Error(["MUI: Can not find the date and time pickers localization context.", "It looks like you forgot to wrap your component in LocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join("\n"));
  }
  if (localization.utils === null) {
    throw new Error(["MUI: Can not find the date and time pickers adapter from its localization context.", "It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join("\n"));
  }
  const localeText = reactExports.useMemo(() => _extends$2({}, DEFAULT_LOCALE, localization.localeText), [localization.localeText]);
  return reactExports.useMemo(() => _extends$2({}, localization, {
    localeText
  }), [localization, localeText]);
};
const useUtils = () => useLocalizationContext().utils;
const useDefaultDates = () => useLocalizationContext().defaultDates;
const useLocaleText = () => useLocalizationContext().localeText;
const useNow = (timezone) => {
  const utils2 = useUtils();
  const now2 = reactExports.useRef();
  if (now2.current === void 0) {
    now2.current = utils2.dateWithTimezone(void 0, timezone);
  }
  return now2.current;
};
function getPickersToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiPickersToolbar", slot);
}
generateUtilityClasses("MuiPickersToolbar", ["root", "content"]);
const useUtilityClasses$f = (ownerState) => {
  const {
    classes,
    isLandscape
  } = ownerState;
  const slots = {
    root: ["root"],
    content: ["content"],
    penIconButton: ["penIconButton", isLandscape && "penIconButtonLandscape"]
  };
  return composeClasses(slots, getPickersToolbarUtilityClass, classes);
};
const PickersToolbarRoot = styled$1("div", {
  name: "MuiPickersToolbar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2,
  ownerState
}) => _extends$2({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start",
  justifyContent: "space-between",
  padding: theme2.spacing(2, 3)
}, ownerState.isLandscape && {
  height: "auto",
  maxWidth: 160,
  padding: 16,
  justifyContent: "flex-start",
  flexWrap: "wrap"
}));
const PickersToolbarContent = styled$1("div", {
  name: "MuiPickersToolbar",
  slot: "Content",
  overridesResolver: (props, styles2) => styles2.content
})(({
  ownerState
}) => {
  var _ownerState$landscape;
  return {
    display: "flex",
    flexWrap: "wrap",
    width: "100%",
    justifyContent: ownerState.isLandscape ? "flex-start" : "space-between",
    flexDirection: ownerState.isLandscape ? (_ownerState$landscape = ownerState.landscapeDirection) != null ? _ownerState$landscape : "column" : "row",
    flex: 1,
    alignItems: ownerState.isLandscape ? "flex-start" : "center"
  };
});
const PickersToolbar = /* @__PURE__ */ reactExports.forwardRef(function PickersToolbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersToolbar"
  });
  const {
    children,
    className,
    toolbarTitle,
    hidden,
    titleId
  } = props;
  const ownerState = props;
  const classes = useUtilityClasses$f(ownerState);
  if (hidden) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersToolbarRoot, {
    ref,
    className: clsx(classes.root, className),
    ownerState,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
      color: "text.secondary",
      variant: "overline",
      id: titleId,
      children: toolbarTitle
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersToolbarContent, {
      className: classes.content,
      ownerState,
      children
    })]
  });
});
function getDatePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiDatePickerToolbar", slot);
}
generateUtilityClasses("MuiDatePickerToolbar", ["root", "title"]);
const _excluded$k = ["value", "isLandscape", "onChange", "toolbarFormat", "toolbarPlaceholder", "views"];
const useUtilityClasses$e = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    title: ["title"]
  };
  return composeClasses(slots, getDatePickerToolbarUtilityClass, classes);
};
const DatePickerToolbarRoot = styled$1(PickersToolbar, {
  name: "MuiDatePickerToolbar",
  slot: "Root",
  overridesResolver: (_2, styles2) => styles2.root
})({});
const DatePickerToolbarTitle = styled$1(Typography$1, {
  name: "MuiDatePickerToolbar",
  slot: "Title",
  overridesResolver: (_2, styles2) => styles2.title
})(({
  ownerState
}) => _extends$2({}, ownerState.isLandscape && {
  margin: "auto 16px auto auto"
}));
const DatePickerToolbar = /* @__PURE__ */ reactExports.forwardRef(function DatePickerToolbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDatePickerToolbar"
  });
  const {
    value,
    isLandscape,
    toolbarFormat,
    toolbarPlaceholder = "––",
    views
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$k);
  const utils2 = useUtils();
  const localeText = useLocaleText();
  const classes = useUtilityClasses$e(props);
  const dateText = reactExports.useMemo(() => {
    if (!value) {
      return toolbarPlaceholder;
    }
    const formatFromViews = resolveDateFormat(utils2, {
      format: toolbarFormat,
      views
    }, true);
    return utils2.formatByString(value, formatFromViews);
  }, [value, toolbarFormat, toolbarPlaceholder, utils2, views]);
  const ownerState = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DatePickerToolbarRoot, _extends$2({
    ref,
    toolbarTitle: localeText.datePickerToolbarTitle,
    isLandscape,
    className: classes.root
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DatePickerToolbarTitle, {
      variant: "h4",
      align: isLandscape ? "left" : "center",
      ownerState,
      className: classes.title,
      children: dateText
    })
  }));
});
const uncapitalizeObjectKeys = (capitalizedObject) => {
  if (capitalizedObject === void 0) {
    return void 0;
  }
  return Object.keys(capitalizedObject).reduce((acc, key) => _extends$2({}, acc, {
    [`${key.slice(0, 1).toLowerCase()}${key.slice(1)}`]: capitalizedObject[key]
  }), {});
};
function useDatePickerDefaultizedProps(props, name) {
  var _themeProps$slots, _themeProps$disableFu, _themeProps$disablePa, _themeProps$slotProps;
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  const localeText = reactExports.useMemo(() => {
    var _themeProps$localeTex;
    if (((_themeProps$localeTex = themeProps.localeText) == null ? void 0 : _themeProps$localeTex.toolbarTitle) == null) {
      return themeProps.localeText;
    }
    return _extends$2({}, themeProps.localeText, {
      datePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  const slots = (_themeProps$slots = themeProps.slots) != null ? _themeProps$slots : uncapitalizeObjectKeys(themeProps.components);
  return _extends$2({}, themeProps, {
    localeText
  }, applyDefaultViewProps({
    views: themeProps.views,
    openTo: themeProps.openTo,
    defaultViews: ["year", "day"],
    defaultOpenTo: "day"
  }), {
    disableFuture: (_themeProps$disableFu = themeProps.disableFuture) != null ? _themeProps$disableFu : false,
    disablePast: (_themeProps$disablePa = themeProps.disablePast) != null ? _themeProps$disablePa : false,
    minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate),
    slots: _extends$2({
      toolbar: DatePickerToolbar
    }, slots),
    slotProps: (_themeProps$slotProps = themeProps.slotProps) != null ? _themeProps$slotProps : themeProps.componentsProps
  });
}
const ArrowDropDownIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
const ArrowLeftIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
}), "ArrowLeft");
const ArrowRightIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), "ArrowRight");
const CalendarIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
}), "Calendar");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Clock");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
}), "DateRange");
createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Time");
const ClearIcon = createSvgIcon$1(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Clear");
function getPickersArrowSwitcherUtilityClass(slot) {
  return generateUtilityClass("MuiPickersArrowSwitcher", slot);
}
generateUtilityClasses("MuiPickersArrowSwitcher", ["root", "spacer", "button"]);
const _excluded$j = ["children", "className", "slots", "slotProps", "isNextDisabled", "isNextHidden", "onGoToNext", "nextLabel", "isPreviousDisabled", "isPreviousHidden", "onGoToPrevious", "previousLabel"], _excluded2$5 = ["ownerState"], _excluded3$2 = ["ownerState"];
const PickersArrowSwitcherRoot = styled$1("div", {
  name: "MuiPickersArrowSwitcher",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "flex"
});
const PickersArrowSwitcherSpacer = styled$1("div", {
  name: "MuiPickersArrowSwitcher",
  slot: "Spacer",
  overridesResolver: (props, styles2) => styles2.spacer
})(({
  theme: theme2
}) => ({
  width: theme2.spacing(3)
}));
const PickersArrowSwitcherButton = styled$1(IconButton$1, {
  name: "MuiPickersArrowSwitcher",
  slot: "Button",
  overridesResolver: (props, styles2) => styles2.button
})(({
  ownerState
}) => _extends$2({}, ownerState.hidden && {
  visibility: "hidden"
}));
const useUtilityClasses$d = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    spacer: ["spacer"],
    button: ["button"]
  };
  return composeClasses(slots, getPickersArrowSwitcherUtilityClass, classes);
};
const PickersArrowSwitcher = /* @__PURE__ */ reactExports.forwardRef(function PickersArrowSwitcher2(inProps, ref) {
  var _slots$previousIconBu, _slots$nextIconButton, _slots$leftArrowIcon, _slots$rightArrowIcon;
  const theme2 = useTheme();
  const isRTL = theme2.direction === "rtl";
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersArrowSwitcher"
  });
  const {
    children,
    className,
    slots,
    slotProps,
    isNextDisabled,
    isNextHidden,
    onGoToNext,
    nextLabel,
    isPreviousDisabled,
    isPreviousHidden,
    onGoToPrevious,
    previousLabel
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$j);
  const ownerState = props;
  const classes = useUtilityClasses$d(ownerState);
  const nextProps = {
    isDisabled: isNextDisabled,
    isHidden: isNextHidden,
    goTo: onGoToNext,
    label: nextLabel
  };
  const previousProps = {
    isDisabled: isPreviousDisabled,
    isHidden: isPreviousHidden,
    goTo: onGoToPrevious,
    label: previousLabel
  };
  const PreviousIconButton = (_slots$previousIconBu = slots == null ? void 0 : slots.previousIconButton) != null ? _slots$previousIconBu : PickersArrowSwitcherButton;
  const previousIconButtonProps = useSlotProps({
    elementType: PreviousIconButton,
    externalSlotProps: slotProps == null ? void 0 : slotProps.previousIconButton,
    additionalProps: {
      size: "medium",
      title: previousProps.label,
      "aria-label": previousProps.label,
      disabled: previousProps.isDisabled,
      edge: "end",
      onClick: previousProps.goTo
    },
    ownerState: _extends$2({}, ownerState, {
      hidden: previousProps.isHidden
    }),
    className: classes.button
  });
  const NextIconButton = (_slots$nextIconButton = slots == null ? void 0 : slots.nextIconButton) != null ? _slots$nextIconButton : PickersArrowSwitcherButton;
  const nextIconButtonProps = useSlotProps({
    elementType: NextIconButton,
    externalSlotProps: slotProps == null ? void 0 : slotProps.nextIconButton,
    additionalProps: {
      size: "medium",
      title: nextProps.label,
      "aria-label": nextProps.label,
      disabled: nextProps.isDisabled,
      edge: "start",
      onClick: nextProps.goTo
    },
    ownerState: _extends$2({}, ownerState, {
      hidden: nextProps.isHidden
    }),
    className: classes.button
  });
  const LeftArrowIcon = (_slots$leftArrowIcon = slots == null ? void 0 : slots.leftArrowIcon) != null ? _slots$leftArrowIcon : ArrowLeftIcon;
  const _useSlotProps = useSlotProps({
    elementType: LeftArrowIcon,
    externalSlotProps: slotProps == null ? void 0 : slotProps.leftArrowIcon,
    additionalProps: {
      fontSize: "inherit"
    },
    ownerState: void 0
  }), leftArrowIconProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2$5);
  const RightArrowIcon = (_slots$rightArrowIcon = slots == null ? void 0 : slots.rightArrowIcon) != null ? _slots$rightArrowIcon : ArrowRightIcon;
  const _useSlotProps2 = useSlotProps({
    elementType: RightArrowIcon,
    externalSlotProps: slotProps == null ? void 0 : slotProps.rightArrowIcon,
    additionalProps: {
      fontSize: "inherit"
    },
    ownerState: void 0
  }), rightArrowIconProps = _objectWithoutPropertiesLoose$1(_useSlotProps2, _excluded3$2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersArrowSwitcherRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PreviousIconButton, _extends$2({}, previousIconButtonProps, {
      children: isRTL ? /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$2({}, rightArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$2({}, leftArrowIconProps))
    })), children ? /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, {
      variant: "subtitle1",
      component: "span",
      children
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcherSpacer, {
      className: classes.spacer,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(NextIconButton, _extends$2({}, nextIconButtonProps, {
      children: isRTL ? /* @__PURE__ */ jsxRuntimeExports.jsx(LeftArrowIcon, _extends$2({}, leftArrowIconProps)) : /* @__PURE__ */ jsxRuntimeExports.jsx(RightArrowIcon, _extends$2({}, rightArrowIconProps))
    }))]
  }));
});
const DAY_SIZE = 36;
const DAY_MARGIN = 2;
const DIALOG_WIDTH = 320;
const VIEW_HEIGHT = 358;
const PickersModalDialogRoot = styled$1(MuiDialog)({
  [`& .${dialogClasses$1.container}`]: {
    outline: 0
  },
  [`& .${dialogClasses$1.paper}`]: {
    outline: 0,
    minWidth: DIALOG_WIDTH
  }
});
const PickersModalDialogContent = styled$1(DialogContent$1)({
  "&:first-of-type": {
    padding: 0
  }
});
function PickersModalDialog(props) {
  var _slots$dialog, _slots$mobileTransiti;
  const {
    children,
    onDismiss,
    open: open2,
    slots,
    slotProps
  } = props;
  const Dialog3 = (_slots$dialog = slots == null ? void 0 : slots.dialog) != null ? _slots$dialog : PickersModalDialogRoot;
  const Transition3 = (_slots$mobileTransiti = slots == null ? void 0 : slots.mobileTransition) != null ? _slots$mobileTransiti : Fade$1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog3, _extends$2({
    open: open2,
    onClose: onDismiss
  }, slotProps == null ? void 0 : slotProps.dialog, {
    TransitionComponent: Transition3,
    TransitionProps: slotProps == null ? void 0 : slotProps.mobileTransition,
    PaperComponent: slots == null ? void 0 : slots.mobilePaper,
    PaperProps: slotProps == null ? void 0 : slotProps.mobilePaper,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersModalDialogContent, {
      children
    })
  }));
}
function getPickersPopperUtilityClass(slot) {
  return generateUtilityClass("MuiPickersPopper", slot);
}
generateUtilityClasses("MuiPickersPopper", ["root", "paper"]);
function arrayIncludes(array2, itemOrItems) {
  if (Array.isArray(itemOrItems)) {
    return itemOrItems.every((item) => array2.indexOf(item) !== -1);
  }
  return array2.indexOf(itemOrItems) !== -1;
}
const onSpaceOrEnter = (innerFn, externalEvent) => (event) => {
  if (event.key === "Enter" || event.key === " ") {
    innerFn(event);
    event.preventDefault();
    event.stopPropagation();
  }
  if (externalEvent) {
    externalEvent(event);
  }
};
const getActiveElement = (root2 = document) => {
  const activeEl = root2.activeElement;
  if (!activeEl) {
    return null;
  }
  if (activeEl.shadowRoot) {
    return getActiveElement(activeEl.shadowRoot);
  }
  return activeEl;
};
const DEFAULT_DESKTOP_MODE_MEDIA_QUERY = "@media (pointer: fine)";
const PREFERS_REDUCED_MOTION = "@media (prefers-reduced-motion: reduce)";
const mobileVersionMatches = typeof navigator !== "undefined" && navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i);
const androidVersion = mobileVersionMatches && mobileVersionMatches[1] ? parseInt(mobileVersionMatches[1], 10) : null;
const iOSVersion = mobileVersionMatches && mobileVersionMatches[2] ? parseInt(mobileVersionMatches[2], 10) : null;
const slowAnimationDevices = androidVersion && androidVersion < 10 || iOSVersion && iOSVersion < 13 || false;
const useDefaultReduceAnimations = () => {
  const prefersReduced = useMediaQuery(PREFERS_REDUCED_MOTION, {
    defaultMatches: false
  });
  return prefersReduced || slowAnimationDevices;
};
const _excluded$i = ["PaperComponent", "popperPlacement", "ownerState", "children", "paperSlotProps", "paperClasses", "onPaperClick", "onPaperTouchStart"];
const useUtilityClasses$c = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPickersPopperUtilityClass, classes);
};
const PickersPopperRoot = styled$1(MuiPopper, {
  name: "MuiPickersPopper",
  slot: "Root",
  overridesResolver: (_2, styles2) => styles2.root
})(({
  theme: theme2
}) => ({
  zIndex: theme2.zIndex.modal
}));
const PickersPopperPaper = styled$1(MuiPaper, {
  name: "MuiPickersPopper",
  slot: "Paper",
  overridesResolver: (_2, styles2) => styles2.paper
})(({
  ownerState
}) => _extends$2({
  outline: 0,
  transformOrigin: "top center"
}, ownerState.placement.includes("top") && {
  transformOrigin: "bottom center"
}));
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function useClickAwayListener(active, onClickAway) {
  const movedRef = reactExports.useRef(false);
  const syntheticEventRef = reactExports.useRef(false);
  const nodeRef = reactExports.useRef(null);
  const activatedRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    if (!active) {
      return void 0;
    }
    function armClickAwayListener() {
      activatedRef.current = true;
    }
    document.addEventListener("mousedown", armClickAwayListener, true);
    document.addEventListener("touchstart", armClickAwayListener, true);
    return () => {
      document.removeEventListener("mousedown", armClickAwayListener, true);
      document.removeEventListener("touchstart", armClickAwayListener, true);
      activatedRef.current = false;
    };
  }, [active]);
  const handleClickAway = useEventCallback$1((event) => {
    if (!activatedRef.current) {
      return;
    }
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!nodeRef.current || // is a TouchEvent?
    "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      insideDOM = !doc.documentElement.contains(event.target) || nodeRef.current.contains(event.target);
    }
    if (!insideDOM && !insideReactTree) {
      onClickAway(event);
    }
  });
  const handleSynthetic = () => {
    syntheticEventRef.current = true;
  };
  reactExports.useEffect(() => {
    if (active) {
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener("touchstart", handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener("touchstart", handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [active, handleClickAway]);
  reactExports.useEffect(() => {
    if (active) {
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener("click", handleClickAway);
      return () => {
        doc.removeEventListener("click", handleClickAway);
        syntheticEventRef.current = false;
      };
    }
    return void 0;
  }, [active, handleClickAway]);
  return [nodeRef, handleSynthetic, handleSynthetic];
}
const PickersPopperPaperWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
  const {
    PaperComponent,
    popperPlacement,
    ownerState: inOwnerState,
    children,
    paperSlotProps,
    paperClasses,
    onPaperClick,
    onPaperTouchStart
    // picks up the style props provided by `Transition`
    // https://mui.com/material-ui/transitions/#child-requirement
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$i);
  const ownerState = _extends$2({}, inOwnerState, {
    placement: popperPlacement
  });
  const paperProps = useSlotProps({
    elementType: PaperComponent,
    externalSlotProps: paperSlotProps,
    additionalProps: {
      tabIndex: -1,
      elevation: 8,
      ref
    },
    className: paperClasses,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperComponent, _extends$2({}, other, paperProps, {
    onClick: (event) => {
      var _paperProps$onClick;
      onPaperClick(event);
      (_paperProps$onClick = paperProps.onClick) == null || _paperProps$onClick.call(paperProps, event);
    },
    onTouchStart: (event) => {
      var _paperProps$onTouchSt;
      onPaperTouchStart(event);
      (_paperProps$onTouchSt = paperProps.onTouchStart) == null || _paperProps$onTouchSt.call(paperProps, event);
    },
    ownerState,
    children
  }));
});
function PickersPopper(inProps) {
  var _slots$desktopTransit, _slots$desktopTrapFoc, _slots$desktopPaper, _slots$popper;
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersPopper"
  });
  const {
    anchorEl,
    children,
    containerRef = null,
    shouldRestoreFocus,
    onBlur,
    onDismiss,
    open: open2,
    role,
    placement,
    slots,
    slotProps,
    reduceAnimations: inReduceAnimations
  } = props;
  reactExports.useEffect(() => {
    function handleKeyDown3(nativeEvent) {
      if (open2 && (nativeEvent.key === "Escape" || nativeEvent.key === "Esc")) {
        onDismiss();
      }
    }
    document.addEventListener("keydown", handleKeyDown3);
    return () => {
      document.removeEventListener("keydown", handleKeyDown3);
    };
  }, [onDismiss, open2]);
  const lastFocusedElementRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (role === "tooltip" || shouldRestoreFocus && !shouldRestoreFocus()) {
      return;
    }
    if (open2) {
      lastFocusedElementRef.current = getActiveElement(document);
    } else if (lastFocusedElementRef.current && lastFocusedElementRef.current instanceof HTMLElement) {
      setTimeout(() => {
        if (lastFocusedElementRef.current instanceof HTMLElement) {
          lastFocusedElementRef.current.focus();
        }
      });
    }
  }, [open2, role, shouldRestoreFocus]);
  const [clickAwayRef, onPaperClick, onPaperTouchStart] = useClickAwayListener(open2, onBlur != null ? onBlur : onDismiss);
  const paperRef = reactExports.useRef(null);
  const handleRef = useForkRef(paperRef, containerRef);
  const handlePaperRef = useForkRef(handleRef, clickAwayRef);
  const ownerState = props;
  const classes = useUtilityClasses$c(ownerState);
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const reduceAnimations = inReduceAnimations != null ? inReduceAnimations : defaultReduceAnimations;
  const handleKeyDown2 = (event) => {
    if (event.key === "Escape") {
      event.stopPropagation();
      onDismiss();
    }
  };
  const Transition3 = ((_slots$desktopTransit = slots == null ? void 0 : slots.desktopTransition) != null ? _slots$desktopTransit : reduceAnimations) ? Fade$1 : Grow$1;
  const FocusTrap$1 = (_slots$desktopTrapFoc = slots == null ? void 0 : slots.desktopTrapFocus) != null ? _slots$desktopTrapFoc : FocusTrap;
  const Paper3 = (_slots$desktopPaper = slots == null ? void 0 : slots.desktopPaper) != null ? _slots$desktopPaper : PickersPopperPaper;
  const Popper4 = (_slots$popper = slots == null ? void 0 : slots.popper) != null ? _slots$popper : PickersPopperRoot;
  const popperProps = useSlotProps({
    elementType: Popper4,
    externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
    additionalProps: {
      transition: true,
      role,
      open: open2,
      anchorEl,
      placement,
      onKeyDown: handleKeyDown2
    },
    className: classes.root,
    ownerState: props
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Popper4, _extends$2({}, popperProps, {
    children: ({
      TransitionProps,
      placement: popperPlacement
    }) => /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap$1, _extends$2({
      open: open2,
      disableAutoFocus: true,
      disableRestoreFocus: true,
      disableEnforceFocus: role === "tooltip",
      isEnabled: () => true
    }, slotProps == null ? void 0 : slotProps.desktopTrapFocus, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Transition3, _extends$2({}, TransitionProps, slotProps == null ? void 0 : slotProps.desktopTransition, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersPopperPaperWrapper, {
          PaperComponent: Paper3,
          ownerState,
          popperPlacement,
          ref: handlePaperRef,
          onPaperClick,
          onPaperTouchStart,
          paperClasses: classes.paper,
          paperSlotProps: slotProps == null ? void 0 : slotProps.desktopPaper,
          children
        })
      }))
    }))
  }));
}
const useValueWithTimezone = ({
  timezone: timezoneProp,
  value: valueProp,
  defaultValue,
  onChange,
  valueManager
}) => {
  var _ref, _ref2;
  const utils2 = useUtils();
  const firstDefaultValue = reactExports.useRef(defaultValue);
  const inputValue = (_ref = valueProp != null ? valueProp : firstDefaultValue.current) != null ? _ref : valueManager.emptyValue;
  const inputTimezone = reactExports.useMemo(() => valueManager.getTimezone(utils2, inputValue), [utils2, valueManager, inputValue]);
  const setInputTimezone = useEventCallback$1((newValue) => {
    if (inputTimezone == null) {
      return newValue;
    }
    return valueManager.setTimezone(utils2, inputTimezone, newValue);
  });
  const timezoneToRender = (_ref2 = timezoneProp != null ? timezoneProp : inputTimezone) != null ? _ref2 : "default";
  const valueWithTimezoneToRender = reactExports.useMemo(() => valueManager.setTimezone(utils2, timezoneToRender, inputValue), [valueManager, utils2, timezoneToRender, inputValue]);
  const handleValueChange = useEventCallback$1((newValue, ...otherParams) => {
    const newValueWithInputTimezone = setInputTimezone(newValue);
    onChange == null || onChange(newValueWithInputTimezone, ...otherParams);
  });
  return {
    value: valueWithTimezoneToRender,
    handleValueChange,
    timezone: timezoneToRender
  };
};
const useControlledValueWithTimezone = ({
  name,
  timezone: timezoneProp,
  value: valueProp,
  defaultValue,
  onChange: onChangeProp,
  valueManager
}) => {
  const [valueWithInputTimezone, setValue2] = useControlled({
    name,
    state: "value",
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : valueManager.emptyValue
  });
  const onChange = useEventCallback$1((newValue, ...otherParams) => {
    setValue2(newValue);
    onChangeProp == null || onChangeProp(newValue, ...otherParams);
  });
  return useValueWithTimezone({
    timezone: timezoneProp,
    value: valueWithInputTimezone,
    defaultValue: void 0,
    onChange,
    valueManager
  });
};
function useValidation(props, validate, isSameError, defaultErrorState) {
  const {
    value,
    onError
  } = props;
  const adapter = useLocalizationContext();
  const previousValidationErrorRef = reactExports.useRef(defaultErrorState);
  const validationError = validate({
    adapter,
    value,
    props
  });
  reactExports.useEffect(() => {
    if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
      onError(validationError, value);
    }
    previousValidationErrorRef.current = validationError;
  }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
  return validationError;
}
const useFieldState = (params) => {
  const utils2 = useUtils();
  const localeText = useLocaleText();
  const adapter = useLocalizationContext();
  const theme2 = useTheme();
  const isRTL = theme2.direction === "rtl";
  const {
    valueManager,
    fieldValueManager,
    valueType,
    validator: validator2,
    internalProps,
    internalProps: {
      value: valueProp,
      defaultValue,
      referenceDate: referenceDateProp,
      onChange,
      format: format2,
      formatDensity = "dense",
      selectedSections: selectedSectionsProp,
      onSelectedSectionsChange,
      shouldRespectLeadingZeros = false,
      timezone: timezoneProp
    }
  } = params;
  const {
    timezone,
    value: valueFromTheOutside,
    handleValueChange
  } = useValueWithTimezone({
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager
  });
  const sectionsValueBoundaries = reactExports.useMemo(() => getSectionsBoundaries(utils2, timezone), [utils2, timezone]);
  const getSectionsFromValue = reactExports.useCallback((value, fallbackSections = null) => fieldValueManager.getSectionsFromValue(utils2, value, fallbackSections, isRTL, (date2) => splitFormatIntoSections(utils2, timezone, localeText, format2, date2, formatDensity, shouldRespectLeadingZeros, isRTL)), [fieldValueManager, format2, localeText, isRTL, shouldRespectLeadingZeros, utils2, formatDensity, timezone]);
  const placeholder = reactExports.useMemo(() => fieldValueManager.getValueStrFromSections(getSectionsFromValue(valueManager.emptyValue), isRTL), [fieldValueManager, getSectionsFromValue, valueManager.emptyValue, isRTL]);
  const [state, setState] = reactExports.useState(() => {
    const sections = getSectionsFromValue(valueFromTheOutside);
    const stateWithoutReferenceDate = {
      sections,
      value: valueFromTheOutside,
      referenceValue: valueManager.emptyValue,
      tempValueStrAndroid: null
    };
    const granularity = getSectionTypeGranularity(sections);
    const referenceValue = valueManager.getInitialReferenceValue({
      referenceDate: referenceDateProp,
      value: valueFromTheOutside,
      utils: utils2,
      props: internalProps,
      granularity,
      timezone
    });
    return _extends$2({}, stateWithoutReferenceDate, {
      referenceValue
    });
  });
  const [selectedSections, innerSetSelectedSections] = useControlled({
    controlled: selectedSectionsProp,
    default: null,
    name: "useField",
    state: "selectedSectionIndexes"
  });
  const setSelectedSections = (newSelectedSections) => {
    innerSetSelectedSections(newSelectedSections);
    onSelectedSectionsChange == null || onSelectedSectionsChange(newSelectedSections);
    setState((prevState) => _extends$2({}, prevState, {
      selectedSectionQuery: null
    }));
  };
  const selectedSectionIndexes = reactExports.useMemo(() => {
    if (selectedSections == null) {
      return null;
    }
    if (selectedSections === "all") {
      return {
        startIndex: 0,
        endIndex: state.sections.length - 1,
        shouldSelectBoundarySelectors: true
      };
    }
    if (typeof selectedSections === "number") {
      return {
        startIndex: selectedSections,
        endIndex: selectedSections
      };
    }
    if (typeof selectedSections === "string") {
      const selectedSectionIndex = state.sections.findIndex((section) => section.type === selectedSections);
      return {
        startIndex: selectedSectionIndex,
        endIndex: selectedSectionIndex
      };
    }
    return selectedSections;
  }, [selectedSections, state.sections]);
  const publishValue = ({
    value,
    referenceValue,
    sections
  }) => {
    setState((prevState) => _extends$2({}, prevState, {
      sections,
      value,
      referenceValue,
      tempValueStrAndroid: null
    }));
    const context = {
      validationError: validator2({
        adapter,
        value,
        props: _extends$2({}, internalProps, {
          value,
          timezone
        })
      })
    };
    handleValueChange(value, context);
  };
  const setSectionValue = (sectionIndex, newSectionValue) => {
    const newSections = [...state.sections];
    newSections[sectionIndex] = _extends$2({}, newSections[sectionIndex], {
      value: newSectionValue,
      modified: true
    });
    return addPositionPropertiesToSections(newSections, isRTL);
  };
  const clearValue = () => {
    if (valueManager.areValuesEqual(utils2, state.value, valueManager.emptyValue)) {
      return;
    }
    publishValue({
      value: valueManager.emptyValue,
      referenceValue: state.referenceValue,
      sections: getSectionsFromValue(valueManager.emptyValue)
    });
  };
  const clearActiveSection = () => {
    if (selectedSectionIndexes == null) {
      return;
    }
    const activeSection = state.sections[selectedSectionIndexes.startIndex];
    if (activeSection.value === "") {
      return;
    }
    const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
    const nonEmptySectionCountBefore = activeDateManager.getSections(state.sections).filter((section) => section.value !== "").length;
    const isTheOnlyNonEmptySection = nonEmptySectionCountBefore === 1;
    const newSections = setSectionValue(selectedSectionIndexes.startIndex, "");
    const newActiveDate = isTheOnlyNonEmptySection ? null : utils2.date(/* @__PURE__ */ new Date(""));
    const newValues = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
    if ((newActiveDate != null && !utils2.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils2.isValid(activeDateManager.date))) {
      publishValue(_extends$2({}, newValues, {
        sections: newSections
      }));
    } else {
      setState((prevState) => _extends$2({}, prevState, newValues, {
        sections: newSections,
        tempValueStrAndroid: null
      }));
    }
  };
  const updateValueFromValueStr = (valueStr) => {
    const parseDateStr = (dateStr, referenceDate) => {
      const date2 = utils2.parse(dateStr, format2);
      if (date2 == null || !utils2.isValid(date2)) {
        return null;
      }
      const sections = splitFormatIntoSections(utils2, timezone, localeText, format2, date2, formatDensity, shouldRespectLeadingZeros, isRTL);
      return mergeDateIntoReferenceDate(utils2, timezone, date2, sections, referenceDate, false);
    };
    const newValue = fieldValueManager.parseValueStr(valueStr, state.referenceValue, parseDateStr);
    const newReferenceValue = fieldValueManager.updateReferenceValue(utils2, newValue, state.referenceValue);
    publishValue({
      value: newValue,
      referenceValue: newReferenceValue,
      sections: getSectionsFromValue(newValue, state.sections)
    });
  };
  const updateSectionValue = ({
    activeSection,
    newSectionValue,
    shouldGoToNextSection
  }) => {
    if (shouldGoToNextSection && selectedSectionIndexes && selectedSectionIndexes.startIndex < state.sections.length - 1) {
      setSelectedSections(selectedSectionIndexes.startIndex + 1);
    } else if (selectedSectionIndexes && selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
      setSelectedSections(selectedSectionIndexes.startIndex);
    }
    const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
    const newSections = setSectionValue(selectedSectionIndexes.startIndex, newSectionValue);
    const newActiveDateSections = activeDateManager.getSections(newSections);
    const newActiveDate = getDateFromDateSections(utils2, newActiveDateSections);
    let values2;
    let shouldPublish;
    if (newActiveDate != null && utils2.isValid(newActiveDate)) {
      const mergedDate = mergeDateIntoReferenceDate(utils2, timezone, newActiveDate, newActiveDateSections, activeDateManager.referenceDate, true);
      values2 = activeDateManager.getNewValuesFromNewActiveDate(mergedDate);
      shouldPublish = true;
    } else {
      values2 = activeDateManager.getNewValuesFromNewActiveDate(newActiveDate);
      shouldPublish = (newActiveDate != null && !utils2.isValid(newActiveDate)) !== (activeDateManager.date != null && !utils2.isValid(activeDateManager.date));
    }
    if (shouldPublish) {
      return publishValue(_extends$2({}, values2, {
        sections: newSections
      }));
    }
    return setState((prevState) => _extends$2({}, prevState, values2, {
      sections: newSections,
      tempValueStrAndroid: null
    }));
  };
  const setTempAndroidValueStr = (tempValueStrAndroid) => setState((prev2) => _extends$2({}, prev2, {
    tempValueStrAndroid
  }));
  reactExports.useEffect(() => {
    const sections = getSectionsFromValue(state.value);
    setState((prevState) => _extends$2({}, prevState, {
      sections
    }));
  }, [format2, utils2.locale]);
  reactExports.useEffect(() => {
    let shouldUpdate = false;
    if (!valueManager.areValuesEqual(utils2, state.value, valueFromTheOutside)) {
      shouldUpdate = true;
    } else {
      shouldUpdate = valueManager.getTimezone(utils2, state.value) !== valueManager.getTimezone(utils2, valueFromTheOutside);
    }
    if (shouldUpdate) {
      setState((prevState) => _extends$2({}, prevState, {
        value: valueFromTheOutside,
        referenceValue: fieldValueManager.updateReferenceValue(utils2, valueFromTheOutside, prevState.referenceValue),
        sections: getSectionsFromValue(valueFromTheOutside)
      }));
    }
  }, [valueFromTheOutside]);
  return {
    state,
    selectedSectionIndexes,
    setSelectedSections,
    clearValue,
    clearActiveSection,
    updateSectionValue,
    updateValueFromValueStr,
    setTempAndroidValueStr,
    sectionsValueBoundaries,
    placeholder,
    timezone
  };
};
const QUERY_LIFE_DURATION_MS = 5e3;
const isQueryResponseWithoutValue = (response) => response.saveQuery != null;
const useFieldCharacterEditing = ({
  sections,
  updateSectionValue,
  sectionsValueBoundaries,
  setTempAndroidValueStr,
  timezone
}) => {
  const utils2 = useUtils();
  const [query, setQuery] = reactExports.useState(null);
  const resetQuery = useEventCallback$1(() => setQuery(null));
  reactExports.useEffect(() => {
    var _sections$query$secti;
    if (query != null && ((_sections$query$secti = sections[query.sectionIndex]) == null ? void 0 : _sections$query$secti.type) !== query.sectionType) {
      resetQuery();
    }
  }, [sections, query, resetQuery]);
  reactExports.useEffect(() => {
    if (query != null) {
      const timeout = setTimeout(() => resetQuery(), QUERY_LIFE_DURATION_MS);
      return () => {
        window.clearTimeout(timeout);
      };
    }
    return () => {
    };
  }, [query, resetQuery]);
  const applyQuery = ({
    keyPressed,
    sectionIndex
  }, getFirstSectionValueMatchingWithQuery, isValidQueryValue) => {
    const cleanKeyPressed = keyPressed.toLowerCase();
    const activeSection = sections[sectionIndex];
    if (query != null && (!isValidQueryValue || isValidQueryValue(query.value)) && query.sectionIndex === sectionIndex) {
      const concatenatedQueryValue = `${query.value}${cleanKeyPressed}`;
      const queryResponse2 = getFirstSectionValueMatchingWithQuery(concatenatedQueryValue, activeSection);
      if (!isQueryResponseWithoutValue(queryResponse2)) {
        setQuery({
          sectionIndex,
          value: concatenatedQueryValue,
          sectionType: activeSection.type
        });
        return queryResponse2;
      }
    }
    const queryResponse = getFirstSectionValueMatchingWithQuery(cleanKeyPressed, activeSection);
    if (isQueryResponseWithoutValue(queryResponse) && !queryResponse.saveQuery) {
      resetQuery();
      return null;
    }
    setQuery({
      sectionIndex,
      value: cleanKeyPressed,
      sectionType: activeSection.type
    });
    if (isQueryResponseWithoutValue(queryResponse)) {
      return null;
    }
    return queryResponse;
  };
  const applyLetterEditing = (params) => {
    const findMatchingOptions = (format2, options, queryValue) => {
      const matchingValues = options.filter((option) => option.toLowerCase().startsWith(queryValue));
      if (matchingValues.length === 0) {
        return {
          saveQuery: false
        };
      }
      return {
        sectionValue: matchingValues[0],
        shouldGoToNextSection: matchingValues.length === 1
      };
    };
    const testQueryOnFormatAndFallbackFormat = (queryValue, activeSection, fallbackFormat, formatFallbackValue) => {
      const getOptions = (format2) => getLetterEditingOptions(utils2, timezone, activeSection.type, format2);
      if (activeSection.contentType === "letter") {
        return findMatchingOptions(activeSection.format, getOptions(activeSection.format), queryValue);
      }
      if (fallbackFormat && formatFallbackValue != null && getDateSectionConfigFromFormatToken(utils2, fallbackFormat).contentType === "letter") {
        const fallbackOptions = getOptions(fallbackFormat);
        const response = findMatchingOptions(fallbackFormat, fallbackOptions, queryValue);
        if (isQueryResponseWithoutValue(response)) {
          return {
            saveQuery: false
          };
        }
        return _extends$2({}, response, {
          sectionValue: formatFallbackValue(response.sectionValue, fallbackOptions)
        });
      }
      return {
        saveQuery: false
      };
    };
    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
      switch (activeSection.type) {
        case "month": {
          const formatFallbackValue = (fallbackValue) => changeSectionValueFormat(utils2, fallbackValue, utils2.formats.month, activeSection.format);
          return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.month, formatFallbackValue);
        }
        case "weekDay": {
          const formatFallbackValue = (fallbackValue, fallbackOptions) => fallbackOptions.indexOf(fallbackValue).toString();
          return testQueryOnFormatAndFallbackFormat(queryValue, activeSection, utils2.formats.weekday, formatFallbackValue);
        }
        case "meridiem": {
          return testQueryOnFormatAndFallbackFormat(queryValue, activeSection);
        }
        default: {
          return {
            saveQuery: false
          };
        }
      }
    };
    return applyQuery(params, getFirstSectionValueMatchingWithQuery);
  };
  const applyNumericEditing = (params) => {
    const getNewSectionValue = (queryValue, section) => {
      const queryValueNumber = Number(`${queryValue}`);
      const sectionBoundaries = sectionsValueBoundaries[section.type]({
        currentDate: null,
        format: section.format,
        contentType: section.contentType
      });
      if (queryValueNumber > sectionBoundaries.maximum) {
        return {
          saveQuery: false
        };
      }
      if (queryValueNumber < sectionBoundaries.minimum) {
        return {
          saveQuery: true
        };
      }
      const shouldGoToNextSection = Number(`${queryValue}0`) > sectionBoundaries.maximum || queryValue.length === sectionBoundaries.maximum.toString().length;
      const newSectionValue = cleanDigitSectionValue(utils2, timezone, queryValueNumber, sectionBoundaries, section);
      return {
        sectionValue: newSectionValue,
        shouldGoToNextSection
      };
    };
    const getFirstSectionValueMatchingWithQuery = (queryValue, activeSection) => {
      if (activeSection.contentType === "digit" || activeSection.contentType === "digit-with-letter") {
        return getNewSectionValue(queryValue, activeSection);
      }
      if (activeSection.type === "month") {
        const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils2, timezone, "digit", "month", "MM");
        const response = getNewSectionValue(queryValue, {
          type: activeSection.type,
          format: "MM",
          hasLeadingZerosInFormat,
          hasLeadingZerosInInput: true,
          contentType: "digit",
          maxLength: 2
        });
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = changeSectionValueFormat(utils2, response.sectionValue, "MM", activeSection.format);
        return _extends$2({}, response, {
          sectionValue: formattedValue
        });
      }
      if (activeSection.type === "weekDay") {
        const response = getNewSectionValue(queryValue, activeSection);
        if (isQueryResponseWithoutValue(response)) {
          return response;
        }
        const formattedValue = getDaysInWeekStr(utils2, timezone, activeSection.format)[Number(response.sectionValue) - 1];
        return _extends$2({}, response, {
          sectionValue: formattedValue
        });
      }
      return {
        saveQuery: false
      };
    };
    return applyQuery(params, getFirstSectionValueMatchingWithQuery, (queryValue) => !Number.isNaN(Number(queryValue)));
  };
  const applyCharacterEditing = useEventCallback$1((params) => {
    const activeSection = sections[params.sectionIndex];
    const isNumericEditing = !Number.isNaN(Number(params.keyPressed));
    const response = isNumericEditing ? applyNumericEditing(params) : applyLetterEditing(params);
    if (response == null) {
      setTempAndroidValueStr(null);
    } else {
      updateSectionValue({
        activeSection,
        newSectionValue: response.sectionValue,
        shouldGoToNextSection: response.shouldGoToNextSection
      });
    }
  });
  return {
    applyCharacterEditing,
    resetCharacterQuery: resetQuery
  };
};
const _excluded$h = ["onClick", "onKeyDown", "onFocus", "onBlur", "onMouseUp", "onPaste", "error", "clearable", "onClear"];
const useField = (params) => {
  const utils2 = useUtils();
  const {
    state,
    selectedSectionIndexes,
    setSelectedSections,
    clearValue,
    clearActiveSection,
    updateSectionValue,
    updateValueFromValueStr,
    setTempAndroidValueStr,
    sectionsValueBoundaries,
    placeholder,
    timezone
  } = useFieldState(params);
  const {
    inputRef: inputRefProp,
    internalProps,
    internalProps: {
      readOnly = false,
      unstableFieldRef,
      minutesStep
    },
    forwardedProps: {
      onClick,
      onKeyDown,
      onFocus,
      onBlur,
      onMouseUp,
      onPaste,
      error,
      clearable,
      onClear
    },
    fieldValueManager,
    valueManager,
    validator: validator2
  } = params, otherForwardedProps = _objectWithoutPropertiesLoose$1(params.forwardedProps, _excluded$h);
  const {
    applyCharacterEditing,
    resetCharacterQuery
  } = useFieldCharacterEditing({
    sections: state.sections,
    updateSectionValue,
    sectionsValueBoundaries,
    setTempAndroidValueStr,
    timezone
  });
  const inputRef = reactExports.useRef(null);
  const handleRef = useForkRef(inputRefProp, inputRef);
  const focusTimeoutRef = reactExports.useRef(void 0);
  const theme2 = useTheme();
  const isRTL = theme2.direction === "rtl";
  const sectionOrder = reactExports.useMemo(() => getSectionOrder(state.sections, isRTL), [state.sections, isRTL]);
  const syncSelectionFromDOM = () => {
    var _selectionStart;
    if (readOnly) {
      setSelectedSections(null);
      return;
    }
    const browserStartIndex = (_selectionStart = inputRef.current.selectionStart) != null ? _selectionStart : 0;
    let nextSectionIndex;
    if (browserStartIndex <= state.sections[0].startInInput) {
      nextSectionIndex = 1;
    } else if (browserStartIndex >= state.sections[state.sections.length - 1].endInInput) {
      nextSectionIndex = 1;
    } else {
      nextSectionIndex = state.sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
    }
    const sectionIndex = nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;
    setSelectedSections(sectionIndex);
  };
  const handleInputClick = useEventCallback$1((event, ...args) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    onClick == null || onClick(event, ...args);
    syncSelectionFromDOM();
  });
  const handleInputMouseUp = useEventCallback$1((event) => {
    onMouseUp == null || onMouseUp(event);
    event.preventDefault();
  });
  const handleInputFocus = useEventCallback$1((...args) => {
    onFocus == null || onFocus(...args);
    const input = inputRef.current;
    window.clearTimeout(focusTimeoutRef.current);
    focusTimeoutRef.current = setTimeout(() => {
      if (!input || input !== inputRef.current) {
        return;
      }
      if (selectedSectionIndexes != null || readOnly) {
        return;
      }
      if (
        // avoid selecting all sections when focusing empty field without value
        input.value.length && Number(input.selectionEnd) - Number(input.selectionStart) === input.value.length
      ) {
        setSelectedSections("all");
      } else {
        syncSelectionFromDOM();
      }
    });
  });
  const handleInputBlur = useEventCallback$1((...args) => {
    onBlur == null || onBlur(...args);
    setSelectedSections(null);
  });
  const handleInputPaste = useEventCallback$1((event) => {
    onPaste == null || onPaste(event);
    if (readOnly) {
      event.preventDefault();
      return;
    }
    const pastedValue = event.clipboardData.getData("text");
    if (selectedSectionIndexes && selectedSectionIndexes.startIndex === selectedSectionIndexes.endIndex) {
      const activeSection = state.sections[selectedSectionIndexes.startIndex];
      const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);
      const digitsOnly = /^[0-9]+$/.test(pastedValue);
      const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);
      const isValidPastedValue = activeSection.contentType === "letter" && lettersOnly || activeSection.contentType === "digit" && digitsOnly || activeSection.contentType === "digit-with-letter" && digitsAndLetterOnly;
      if (isValidPastedValue) {
        return;
      }
      if (lettersOnly || digitsOnly) {
        event.preventDefault();
        return;
      }
    }
    event.preventDefault();
    resetCharacterQuery();
    updateValueFromValueStr(pastedValue);
  });
  const handleInputChange = useEventCallback$1((event) => {
    if (readOnly) {
      return;
    }
    const targetValue = event.target.value;
    const eventData = event.nativeEvent.data;
    const shouldUseEventData = eventData && eventData.length > 1;
    const valueStr2 = shouldUseEventData ? eventData : targetValue;
    const cleanValueStr = cleanString(valueStr2);
    if (selectedSectionIndexes == null || shouldUseEventData) {
      updateValueFromValueStr(shouldUseEventData ? eventData : cleanValueStr);
      return;
    }
    let keyPressed;
    if (selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1 && cleanValueStr.length === 1) {
      keyPressed = cleanValueStr;
    } else {
      const prevValueStr = cleanString(fieldValueManager.getValueStrFromSections(state.sections, isRTL));
      let startOfDiffIndex = -1;
      let endOfDiffIndex = -1;
      for (let i2 = 0; i2 < prevValueStr.length; i2 += 1) {
        if (startOfDiffIndex === -1 && prevValueStr[i2] !== cleanValueStr[i2]) {
          startOfDiffIndex = i2;
        }
        if (endOfDiffIndex === -1 && prevValueStr[prevValueStr.length - i2 - 1] !== cleanValueStr[cleanValueStr.length - i2 - 1]) {
          endOfDiffIndex = i2;
        }
      }
      const activeSection = state.sections[selectedSectionIndexes.startIndex];
      const hasDiffOutsideOfActiveSection = startOfDiffIndex < activeSection.start || prevValueStr.length - endOfDiffIndex - 1 > activeSection.end;
      if (hasDiffOutsideOfActiveSection) {
        return;
      }
      const activeSectionEndRelativeToNewValue = cleanValueStr.length - prevValueStr.length + activeSection.end - cleanString(activeSection.endSeparator || "").length;
      keyPressed = cleanValueStr.slice(activeSection.start + cleanString(activeSection.startSeparator || "").length, activeSectionEndRelativeToNewValue);
    }
    if (isAndroid() && keyPressed.length === 0) {
      setTempAndroidValueStr(valueStr2);
      return;
    }
    applyCharacterEditing({
      keyPressed,
      sectionIndex: selectedSectionIndexes.startIndex
    });
  });
  const handleInputKeyDown = useEventCallback$1((event) => {
    onKeyDown == null || onKeyDown(event);
    switch (true) {
      case (event.key === "a" && (event.ctrlKey || event.metaKey)): {
        event.preventDefault();
        setSelectedSections("all");
        break;
      }
      case event.key === "ArrowRight": {
        event.preventDefault();
        if (selectedSectionIndexes == null) {
          setSelectedSections(sectionOrder.startIndex);
        } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
          setSelectedSections(selectedSectionIndexes.endIndex);
        } else {
          const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].rightIndex;
          if (nextSectionIndex !== null) {
            setSelectedSections(nextSectionIndex);
          }
        }
        break;
      }
      case event.key === "ArrowLeft": {
        event.preventDefault();
        if (selectedSectionIndexes == null) {
          setSelectedSections(sectionOrder.endIndex);
        } else if (selectedSectionIndexes.startIndex !== selectedSectionIndexes.endIndex) {
          setSelectedSections(selectedSectionIndexes.startIndex);
        } else {
          const nextSectionIndex = sectionOrder.neighbors[selectedSectionIndexes.startIndex].leftIndex;
          if (nextSectionIndex !== null) {
            setSelectedSections(nextSectionIndex);
          }
        }
        break;
      }
      case ["Backspace", "Delete"].includes(event.key): {
        event.preventDefault();
        if (readOnly) {
          break;
        }
        if (selectedSectionIndexes == null || selectedSectionIndexes.startIndex === 0 && selectedSectionIndexes.endIndex === state.sections.length - 1) {
          clearValue();
        } else {
          clearActiveSection();
        }
        resetCharacterQuery();
        break;
      }
      case ["ArrowUp", "ArrowDown", "Home", "End", "PageUp", "PageDown"].includes(event.key): {
        event.preventDefault();
        if (readOnly || selectedSectionIndexes == null) {
          break;
        }
        const activeSection = state.sections[selectedSectionIndexes.startIndex];
        const activeDateManager = fieldValueManager.getActiveDateManager(utils2, state, activeSection);
        const newSectionValue = adjustSectionValue(utils2, timezone, activeSection, event.key, sectionsValueBoundaries, activeDateManager.date, {
          minutesStep
        });
        updateSectionValue({
          activeSection,
          newSectionValue,
          shouldGoToNextSection: false
        });
        break;
      }
    }
  });
  useEnhancedEffect$1(() => {
    if (!inputRef.current) {
      return;
    }
    if (selectedSectionIndexes == null) {
      if (inputRef.current.scrollLeft) {
        inputRef.current.scrollLeft = 0;
      }
      return;
    }
    const firstSelectedSection = state.sections[selectedSectionIndexes.startIndex];
    const lastSelectedSection = state.sections[selectedSectionIndexes.endIndex];
    let selectionStart = firstSelectedSection.startInInput;
    let selectionEnd = lastSelectedSection.endInInput;
    if (selectedSectionIndexes.shouldSelectBoundarySelectors) {
      selectionStart -= firstSelectedSection.startSeparator.length;
      selectionEnd += lastSelectedSection.endSeparator.length;
    }
    if (selectionStart !== inputRef.current.selectionStart || selectionEnd !== inputRef.current.selectionEnd) {
      const currentScrollTop = inputRef.current.scrollTop;
      if (inputRef.current === getActiveElement(document)) {
        inputRef.current.setSelectionRange(selectionStart, selectionEnd);
      }
      inputRef.current.scrollTop = currentScrollTop;
    }
  });
  const validationError = useValidation(_extends$2({}, internalProps, {
    value: state.value,
    timezone
  }), validator2, valueManager.isSameError, valueManager.defaultErrorState);
  const inputError = reactExports.useMemo(() => {
    if (error !== void 0) {
      return error;
    }
    return valueManager.hasError(validationError);
  }, [valueManager, validationError, error]);
  reactExports.useEffect(() => {
    if (!inputError && !selectedSectionIndexes) {
      resetCharacterQuery();
    }
  }, [state.referenceValue, selectedSectionIndexes, inputError]);
  reactExports.useEffect(() => {
    if (inputRef.current && inputRef.current === document.activeElement) {
      setSelectedSections("all");
    }
    return () => window.clearTimeout(focusTimeoutRef.current);
  }, []);
  reactExports.useEffect(() => {
    if (state.tempValueStrAndroid != null && selectedSectionIndexes != null) {
      resetCharacterQuery();
      clearActiveSection();
    }
  }, [state.tempValueStrAndroid]);
  const valueStr = reactExports.useMemo(() => {
    var _state$tempValueStrAn;
    return (_state$tempValueStrAn = state.tempValueStrAndroid) != null ? _state$tempValueStrAn : fieldValueManager.getValueStrFromSections(state.sections, isRTL);
  }, [state.sections, fieldValueManager, state.tempValueStrAndroid, isRTL]);
  const inputMode = reactExports.useMemo(() => {
    if (selectedSectionIndexes == null) {
      return "text";
    }
    if (state.sections[selectedSectionIndexes.startIndex].contentType === "letter") {
      return "text";
    }
    return "numeric";
  }, [selectedSectionIndexes, state.sections]);
  const inputHasFocus = inputRef.current && inputRef.current === getActiveElement(document);
  const areAllSectionsEmpty = valueManager.areValuesEqual(utils2, state.value, valueManager.emptyValue);
  const shouldShowPlaceholder = !inputHasFocus && areAllSectionsEmpty;
  reactExports.useImperativeHandle(unstableFieldRef, () => ({
    getSections: () => state.sections,
    getActiveSectionIndex: () => {
      var _selectionStart2, _selectionEnd;
      const browserStartIndex = (_selectionStart2 = inputRef.current.selectionStart) != null ? _selectionStart2 : 0;
      const browserEndIndex = (_selectionEnd = inputRef.current.selectionEnd) != null ? _selectionEnd : 0;
      if (browserStartIndex === 0 && browserEndIndex === 0) {
        return null;
      }
      const nextSectionIndex = browserStartIndex <= state.sections[0].startInInput ? 1 : state.sections.findIndex((section) => section.startInInput - section.startSeparator.length > browserStartIndex);
      return nextSectionIndex === -1 ? state.sections.length - 1 : nextSectionIndex - 1;
    },
    setSelectedSections: (activeSectionIndex) => setSelectedSections(activeSectionIndex)
  }));
  const handleClearValue = useEventCallback$1((event, ...args) => {
    var _inputRef$current;
    event.preventDefault();
    onClear == null || onClear(event, ...args);
    clearValue();
    inputRef == null || (_inputRef$current = inputRef.current) == null || _inputRef$current.focus();
    setSelectedSections(0);
  });
  return _extends$2({
    placeholder,
    autoComplete: "off"
  }, otherForwardedProps, {
    value: shouldShowPlaceholder ? "" : valueStr,
    inputMode,
    readOnly,
    onClick: handleInputClick,
    onFocus: handleInputFocus,
    onBlur: handleInputBlur,
    onPaste: handleInputPaste,
    onChange: handleInputChange,
    onKeyDown: handleInputKeyDown,
    onMouseUp: handleInputMouseUp,
    onClear: handleClearValue,
    error: inputError,
    ref: handleRef,
    clearable: Boolean(clearable && !areAllSectionsEmpty && !readOnly)
  });
};
const useOpenState = ({
  open: open2,
  onOpen,
  onClose
}) => {
  const isControllingOpenProp = reactExports.useRef(typeof open2 === "boolean").current;
  const [openState, setIsOpenState] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (isControllingOpenProp) {
      if (typeof open2 !== "boolean") {
        throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
      }
      setIsOpenState(open2);
    }
  }, [isControllingOpenProp, open2]);
  const setIsOpen = reactExports.useCallback((newIsOpen) => {
    if (!isControllingOpenProp) {
      setIsOpenState(newIsOpen);
    }
    if (newIsOpen && onOpen) {
      onOpen();
    }
    if (!newIsOpen && onClose) {
      onClose();
    }
  }, [isControllingOpenProp, onOpen, onClose]);
  return {
    isOpen: openState,
    setIsOpen
  };
};
const shouldPublishValue = (params) => {
  const {
    action,
    hasChanged,
    dateState,
    isControlled
  } = params;
  const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
  if (action.name === "setValueFromField") {
    return true;
  }
  if (action.name === "setValueFromAction") {
    if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
      return true;
    }
    return hasChanged(dateState.lastPublishedValue);
  }
  if (action.name === "setValueFromView" && action.selectionState !== "shallow") {
    if (isCurrentValueTheDefaultValue) {
      return true;
    }
    return hasChanged(dateState.lastPublishedValue);
  }
  if (action.name === "setValueFromShortcut") {
    if (isCurrentValueTheDefaultValue) {
      return true;
    }
    return hasChanged(dateState.lastPublishedValue);
  }
  return false;
};
const shouldCommitValue = (params) => {
  const {
    action,
    hasChanged,
    dateState,
    isControlled,
    closeOnSelect
  } = params;
  const isCurrentValueTheDefaultValue = !isControlled && !dateState.hasBeenModifiedSinceMount;
  if (action.name === "setValueFromAction") {
    if (isCurrentValueTheDefaultValue && ["accept", "today", "clear"].includes(action.pickerAction)) {
      return true;
    }
    return hasChanged(dateState.lastCommittedValue);
  }
  if (action.name === "setValueFromView" && action.selectionState === "finish" && closeOnSelect) {
    if (isCurrentValueTheDefaultValue) {
      return true;
    }
    return hasChanged(dateState.lastCommittedValue);
  }
  if (action.name === "setValueFromShortcut") {
    return action.changeImportance === "accept" && hasChanged(dateState.lastCommittedValue);
  }
  return false;
};
const shouldClosePicker = (params) => {
  const {
    action,
    closeOnSelect
  } = params;
  if (action.name === "setValueFromAction") {
    return true;
  }
  if (action.name === "setValueFromView") {
    return action.selectionState === "finish" && closeOnSelect;
  }
  if (action.name === "setValueFromShortcut") {
    return action.changeImportance === "accept";
  }
  return false;
};
const usePickerValue = ({
  props,
  valueManager,
  valueType,
  wrapperVariant,
  validator: validator2
}) => {
  const {
    onAccept,
    onChange,
    value: inValue,
    defaultValue: inDefaultValue,
    closeOnSelect = wrapperVariant === "desktop",
    selectedSections: selectedSectionsProp,
    onSelectedSectionsChange,
    timezone: timezoneProp
  } = props;
  const {
    current: defaultValue
  } = reactExports.useRef(inDefaultValue);
  const {
    current: isControlled
  } = reactExports.useRef(inValue !== void 0);
  const utils2 = useUtils();
  const adapter = useLocalizationContext();
  const [selectedSections, setSelectedSections] = useControlled({
    controlled: selectedSectionsProp,
    default: null,
    name: "usePickerValue",
    state: "selectedSections"
  });
  const {
    isOpen,
    setIsOpen
  } = useOpenState(props);
  const [dateState, setDateState] = reactExports.useState(() => {
    let initialValue;
    if (inValue !== void 0) {
      initialValue = inValue;
    } else if (defaultValue !== void 0) {
      initialValue = defaultValue;
    } else {
      initialValue = valueManager.emptyValue;
    }
    return {
      draft: initialValue,
      lastPublishedValue: initialValue,
      lastCommittedValue: initialValue,
      lastControlledValue: inValue,
      hasBeenModifiedSinceMount: false
    };
  });
  const {
    timezone,
    handleValueChange
  } = useValueWithTimezone({
    timezone: timezoneProp,
    value: inValue,
    defaultValue,
    onChange,
    valueManager
  });
  useValidation(_extends$2({}, props, {
    value: dateState.draft,
    timezone
  }), validator2, valueManager.isSameError, valueManager.defaultErrorState);
  const updateDate = useEventCallback$1((action) => {
    const updaterParams = {
      action,
      dateState,
      hasChanged: (comparison) => !valueManager.areValuesEqual(utils2, action.value, comparison),
      isControlled,
      closeOnSelect
    };
    const shouldPublish = shouldPublishValue(updaterParams);
    const shouldCommit = shouldCommitValue(updaterParams);
    const shouldClose = shouldClosePicker(updaterParams);
    setDateState((prev2) => _extends$2({}, prev2, {
      draft: action.value,
      lastPublishedValue: shouldPublish ? action.value : prev2.lastPublishedValue,
      lastCommittedValue: shouldCommit ? action.value : prev2.lastCommittedValue,
      hasBeenModifiedSinceMount: true
    }));
    if (shouldPublish) {
      const validationError = action.name === "setValueFromField" ? action.context.validationError : validator2({
        adapter,
        value: action.value,
        props: _extends$2({}, props, {
          value: action.value,
          timezone
        })
      });
      const context = {
        validationError
      };
      if (action.name === "setValueFromShortcut" && action.shortcut != null) {
        context.shortcut = action.shortcut;
      }
      handleValueChange(action.value, context);
    }
    if (shouldCommit && onAccept) {
      onAccept(action.value);
    }
    if (shouldClose) {
      setIsOpen(false);
    }
  });
  if (inValue !== void 0 && (dateState.lastControlledValue === void 0 || !valueManager.areValuesEqual(utils2, dateState.lastControlledValue, inValue))) {
    const isUpdateComingFromPicker = valueManager.areValuesEqual(utils2, dateState.draft, inValue);
    setDateState((prev2) => _extends$2({}, prev2, {
      lastControlledValue: inValue
    }, isUpdateComingFromPicker ? {} : {
      lastCommittedValue: inValue,
      lastPublishedValue: inValue,
      draft: inValue,
      hasBeenModifiedSinceMount: true
    }));
  }
  const handleClear = useEventCallback$1(() => {
    updateDate({
      value: valueManager.emptyValue,
      name: "setValueFromAction",
      pickerAction: "clear"
    });
  });
  const handleAccept = useEventCallback$1(() => {
    updateDate({
      value: dateState.lastPublishedValue,
      name: "setValueFromAction",
      pickerAction: "accept"
    });
  });
  const handleDismiss = useEventCallback$1(() => {
    updateDate({
      value: dateState.lastPublishedValue,
      name: "setValueFromAction",
      pickerAction: "dismiss"
    });
  });
  const handleCancel = useEventCallback$1(() => {
    updateDate({
      value: dateState.lastCommittedValue,
      name: "setValueFromAction",
      pickerAction: "cancel"
    });
  });
  const handleSetToday = useEventCallback$1(() => {
    updateDate({
      value: valueManager.getTodayValue(utils2, timezone, valueType),
      name: "setValueFromAction",
      pickerAction: "today"
    });
  });
  const handleOpen = useEventCallback$1(() => setIsOpen(true));
  const handleClose = useEventCallback$1(() => setIsOpen(false));
  const handleChange = useEventCallback$1((newValue, selectionState = "partial") => updateDate({
    name: "setValueFromView",
    value: newValue,
    selectionState
  }));
  const handleSelectShortcut = useEventCallback$1((newValue, changeImportance, shortcut) => updateDate({
    name: "setValueFromShortcut",
    value: newValue,
    changeImportance: changeImportance != null ? changeImportance : "accept",
    shortcut
  }));
  const handleChangeFromField = useEventCallback$1((newValue, context) => updateDate({
    name: "setValueFromField",
    value: newValue,
    context
  }));
  const handleFieldSelectedSectionsChange = useEventCallback$1((newSelectedSections) => {
    setSelectedSections(newSelectedSections);
    onSelectedSectionsChange == null || onSelectedSectionsChange(newSelectedSections);
  });
  const actions = {
    onClear: handleClear,
    onAccept: handleAccept,
    onDismiss: handleDismiss,
    onCancel: handleCancel,
    onSetToday: handleSetToday,
    onOpen: handleOpen,
    onClose: handleClose
  };
  const fieldResponse = {
    value: dateState.draft,
    onChange: handleChangeFromField,
    selectedSections,
    onSelectedSectionsChange: handleFieldSelectedSectionsChange
  };
  const viewValue = reactExports.useMemo(() => valueManager.cleanValue(utils2, dateState.draft), [utils2, valueManager, dateState.draft]);
  const viewResponse = {
    value: viewValue,
    onChange: handleChange,
    onClose: handleClose,
    open: isOpen,
    onSelectedSectionsChange: handleFieldSelectedSectionsChange
  };
  const isValid = (testedValue) => {
    const error = validator2({
      adapter,
      value: testedValue,
      props: _extends$2({}, props, {
        value: testedValue,
        timezone
      })
    });
    return !valueManager.hasError(error);
  };
  const layoutResponse = _extends$2({}, actions, {
    value: viewValue,
    onChange: handleChange,
    onSelectShortcut: handleSelectShortcut,
    isValid
  });
  return {
    open: isOpen,
    fieldProps: fieldResponse,
    viewProps: viewResponse,
    layoutProps: layoutResponse,
    actions
  };
};
function useViews({
  onChange,
  onViewChange,
  openTo,
  view: inView,
  views,
  autoFocus,
  focusedView: inFocusedView,
  onFocusedViewChange
}) {
  var _views, _views2;
  const previousOpenTo = reactExports.useRef(openTo);
  const previousViews = reactExports.useRef(views);
  const defaultView = reactExports.useRef(views.includes(openTo) ? openTo : views[0]);
  const [view, setView] = useControlled({
    name: "useViews",
    state: "view",
    controlled: inView,
    default: defaultView.current
  });
  const defaultFocusedView = reactExports.useRef(autoFocus ? view : null);
  const [focusedView, setFocusedView] = useControlled({
    name: "useViews",
    state: "focusedView",
    controlled: inFocusedView,
    default: defaultFocusedView.current
  });
  reactExports.useEffect(() => {
    if (previousOpenTo.current && previousOpenTo.current !== openTo || previousViews.current && previousViews.current.some((previousView2) => !views.includes(previousView2))) {
      setView(views.includes(openTo) ? openTo : views[0]);
      previousViews.current = views;
      previousOpenTo.current = openTo;
    }
  }, [openTo, setView, view, views]);
  const viewIndex = views.indexOf(view);
  const previousView = (_views = views[viewIndex - 1]) != null ? _views : null;
  const nextView = (_views2 = views[viewIndex + 1]) != null ? _views2 : null;
  const handleFocusedViewChange = useEventCallback$1((viewToFocus, hasFocus) => {
    if (hasFocus) {
      setFocusedView(viewToFocus);
    } else {
      setFocusedView(
        (prevFocusedView) => viewToFocus === prevFocusedView ? null : prevFocusedView
        // If false the blur is due to view switching
      );
    }
    onFocusedViewChange == null || onFocusedViewChange(viewToFocus, hasFocus);
  });
  const handleChangeView = useEventCallback$1((newView) => {
    if (newView === view) {
      return;
    }
    setView(newView);
    handleFocusedViewChange(newView, true);
    if (onViewChange) {
      onViewChange(newView);
    }
  });
  const goToNextView = useEventCallback$1(() => {
    if (nextView) {
      handleChangeView(nextView);
    }
    handleFocusedViewChange(nextView, true);
  });
  const setValueAndGoToNextView = useEventCallback$1((value, currentViewSelectionState, selectedView) => {
    const isSelectionFinishedOnCurrentView = currentViewSelectionState === "finish";
    const hasMoreViews = selectedView ? (
      // handles case like `DateTimePicker`, where a view might return a `finish` selection state
      // but we it's not the final view given all `views` -> overall selection state should be `partial`.
      views.indexOf(selectedView) < views.length - 1
    ) : Boolean(nextView);
    const globalSelectionState = isSelectionFinishedOnCurrentView && hasMoreViews ? "partial" : currentViewSelectionState;
    onChange(value, globalSelectionState);
    if (isSelectionFinishedOnCurrentView) {
      goToNextView();
    }
  });
  const setValueAndGoToView = useEventCallback$1((value, newView, selectedView) => {
    onChange(value, newView ? "partial" : "finish", selectedView);
    if (newView) {
      handleChangeView(newView);
      handleFocusedViewChange(newView, true);
    }
  });
  return {
    view,
    setView: handleChangeView,
    focusedView,
    setFocusedView: handleFocusedViewChange,
    nextView,
    previousView,
    defaultView: defaultView.current,
    goToNextView,
    setValueAndGoToNextView,
    setValueAndGoToView
  };
}
const _excluded$g = ["className", "sx"];
const usePickerViews = ({
  props,
  propsFromPickerValue,
  additionalViewProps,
  inputRef,
  autoFocusView
}) => {
  const {
    onChange,
    open: open2,
    onSelectedSectionsChange,
    onClose
  } = propsFromPickerValue;
  const {
    views,
    openTo,
    onViewChange,
    disableOpenPicker,
    viewRenderers,
    timezone
  } = props;
  const propsToForwardToView = _objectWithoutPropertiesLoose$1(props, _excluded$g);
  const {
    view,
    setView,
    defaultView,
    focusedView,
    setFocusedView,
    setValueAndGoToNextView
  } = useViews({
    view: void 0,
    views,
    openTo,
    onChange,
    onViewChange,
    autoFocus: autoFocusView
  });
  const {
    hasUIView,
    viewModeLookup
  } = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
    let viewMode;
    if (disableOpenPicker) {
      viewMode = "field";
    } else if (viewRenderers[viewForReduce] != null) {
      viewMode = "UI";
    } else {
      viewMode = "field";
    }
    acc.viewModeLookup[viewForReduce] = viewMode;
    if (viewMode === "UI") {
      acc.hasUIView = true;
    }
    return acc;
  }, {
    hasUIView: false,
    viewModeLookup: {}
  }), [disableOpenPicker, viewRenderers, views]);
  const timeViewsCount = reactExports.useMemo(() => views.reduce((acc, viewForReduce) => {
    if (viewRenderers[viewForReduce] != null && isTimeView(viewForReduce)) {
      return acc + 1;
    }
    return acc;
  }, 0), [viewRenderers, views]);
  const currentViewMode = viewModeLookup[view];
  const shouldRestoreFocus = useEventCallback$1(() => currentViewMode === "UI");
  const [popperView, setPopperView] = reactExports.useState(currentViewMode === "UI" ? view : null);
  if (popperView !== view && viewModeLookup[view] === "UI") {
    setPopperView(view);
  }
  useEnhancedEffect$1(() => {
    if (currentViewMode === "field" && open2) {
      onClose();
      setTimeout(() => {
        inputRef == null || inputRef.current.focus();
        onSelectedSectionsChange(view);
      });
    }
  }, [view]);
  useEnhancedEffect$1(() => {
    if (!open2) {
      return;
    }
    let newView = view;
    if (currentViewMode === "field" && popperView != null) {
      newView = popperView;
    }
    if (newView !== defaultView && viewModeLookup[newView] === "UI" && viewModeLookup[defaultView] === "UI") {
      newView = defaultView;
    }
    if (newView !== view) {
      setView(newView);
    }
    setFocusedView(newView, true);
  }, [open2]);
  const layoutProps = {
    views,
    view: popperView,
    onViewChange: setView
  };
  return {
    hasUIView,
    shouldRestoreFocus,
    layoutProps,
    renderCurrentView: () => {
      if (popperView == null) {
        return null;
      }
      const renderer = viewRenderers[popperView];
      if (renderer == null) {
        return null;
      }
      return renderer(_extends$2({}, propsToForwardToView, additionalViewProps, propsFromPickerValue, {
        views,
        timezone,
        onChange: setValueAndGoToNextView,
        view: popperView,
        onViewChange: setView,
        focusedView,
        onFocusedViewChange: setFocusedView,
        showViewSwitcher: timeViewsCount > 1,
        timeViewsCount
      }));
    }
  };
};
function getOrientation() {
  if (typeof window === "undefined") {
    return "portrait";
  }
  if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
    return Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait";
  }
  if (window.orientation) {
    return Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait";
  }
  return "portrait";
}
const useIsLandscape = (views, customOrientation) => {
  const [orientation, setOrientation] = reactExports.useState(getOrientation);
  useEnhancedEffect$1(() => {
    const eventHandler = () => {
      setOrientation(getOrientation());
    };
    window.addEventListener("orientationchange", eventHandler);
    return () => {
      window.removeEventListener("orientationchange", eventHandler);
    };
  }, []);
  if (arrayIncludes(views, ["hours", "minutes", "seconds"])) {
    return false;
  }
  const orientationToUse = customOrientation || orientation;
  return orientationToUse === "landscape";
};
const usePickerLayoutProps = ({
  props,
  propsFromPickerValue,
  propsFromPickerViews,
  wrapperVariant
}) => {
  const {
    orientation
  } = props;
  const isLandscape = useIsLandscape(propsFromPickerViews.views, orientation);
  const layoutProps = _extends$2({}, propsFromPickerViews, propsFromPickerValue, {
    isLandscape,
    wrapperVariant,
    disabled: props.disabled,
    readOnly: props.readOnly
  });
  return {
    layoutProps
  };
};
buildWarning(["The `renderInput` prop has been removed in version 6.0 of the Date and Time Pickers.", "You can replace it with the `textField` component slot in most cases.", "For more information, please have a look at the migration guide (https://mui.com/x/migration/migration-pickers-v5/#input-renderer-required-in-v5)."]);
const usePicker = ({
  props,
  valueManager,
  valueType,
  wrapperVariant,
  inputRef,
  additionalViewProps,
  validator: validator2,
  autoFocusView
}) => {
  const pickerValueResponse = usePickerValue({
    props,
    valueManager,
    valueType,
    wrapperVariant,
    validator: validator2
  });
  const pickerViewsResponse = usePickerViews({
    props,
    inputRef,
    additionalViewProps,
    autoFocusView,
    propsFromPickerValue: pickerValueResponse.viewProps
  });
  const pickerLayoutResponse = usePickerLayoutProps({
    props,
    wrapperVariant,
    propsFromPickerValue: pickerValueResponse.layoutProps,
    propsFromPickerViews: pickerViewsResponse.layoutProps
  });
  return {
    // Picker value
    open: pickerValueResponse.open,
    actions: pickerValueResponse.actions,
    fieldProps: pickerValueResponse.fieldProps,
    // Picker views
    renderCurrentView: pickerViewsResponse.renderCurrentView,
    hasUIView: pickerViewsResponse.hasUIView,
    shouldRestoreFocus: pickerViewsResponse.shouldRestoreFocus,
    // Picker layout
    layoutProps: pickerLayoutResponse.layoutProps
  };
};
function getPickersLayoutUtilityClass(slot) {
  return generateUtilityClass("MuiPickersLayout", slot);
}
const pickersLayoutClasses = generateUtilityClasses("MuiPickersLayout", ["root", "landscape", "contentWrapper", "toolbar", "actionBar", "shortcuts"]);
const _excluded$f = ["onAccept", "onClear", "onCancel", "onSetToday", "actions"];
function PickersActionBar(props) {
  const {
    onAccept,
    onClear,
    onCancel,
    onSetToday,
    actions
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$f);
  const localeText = useLocaleText();
  if (actions == null || actions.length === 0) {
    return null;
  }
  const buttons = actions == null ? void 0 : actions.map((actionType) => {
    switch (actionType) {
      case "clear":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
          onClick: onClear,
          children: localeText.clearButtonLabel
        }, actionType);
      case "cancel":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
          onClick: onCancel,
          children: localeText.cancelButtonLabel
        }, actionType);
      case "accept":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
          onClick: onAccept,
          children: localeText.okButtonLabel
        }, actionType);
      case "today":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
          onClick: onSetToday,
          children: localeText.todayButtonLabel
        }, actionType);
      default:
        return null;
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActions$1, _extends$2({}, other, {
    children: buttons
  }));
}
const _excluded$e = ["items", "changeImportance", "isLandscape", "onChange", "isValid"], _excluded2$4 = ["getValue"];
function PickersShortcuts(props) {
  const {
    items,
    changeImportance,
    onChange,
    isValid
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$e);
  if (items == null || items.length === 0) {
    return null;
  }
  const resolvedItems = items.map((_ref) => {
    let {
      getValue: getValue2
    } = _ref, item = _objectWithoutPropertiesLoose$1(_ref, _excluded2$4);
    const newValue = getValue2({
      isValid
    });
    return {
      label: item.label,
      onClick: () => {
        onChange(newValue, changeImportance, item);
      },
      disabled: !isValid(newValue)
    };
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, _extends$2({
    dense: true,
    sx: [{
      maxHeight: VIEW_HEIGHT,
      maxWidth: 200,
      overflow: "auto"
    }, ...Array.isArray(other.sx) ? other.sx : [other.sx]]
  }, other, {
    children: resolvedItems.map((item) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem$1, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chip$1, _extends$2({}, item))
      }, item.label);
    })
  }));
}
function toolbarHasView(toolbarProps) {
  return toolbarProps.view !== null;
}
const useUtilityClasses$b = (ownerState) => {
  const {
    classes,
    isLandscape
  } = ownerState;
  const slots = {
    root: ["root", isLandscape && "landscape"],
    contentWrapper: ["contentWrapper"],
    toolbar: ["toolbar"],
    actionBar: ["actionBar"],
    tabs: ["tabs"],
    landscape: ["landscape"],
    shortcuts: ["shortcuts"]
  };
  return composeClasses(slots, getPickersLayoutUtilityClass, classes);
};
const usePickerLayout = (props) => {
  var _slots$actionBar, _slots$shortcuts;
  const {
    wrapperVariant,
    onAccept,
    onClear,
    onCancel,
    onSetToday,
    view,
    views,
    onViewChange,
    value,
    onChange,
    onSelectShortcut,
    isValid,
    isLandscape,
    disabled,
    readOnly,
    children,
    components,
    componentsProps,
    slots: innerSlots,
    slotProps: innerSlotProps
    // TODO: Remove this "as" hack. It get introduced to mark `value` prop in PickersLayoutProps as not required.
    // The true type should be
    // - For pickers value: TDate | null
    // - For range pickers value: [TDate | null, TDate | null]
  } = props;
  const slots = innerSlots != null ? innerSlots : uncapitalizeObjectKeys(components);
  const slotProps = innerSlotProps != null ? innerSlotProps : componentsProps;
  const classes = useUtilityClasses$b(props);
  const ActionBar = (_slots$actionBar = slots == null ? void 0 : slots.actionBar) != null ? _slots$actionBar : PickersActionBar;
  const actionBarProps = useSlotProps({
    elementType: ActionBar,
    externalSlotProps: slotProps == null ? void 0 : slotProps.actionBar,
    additionalProps: {
      onAccept,
      onClear,
      onCancel,
      onSetToday,
      actions: wrapperVariant === "desktop" ? [] : ["cancel", "accept"],
      className: classes.actionBar
    },
    ownerState: _extends$2({}, props, {
      wrapperVariant
    })
  });
  const actionBar = /* @__PURE__ */ jsxRuntimeExports.jsx(ActionBar, _extends$2({}, actionBarProps));
  const Toolbar3 = slots == null ? void 0 : slots.toolbar;
  const toolbarProps = useSlotProps({
    elementType: Toolbar3,
    externalSlotProps: slotProps == null ? void 0 : slotProps.toolbar,
    additionalProps: {
      isLandscape,
      onChange,
      value,
      view,
      onViewChange,
      views,
      disabled,
      readOnly,
      className: classes.toolbar
    },
    ownerState: _extends$2({}, props, {
      wrapperVariant
    })
  });
  const toolbar = toolbarHasView(toolbarProps) && !!Toolbar3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar3, _extends$2({}, toolbarProps)) : null;
  const content2 = children;
  const Tabs3 = slots == null ? void 0 : slots.tabs;
  const tabs = view && Tabs3 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs3, _extends$2({
    view,
    onViewChange
  }, slotProps == null ? void 0 : slotProps.tabs)) : null;
  const Shortcuts = (_slots$shortcuts = slots == null ? void 0 : slots.shortcuts) != null ? _slots$shortcuts : PickersShortcuts;
  const shortcutsProps = useSlotProps({
    elementType: Shortcuts,
    externalSlotProps: slotProps == null ? void 0 : slotProps.shortcuts,
    additionalProps: {
      isValid,
      isLandscape,
      onChange: onSelectShortcut,
      className: classes.shortcuts
    },
    ownerState: {
      isValid,
      isLandscape,
      onChange: onSelectShortcut,
      className: classes.shortcuts,
      wrapperVariant
    }
  });
  const shortcuts = view && !!Shortcuts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Shortcuts, _extends$2({}, shortcutsProps)) : null;
  return {
    toolbar,
    content: content2,
    tabs,
    actionBar,
    shortcuts
  };
};
const usePickerLayout$1 = usePickerLayout;
const useUtilityClasses$a = (ownerState) => {
  const {
    isLandscape,
    classes
  } = ownerState;
  const slots = {
    root: ["root", isLandscape && "landscape"],
    contentWrapper: ["contentWrapper"]
  };
  return composeClasses(slots, getPickersLayoutUtilityClass, classes);
};
const PickersLayoutRoot = styled$1("div", {
  name: "MuiPickersLayout",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2,
  ownerState
}) => ({
  display: "grid",
  gridAutoColumns: "max-content auto max-content",
  gridAutoRows: "max-content auto max-content",
  [`& .${pickersLayoutClasses.toolbar}`]: ownerState.isLandscape ? {
    gridColumn: theme2.direction === "rtl" ? 3 : 1,
    gridRow: "2 / 3"
  } : {
    gridColumn: "2 / 4",
    gridRow: 1
  },
  [`.${pickersLayoutClasses.shortcuts}`]: ownerState.isLandscape ? {
    gridColumn: "2 / 4",
    gridRow: 1
  } : {
    gridColumn: theme2.direction === "rtl" ? 3 : 1,
    gridRow: "2 / 3"
  },
  [`& .${pickersLayoutClasses.actionBar}`]: {
    gridColumn: "1 / 4",
    gridRow: 3
  }
}));
PickersLayoutRoot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: PropTypes.elementType,
  ownerState: PropTypes.shape({
    isLandscape: PropTypes.bool.isRequired
  }).isRequired,
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])
};
const PickersLayoutContentWrapper = styled$1("div", {
  name: "MuiPickersLayout",
  slot: "ContentWrapper",
  overridesResolver: (props, styles2) => styles2.contentWrapper
})({
  gridColumn: 2,
  gridRow: 2,
  display: "flex",
  flexDirection: "column"
});
const PickersLayout = function PickersLayout2(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersLayout"
  });
  const {
    toolbar,
    content: content2,
    tabs,
    actionBar,
    shortcuts
  } = usePickerLayout$1(props);
  const {
    sx,
    className,
    isLandscape,
    ref,
    wrapperVariant
  } = props;
  const ownerState = props;
  const classes = useUtilityClasses$a(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersLayoutRoot, {
    ref,
    sx,
    className: clsx(className, classes.root),
    ownerState,
    children: [isLandscape ? shortcuts : toolbar, isLandscape ? toolbar : shortcuts, /* @__PURE__ */ jsxRuntimeExports.jsx(PickersLayoutContentWrapper, {
      className: classes.contentWrapper,
      children: wrapperVariant === "desktop" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [content2, tabs]
      }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [tabs, content2]
      })
    }), actionBar]
  });
};
function useNextMonthDisabled(month, {
  disableFuture,
  maxDate,
  timezone
}) {
  const utils2 = useUtils();
  return reactExports.useMemo(() => {
    const now2 = utils2.dateWithTimezone(void 0, timezone);
    const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now2, maxDate) ? now2 : maxDate);
    return !utils2.isAfter(lastEnabledMonth, month);
  }, [disableFuture, maxDate, month, utils2, timezone]);
}
function usePreviousMonthDisabled(month, {
  disablePast,
  minDate,
  timezone
}) {
  const utils2 = useUtils();
  return reactExports.useMemo(() => {
    const now2 = utils2.dateWithTimezone(void 0, timezone);
    const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now2, minDate) ? now2 : minDate);
    return !utils2.isBefore(firstEnabledMonth, month);
  }, [disablePast, minDate, month, utils2, timezone]);
}
const DATE_VALIDATION_PROP_NAMES = ["disablePast", "disableFuture", "minDate", "maxDate", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear"];
const TIME_VALIDATION_PROP_NAMES = ["disablePast", "disableFuture", "minTime", "maxTime", "shouldDisableClock", "shouldDisableTime", "minutesStep", "ampm", "disableIgnoringDatePartForTimeValidation"];
const DATE_TIME_VALIDATION_PROP_NAMES = ["minDateTime", "maxDateTime"];
const VALIDATION_PROP_NAMES = [...DATE_VALIDATION_PROP_NAMES, ...TIME_VALIDATION_PROP_NAMES, ...DATE_TIME_VALIDATION_PROP_NAMES];
const extractValidationProps = (props) => VALIDATION_PROP_NAMES.reduce((extractedProps, propName) => {
  if (props.hasOwnProperty(propName)) {
    extractedProps[propName] = props[propName];
  }
  return extractedProps;
}, {});
const SHARED_FIELD_INTERNAL_PROP_NAMES = ["value", "defaultValue", "referenceDate", "format", "formatDensity", "onChange", "timezone", "readOnly", "onError", "shouldRespectLeadingZeros", "selectedSections", "onSelectedSectionsChange", "unstableFieldRef"];
const splitFieldInternalAndForwardedProps = (props, valueType) => {
  const forwardedProps = _extends$2({}, props);
  const internalProps = {};
  const extractProp = (propName) => {
    if (forwardedProps.hasOwnProperty(propName)) {
      internalProps[propName] = forwardedProps[propName];
      delete forwardedProps[propName];
    }
  };
  SHARED_FIELD_INTERNAL_PROP_NAMES.forEach(extractProp);
  if (valueType === "date") {
    DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
  } else if (valueType === "time") {
    TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
  } else if (valueType === "date-time") {
    DATE_VALIDATION_PROP_NAMES.forEach(extractProp);
    TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
    DATE_TIME_VALIDATION_PROP_NAMES.forEach(extractProp);
  }
  return {
    forwardedProps,
    internalProps
  };
};
const validateDate = ({
  props,
  value,
  adapter
}) => {
  if (value === null) {
    return null;
  }
  const {
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    disablePast,
    disableFuture,
    timezone
  } = props;
  const now2 = adapter.utils.dateWithTimezone(void 0, timezone);
  const minDate = applyDefaultDate(adapter.utils, props.minDate, adapter.defaultDates.minDate);
  const maxDate = applyDefaultDate(adapter.utils, props.maxDate, adapter.defaultDates.maxDate);
  switch (true) {
    case !adapter.utils.isValid(value):
      return "invalidDate";
    case Boolean(shouldDisableDate && shouldDisableDate(value)):
      return "shouldDisableDate";
    case Boolean(shouldDisableMonth && shouldDisableMonth(value)):
      return "shouldDisableMonth";
    case Boolean(shouldDisableYear && shouldDisableYear(value)):
      return "shouldDisableYear";
    case Boolean(disableFuture && adapter.utils.isAfterDay(value, now2)):
      return "disableFuture";
    case Boolean(disablePast && adapter.utils.isBeforeDay(value, now2)):
      return "disablePast";
    case Boolean(minDate && adapter.utils.isBeforeDay(value, minDate)):
      return "minDate";
    case Boolean(maxDate && adapter.utils.isAfterDay(value, maxDate)):
      return "maxDate";
    default:
      return null;
  }
};
function getPickersDayUtilityClass(slot) {
  return generateUtilityClass("MuiPickersDay", slot);
}
const pickersDayClasses = generateUtilityClasses("MuiPickersDay", ["root", "dayWithMargin", "dayOutsideMonth", "hiddenDaySpacingFiller", "today", "selected", "disabled"]);
const _excluded$d = ["autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDaySelect", "onFocus", "onBlur", "onKeyDown", "onMouseDown", "onMouseEnter", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today", "isFirstVisibleCell", "isLastVisibleCell"];
const useUtilityClasses$9 = (ownerState) => {
  const {
    selected,
    disableMargin,
    disableHighlightToday,
    today,
    disabled,
    outsideCurrentMonth,
    showDaysOutsideCurrentMonth,
    classes
  } = ownerState;
  const isHiddenDaySpacingFiller = outsideCurrentMonth && !showDaysOutsideCurrentMonth;
  const slots = {
    root: ["root", selected && !isHiddenDaySpacingFiller && "selected", disabled && "disabled", !disableMargin && "dayWithMargin", !disableHighlightToday && today && "today", outsideCurrentMonth && showDaysOutsideCurrentMonth && "dayOutsideMonth", isHiddenDaySpacingFiller && "hiddenDaySpacingFiller"],
    hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
  };
  return composeClasses(slots, getPickersDayUtilityClass, classes);
};
const styleArg = ({
  theme: theme2,
  ownerState
}) => _extends$2({}, theme2.typography.caption, {
  width: DAY_SIZE,
  height: DAY_SIZE,
  borderRadius: "50%",
  padding: 0,
  // explicitly setting to `transparent` to avoid potentially getting impacted by change from the overridden component
  backgroundColor: "transparent",
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.short
  }),
  color: (theme2.vars || theme2).palette.text.primary,
  "@media (pointer: fine)": {
    "&:hover": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.hoverOpacity)
    }
  },
  "&:focus": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.focusOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.focusOpacity),
    [`&.${pickersDayClasses.selected}`]: {
      willChange: "background-color",
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    }
  },
  [`&.${pickersDayClasses.selected}`]: {
    color: (theme2.vars || theme2).palette.primary.contrastText,
    backgroundColor: (theme2.vars || theme2).palette.primary.main,
    fontWeight: theme2.typography.fontWeightMedium,
    "&:hover": {
      willChange: "background-color",
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    }
  },
  [`&.${pickersDayClasses.disabled}:not(.${pickersDayClasses.selected})`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${pickersDayClasses.disabled}&.${pickersDayClasses.selected}`]: {
    opacity: 0.6
  }
}, !ownerState.disableMargin && {
  margin: `0 ${DAY_MARGIN}px`
}, ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && {
  color: (theme2.vars || theme2).palette.text.secondary
}, !ownerState.disableHighlightToday && ownerState.today && {
  [`&:not(.${pickersDayClasses.selected})`]: {
    border: `1px solid ${(theme2.vars || theme2).palette.text.secondary}`
  }
});
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, !ownerState.disableMargin && styles2.dayWithMargin, !ownerState.disableHighlightToday && ownerState.today && styles2.today, !ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && styles2.dayOutsideMonth, ownerState.outsideCurrentMonth && !ownerState.showDaysOutsideCurrentMonth && styles2.hiddenDaySpacingFiller];
};
const PickersDayRoot = styled$1(ButtonBase$1, {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver
})(styleArg);
const PickersDayFiller = styled$1("div", {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$2({}, styleArg({
  theme: theme2,
  ownerState
}), {
  // visibility: 'hidden' does not work here as it hides the element from screen readers as well
  opacity: 0,
  pointerEvents: "none"
}));
const noop$1 = () => {
};
const PickersDayRaw = /* @__PURE__ */ reactExports.forwardRef(function PickersDay(inProps, forwardedRef) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersDay"
  });
  const {
    autoFocus = false,
    className,
    day,
    disabled = false,
    disableHighlightToday = false,
    disableMargin = false,
    isAnimating,
    onClick,
    onDaySelect,
    onFocus = noop$1,
    onBlur = noop$1,
    onKeyDown = noop$1,
    onMouseDown = noop$1,
    onMouseEnter = noop$1,
    outsideCurrentMonth,
    selected = false,
    showDaysOutsideCurrentMonth = false,
    children,
    today: isToday = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$d);
  const ownerState = _extends$2({}, props, {
    autoFocus,
    disabled,
    disableHighlightToday,
    disableMargin,
    selected,
    showDaysOutsideCurrentMonth,
    today: isToday
  });
  const classes = useUtilityClasses$9(ownerState);
  const utils2 = useUtils();
  const ref = reactExports.useRef(null);
  const handleRef = useForkRef(ref, forwardedRef);
  useEnhancedEffect$1(() => {
    if (autoFocus && !disabled && !isAnimating && !outsideCurrentMonth) {
      ref.current.focus();
    }
  }, [autoFocus, disabled, isAnimating, outsideCurrentMonth]);
  const handleMouseDown = (event) => {
    onMouseDown(event);
    if (outsideCurrentMonth) {
      event.preventDefault();
    }
  };
  const handleClick = (event) => {
    if (!disabled) {
      onDaySelect(day);
    }
    if (outsideCurrentMonth) {
      event.currentTarget.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  if (outsideCurrentMonth && !showDaysOutsideCurrentMonth) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayFiller, {
      className: clsx(classes.root, classes.hiddenDaySpacingFiller, className),
      ownerState,
      role: other.role
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersDayRoot, _extends$2({
    className: clsx(classes.root, className),
    ref: handleRef,
    centerRipple: true,
    disabled,
    tabIndex: selected ? 0 : -1,
    onKeyDown: (event) => onKeyDown(event, day),
    onFocus: (event) => onFocus(event, day),
    onBlur: (event) => onBlur(event, day),
    onMouseEnter: (event) => onMouseEnter(event, day),
    onClick: handleClick,
    onMouseDown: handleMouseDown
  }, other, {
    ownerState,
    children: !children ? utils2.format(day, "dayOfMonth") : children
  }));
});
const PickersDay2 = /* @__PURE__ */ reactExports.memo(PickersDayRaw);
const getPickersSlideTransitionUtilityClass = (slot) => generateUtilityClass("MuiPickersSlideTransition", slot);
const pickersSlideTransitionClasses = generateUtilityClasses("MuiPickersSlideTransition", ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"]);
const _excluded$c = ["children", "className", "reduceAnimations", "slideDirection", "transKey", "classes"];
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes,
    slideDirection
  } = ownerState;
  const slots = {
    root: ["root"],
    exit: ["slideExit"],
    enterActive: ["slideEnterActive"],
    enter: [`slideEnter-${slideDirection}`],
    exitActive: [`slideExitActiveLeft-${slideDirection}`]
  };
  return composeClasses(slots, getPickersSlideTransitionUtilityClass, classes);
};
const slideAnimationDuration = 350;
const PickersSlideTransitionRoot = styled$1(TransitionGroup$1, {
  name: "MuiPickersSlideTransition",
  slot: "Root",
  overridesResolver: (_2, styles2) => [styles2.root, {
    [`.${pickersSlideTransitionClasses["slideEnter-left"]}`]: styles2["slideEnter-left"]
  }, {
    [`.${pickersSlideTransitionClasses["slideEnter-right"]}`]: styles2["slideEnter-right"]
  }, {
    [`.${pickersSlideTransitionClasses.slideEnterActive}`]: styles2.slideEnterActive
  }, {
    [`.${pickersSlideTransitionClasses.slideExit}`]: styles2.slideExit
  }, {
    [`.${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: styles2["slideExitActiveLeft-left"]
  }, {
    [`.${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: styles2["slideExitActiveLeft-right"]
  }]
})(({
  theme: theme2
}) => {
  const slideTransition = theme2.transitions.create("transform", {
    duration: slideAnimationDuration,
    easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
  });
  return {
    display: "block",
    position: "relative",
    overflowX: "hidden",
    "& > *": {
      position: "absolute",
      top: 0,
      right: 0,
      left: 0
    },
    [`& .${pickersSlideTransitionClasses["slideEnter-left"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      zIndex: 1
    },
    [`& .${pickersSlideTransitionClasses["slideEnter-right"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      zIndex: 1
    },
    [`& .${pickersSlideTransitionClasses.slideEnterActive}`]: {
      transform: "translate(0%)",
      transition: slideTransition
    },
    [`& .${pickersSlideTransitionClasses.slideExit}`]: {
      transform: "translate(0%)"
    },
    [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-left"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      transition: slideTransition,
      zIndex: 0
    },
    [`& .${pickersSlideTransitionClasses["slideExitActiveLeft-right"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      transition: slideTransition,
      zIndex: 0
    }
  };
});
function PickersSlideTransition(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersSlideTransition"
  });
  const {
    children,
    className,
    reduceAnimations,
    transKey
    // extracting `classes` from `other`
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$c);
  const classes = useUtilityClasses$8(props);
  if (reduceAnimations) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: clsx(classes.root, className),
      children
    });
  }
  const transitionClasses = {
    exit: classes.exit,
    enterActive: classes.enterActive,
    enter: classes.enter,
    exitActive: classes.exitActive
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersSlideTransitionRoot, {
    className: clsx(classes.root, className),
    childFactory: (element) => /* @__PURE__ */ reactExports.cloneElement(element, {
      classNames: transitionClasses
    }),
    role: "presentation",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(CSSTransition$1, _extends$2({
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: slideAnimationDuration,
      classNames: transitionClasses
    }, other, {
      children
    }), transKey)
  });
}
const useIsDateDisabled = ({
  shouldDisableDate,
  shouldDisableMonth,
  shouldDisableYear,
  minDate,
  maxDate,
  disableFuture,
  disablePast,
  timezone
}) => {
  const adapter = useLocalizationContext();
  return reactExports.useCallback((day) => validateDate({
    adapter,
    value: day,
    props: {
      shouldDisableDate,
      shouldDisableMonth,
      shouldDisableYear,
      minDate,
      maxDate,
      disableFuture,
      disablePast,
      timezone
    }
  }) !== null, [adapter, shouldDisableDate, shouldDisableMonth, shouldDisableYear, minDate, maxDate, disableFuture, disablePast, timezone]);
};
const getDayCalendarUtilityClass = (slot) => generateUtilityClass("MuiDayCalendar", slot);
generateUtilityClasses("MuiDayCalendar", ["root", "header", "weekDayLabel", "loadingContainer", "slideTransition", "monthContainer", "weekContainer", "weekNumberLabel", "weekNumber"]);
const _excluded$b = ["parentProps", "day", "focusableDay", "selectedDays", "isDateDisabled", "currentMonthNumber", "isViewFocused"], _excluded2$3 = ["ownerState"];
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    header: ["header"],
    weekDayLabel: ["weekDayLabel"],
    loadingContainer: ["loadingContainer"],
    slideTransition: ["slideTransition"],
    monthContainer: ["monthContainer"],
    weekContainer: ["weekContainer"],
    weekNumberLabel: ["weekNumberLabel"],
    weekNumber: ["weekNumber"]
  };
  return composeClasses(slots, getDayCalendarUtilityClass, classes);
};
const weeksContainerHeight = (DAY_SIZE + DAY_MARGIN * 2) * 6;
const PickersCalendarDayRoot = styled$1("div", {
  name: "MuiDayCalendar",
  slot: "Root",
  overridesResolver: (_2, styles2) => styles2.root
})({});
const PickersCalendarDayHeader = styled$1("div", {
  name: "MuiDayCalendar",
  slot: "Header",
  overridesResolver: (_2, styles2) => styles2.header
})({
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
const PickersCalendarWeekDayLabel = styled$1(Typography$1, {
  name: "MuiDayCalendar",
  slot: "WeekDayLabel",
  overridesResolver: (_2, styles2) => styles2.weekDayLabel
})(({
  theme: theme2
}) => ({
  width: 36,
  height: 40,
  margin: "0 2px",
  textAlign: "center",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: (theme2.vars || theme2).palette.text.secondary
}));
const PickersCalendarWeekNumberLabel = styled$1(Typography$1, {
  name: "MuiDayPicker",
  slot: "WeekNumberLabel",
  overridesResolver: (_2, styles2) => styles2.weekNumberLabel
})(({
  theme: theme2
}) => ({
  width: 36,
  height: 40,
  margin: "0 2px",
  textAlign: "center",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: theme2.palette.text.disabled
}));
const PickersCalendarWeekNumber = styled$1(Typography$1, {
  name: "MuiDayPicker",
  slot: "WeekNumber",
  overridesResolver: (_2, styles2) => styles2.weekNumber
})(({
  theme: theme2
}) => _extends$2({}, theme2.typography.caption, {
  width: DAY_SIZE,
  height: DAY_SIZE,
  padding: 0,
  margin: `0 ${DAY_MARGIN}px`,
  color: theme2.palette.text.disabled,
  fontSize: "0.75rem",
  alignItems: "center",
  justifyContent: "center",
  display: "inline-flex"
}));
const PickersCalendarLoadingContainer = styled$1("div", {
  name: "MuiDayCalendar",
  slot: "LoadingContainer",
  overridesResolver: (_2, styles2) => styles2.loadingContainer
})({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  minHeight: weeksContainerHeight
});
const PickersCalendarSlideTransition = styled$1(PickersSlideTransition, {
  name: "MuiDayCalendar",
  slot: "SlideTransition",
  overridesResolver: (_2, styles2) => styles2.slideTransition
})({
  minHeight: weeksContainerHeight
});
const PickersCalendarWeekContainer = styled$1("div", {
  name: "MuiDayCalendar",
  slot: "MonthContainer",
  overridesResolver: (_2, styles2) => styles2.monthContainer
})({
  overflow: "hidden"
});
const PickersCalendarWeek = styled$1("div", {
  name: "MuiDayCalendar",
  slot: "WeekContainer",
  overridesResolver: (_2, styles2) => styles2.weekContainer
})({
  margin: `${DAY_MARGIN}px 0`,
  display: "flex",
  justifyContent: "center"
});
function WrappedDay(_ref) {
  var _ref2, _slots$day, _slotProps$day;
  let {
    parentProps,
    day,
    focusableDay,
    selectedDays,
    isDateDisabled,
    currentMonthNumber,
    isViewFocused
  } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded$b);
  const {
    disabled,
    disableHighlightToday,
    isMonthSwitchingAnimating,
    showDaysOutsideCurrentMonth,
    components,
    componentsProps,
    slots,
    slotProps,
    timezone
  } = parentProps;
  const utils2 = useUtils();
  const now2 = useNow(timezone);
  const isFocusableDay = focusableDay !== null && utils2.isSameDay(day, focusableDay);
  const isSelected = selectedDays.some((selectedDay) => utils2.isSameDay(selectedDay, day));
  const isToday = utils2.isSameDay(day, now2);
  const Day = (_ref2 = (_slots$day = slots == null ? void 0 : slots.day) != null ? _slots$day : components == null ? void 0 : components.Day) != null ? _ref2 : PickersDay2;
  const _useSlotProps = useSlotProps({
    elementType: Day,
    externalSlotProps: (_slotProps$day = slotProps == null ? void 0 : slotProps.day) != null ? _slotProps$day : componentsProps == null ? void 0 : componentsProps.day,
    additionalProps: _extends$2({
      disableHighlightToday,
      showDaysOutsideCurrentMonth,
      role: "gridcell",
      isAnimating: isMonthSwitchingAnimating,
      // it is used in date range dragging logic by accessing `dataset.timestamp`
      "data-timestamp": utils2.toJsDate(day).valueOf()
    }, other),
    ownerState: _extends$2({}, parentProps, {
      day,
      selected: isSelected
    })
  }), dayProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2$3);
  const isDisabled = reactExports.useMemo(() => disabled || isDateDisabled(day), [disabled, isDateDisabled, day]);
  const outsideCurrentMonth = reactExports.useMemo(() => utils2.getMonth(day) !== currentMonthNumber, [utils2, day, currentMonthNumber]);
  const isFirstVisibleCell = reactExports.useMemo(() => {
    const startOfMonth = utils2.startOfMonth(utils2.setMonth(day, currentMonthNumber));
    if (!showDaysOutsideCurrentMonth) {
      return utils2.isSameDay(day, startOfMonth);
    }
    return utils2.isSameDay(day, utils2.startOfWeek(startOfMonth));
  }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils2]);
  const isLastVisibleCell = reactExports.useMemo(() => {
    const endOfMonth = utils2.endOfMonth(utils2.setMonth(day, currentMonthNumber));
    if (!showDaysOutsideCurrentMonth) {
      return utils2.isSameDay(day, endOfMonth);
    }
    return utils2.isSameDay(day, utils2.endOfWeek(endOfMonth));
  }, [currentMonthNumber, day, showDaysOutsideCurrentMonth, utils2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Day, _extends$2({}, dayProps, {
    day,
    disabled: isDisabled,
    autoFocus: isViewFocused && isFocusableDay,
    today: isToday,
    outsideCurrentMonth,
    isFirstVisibleCell,
    isLastVisibleCell,
    selected: isSelected,
    tabIndex: isFocusableDay ? 0 : -1,
    "aria-selected": isSelected,
    "aria-current": isToday ? "date" : void 0
  }));
}
function DayCalendar(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDayCalendar"
  });
  const {
    onFocusedDayChange,
    className,
    currentMonth,
    selectedDays,
    focusedDay,
    loading,
    onSelectedDaysChange,
    onMonthSwitchingAnimationEnd,
    readOnly,
    reduceAnimations,
    renderLoading = () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      children: "..."
    }),
    slideDirection,
    TransitionProps,
    disablePast,
    disableFuture,
    minDate,
    maxDate,
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    dayOfWeekFormatter: dayOfWeekFormatterFromProps,
    hasFocus,
    onFocusedViewChange,
    gridLabelId,
    displayWeekNumber,
    fixedWeekNumber,
    autoFocus,
    timezone
  } = props;
  const now2 = useNow(timezone);
  const utils2 = useUtils();
  const classes = useUtilityClasses$7(props);
  const theme2 = useTheme();
  const isRTL = theme2.direction === "rtl";
  const dayOfWeekFormatter = dayOfWeekFormatterFromProps || ((_day, date2) => utils2.format(date2, "weekdayShort").charAt(0).toUpperCase());
  const isDateDisabled = useIsDateDisabled({
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    minDate,
    maxDate,
    disablePast,
    disableFuture,
    timezone
  });
  const localeText = useLocaleText();
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: "DayCalendar",
    state: "hasFocus",
    controlled: hasFocus,
    default: autoFocus != null ? autoFocus : false
  });
  const [internalFocusedDay, setInternalFocusedDay] = reactExports.useState(() => focusedDay || now2);
  const handleDaySelect = useEventCallback$1((day) => {
    if (readOnly) {
      return;
    }
    onSelectedDaysChange(day);
  });
  const focusDay = (day) => {
    if (!isDateDisabled(day)) {
      onFocusedDayChange(day);
      setInternalFocusedDay(day);
      onFocusedViewChange == null || onFocusedViewChange(true);
      setInternalHasFocus(true);
    }
  };
  const handleKeyDown2 = useEventCallback$1((event, day) => {
    switch (event.key) {
      case "ArrowUp":
        focusDay(utils2.addDays(day, -7));
        event.preventDefault();
        break;
      case "ArrowDown":
        focusDay(utils2.addDays(day, 7));
        event.preventDefault();
        break;
      case "ArrowLeft": {
        const newFocusedDayDefault = utils2.addDays(day, isRTL ? 1 : -1);
        const nextAvailableMonth = utils2.addMonths(day, isRTL ? 1 : -1);
        const closestDayToFocus = findClosestEnabledDate({
          utils: utils2,
          date: newFocusedDayDefault,
          minDate: isRTL ? newFocusedDayDefault : utils2.startOfMonth(nextAvailableMonth),
          maxDate: isRTL ? utils2.endOfMonth(nextAvailableMonth) : newFocusedDayDefault,
          isDateDisabled,
          timezone
        });
        focusDay(closestDayToFocus || newFocusedDayDefault);
        event.preventDefault();
        break;
      }
      case "ArrowRight": {
        const newFocusedDayDefault = utils2.addDays(day, isRTL ? -1 : 1);
        const nextAvailableMonth = utils2.addMonths(day, isRTL ? -1 : 1);
        const closestDayToFocus = findClosestEnabledDate({
          utils: utils2,
          date: newFocusedDayDefault,
          minDate: isRTL ? utils2.startOfMonth(nextAvailableMonth) : newFocusedDayDefault,
          maxDate: isRTL ? newFocusedDayDefault : utils2.endOfMonth(nextAvailableMonth),
          isDateDisabled,
          timezone
        });
        focusDay(closestDayToFocus || newFocusedDayDefault);
        event.preventDefault();
        break;
      }
      case "Home":
        focusDay(utils2.startOfWeek(day));
        event.preventDefault();
        break;
      case "End":
        focusDay(utils2.endOfWeek(day));
        event.preventDefault();
        break;
      case "PageUp":
        focusDay(utils2.addMonths(day, 1));
        event.preventDefault();
        break;
      case "PageDown":
        focusDay(utils2.addMonths(day, -1));
        event.preventDefault();
        break;
    }
  });
  const handleFocus = useEventCallback$1((event, day) => focusDay(day));
  const handleBlur = useEventCallback$1((event, day) => {
    if (internalHasFocus && utils2.isSameDay(internalFocusedDay, day)) {
      onFocusedViewChange == null || onFocusedViewChange(false);
    }
  });
  const currentMonthNumber = utils2.getMonth(currentMonth);
  const validSelectedDays = reactExports.useMemo(() => selectedDays.filter((day) => !!day).map((day) => utils2.startOfDay(day)), [utils2, selectedDays]);
  const transitionKey = currentMonthNumber;
  const slideNodeRef = reactExports.useMemo(() => /* @__PURE__ */ reactExports.createRef(), [transitionKey]);
  const startOfCurrentWeek = utils2.startOfWeek(now2);
  const focusableDay = reactExports.useMemo(() => {
    const startOfMonth = utils2.startOfMonth(currentMonth);
    const endOfMonth = utils2.endOfMonth(currentMonth);
    if (isDateDisabled(internalFocusedDay) || utils2.isAfterDay(internalFocusedDay, endOfMonth) || utils2.isBeforeDay(internalFocusedDay, startOfMonth)) {
      return findClosestEnabledDate({
        utils: utils2,
        date: internalFocusedDay,
        minDate: startOfMonth,
        maxDate: endOfMonth,
        disablePast,
        disableFuture,
        isDateDisabled,
        timezone
      });
    }
    return internalFocusedDay;
  }, [currentMonth, disableFuture, disablePast, internalFocusedDay, isDateDisabled, utils2, timezone]);
  const weeksToDisplay = reactExports.useMemo(() => {
    const currentMonthWithTimezone = utils2.setTimezone(currentMonth, timezone);
    const toDisplay = utils2.getWeekArray(currentMonthWithTimezone);
    let nextMonth = utils2.addMonths(currentMonthWithTimezone, 1);
    while (fixedWeekNumber && toDisplay.length < fixedWeekNumber) {
      const additionalWeeks = utils2.getWeekArray(nextMonth);
      const hasCommonWeek = utils2.isSameDay(toDisplay[toDisplay.length - 1][0], additionalWeeks[0][0]);
      additionalWeeks.slice(hasCommonWeek ? 1 : 0).forEach((week) => {
        if (toDisplay.length < fixedWeekNumber) {
          toDisplay.push(week);
        }
      });
      nextMonth = utils2.addMonths(nextMonth, 1);
    }
    return toDisplay;
  }, [currentMonth, fixedWeekNumber, utils2, timezone]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarDayRoot, {
    role: "grid",
    "aria-labelledby": gridLabelId,
    className: classes.root,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarDayHeader, {
      role: "row",
      className: classes.header,
      children: [displayWeekNumber && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekNumberLabel, {
        variant: "caption",
        role: "columnheader",
        "aria-label": localeText.calendarWeekNumberHeaderLabel,
        className: classes.weekNumberLabel,
        children: localeText.calendarWeekNumberHeaderText
      }), getWeekdays(utils2, now2).map((weekday, i2) => {
        var _dayOfWeekFormatter;
        const day = utils2.format(weekday, "weekdayShort").slice(0, 2);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekDayLabel, {
          variant: "caption",
          role: "columnheader",
          "aria-label": utils2.format(utils2.addDays(startOfCurrentWeek, i2), "weekday"),
          className: classes.weekDayLabel,
          children: (_dayOfWeekFormatter = dayOfWeekFormatter == null ? void 0 : dayOfWeekFormatter(day, weekday)) != null ? _dayOfWeekFormatter : day
        }, day + i2.toString());
      })]
    }), loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarLoadingContainer, {
      className: classes.loadingContainer,
      children: renderLoading()
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarSlideTransition, _extends$2({
      transKey: transitionKey,
      onExited: onMonthSwitchingAnimationEnd,
      reduceAnimations,
      slideDirection,
      className: clsx(className, classes.slideTransition)
    }, TransitionProps, {
      nodeRef: slideNodeRef,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekContainer, {
        ref: slideNodeRef,
        role: "rowgroup",
        className: classes.monthContainer,
        children: weeksToDisplay.map((week, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarWeek, {
          role: "row",
          className: classes.weekContainer,
          "aria-rowindex": index2 + 1,
          children: [displayWeekNumber && /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarWeekNumber, {
            className: classes.weekNumber,
            role: "rowheader",
            "aria-label": localeText.calendarWeekNumberAriaLabelText(utils2.getWeekNumber(week[0])),
            children: localeText.calendarWeekNumberText(utils2.getWeekNumber(week[0]))
          }), week.map((day, dayIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedDay, {
            parentProps: props,
            day,
            selectedDays: validSelectedDays,
            focusableDay,
            onKeyDown: handleKeyDown2,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onDaySelect: handleDaySelect,
            isDateDisabled,
            currentMonthNumber,
            isViewFocused: internalHasFocus,
            "aria-colindex": dayIndex + 1
          }, day.toString()))]
        }, `week-${week[0]}`))
      })
    }))]
  });
}
const createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils2) => (state, action) => {
  switch (action.type) {
    case "changeMonth":
      return _extends$2({}, state, {
        slideDirection: action.direction,
        currentMonth: action.newMonth,
        isMonthSwitchingAnimating: !reduceAnimations
      });
    case "finishMonthSwitchingAnimation":
      return _extends$2({}, state, {
        isMonthSwitchingAnimating: false
      });
    case "changeFocusedDay": {
      if (state.focusedDay != null && action.focusedDay != null && utils2.isSameDay(action.focusedDay, state.focusedDay)) {
        return state;
      }
      const needMonthSwitch = action.focusedDay != null && !disableSwitchToMonthOnDayFocus && !utils2.isSameMonth(state.currentMonth, action.focusedDay);
      return _extends$2({}, state, {
        focusedDay: action.focusedDay,
        isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations && !action.withoutMonthSwitchingAnimation,
        currentMonth: needMonthSwitch ? utils2.startOfMonth(action.focusedDay) : state.currentMonth,
        slideDirection: action.focusedDay != null && utils2.isAfterDay(action.focusedDay, state.currentMonth) ? "left" : "right"
      });
    }
    default:
      throw new Error("missing support");
  }
};
const useCalendarState = (params) => {
  const {
    value,
    referenceDate: referenceDateProp,
    defaultCalendarMonth,
    disableFuture,
    disablePast,
    disableSwitchToMonthOnDayFocus = false,
    maxDate,
    minDate,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate,
    timezone
  } = params;
  const now2 = useNow(timezone);
  const utils2 = useUtils();
  const reducerFn = reactExports.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils2)).current;
  const referenceDate = reactExports.useMemo(
    () => {
      let externalReferenceDate = null;
      if (referenceDateProp) {
        externalReferenceDate = referenceDateProp;
      } else if (defaultCalendarMonth) {
        externalReferenceDate = utils2.startOfMonth(defaultCalendarMonth);
      }
      return singleItemValueManager.getInitialReferenceValue({
        value,
        utils: utils2,
        timezone,
        props: params,
        referenceDate: externalReferenceDate,
        granularity: SECTION_TYPE_GRANULARITY.day
      });
    },
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const [calendarState, dispatch] = reactExports.useReducer(reducerFn, {
    isMonthSwitchingAnimating: false,
    focusedDay: value || now2,
    currentMonth: utils2.startOfMonth(referenceDate),
    slideDirection: "left"
  });
  const handleChangeMonth = reactExports.useCallback((payload) => {
    dispatch(_extends$2({
      type: "changeMonth"
    }, payload));
    if (onMonthChange) {
      onMonthChange(payload.newMonth);
    }
  }, [onMonthChange]);
  const changeMonth = reactExports.useCallback((newDate) => {
    const newDateRequested = newDate;
    if (utils2.isSameMonth(newDateRequested, calendarState.currentMonth)) {
      return;
    }
    handleChangeMonth({
      newMonth: utils2.startOfMonth(newDateRequested),
      direction: utils2.isAfterDay(newDateRequested, calendarState.currentMonth) ? "left" : "right"
    });
  }, [calendarState.currentMonth, handleChangeMonth, utils2]);
  const isDateDisabled = useIsDateDisabled({
    shouldDisableDate,
    minDate,
    maxDate,
    disableFuture,
    disablePast,
    timezone
  });
  const onMonthSwitchingAnimationEnd = reactExports.useCallback(() => {
    dispatch({
      type: "finishMonthSwitchingAnimation"
    });
  }, []);
  const changeFocusedDay = useEventCallback$1((newFocusedDate, withoutMonthSwitchingAnimation) => {
    if (!isDateDisabled(newFocusedDate)) {
      dispatch({
        type: "changeFocusedDay",
        focusedDay: newFocusedDate,
        withoutMonthSwitchingAnimation
      });
    }
  });
  return {
    referenceDate,
    calendarState,
    changeMonth,
    changeFocusedDay,
    isDateDisabled,
    onMonthSwitchingAnimationEnd,
    handleChangeMonth
  };
};
const _excluded$a = ["props", "getOpenDialogAriaText"], _excluded2$2 = ["ownerState"], _excluded3$1 = ["ownerState"];
const useDesktopPicker = (_ref) => {
  var _innerSlotProps$toolb, _innerSlotProps$toolb2, _slots$inputAdornment, _slots$openPickerButt, _slots$layout;
  let {
    props,
    getOpenDialogAriaText
  } = _ref, pickerParams = _objectWithoutPropertiesLoose$1(_ref, _excluded$a);
  const {
    slots,
    slotProps: innerSlotProps,
    className,
    sx,
    format: format2,
    formatDensity,
    timezone,
    label,
    inputRef,
    readOnly,
    disabled,
    autoFocus,
    localeText,
    reduceAnimations
  } = props;
  const utils2 = useUtils();
  const internalInputRef = reactExports.useRef(null);
  const containerRef = reactExports.useRef(null);
  const labelId = useId();
  const isToolbarHidden = (_innerSlotProps$toolb = innerSlotProps == null || (_innerSlotProps$toolb2 = innerSlotProps.toolbar) == null ? void 0 : _innerSlotProps$toolb2.hidden) != null ? _innerSlotProps$toolb : false;
  const {
    open: open2,
    actions,
    hasUIView,
    layoutProps,
    renderCurrentView,
    shouldRestoreFocus,
    fieldProps: pickerFieldProps
  } = usePicker(_extends$2({}, pickerParams, {
    props,
    inputRef: internalInputRef,
    autoFocusView: true,
    additionalViewProps: {},
    wrapperVariant: "desktop"
  }));
  const InputAdornment3 = (_slots$inputAdornment = slots.inputAdornment) != null ? _slots$inputAdornment : InputAdornment$1;
  const _useSlotProps = useSlotProps({
    elementType: InputAdornment3,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.inputAdornment,
    additionalProps: {
      position: "end"
    },
    ownerState: props
  }), inputAdornmentProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2$2);
  const OpenPickerButton = (_slots$openPickerButt = slots.openPickerButton) != null ? _slots$openPickerButt : IconButton$1;
  const _useSlotProps2 = useSlotProps({
    elementType: OpenPickerButton,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.openPickerButton,
    additionalProps: {
      disabled: disabled || readOnly,
      onClick: open2 ? actions.onClose : actions.onOpen,
      "aria-label": getOpenDialogAriaText(pickerFieldProps.value, utils2),
      edge: inputAdornmentProps.position
    },
    ownerState: props
  }), openPickerButtonProps = _objectWithoutPropertiesLoose$1(_useSlotProps2, _excluded3$1);
  const OpenPickerIcon = slots.openPickerIcon;
  const Field = slots.field;
  const fieldProps = useSlotProps({
    elementType: Field,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
    additionalProps: _extends$2({}, pickerFieldProps, isToolbarHidden && {
      id: labelId
    }, {
      readOnly,
      disabled,
      className,
      sx,
      format: format2,
      formatDensity,
      timezone,
      label,
      autoFocus: autoFocus && !props.open,
      focused: open2 ? true : void 0
    }),
    ownerState: props
  });
  if (hasUIView) {
    fieldProps.InputProps = _extends$2({}, fieldProps.InputProps, {
      ref: containerRef,
      [`${inputAdornmentProps.position}Adornment`]: /* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment3, _extends$2({}, inputAdornmentProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenPickerButton, _extends$2({}, openPickerButtonProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(OpenPickerIcon, _extends$2({}, innerSlotProps == null ? void 0 : innerSlotProps.openPickerIcon))
        }))
      }))
    });
  }
  const slotsForField = _extends$2({
    textField: slots.textField,
    clearIcon: slots.clearIcon,
    clearButton: slots.clearButton
  }, fieldProps.slots);
  const Layout = (_slots$layout = slots.layout) != null ? _slots$layout : PickersLayout;
  const handleInputRef = useForkRef(internalInputRef, fieldProps.inputRef, inputRef);
  let labelledById = labelId;
  if (isToolbarHidden) {
    if (label) {
      labelledById = `${labelId}-label`;
    } else {
      labelledById = void 0;
    }
  }
  const slotProps = _extends$2({}, innerSlotProps, {
    toolbar: _extends$2({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
      titleId: labelId
    }),
    popper: _extends$2({
      "aria-labelledby": labelledById
    }, innerSlotProps == null ? void 0 : innerSlotProps.popper)
  });
  const renderPicker = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(LocalizationProvider, {
    localeText,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Field, _extends$2({}, fieldProps, {
      slots: slotsForField,
      slotProps,
      inputRef: handleInputRef
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersPopper, _extends$2({
      role: "dialog",
      placement: "bottom-start",
      anchorEl: containerRef.current
    }, actions, {
      open: open2,
      slots,
      slotProps,
      shouldRestoreFocus,
      reduceAnimations,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, _extends$2({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};
const useDefaultizedDateField = (props) => {
  var _props$disablePast, _props$disableFuture, _props$format;
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  return _extends$2({}, props, {
    disablePast: (_props$disablePast = props.disablePast) != null ? _props$disablePast : false,
    disableFuture: (_props$disableFuture = props.disableFuture) != null ? _props$disableFuture : false,
    format: (_props$format = props.format) != null ? _props$format : utils2.formats.keyboardDate,
    minDate: applyDefaultDate(utils2, props.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, props.maxDate, defaultDates.maxDate)
  });
};
const useDateField = ({
  props: inProps,
  inputRef
}) => {
  const props = useDefaultizedDateField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "date");
  return useField({
    inputRef,
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateDate,
    valueType: "date"
  });
};
const _excluded$9 = ["ownerState"];
const useClearableField = ({
  clearable,
  fieldProps: forwardedFieldProps,
  InputProps: ForwardedInputProps,
  onClear,
  slots,
  slotProps,
  components,
  componentsProps
}) => {
  var _ref, _slots$clearButton, _slotProps$clearButto, _ref2, _slots$clearIcon, _slotProps$clearIcon;
  const localeText = useLocaleText();
  const IconButton3 = (_ref = (_slots$clearButton = slots == null ? void 0 : slots.clearButton) != null ? _slots$clearButton : components == null ? void 0 : components.ClearButton) != null ? _ref : IconButton$1;
  const _useSlotProps = useSlotProps({
    elementType: IconButton3,
    externalSlotProps: (_slotProps$clearButto = slotProps == null ? void 0 : slotProps.clearButton) != null ? _slotProps$clearButto : componentsProps == null ? void 0 : componentsProps.clearButton,
    ownerState: {},
    className: "clearButton",
    additionalProps: {
      title: localeText.fieldClearLabel
    }
  }), iconButtonProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded$9);
  const EndClearIcon = (_ref2 = (_slots$clearIcon = slots == null ? void 0 : slots.clearIcon) != null ? _slots$clearIcon : components == null ? void 0 : components.ClearIcon) != null ? _ref2 : ClearIcon;
  const endClearIconProps = useSlotProps({
    elementType: EndClearIcon,
    externalSlotProps: (_slotProps$clearIcon = slotProps == null ? void 0 : slotProps.clearIcon) != null ? _slotProps$clearIcon : componentsProps == null ? void 0 : componentsProps.clearIcon,
    ownerState: {}
  });
  const InputProps = _extends$2({}, ForwardedInputProps, {
    endAdornment: clearable ? /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(InputAdornment$1, {
        position: "end",
        sx: {
          marginRight: ForwardedInputProps != null && ForwardedInputProps.endAdornment ? -1 : -1.5
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton3, _extends$2({}, iconButtonProps, {
          onClick: onClear,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(EndClearIcon, _extends$2({
            fontSize: "small"
          }, endClearIconProps))
        }))
      }), ForwardedInputProps == null ? void 0 : ForwardedInputProps.endAdornment]
    }) : ForwardedInputProps == null ? void 0 : ForwardedInputProps.endAdornment
  });
  const fieldProps = _extends$2({}, forwardedFieldProps, {
    sx: [{
      "& .clearButton": {
        opacity: 1
      },
      "@media (pointer: fine)": {
        "& .clearButton": {
          opacity: 0
        },
        "&:hover, &:focus-within": {
          ".clearButton": {
            opacity: 1
          }
        }
      }
    }, ...Array.isArray(forwardedFieldProps.sx) ? forwardedFieldProps.sx : [forwardedFieldProps.sx]]
  });
  return {
    InputProps,
    fieldProps
  };
};
const _excluded$8 = ["components", "componentsProps", "slots", "slotProps", "InputProps", "inputProps"], _excluded2$1 = ["inputRef"], _excluded3 = ["ref", "onPaste", "onKeyDown", "inputMode", "readOnly", "clearable", "onClear"];
const DateField = /* @__PURE__ */ reactExports.forwardRef(function DateField2(inProps, ref) {
  var _ref, _slots$textField, _slotProps$textField;
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiDateField"
  });
  const {
    components,
    componentsProps,
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose$1(themeProps, _excluded$8);
  const ownerState = themeProps;
  const TextField3 = (_ref = (_slots$textField = slots == null ? void 0 : slots.textField) != null ? _slots$textField : components == null ? void 0 : components.TextField) != null ? _ref : TextField$1;
  const _useSlotProps = useSlotProps({
    elementType: TextField3,
    externalSlotProps: (_slotProps$textField = slotProps == null ? void 0 : slotProps.textField) != null ? _slotProps$textField : componentsProps == null ? void 0 : componentsProps.textField,
    externalForwardedProps: other,
    ownerState
  }), {
    inputRef: externalInputRef
  } = _useSlotProps, textFieldProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2$1);
  textFieldProps.inputProps = _extends$2({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends$2({}, InputProps, textFieldProps.InputProps);
  const _useDateField = useDateField({
    props: textFieldProps,
    inputRef: externalInputRef
  }), {
    ref: inputRef,
    onPaste,
    onKeyDown,
    inputMode,
    readOnly,
    clearable,
    onClear
  } = _useDateField, fieldProps = _objectWithoutPropertiesLoose$1(_useDateField, _excluded3);
  const {
    InputProps: ProcessedInputProps,
    fieldProps: processedFieldProps
  } = useClearableField({
    onClear,
    clearable,
    fieldProps,
    InputProps: fieldProps.InputProps,
    slots,
    slotProps,
    components,
    componentsProps
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TextField3, _extends$2({
    ref
  }, processedFieldProps, {
    InputProps: _extends$2({}, ProcessedInputProps, {
      readOnly
    }),
    inputProps: _extends$2({}, fieldProps.inputProps, {
      inputMode,
      onPaste,
      onKeyDown,
      ref: inputRef
    })
  }));
});
const getPickersFadeTransitionGroupUtilityClass = (slot) => generateUtilityClass("MuiPickersFadeTransitionGroup", slot);
generateUtilityClasses("MuiPickersFadeTransitionGroup", ["root"]);
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPickersFadeTransitionGroupUtilityClass, classes);
};
const animationDuration = 500;
const PickersFadeTransitionGroupRoot = styled$1(TransitionGroup$1, {
  name: "MuiPickersFadeTransitionGroup",
  slot: "Root",
  overridesResolver: (_2, styles2) => styles2.root
})({
  display: "block",
  position: "relative"
});
function PickersFadeTransitionGroup(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersFadeTransitionGroup"
  });
  const {
    children,
    className,
    reduceAnimations,
    transKey
  } = props;
  const classes = useUtilityClasses$6(props);
  if (reduceAnimations) {
    return children;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersFadeTransitionGroupRoot, {
    className: clsx(classes.root, className),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Fade$1, {
      appear: false,
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: {
        appear: animationDuration,
        enter: animationDuration / 2,
        exit: 0
      },
      children
    }, transKey)
  });
}
function getPickersMonthUtilityClass(slot) {
  return generateUtilityClass("MuiPickersMonth", slot);
}
const pickersMonthClasses = generateUtilityClasses("MuiPickersMonth", ["root", "monthButton", "disabled", "selected"]);
const _excluded$7 = ["autoFocus", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "aria-label", "monthsPerRow"];
const useUtilityClasses$5 = (ownerState) => {
  const {
    disabled,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    monthButton: ["monthButton", disabled && "disabled", selected && "selected"]
  };
  return composeClasses(slots, getPickersMonthUtilityClass, classes);
};
const PickersMonthRoot = styled$1("div", {
  name: "MuiPickersMonth",
  slot: "Root",
  overridesResolver: (_2, styles2) => [styles2.root]
})(({
  ownerState
}) => ({
  flexBasis: ownerState.monthsPerRow === 3 ? "33.3%" : "25%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
}));
const PickersMonthButton = styled$1("button", {
  name: "MuiPickersMonth",
  slot: "MonthButton",
  overridesResolver: (_2, styles2) => [styles2.monthButton, {
    [`&.${pickersMonthClasses.disabled}`]: styles2.disabled
  }, {
    [`&.${pickersMonthClasses.selected}`]: styles2.selected
  }]
})(({
  theme: theme2
}) => _extends$2({
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, theme2.typography.subtitle1, {
  margin: "8px 0",
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.action.active, theme2.palette.action.hoverOpacity)
  },
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.action.active, theme2.palette.action.hoverOpacity)
  },
  "&:disabled": {
    cursor: "auto",
    pointerEvents: "none"
  },
  [`&.${pickersMonthClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.secondary
  },
  [`&.${pickersMonthClasses.selected}`]: {
    color: (theme2.vars || theme2).palette.primary.contrastText,
    backgroundColor: (theme2.vars || theme2).palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    }
  }
}));
const PickersMonth = /* @__PURE__ */ reactExports.memo(function PickersMonth2(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersMonth"
  });
  const {
    autoFocus,
    children,
    disabled,
    selected,
    value,
    tabIndex,
    onClick,
    onKeyDown,
    onFocus,
    onBlur,
    "aria-current": ariaCurrent,
    "aria-label": ariaLabel
    // We don't want to forward this prop to the root element
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$7);
  const ref = reactExports.useRef(null);
  const classes = useUtilityClasses$5(props);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      var _ref$current;
      (_ref$current = ref.current) == null || _ref$current.focus();
    }
  }, [autoFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonthRoot, _extends$2({
    className: classes.root,
    ownerState: props
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonthButton, {
      ref,
      disabled,
      type: "button",
      role: "radio",
      tabIndex: disabled ? -1 : tabIndex,
      "aria-current": ariaCurrent,
      "aria-checked": selected,
      "aria-label": ariaLabel,
      onClick: (event) => onClick(event, value),
      onKeyDown: (event) => onKeyDown(event, value),
      onFocus: (event) => onFocus(event, value),
      onBlur: (event) => onBlur(event, value),
      className: classes.monthButton,
      ownerState: props,
      children
    })
  }));
});
function getMonthCalendarUtilityClass(slot) {
  return generateUtilityClass("MuiMonthCalendar", slot);
}
generateUtilityClasses("MuiMonthCalendar", ["root"]);
const _excluded$6 = ["className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "shouldDisableMonth", "readOnly", "disableHighlightToday", "autoFocus", "onMonthFocus", "hasFocus", "onFocusedViewChange", "monthsPerRow", "timezone", "gridLabelId"];
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getMonthCalendarUtilityClass, classes);
};
function useMonthCalendarDefaultizedProps(props, name) {
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends$2({
    disableFuture: false,
    disablePast: false
  }, themeProps, {
    minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
  });
}
const MonthCalendarRoot = styled$1("div", {
  name: "MuiMonthCalendar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "flex",
  flexWrap: "wrap",
  alignContent: "stretch",
  padding: "0 4px",
  width: 320
});
const MonthCalendar = /* @__PURE__ */ reactExports.forwardRef(function MonthCalendar2(inProps, ref) {
  const props = useMonthCalendarDefaultizedProps(inProps, "MuiMonthCalendar");
  const {
    className,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onChange,
    shouldDisableMonth,
    readOnly,
    disableHighlightToday,
    autoFocus = false,
    onMonthFocus,
    hasFocus,
    onFocusedViewChange,
    monthsPerRow = 3,
    timezone: timezoneProp,
    gridLabelId
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$6);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "MonthCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const now2 = useNow(timezone);
  const theme2 = useTheme$2();
  const utils2 = useUtils();
  const referenceDate = reactExports.useMemo(
    () => singleItemValueManager.getInitialReferenceValue({
      value,
      utils: utils2,
      props,
      timezone,
      referenceDate: referenceDateProp,
      granularity: SECTION_TYPE_GRANULARITY.month
    }),
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const ownerState = props;
  const classes = useUtilityClasses$4(ownerState);
  const todayMonth = reactExports.useMemo(() => utils2.getMonth(now2), [utils2, now2]);
  const selectedMonth = reactExports.useMemo(() => {
    if (value != null) {
      return utils2.getMonth(value);
    }
    if (disableHighlightToday) {
      return null;
    }
    return utils2.getMonth(referenceDate);
  }, [value, utils2, disableHighlightToday, referenceDate]);
  const [focusedMonth, setFocusedMonth] = reactExports.useState(() => selectedMonth || todayMonth);
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: "MonthCalendar",
    state: "hasFocus",
    controlled: hasFocus,
    default: autoFocus != null ? autoFocus : false
  });
  const changeHasFocus = useEventCallback$1((newHasFocus) => {
    setInternalHasFocus(newHasFocus);
    if (onFocusedViewChange) {
      onFocusedViewChange(newHasFocus);
    }
  });
  const isMonthDisabled = reactExports.useCallback((dateToValidate) => {
    const firstEnabledMonth = utils2.startOfMonth(disablePast && utils2.isAfter(now2, minDate) ? now2 : minDate);
    const lastEnabledMonth = utils2.startOfMonth(disableFuture && utils2.isBefore(now2, maxDate) ? now2 : maxDate);
    const monthToValidate = utils2.startOfMonth(dateToValidate);
    if (utils2.isBefore(monthToValidate, firstEnabledMonth)) {
      return true;
    }
    if (utils2.isAfter(monthToValidate, lastEnabledMonth)) {
      return true;
    }
    if (!shouldDisableMonth) {
      return false;
    }
    return shouldDisableMonth(monthToValidate);
  }, [disableFuture, disablePast, maxDate, minDate, now2, shouldDisableMonth, utils2]);
  const handleMonthSelection = useEventCallback$1((event, month) => {
    if (readOnly) {
      return;
    }
    const newDate = utils2.setMonth(value != null ? value : referenceDate, month);
    handleValueChange(newDate);
  });
  const focusMonth = useEventCallback$1((month) => {
    if (!isMonthDisabled(utils2.setMonth(value != null ? value : referenceDate, month))) {
      setFocusedMonth(month);
      changeHasFocus(true);
      if (onMonthFocus) {
        onMonthFocus(month);
      }
    }
  });
  reactExports.useEffect(() => {
    setFocusedMonth((prevFocusedMonth) => selectedMonth !== null && prevFocusedMonth !== selectedMonth ? selectedMonth : prevFocusedMonth);
  }, [selectedMonth]);
  const handleKeyDown2 = useEventCallback$1((event, month) => {
    const monthsInYear = 12;
    const monthsInRow = 3;
    switch (event.key) {
      case "ArrowUp":
        focusMonth((monthsInYear + month - monthsInRow) % monthsInYear);
        event.preventDefault();
        break;
      case "ArrowDown":
        focusMonth((monthsInYear + month + monthsInRow) % monthsInYear);
        event.preventDefault();
        break;
      case "ArrowLeft":
        focusMonth((monthsInYear + month + (theme2.direction === "ltr" ? -1 : 1)) % monthsInYear);
        event.preventDefault();
        break;
      case "ArrowRight":
        focusMonth((monthsInYear + month + (theme2.direction === "ltr" ? 1 : -1)) % monthsInYear);
        event.preventDefault();
        break;
    }
  });
  const handleMonthFocus = useEventCallback$1((event, month) => {
    focusMonth(month);
  });
  const handleMonthBlur = useEventCallback$1((event, month) => {
    if (focusedMonth === month) {
      changeHasFocus(false);
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendarRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState,
    role: "radiogroup",
    "aria-labelledby": gridLabelId
  }, other, {
    children: getMonthsInYear(utils2, value != null ? value : referenceDate).map((month) => {
      const monthNumber = utils2.getMonth(month);
      const monthText = utils2.format(month, "monthShort");
      const monthLabel = utils2.format(month, "month");
      const isSelected = monthNumber === selectedMonth;
      const isDisabled = disabled || isMonthDisabled(month);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersMonth, {
        selected: isSelected,
        value: monthNumber,
        onClick: handleMonthSelection,
        onKeyDown: handleKeyDown2,
        autoFocus: internalHasFocus && monthNumber === focusedMonth,
        disabled: isDisabled,
        tabIndex: monthNumber === focusedMonth ? 0 : -1,
        onFocus: handleMonthFocus,
        onBlur: handleMonthBlur,
        "aria-current": todayMonth === monthNumber ? "date" : void 0,
        "aria-label": monthLabel,
        monthsPerRow,
        children: monthText
      }, monthText);
    })
  }));
});
function getPickersYearUtilityClass(slot) {
  return generateUtilityClass("MuiPickersYear", slot);
}
const pickersYearClasses = generateUtilityClasses("MuiPickersYear", ["root", "yearButton", "selected", "disabled"]);
const _excluded$5 = ["autoFocus", "className", "children", "disabled", "selected", "value", "tabIndex", "onClick", "onKeyDown", "onFocus", "onBlur", "aria-current", "yearsPerRow"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    disabled,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    yearButton: ["yearButton", disabled && "disabled", selected && "selected"]
  };
  return composeClasses(slots, getPickersYearUtilityClass, classes);
};
const PickersYearRoot = styled$1("div", {
  name: "MuiPickersYear",
  slot: "Root",
  overridesResolver: (_2, styles2) => [styles2.root]
})(({
  ownerState
}) => ({
  flexBasis: ownerState.yearsPerRow === 3 ? "33.3%" : "25%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
}));
const PickersYearButton = styled$1("button", {
  name: "MuiPickersYear",
  slot: "YearButton",
  overridesResolver: (_2, styles2) => [styles2.yearButton, {
    [`&.${pickersYearClasses.disabled}`]: styles2.disabled
  }, {
    [`&.${pickersYearClasses.selected}`]: styles2.selected
  }]
})(({
  theme: theme2
}) => _extends$2({
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, theme2.typography.subtitle1, {
  margin: "8px 0",
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.focusOpacity})` : alpha(theme2.palette.action.active, theme2.palette.action.focusOpacity)
  },
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.action.active, theme2.palette.action.hoverOpacity)
  },
  "&:disabled": {
    cursor: "auto",
    pointerEvents: "none"
  },
  [`&.${pickersYearClasses.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.secondary
  },
  [`&.${pickersYearClasses.selected}`]: {
    color: (theme2.vars || theme2).palette.primary.contrastText,
    backgroundColor: (theme2.vars || theme2).palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    }
  }
}));
const PickersYear = /* @__PURE__ */ reactExports.memo(function PickersYear2(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersYear"
  });
  const {
    autoFocus,
    className,
    children,
    disabled,
    selected,
    value,
    tabIndex,
    onClick,
    onKeyDown,
    onFocus,
    onBlur,
    "aria-current": ariaCurrent
    // We don't want to forward this prop to the root element
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$5);
  const ref = reactExports.useRef(null);
  const classes = useUtilityClasses$3(props);
  reactExports.useEffect(() => {
    if (autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYearRoot, _extends$2({
    className: clsx(classes.root, className),
    ownerState: props
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYearButton, {
      ref,
      disabled,
      type: "button",
      role: "radio",
      tabIndex: disabled ? -1 : tabIndex,
      "aria-current": ariaCurrent,
      "aria-checked": selected,
      onClick: (event) => onClick(event, value),
      onKeyDown: (event) => onKeyDown(event, value),
      onFocus: (event) => onFocus(event, value),
      onBlur: (event) => onBlur(event, value),
      className: classes.yearButton,
      ownerState: props,
      children
    })
  }));
});
function getYearCalendarUtilityClass(slot) {
  return generateUtilityClass("MuiYearCalendar", slot);
}
generateUtilityClasses("MuiYearCalendar", ["root"]);
const _excluded$4 = ["autoFocus", "className", "value", "defaultValue", "referenceDate", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "readOnly", "shouldDisableYear", "disableHighlightToday", "onYearFocus", "hasFocus", "onFocusedViewChange", "yearsPerRow", "timezone", "gridLabelId"];
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getYearCalendarUtilityClass, classes);
};
function useYearCalendarDefaultizedProps(props, name) {
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends$2({
    disablePast: false,
    disableFuture: false
  }, themeProps, {
    minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
  });
}
const YearCalendarRoot = styled$1("div", {
  name: "MuiYearCalendar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  overflowY: "auto",
  height: "100%",
  padding: "0 4px",
  width: 320,
  maxHeight: 304,
  // avoid padding increasing width over defined
  boxSizing: "border-box",
  position: "relative"
});
const YearCalendar = /* @__PURE__ */ reactExports.forwardRef(function YearCalendar2(inProps, ref) {
  const props = useYearCalendarDefaultizedProps(inProps, "MuiYearCalendar");
  const {
    autoFocus,
    className,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onChange,
    readOnly,
    shouldDisableYear,
    disableHighlightToday,
    onYearFocus,
    hasFocus,
    onFocusedViewChange,
    yearsPerRow = 3,
    timezone: timezoneProp,
    gridLabelId
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$4);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "YearCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const now2 = useNow(timezone);
  const theme2 = useTheme$2();
  const utils2 = useUtils();
  const referenceDate = reactExports.useMemo(
    () => singleItemValueManager.getInitialReferenceValue({
      value,
      utils: utils2,
      props,
      timezone,
      referenceDate: referenceDateProp,
      granularity: SECTION_TYPE_GRANULARITY.year
    }),
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  const ownerState = props;
  const classes = useUtilityClasses$2(ownerState);
  const todayYear = reactExports.useMemo(() => utils2.getYear(now2), [utils2, now2]);
  const selectedYear = reactExports.useMemo(() => {
    if (value != null) {
      return utils2.getYear(value);
    }
    if (disableHighlightToday) {
      return null;
    }
    return utils2.getYear(referenceDate);
  }, [value, utils2, disableHighlightToday, referenceDate]);
  const [focusedYear, setFocusedYear] = reactExports.useState(() => selectedYear || todayYear);
  const [internalHasFocus, setInternalHasFocus] = useControlled({
    name: "YearCalendar",
    state: "hasFocus",
    controlled: hasFocus,
    default: autoFocus != null ? autoFocus : false
  });
  const changeHasFocus = useEventCallback$1((newHasFocus) => {
    setInternalHasFocus(newHasFocus);
    if (onFocusedViewChange) {
      onFocusedViewChange(newHasFocus);
    }
  });
  const isYearDisabled = reactExports.useCallback((dateToValidate) => {
    if (disablePast && utils2.isBeforeYear(dateToValidate, now2)) {
      return true;
    }
    if (disableFuture && utils2.isAfterYear(dateToValidate, now2)) {
      return true;
    }
    if (minDate && utils2.isBeforeYear(dateToValidate, minDate)) {
      return true;
    }
    if (maxDate && utils2.isAfterYear(dateToValidate, maxDate)) {
      return true;
    }
    if (!shouldDisableYear) {
      return false;
    }
    const yearToValidate = utils2.startOfYear(dateToValidate);
    return shouldDisableYear(yearToValidate);
  }, [disableFuture, disablePast, maxDate, minDate, now2, shouldDisableYear, utils2]);
  const handleYearSelection = useEventCallback$1((event, year) => {
    if (readOnly) {
      return;
    }
    const newDate = utils2.setYear(value != null ? value : referenceDate, year);
    handleValueChange(newDate);
  });
  const focusYear = useEventCallback$1((year) => {
    if (!isYearDisabled(utils2.setYear(value != null ? value : referenceDate, year))) {
      setFocusedYear(year);
      changeHasFocus(true);
      onYearFocus == null || onYearFocus(year);
    }
  });
  reactExports.useEffect(() => {
    setFocusedYear((prevFocusedYear) => selectedYear !== null && prevFocusedYear !== selectedYear ? selectedYear : prevFocusedYear);
  }, [selectedYear]);
  const handleKeyDown2 = useEventCallback$1((event, year) => {
    switch (event.key) {
      case "ArrowUp":
        focusYear(year - yearsPerRow);
        event.preventDefault();
        break;
      case "ArrowDown":
        focusYear(year + yearsPerRow);
        event.preventDefault();
        break;
      case "ArrowLeft":
        focusYear(year + (theme2.direction === "ltr" ? -1 : 1));
        event.preventDefault();
        break;
      case "ArrowRight":
        focusYear(year + (theme2.direction === "ltr" ? 1 : -1));
        event.preventDefault();
        break;
    }
  });
  const handleYearFocus = useEventCallback$1((event, year) => {
    focusYear(year);
  });
  const handleYearBlur = useEventCallback$1((event, year) => {
    if (focusedYear === year) {
      changeHasFocus(false);
    }
  });
  const scrollerRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, scrollerRef);
  reactExports.useEffect(() => {
    if (autoFocus || scrollerRef.current === null) {
      return;
    }
    const tabbableButton = scrollerRef.current.querySelector('[tabindex="0"]');
    if (!tabbableButton) {
      return;
    }
    const offsetHeight = tabbableButton.offsetHeight;
    const offsetTop = tabbableButton.offsetTop;
    const clientHeight = scrollerRef.current.clientHeight;
    const scrollTop = scrollerRef.current.scrollTop;
    const elementBottom = offsetTop + offsetHeight;
    if (offsetHeight > clientHeight || offsetTop < scrollTop) {
      return;
    }
    scrollerRef.current.scrollTop = elementBottom - clientHeight / 2 - offsetHeight / 2;
  }, [autoFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendarRoot, _extends$2({
    ref: handleRef,
    className: clsx(classes.root, className),
    ownerState,
    role: "radiogroup",
    "aria-labelledby": gridLabelId
  }, other, {
    children: utils2.getYearRange(minDate, maxDate).map((year) => {
      const yearNumber = utils2.getYear(year);
      const isSelected = yearNumber === selectedYear;
      const isDisabled = disabled || isYearDisabled(year);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PickersYear, {
        selected: isSelected,
        value: yearNumber,
        onClick: handleYearSelection,
        onKeyDown: handleKeyDown2,
        autoFocus: internalHasFocus && yearNumber === focusedYear,
        disabled: isDisabled,
        tabIndex: yearNumber === focusedYear ? 0 : -1,
        onFocus: handleYearFocus,
        onBlur: handleYearBlur,
        "aria-current": todayYear === yearNumber ? "date" : void 0,
        yearsPerRow,
        children: utils2.format(year, "year")
      }, utils2.format(year, "year"));
    })
  }));
});
const getPickersCalendarHeaderUtilityClass = (slot) => generateUtilityClass("MuiPickersCalendarHeader", slot);
const pickersCalendarHeaderClasses = generateUtilityClasses("MuiPickersCalendarHeader", ["root", "labelContainer", "label", "switchViewButton", "switchViewIcon"]);
const _excluded$3 = ["slots", "slotProps", "currentMonth", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onMonthChange", "onViewChange", "view", "reduceAnimations", "views", "labelId", "className", "timezone"], _excluded2 = ["ownerState"];
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    labelContainer: ["labelContainer"],
    label: ["label"],
    switchViewButton: ["switchViewButton"],
    switchViewIcon: ["switchViewIcon"]
  };
  return composeClasses(slots, getPickersCalendarHeaderUtilityClass, classes);
};
const PickersCalendarHeaderRoot = styled$1("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Root",
  overridesResolver: (_2, styles2) => styles2.root
})({
  display: "flex",
  alignItems: "center",
  marginTop: 16,
  marginBottom: 8,
  paddingLeft: 24,
  paddingRight: 12,
  // prevent jumping in safari
  maxHeight: 30,
  minHeight: 30
});
const PickersCalendarHeaderLabelContainer = styled$1("div", {
  name: "MuiPickersCalendarHeader",
  slot: "LabelContainer",
  overridesResolver: (_2, styles2) => styles2.labelContainer
})(({
  theme: theme2
}) => _extends$2({
  display: "flex",
  overflow: "hidden",
  alignItems: "center",
  cursor: "pointer",
  marginRight: "auto"
}, theme2.typography.body1, {
  fontWeight: theme2.typography.fontWeightMedium
}));
const PickersCalendarHeaderLabel = styled$1("div", {
  name: "MuiPickersCalendarHeader",
  slot: "Label",
  overridesResolver: (_2, styles2) => styles2.label
})({
  marginRight: 6
});
const PickersCalendarHeaderSwitchViewButton = styled$1(IconButton$1, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewButton",
  overridesResolver: (_2, styles2) => styles2.switchViewButton
})(({
  ownerState
}) => _extends$2({
  marginRight: "auto"
}, ownerState.view === "year" && {
  [`.${pickersCalendarHeaderClasses.switchViewIcon}`]: {
    transform: "rotate(180deg)"
  }
}));
const PickersCalendarHeaderSwitchViewIcon = styled$1(ArrowDropDownIcon, {
  name: "MuiPickersCalendarHeader",
  slot: "SwitchViewIcon",
  overridesResolver: (_2, styles2) => styles2.switchViewIcon
})(({
  theme: theme2
}) => ({
  willChange: "transform",
  transition: theme2.transitions.create("transform"),
  transform: "rotate(0deg)"
}));
const PickersCalendarHeader = /* @__PURE__ */ reactExports.forwardRef(function PickersCalendarHeader2(inProps, ref) {
  var _slots$switchViewButt, _slots$switchViewIcon;
  const localeText = useLocaleText();
  const utils2 = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersCalendarHeader"
  });
  const {
    slots,
    slotProps,
    currentMonth: month,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onMonthChange,
    onViewChange,
    view,
    reduceAnimations,
    views,
    labelId,
    className,
    timezone
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$3);
  const ownerState = props;
  const classes = useUtilityClasses$1(props);
  const SwitchViewButton = (_slots$switchViewButt = slots == null ? void 0 : slots.switchViewButton) != null ? _slots$switchViewButt : PickersCalendarHeaderSwitchViewButton;
  const switchViewButtonProps = useSlotProps({
    elementType: SwitchViewButton,
    externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewButton,
    additionalProps: {
      size: "small",
      "aria-label": localeText.calendarViewSwitchingButtonAriaLabel(view)
    },
    ownerState,
    className: classes.switchViewButton
  });
  const SwitchViewIcon = (_slots$switchViewIcon = slots == null ? void 0 : slots.switchViewIcon) != null ? _slots$switchViewIcon : PickersCalendarHeaderSwitchViewIcon;
  const _useSlotProps = useSlotProps({
    elementType: SwitchViewIcon,
    externalSlotProps: slotProps == null ? void 0 : slotProps.switchViewIcon,
    ownerState: void 0,
    className: classes.switchViewIcon
  }), switchViewIconProps = _objectWithoutPropertiesLoose$1(_useSlotProps, _excluded2);
  const selectNextMonth = () => onMonthChange(utils2.addMonths(month, 1), "left");
  const selectPreviousMonth = () => onMonthChange(utils2.addMonths(month, -1), "right");
  const isNextMonthDisabled = useNextMonthDisabled(month, {
    disableFuture,
    maxDate,
    timezone
  });
  const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
    disablePast,
    minDate,
    timezone
  });
  const handleToggleView = () => {
    if (views.length === 1 || !onViewChange || disabled) {
      return;
    }
    if (views.length === 2) {
      onViewChange(views.find((el2) => el2 !== view) || views[0]);
    } else {
      const nextIndexToOpen = views.indexOf(view) !== 0 ? 0 : 1;
      onViewChange(views[nextIndexToOpen]);
    }
  };
  if (views.length === 1 && views[0] === "year") {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderRoot, _extends$2({}, other, {
    ownerState,
    className: clsx(className, classes.root),
    ref,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(PickersCalendarHeaderLabelContainer, {
      role: "presentation",
      onClick: handleToggleView,
      ownerState,
      "aria-live": "polite",
      className: classes.labelContainer,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(PickersFadeTransitionGroup, {
        reduceAnimations,
        transKey: utils2.format(month, "monthAndYear"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersCalendarHeaderLabel, {
          id: labelId,
          ownerState,
          className: classes.label,
          children: utils2.format(month, "monthAndYear")
        })
      }), views.length > 1 && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewButton, _extends$2({}, switchViewButtonProps, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwitchViewIcon, _extends$2({}, switchViewIconProps))
      }))]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Fade$1, {
      in: view === "day",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PickersArrowSwitcher, {
        slots,
        slotProps,
        onGoToPrevious: selectPreviousMonth,
        isPreviousDisabled: isPreviousMonthDisabled,
        previousLabel: localeText.previousMonth,
        onGoToNext: selectNextMonth,
        isNextDisabled: isNextMonthDisabled,
        nextLabel: localeText.nextMonth
      })
    })]
  }));
});
const PickerViewRoot = styled$1("div")({
  overflow: "hidden",
  width: DIALOG_WIDTH,
  maxHeight: VIEW_HEIGHT,
  display: "flex",
  flexDirection: "column",
  margin: "0 auto"
});
const getDateCalendarUtilityClass = (slot) => generateUtilityClass("MuiDateCalendar", slot);
generateUtilityClasses("MuiDateCalendar", ["root", "viewTransitionContainer"]);
const _excluded$2 = ["autoFocus", "onViewChange", "value", "defaultValue", "referenceDate", "disableFuture", "disablePast", "defaultCalendarMonth", "onChange", "onYearChange", "onMonthChange", "reduceAnimations", "shouldDisableDate", "shouldDisableMonth", "shouldDisableYear", "view", "views", "openTo", "className", "disabled", "readOnly", "minDate", "maxDate", "disableHighlightToday", "focusedView", "onFocusedViewChange", "showDaysOutsideCurrentMonth", "fixedWeekNumber", "dayOfWeekFormatter", "components", "componentsProps", "slots", "slotProps", "loading", "renderLoading", "displayWeekNumber", "yearsPerRow", "monthsPerRow", "timezone"];
const useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    viewTransitionContainer: ["viewTransitionContainer"]
  };
  return composeClasses(slots, getDateCalendarUtilityClass, classes);
};
function useDateCalendarDefaultizedProps(props, name) {
  var _themeProps$loading, _themeProps$disablePa, _themeProps$disableFu, _themeProps$openTo, _themeProps$views, _themeProps$reduceAni, _themeProps$renderLoa;
  const utils2 = useUtils();
  const defaultDates = useDefaultDates();
  const defaultReduceAnimations = useDefaultReduceAnimations();
  const themeProps = useThemeProps({
    props,
    name
  });
  return _extends$2({}, themeProps, {
    loading: (_themeProps$loading = themeProps.loading) != null ? _themeProps$loading : false,
    disablePast: (_themeProps$disablePa = themeProps.disablePast) != null ? _themeProps$disablePa : false,
    disableFuture: (_themeProps$disableFu = themeProps.disableFuture) != null ? _themeProps$disableFu : false,
    openTo: (_themeProps$openTo = themeProps.openTo) != null ? _themeProps$openTo : "day",
    views: (_themeProps$views = themeProps.views) != null ? _themeProps$views : ["year", "day"],
    reduceAnimations: (_themeProps$reduceAni = themeProps.reduceAnimations) != null ? _themeProps$reduceAni : defaultReduceAnimations,
    renderLoading: (_themeProps$renderLoa = themeProps.renderLoading) != null ? _themeProps$renderLoa : () => /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      children: "..."
    }),
    minDate: applyDefaultDate(utils2, themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils2, themeProps.maxDate, defaultDates.maxDate)
  });
}
const DateCalendarRoot = styled$1(PickerViewRoot, {
  name: "MuiDateCalendar",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "flex",
  flexDirection: "column"
});
const DateCalendarViewTransitionContainer = styled$1(PickersFadeTransitionGroup, {
  name: "MuiDateCalendar",
  slot: "ViewTransitionContainer",
  overridesResolver: (props, styles2) => styles2.viewTransitionContainer
})({});
const DateCalendar = /* @__PURE__ */ reactExports.forwardRef(function DateCalendar2(inProps, ref) {
  var _ref, _slots$calendarHeader, _slotProps$calendarHe;
  const utils2 = useUtils();
  const id2 = useId();
  const props = useDateCalendarDefaultizedProps(inProps, "MuiDateCalendar");
  const {
    autoFocus,
    onViewChange,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableFuture,
    disablePast,
    defaultCalendarMonth,
    onChange,
    onYearChange,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate,
    shouldDisableMonth,
    shouldDisableYear,
    view: inView,
    views,
    openTo,
    className,
    disabled,
    readOnly,
    minDate,
    maxDate,
    disableHighlightToday,
    focusedView: inFocusedView,
    onFocusedViewChange,
    showDaysOutsideCurrentMonth,
    fixedWeekNumber,
    dayOfWeekFormatter,
    components,
    componentsProps,
    slots,
    slotProps,
    loading,
    renderLoading,
    displayWeekNumber,
    yearsPerRow,
    monthsPerRow,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2);
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "DateCalendar",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const {
    view,
    setView,
    focusedView,
    setFocusedView,
    goToNextView,
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onChange: handleValueChange,
    onViewChange,
    autoFocus,
    focusedView: inFocusedView,
    onFocusedViewChange
  });
  const {
    referenceDate,
    calendarState,
    changeFocusedDay,
    changeMonth,
    handleChangeMonth,
    isDateDisabled,
    onMonthSwitchingAnimationEnd
  } = useCalendarState({
    value,
    defaultCalendarMonth,
    referenceDate: referenceDateProp,
    reduceAnimations,
    onMonthChange,
    minDate,
    maxDate,
    shouldDisableDate,
    disablePast,
    disableFuture,
    timezone
  });
  const minDateWithDisabled = disabled && value || minDate;
  const maxDateWithDisabled = disabled && value || maxDate;
  const gridLabelId = `${id2}-grid-label`;
  const hasFocus = focusedView !== null;
  const CalendarHeader = (_ref = (_slots$calendarHeader = slots == null ? void 0 : slots.calendarHeader) != null ? _slots$calendarHeader : components == null ? void 0 : components.CalendarHeader) != null ? _ref : PickersCalendarHeader;
  const calendarHeaderProps = useSlotProps({
    elementType: CalendarHeader,
    externalSlotProps: (_slotProps$calendarHe = slotProps == null ? void 0 : slotProps.calendarHeader) != null ? _slotProps$calendarHe : componentsProps == null ? void 0 : componentsProps.calendarHeader,
    additionalProps: {
      views,
      view,
      currentMonth: calendarState.currentMonth,
      onViewChange: setView,
      onMonthChange: (newMonth, direction2) => handleChangeMonth({
        newMonth,
        direction: direction2
      }),
      minDate: minDateWithDisabled,
      maxDate: maxDateWithDisabled,
      disabled,
      disablePast,
      disableFuture,
      reduceAnimations,
      timezone,
      labelId: gridLabelId,
      slots,
      slotProps
    },
    ownerState: props
  });
  const handleDateMonthChange = useEventCallback$1((newDate) => {
    const startOfMonth = utils2.startOfMonth(newDate);
    const endOfMonth = utils2.endOfMonth(newDate);
    const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
      utils: utils2,
      date: newDate,
      minDate: utils2.isBefore(minDate, startOfMonth) ? startOfMonth : minDate,
      maxDate: utils2.isAfter(maxDate, endOfMonth) ? endOfMonth : maxDate,
      disablePast,
      disableFuture,
      isDateDisabled,
      timezone
    }) : newDate;
    if (closestEnabledDate) {
      setValueAndGoToNextView(closestEnabledDate, "finish");
      onMonthChange == null || onMonthChange(startOfMonth);
    } else {
      goToNextView();
      changeMonth(startOfMonth);
    }
    changeFocusedDay(closestEnabledDate, true);
  });
  const handleDateYearChange = useEventCallback$1((newDate) => {
    const startOfYear = utils2.startOfYear(newDate);
    const endOfYear = utils2.endOfYear(newDate);
    const closestEnabledDate = isDateDisabled(newDate) ? findClosestEnabledDate({
      utils: utils2,
      date: newDate,
      minDate: utils2.isBefore(minDate, startOfYear) ? startOfYear : minDate,
      maxDate: utils2.isAfter(maxDate, endOfYear) ? endOfYear : maxDate,
      disablePast,
      disableFuture,
      isDateDisabled,
      timezone
    }) : newDate;
    if (closestEnabledDate) {
      setValueAndGoToNextView(closestEnabledDate, "finish");
      onYearChange == null || onYearChange(closestEnabledDate);
    } else {
      goToNextView();
      changeMonth(startOfYear);
    }
    changeFocusedDay(closestEnabledDate, true);
  });
  const handleSelectedDayChange = useEventCallback$1((day) => {
    if (day) {
      return handleValueChange(mergeDateAndTime(utils2, day, value != null ? value : referenceDate), "finish");
    }
    return handleValueChange(day, "finish");
  });
  reactExports.useEffect(() => {
    if (value != null && utils2.isValid(value)) {
      changeMonth(value);
    }
  }, [value]);
  const ownerState = props;
  const classes = useUtilityClasses(ownerState);
  const baseDateValidationProps = {
    disablePast,
    disableFuture,
    maxDate,
    minDate
  };
  const commonViewProps = {
    disableHighlightToday,
    readOnly,
    disabled,
    timezone,
    gridLabelId
  };
  const prevOpenViewRef = reactExports.useRef(view);
  reactExports.useEffect(() => {
    if (prevOpenViewRef.current === view) {
      return;
    }
    if (focusedView === prevOpenViewRef.current) {
      setFocusedView(view, true);
    }
    prevOpenViewRef.current = view;
  }, [focusedView, setFocusedView, view]);
  const selectedDays = reactExports.useMemo(() => [value], [value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DateCalendarRoot, _extends$2({
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(CalendarHeader, _extends$2({}, calendarHeaderProps)), /* @__PURE__ */ jsxRuntimeExports.jsx(DateCalendarViewTransitionContainer, {
      reduceAnimations,
      className: classes.viewTransitionContainer,
      transKey: view,
      ownerState,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        children: [view === "year" && /* @__PURE__ */ jsxRuntimeExports.jsx(YearCalendar, _extends$2({}, baseDateValidationProps, commonViewProps, {
          value,
          onChange: handleDateYearChange,
          shouldDisableYear,
          hasFocus,
          onFocusedViewChange: (isViewFocused) => setFocusedView("year", isViewFocused),
          yearsPerRow,
          referenceDate
        })), view === "month" && /* @__PURE__ */ jsxRuntimeExports.jsx(MonthCalendar, _extends$2({}, baseDateValidationProps, commonViewProps, {
          hasFocus,
          className,
          value,
          onChange: handleDateMonthChange,
          shouldDisableMonth,
          onFocusedViewChange: (isViewFocused) => setFocusedView("month", isViewFocused),
          monthsPerRow,
          referenceDate
        })), view === "day" && /* @__PURE__ */ jsxRuntimeExports.jsx(DayCalendar, _extends$2({}, calendarState, baseDateValidationProps, commonViewProps, {
          onMonthSwitchingAnimationEnd,
          onFocusedDayChange: changeFocusedDay,
          reduceAnimations,
          selectedDays,
          onSelectedDaysChange: handleSelectedDayChange,
          shouldDisableDate,
          shouldDisableMonth,
          shouldDisableYear,
          hasFocus,
          onFocusedViewChange: (isViewFocused) => setFocusedView("day", isViewFocused),
          showDaysOutsideCurrentMonth,
          fixedWeekNumber,
          dayOfWeekFormatter,
          displayWeekNumber,
          components,
          componentsProps,
          slots,
          slotProps,
          loading,
          renderLoading
        }))]
      })
    })]
  }));
});
const renderDateViewCalendar = ({
  view,
  onViewChange,
  views,
  focusedView,
  onFocusedViewChange,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  shouldDisableMonth,
  shouldDisableYear,
  reduceAnimations,
  onMonthChange,
  monthsPerRow,
  onYearChange,
  yearsPerRow,
  defaultCalendarMonth,
  components,
  componentsProps,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  sx,
  autoFocus,
  fixedWeekNumber,
  displayWeekNumber,
  timezone
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(DateCalendar, {
  view,
  onViewChange,
  views: views.filter(isDatePickerView),
  focusedView: focusedView && isDatePickerView(focusedView) ? focusedView : null,
  onFocusedViewChange,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  maxDate,
  shouldDisableDate,
  shouldDisableMonth,
  shouldDisableYear,
  reduceAnimations,
  onMonthChange,
  monthsPerRow,
  onYearChange,
  yearsPerRow,
  defaultCalendarMonth,
  components,
  componentsProps,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  sx,
  autoFocus,
  fixedWeekNumber,
  displayWeekNumber,
  timezone
});
const DesktopDatePicker = /* @__PURE__ */ reactExports.forwardRef(function DesktopDatePicker2(inProps, ref) {
  var _defaultizedProps$yea, _defaultizedProps$slo2, _props$localeText$ope, _props$localeText;
  const localeText = useLocaleText();
  const utils2 = useUtils();
  const defaultizedProps = useDatePickerDefaultizedProps(inProps, "MuiDesktopDatePicker");
  const viewRenderers = _extends$2({
    day: renderDateViewCalendar,
    month: renderDateViewCalendar,
    year: renderDateViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends$2({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateFormat(utils2, defaultizedProps, false),
    yearsPerRow: (_defaultizedProps$yea = defaultizedProps.yearsPerRow) != null ? _defaultizedProps$yea : 4,
    slots: _extends$2({
      openPickerIcon: CalendarIcon,
      field: DateField
    }, defaultizedProps.slots),
    slotProps: _extends$2({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _defaultizedProps$slo;
        return _extends$2({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends$2({
        hidden: true
      }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar)
    })
  });
  const {
    renderPicker
  } = useDesktopPicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "date",
    getOpenDialogAriaText: (_props$localeText$ope = (_props$localeText = props.localeText) == null ? void 0 : _props$localeText.openDatePickerDialogue) != null ? _props$localeText$ope : localeText.openDatePickerDialogue,
    validator: validateDate
  });
  return renderPicker();
});
DesktopDatePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes.bool,
  /**
   * Class name applied to the root element.
   */
  className: PropTypes.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: PropTypes.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: PropTypes.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter.  Deprecated, will be removed in v7: Use `date` instead.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (_day: string, date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: PropTypes.func,
  /**
   * Default calendar month displayed when `value` and `defaultValue` are empty.
   */
  defaultCalendarMonth: PropTypes.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: PropTypes.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: PropTypes.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: PropTypes.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,
  /**
   * The label content.
   */
  label: PropTypes.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: PropTypes.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes.object,
  /**
   * Maximal selectable date.
   */
  maxDate: PropTypes.any,
  /**
   * Minimal selectable date.
   */
  minDate: PropTypes.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: PropTypes.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: PropTypes.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: PropTypes.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: PropTypes.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes.oneOf(["landscape", "portrait"]),
  readOnly: PropTypes.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes.any,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: PropTypes.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number, PropTypes.shape({
    endIndex: PropTypes.number.isRequired,
    startIndex: PropTypes.number.isRequired
  })]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: PropTypes.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: PropTypes.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: PropTypes.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: PropTypes.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: PropTypes.shape({
    day: PropTypes.func,
    month: PropTypes.func,
    year: PropTypes.func
  }),
  /**
   * Available views.
   */
  views: PropTypes.arrayOf(PropTypes.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4
   */
  yearsPerRow: PropTypes.oneOf([3, 4])
};
const _excluded$1 = ["props", "getOpenDialogAriaText"];
const useMobilePicker = (_ref) => {
  var _innerSlotProps$toolb, _innerSlotProps$toolb2, _slots$layout;
  let {
    props,
    getOpenDialogAriaText
  } = _ref, pickerParams = _objectWithoutPropertiesLoose$1(_ref, _excluded$1);
  const {
    slots,
    slotProps: innerSlotProps,
    className,
    sx,
    format: format2,
    formatDensity,
    timezone,
    label,
    inputRef,
    readOnly,
    disabled,
    localeText
  } = props;
  const utils2 = useUtils();
  const internalInputRef = reactExports.useRef(null);
  const labelId = useId();
  const isToolbarHidden = (_innerSlotProps$toolb = innerSlotProps == null || (_innerSlotProps$toolb2 = innerSlotProps.toolbar) == null ? void 0 : _innerSlotProps$toolb2.hidden) != null ? _innerSlotProps$toolb : false;
  const {
    open: open2,
    actions,
    layoutProps,
    renderCurrentView,
    fieldProps: pickerFieldProps
  } = usePicker(_extends$2({}, pickerParams, {
    props,
    inputRef: internalInputRef,
    autoFocusView: true,
    additionalViewProps: {},
    wrapperVariant: "mobile"
  }));
  const Field = slots.field;
  const fieldProps = useSlotProps({
    elementType: Field,
    externalSlotProps: innerSlotProps == null ? void 0 : innerSlotProps.field,
    additionalProps: _extends$2({}, pickerFieldProps, isToolbarHidden && {
      id: labelId
    }, !(disabled || readOnly) && {
      onClick: actions.onOpen,
      onKeyDown: onSpaceOrEnter(actions.onOpen)
    }, {
      readOnly: readOnly != null ? readOnly : true,
      disabled,
      className,
      sx,
      format: format2,
      formatDensity,
      timezone,
      label
    }),
    ownerState: props
  });
  fieldProps.inputProps = _extends$2({}, fieldProps.inputProps, {
    "aria-label": getOpenDialogAriaText(pickerFieldProps.value, utils2)
  });
  const slotsForField = _extends$2({
    textField: slots.textField
  }, fieldProps.slots);
  const Layout = (_slots$layout = slots.layout) != null ? _slots$layout : PickersLayout;
  const handleInputRef = useForkRef(internalInputRef, fieldProps.inputRef, inputRef);
  let labelledById = labelId;
  if (isToolbarHidden) {
    if (label) {
      labelledById = `${labelId}-label`;
    } else {
      labelledById = void 0;
    }
  }
  const slotProps = _extends$2({}, innerSlotProps, {
    toolbar: _extends$2({}, innerSlotProps == null ? void 0 : innerSlotProps.toolbar, {
      titleId: labelId
    }),
    mobilePaper: _extends$2({
      "aria-labelledby": labelledById
    }, innerSlotProps == null ? void 0 : innerSlotProps.mobilePaper)
  });
  const renderPicker = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(LocalizationProvider, {
    localeText,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Field, _extends$2({}, fieldProps, {
      slots: slotsForField,
      slotProps,
      inputRef: handleInputRef
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(PickersModalDialog, _extends$2({}, actions, {
      open: open2,
      slots,
      slotProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, _extends$2({}, layoutProps, slotProps == null ? void 0 : slotProps.layout, {
        slots,
        slotProps,
        children: renderCurrentView()
      }))
    }))]
  });
  return {
    renderPicker
  };
};
const MobileDatePicker = /* @__PURE__ */ reactExports.forwardRef(function MobileDatePicker2(inProps, ref) {
  var _defaultizedProps$slo2, _props$localeText$ope, _props$localeText;
  const localeText = useLocaleText();
  const utils2 = useUtils();
  const defaultizedProps = useDatePickerDefaultizedProps(inProps, "MuiMobileDatePicker");
  const viewRenderers = _extends$2({
    day: renderDateViewCalendar,
    month: renderDateViewCalendar,
    year: renderDateViewCalendar
  }, defaultizedProps.viewRenderers);
  const props = _extends$2({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateFormat(utils2, defaultizedProps, false),
    slots: _extends$2({
      field: DateField
    }, defaultizedProps.slots),
    slotProps: _extends$2({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _defaultizedProps$slo;
        return _extends$2({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends$2({
        hidden: false
      }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobilePicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "date",
    getOpenDialogAriaText: (_props$localeText$ope = (_props$localeText = props.localeText) == null ? void 0 : _props$localeText.openDatePickerDialogue) != null ? _props$localeText$ope : localeText.openDatePickerDialogue,
    validator: validateDate
  });
  return renderPicker();
});
MobileDatePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: PropTypes.bool,
  /**
   * Class name applied to the root element.
   */
  className: PropTypes.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: PropTypes.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: PropTypes.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: PropTypes.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter.  Deprecated, will be removed in v7: Use `date` instead.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (_day: string, date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: PropTypes.func,
  /**
   * Default calendar month displayed when `value` and `defaultValue` are empty.
   */
  defaultCalendarMonth: PropTypes.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: PropTypes.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: PropTypes.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: PropTypes.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: PropTypes.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: PropTypes.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: PropTypes.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: PropTypes.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: PropTypes.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: PropTypes.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType$1,
  /**
   * The label content.
   */
  label: PropTypes.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: PropTypes.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: PropTypes.object,
  /**
   * Maximal selectable date.
   */
  maxDate: PropTypes.any,
  /**
   * Minimal selectable date.
   */
  minDate: PropTypes.any,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: PropTypes.oneOf([3, 4]),
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: PropTypes.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: PropTypes.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: PropTypes.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: PropTypes.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: PropTypes.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: PropTypes.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: PropTypes.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: PropTypes.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: PropTypes.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: PropTypes.oneOf(["day", "month", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: PropTypes.oneOf(["landscape", "portrait"]),
  readOnly: PropTypes.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: PropTypes.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: PropTypes.any,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: PropTypes.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: PropTypes.oneOfType([PropTypes.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), PropTypes.number, PropTypes.shape({
    endIndex: PropTypes.number.isRequired,
    startIndex: PropTypes.number.isRequired
  })]),
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: PropTypes.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: PropTypes.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: PropTypes.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: PropTypes.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: PropTypes.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: PropTypes.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: PropTypes.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: PropTypes.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: PropTypes.oneOf(["day", "month", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: PropTypes.shape({
    day: PropTypes.func,
    month: PropTypes.func,
    year: PropTypes.func
  }),
  /**
   * Available views.
   */
  views: PropTypes.arrayOf(PropTypes.oneOf(["day", "month", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: PropTypes.oneOf([3, 4])
};
const _excluded = ["desktopModeMediaQuery"];
const DatePicker = /* @__PURE__ */ reactExports.forwardRef(function DatePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDatePicker"
  });
  const {
    desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded);
  const isDesktop = useMediaQuery(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DesktopDatePicker, _extends$2({
      ref
    }, other));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MobileDatePicker, _extends$2({
    ref
  }, other));
});
const statesCities = [
  {
    name: "Abia",
    cities: [
      "Aba South",
      "Arochukwu",
      "Bende",
      "Ikwuano",
      "Isiala Ngwa North",
      "Isiala Ngwa South",
      "Isuikwuato",
      "Obi Ngwa",
      "Ohafia",
      "Osisioma",
      "Ugwunagbo",
      "Ukwa East",
      "Ukwa West",
      "Umuahia North",
      "Umuahia South",
      "Umu Nneochi"
    ]
  },
  {
    name: "Adamawa",
    cities: [
      "Fufure",
      "Ganye",
      "Gayuk",
      "Gombi",
      "Grie",
      "Hong",
      "Jada",
      "Lamurde",
      "Madagali",
      "Maiha",
      "Mayo Belwa",
      "Michika",
      "Mubi North",
      "Mubi South",
      "Numan",
      "Shelleng",
      "Song",
      "Toungo",
      "Yola North",
      "Yola South"
    ]
  },
  {
    name: "Akwa Ibom",
    cities: [
      "Eastern Obolo",
      "Eket",
      "Esit Eket",
      "Essien Udim",
      "Etim Ekpo",
      "Etinan",
      "Ibeno",
      "Ibesikpo Asutan",
      "Ibiono-Ibom",
      "Ika",
      "Ikono",
      "Ikot Abasi",
      "Ikot Ekpene",
      "Ini",
      "Itu",
      "Mbo",
      "Mkpat-Enin",
      "Nsit-Atai",
      "Nsit-Ibom",
      "Nsit-Ubium",
      "Obot Akara",
      "Okobo",
      "Onna",
      "Oron",
      "Oruk Anam",
      "Udung-Uko",
      "Ukanafun",
      "Uruan",
      "Urue-Offong/Oruko",
      "Uyo"
    ]
  },
  {
    name: "Anambra",
    cities: [
      "Anambra East",
      "Anambra West",
      "Anaocha",
      "Awka North",
      "Awka South",
      "Ayamelum",
      "Dunukofia",
      "Ekwusigo",
      "Idemili North",
      "Idemili South",
      "Ihiala",
      "Njikoka",
      "Nnewi North",
      "Nnewi South",
      "Ogbaru",
      "Onitsha North",
      "Onitsha South",
      "Orumba North",
      "Orumba South",
      "Oyi"
    ]
  },
  {
    name: "Bauchi",
    cities: [
      "Bauchi",
      "Bogoro",
      "Damban",
      "Darazo",
      "Dass",
      "Gamawa",
      "Ganjuwa",
      "Giade",
      "Itas/Gadau",
      "Jama'are",
      "Katagum",
      "Kirfi",
      "Misau",
      "Ningi",
      "Shira",
      "Tafawa Balewa",
      "Toro",
      "Warji",
      "Zaki"
    ]
  },
  {
    name: "Bayelsa",
    cities: [
      "Ekeremor",
      "Kolokuma/Opokuma",
      "Nembe",
      "Ogbia",
      "Sagbama",
      "Southern Ijaw",
      "Yenagoa"
    ]
  },
  {
    name: "Benue",
    cities: [
      "Apa",
      "Ado",
      "Buruku",
      "Gboko",
      "Guma",
      "Gwer East",
      "Gwer West",
      "Katsina-Ala",
      "Konshisha",
      "Kwande",
      "Logo",
      "Makurdi",
      "Obi",
      "Ogbadibo",
      "Ohimini",
      "Oju",
      "Okpokwu",
      "Oturkpo",
      "Tarka",
      "Ukum",
      "Ushongo",
      "Vandeikya"
    ]
  },
  {
    name: "Borno",
    cities: [
      "Askira/Uba",
      "Bama",
      "Bayo",
      "Biu",
      "Chibok",
      "Damboa",
      "Dikwa",
      "Gubio",
      "Guzamala",
      "Gwoza",
      "Hawul",
      "Jere",
      "Kaga",
      "Kala/Balge",
      "Konduga",
      "Kukawa",
      "Kwaya Kusar",
      "Mafa",
      "Magumeri",
      "Maiduguri",
      "Marte",
      "Mobbar",
      "Monguno",
      "Ngala",
      "Nganzai",
      "Shani"
    ]
  },
  {
    name: "Cross River",
    cities: [
      "Akamkpa",
      "Akpabuyo",
      "Bakassi",
      "Bekwarra",
      "Biase",
      "Boki",
      "Calabar Municipal",
      "Calabar South",
      "Etung",
      "Ikom",
      "Obanliku",
      "Obubra",
      "Obudu",
      "Odukpani",
      "Ogoja",
      "Yakuur",
      "Yala"
    ]
  },
  {
    name: "Delta",
    cities: [
      "Aniocha South",
      "Bomadi",
      "Burutu",
      "Ethiope East",
      "Ethiope West",
      "Ika North East",
      "Ika South",
      "Isoko North",
      "Isoko South",
      "Ndokwa East",
      "Ndokwa West",
      "Okpe",
      "Oshimili North",
      "Oshimili South",
      "Patani",
      "Sapele",
      "Udu",
      "Ughelli North",
      "Ughelli South",
      "Ukwuani",
      "Uvwie",
      "Warri North",
      "Warri South",
      "Warri South West"
    ]
  },
  {
    name: "Ebonyi",
    cities: [
      "Afikpo North",
      "Afikpo South",
      "Ebonyi",
      "Ezza North",
      "Ezza South",
      "Ikwo",
      "Ishielu",
      "Ivo",
      "Izzi",
      "Ohaozara",
      "Ohaukwu",
      "Onicha"
    ]
  },
  {
    name: "Edo",
    cities: [
      "Egor",
      "Esan Central",
      "Esan North-East",
      "Esan South-East",
      "Esan West",
      "Etsako Central",
      "Etsako East",
      "Etsako West",
      "Igueben",
      "Ikpoba Okha",
      "Orhionmwon",
      "Oredo",
      "Ovia North-East",
      "Ovia South-West",
      "Owan East",
      "Owan West",
      "Uhunmwonde"
    ]
  },
  {
    name: "Ekiti",
    cities: [
      "Efon",
      "Ekiti East",
      "Ekiti South-West",
      "Ekiti West",
      "Emure",
      "Gbonyin",
      "Ido Osi",
      "Ijero",
      "Ikere",
      "Ikole",
      "Ilejemeje",
      "Irepodun/Ifelodun",
      "Ise/Orun",
      "Moba",
      "Oye"
    ]
  },
  {
    name: "Enugu",
    cities: [
      "Awgu",
      "Enugu East",
      "Enugu North",
      "Enugu South",
      "Ezeagu",
      "Igbo Etiti",
      "Igbo Eze North",
      "Igbo Eze South",
      "Isi Uzo",
      "Nkanu East",
      "Nkanu West",
      "Nsukka",
      "Oji River",
      "Udenu",
      "Udi",
      "Uzo Uwani"
    ]
  },
  {
    name: "FCT",
    cities: ["Bwari", "Gwagwalada", "Kuje", "Kwali", "Municipal Area Council"]
  },
  {
    name: "Gombe",
    cities: [
      "Balanga",
      "Billiri",
      "Dukku",
      "Funakaye",
      "Gombe",
      "Kaltungo",
      "Kwami",
      "Nafada",
      "Shongom",
      "Yamaltu/Deba"
    ]
  },
  {
    name: "Imo",
    cities: [
      "Ahiazu Mbaise",
      "Ehime Mbano",
      "Ezinihitte",
      "Ideato North",
      "Ideato South",
      "Ihitte/Uboma",
      "Ikeduru",
      "Isiala Mbano",
      "Isu",
      "Mbaitoli",
      "Ngor Okpala",
      "Njaba",
      "Nkwerre",
      "Nwangele",
      "Obowo",
      "Oguta",
      "Ohaji/Egbema",
      "Okigwe",
      "Orlu",
      "Orsu",
      "Oru East",
      "Oru West",
      "Owerri Municipal",
      "Owerri North",
      "Owerri West",
      "Unuimo"
    ]
  },
  {
    name: "Jigawa",
    cities: [
      "Babura",
      "Biriniwa",
      "Birnin Kudu",
      "Buji",
      "Dutse",
      "Gagarawa",
      "Garki",
      "Gumel",
      "Guri",
      "Gwaram",
      "Gwiwa",
      "Hadejia",
      "Jahun",
      "Kafin Hausa",
      "Kazaure",
      "Kiri Kasama",
      "Kiyawa",
      "Kaugama",
      "Maigatari",
      "Malam Madori",
      "Miga",
      "Ringim",
      "Roni",
      "Sule Tankarkar",
      "Taura",
      "Yankwashi"
    ]
  },
  {
    name: "Kaduna",
    cities: [
      "Chikun",
      "Giwa",
      "Igabi",
      "Ikara",
      "Jaba",
      "Jema'a",
      "Kachia",
      "Kaduna North",
      "Kaduna South",
      "Kagarko",
      "Kajuru",
      "Kaura",
      "Kauru",
      "Kubau",
      "Kudan",
      "Lere",
      "Makarfi",
      "Sabon Gari",
      "Sanga",
      "Soba",
      "Zangon Kataf",
      "Zaria"
    ]
  },
  {
    name: "Kano",
    cities: [
      "Albasu",
      "Bagwai",
      "Bebeji",
      "Bichi",
      "Bunkure",
      "Dala",
      "Dambatta",
      "Dawakin Kudu",
      "Dawakin Tofa",
      "Doguwa",
      "Fagge",
      "Gabasawa",
      "Garko",
      "Garun Mallam",
      "Gaya",
      "Gezawa",
      "Gwale",
      "Gwarzo",
      "Kabo",
      "Kano Municipal",
      "Karaye",
      "Kibiya",
      "Kiru",
      "Kumbotso",
      "Kunchi",
      "Kura",
      "Madobi",
      "Makoda",
      "Minjibir",
      "Nasarawa",
      "Rano",
      "Rimin Gado",
      "Rogo",
      "Shanono",
      "Sumaila",
      "Takai",
      "Tarauni",
      "Tofa",
      "Tsanyawa",
      "Tudun Wada",
      "Ungogo",
      "Warawa",
      "Wudil"
    ]
  },
  {
    name: "Katsina",
    cities: [
      "Batagarawa",
      "Batsari",
      "Baure",
      "Bindawa",
      "Charanchi",
      "Dandume",
      "Danja",
      "Dan Musa",
      "Daura",
      "Dutsi",
      "Dutsin Ma",
      "Faskari",
      "Funtua",
      "Ingawa",
      "Jibia",
      "Kafur",
      "Kaita",
      "Kankara",
      "Kankia",
      "Katsina",
      "Kurfi",
      "Kusada",
      "Mai'Adua",
      "Malumfashi",
      "Mani",
      "Mashi",
      "Matazu",
      "Musawa",
      "Rimi",
      "Sabuwa",
      "Safana",
      "Sandamu",
      "Zango"
    ]
  },
  {
    name: "Kebbi",
    cities: [
      "Arewa Dandi",
      "Argungu",
      "Augie",
      "Bagudo",
      "Birnin Kebbi",
      "Bunza",
      "Dandi",
      "Fakai",
      "Gwandu",
      "Jega",
      "Kalgo",
      "Koko/Besse",
      "Maiyama",
      "Ngaski",
      "Sakaba",
      "Shanga",
      "Suru",
      "Wasagu/Danko",
      "Yauri",
      "Zuru"
    ]
  },
  {
    name: "Kogi",
    cities: [
      "Ajaokuta",
      "Ankpa",
      "Bassa",
      "Dekina",
      "Ibaji",
      "Idah",
      "Igalamela Odolu",
      "Ijumu",
      "Kabba/Bunu",
      "Kogi",
      "Lokoja",
      "Mopa Muro",
      "Ofu",
      "Ogori/Magongo",
      "Okehi",
      "Okene",
      "Olamaboro",
      "Omala",
      "Yagba East",
      "Yagba West"
    ]
  },
  {
    name: "Kwara",
    cities: [
      "Baruten",
      "Edu",
      "Ekiti",
      "Ifelodun",
      "Ilorin East",
      "Ilorin South",
      "Ilorin West",
      "Irepodun",
      "Isin",
      "Kaiama",
      "Moro",
      "Offa",
      "Oke Ero",
      "Oyun",
      "Pategi"
    ]
  },
  {
    name: "Lagos",
    cities: [
      "Ajeromi-Ifelodun",
      "Alimosho",
      "Amuwo-Odofin",
      "Apapa",
      "Badagry",
      "Epe",
      "Eti Osa",
      "Ibeju-Lekki",
      "Ifako-Ijaiye",
      "Ikeja",
      "Ikorodu",
      "Kosofe",
      "Lagos Island",
      "Lagos Mainland",
      "Mushin",
      "Ojo",
      "Oshodi-Isolo",
      "Shomolu",
      "Surulere"
    ]
  },
  {
    name: "Nasarawa",
    cities: [
      "Awe",
      "Doma",
      "Karu",
      "Keana",
      "Keffi",
      "Kokona",
      "Lafia",
      "Nasarawa",
      "Nasarawa Egon",
      "Obi",
      "Toto",
      "Wamba"
    ]
  },
  {
    name: "Niger",
    cities: [
      "Agwara",
      "Bida",
      "Borgu",
      "Bosso",
      "Chanchaga",
      "Edati",
      "Gbako",
      "Gurara",
      "Katcha",
      "Kontagora",
      "Lapai",
      "Lavun",
      "Magama",
      "Mariga",
      "Mashegu",
      "Mokwa",
      "Moya",
      "Paikoro",
      "Rafi",
      "Rijau",
      "Shiroro",
      "Suleja",
      "Tafa",
      "Wushishi"
    ]
  },
  {
    name: "Ogun",
    cities: [
      "Abeokuta South",
      "Ado-Odo/Ota",
      "Egbado North",
      "Egbado South",
      "Ewekoro",
      "Ifo",
      "Ijebu East",
      "Ijebu North",
      "Ijebu North East",
      "Ijebu Ode",
      "Ikenne",
      "Imeko Afon",
      "Ipokia",
      "Obafemi Owode",
      "Odeda",
      "Odogbolu",
      "Ogun Waterside",
      "Remo North",
      "Shagamu"
    ]
  },
  {
    name: "Ondo",
    cities: [
      "Akoko North-West",
      "Akoko South-West",
      "Akoko South-East",
      "Akure North",
      "Akure South",
      "Ese Odo",
      "Idanre",
      "Ifedore",
      "Ilaje",
      "Ile Oluji/Okeigbo",
      "Irele",
      "Odigbo",
      "Okitipupa",
      "Ondo East",
      "Ondo West",
      "Ose",
      "Owo"
    ]
  },
  {
    name: "Osun",
    cities: [
      "Atakunmosa West",
      "Aiyedaade",
      "Aiyedire",
      "Boluwaduro",
      "Boripe",
      "Ede North",
      "Ede South",
      "Ife Central",
      "Ife East",
      "Ife North",
      "Ife South",
      "Egbedore",
      "Ejigbo",
      "Ifedayo",
      "Ifelodun",
      "Ila",
      "Ilesa East",
      "Ilesa West",
      "Irepodun",
      "Irewole",
      "Isokan",
      "Iwo",
      "Obokun",
      "Odo Otin",
      "Ola Oluwa",
      "Olorunda",
      "Oriade",
      "Orolu",
      "Osogbo"
    ]
  },
  {
    name: "Oyo",
    cities: [
      "Akinyele",
      "Atiba",
      "Atisbo",
      "Egbeda",
      "Ibadan North",
      "Ibadan North-East",
      "Ibadan North-West",
      "Ibadan South-East",
      "Ibadan South-West",
      "Ibarapa Central",
      "Ibarapa East",
      "Ibarapa North",
      "Ido",
      "Irepo",
      "Iseyin",
      "Itesiwaju",
      "Iwajowa",
      "Kajola",
      "Lagelu",
      "Ogbomosho North",
      "Ogbomosho South",
      "Ogo Oluwa",
      "Olorunsogo",
      "Oluyole",
      "Ona Ara",
      "Orelope",
      "Ori Ire",
      "Oyo",
      "Oyo East",
      "Saki East",
      "Saki West",
      "Surulere"
    ]
  },
  {
    name: "Plateau",
    cities: [
      "Barkin Ladi",
      "Bassa",
      "Jos East",
      "Jos North",
      "Jos South",
      "Kanam",
      "Kanke",
      "Langtang South",
      "Langtang North",
      "Mangu",
      "Mikang",
      "Pankshin",
      "Qua'an Pan",
      "Riyom",
      "Shendam",
      "Wase"
    ]
  },
  {
    name: "Rivers",
    cities: [
      "Ahoada East",
      "Ahoada West",
      "Akuku-Toru",
      "Andoni",
      "Asari-Toru",
      "Bonny",
      "Degema",
      "Eleme",
      "Emuoha",
      "Etche",
      "Gokana",
      "Ikwerre",
      "Khana",
      "Obio/Akpor",
      "Ogba/Egbema/Ndoni",
      "Ogu/Bolo",
      "Okrika",
      "Omuma",
      "Opobo/Nkoro",
      "Oyigbo",
      "Port Harcourt",
      "Tai"
    ]
  },
  {
    name: "Sokoto",
    cities: [
      "Bodinga",
      "Dange Shuni",
      "Gada",
      "Goronyo",
      "Gudu",
      "Gwadabawa",
      "Illela",
      "Isa",
      "Kebbe",
      "Kware",
      "Rabah",
      "Sabon Birni",
      "Shagari",
      "Silame",
      "Sokoto North",
      "Sokoto South",
      "Tambuwal",
      "Tangaza",
      "Tureta",
      "Wamako",
      "Wurno",
      "Yabo"
    ]
  },
  {
    name: "Taraba",
    cities: [
      "Bali",
      "Donga",
      "Gashaka",
      "Gassol",
      "Ibi",
      "Jalingo",
      "Karim Lamido",
      "Kumi",
      "Lau",
      "Sardauna",
      "Takum",
      "Ussa",
      "Wukari",
      "Yorro",
      "Zing"
    ]
  },
  {
    name: "Yobe",
    cities: [
      "Bursari",
      "Damaturu",
      "Fika",
      "Fune",
      "Geidam",
      "Gujba",
      "Gulani",
      "Jakusko",
      "Karasuwa",
      "Machina",
      "Nangere",
      "Nguru",
      "Potiskum",
      "Tarmuwa",
      "Yunusari",
      "Yusufari"
    ]
  },
  {
    name: "Zamfara",
    cities: [
      "Bakura",
      "Birnin Magaji/Kiyaw",
      "Bukkuyum",
      "Bungudu",
      "Gummi",
      "Gusau",
      "Kaura Namoda",
      "Maradun",
      "Maru",
      "Shinkafi",
      "Talata Mafara",
      "Chafe",
      "Zurmi"
    ]
  }
];
function NewCustomerForm() {
  const [value, setValue2] = reactExports.useState();
  const [cities, setCities] = reactExports.useState([]);
  const dispatch = useDispatch();
  const isOnline2 = useSelector((state) => state.loader.isOnline);
  const dbasePath = useSelector((state) => state.database.dbasePath);
  const customerSchema2 = create$3$1().shape({
    firstName: create$6().required("First name is required"),
    lastName: create$6().nullable(),
    emailAddress: create$6().email("Invalid email address").nullable(),
    mobileID: create$6().max(11, "Maximum allowed is 11 digits").required("Phone number is required"),
    phoneNumber: create$6().max(11, "Maximum allowed is 11 digits").nullable(),
    date: create$6().nullable(),
    homeAddress: create$6().nullable(),
    shippingAddress: create$6().nullable()
  });
  const initialValues = {
    firstName: "",
    lastName: "",
    emailAddress: "",
    gender: "",
    homeAddress: "",
    date: (/* @__PURE__ */ new Date()).toDateString(),
    mobileID: "",
    shippingAddress: "",
    phoneNumber: null,
    state: "",
    city: ""
  };
  function formatDateToYMD(date2) {
    const year = date2.getFullYear();
    const month = String(date2.getMonth() + 1).padStart(2, "0");
    const day = String(date2.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  const formik = useFormik({
    initialValues,
    validationSchema: customerSchema2,
    onSubmit: async (values22) => {
      dispatch(setLoading(true));
      console.log(values22.emailAddress);
      const payload = {
        id: (/* @__PURE__ */ new Date()).getTime(),
        email: values22.emailAddress,
        type: "customer",
        first_name: values22.firstName,
        last_name: values22.lastName,
        dob: formatDateToYMD(new Date(values22.date)),
        mobile: values22.mobileID,
        alternate_number: values22.phoneNumber,
        address_line_1: values22.homeAddress,
        shipping_address: values22.shippingAddress,
        state: values22.state,
        city: values22.city,
        country: "nigeria"
      };
      try {
        if (isOnline2) {
          const data = await APIService.addNewCustomer(payload);
          console.log("NEW CUSTOMER RESPONSE ", data);
        }
        const db2 = await getDatabase(`${dbasePath}`);
        db2?.users.insert(payload);
        console.log(payload);
        dispatch(setLoading(false));
        _t$1.success("New customer added successfully.");
      } catch (error) {
        dispatch(setLoading(false));
      }
    }
  });
  const { errors, touched, values: values2, handleSubmit, handleChange, setFieldValue } = formik;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { px: 4, role: "form", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 4, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 6, lg: 5, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          display: "flex",
          flexDirection: "column",
          justifyContent: "start",
          alignItems: "start",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "First Name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField$1,
              {
                variant: "outlined",
                placeholder: "Enter first name",
                value: values2.firstName,
                onChange: handleChange,
                name: "firstName",
                fullWidth: true,
                InputProps: {
                  style: { backgroundColor: "white" }
                },
                helperText: touched.firstName && errors.firstName,
                error: Boolean(touched.firstName && errors.firstName)
              }
            )
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 6, lg: 5, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          display: "flex",
          flexDirection: "column",
          justifyContent: "start",
          alignItems: "start",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Last Name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField$1,
              {
                variant: "outlined",
                placeholder: "Enter last name",
                value: values2.lastName,
                onChange: handleChange,
                name: "lastName",
                fullWidth: true,
                InputProps: {
                  style: { backgroundColor: "white" }
                },
                error: Boolean(touched.lastName && errors.lastName),
                helperText: touched.lastName && errors.lastName
              }
            )
          ]
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, mt: 0.5, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, lg: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          display: "flex",
          flexDirection: "column",
          justifyContent: "start",
          alignItems: "start",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Email Address" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField$1,
              {
                variant: "outlined",
                placeholder: "Enter email address",
                value: values2.emailAddress,
                onChange: handleChange,
                name: "emailAddress",
                fullWidth: true,
                InputProps: {
                  style: { backgroundColor: "white" }
                },
                error: Boolean(touched.emailAddress && errors.emailAddress),
                helperText: touched.emailAddress && errors.emailAddress
              }
            )
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, lg: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "State" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, { placeholder: "Select state", fullWidth: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select$1,
            {
              id: "demo--select",
              size: "medium",
              value: values2.state,
              name: "state",
              sx: { backgroundColor: "white" },
              onChange: (e2) => {
                handleChange(e2);
                const filtered = statesCities.filter(
                  (item) => item?.name.toLowerCase() === e2.target.value
                );
                setCities(filtered[0].cities);
              },
              error: Boolean(touched.state && errors.state),
              displayEmpty: true,
              inputProps: { "aria-label": "Without label" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("em", { children: "Select state" }) }),
                statesCities.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: item?.name?.toLowerCase(), children: item.name }, item.name))
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText$1, { children: touched.state && errors.state })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, lg: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "City" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(FormControl$1, { placeholder: "Select city", fullWidth: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select$1,
            {
              id: "demo--select",
              size: "medium",
              value: values2.city,
              name: "city",
              sx: { backgroundColor: "white" },
              onChange: handleChange,
              error: Boolean(touched.city && errors.city),
              displayEmpty: true,
              inputProps: { "aria-label": "Without label" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("em", { children: "Select city" }) }),
                cities?.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: item?.toLowerCase(), children: item }, item))
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormHelperText$1, { children: touched.city && errors.city })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 4, md: 4, lg: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Date" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LocalizationProvider, { dateAdapter: AdapterDayjs, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DatePicker,
          {
            sx: { bgcolor: "white" },
            value,
            onChange: (newValue) => {
              setValue2(newValue);
              setFieldValue("date", newValue.toString());
            }
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 4, mt: 0.5, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 7, lg: 8, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "start",
          alignItems: "start",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Home Address" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField$1,
              {
                variant: "outlined",
                placeholder: "Enter home address",
                value: values2.homeAddress,
                onChange: handleChange,
                name: "homeAddress",
                fullWidth: true,
                InputProps: {
                  style: { backgroundColor: "white" }
                },
                error: Boolean(touched.homeAddress && errors.homeAddress),
                helperText: touched.homeAddress && errors.homeAddress
              }
            )
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 5, lg: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Mobile (required)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField$1,
          {
            variant: "outlined",
            placeholder: "Enter mobile number",
            value: values2.mobileID,
            onChange: handleChange,
            name: "mobileID",
            fullWidth: true,
            InputProps: {
              style: { backgroundColor: "white" }
            },
            error: Boolean(touched.mobileID && errors.mobileID),
            helperText: touched.mobileID && errors.mobileID
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 4, mt: 0.5, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 7, lg: 8, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Box$1,
        {
          width: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "start",
          alignItems: "start",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Shipping Address" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TextField$1,
              {
                variant: "outlined",
                placeholder: "Enter shipping address",
                value: values2.shippingAddress,
                onChange: handleChange,
                name: "shippingAddress",
                fullWidth: true,
                InputProps: {
                  style: { backgroundColor: "white" }
                },
                error: Boolean(touched.shippingAddress && errors.shippingAddress),
                helperText: touched.shippingAddress && errors.shippingAddress
              }
            )
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 6, md: 5, lg: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: "Alt Phone Number" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField$1,
          {
            variant: "outlined",
            placeholder: "Enter phone number",
            value: values2.phoneNumber,
            onChange: handleChange,
            name: "phoneNumber",
            fullWidth: true,
            InputProps: {
              style: { backgroundColor: "white" }
            },
            error: Boolean(touched.phoneNumber && errors.phoneNumber),
            helperText: touched.phoneNumber && errors.phoneNumber
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Box$1,
      {
        width: "100%",
        display: "flex",
        flexDirection: "row",
        justifyContent: "center",
        alignItems: "center",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            type: "submit",
            variant: "contained",
            sx: { py: 1, px: 4 },
            onClick: () => handleSubmit(),
            children: "Add New Customer"
          }
        )
      }
    )
  ] });
}
function AddCustomer() {
  const [customerType, setCustomerType] = React.useState("");
  const navigate = useNavigate();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { height: "100vh", width: "100vw", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        bgcolor: "#ECF0F4",
        position: "fixed",
        left: 0,
        right: 0,
        zIndex: 500,
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        px: 3,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Box$1,
            {
              display: "flex",
              flexDirection: "row",
              justifyContent: "start",
              alignItems: "center",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => navigate(-1), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowBack, { sx: { color: "black" } }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 21, fontWeight: 800, px: 1, children: "New Customer" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select$1,
            {
              size: "small",
              value: customerType,
              name: "gender",
              sx: { minWidth: 175 },
              onChange: (e2) => setCustomerType(e2?.target?.value),
              displayEmpty: true,
              inputProps: { "aria-label": "Without label" },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { disabled: true, "aria-disabled": true, value: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx("em", { children: "Customer Type" }) }),
                ["Individual", "Business"].map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem$1, { value: item?.toLowerCase(), children: item }, item))
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(NewCustomerForm, {})
  ] });
}
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t3[p2] = s2[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y2, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done)
          return t3;
        if (y2 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from2, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to.concat(ar || from2);
}
var Bounds = (
  /** @class */
  function() {
    function Bounds2(left2, top2, width2, height2) {
      this.left = left2;
      this.top = top2;
      this.width = width2;
      this.height = height2;
    }
    Bounds2.prototype.add = function(x2, y2, w2, h2) {
      return new Bounds2(this.left + x2, this.top + y2, this.width + w2, this.height + h2);
    };
    Bounds2.fromClientRect = function(context, clientRect) {
      return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
    };
    Bounds2.fromDOMRectList = function(context, domRectList) {
      var domRect = Array.from(domRectList).find(function(rect) {
        return rect.width !== 0;
      });
      return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
    };
    Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
    return Bounds2;
  }()
);
var parseBounds = function(context, node2) {
  return Bounds.fromClientRect(context, node2.getBoundingClientRect());
};
var parseDocumentSize = function(document2) {
  var body = document2.body;
  var documentElement = document2.documentElement;
  if (!body || !documentElement) {
    throw new Error("Unable to get document size");
  }
  var width2 = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
  var height2 = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
  return new Bounds(0, 0, width2, height2);
};
var toCodePoints$1 = function(str) {
  var codePoints = [];
  var i2 = 0;
  var length2 = str.length;
  while (i2 < length2) {
    var value = str.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length2) {
      var extra = str.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint$1 = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length2 = codePoints.length;
  if (!length2) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length2) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length2 || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
  lookup$2[chars$2.charCodeAt(i$2)] = i$2;
}
var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
}
var decode$1 = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1$1[base642.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array$1 = function(buffer) {
  var length2 = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length2; i2 += 2) {
    bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var polyUint32Array$1 = function(buffer) {
  var length2 = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length2; i2 += 4) {
    bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2$1 = 5;
var UTRIE2_SHIFT_1$1 = 6 + 5;
var UTRIE2_INDEX_SHIFT$1 = 2;
var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
var slice16$1 = function(view, start2, end2) {
  if (view.slice) {
    return view.slice(start2, end2);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start2, end2));
};
var slice32$1 = function(view, start2, end2) {
  if (view.slice) {
    return view.slice(start2, end2);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start2, end2));
};
var createTrieFromBase64$1 = function(base642, _byteLength) {
  var buffer = decode$1(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data);
};
var Trie$1 = (
  /** @class */
  function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index2;
      this.data = data;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  }()
);
var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
  lookup$3[chars$3.charCodeAt(i$3)] = i$3;
}
var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
var LETTER_NUMBER_MODIFIER = 50;
var BK = 1;
var CR$1 = 2;
var LF$1 = 3;
var CM = 4;
var NL = 5;
var WJ = 7;
var ZW = 8;
var GL = 9;
var SP = 10;
var ZWJ$1 = 11;
var B2 = 12;
var BA = 13;
var BB = 14;
var HY = 15;
var CB = 16;
var CL = 17;
var CP = 18;
var EX = 19;
var IN = 20;
var NS = 21;
var OP = 22;
var QU = 23;
var IS = 24;
var NU = 25;
var PO = 26;
var PR = 27;
var SY = 28;
var AI = 29;
var AL = 30;
var CJ = 31;
var EB = 32;
var EM = 33;
var H2 = 34;
var H3 = 35;
var HL = 36;
var ID = 37;
var JL = 38;
var JV = 39;
var JT = 40;
var RI$1 = 41;
var SA = 42;
var XX = 43;
var ea_OP = [9001, 65288];
var BREAK_MANDATORY = "!";
var BREAK_NOT_ALLOWED$1 = "×";
var BREAK_ALLOWED$1 = "÷";
var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
var SPACE$1 = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];
var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
  if (lineBreak2 === void 0) {
    lineBreak2 = "strict";
  }
  var types = [];
  var indices = [];
  var categories = [];
  codePoints.forEach(function(codePoint, index2) {
    var classType = UnicodeTrie$1.get(codePoint);
    if (classType > LETTER_NUMBER_MODIFIER) {
      categories.push(true);
      classType -= LETTER_NUMBER_MODIFIER;
    } else {
      categories.push(false);
    }
    if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
      if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
        indices.push(index2);
        return types.push(CB);
      }
    }
    if (classType === CM || classType === ZWJ$1) {
      if (index2 === 0) {
        indices.push(index2);
        return types.push(AL);
      }
      var prev2 = types[index2 - 1];
      if (LINE_BREAKS.indexOf(prev2) === -1) {
        indices.push(indices[index2 - 1]);
        return types.push(prev2);
      }
      indices.push(index2);
      return types.push(AL);
    }
    indices.push(index2);
    if (classType === CJ) {
      return types.push(lineBreak2 === "strict" ? NS : ID);
    }
    if (classType === SA) {
      return types.push(AL);
    }
    if (classType === AI) {
      return types.push(AL);
    }
    if (classType === XX) {
      if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
        return types.push(ID);
      } else {
        return types.push(AL);
      }
    }
    types.push(classType);
  });
  return [indices, types, categories];
};
var isAdjacentWithSpaceIgnored = function(a2, b2, currentIndex, classTypes) {
  var current = classTypes[currentIndex];
  if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
    var i2 = currentIndex;
    while (i2 <= classTypes.length) {
      i2++;
      var next2 = classTypes[i2];
      if (next2 === b2) {
        return true;
      }
      if (next2 !== SP) {
        break;
      }
    }
  }
  if (current === SP) {
    var i2 = currentIndex;
    while (i2 > 0) {
      i2--;
      var prev2 = classTypes[i2];
      if (Array.isArray(a2) ? a2.indexOf(prev2) !== -1 : a2 === prev2) {
        var n2 = currentIndex;
        while (n2 <= classTypes.length) {
          n2++;
          var next2 = classTypes[n2];
          if (next2 === b2) {
            return true;
          }
          if (next2 !== SP) {
            break;
          }
        }
      }
      if (prev2 !== SP) {
        break;
      }
    }
  }
  return false;
};
var previousNonSpaceClassType = function(currentIndex, classTypes) {
  var i2 = currentIndex;
  while (i2 >= 0) {
    var type2 = classTypes[i2];
    if (type2 === SP) {
      i2--;
    } else {
      return type2;
    }
  }
  return 0;
};
var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
  if (indicies[index2] === 0) {
    return BREAK_NOT_ALLOWED$1;
  }
  var currentIndex = index2 - 1;
  if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
    return BREAK_NOT_ALLOWED$1;
  }
  var beforeIndex = currentIndex - 1;
  var afterIndex = currentIndex + 1;
  var current = classTypes[currentIndex];
  var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
  var next2 = classTypes[afterIndex];
  if (current === CR$1 && next2 === LF$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
    return BREAK_MANDATORY;
  }
  if (HARD_LINE_BREAKS.indexOf(next2) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (SPACE$1.indexOf(next2) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
    return BREAK_ALLOWED$1;
  }
  if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === WJ || next2 === WJ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([SP, BA, HY].indexOf(current) === -1 && next2 === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([CL, CP, EX, IS, SY].indexOf(next2) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SP) {
    return BREAK_ALLOWED$1;
  }
  if (current === QU || next2 === QU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next2 === CB || current === CB) {
    return BREAK_ALLOWED$1;
  }
  if ([BA, HY, NS].indexOf(next2) !== -1 || current === BB) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (before === HL && HYPHEN.indexOf(current) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SY && next2 === HL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next2 === IN) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(next2) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next2 === NU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === PR && [ID, EB, EM].indexOf(next2) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next2 === PO) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next2) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next2) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (
    // (PR | PO) × ( OP | HY )? NU
    [PR, PO].indexOf(current) !== -1 && (next2 === NU || [OP, HY].indexOf(next2) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY ) × NU
    [OP, HY].indexOf(current) !== -1 && next2 === NU || // NU ×	(NU | SY | IS)
    current === NU && [NU, SY, IS].indexOf(next2) !== -1
  ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([NU, SY, IS, CL, CP].indexOf(next2) !== -1) {
    var prevIndex = currentIndex;
    while (prevIndex >= 0) {
      var type2 = classTypes[prevIndex];
      if (type2 === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type2) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if ([PR, PO].indexOf(next2) !== -1) {
    var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
    while (prevIndex >= 0) {
      var type2 = classTypes[prevIndex];
      if (type2 === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type2) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if (JL === current && [JL, JV, H2, H3].indexOf(next2) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next2) !== -1 || [JT, H3].indexOf(current) !== -1 && next2 === JT) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next2) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next2) !== -1 && current === PR) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next2) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === IS && ALPHABETICS.indexOf(next2) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next2 === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next2) !== -1 && current === CP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === RI$1 && next2 === RI$1) {
    var i2 = indicies[currentIndex];
    var count = 1;
    while (i2 > 0) {
      i2--;
      if (classTypes[i2] === RI$1) {
        count++;
      } else {
        break;
      }
    }
    if (count % 2 !== 0) {
      return BREAK_NOT_ALLOWED$1;
    }
  }
  if (current === EB && next2 === EM) {
    return BREAK_NOT_ALLOWED$1;
  }
  return BREAK_ALLOWED$1;
};
var cssFormattedClasses = function(codePoints, options) {
  if (!options) {
    options = { lineBreak: "normal", wordBreak: "normal" };
  }
  var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
  if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
    classTypes = classTypes.map(function(type2) {
      return [NU, AL, SA].indexOf(type2) !== -1 ? ID : type2;
    });
  }
  var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i2) {
    return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;
  }) : void 0;
  return [indicies, classTypes, forbiddenBreakpoints];
};
var Break = (
  /** @class */
  function() {
    function Break2(codePoints, lineBreak2, start2, end2) {
      this.codePoints = codePoints;
      this.required = lineBreak2 === BREAK_MANDATORY;
      this.start = start2;
      this.end = end2;
    }
    Break2.prototype.slice = function() {
      return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
    };
    return Break2;
  }()
);
var LineBreaker = function(str, options) {
  var codePoints = toCodePoints$1(str);
  var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
  var length2 = codePoints.length;
  var lastEnd = 0;
  var nextIndex = 0;
  return {
    next: function() {
      if (nextIndex >= length2) {
        return { done: true, value: null };
      }
      var lineBreak2 = BREAK_NOT_ALLOWED$1;
      while (nextIndex < length2 && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
      }
      if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length2) {
        var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
        lastEnd = nextIndex;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var FLAG_UNRESTRICTED = 1 << 0;
var FLAG_ID = 1 << 1;
var FLAG_INTEGER = 1 << 2;
var FLAG_NUMBER = 1 << 3;
var LINE_FEED = 10;
var SOLIDUS = 47;
var REVERSE_SOLIDUS = 92;
var CHARACTER_TABULATION = 9;
var SPACE = 32;
var QUOTATION_MARK = 34;
var EQUALS_SIGN = 61;
var NUMBER_SIGN = 35;
var DOLLAR_SIGN = 36;
var PERCENTAGE_SIGN = 37;
var APOSTROPHE = 39;
var LEFT_PARENTHESIS = 40;
var RIGHT_PARENTHESIS = 41;
var LOW_LINE = 95;
var HYPHEN_MINUS = 45;
var EXCLAMATION_MARK = 33;
var LESS_THAN_SIGN = 60;
var GREATER_THAN_SIGN = 62;
var COMMERCIAL_AT = 64;
var LEFT_SQUARE_BRACKET = 91;
var RIGHT_SQUARE_BRACKET = 93;
var CIRCUMFLEX_ACCENT = 61;
var LEFT_CURLY_BRACKET = 123;
var QUESTION_MARK = 63;
var RIGHT_CURLY_BRACKET = 125;
var VERTICAL_LINE = 124;
var TILDE = 126;
var CONTROL = 128;
var REPLACEMENT_CHARACTER = 65533;
var ASTERISK = 42;
var PLUS_SIGN = 43;
var COMMA = 44;
var COLON = 58;
var SEMICOLON = 59;
var FULL_STOP = 46;
var NULL = 0;
var BACKSPACE = 8;
var LINE_TABULATION = 11;
var SHIFT_OUT = 14;
var INFORMATION_SEPARATOR_ONE = 31;
var DELETE = 127;
var EOF = -1;
var ZERO = 48;
var a$1 = 97;
var e = 101;
var f$1 = 102;
var u$1 = 117;
var z$1 = 122;
var A$1 = 65;
var E$1 = 69;
var F$1 = 70;
var U$1 = 85;
var Z$1 = 90;
var isDigit = function(codePoint) {
  return codePoint >= ZERO && codePoint <= 57;
};
var isSurrogateCodePoint = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 57343;
};
var isHex = function(codePoint) {
  return isDigit(codePoint) || codePoint >= A$1 && codePoint <= F$1 || codePoint >= a$1 && codePoint <= f$1;
};
var isLowerCaseLetter = function(codePoint) {
  return codePoint >= a$1 && codePoint <= z$1;
};
var isUpperCaseLetter = function(codePoint) {
  return codePoint >= A$1 && codePoint <= Z$1;
};
var isLetter = function(codePoint) {
  return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
};
var isNonASCIICodePoint = function(codePoint) {
  return codePoint >= CONTROL;
};
var isWhiteSpace = function(codePoint) {
  return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
};
var isNameStartCodePoint = function(codePoint) {
  return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
};
var isNameCodePoint = function(codePoint) {
  return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
};
var isNonPrintableCodePoint = function(codePoint) {
  return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
};
var isValidEscape = function(c1, c2) {
  if (c1 !== REVERSE_SOLIDUS) {
    return false;
  }
  return c2 !== LINE_FEED;
};
var isIdentifierStart = function(c1, c2, c3) {
  if (c1 === HYPHEN_MINUS) {
    return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
  } else if (isNameStartCodePoint(c1)) {
    return true;
  } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
    return true;
  }
  return false;
};
var isNumberStart = function(c1, c2, c3) {
  if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
    if (isDigit(c2)) {
      return true;
    }
    return c2 === FULL_STOP && isDigit(c3);
  }
  if (c1 === FULL_STOP) {
    return isDigit(c2);
  }
  return isDigit(c1);
};
var stringToNumber = function(codePoints) {
  var c2 = 0;
  var sign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      sign = -1;
    }
    c2++;
  }
  var integers = [];
  while (isDigit(codePoints[c2])) {
    integers.push(codePoints[c2++]);
  }
  var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
  if (codePoints[c2] === FULL_STOP) {
    c2++;
  }
  var fraction = [];
  while (isDigit(codePoints[c2])) {
    fraction.push(codePoints[c2++]);
  }
  var fracd = fraction.length;
  var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
  if (codePoints[c2] === E$1 || codePoints[c2] === e) {
    c2++;
  }
  var expsign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      expsign = -1;
    }
    c2++;
  }
  var exponent = [];
  while (isDigit(codePoints[c2])) {
    exponent.push(codePoints[c2++]);
  }
  var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
  return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
};
var LEFT_PARENTHESIS_TOKEN = {
  type: 2
  /* LEFT_PARENTHESIS_TOKEN */
};
var RIGHT_PARENTHESIS_TOKEN = {
  type: 3
  /* RIGHT_PARENTHESIS_TOKEN */
};
var COMMA_TOKEN = {
  type: 4
  /* COMMA_TOKEN */
};
var SUFFIX_MATCH_TOKEN = {
  type: 13
  /* SUFFIX_MATCH_TOKEN */
};
var PREFIX_MATCH_TOKEN = {
  type: 8
  /* PREFIX_MATCH_TOKEN */
};
var COLUMN_TOKEN = {
  type: 21
  /* COLUMN_TOKEN */
};
var DASH_MATCH_TOKEN = {
  type: 9
  /* DASH_MATCH_TOKEN */
};
var INCLUDE_MATCH_TOKEN = {
  type: 10
  /* INCLUDE_MATCH_TOKEN */
};
var LEFT_CURLY_BRACKET_TOKEN = {
  type: 11
  /* LEFT_CURLY_BRACKET_TOKEN */
};
var RIGHT_CURLY_BRACKET_TOKEN = {
  type: 12
  /* RIGHT_CURLY_BRACKET_TOKEN */
};
var SUBSTRING_MATCH_TOKEN = {
  type: 14
  /* SUBSTRING_MATCH_TOKEN */
};
var BAD_URL_TOKEN = {
  type: 23
  /* BAD_URL_TOKEN */
};
var BAD_STRING_TOKEN = {
  type: 1
  /* BAD_STRING_TOKEN */
};
var CDO_TOKEN = {
  type: 25
  /* CDO_TOKEN */
};
var CDC_TOKEN = {
  type: 24
  /* CDC_TOKEN */
};
var COLON_TOKEN = {
  type: 26
  /* COLON_TOKEN */
};
var SEMICOLON_TOKEN = {
  type: 27
  /* SEMICOLON_TOKEN */
};
var LEFT_SQUARE_BRACKET_TOKEN = {
  type: 28
  /* LEFT_SQUARE_BRACKET_TOKEN */
};
var RIGHT_SQUARE_BRACKET_TOKEN = {
  type: 29
  /* RIGHT_SQUARE_BRACKET_TOKEN */
};
var WHITESPACE_TOKEN = {
  type: 31
  /* WHITESPACE_TOKEN */
};
var EOF_TOKEN = {
  type: 32
  /* EOF_TOKEN */
};
var Tokenizer = (
  /** @class */
  function() {
    function Tokenizer2() {
      this._value = [];
    }
    Tokenizer2.prototype.write = function(chunk) {
      this._value = this._value.concat(toCodePoints$1(chunk));
    };
    Tokenizer2.prototype.read = function() {
      var tokens = [];
      var token2 = this.consumeToken();
      while (token2 !== EOF_TOKEN) {
        tokens.push(token2);
        token2 = this.consumeToken();
      }
      return tokens;
    };
    Tokenizer2.prototype.consumeToken = function() {
      var codePoint = this.consumeCodePoint();
      switch (codePoint) {
        case QUOTATION_MARK:
          return this.consumeStringToken(QUOTATION_MARK);
        case NUMBER_SIGN:
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
            var flags3 = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
            var value = this.consumeName();
            return { type: 5, value, flags: flags3 };
          }
          break;
        case DOLLAR_SIGN:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUFFIX_MATCH_TOKEN;
          }
          break;
        case APOSTROPHE:
          return this.consumeStringToken(APOSTROPHE);
        case LEFT_PARENTHESIS:
          return LEFT_PARENTHESIS_TOKEN;
        case RIGHT_PARENTHESIS:
          return RIGHT_PARENTHESIS_TOKEN;
        case ASTERISK:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUBSTRING_MATCH_TOKEN;
          }
          break;
        case PLUS_SIGN:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case COMMA:
          return COMMA_TOKEN;
        case HYPHEN_MINUS:
          var e1 = codePoint;
          var e2 = this.peekCodePoint(0);
          var e3 = this.peekCodePoint(1);
          if (isNumberStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          if (isIdentifierStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDC_TOKEN;
          }
          break;
        case FULL_STOP:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case SOLIDUS:
          if (this.peekCodePoint(0) === ASTERISK) {
            this.consumeCodePoint();
            while (true) {
              var c4 = this.consumeCodePoint();
              if (c4 === ASTERISK) {
                c4 = this.consumeCodePoint();
                if (c4 === SOLIDUS) {
                  return this.consumeToken();
                }
              }
              if (c4 === EOF) {
                return this.consumeToken();
              }
            }
          }
          break;
        case COLON:
          return COLON_TOKEN;
        case SEMICOLON:
          return SEMICOLON_TOKEN;
        case LESS_THAN_SIGN:
          if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDO_TOKEN;
          }
          break;
        case COMMERCIAL_AT:
          var a1 = this.peekCodePoint(0);
          var a2 = this.peekCodePoint(1);
          var a3 = this.peekCodePoint(2);
          if (isIdentifierStart(a1, a2, a3)) {
            var value = this.consumeName();
            return { type: 7, value };
          }
          break;
        case LEFT_SQUARE_BRACKET:
          return LEFT_SQUARE_BRACKET_TOKEN;
        case REVERSE_SOLIDUS:
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          break;
        case RIGHT_SQUARE_BRACKET:
          return RIGHT_SQUARE_BRACKET_TOKEN;
        case CIRCUMFLEX_ACCENT:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return PREFIX_MATCH_TOKEN;
          }
          break;
        case LEFT_CURLY_BRACKET:
          return LEFT_CURLY_BRACKET_TOKEN;
        case RIGHT_CURLY_BRACKET:
          return RIGHT_CURLY_BRACKET_TOKEN;
        case u$1:
        case U$1:
          var u1 = this.peekCodePoint(0);
          var u2 = this.peekCodePoint(1);
          if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
            this.consumeCodePoint();
            this.consumeUnicodeRangeToken();
          }
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        case VERTICAL_LINE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return DASH_MATCH_TOKEN;
          }
          if (this.peekCodePoint(0) === VERTICAL_LINE) {
            this.consumeCodePoint();
            return COLUMN_TOKEN;
          }
          break;
        case TILDE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return INCLUDE_MATCH_TOKEN;
          }
          break;
        case EOF:
          return EOF_TOKEN;
      }
      if (isWhiteSpace(codePoint)) {
        this.consumeWhiteSpace();
        return WHITESPACE_TOKEN;
      }
      if (isDigit(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeNumericToken();
      }
      if (isNameStartCodePoint(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeIdentLikeToken();
      }
      return { type: 6, value: fromCodePoint$1(codePoint) };
    };
    Tokenizer2.prototype.consumeCodePoint = function() {
      var value = this._value.shift();
      return typeof value === "undefined" ? -1 : value;
    };
    Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
      this._value.unshift(codePoint);
    };
    Tokenizer2.prototype.peekCodePoint = function(delta) {
      if (delta >= this._value.length) {
        return -1;
      }
      return this._value[delta];
    };
    Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
      var digits2 = [];
      var codePoint = this.consumeCodePoint();
      while (isHex(codePoint) && digits2.length < 6) {
        digits2.push(codePoint);
        codePoint = this.consumeCodePoint();
      }
      var questionMarks = false;
      while (codePoint === QUESTION_MARK && digits2.length < 6) {
        digits2.push(codePoint);
        codePoint = this.consumeCodePoint();
        questionMarks = true;
      }
      if (questionMarks) {
        var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits2.map(function(digit) {
          return digit === QUESTION_MARK ? ZERO : digit;
        })), 16);
        var end2 = parseInt(fromCodePoint$1.apply(void 0, digits2.map(function(digit) {
          return digit === QUESTION_MARK ? F$1 : digit;
        })), 16);
        return { type: 30, start: start_1, end: end2 };
      }
      var start2 = parseInt(fromCodePoint$1.apply(void 0, digits2), 16);
      if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
        this.consumeCodePoint();
        codePoint = this.consumeCodePoint();
        var endDigits = [];
        while (isHex(codePoint) && endDigits.length < 6) {
          endDigits.push(codePoint);
          codePoint = this.consumeCodePoint();
        }
        var end2 = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
        return { type: 30, start: start2, end: end2 };
      } else {
        return { type: 30, start: start2, end: start2 };
      }
    };
    Tokenizer2.prototype.consumeIdentLikeToken = function() {
      var value = this.consumeName();
      if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return this.consumeUrlToken();
      } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return { type: 19, value };
      }
      return { type: 20, value };
    };
    Tokenizer2.prototype.consumeUrlToken = function() {
      var value = [];
      this.consumeWhiteSpace();
      if (this.peekCodePoint(0) === EOF) {
        return { type: 22, value: "" };
      }
      var next2 = this.peekCodePoint(0);
      if (next2 === APOSTROPHE || next2 === QUOTATION_MARK) {
        var stringToken = this.consumeStringToken(this.consumeCodePoint());
        if (stringToken.type === 0) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: stringToken.value };
          }
        }
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      }
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
          return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
        } else if (isWhiteSpace(codePoint)) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
          }
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === REVERSE_SOLIDUS) {
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            value.push(this.consumeEscapedCodePoint());
          } else {
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          }
        } else {
          value.push(codePoint);
        }
      }
    };
    Tokenizer2.prototype.consumeWhiteSpace = function() {
      while (isWhiteSpace(this.peekCodePoint(0))) {
        this.consumeCodePoint();
      }
    };
    Tokenizer2.prototype.consumeBadUrlRemnants = function() {
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
          return;
        }
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          this.consumeEscapedCodePoint();
        }
      }
    };
    Tokenizer2.prototype.consumeStringSlice = function(count) {
      var SLICE_STACK_SIZE = 5e4;
      var value = "";
      while (count > 0) {
        var amount = Math.min(SLICE_STACK_SIZE, count);
        value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
        count -= amount;
      }
      this._value.shift();
      return value;
    };
    Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
      var value = "";
      var i2 = 0;
      do {
        var codePoint = this._value[i2];
        if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
          value += this.consumeStringSlice(i2);
          return { type: 0, value };
        }
        if (codePoint === LINE_FEED) {
          this._value.splice(0, i2);
          return BAD_STRING_TOKEN;
        }
        if (codePoint === REVERSE_SOLIDUS) {
          var next2 = this._value[i2 + 1];
          if (next2 !== EOF && next2 !== void 0) {
            if (next2 === LINE_FEED) {
              value += this.consumeStringSlice(i2);
              i2 = -1;
              this._value.shift();
            } else if (isValidEscape(codePoint, next2)) {
              value += this.consumeStringSlice(i2);
              value += fromCodePoint$1(this.consumeEscapedCodePoint());
              i2 = -1;
            }
          }
        }
        i2++;
      } while (true);
    };
    Tokenizer2.prototype.consumeNumber = function() {
      var repr = [];
      var type2 = FLAG_INTEGER;
      var c1 = this.peekCodePoint(0);
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
        repr.push(this.consumeCodePoint());
      }
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
      c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      if (c1 === FULL_STOP && isDigit(c2)) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type2 = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      c1 = this.peekCodePoint(0);
      c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if ((c1 === E$1 || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type2 = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      return [stringToNumber(repr), type2];
    };
    Tokenizer2.prototype.consumeNumericToken = function() {
      var _a2 = this.consumeNumber(), number2 = _a2[0], flags3 = _a2[1];
      var c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if (isIdentifierStart(c1, c2, c3)) {
        var unit = this.consumeName();
        return { type: 15, number: number2, flags: flags3, unit };
      }
      if (c1 === PERCENTAGE_SIGN) {
        this.consumeCodePoint();
        return { type: 16, number: number2, flags: flags3 };
      }
      return { type: 17, number: number2, flags: flags3 };
    };
    Tokenizer2.prototype.consumeEscapedCodePoint = function() {
      var codePoint = this.consumeCodePoint();
      if (isHex(codePoint)) {
        var hex = fromCodePoint$1(codePoint);
        while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
          hex += fromCodePoint$1(this.consumeCodePoint());
        }
        if (isWhiteSpace(this.peekCodePoint(0))) {
          this.consumeCodePoint();
        }
        var hexCodePoint = parseInt(hex, 16);
        if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
          return REPLACEMENT_CHARACTER;
        }
        return hexCodePoint;
      }
      if (codePoint === EOF) {
        return REPLACEMENT_CHARACTER;
      }
      return codePoint;
    };
    Tokenizer2.prototype.consumeName = function() {
      var result = "";
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (isNameCodePoint(codePoint)) {
          result += fromCodePoint$1(codePoint);
        } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          result += fromCodePoint$1(this.consumeEscapedCodePoint());
        } else {
          this.reconsumeCodePoint(codePoint);
          return result;
        }
      }
    };
    return Tokenizer2;
  }()
);
var Parser = (
  /** @class */
  function() {
    function Parser2(tokens) {
      this._tokens = tokens;
    }
    Parser2.create = function(value) {
      var tokenizer = new Tokenizer();
      tokenizer.write(value);
      return new Parser2(tokenizer.read());
    };
    Parser2.parseValue = function(value) {
      return Parser2.create(value).parseComponentValue();
    };
    Parser2.parseValues = function(value) {
      return Parser2.create(value).parseComponentValues();
    };
    Parser2.prototype.parseComponentValue = function() {
      var token2 = this.consumeToken();
      while (token2.type === 31) {
        token2 = this.consumeToken();
      }
      if (token2.type === 32) {
        throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      }
      this.reconsumeToken(token2);
      var value = this.consumeComponentValue();
      do {
        token2 = this.consumeToken();
      } while (token2.type === 31);
      if (token2.type === 32) {
        return value;
      }
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    };
    Parser2.prototype.parseComponentValues = function() {
      var values2 = [];
      while (true) {
        var value = this.consumeComponentValue();
        if (value.type === 32) {
          return values2;
        }
        values2.push(value);
        values2.push();
      }
    };
    Parser2.prototype.consumeComponentValue = function() {
      var token2 = this.consumeToken();
      switch (token2.type) {
        case 11:
        case 28:
        case 2:
          return this.consumeSimpleBlock(token2.type);
        case 19:
          return this.consumeFunction(token2);
      }
      return token2;
    };
    Parser2.prototype.consumeSimpleBlock = function(type2) {
      var block = { type: type2, values: [] };
      var token2 = this.consumeToken();
      while (true) {
        if (token2.type === 32 || isEndingTokenFor(token2, type2)) {
          return block;
        }
        this.reconsumeToken(token2);
        block.values.push(this.consumeComponentValue());
        token2 = this.consumeToken();
      }
    };
    Parser2.prototype.consumeFunction = function(functionToken) {
      var cssFunction = {
        name: functionToken.value,
        values: [],
        type: 18
        /* FUNCTION */
      };
      while (true) {
        var token2 = this.consumeToken();
        if (token2.type === 32 || token2.type === 3) {
          return cssFunction;
        }
        this.reconsumeToken(token2);
        cssFunction.values.push(this.consumeComponentValue());
      }
    };
    Parser2.prototype.consumeToken = function() {
      var token2 = this._tokens.shift();
      return typeof token2 === "undefined" ? EOF_TOKEN : token2;
    };
    Parser2.prototype.reconsumeToken = function(token2) {
      this._tokens.unshift(token2);
    };
    return Parser2;
  }()
);
var isDimensionToken = function(token2) {
  return token2.type === 15;
};
var isNumberToken = function(token2) {
  return token2.type === 17;
};
var isIdentToken = function(token2) {
  return token2.type === 20;
};
var isStringToken = function(token2) {
  return token2.type === 0;
};
var isIdentWithValue = function(token2, value) {
  return isIdentToken(token2) && token2.value === value;
};
var nonWhiteSpace = function(token2) {
  return token2.type !== 31;
};
var nonFunctionArgSeparator = function(token2) {
  return token2.type !== 31 && token2.type !== 4;
};
var parseFunctionArgs = function(tokens) {
  var args = [];
  var arg = [];
  tokens.forEach(function(token2) {
    if (token2.type === 4) {
      if (arg.length === 0) {
        throw new Error("Error parsing function args, zero tokens for arg");
      }
      args.push(arg);
      arg = [];
      return;
    }
    if (token2.type !== 31) {
      arg.push(token2);
    }
  });
  if (arg.length) {
    args.push(arg);
  }
  return args;
};
var isEndingTokenFor = function(token2, type2) {
  if (type2 === 11 && token2.type === 12) {
    return true;
  }
  if (type2 === 28 && token2.type === 29) {
    return true;
  }
  return type2 === 2 && token2.type === 3;
};
var isLength = function(token2) {
  return token2.type === 17 || token2.type === 15;
};
var isLengthPercentage = function(token2) {
  return token2.type === 16 || isLength(token2);
};
var parseLengthPercentageTuple = function(tokens) {
  return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
};
var ZERO_LENGTH = {
  type: 17,
  number: 0,
  flags: FLAG_INTEGER
};
var FIFTY_PERCENT = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var HUNDRED_PERCENT = {
  type: 16,
  number: 100,
  flags: FLAG_INTEGER
};
var getAbsoluteValueForTuple = function(tuple2, width2, height2) {
  var x2 = tuple2[0], y2 = tuple2[1];
  return [getAbsoluteValue(x2, width2), getAbsoluteValue(typeof y2 !== "undefined" ? y2 : x2, height2)];
};
var getAbsoluteValue = function(token2, parent) {
  if (token2.type === 16) {
    return token2.number / 100 * parent;
  }
  if (isDimensionToken(token2)) {
    switch (token2.unit) {
      case "rem":
      case "em":
        return 16 * token2.number;
      case "px":
      default:
        return token2.number;
    }
  }
  return token2.number;
};
var DEG = "deg";
var GRAD = "grad";
var RAD = "rad";
var TURN = "turn";
var angle = {
  name: "angle",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit) {
        case DEG:
          return Math.PI * value.number / 180;
        case GRAD:
          return Math.PI / 200 * value.number;
        case RAD:
          return value.number;
        case TURN:
          return Math.PI * 2 * value.number;
      }
    }
    throw new Error("Unsupported angle type");
  }
};
var isAngle = function(value) {
  if (value.type === 15) {
    if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
      return true;
    }
  }
  return false;
};
var parseNamedSide = function(tokens) {
  var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
    return ident.value;
  }).join(" ");
  switch (sideOrCorner) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [ZERO_LENGTH, ZERO_LENGTH];
    case "to top":
    case "bottom":
      return deg(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [ZERO_LENGTH, HUNDRED_PERCENT];
    case "to right":
    case "left":
      return deg(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [HUNDRED_PERCENT, HUNDRED_PERCENT];
    case "to bottom":
    case "top":
      return deg(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [HUNDRED_PERCENT, ZERO_LENGTH];
    case "to left":
    case "right":
      return deg(270);
  }
  return 0;
};
var deg = function(deg2) {
  return Math.PI * deg2 / 180;
};
var color$1 = {
  name: "color",
  parse: function(context, value) {
    if (value.type === 18) {
      var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
      if (typeof colorFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
      }
      return colorFunction(context, value.values);
    }
    if (value.type === 5) {
      if (value.value.length === 3) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);
      }
      if (value.value.length === 4) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        var a2 = value.value.substring(3, 4);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a2 + a2, 16) / 255);
      }
      if (value.value.length === 6) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), 1);
      }
      if (value.value.length === 8) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        var a2 = value.value.substring(6, 8);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a2, 16) / 255);
      }
    }
    if (value.type === 20) {
      var namedColor = COLORS[value.value.toUpperCase()];
      if (typeof namedColor !== "undefined") {
        return namedColor;
      }
    }
    return COLORS.TRANSPARENT;
  }
};
var isTransparent = function(color2) {
  return (255 & color2) === 0;
};
var asString = function(color2) {
  var alpha2 = 255 & color2;
  var blue2 = 255 & color2 >> 8;
  var green2 = 255 & color2 >> 16;
  var red2 = 255 & color2 >> 24;
  return alpha2 < 255 ? "rgba(" + red2 + "," + green2 + "," + blue2 + "," + alpha2 / 255 + ")" : "rgb(" + red2 + "," + green2 + "," + blue2 + ")";
};
var pack = function(r2, g2, b2, a2) {
  return (r2 << 24 | g2 << 16 | b2 << 8 | Math.round(a2 * 255) << 0) >>> 0;
};
var getTokenColorValue = function(token2, i2) {
  if (token2.type === 17) {
    return token2.number;
  }
  if (token2.type === 16) {
    var max2 = i2 === 3 ? 1 : 255;
    return i2 === 3 ? token2.number / 100 * max2 : Math.round(token2.number / 100 * max2);
  }
  return 0;
};
var rgb = function(_context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  if (tokens.length === 3) {
    var _a2 = tokens.map(getTokenColorValue), r2 = _a2[0], g2 = _a2[1], b2 = _a2[2];
    return pack(r2, g2, b2, 1);
  }
  if (tokens.length === 4) {
    var _b2 = tokens.map(getTokenColorValue), r2 = _b2[0], g2 = _b2[1], b2 = _b2[2], a2 = _b2[3];
    return pack(r2, g2, b2, a2);
  }
  return 0;
};
function hue2rgb(t1, t22, hue) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue >= 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return (t22 - t1) * hue * 6 + t1;
  } else if (hue < 1 / 2) {
    return t22;
  } else if (hue < 2 / 3) {
    return (t22 - t1) * 6 * (2 / 3 - hue) + t1;
  } else {
    return t1;
  }
}
var hsl = function(context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha2 = tokens[3];
  var h2 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
  var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
  var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
  var a2 = typeof alpha2 !== "undefined" && isLengthPercentage(alpha2) ? getAbsoluteValue(alpha2, 1) : 1;
  if (s2 === 0) {
    return pack(l2 * 255, l2 * 255, l2 * 255, 1);
  }
  var t22 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
  var t1 = l2 * 2 - t22;
  var r2 = hue2rgb(t1, t22, h2 + 1 / 3);
  var g2 = hue2rgb(t1, t22, h2);
  var b2 = hue2rgb(t1, t22, h2 - 1 / 3);
  return pack(r2 * 255, g2 * 255, b2 * 255, a2);
};
var SUPPORTED_COLOR_FUNCTIONS = {
  hsl,
  hsla: hsl,
  rgb,
  rgba: rgb
};
var parseColor = function(context, value) {
  return color$1.parse(context, Parser.create(value).parseComponentValue());
};
var COLORS = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
};
var backgroundClip = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token2) {
      if (isIdentToken(token2)) {
        switch (token2.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundColor = {
  name: "background-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var parseColorStop = function(context, args) {
  var color2 = color$1.parse(context, args[0]);
  var stop = args[1];
  return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
};
var processColorStops = function(stops, lineLength) {
  var first = stops[0];
  var last2 = stops[stops.length - 1];
  if (first.stop === null) {
    first.stop = ZERO_LENGTH;
  }
  if (last2.stop === null) {
    last2.stop = HUNDRED_PERCENT;
  }
  var processStops = [];
  var previous = 0;
  for (var i2 = 0; i2 < stops.length; i2++) {
    var stop_1 = stops[i2].stop;
    if (stop_1 !== null) {
      var absoluteValue = getAbsoluteValue(stop_1, lineLength);
      if (absoluteValue > previous) {
        processStops.push(absoluteValue);
      } else {
        processStops.push(previous);
      }
      previous = absoluteValue;
    } else {
      processStops.push(null);
    }
  }
  var gapBegin = null;
  for (var i2 = 0; i2 < processStops.length; i2++) {
    var stop_2 = processStops[i2];
    if (stop_2 === null) {
      if (gapBegin === null) {
        gapBegin = i2;
      }
    } else if (gapBegin !== null) {
      var gapLength = i2 - gapBegin;
      var beforeGap = processStops[gapBegin - 1];
      var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
      for (var g2 = 1; g2 <= gapLength; g2++) {
        processStops[gapBegin + g2 - 1] = gapValue * g2;
      }
      gapBegin = null;
    }
  }
  return stops.map(function(_a2, i3) {
    var color2 = _a2.color;
    return { color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0) };
  });
};
var getAngleFromCorner = function(corner, width2, height2) {
  var centerX = width2 / 2;
  var centerY = height2 / 2;
  var x2 = getAbsoluteValue(corner[0], width2) - centerX;
  var y2 = centerY - getAbsoluteValue(corner[1], height2);
  return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);
};
var calculateGradientDirection = function(angle2, width2, height2) {
  var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width2, height2);
  var lineLength = Math.abs(width2 * Math.sin(radian)) + Math.abs(height2 * Math.cos(radian));
  var halfWidth = width2 / 2;
  var halfHeight = height2 / 2;
  var halfLineLength = lineLength / 2;
  var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
  var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
  return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
};
var distance = function(a2, b2) {
  return Math.sqrt(a2 * a2 + b2 * b2);
};
var findCorner = function(width2, height2, x2, y2, closest) {
  var corners = [
    [0, 0],
    [0, height2],
    [width2, 0],
    [width2, height2]
  ];
  return corners.reduce(function(stat, corner) {
    var cx = corner[0], cy = corner[1];
    var d2 = distance(x2 - cx, y2 - cy);
    if (closest ? d2 < stat.optimumDistance : d2 > stat.optimumDistance) {
      return {
        optimumCorner: corner,
        optimumDistance: d2
      };
    }
    return stat;
  }, {
    optimumDistance: closest ? Infinity : -Infinity,
    optimumCorner: null
  }).optimumCorner;
};
var calculateRadius = function(gradient, x2, y2, width2, height2) {
  var rx = 0;
  var ry = 0;
  switch (gradient.size) {
    case 0:
      if (gradient.shape === 0) {
        rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width2), Math.abs(y2), Math.abs(y2 - height2));
      } else if (gradient.shape === 1) {
        rx = Math.min(Math.abs(x2), Math.abs(x2 - width2));
        ry = Math.min(Math.abs(y2), Math.abs(y2 - height2));
      }
      break;
    case 2:
      if (gradient.shape === 0) {
        rx = ry = Math.min(distance(x2, y2), distance(x2, y2 - height2), distance(x2 - width2, y2), distance(x2 - width2, y2 - height2));
      } else if (gradient.shape === 1) {
        var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height2)) / Math.min(Math.abs(x2), Math.abs(x2 - width2));
        var _a2 = findCorner(width2, height2, x2, y2, true), cx = _a2[0], cy = _a2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
    case 1:
      if (gradient.shape === 0) {
        rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width2), Math.abs(y2), Math.abs(y2 - height2));
      } else if (gradient.shape === 1) {
        rx = Math.max(Math.abs(x2), Math.abs(x2 - width2));
        ry = Math.max(Math.abs(y2), Math.abs(y2 - height2));
      }
      break;
    case 3:
      if (gradient.shape === 0) {
        rx = ry = Math.max(distance(x2, y2), distance(x2, y2 - height2), distance(x2 - width2, y2), distance(x2 - width2, y2 - height2));
      } else if (gradient.shape === 1) {
        var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height2)) / Math.max(Math.abs(x2), Math.abs(x2 - width2));
        var _b2 = findCorner(width2, height2, x2, y2, false), cx = _b2[0], cy = _b2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
  }
  if (Array.isArray(gradient.size)) {
    rx = getAbsoluteValue(gradient.size[0], width2);
    ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height2) : rx;
  }
  return [rx, ry];
};
var linearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && firstToken.value === "to") {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = angle.parse(context, firstToken);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var prefixLinearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var webkitGradient = function(context, tokens) {
  var angle2 = deg(180);
  var stops = [];
  var type2 = 1;
  var shape2 = 0;
  var size = 3;
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var firstToken = arg[0];
    if (i2 === 0) {
      if (isIdentToken(firstToken) && firstToken.value === "linear") {
        type2 = 1;
        return;
      } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
        type2 = 2;
        return;
      }
    }
    if (firstToken.type === 18) {
      if (firstToken.name === "from") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: ZERO_LENGTH, color: color2 });
      } else if (firstToken.name === "to") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: HUNDRED_PERCENT, color: color2 });
      } else if (firstToken.name === "color-stop") {
        var values2 = firstToken.values.filter(nonFunctionArgSeparator);
        if (values2.length === 2) {
          var color2 = color$1.parse(context, values2[1]);
          var stop_1 = values2[0];
          if (isNumberToken(stop_1)) {
            stops.push({
              stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
              color: color2
            });
          }
        }
      }
    }
  });
  return type2 === 1 ? {
    angle: (angle2 + deg(180)) % deg(360),
    stops,
    type: type2
  } : { size, shape: shape2, stops, position: position2, type: type2 };
};
var CLOSEST_SIDE = "closest-side";
var FARTHEST_SIDE = "farthest-side";
var CLOSEST_CORNER = "closest-corner";
var FARTHEST_CORNER = "farthest-corner";
var CIRCLE = "circle";
var ELLIPSE = "ellipse";
var COVER = "cover";
var CONTAIN = "contain";
var radialGradient = function(context, tokens) {
  var shape2 = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      var isAtPosition_1 = false;
      isColorStop = arg.reduce(function(acc, token2) {
        if (isAtPosition_1) {
          if (isIdentToken(token2)) {
            switch (token2.value) {
              case "center":
                position2.push(FIFTY_PERCENT);
                return acc;
              case "top":
              case "left":
                position2.push(ZERO_LENGTH);
                return acc;
              case "right":
              case "bottom":
                position2.push(HUNDRED_PERCENT);
                return acc;
            }
          } else if (isLengthPercentage(token2) || isLength(token2)) {
            position2.push(token2);
          }
        } else if (isIdentToken(token2)) {
          switch (token2.value) {
            case CIRCLE:
              shape2 = 0;
              return false;
            case ELLIPSE:
              shape2 = 1;
              return false;
            case "at":
              isAtPosition_1 = true;
              return false;
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case COVER:
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CONTAIN:
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token2) || isLengthPercentage(token2)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token2);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size,
    shape: shape2,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var prefixRadialGradient = function(context, tokens) {
  var shape2 = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      isColorStop = arg.reduce(function(acc, token2) {
        if (isIdentToken(token2)) {
          switch (token2.value) {
            case "center":
              position2.push(FIFTY_PERCENT);
              return false;
            case "top":
            case "left":
              position2.push(ZERO_LENGTH);
              return false;
            case "right":
            case "bottom":
              position2.push(HUNDRED_PERCENT);
              return false;
          }
        } else if (isLengthPercentage(token2) || isLength(token2)) {
          position2.push(token2);
          return false;
        }
        return acc;
      }, isColorStop);
    } else if (i2 === 1) {
      isColorStop = arg.reduce(function(acc, token2) {
        if (isIdentToken(token2)) {
          switch (token2.value) {
            case CIRCLE:
              shape2 = 0;
              return false;
            case ELLIPSE:
              shape2 = 1;
              return false;
            case CONTAIN:
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case COVER:
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token2) || isLengthPercentage(token2)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token2);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size,
    shape: shape2,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var isLinearGradient = function(background) {
  return background.type === 1;
};
var isRadialGradient = function(background) {
  return background.type === 2;
};
var image = {
  name: "image",
  parse: function(context, value) {
    if (value.type === 22) {
      var image_1 = {
        url: value.value,
        type: 0
        /* URL */
      };
      context.cache.addImage(value.value);
      return image_1;
    }
    if (value.type === 18) {
      var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
      if (typeof imageFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
      }
      return imageFunction(context, value.values);
    }
    throw new Error("Unsupported image type " + value.type);
  }
};
function isSupportedImage(value) {
  return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
}
var SUPPORTED_IMAGE_FUNCTIONS = {
  "linear-gradient": linearGradient,
  "-moz-linear-gradient": prefixLinearGradient,
  "-ms-linear-gradient": prefixLinearGradient,
  "-o-linear-gradient": prefixLinearGradient,
  "-webkit-linear-gradient": prefixLinearGradient,
  "radial-gradient": radialGradient,
  "-moz-radial-gradient": prefixRadialGradient,
  "-ms-radial-gradient": prefixRadialGradient,
  "-o-radial-gradient": prefixRadialGradient,
  "-webkit-radial-gradient": prefixRadialGradient,
  "-webkit-gradient": webkitGradient
};
var backgroundImage = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens.filter(function(value) {
      return nonFunctionArgSeparator(value) && isSupportedImage(value);
    }).map(function(value) {
      return image.parse(context, value);
    });
  }
};
var backgroundOrigin = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token2) {
      if (isIdentToken(token2)) {
        switch (token2.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundPosition = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values2) {
      return values2.filter(isLengthPercentage);
    }).map(parseLengthPercentageTuple);
  }
};
var backgroundRepeat = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values2) {
      return values2.filter(isIdentToken).map(function(token2) {
        return token2.value;
      }).join(" ");
    }).map(parseBackgroundRepeat);
  }
};
var parseBackgroundRepeat = function(value) {
  switch (value) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
};
var BACKGROUND_SIZE;
(function(BACKGROUND_SIZE2) {
  BACKGROUND_SIZE2["AUTO"] = "auto";
  BACKGROUND_SIZE2["CONTAIN"] = "contain";
  BACKGROUND_SIZE2["COVER"] = "cover";
})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
var backgroundSize = {
  name: "background-size",
  initialValue: "0",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values2) {
      return values2.filter(isBackgroundSizeInfoToken);
    });
  }
};
var isBackgroundSizeInfoToken = function(value) {
  return isIdentToken(value) || isLengthPercentage(value);
};
var borderColorForSide = function(side) {
  return {
    name: "border-" + side + "-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
};
var borderTopColor = borderColorForSide("top");
var borderRightColor = borderColorForSide("right");
var borderBottomColor = borderColorForSide("bottom");
var borderLeftColor = borderColorForSide("left");
var borderRadiusForSide = function(side) {
  return {
    name: "border-radius-" + side,
    initialValue: "0 0",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
    }
  };
};
var borderTopLeftRadius = borderRadiusForSide("top-left");
var borderTopRightRadius = borderRadiusForSide("top-right");
var borderBottomRightRadius = borderRadiusForSide("bottom-right");
var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
var borderStyleForSide = function(side) {
  return {
    name: "border-" + side + "-style",
    initialValue: "solid",
    prefix: false,
    type: 2,
    parse: function(_context, style2) {
      switch (style2) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
};
var borderTopStyle = borderStyleForSide("top");
var borderRightStyle = borderStyleForSide("right");
var borderBottomStyle = borderStyleForSide("bottom");
var borderLeftStyle = borderStyleForSide("left");
var borderWidthForSide = function(side) {
  return {
    name: "border-" + side + "-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(_context, token2) {
      if (isDimensionToken(token2)) {
        return token2.number;
      }
      return 0;
    }
  };
};
var borderTopWidth = borderWidthForSide("top");
var borderRightWidth = borderWidthForSide("right");
var borderBottomWidth = borderWidthForSide("bottom");
var borderLeftWidth = borderWidthForSide("left");
var color = {
  name: "color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var direction = {
  name: "direction",
  initialValue: "ltr",
  prefix: false,
  type: 2,
  parse: function(_context, direction2) {
    switch (direction2) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
};
var display = {
  name: "display",
  initialValue: "inline-block",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).reduce(
      function(bit, token2) {
        return bit | parseDisplayValue(token2.value);
      },
      0
      /* NONE */
    );
  }
};
var parseDisplayValue = function(display2) {
  switch (display2) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
};
var float = {
  name: "float",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, float2) {
    switch (float2) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
};
var letterSpacing = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: false,
  type: 0,
  parse: function(_context, token2) {
    if (token2.type === 20 && token2.value === "normal") {
      return 0;
    }
    if (token2.type === 17) {
      return token2.number;
    }
    if (token2.type === 15) {
      return token2.number;
    }
    return 0;
  }
};
var LINE_BREAK;
(function(LINE_BREAK2) {
  LINE_BREAK2["NORMAL"] = "normal";
  LINE_BREAK2["STRICT"] = "strict";
})(LINE_BREAK || (LINE_BREAK = {}));
var lineBreak = {
  name: "line-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, lineBreak2) {
    switch (lineBreak2) {
      case "strict":
        return LINE_BREAK.STRICT;
      case "normal":
      default:
        return LINE_BREAK.NORMAL;
    }
  }
};
var lineHeight = {
  name: "line-height",
  initialValue: "normal",
  prefix: false,
  type: 4
  /* TOKEN_VALUE */
};
var computeLineHeight = function(token2, fontSize2) {
  if (isIdentToken(token2) && token2.value === "normal") {
    return 1.2 * fontSize2;
  } else if (token2.type === 17) {
    return fontSize2 * token2.number;
  } else if (isLengthPercentage(token2)) {
    return getAbsoluteValue(token2, fontSize2);
  }
  return fontSize2;
};
var listStyleImage = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: false,
  parse: function(context, token2) {
    if (token2.type === 20 && token2.value === "none") {
      return null;
    }
    return image.parse(context, token2);
  }
};
var listStylePosition = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
};
var listStyleType = {
  name: "list-style-type",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, type2) {
    switch (type2) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
};
var marginForSide = function(side) {
  return {
    name: "margin-" + side,
    initialValue: "0",
    prefix: false,
    type: 4
    /* TOKEN_VALUE */
  };
};
var marginTop = marginForSide("top");
var marginRight = marginForSide("right");
var marginBottom = marginForSide("bottom");
var marginLeft = marginForSide("left");
var overflow = {
  name: "overflow",
  initialValue: "visible",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(overflow2) {
      switch (overflow2.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
};
var overflowWrap = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
};
var paddingForSide = function(side) {
  return {
    name: "padding-" + side,
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length-percentage"
  };
};
var paddingTop = paddingForSide("top");
var paddingRight = paddingForSide("right");
var paddingBottom = paddingForSide("bottom");
var paddingLeft = paddingForSide("left");
var textAlign = {
  name: "text-align",
  initialValue: "left",
  prefix: false,
  type: 2,
  parse: function(_context, textAlign2) {
    switch (textAlign2) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
};
var position = {
  name: "position",
  initialValue: "static",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
};
var textShadow = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values2) {
      var shadow = {
        color: COLORS.TRANSPARENT,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values2.length; i2++) {
        var token2 = values2[i2];
        if (isLength(token2)) {
          if (c2 === 0) {
            shadow.offsetX = token2;
          } else if (c2 === 1) {
            shadow.offsetY = token2;
          } else {
            shadow.blur = token2;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token2);
        }
      }
      return shadow;
    });
  }
};
var textTransform = {
  name: "text-transform",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, textTransform2) {
    switch (textTransform2) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
};
var transform$1 = {
  name: "transform",
  initialValue: "none",
  prefix: true,
  type: 0,
  parse: function(_context, token2) {
    if (token2.type === 20 && token2.value === "none") {
      return null;
    }
    if (token2.type === 18) {
      var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token2.name];
      if (typeof transformFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported transform function "' + token2.name + '"');
      }
      return transformFunction(token2.values);
    }
    return null;
  }
};
var matrix = function(args) {
  var values2 = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  return values2.length === 6 ? values2 : null;
};
var matrix3d = function(args) {
  var values2 = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  var a1 = values2[0], b1 = values2[1];
  values2[2];
  values2[3];
  var a2 = values2[4], b2 = values2[5];
  values2[6];
  values2[7];
  values2[8];
  values2[9];
  values2[10];
  values2[11];
  var a4 = values2[12], b4 = values2[13];
  values2[14];
  values2[15];
  return values2.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
};
var SUPPORTED_TRANSFORM_FUNCTIONS = {
  matrix,
  matrix3d
};
var DEFAULT_VALUE = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
var transformOrigin = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    var origins = tokens.filter(isLengthPercentage);
    if (origins.length !== 2) {
      return DEFAULT;
    }
    return [origins[0], origins[1]];
  }
};
var visibility = {
  name: "visible",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, visibility2) {
    switch (visibility2) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
};
var WORD_BREAK;
(function(WORD_BREAK2) {
  WORD_BREAK2["NORMAL"] = "normal";
  WORD_BREAK2["BREAK_ALL"] = "break-all";
  WORD_BREAK2["KEEP_ALL"] = "keep-all";
})(WORD_BREAK || (WORD_BREAK = {}));
var wordBreak = {
  name: "word-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, wordBreak2) {
    switch (wordBreak2) {
      case "break-all":
        return WORD_BREAK.BREAK_ALL;
      case "keep-all":
        return WORD_BREAK.KEEP_ALL;
      case "normal":
      default:
        return WORD_BREAK.NORMAL;
    }
  }
};
var zIndex = {
  name: "z-index",
  initialValue: "auto",
  prefix: false,
  type: 0,
  parse: function(_context, token2) {
    if (token2.type === 20) {
      return { auto: true, order: 0 };
    }
    if (isNumberToken(token2)) {
      return { auto: false, order: token2.number };
    }
    throw new Error("Invalid z-index number parsed");
  }
};
var time = {
  name: "time",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit.toLowerCase()) {
        case "s":
          return 1e3 * value.number;
        case "ms":
          return value.number;
      }
    }
    throw new Error("Unsupported time type");
  }
};
var opacity = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: false,
  parse: function(_context, token2) {
    if (isNumberToken(token2)) {
      return token2.number;
    }
    return 1;
  }
};
var textDecorationColor = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var textDecorationLine = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token2) {
      switch (token2.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(line2) {
      return line2 !== 0;
    });
  }
};
var fontFamily = {
  name: "font-family",
  initialValue: "",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var accumulator = [];
    var results = [];
    tokens.forEach(function(token2) {
      switch (token2.type) {
        case 20:
        case 0:
          accumulator.push(token2.value);
          break;
        case 17:
          accumulator.push(token2.number.toString());
          break;
        case 4:
          results.push(accumulator.join(" "));
          accumulator.length = 0;
          break;
      }
    });
    if (accumulator.length) {
      results.push(accumulator.join(" "));
    }
    return results.map(function(result) {
      return result.indexOf(" ") === -1 ? result : "'" + result + "'";
    });
  }
};
var fontSize = {
  name: "font-size",
  initialValue: "0",
  prefix: false,
  type: 3,
  format: "length"
};
var fontWeight = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: false,
  parse: function(_context, token2) {
    if (isNumberToken(token2)) {
      return token2.number;
    }
    if (isIdentToken(token2)) {
      switch (token2.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    }
    return 400;
  }
};
var fontVariant = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token2) {
      return token2.value;
    });
  }
};
var fontStyle = {
  name: "font-style",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
};
var contains = function(bit, value) {
  return (bit & value) !== 0;
};
var content = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens;
  }
};
var counterIncrement = {
  name: "counter-increment",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var increments = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i2 = 0; i2 < filtered.length; i2++) {
      var counter2 = filtered[i2];
      var next2 = filtered[i2 + 1];
      if (counter2.type === 20) {
        var increment = next2 && isNumberToken(next2) ? next2.number : 1;
        increments.push({ counter: counter2.value, increment });
      }
    }
    return increments;
  }
};
var counterReset = {
  name: "counter-reset",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var resets = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i2 = 0; i2 < filtered.length; i2++) {
      var counter2 = filtered[i2];
      var next2 = filtered[i2 + 1];
      if (isIdentToken(counter2) && counter2.value !== "none") {
        var reset = next2 && isNumberToken(next2) ? next2.number : 0;
        resets.push({ counter: counter2.value, reset });
      }
    }
    return resets;
  }
};
var duration = {
  name: "duration",
  initialValue: "0s",
  prefix: false,
  type: 1,
  parse: function(context, tokens) {
    return tokens.filter(isDimensionToken).map(function(token2) {
      return time.parse(context, token2);
    });
  }
};
var quotes = {
  name: "quotes",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var quotes2 = [];
    var filtered = tokens.filter(isStringToken);
    if (filtered.length % 2 !== 0) {
      return null;
    }
    for (var i2 = 0; i2 < filtered.length; i2 += 2) {
      var open_1 = filtered[i2].value;
      var close_1 = filtered[i2 + 1].value;
      quotes2.push({ open: open_1, close: close_1 });
    }
    return quotes2;
  }
};
var getQuote = function(quotes2, depth, open2) {
  if (!quotes2) {
    return "";
  }
  var quote = quotes2[Math.min(depth, quotes2.length - 1)];
  if (!quote) {
    return "";
  }
  return open2 ? quote.open : quote.close;
};
var boxShadow = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values2) {
      var shadow = {
        color: 255,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH,
        spread: ZERO_LENGTH,
        inset: false
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values2.length; i2++) {
        var token2 = values2[i2];
        if (isIdentWithValue(token2, "inset")) {
          shadow.inset = true;
        } else if (isLength(token2)) {
          if (c2 === 0) {
            shadow.offsetX = token2;
          } else if (c2 === 1) {
            shadow.offsetY = token2;
          } else if (c2 === 2) {
            shadow.blur = token2;
          } else {
            shadow.spread = token2;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token2);
        }
      }
      return shadow;
    });
  }
};
var paintOrder = {
  name: "paint-order",
  initialValue: "normal",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var DEFAULT_VALUE2 = [
      0,
      1,
      2
      /* MARKERS */
    ];
    var layers = [];
    tokens.filter(isIdentToken).forEach(function(token2) {
      switch (token2.value) {
        case "stroke":
          layers.push(
            1
            /* STROKE */
          );
          break;
        case "fill":
          layers.push(
            0
            /* FILL */
          );
          break;
        case "markers":
          layers.push(
            2
            /* MARKERS */
          );
          break;
      }
    });
    DEFAULT_VALUE2.forEach(function(value) {
      if (layers.indexOf(value) === -1) {
        layers.push(value);
      }
    });
    return layers;
  }
};
var webkitTextStrokeColor = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: false,
  type: 3,
  format: "color"
};
var webkitTextStrokeWidth = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: false,
  parse: function(_context, token2) {
    if (isDimensionToken(token2)) {
      return token2.number;
    }
    return 0;
  }
};
var CSSParsedDeclaration = (
  /** @class */
  function() {
    function CSSParsedDeclaration2(context, declaration2) {
      var _a2, _b2;
      this.animationDuration = parse(context, duration, declaration2.animationDuration);
      this.backgroundClip = parse(context, backgroundClip, declaration2.backgroundClip);
      this.backgroundColor = parse(context, backgroundColor, declaration2.backgroundColor);
      this.backgroundImage = parse(context, backgroundImage, declaration2.backgroundImage);
      this.backgroundOrigin = parse(context, backgroundOrigin, declaration2.backgroundOrigin);
      this.backgroundPosition = parse(context, backgroundPosition, declaration2.backgroundPosition);
      this.backgroundRepeat = parse(context, backgroundRepeat, declaration2.backgroundRepeat);
      this.backgroundSize = parse(context, backgroundSize, declaration2.backgroundSize);
      this.borderTopColor = parse(context, borderTopColor, declaration2.borderTopColor);
      this.borderRightColor = parse(context, borderRightColor, declaration2.borderRightColor);
      this.borderBottomColor = parse(context, borderBottomColor, declaration2.borderBottomColor);
      this.borderLeftColor = parse(context, borderLeftColor, declaration2.borderLeftColor);
      this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration2.borderTopLeftRadius);
      this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration2.borderTopRightRadius);
      this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration2.borderBottomRightRadius);
      this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration2.borderBottomLeftRadius);
      this.borderTopStyle = parse(context, borderTopStyle, declaration2.borderTopStyle);
      this.borderRightStyle = parse(context, borderRightStyle, declaration2.borderRightStyle);
      this.borderBottomStyle = parse(context, borderBottomStyle, declaration2.borderBottomStyle);
      this.borderLeftStyle = parse(context, borderLeftStyle, declaration2.borderLeftStyle);
      this.borderTopWidth = parse(context, borderTopWidth, declaration2.borderTopWidth);
      this.borderRightWidth = parse(context, borderRightWidth, declaration2.borderRightWidth);
      this.borderBottomWidth = parse(context, borderBottomWidth, declaration2.borderBottomWidth);
      this.borderLeftWidth = parse(context, borderLeftWidth, declaration2.borderLeftWidth);
      this.boxShadow = parse(context, boxShadow, declaration2.boxShadow);
      this.color = parse(context, color, declaration2.color);
      this.direction = parse(context, direction, declaration2.direction);
      this.display = parse(context, display, declaration2.display);
      this.float = parse(context, float, declaration2.cssFloat);
      this.fontFamily = parse(context, fontFamily, declaration2.fontFamily);
      this.fontSize = parse(context, fontSize, declaration2.fontSize);
      this.fontStyle = parse(context, fontStyle, declaration2.fontStyle);
      this.fontVariant = parse(context, fontVariant, declaration2.fontVariant);
      this.fontWeight = parse(context, fontWeight, declaration2.fontWeight);
      this.letterSpacing = parse(context, letterSpacing, declaration2.letterSpacing);
      this.lineBreak = parse(context, lineBreak, declaration2.lineBreak);
      this.lineHeight = parse(context, lineHeight, declaration2.lineHeight);
      this.listStyleImage = parse(context, listStyleImage, declaration2.listStyleImage);
      this.listStylePosition = parse(context, listStylePosition, declaration2.listStylePosition);
      this.listStyleType = parse(context, listStyleType, declaration2.listStyleType);
      this.marginTop = parse(context, marginTop, declaration2.marginTop);
      this.marginRight = parse(context, marginRight, declaration2.marginRight);
      this.marginBottom = parse(context, marginBottom, declaration2.marginBottom);
      this.marginLeft = parse(context, marginLeft, declaration2.marginLeft);
      this.opacity = parse(context, opacity, declaration2.opacity);
      var overflowTuple = parse(context, overflow, declaration2.overflow);
      this.overflowX = overflowTuple[0];
      this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
      this.overflowWrap = parse(context, overflowWrap, declaration2.overflowWrap);
      this.paddingTop = parse(context, paddingTop, declaration2.paddingTop);
      this.paddingRight = parse(context, paddingRight, declaration2.paddingRight);
      this.paddingBottom = parse(context, paddingBottom, declaration2.paddingBottom);
      this.paddingLeft = parse(context, paddingLeft, declaration2.paddingLeft);
      this.paintOrder = parse(context, paintOrder, declaration2.paintOrder);
      this.position = parse(context, position, declaration2.position);
      this.textAlign = parse(context, textAlign, declaration2.textAlign);
      this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration2.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration2.color);
      this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration2.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration2.textDecoration);
      this.textShadow = parse(context, textShadow, declaration2.textShadow);
      this.textTransform = parse(context, textTransform, declaration2.textTransform);
      this.transform = parse(context, transform$1, declaration2.transform);
      this.transformOrigin = parse(context, transformOrigin, declaration2.transformOrigin);
      this.visibility = parse(context, visibility, declaration2.visibility);
      this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration2.webkitTextStrokeColor);
      this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration2.webkitTextStrokeWidth);
      this.wordBreak = parse(context, wordBreak, declaration2.wordBreak);
      this.zIndex = parse(context, zIndex, declaration2.zIndex);
    }
    CSSParsedDeclaration2.prototype.isVisible = function() {
      return this.display > 0 && this.opacity > 0 && this.visibility === 0;
    };
    CSSParsedDeclaration2.prototype.isTransparent = function() {
      return isTransparent(this.backgroundColor);
    };
    CSSParsedDeclaration2.prototype.isTransformed = function() {
      return this.transform !== null;
    };
    CSSParsedDeclaration2.prototype.isPositioned = function() {
      return this.position !== 0;
    };
    CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
      return this.isPositioned() && !this.zIndex.auto;
    };
    CSSParsedDeclaration2.prototype.isFloating = function() {
      return this.float !== 0;
    };
    CSSParsedDeclaration2.prototype.isInlineLevel = function() {
      return contains(
        this.display,
        4
        /* INLINE */
      ) || contains(
        this.display,
        33554432
        /* INLINE_BLOCK */
      ) || contains(
        this.display,
        268435456
        /* INLINE_FLEX */
      ) || contains(
        this.display,
        536870912
        /* INLINE_GRID */
      ) || contains(
        this.display,
        67108864
        /* INLINE_LIST_ITEM */
      ) || contains(
        this.display,
        134217728
        /* INLINE_TABLE */
      );
    };
    return CSSParsedDeclaration2;
  }()
);
var CSSParsedPseudoDeclaration = (
  /** @class */
  function() {
    function CSSParsedPseudoDeclaration2(context, declaration2) {
      this.content = parse(context, content, declaration2.content);
      this.quotes = parse(context, quotes, declaration2.quotes);
    }
    return CSSParsedPseudoDeclaration2;
  }()
);
var CSSParsedCounterDeclaration = (
  /** @class */
  function() {
    function CSSParsedCounterDeclaration2(context, declaration2) {
      this.counterIncrement = parse(context, counterIncrement, declaration2.counterIncrement);
      this.counterReset = parse(context, counterReset, declaration2.counterReset);
    }
    return CSSParsedCounterDeclaration2;
  }()
);
var parse = function(context, descriptor, style2) {
  var tokenizer = new Tokenizer();
  var value = style2 !== null && typeof style2 !== "undefined" ? style2.toString() : descriptor.initialValue;
  tokenizer.write(value);
  var parser = new Parser(tokenizer.read());
  switch (descriptor.type) {
    case 2:
      var token2 = parser.parseComponentValue();
      return descriptor.parse(context, isIdentToken(token2) ? token2.value : descriptor.initialValue);
    case 0:
      return descriptor.parse(context, parser.parseComponentValue());
    case 1:
      return descriptor.parse(context, parser.parseComponentValues());
    case 4:
      return parser.parseComponentValue();
    case 3:
      switch (descriptor.format) {
        case "angle":
          return angle.parse(context, parser.parseComponentValue());
        case "color":
          return color$1.parse(context, parser.parseComponentValue());
        case "image":
          return image.parse(context, parser.parseComponentValue());
        case "length":
          var length_1 = parser.parseComponentValue();
          return isLength(length_1) ? length_1 : ZERO_LENGTH;
        case "length-percentage":
          var value_1 = parser.parseComponentValue();
          return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
        case "time":
          return time.parse(context, parser.parseComponentValue());
      }
      break;
  }
};
var elementDebuggerAttribute = "data-html2canvas-debug";
var getElementDebugType = function(element) {
  var attribute = element.getAttribute(elementDebuggerAttribute);
  switch (attribute) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
};
var isDebugging = function(element, type2) {
  var elementType = getElementDebugType(element);
  return elementType === 1 || type2 === elementType;
};
var ElementContainer = (
  /** @class */
  function() {
    function ElementContainer2(context, element) {
      this.context = context;
      this.textNodes = [];
      this.elements = [];
      this.flags = 0;
      if (isDebugging(
        element,
        3
        /* PARSE */
      )) {
        debugger;
      }
      this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
      if (isHTMLElementNode(element)) {
        if (this.styles.animationDuration.some(function(duration2) {
          return duration2 > 0;
        })) {
          element.style.animationDuration = "0s";
        }
        if (this.styles.transform !== null) {
          element.style.transform = "none";
        }
      }
      this.bounds = parseBounds(this.context, element);
      if (isDebugging(
        element,
        4
        /* RENDER */
      )) {
        this.flags |= 16;
      }
    }
    return ElementContainer2;
  }()
);
var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1$2 = 0; i$1$2 < chars$1.length; i$1$2++) {
  lookup$1[chars$1.charCodeAt(i$1$2)] = i$1$2;
}
var decode = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array = function(buffer) {
  var length2 = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length2; i2 += 2) {
    bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var polyUint32Array = function(buffer) {
  var length2 = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length2; i2 += 4) {
    bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2 = 5;
var UTRIE2_SHIFT_1 = 6 + 5;
var UTRIE2_INDEX_SHIFT = 2;
var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
var slice16 = function(view, start2, end2) {
  if (view.slice) {
    return view.slice(start2, end2);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start2, end2));
};
var slice32 = function(view, start2, end2) {
  if (view.slice) {
    return view.slice(start2, end2);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start2, end2));
};
var createTrieFromBase64 = function(base642, _byteLength) {
  var buffer = decode(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data);
};
var Trie = (
  /** @class */
  function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index2;
      this.data = data;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  }()
);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$4 = 0; i$4 < chars.length; i$4++) {
  lookup[chars.charCodeAt(i$4)] = i$4;
}
var Prepend = 1;
var CR = 2;
var LF = 3;
var Control = 4;
var Extend = 5;
var SpacingMark = 7;
var L$1 = 8;
var V$1 = 9;
var T$1 = 10;
var LV = 11;
var LVT = 12;
var ZWJ = 13;
var Extended_Pictographic = 14;
var RI = 15;
var toCodePoints = function(str) {
  var codePoints = [];
  var i2 = 0;
  var length2 = str.length;
  while (i2 < length2) {
    var value = str.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length2) {
      var extra = str.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length2 = codePoints.length;
  if (!length2) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length2) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length2 || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var UnicodeTrie = createTrieFromBase64(base64);
var BREAK_NOT_ALLOWED = "×";
var BREAK_ALLOWED = "÷";
var codePointToClass = function(codePoint) {
  return UnicodeTrie.get(codePoint);
};
var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
  var prevIndex = index2 - 2;
  var prev2 = classTypes[prevIndex];
  var current = classTypes[index2 - 1];
  var next2 = classTypes[index2];
  if (current === CR && next2 === LF) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === CR || current === LF || current === Control) {
    return BREAK_ALLOWED;
  }
  if (next2 === CR || next2 === LF || next2 === Control) {
    return BREAK_ALLOWED;
  }
  if (current === L$1 && [L$1, V$1, LV, LVT].indexOf(next2) !== -1) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LV || current === V$1) && (next2 === V$1 || next2 === T$1)) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LVT || current === T$1) && next2 === T$1) {
    return BREAK_NOT_ALLOWED;
  }
  if (next2 === ZWJ || next2 === Extend) {
    return BREAK_NOT_ALLOWED;
  }
  if (next2 === SpacingMark) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === Prepend) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === ZWJ && next2 === Extended_Pictographic) {
    while (prev2 === Extend) {
      prev2 = classTypes[--prevIndex];
    }
    if (prev2 === Extended_Pictographic) {
      return BREAK_NOT_ALLOWED;
    }
  }
  if (current === RI && next2 === RI) {
    var countRI = 0;
    while (prev2 === RI) {
      countRI++;
      prev2 = classTypes[--prevIndex];
    }
    if (countRI % 2 === 0) {
      return BREAK_NOT_ALLOWED;
    }
  }
  return BREAK_ALLOWED;
};
var GraphemeBreaker = function(str) {
  var codePoints = toCodePoints(str);
  var length2 = codePoints.length;
  var index2 = 0;
  var lastEnd = 0;
  var classTypes = codePoints.map(codePointToClass);
  return {
    next: function() {
      if (index2 >= length2) {
        return { done: true, value: null };
      }
      var graphemeBreak = BREAK_NOT_ALLOWED;
      while (index2 < length2 && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
      }
      if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length2) {
        var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
        lastEnd = index2;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var splitGraphemes = function(str) {
  var breaker = GraphemeBreaker(str);
  var graphemes = [];
  var bk2;
  while (!(bk2 = breaker.next()).done) {
    if (bk2.value) {
      graphemes.push(bk2.value.slice());
    }
  }
  return graphemes;
};
var testRangeBounds = function(document2) {
  var TEST_HEIGHT = 123;
  if (document2.createRange) {
    var range = document2.createRange();
    if (range.getBoundingClientRect) {
      var testElement = document2.createElement("boundtest");
      testElement.style.height = TEST_HEIGHT + "px";
      testElement.style.display = "block";
      document2.body.appendChild(testElement);
      range.selectNode(testElement);
      var rangeBounds = range.getBoundingClientRect();
      var rangeHeight = Math.round(rangeBounds.height);
      document2.body.removeChild(testElement);
      if (rangeHeight === TEST_HEIGHT) {
        return true;
      }
    }
  }
  return false;
};
var testIOSLineBreak = function(document2) {
  var testElement = document2.createElement("boundtest");
  testElement.style.width = "50px";
  testElement.style.display = "block";
  testElement.style.fontSize = "12px";
  testElement.style.letterSpacing = "0px";
  testElement.style.wordSpacing = "0px";
  document2.body.appendChild(testElement);
  var range = document2.createRange();
  testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
  var node2 = testElement.firstChild;
  var textList = toCodePoints$1(node2.data).map(function(i2) {
    return fromCodePoint$1(i2);
  });
  var offset2 = 0;
  var prev2 = {};
  var supports = textList.every(function(text, i2) {
    range.setStart(node2, offset2);
    range.setEnd(node2, offset2 + text.length);
    var rect = range.getBoundingClientRect();
    offset2 += text.length;
    var boundAhead = rect.x > prev2.x || rect.y > prev2.y;
    prev2 = rect;
    if (i2 === 0) {
      return true;
    }
    return boundAhead;
  });
  document2.body.removeChild(testElement);
  return supports;
};
var testCORS = function() {
  return typeof new Image().crossOrigin !== "undefined";
};
var testResponseType = function() {
  return typeof new XMLHttpRequest().responseType === "string";
};
var testSVG = function(document2) {
  var img = new Image();
  var canvas = document2.createElement("canvas");
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return false;
  }
  img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    ctx.drawImage(img, 0, 0);
    canvas.toDataURL();
  } catch (e2) {
    return false;
  }
  return true;
};
var isGreenPixel = function(data) {
  return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
};
var testForeignObject = function(document2) {
  var canvas = document2.createElement("canvas");
  var size = 100;
  canvas.width = size;
  canvas.height = size;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return Promise.reject(false);
  }
  ctx.fillStyle = "rgb(0, 255, 0)";
  ctx.fillRect(0, 0, size, size);
  var img = new Image();
  var greenImageSrc = canvas.toDataURL();
  img.src = greenImageSrc;
  var svg = createForeignObjectSVG(size, size, 0, 0, img);
  ctx.fillStyle = "red";
  ctx.fillRect(0, 0, size, size);
  return loadSerializedSVG$1(svg).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    var data = ctx.getImageData(0, 0, size, size).data;
    ctx.fillStyle = "red";
    ctx.fillRect(0, 0, size, size);
    var node2 = document2.createElement("div");
    node2.style.backgroundImage = "url(" + greenImageSrc + ")";
    node2.style.height = size + "px";
    return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node2)) : Promise.reject(false);
  }).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
  }).catch(function() {
    return false;
  });
};
var createForeignObjectSVG = function(width2, height2, x2, y2, node2) {
  var xmlns = "http://www.w3.org/2000/svg";
  var svg = document.createElementNS(xmlns, "svg");
  var foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg.setAttributeNS(null, "width", width2.toString());
  svg.setAttributeNS(null, "height", height2.toString());
  foreignObject.setAttributeNS(null, "width", "100%");
  foreignObject.setAttributeNS(null, "height", "100%");
  foreignObject.setAttributeNS(null, "x", x2.toString());
  foreignObject.setAttributeNS(null, "y", y2.toString());
  foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
  svg.appendChild(foreignObject);
  foreignObject.appendChild(node2);
  return svg;
};
var loadSerializedSVG$1 = function(svg) {
  return new Promise(function(resolve2, reject) {
    var img = new Image();
    img.onload = function() {
      return resolve2(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  });
};
var FEATURES = {
  get SUPPORT_RANGE_BOUNDS() {
    var value = testRangeBounds(document);
    Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
    return value;
  },
  get SUPPORT_WORD_BREAKING() {
    var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
    Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
    return value;
  },
  get SUPPORT_SVG_DRAWING() {
    var value = testSVG(document);
    Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
    return value;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
    Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
    return value;
  },
  get SUPPORT_CORS_IMAGES() {
    var value = testCORS();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
    return value;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var value = testResponseType();
    Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
    return value;
  },
  get SUPPORT_CORS_XHR() {
    var value = "withCredentials" in new XMLHttpRequest();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
    return value;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
    Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
    return value;
  }
};
var TextBounds = (
  /** @class */
  function() {
    function TextBounds2(text, bounds) {
      this.text = text;
      this.bounds = bounds;
    }
    return TextBounds2;
  }()
);
var parseTextBounds = function(context, value, styles2, node2) {
  var textList = breakText(value, styles2);
  var textBounds = [];
  var offset2 = 0;
  textList.forEach(function(text) {
    if (styles2.textDecorationLine.length || text.trim().length > 0) {
      if (FEATURES.SUPPORT_RANGE_BOUNDS) {
        var clientRects = createRange(node2, offset2, text.length).getClientRects();
        if (clientRects.length > 1) {
          var subSegments = segmentGraphemes(text);
          var subOffset_1 = 0;
          subSegments.forEach(function(subSegment) {
            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node2, subOffset_1 + offset2, subSegment.length).getClientRects())));
            subOffset_1 += subSegment.length;
          });
        } else {
          textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
        }
      } else {
        var replacementNode = node2.splitText(text.length);
        textBounds.push(new TextBounds(text, getWrapperBounds(context, node2)));
        node2 = replacementNode;
      }
    } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
      node2 = node2.splitText(text.length);
    }
    offset2 += text.length;
  });
  return textBounds;
};
var getWrapperBounds = function(context, node2) {
  var ownerDocument2 = node2.ownerDocument;
  if (ownerDocument2) {
    var wrapper = ownerDocument2.createElement("html2canvaswrapper");
    wrapper.appendChild(node2.cloneNode(true));
    var parentNode = node2.parentNode;
    if (parentNode) {
      parentNode.replaceChild(wrapper, node2);
      var bounds = parseBounds(context, wrapper);
      if (wrapper.firstChild) {
        parentNode.replaceChild(wrapper.firstChild, wrapper);
      }
      return bounds;
    }
  }
  return Bounds.EMPTY;
};
var createRange = function(node2, offset2, length2) {
  var ownerDocument2 = node2.ownerDocument;
  if (!ownerDocument2) {
    throw new Error("Node has no owner document");
  }
  var range = ownerDocument2.createRange();
  range.setStart(node2, offset2);
  range.setEnd(node2, offset2 + length2);
  return range;
};
var segmentGraphemes = function(value) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return splitGraphemes(value);
};
var segmentWords = function(value, styles2) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return breakWords(value, styles2);
};
var breakText = function(value, styles2) {
  return styles2.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles2);
};
var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
var breakWords = function(str, styles2) {
  var breaker = LineBreaker(str, {
    lineBreak: styles2.lineBreak,
    wordBreak: styles2.overflowWrap === "break-word" ? "break-word" : styles2.wordBreak
  });
  var words2 = [];
  var bk2;
  var _loop_1 = function() {
    if (bk2.value) {
      var value = bk2.value.slice();
      var codePoints = toCodePoints$1(value);
      var word_1 = "";
      codePoints.forEach(function(codePoint) {
        if (wordSeparators.indexOf(codePoint) === -1) {
          word_1 += fromCodePoint$1(codePoint);
        } else {
          if (word_1.length) {
            words2.push(word_1);
          }
          words2.push(fromCodePoint$1(codePoint));
          word_1 = "";
        }
      });
      if (word_1.length) {
        words2.push(word_1);
      }
    }
  };
  while (!(bk2 = breaker.next()).done) {
    _loop_1();
  }
  return words2;
};
var TextContainer = (
  /** @class */
  function() {
    function TextContainer2(context, node2, styles2) {
      this.text = transform(node2.data, styles2.textTransform);
      this.textBounds = parseTextBounds(context, this.text, styles2, node2);
    }
    return TextContainer2;
  }()
);
var transform = function(text, transform2) {
  switch (transform2) {
    case 1:
      return text.toLowerCase();
    case 3:
      return text.replace(CAPITALIZE, capitalize);
    case 2:
      return text.toUpperCase();
    default:
      return text;
  }
};
var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
var capitalize = function(m2, p1, p2) {
  if (m2.length > 0) {
    return p1 + p2.toUpperCase();
  }
  return m2;
};
var ImageElementContainer = (
  /** @class */
  function(_super) {
    __extends(ImageElementContainer2, _super);
    function ImageElementContainer2(context, img) {
      var _this = _super.call(this, context, img) || this;
      _this.src = img.currentSrc || img.src;
      _this.intrinsicWidth = img.naturalWidth;
      _this.intrinsicHeight = img.naturalHeight;
      _this.context.cache.addImage(_this.src);
      return _this;
    }
    return ImageElementContainer2;
  }(ElementContainer)
);
var CanvasElementContainer = (
  /** @class */
  function(_super) {
    __extends(CanvasElementContainer2, _super);
    function CanvasElementContainer2(context, canvas) {
      var _this = _super.call(this, context, canvas) || this;
      _this.canvas = canvas;
      _this.intrinsicWidth = canvas.width;
      _this.intrinsicHeight = canvas.height;
      return _this;
    }
    return CanvasElementContainer2;
  }(ElementContainer)
);
var SVGElementContainer = (
  /** @class */
  function(_super) {
    __extends(SVGElementContainer2, _super);
    function SVGElementContainer2(context, img) {
      var _this = _super.call(this, context, img) || this;
      var s2 = new XMLSerializer();
      var bounds = parseBounds(context, img);
      img.setAttribute("width", bounds.width + "px");
      img.setAttribute("height", bounds.height + "px");
      _this.svg = "data:image/svg+xml," + encodeURIComponent(s2.serializeToString(img));
      _this.intrinsicWidth = img.width.baseVal.value;
      _this.intrinsicHeight = img.height.baseVal.value;
      _this.context.cache.addImage(_this.svg);
      return _this;
    }
    return SVGElementContainer2;
  }(ElementContainer)
);
var LIElementContainer = (
  /** @class */
  function(_super) {
    __extends(LIElementContainer2, _super);
    function LIElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return LIElementContainer2;
  }(ElementContainer)
);
var OLElementContainer = (
  /** @class */
  function(_super) {
    __extends(OLElementContainer2, _super);
    function OLElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.start = element.start;
      _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
      return _this;
    }
    return OLElementContainer2;
  }(ElementContainer)
);
var CHECKBOX_BORDER_RADIUS = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
];
var RADIO_BORDER_RADIUS = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
];
var reformatInputBounds = function(bounds) {
  if (bounds.width > bounds.height) {
    return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
  } else if (bounds.width < bounds.height) {
    return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
  }
  return bounds;
};
var getInputValue = function(node2) {
  var value = node2.type === PASSWORD ? new Array(node2.value.length + 1).join("•") : node2.value;
  return value.length === 0 ? node2.placeholder || "" : value;
};
var CHECKBOX = "checkbox";
var RADIO = "radio";
var PASSWORD = "password";
var INPUT_COLOR = 707406591;
var InputElementContainer = (
  /** @class */
  function(_super) {
    __extends(InputElementContainer2, _super);
    function InputElementContainer2(context, input) {
      var _this = _super.call(this, context, input) || this;
      _this.type = input.type.toLowerCase();
      _this.checked = input.checked;
      _this.value = getInputValue(input);
      if (_this.type === CHECKBOX || _this.type === RADIO) {
        _this.styles.backgroundColor = 3739148031;
        _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
        _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
        _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
        _this.styles.backgroundClip = [
          0
          /* BORDER_BOX */
        ];
        _this.styles.backgroundOrigin = [
          0
          /* BORDER_BOX */
        ];
        _this.bounds = reformatInputBounds(_this.bounds);
      }
      switch (_this.type) {
        case CHECKBOX:
          _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
          break;
        case RADIO:
          _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
          break;
      }
      return _this;
    }
    return InputElementContainer2;
  }(ElementContainer)
);
var SelectElementContainer = (
  /** @class */
  function(_super) {
    __extends(SelectElementContainer2, _super);
    function SelectElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      var option = element.options[element.selectedIndex || 0];
      _this.value = option ? option.text || "" : "";
      return _this;
    }
    return SelectElementContainer2;
  }(ElementContainer)
);
var TextareaElementContainer = (
  /** @class */
  function(_super) {
    __extends(TextareaElementContainer2, _super);
    function TextareaElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return TextareaElementContainer2;
  }(ElementContainer)
);
var IFrameElementContainer = (
  /** @class */
  function(_super) {
    __extends(IFrameElementContainer2, _super);
    function IFrameElementContainer2(context, iframe) {
      var _this = _super.call(this, context, iframe) || this;
      _this.src = iframe.src;
      _this.width = parseInt(iframe.width, 10) || 0;
      _this.height = parseInt(iframe.height, 10) || 0;
      _this.backgroundColor = _this.styles.backgroundColor;
      try {
        if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
          _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
          var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
          var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
          _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
        }
      } catch (e2) {
      }
      return _this;
    }
    return IFrameElementContainer2;
  }(ElementContainer)
);
var LIST_OWNERS = ["OL", "UL", "MENU"];
var parseNodeTree = function(context, node2, parent, root2) {
  for (var childNode = node2.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
    nextNode = childNode.nextSibling;
    if (isTextNode(childNode) && childNode.data.trim().length > 0) {
      parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
    } else if (isElementNode(childNode)) {
      if (isSlotElement(childNode) && childNode.assignedNodes) {
        childNode.assignedNodes().forEach(function(childNode2) {
          return parseNodeTree(context, childNode2, parent, root2);
        });
      } else {
        var container = createContainer(context, childNode);
        if (container.styles.isVisible()) {
          if (createsRealStackingContext(childNode, container, root2)) {
            container.flags |= 4;
          } else if (createsStackingContext(container.styles)) {
            container.flags |= 2;
          }
          if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
            container.flags |= 8;
          }
          parent.elements.push(container);
          childNode.slot;
          if (childNode.shadowRoot) {
            parseNodeTree(context, childNode.shadowRoot, container, root2);
          } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
            parseNodeTree(context, childNode, container, root2);
          }
        }
      }
    }
  }
};
var createContainer = function(context, element) {
  if (isImageElement(element)) {
    return new ImageElementContainer(context, element);
  }
  if (isCanvasElement(element)) {
    return new CanvasElementContainer(context, element);
  }
  if (isSVGElement(element)) {
    return new SVGElementContainer(context, element);
  }
  if (isLIElement(element)) {
    return new LIElementContainer(context, element);
  }
  if (isOLElement(element)) {
    return new OLElementContainer(context, element);
  }
  if (isInputElement(element)) {
    return new InputElementContainer(context, element);
  }
  if (isSelectElement(element)) {
    return new SelectElementContainer(context, element);
  }
  if (isTextareaElement(element)) {
    return new TextareaElementContainer(context, element);
  }
  if (isIFrameElement(element)) {
    return new IFrameElementContainer(context, element);
  }
  return new ElementContainer(context, element);
};
var parseTree = function(context, element) {
  var container = createContainer(context, element);
  container.flags |= 4;
  parseNodeTree(context, element, container, container);
  return container;
};
var createsRealStackingContext = function(node2, container, root2) {
  return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node2) && root2.styles.isTransparent();
};
var createsStackingContext = function(styles2) {
  return styles2.isPositioned() || styles2.isFloating();
};
var isTextNode = function(node2) {
  return node2.nodeType === Node.TEXT_NODE;
};
var isElementNode = function(node2) {
  return node2.nodeType === Node.ELEMENT_NODE;
};
var isHTMLElementNode = function(node2) {
  return isElementNode(node2) && typeof node2.style !== "undefined" && !isSVGElementNode(node2);
};
var isSVGElementNode = function(element) {
  return typeof element.className === "object";
};
var isLIElement = function(node2) {
  return node2.tagName === "LI";
};
var isOLElement = function(node2) {
  return node2.tagName === "OL";
};
var isInputElement = function(node2) {
  return node2.tagName === "INPUT";
};
var isHTMLElement = function(node2) {
  return node2.tagName === "HTML";
};
var isSVGElement = function(node2) {
  return node2.tagName === "svg";
};
var isBodyElement = function(node2) {
  return node2.tagName === "BODY";
};
var isCanvasElement = function(node2) {
  return node2.tagName === "CANVAS";
};
var isVideoElement = function(node2) {
  return node2.tagName === "VIDEO";
};
var isImageElement = function(node2) {
  return node2.tagName === "IMG";
};
var isIFrameElement = function(node2) {
  return node2.tagName === "IFRAME";
};
var isStyleElement = function(node2) {
  return node2.tagName === "STYLE";
};
var isScriptElement = function(node2) {
  return node2.tagName === "SCRIPT";
};
var isTextareaElement = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var isSelectElement = function(node2) {
  return node2.tagName === "SELECT";
};
var isSlotElement = function(node2) {
  return node2.tagName === "SLOT";
};
var isCustomElement = function(node2) {
  return node2.tagName.indexOf("-") > 0;
};
var CounterState = (
  /** @class */
  function() {
    function CounterState2() {
      this.counters = {};
    }
    CounterState2.prototype.getCounterValue = function(name) {
      var counter2 = this.counters[name];
      if (counter2 && counter2.length) {
        return counter2[counter2.length - 1];
      }
      return 1;
    };
    CounterState2.prototype.getCounterValues = function(name) {
      var counter2 = this.counters[name];
      return counter2 ? counter2 : [];
    };
    CounterState2.prototype.pop = function(counters) {
      var _this = this;
      counters.forEach(function(counter2) {
        return _this.counters[counter2].pop();
      });
    };
    CounterState2.prototype.parse = function(style2) {
      var _this = this;
      var counterIncrement2 = style2.counterIncrement;
      var counterReset2 = style2.counterReset;
      var canReset = true;
      if (counterIncrement2 !== null) {
        counterIncrement2.forEach(function(entry) {
          var counter2 = _this.counters[entry.counter];
          if (counter2 && entry.increment !== 0) {
            canReset = false;
            if (!counter2.length) {
              counter2.push(1);
            }
            counter2[Math.max(0, counter2.length - 1)] += entry.increment;
          }
        });
      }
      var counterNames = [];
      if (canReset) {
        counterReset2.forEach(function(entry) {
          var counter2 = _this.counters[entry.counter];
          counterNames.push(entry.counter);
          if (!counter2) {
            counter2 = _this.counters[entry.counter] = [];
          }
          counter2.push(entry.reset);
        });
      }
      return counterNames;
    };
    return CounterState2;
  }()
);
var ROMAN_UPPER = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
};
var ARMENIAN = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "Ք",
    "Փ",
    "Ւ",
    "Ց",
    "Ր",
    "Տ",
    "Վ",
    "Ս",
    "Ռ",
    "Ջ",
    "Պ",
    "Չ",
    "Ո",
    "Շ",
    "Ն",
    "Յ",
    "Մ",
    "Ճ",
    "Ղ",
    "Ձ",
    "Հ",
    "Կ",
    "Ծ",
    "Խ",
    "Լ",
    "Ի",
    "Ժ",
    "Թ",
    "Ը",
    "Է",
    "Զ",
    "Ե",
    "Դ",
    "Գ",
    "Բ",
    "Ա"
  ]
};
var HEBREW = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "י׳",
    "ט׳",
    "ח׳",
    "ז׳",
    "ו׳",
    "ה׳",
    "ד׳",
    "ג׳",
    "ב׳",
    "א׳",
    "ת",
    "ש",
    "ר",
    "ק",
    "צ",
    "פ",
    "ע",
    "ס",
    "נ",
    "מ",
    "ל",
    "כ",
    "יט",
    "יח",
    "יז",
    "טז",
    "טו",
    "י",
    "ט",
    "ח",
    "ז",
    "ו",
    "ה",
    "ד",
    "ג",
    "ב",
    "א"
  ]
};
var GEORGIAN = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "ჵ",
    "ჰ",
    "ჯ",
    "ჴ",
    "ხ",
    "ჭ",
    "წ",
    "ძ",
    "ც",
    "ჩ",
    "შ",
    "ყ",
    "ღ",
    "ქ",
    "ფ",
    "ჳ",
    "ტ",
    "ს",
    "რ",
    "ჟ",
    "პ",
    "ო",
    "ჲ",
    "ნ",
    "მ",
    "ლ",
    "კ",
    "ი",
    "თ",
    "ჱ",
    "ზ",
    "ვ",
    "ე",
    "დ",
    "გ",
    "ბ",
    "ა"
  ]
};
var createAdditiveCounter = function(value, min2, max2, symbols, fallback, suffix) {
  if (value < min2 || value > max2) {
    return createCounterText(value, fallback, suffix.length > 0);
  }
  return symbols.integers.reduce(function(string2, integer, index2) {
    while (value >= integer) {
      value -= integer;
      string2 += symbols.values[index2];
    }
    return string2;
  }, "") + suffix;
};
var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
  var string2 = "";
  do {
    if (!isNumeric) {
      value--;
    }
    string2 = resolver(value) + string2;
    value /= codePointRangeLength;
  } while (value * codePointRangeLength >= codePointRangeLength);
  return string2;
};
var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
    return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  }) + suffix);
};
var createCounterStyleFromSymbols = function(value, symbols, suffix) {
  if (suffix === void 0) {
    suffix = ". ";
  }
  var codePointRangeLength = symbols.length;
  return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
    return symbols[Math.floor(codePoint % codePointRangeLength)];
  }) + suffix;
};
var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags3) {
  if (value < -9999 || value > 9999) {
    return createCounterText(value, 4, suffix.length > 0);
  }
  var tmp = Math.abs(value);
  var string2 = suffix;
  if (tmp === 0) {
    return numbers[0] + string2;
  }
  for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
    var coefficient = tmp % 10;
    if (coefficient === 0 && contains(flags3, CJK_ZEROS) && string2 !== "") {
      string2 = numbers[coefficient] + string2;
    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags3, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags3, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags3, CJK_HUNDRED_COEFFICIENTS)) {
      string2 = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string2;
    } else if (coefficient === 1 && digit > 0) {
      string2 = multipliers[digit - 1] + string2;
    }
    tmp = Math.floor(tmp / 10);
  }
  return (value < 0 ? negativeSign : "") + string2;
};
var CHINESE_INFORMAL_MULTIPLIERS = "十百千萬";
var CHINESE_FORMAL_MULTIPLIERS = "拾佰仟萬";
var JAPANESE_NEGATIVE = "マイナス";
var KOREAN_NEGATIVE = "마이너스";
var createCounterText = function(value, type2, appendSuffix) {
  var defaultSuffix = appendSuffix ? ". " : "";
  var cjkSuffix = appendSuffix ? "、" : "";
  var koreanSuffix = appendSuffix ? ", " : "";
  var spaceSuffix = appendSuffix ? " " : "";
  switch (type2) {
    case 0:
      return "•" + spaceSuffix;
    case 1:
      return "◦" + spaceSuffix;
    case 2:
      return "◾" + spaceSuffix;
    case 5:
      var string2 = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      return string2.length < 4 ? "0" + string2 : string2;
    case 4:
      return createCounterStyleFromSymbols(value, "〇一二三四五六七八九", cjkSuffix);
    case 6:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
    case 7:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
    case 8:
      return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
    case 9:
      return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
    case 10:
      return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
    case 11:
      return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
    case 12:
    case 49:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
    case 35:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
    case 13:
      return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
    case 14:
    case 30:
      return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
    case 15:
      return createCounterStyleFromSymbols(value, "子丑寅卯辰巳午未申酉戌亥", cjkSuffix);
    case 16:
      return createCounterStyleFromSymbols(value, "甲乙丙丁戊己庚辛壬癸", cjkSuffix);
    case 17:
    case 48:
      return createCJKCounter(value, "零一二三四五六七八九", CHINESE_INFORMAL_MULTIPLIERS, "負", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 47:
      return createCJKCounter(value, "零壹貳參肆伍陸柒捌玖", CHINESE_FORMAL_MULTIPLIERS, "負", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 42:
      return createCJKCounter(value, "零一二三四五六七八九", CHINESE_INFORMAL_MULTIPLIERS, "负", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 41:
      return createCJKCounter(value, "零壹贰叁肆伍陆柒捌玖", CHINESE_FORMAL_MULTIPLIERS, "负", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 26:
      return createCJKCounter(value, "〇一二三四五六七八九", "十百千万", JAPANESE_NEGATIVE, cjkSuffix, 0);
    case 25:
      return createCJKCounter(value, "零壱弐参四伍六七八九", "拾百千万", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 31:
      return createCJKCounter(value, "영일이삼사오육칠팔구", "십백천만", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 33:
      return createCJKCounter(value, "零一二三四五六七八九", "十百千萬", KOREAN_NEGATIVE, koreanSuffix, 0);
    case 32:
      return createCJKCounter(value, "零壹貳參四五六七八九", "拾百千", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 18:
      return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
    case 20:
      return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
    case 21:
      return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
    case 22:
      return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
    case 22:
      return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
    case 23:
      return createCounterStyleFromSymbols(value, "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん");
    case 24:
      return createCounterStyleFromSymbols(value, "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす");
    case 27:
      return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
    case 28:
      return createCounterStyleFromSymbols(value, "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン", cjkSuffix);
    case 29:
      return createCounterStyleFromSymbols(value, "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス", cjkSuffix);
    case 34:
      return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
    case 37:
      return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
    case 38:
      return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
    case 39:
      return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
    case 40:
      return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
    case 43:
      return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
    case 44:
      return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
    case 45:
      return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
    case 46:
      return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
    case 3:
    default:
      return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  }
};
var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
var DocumentCloner = (
  /** @class */
  function() {
    function DocumentCloner2(context, element, options) {
      this.context = context;
      this.options = options;
      this.scrolledElements = [];
      this.referenceElement = element;
      this.counters = new CounterState();
      this.quoteDepth = 0;
      if (!element.ownerDocument) {
        throw new Error("Cloned element does not have an owner document");
      }
      this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
    }
    DocumentCloner2.prototype.toIFrame = function(ownerDocument2, windowSize) {
      var _this = this;
      var iframe = createIFrameContainer(ownerDocument2, windowSize);
      if (!iframe.contentWindow) {
        return Promise.reject("Unable to find iframe window");
      }
      var scrollX = ownerDocument2.defaultView.pageXOffset;
      var scrollY = ownerDocument2.defaultView.pageYOffset;
      var cloneWindow = iframe.contentWindow;
      var documentClone = cloneWindow.document;
      var iframeLoad = iframeLoader(iframe).then(function() {
        return __awaiter(_this, void 0, void 0, function() {
          var onclone, referenceElement;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.scrolledElements.forEach(restoreNodeScroll);
                if (cloneWindow) {
                  cloneWindow.scrollTo(windowSize.left, windowSize.top);
                  if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                    this.context.logger.warn("Unable to restore scroll position for cloned document");
                    this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                  }
                }
                onclone = this.options.onclone;
                referenceElement = this.clonedReferenceElement;
                if (typeof referenceElement === "undefined") {
                  return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                }
                if (!(documentClone.fonts && documentClone.fonts.ready))
                  return [3, 2];
                return [4, documentClone.fonts.ready];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                if (!/(AppleWebKit)/g.test(navigator.userAgent))
                  return [3, 4];
                return [4, imagesReady(documentClone)];
              case 3:
                _a2.sent();
                _a2.label = 4;
              case 4:
                if (typeof onclone === "function") {
                  return [2, Promise.resolve().then(function() {
                    return onclone(documentClone, referenceElement);
                  }).then(function() {
                    return iframe;
                  })];
                }
                return [2, iframe];
            }
          });
        });
      });
      documentClone.open();
      documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
      restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
      documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
      documentClone.close();
      return iframeLoad;
    };
    DocumentCloner2.prototype.createElementClone = function(node2) {
      if (isDebugging(
        node2,
        2
        /* CLONE */
      )) {
        debugger;
      }
      if (isCanvasElement(node2)) {
        return this.createCanvasClone(node2);
      }
      if (isVideoElement(node2)) {
        return this.createVideoClone(node2);
      }
      if (isStyleElement(node2)) {
        return this.createStyleClone(node2);
      }
      var clone2 = node2.cloneNode(false);
      if (isImageElement(clone2)) {
        if (isImageElement(node2) && node2.currentSrc && node2.currentSrc !== node2.src) {
          clone2.src = node2.currentSrc;
          clone2.srcset = "";
        }
        if (clone2.loading === "lazy") {
          clone2.loading = "eager";
        }
      }
      if (isCustomElement(clone2)) {
        return this.createCustomElementClone(clone2);
      }
      return clone2;
    };
    DocumentCloner2.prototype.createCustomElementClone = function(node2) {
      var clone2 = document.createElement("html2canvascustomelement");
      copyCSSStyles(node2.style, clone2);
      return clone2;
    };
    DocumentCloner2.prototype.createStyleClone = function(node2) {
      try {
        var sheet = node2.sheet;
        if (sheet && sheet.cssRules) {
          var css2 = [].slice.call(sheet.cssRules, 0).reduce(function(css3, rule) {
            if (rule && typeof rule.cssText === "string") {
              return css3 + rule.cssText;
            }
            return css3;
          }, "");
          var style2 = node2.cloneNode(false);
          style2.textContent = css2;
          return style2;
        }
      } catch (e2) {
        this.context.logger.error("Unable to access cssRules property", e2);
        if (e2.name !== "SecurityError") {
          throw e2;
        }
      }
      return node2.cloneNode(false);
    };
    DocumentCloner2.prototype.createCanvasClone = function(canvas) {
      var _a2;
      if (this.options.inlineImages && canvas.ownerDocument) {
        var img = canvas.ownerDocument.createElement("img");
        try {
          img.src = canvas.toDataURL();
          return img;
        } catch (e2) {
          this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
        }
      }
      var clonedCanvas = canvas.cloneNode(false);
      try {
        clonedCanvas.width = canvas.width;
        clonedCanvas.height = canvas.height;
        var ctx = canvas.getContext("2d");
        var clonedCtx = clonedCanvas.getContext("2d");
        if (clonedCtx) {
          if (!this.options.allowTaint && ctx) {
            clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
          } else {
            var gl2 = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
            if (gl2) {
              var attribs = gl2.getContextAttributes();
              if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
              }
            }
            clonedCtx.drawImage(canvas, 0, 0);
          }
        }
        return clonedCanvas;
      } catch (e2) {
        this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
      }
      return clonedCanvas;
    };
    DocumentCloner2.prototype.createVideoClone = function(video) {
      var canvas = video.ownerDocument.createElement("canvas");
      canvas.width = video.offsetWidth;
      canvas.height = video.offsetHeight;
      var ctx = canvas.getContext("2d");
      try {
        if (ctx) {
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          if (!this.options.allowTaint) {
            ctx.getImageData(0, 0, canvas.width, canvas.height);
          }
        }
        return canvas;
      } catch (e2) {
        this.context.logger.info("Unable to clone video as it is tainted", video);
      }
      var blankCanvas = video.ownerDocument.createElement("canvas");
      blankCanvas.width = video.offsetWidth;
      blankCanvas.height = video.offsetHeight;
      return blankCanvas;
    };
    DocumentCloner2.prototype.appendChildNode = function(clone2, child, copyStyles) {
      if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
        if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
          clone2.appendChild(this.cloneNode(child, copyStyles));
        }
      }
    };
    DocumentCloner2.prototype.cloneChildNodes = function(node2, clone2, copyStyles) {
      var _this = this;
      for (var child = node2.shadowRoot ? node2.shadowRoot.firstChild : node2.firstChild; child; child = child.nextSibling) {
        if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
          var assignedNodes = child.assignedNodes();
          if (assignedNodes.length) {
            assignedNodes.forEach(function(assignedNode) {
              return _this.appendChildNode(clone2, assignedNode, copyStyles);
            });
          }
        } else {
          this.appendChildNode(clone2, child, copyStyles);
        }
      }
    };
    DocumentCloner2.prototype.cloneNode = function(node2, copyStyles) {
      if (isTextNode(node2)) {
        return document.createTextNode(node2.data);
      }
      if (!node2.ownerDocument) {
        return node2.cloneNode(false);
      }
      var window2 = node2.ownerDocument.defaultView;
      if (window2 && isElementNode(node2) && (isHTMLElementNode(node2) || isSVGElementNode(node2))) {
        var clone2 = this.createElementClone(node2);
        clone2.style.transitionProperty = "none";
        var style2 = window2.getComputedStyle(node2);
        var styleBefore = window2.getComputedStyle(node2, ":before");
        var styleAfter = window2.getComputedStyle(node2, ":after");
        if (this.referenceElement === node2 && isHTMLElementNode(clone2)) {
          this.clonedReferenceElement = clone2;
        }
        if (isBodyElement(clone2)) {
          createPseudoHideStyles(clone2);
        }
        var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));
        var before = this.resolvePseudoContent(node2, clone2, styleBefore, PseudoElementType.BEFORE);
        if (isCustomElement(node2)) {
          copyStyles = true;
        }
        if (!isVideoElement(node2)) {
          this.cloneChildNodes(node2, clone2, copyStyles);
        }
        if (before) {
          clone2.insertBefore(before, clone2.firstChild);
        }
        var after = this.resolvePseudoContent(node2, clone2, styleAfter, PseudoElementType.AFTER);
        if (after) {
          clone2.appendChild(after);
        }
        this.counters.pop(counters);
        if (style2 && (this.options.copyStyles || isSVGElementNode(node2)) && !isIFrameElement(node2) || copyStyles) {
          copyCSSStyles(style2, clone2);
        }
        if (node2.scrollTop !== 0 || node2.scrollLeft !== 0) {
          this.scrolledElements.push([clone2, node2.scrollLeft, node2.scrollTop]);
        }
        if ((isTextareaElement(node2) || isSelectElement(node2)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
          clone2.value = node2.value;
        }
        return clone2;
      }
      return node2.cloneNode(false);
    };
    DocumentCloner2.prototype.resolvePseudoContent = function(node2, clone2, style2, pseudoElt) {
      var _this = this;
      if (!style2) {
        return;
      }
      var value = style2.content;
      var document2 = clone2.ownerDocument;
      if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style2.display === "none") {
        return;
      }
      this.counters.parse(new CSSParsedCounterDeclaration(this.context, style2));
      var declaration2 = new CSSParsedPseudoDeclaration(this.context, style2);
      var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
      copyCSSStyles(style2, anonymousReplacedElement);
      declaration2.content.forEach(function(token2) {
        if (token2.type === 0) {
          anonymousReplacedElement.appendChild(document2.createTextNode(token2.value));
        } else if (token2.type === 22) {
          var img = document2.createElement("img");
          img.src = token2.value;
          img.style.opacity = "1";
          anonymousReplacedElement.appendChild(img);
        } else if (token2.type === 18) {
          if (token2.name === "attr") {
            var attr = token2.values.filter(isIdentToken);
            if (attr.length) {
              anonymousReplacedElement.appendChild(document2.createTextNode(node2.getAttribute(attr[0].value) || ""));
            }
          } else if (token2.name === "counter") {
            var _a2 = token2.values.filter(nonFunctionArgSeparator), counter2 = _a2[0], counterStyle = _a2[1];
            if (counter2 && isIdentToken(counter2)) {
              var counterState = _this.counters.getCounterValue(counter2.value);
              var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
              anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
            }
          } else if (token2.name === "counters") {
            var _b2 = token2.values.filter(nonFunctionArgSeparator), counter2 = _b2[0], delim = _b2[1], counterStyle = _b2[2];
            if (counter2 && isIdentToken(counter2)) {
              var counterStates = _this.counters.getCounterValues(counter2.value);
              var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
              var separator = delim && delim.type === 0 ? delim.value : "";
              var text = counterStates.map(function(value2) {
                return createCounterText(value2, counterType_1, false);
              }).join(separator);
              anonymousReplacedElement.appendChild(document2.createTextNode(text));
            }
          } else
            ;
        } else if (token2.type === 20) {
          switch (token2.value) {
            case "open-quote":
              anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration2.quotes, _this.quoteDepth++, true)));
              break;
            case "close-quote":
              anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration2.quotes, --_this.quoteDepth, false)));
              break;
            default:
              anonymousReplacedElement.appendChild(document2.createTextNode(token2.value));
          }
        }
      });
      anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      if (isSVGElementNode(clone2)) {
        clone2.className.baseValue += newClassName;
      } else {
        clone2.className += newClassName;
      }
      return anonymousReplacedElement;
    };
    DocumentCloner2.destroy = function(container) {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
        return true;
      }
      return false;
    };
    return DocumentCloner2;
  }()
);
var PseudoElementType;
(function(PseudoElementType2) {
  PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
  PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
})(PseudoElementType || (PseudoElementType = {}));
var createIFrameContainer = function(ownerDocument2, bounds) {
  var cloneIframeContainer = ownerDocument2.createElement("iframe");
  cloneIframeContainer.className = "html2canvas-container";
  cloneIframeContainer.style.visibility = "hidden";
  cloneIframeContainer.style.position = "fixed";
  cloneIframeContainer.style.left = "-10000px";
  cloneIframeContainer.style.top = "0px";
  cloneIframeContainer.style.border = "0";
  cloneIframeContainer.width = bounds.width.toString();
  cloneIframeContainer.height = bounds.height.toString();
  cloneIframeContainer.scrolling = "no";
  cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
  ownerDocument2.body.appendChild(cloneIframeContainer);
  return cloneIframeContainer;
};
var imageReady = function(img) {
  return new Promise(function(resolve2) {
    if (img.complete) {
      resolve2();
      return;
    }
    if (!img.src) {
      resolve2();
      return;
    }
    img.onload = resolve2;
    img.onerror = resolve2;
  });
};
var imagesReady = function(document2) {
  return Promise.all([].slice.call(document2.images, 0).map(imageReady));
};
var iframeLoader = function(iframe) {
  return new Promise(function(resolve2, reject) {
    var cloneWindow = iframe.contentWindow;
    if (!cloneWindow) {
      return reject("No window assigned for iframe");
    }
    var documentClone = cloneWindow.document;
    cloneWindow.onload = iframe.onload = function() {
      cloneWindow.onload = iframe.onload = null;
      var interval = setInterval(function() {
        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
          clearInterval(interval);
          resolve2(iframe);
        }
      }, 50);
    };
  });
};
var ignoredStyleProperties = [
  "all",
  "d",
  "content"
  // Safari shows pseudoelements if content is set
];
var copyCSSStyles = function(style2, target) {
  for (var i2 = style2.length - 1; i2 >= 0; i2--) {
    var property = style2.item(i2);
    if (ignoredStyleProperties.indexOf(property) === -1) {
      target.style.setProperty(property, style2.getPropertyValue(property));
    }
  }
  return target;
};
var serializeDoctype = function(doctype) {
  var str = "";
  if (doctype) {
    str += "<!DOCTYPE ";
    if (doctype.name) {
      str += doctype.name;
    }
    if (doctype.internalSubset) {
      str += doctype.internalSubset;
    }
    if (doctype.publicId) {
      str += '"' + doctype.publicId + '"';
    }
    if (doctype.systemId) {
      str += '"' + doctype.systemId + '"';
    }
    str += ">";
  }
  return str;
};
var restoreOwnerScroll = function(ownerDocument2, x2, y2) {
  if (ownerDocument2 && ownerDocument2.defaultView && (x2 !== ownerDocument2.defaultView.pageXOffset || y2 !== ownerDocument2.defaultView.pageYOffset)) {
    ownerDocument2.defaultView.scrollTo(x2, y2);
  }
};
var restoreNodeScroll = function(_a2) {
  var element = _a2[0], x2 = _a2[1], y2 = _a2[2];
  element.scrollLeft = x2;
  element.scrollTop = y2;
};
var PSEUDO_BEFORE = ":before";
var PSEUDO_AFTER = ":after";
var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
var createPseudoHideStyles = function(body) {
  createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
};
var createStyles = function(body, styles2) {
  var document2 = body.ownerDocument;
  if (document2) {
    var style2 = document2.createElement("style");
    style2.textContent = styles2;
    body.appendChild(style2);
  }
};
var CacheStorage = (
  /** @class */
  function() {
    function CacheStorage2() {
    }
    CacheStorage2.getOrigin = function(url) {
      var link = CacheStorage2._link;
      if (!link) {
        return "about:blank";
      }
      link.href = url;
      link.href = link.href;
      return link.protocol + link.hostname + link.port;
    };
    CacheStorage2.isSameOrigin = function(src2) {
      return CacheStorage2.getOrigin(src2) === CacheStorage2._origin;
    };
    CacheStorage2.setContext = function(window2) {
      CacheStorage2._link = window2.document.createElement("a");
      CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
    };
    CacheStorage2._origin = "about:blank";
    return CacheStorage2;
  }()
);
var Cache = (
  /** @class */
  function() {
    function Cache2(context, _options) {
      this.context = context;
      this._options = _options;
      this._cache = {};
    }
    Cache2.prototype.addImage = function(src2) {
      var result = Promise.resolve();
      if (this.has(src2)) {
        return result;
      }
      if (isBlobImage(src2) || isRenderable(src2)) {
        (this._cache[src2] = this.loadImage(src2)).catch(function() {
        });
        return result;
      }
      return result;
    };
    Cache2.prototype.match = function(src2) {
      return this._cache[src2];
    };
    Cache2.prototype.loadImage = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var isSameOrigin, useCORS, useProxy, src2;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              isSameOrigin = CacheStorage.isSameOrigin(key);
              useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
              useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
              if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                return [
                  2
                  /*return*/
                ];
              }
              src2 = key;
              if (!useProxy)
                return [3, 2];
              return [4, this.proxy(src2)];
            case 1:
              src2 = _a2.sent();
              _a2.label = 2;
            case 2:
              this.context.logger.debug("Added image " + key.substring(0, 256));
              return [4, new Promise(function(resolve2, reject) {
                var img = new Image();
                img.onload = function() {
                  return resolve2(img);
                };
                img.onerror = reject;
                if (isInlineBase64Image(src2) || useCORS) {
                  img.crossOrigin = "anonymous";
                }
                img.src = src2;
                if (img.complete === true) {
                  setTimeout(function() {
                    return resolve2(img);
                  }, 500);
                }
                if (_this._options.imageTimeout > 0) {
                  setTimeout(function() {
                    return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                  }, _this._options.imageTimeout);
                }
              })];
            case 3:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Cache2.prototype.has = function(key) {
      return typeof this._cache[key] !== "undefined";
    };
    Cache2.prototype.keys = function() {
      return Promise.resolve(Object.keys(this._cache));
    };
    Cache2.prototype.proxy = function(src2) {
      var _this = this;
      var proxy = this._options.proxy;
      if (!proxy) {
        throw new Error("No proxy defined");
      }
      var key = src2.substring(0, 256);
      return new Promise(function(resolve2, reject) {
        var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
          if (xhr.status === 200) {
            if (responseType === "text") {
              resolve2(xhr.response);
            } else {
              var reader_1 = new FileReader();
              reader_1.addEventListener("load", function() {
                return resolve2(reader_1.result);
              }, false);
              reader_1.addEventListener("error", function(e2) {
                return reject(e2);
              }, false);
              reader_1.readAsDataURL(xhr.response);
            }
          } else {
            reject("Failed to proxy resource " + key + " with status code " + xhr.status);
          }
        };
        xhr.onerror = reject;
        var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
        xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src2) + "&responseType=" + responseType);
        if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
          xhr.responseType = responseType;
        }
        if (_this._options.imageTimeout) {
          var timeout_1 = _this._options.imageTimeout;
          xhr.timeout = timeout_1;
          xhr.ontimeout = function() {
            return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
          };
        }
        xhr.send();
      });
    };
    return Cache2;
  }()
);
var INLINE_SVG = /^data:image\/svg\+xml/i;
var INLINE_BASE64 = /^data:image\/.*;base64,/i;
var INLINE_IMG = /^data:image\/.*/i;
var isRenderable = function(src2) {
  return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src2);
};
var isInlineImage = function(src2) {
  return INLINE_IMG.test(src2);
};
var isInlineBase64Image = function(src2) {
  return INLINE_BASE64.test(src2);
};
var isBlobImage = function(src2) {
  return src2.substr(0, 4) === "blob";
};
var isSVG = function(src2) {
  return src2.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src2);
};
var Vector = (
  /** @class */
  function() {
    function Vector2(x2, y2) {
      this.type = 0;
      this.x = x2;
      this.y = y2;
    }
    Vector2.prototype.add = function(deltaX, deltaY) {
      return new Vector2(this.x + deltaX, this.y + deltaY);
    };
    return Vector2;
  }()
);
var lerp = function(a2, b2, t3) {
  return new Vector(a2.x + (b2.x - a2.x) * t3, a2.y + (b2.y - a2.y) * t3);
};
var BezierCurve = (
  /** @class */
  function() {
    function BezierCurve2(start2, startControl, endControl, end2) {
      this.type = 1;
      this.start = start2;
      this.startControl = startControl;
      this.endControl = endControl;
      this.end = end2;
    }
    BezierCurve2.prototype.subdivide = function(t3, firstHalf) {
      var ab2 = lerp(this.start, this.startControl, t3);
      var bc2 = lerp(this.startControl, this.endControl, t3);
      var cd2 = lerp(this.endControl, this.end, t3);
      var abbc = lerp(ab2, bc2, t3);
      var bccd = lerp(bc2, cd2, t3);
      var dest = lerp(abbc, bccd, t3);
      return firstHalf ? new BezierCurve2(this.start, ab2, abbc, dest) : new BezierCurve2(dest, bccd, cd2, this.end);
    };
    BezierCurve2.prototype.add = function(deltaX, deltaY) {
      return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
    };
    BezierCurve2.prototype.reverse = function() {
      return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
    };
    return BezierCurve2;
  }()
);
var isBezierCurve = function(path) {
  return path.type === 1;
};
var BoundCurves = (
  /** @class */
  function() {
    function BoundCurves2(element) {
      var styles2 = element.styles;
      var bounds = element.bounds;
      var _a2 = getAbsoluteValueForTuple(styles2.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
      var _b2 = getAbsoluteValueForTuple(styles2.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
      var _c = getAbsoluteValueForTuple(styles2.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
      var _d = getAbsoluteValueForTuple(styles2.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
      var factors = [];
      factors.push((tlh + trh) / bounds.width);
      factors.push((blh + brh) / bounds.width);
      factors.push((tlv + blv) / bounds.height);
      factors.push((trv + brv) / bounds.height);
      var maxFactor = Math.max.apply(Math, factors);
      if (maxFactor > 1) {
        tlh /= maxFactor;
        tlv /= maxFactor;
        trh /= maxFactor;
        trv /= maxFactor;
        brh /= maxFactor;
        brv /= maxFactor;
        blh /= maxFactor;
        blv /= maxFactor;
      }
      var topWidth = bounds.width - trh;
      var rightHeight = bounds.height - brv;
      var bottomWidth = bounds.width - brh;
      var leftHeight = bounds.height - blv;
      var borderTopWidth2 = styles2.borderTopWidth;
      var borderRightWidth2 = styles2.borderRightWidth;
      var borderBottomWidth2 = styles2.borderBottomWidth;
      var borderLeftWidth2 = styles2.borderLeftWidth;
      var paddingTop2 = getAbsoluteValue(styles2.paddingTop, element.bounds.width);
      var paddingRight2 = getAbsoluteValue(styles2.paddingRight, element.bounds.width);
      var paddingBottom2 = getAbsoluteValue(styles2.paddingBottom, element.bounds.width);
      var paddingLeft2 = getAbsoluteValue(styles2.paddingLeft, element.bounds.width);
      this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
      this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
      this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
      this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
      this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
      this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
      this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
      this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
      this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
      this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
    }
    return BoundCurves2;
  }()
);
var CORNER;
(function(CORNER2) {
  CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
  CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
  CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
  CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
})(CORNER || (CORNER = {}));
var getCurvePoints = function(x2, y2, r1, r2, position2) {
  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  var ox = r1 * kappa;
  var oy = r2 * kappa;
  var xm = x2 + r1;
  var ym = y2 + r2;
  switch (position2) {
    case CORNER.TOP_LEFT:
      return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));
    case CORNER.TOP_RIGHT:
      return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));
    case CORNER.BOTTOM_RIGHT:
      return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
    case CORNER.BOTTOM_LEFT:
    default:
      return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));
  }
};
var calculateBorderBoxPath = function(curves) {
  return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
};
var calculateContentBoxPath = function(curves) {
  return [
    curves.topLeftContentBox,
    curves.topRightContentBox,
    curves.bottomRightContentBox,
    curves.bottomLeftContentBox
  ];
};
var calculatePaddingBoxPath = function(curves) {
  return [
    curves.topLeftPaddingBox,
    curves.topRightPaddingBox,
    curves.bottomRightPaddingBox,
    curves.bottomLeftPaddingBox
  ];
};
var TransformEffect = (
  /** @class */
  function() {
    function TransformEffect2(offsetX, offsetY, matrix2) {
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.matrix = matrix2;
      this.type = 0;
      this.target = 2 | 4;
    }
    return TransformEffect2;
  }()
);
var ClipEffect = (
  /** @class */
  function() {
    function ClipEffect2(path, target) {
      this.path = path;
      this.target = target;
      this.type = 1;
    }
    return ClipEffect2;
  }()
);
var OpacityEffect = (
  /** @class */
  function() {
    function OpacityEffect2(opacity2) {
      this.opacity = opacity2;
      this.type = 2;
      this.target = 2 | 4;
    }
    return OpacityEffect2;
  }()
);
var isTransformEffect = function(effect2) {
  return effect2.type === 0;
};
var isClipEffect = function(effect2) {
  return effect2.type === 1;
};
var isOpacityEffect = function(effect2) {
  return effect2.type === 2;
};
var equalPath = function(a2, b2) {
  if (a2.length === b2.length) {
    return a2.some(function(v2, i2) {
      return v2 === b2[i2];
    });
  }
  return false;
};
var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
  return path.map(function(point, index2) {
    switch (index2) {
      case 0:
        return point.add(deltaX, deltaY);
      case 1:
        return point.add(deltaX + deltaW, deltaY);
      case 2:
        return point.add(deltaX + deltaW, deltaY + deltaH);
      case 3:
        return point.add(deltaX, deltaY + deltaH);
    }
    return point;
  });
};
var StackingContext = (
  /** @class */
  function() {
    function StackingContext2(container) {
      this.element = container;
      this.inlineLevel = [];
      this.nonInlineLevel = [];
      this.negativeZIndex = [];
      this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
      this.positiveZIndex = [];
      this.nonPositionedFloats = [];
      this.nonPositionedInlineLevel = [];
    }
    return StackingContext2;
  }()
);
var ElementPaint = (
  /** @class */
  function() {
    function ElementPaint2(container, parent) {
      this.container = container;
      this.parent = parent;
      this.effects = [];
      this.curves = new BoundCurves(this.container);
      if (this.container.styles.opacity < 1) {
        this.effects.push(new OpacityEffect(this.container.styles.opacity));
      }
      if (this.container.styles.transform !== null) {
        var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
        var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
        var matrix2 = this.container.styles.transform;
        this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
      }
      if (this.container.styles.overflowX !== 0) {
        var borderBox = calculateBorderBoxPath(this.curves);
        var paddingBox2 = calculatePaddingBoxPath(this.curves);
        if (equalPath(borderBox, paddingBox2)) {
          this.effects.push(new ClipEffect(
            borderBox,
            2 | 4
            /* CONTENT */
          ));
        } else {
          this.effects.push(new ClipEffect(
            borderBox,
            2
            /* BACKGROUND_BORDERS */
          ));
          this.effects.push(new ClipEffect(
            paddingBox2,
            4
            /* CONTENT */
          ));
        }
      }
    }
    ElementPaint2.prototype.getEffects = function(target) {
      var inFlow = [
        2,
        3
        /* FIXED */
      ].indexOf(this.container.styles.position) === -1;
      var parent = this.parent;
      var effects = this.effects.slice(0);
      while (parent) {
        var croplessEffects = parent.effects.filter(function(effect2) {
          return !isClipEffect(effect2);
        });
        if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
          effects.unshift.apply(effects, croplessEffects);
          inFlow = [
            2,
            3
            /* FIXED */
          ].indexOf(parent.container.styles.position) === -1;
          if (parent.container.styles.overflowX !== 0) {
            var borderBox = calculateBorderBoxPath(parent.curves);
            var paddingBox2 = calculatePaddingBoxPath(parent.curves);
            if (!equalPath(borderBox, paddingBox2)) {
              effects.unshift(new ClipEffect(
                paddingBox2,
                2 | 4
                /* CONTENT */
              ));
            }
          }
        } else {
          effects.unshift.apply(effects, croplessEffects);
        }
        parent = parent.parent;
      }
      return effects.filter(function(effect2) {
        return contains(effect2.target, target);
      });
    };
    return ElementPaint2;
  }()
);
var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
  parent.container.elements.forEach(function(child) {
    var treatAsRealStackingContext = contains(
      child.flags,
      4
      /* CREATES_REAL_STACKING_CONTEXT */
    );
    var createsStackingContext2 = contains(
      child.flags,
      2
      /* CREATES_STACKING_CONTEXT */
    );
    var paintContainer = new ElementPaint(child, parent);
    if (contains(
      child.styles.display,
      2048
      /* LIST_ITEM */
    )) {
      listItems.push(paintContainer);
    }
    var listOwnerItems = contains(
      child.flags,
      8
      /* IS_LIST_OWNER */
    ) ? [] : listItems;
    if (treatAsRealStackingContext || createsStackingContext2) {
      var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
      var stack = new StackingContext(paintContainer);
      if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
        var order_1 = child.styles.zIndex.order;
        if (order_1 < 0) {
          var index_1 = 0;
          parentStack.negativeZIndex.some(function(current, i2) {
            if (order_1 > current.element.container.styles.zIndex.order) {
              index_1 = i2;
              return false;
            } else if (index_1 > 0) {
              return true;
            }
            return false;
          });
          parentStack.negativeZIndex.splice(index_1, 0, stack);
        } else if (order_1 > 0) {
          var index_2 = 0;
          parentStack.positiveZIndex.some(function(current, i2) {
            if (order_1 >= current.element.container.styles.zIndex.order) {
              index_2 = i2 + 1;
              return false;
            } else if (index_2 > 0) {
              return true;
            }
            return false;
          });
          parentStack.positiveZIndex.splice(index_2, 0, stack);
        } else {
          parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
        }
      } else {
        if (child.styles.isFloating()) {
          parentStack.nonPositionedFloats.push(stack);
        } else {
          parentStack.nonPositionedInlineLevel.push(stack);
        }
      }
      parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
    } else {
      if (child.styles.isInlineLevel()) {
        stackingContext.inlineLevel.push(paintContainer);
      } else {
        stackingContext.nonInlineLevel.push(paintContainer);
      }
      parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
    }
    if (contains(
      child.flags,
      8
      /* IS_LIST_OWNER */
    )) {
      processListItems(child, listOwnerItems);
    }
  });
};
var processListItems = function(owner, elements) {
  var numbering = owner instanceof OLElementContainer ? owner.start : 1;
  var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
  for (var i2 = 0; i2 < elements.length; i2++) {
    var item = elements[i2];
    if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
      numbering = item.container.value;
    }
    item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
    numbering += reversed ? -1 : 1;
  }
};
var parseStackingContexts = function(container) {
  var paintContainer = new ElementPaint(container, null);
  var root2 = new StackingContext(paintContainer);
  var listItems = [];
  parseStackTree(paintContainer, root2, root2, listItems);
  processListItems(paintContainer.container, listItems);
  return root2;
};
var parsePathForBorder = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderDoubleOuter = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
  }
};
var parsePathForBorderDoubleInner = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderStroke = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
    case 1:
      return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
    case 2:
      return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
    case 3:
    default:
      return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
  }
};
var createStrokePathFromCurves = function(outer1, outer2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  return path;
};
var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  if (isBezierCurve(inner2)) {
    path.push(inner2.subdivide(0.5, true).reverse());
  } else {
    path.push(inner2);
  }
  if (isBezierCurve(inner1)) {
    path.push(inner1.subdivide(0.5, false).reverse());
  } else {
    path.push(inner1);
  }
  return path;
};
var paddingBox = function(element) {
  var bounds = element.bounds;
  var styles2 = element.styles;
  return bounds.add(styles2.borderLeftWidth, styles2.borderTopWidth, -(styles2.borderRightWidth + styles2.borderLeftWidth), -(styles2.borderTopWidth + styles2.borderBottomWidth));
};
var contentBox = function(element) {
  var styles2 = element.styles;
  var bounds = element.bounds;
  var paddingLeft2 = getAbsoluteValue(styles2.paddingLeft, bounds.width);
  var paddingRight2 = getAbsoluteValue(styles2.paddingRight, bounds.width);
  var paddingTop2 = getAbsoluteValue(styles2.paddingTop, bounds.width);
  var paddingBottom2 = getAbsoluteValue(styles2.paddingBottom, bounds.width);
  return bounds.add(paddingLeft2 + styles2.borderLeftWidth, paddingTop2 + styles2.borderTopWidth, -(styles2.borderRightWidth + styles2.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles2.borderTopWidth + styles2.borderBottomWidth + paddingTop2 + paddingBottom2));
};
var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
  if (backgroundOrigin2 === 0) {
    return element.bounds;
  }
  if (backgroundOrigin2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
  if (backgroundClip2 === 0) {
    return element.bounds;
  }
  if (backgroundClip2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
  var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
  var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
  var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
  var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
  var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
  var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
  var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
  var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
  return [path, offsetX, offsetY, sizeWidth, sizeHeight];
};
var isAuto = function(token2) {
  return isIdentToken(token2) && token2.value === BACKGROUND_SIZE.AUTO;
};
var hasIntrinsicValue = function(value) {
  return typeof value === "number";
};
var calculateBackgroundSize = function(size, _a2, bounds) {
  var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
  var first = size[0], second = size[1];
  if (!first) {
    return [0, 0];
  }
  if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
    return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
  }
  var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
  if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
    if (hasIntrinsicValue(intrinsicProportion)) {
      var targetRatio = bounds.width / bounds.height;
      return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
    }
    return [bounds.width, bounds.height];
  }
  var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
  var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
  var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
  if (isAuto(first) && (!second || isAuto(second))) {
    if (hasIntrinsicWidth && hasIntrinsicHeight) {
      return [intrinsicWidth, intrinsicHeight];
    }
    if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
      return [bounds.width, bounds.height];
    }
    if (hasIntrinsicDimensions && hasIntrinsicProportion) {
      var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
      var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
      return [width_1, height_1];
    }
    var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
    var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
    return [width_2, height_2];
  }
  if (hasIntrinsicProportion) {
    var width_3 = 0;
    var height_3 = 0;
    if (isLengthPercentage(first)) {
      width_3 = getAbsoluteValue(first, bounds.width);
    } else if (isLengthPercentage(second)) {
      height_3 = getAbsoluteValue(second, bounds.height);
    }
    if (isAuto(first)) {
      width_3 = height_3 * intrinsicProportion;
    } else if (!second || isAuto(second)) {
      height_3 = width_3 / intrinsicProportion;
    }
    return [width_3, height_3];
  }
  var width2 = null;
  var height2 = null;
  if (isLengthPercentage(first)) {
    width2 = getAbsoluteValue(first, bounds.width);
  } else if (second && isLengthPercentage(second)) {
    height2 = getAbsoluteValue(second, bounds.height);
  }
  if (width2 !== null && (!second || isAuto(second))) {
    height2 = hasIntrinsicWidth && hasIntrinsicHeight ? width2 / intrinsicWidth * intrinsicHeight : bounds.height;
  }
  if (height2 !== null && isAuto(first)) {
    width2 = hasIntrinsicWidth && hasIntrinsicHeight ? height2 / intrinsicHeight * intrinsicWidth : bounds.width;
  }
  if (width2 !== null && height2 !== null) {
    return [width2, height2];
  }
  throw new Error("Unable to calculate background-size for element");
};
var getBackgroundValueForIndex = function(values2, index2) {
  var value = values2[index2];
  if (typeof value === "undefined") {
    return values2[0];
  }
  return value;
};
var calculateBackgroundRepeatPath = function(repeat2, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
  var x2 = _a2[0], y2 = _a2[1];
  var width2 = _b2[0], height2 = _b2[1];
  switch (repeat2) {
    case 2:
      return [
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height2 + backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height2 + backgroundPositioningArea.top + y2))
      ];
    case 3:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
      ];
    case 1:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width2), Math.round(backgroundPositioningArea.top + y2 + height2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height2))
      ];
    default:
      return [
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
      ];
  }
};
var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var SAMPLE_TEXT = "Hidden Text";
var FontMetrics = (
  /** @class */
  function() {
    function FontMetrics2(document2) {
      this._data = {};
      this._document = document2;
    }
    FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
      var container = this._document.createElement("div");
      var img = this._document.createElement("img");
      var span = this._document.createElement("span");
      var body = this._document.body;
      container.style.visibility = "hidden";
      container.style.fontFamily = fontFamily2;
      container.style.fontSize = fontSize2;
      container.style.margin = "0";
      container.style.padding = "0";
      container.style.whiteSpace = "nowrap";
      body.appendChild(container);
      img.src = SMALL_IMAGE;
      img.width = 1;
      img.height = 1;
      img.style.margin = "0";
      img.style.padding = "0";
      img.style.verticalAlign = "baseline";
      span.style.fontFamily = fontFamily2;
      span.style.fontSize = fontSize2;
      span.style.margin = "0";
      span.style.padding = "0";
      span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.appendChild(span);
      container.appendChild(img);
      var baseline = img.offsetTop - span.offsetTop + 2;
      container.removeChild(span);
      container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.style.lineHeight = "normal";
      img.style.verticalAlign = "super";
      var middle = img.offsetTop - container.offsetTop + 2;
      body.removeChild(container);
      return { baseline, middle };
    };
    FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
      var key = fontFamily2 + " " + fontSize2;
      if (typeof this._data[key] === "undefined") {
        this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
      }
      return this._data[key];
    };
    return FontMetrics2;
  }()
);
var Renderer = (
  /** @class */
  function() {
    function Renderer2(context, options) {
      this.context = context;
      this.options = options;
    }
    return Renderer2;
  }()
);
var MASK_OFFSET = 1e4;
var CanvasRenderer = (
  /** @class */
  function(_super) {
    __extends(CanvasRenderer2, _super);
    function CanvasRenderer2(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this._activeEffects = [];
      _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
      _this.ctx = _this.canvas.getContext("2d");
      if (!options.canvas) {
        _this.canvas.width = Math.floor(options.width * options.scale);
        _this.canvas.height = Math.floor(options.height * options.scale);
        _this.canvas.style.width = options.width + "px";
        _this.canvas.style.height = options.height + "px";
      }
      _this.fontMetrics = new FontMetrics(document);
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.ctx.textBaseline = "bottom";
      _this._activeEffects = [];
      _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
      return _this;
    }
    CanvasRenderer2.prototype.applyEffects = function(effects) {
      var _this = this;
      while (this._activeEffects.length) {
        this.popEffect();
      }
      effects.forEach(function(effect2) {
        return _this.applyEffect(effect2);
      });
    };
    CanvasRenderer2.prototype.applyEffect = function(effect2) {
      this.ctx.save();
      if (isOpacityEffect(effect2)) {
        this.ctx.globalAlpha = effect2.opacity;
      }
      if (isTransformEffect(effect2)) {
        this.ctx.translate(effect2.offsetX, effect2.offsetY);
        this.ctx.transform(effect2.matrix[0], effect2.matrix[1], effect2.matrix[2], effect2.matrix[3], effect2.matrix[4], effect2.matrix[5]);
        this.ctx.translate(-effect2.offsetX, -effect2.offsetY);
      }
      if (isClipEffect(effect2)) {
        this.path(effect2.path);
        this.ctx.clip();
      }
      this._activeEffects.push(effect2);
    };
    CanvasRenderer2.prototype.popEffect = function() {
      this._activeEffects.pop();
      this.ctx.restore();
    };
    CanvasRenderer2.prototype.renderStack = function(stack) {
      return __awaiter(this, void 0, void 0, function() {
        var styles2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              styles2 = stack.element.container.styles;
              if (!styles2.isVisible())
                return [3, 2];
              return [4, this.renderStackContent(stack)];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderNode = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (contains(
                paint.container.flags,
                16
                /* DEBUG_RENDER */
              )) {
                debugger;
              }
              if (!paint.container.styles.isVisible())
                return [3, 3];
              return [4, this.renderNodeBackgroundAndBorders(paint)];
            case 1:
              _a2.sent();
              return [4, this.renderNodeContent(paint)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
      var _this = this;
      if (letterSpacing2 === 0) {
        this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
      } else {
        var letters = segmentGraphemes(text.text);
        letters.reduce(function(left2, letter) {
          _this.ctx.fillText(letter, left2, text.bounds.top + baseline);
          return left2 + _this.ctx.measureText(letter).width;
        }, text.bounds.left);
      }
    };
    CanvasRenderer2.prototype.createFontStyle = function(styles2) {
      var fontVariant2 = styles2.fontVariant.filter(function(variant) {
        return variant === "normal" || variant === "small-caps";
      }).join("");
      var fontFamily2 = fixIOSSystemFonts(styles2.fontFamily).join(", ");
      var fontSize2 = isDimensionToken(styles2.fontSize) ? "" + styles2.fontSize.number + styles2.fontSize.unit : styles2.fontSize.number + "px";
      return [
        [styles2.fontStyle, fontVariant2, styles2.fontWeight, fontSize2, fontFamily2].join(" "),
        fontFamily2,
        fontSize2
      ];
    };
    CanvasRenderer2.prototype.renderTextNode = function(text, styles2) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
        var _this = this;
        return __generator(this, function(_c) {
          _a2 = this.createFontStyle(styles2), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
          this.ctx.font = font;
          this.ctx.direction = styles2.direction === 1 ? "rtl" : "ltr";
          this.ctx.textAlign = "left";
          this.ctx.textBaseline = "alphabetic";
          _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
          paintOrder2 = styles2.paintOrder;
          text.textBounds.forEach(function(text2) {
            paintOrder2.forEach(function(paintOrderLayer) {
              switch (paintOrderLayer) {
                case 0:
                  _this.ctx.fillStyle = asString(styles2.color);
                  _this.renderTextWithLetterSpacing(text2, styles2.letterSpacing, baseline);
                  var textShadows = styles2.textShadow;
                  if (textShadows.length && text2.text.trim().length) {
                    textShadows.slice(0).reverse().forEach(function(textShadow2) {
                      _this.ctx.shadowColor = asString(textShadow2.color);
                      _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                      _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                      _this.ctx.shadowBlur = textShadow2.blur.number;
                      _this.renderTextWithLetterSpacing(text2, styles2.letterSpacing, baseline);
                    });
                    _this.ctx.shadowColor = "";
                    _this.ctx.shadowOffsetX = 0;
                    _this.ctx.shadowOffsetY = 0;
                    _this.ctx.shadowBlur = 0;
                  }
                  if (styles2.textDecorationLine.length) {
                    _this.ctx.fillStyle = asString(styles2.textDecorationColor || styles2.color);
                    styles2.textDecorationLine.forEach(function(textDecorationLine2) {
                      switch (textDecorationLine2) {
                        case 1:
                          _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                          break;
                        case 2:
                          _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                          break;
                        case 3:
                          _this.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                          break;
                      }
                    });
                  }
                  break;
                case 1:
                  if (styles2.webkitTextStrokeWidth && text2.text.trim().length) {
                    _this.ctx.strokeStyle = asString(styles2.webkitTextStrokeColor);
                    _this.ctx.lineWidth = styles2.webkitTextStrokeWidth;
                    _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                    _this.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                  }
                  _this.ctx.strokeStyle = "";
                  _this.ctx.lineWidth = 0;
                  _this.ctx.lineJoin = "miter";
                  break;
              }
            });
          });
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
      if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
        var box = contentBox(container);
        var path = calculatePaddingBoxPath(curves);
        this.path(path);
        this.ctx.save();
        this.ctx.clip();
        this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
        this.ctx.restore();
      }
    };
    CanvasRenderer2.prototype.renderNodeContent = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        var container, curves, styles2, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              this.applyEffects(paint.getEffects(
                4
                /* CONTENT */
              ));
              container = paint.container;
              curves = paint.curves;
              styles2 = container.styles;
              _i = 0, _a2 = container.textNodes;
              _c.label = 1;
            case 1:
              if (!(_i < _a2.length))
                return [3, 4];
              child = _a2[_i];
              return [4, this.renderTextNode(child, styles2)];
            case 2:
              _c.sent();
              _c.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              if (!(container instanceof ImageElementContainer))
                return [3, 8];
              _c.label = 5;
            case 5:
              _c.trys.push([5, 7, , 8]);
              return [4, this.context.cache.match(container.src)];
            case 6:
              image2 = _c.sent();
              this.renderReplacedElement(container, curves, image2);
              return [3, 8];
            case 7:
              _c.sent();
              this.context.logger.error("Error loading image " + container.src);
              return [3, 8];
            case 8:
              if (container instanceof CanvasElementContainer) {
                this.renderReplacedElement(container, curves, container.canvas);
              }
              if (!(container instanceof SVGElementContainer))
                return [3, 12];
              _c.label = 9;
            case 9:
              _c.trys.push([9, 11, , 12]);
              return [4, this.context.cache.match(container.svg)];
            case 10:
              image2 = _c.sent();
              this.renderReplacedElement(container, curves, image2);
              return [3, 12];
            case 11:
              _c.sent();
              this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
              return [3, 12];
            case 12:
              if (!(container instanceof IFrameElementContainer && container.tree))
                return [3, 14];
              iframeRenderer = new CanvasRenderer2(this.context, {
                scale: this.options.scale,
                backgroundColor: container.backgroundColor,
                x: 0,
                y: 0,
                width: container.width,
                height: container.height
              });
              return [4, iframeRenderer.render(container.tree)];
            case 13:
              canvas = _c.sent();
              if (container.width && container.height) {
                this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
              }
              _c.label = 14;
            case 14:
              if (container instanceof InputElementContainer) {
                size = Math.min(container.bounds.width, container.bounds.height);
                if (container.type === CHECKBOX) {
                  if (container.checked) {
                    this.ctx.save();
                    this.path([
                      new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                      new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                      new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                      new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                      new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                      new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                      new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                    ]);
                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                } else if (container.type === RADIO) {
                  if (container.checked) {
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                }
              }
              if (isTextInputElement(container) && container.value.length) {
                _b2 = this.createFontStyle(styles2), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                this.ctx.font = fontFamily2;
                this.ctx.fillStyle = asString(styles2.color);
                this.ctx.textBaseline = "alphabetic";
                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                bounds = contentBox(container);
                x2 = 0;
                switch (container.styles.textAlign) {
                  case 1:
                    x2 += bounds.width / 2;
                    break;
                  case 2:
                    x2 += bounds.width;
                    break;
                }
                textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                this.ctx.save();
                this.path([
                  new Vector(bounds.left, bounds.top),
                  new Vector(bounds.left + bounds.width, bounds.top),
                  new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                  new Vector(bounds.left, bounds.top + bounds.height)
                ]);
                this.ctx.clip();
                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles2.letterSpacing, baseline);
                this.ctx.restore();
                this.ctx.textBaseline = "alphabetic";
                this.ctx.textAlign = "left";
              }
              if (!contains(
                container.styles.display,
                2048
                /* LIST_ITEM */
              ))
                return [3, 20];
              if (!(container.styles.listStyleImage !== null))
                return [3, 19];
              img = container.styles.listStyleImage;
              if (!(img.type === 0))
                return [3, 18];
              image2 = void 0;
              url = img.url;
              _c.label = 15;
            case 15:
              _c.trys.push([15, 17, , 18]);
              return [4, this.context.cache.match(url)];
            case 16:
              image2 = _c.sent();
              this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
              return [3, 18];
            case 17:
              _c.sent();
              this.context.logger.error("Error loading list-style-image " + url);
              return [3, 18];
            case 18:
              return [3, 20];
            case 19:
              if (paint.listValue && container.styles.listStyleType !== -1) {
                fontFamily2 = this.createFontStyle(styles2)[0];
                this.ctx.font = fontFamily2;
                this.ctx.fillStyle = asString(styles2.color);
                this.ctx.textBaseline = "middle";
                this.ctx.textAlign = "right";
                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles2.lineHeight, styles2.fontSize.number) / 2 + 1);
                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles2.letterSpacing, computeLineHeight(styles2.lineHeight, styles2.fontSize.number) / 2 + 2);
                this.ctx.textBaseline = "bottom";
                this.ctx.textAlign = "left";
              }
              _c.label = 20;
            case 20:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderStackContent = function(stack) {
      return __awaiter(this, void 0, void 0, function() {
        var _i, _a2, child, _b2, _c, child, _d, _e2, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
        return __generator(this, function(_p) {
          switch (_p.label) {
            case 0:
              if (contains(
                stack.element.container.flags,
                16
                /* DEBUG_RENDER */
              )) {
                debugger;
              }
              return [4, this.renderNodeBackgroundAndBorders(stack.element)];
            case 1:
              _p.sent();
              _i = 0, _a2 = stack.negativeZIndex;
              _p.label = 2;
            case 2:
              if (!(_i < _a2.length))
                return [3, 5];
              child = _a2[_i];
              return [4, this.renderStack(child)];
            case 3:
              _p.sent();
              _p.label = 4;
            case 4:
              _i++;
              return [3, 2];
            case 5:
              return [4, this.renderNodeContent(stack.element)];
            case 6:
              _p.sent();
              _b2 = 0, _c = stack.nonInlineLevel;
              _p.label = 7;
            case 7:
              if (!(_b2 < _c.length))
                return [3, 10];
              child = _c[_b2];
              return [4, this.renderNode(child)];
            case 8:
              _p.sent();
              _p.label = 9;
            case 9:
              _b2++;
              return [3, 7];
            case 10:
              _d = 0, _e2 = stack.nonPositionedFloats;
              _p.label = 11;
            case 11:
              if (!(_d < _e2.length))
                return [3, 14];
              child = _e2[_d];
              return [4, this.renderStack(child)];
            case 12:
              _p.sent();
              _p.label = 13;
            case 13:
              _d++;
              return [3, 11];
            case 14:
              _f = 0, _g = stack.nonPositionedInlineLevel;
              _p.label = 15;
            case 15:
              if (!(_f < _g.length))
                return [3, 18];
              child = _g[_f];
              return [4, this.renderStack(child)];
            case 16:
              _p.sent();
              _p.label = 17;
            case 17:
              _f++;
              return [3, 15];
            case 18:
              _h = 0, _j = stack.inlineLevel;
              _p.label = 19;
            case 19:
              if (!(_h < _j.length))
                return [3, 22];
              child = _j[_h];
              return [4, this.renderNode(child)];
            case 20:
              _p.sent();
              _p.label = 21;
            case 21:
              _h++;
              return [3, 19];
            case 22:
              _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
              _p.label = 23;
            case 23:
              if (!(_k < _l.length))
                return [3, 26];
              child = _l[_k];
              return [4, this.renderStack(child)];
            case 24:
              _p.sent();
              _p.label = 25;
            case 25:
              _k++;
              return [3, 23];
            case 26:
              _m = 0, _o = stack.positiveZIndex;
              _p.label = 27;
            case 27:
              if (!(_m < _o.length))
                return [3, 30];
              child = _o[_m];
              return [4, this.renderStack(child)];
            case 28:
              _p.sent();
              _p.label = 29;
            case 29:
              _m++;
              return [3, 27];
            case 30:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.mask = function(paths) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0);
      this.ctx.lineTo(this.canvas.width, 0);
      this.ctx.lineTo(this.canvas.width, this.canvas.height);
      this.ctx.lineTo(0, this.canvas.height);
      this.ctx.lineTo(0, 0);
      this.formatPath(paths.slice(0).reverse());
      this.ctx.closePath();
    };
    CanvasRenderer2.prototype.path = function(paths) {
      this.ctx.beginPath();
      this.formatPath(paths);
      this.ctx.closePath();
    };
    CanvasRenderer2.prototype.formatPath = function(paths) {
      var _this = this;
      paths.forEach(function(point, index2) {
        var start2 = isBezierCurve(point) ? point.start : point;
        if (index2 === 0) {
          _this.ctx.moveTo(start2.x, start2.y);
        } else {
          _this.ctx.lineTo(start2.x, start2.y);
        }
        if (isBezierCurve(point)) {
          _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
        }
      });
    };
    CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
      this.path(path);
      this.ctx.fillStyle = pattern;
      this.ctx.translate(offsetX, offsetY);
      this.ctx.fill();
      this.ctx.translate(-offsetX, -offsetY);
    };
    CanvasRenderer2.prototype.resizeImage = function(image2, width2, height2) {
      var _a2;
      if (image2.width === width2 && image2.height === height2) {
        return image2;
      }
      var ownerDocument2 = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
      var canvas = ownerDocument2.createElement("canvas");
      canvas.width = Math.max(1, width2);
      canvas.height = Math.max(1, height2);
      var ctx = canvas.getContext("2d");
      ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width2, height2);
      return canvas;
    };
    CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
      return __awaiter(this, void 0, void 0, function() {
        var index2, _loop_1, this_1, _i, _a2, backgroundImage2;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              index2 = container.styles.backgroundImage.length - 1;
              _loop_1 = function(backgroundImage3) {
                var image2, url, _c, path, x2, y2, width2, height2, pattern, _d, path, x2, y2, width2, height2, _e2, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left2, top_1, width2, height2, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                return __generator(this, function(_h) {
                  switch (_h.label) {
                    case 0:
                      if (!(backgroundImage3.type === 0))
                        return [3, 5];
                      image2 = void 0;
                      url = backgroundImage3.url;
                      _h.label = 1;
                    case 1:
                      _h.trys.push([1, 3, , 4]);
                      return [4, this_1.context.cache.match(url)];
                    case 2:
                      image2 = _h.sent();
                      return [3, 4];
                    case 3:
                      _h.sent();
                      this_1.context.logger.error("Error loading background-image " + url);
                      return [3, 4];
                    case 4:
                      if (image2) {
                        _c = calculateBackgroundRendering(container, index2, [
                          image2.width,
                          image2.height,
                          image2.width / image2.height
                        ]), path = _c[0], x2 = _c[1], y2 = _c[2], width2 = _c[3], height2 = _c[4];
                        pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width2, height2), "repeat");
                        this_1.renderRepeat(path, pattern, x2, y2);
                      }
                      return [3, 6];
                    case 5:
                      if (isLinearGradient(backgroundImage3)) {
                        _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x2 = _d[1], y2 = _d[2], width2 = _d[3], height2 = _d[4];
                        _e2 = calculateGradientDirection(backgroundImage3.angle, width2, height2), lineLength = _e2[0], x0 = _e2[1], x1 = _e2[2], y0 = _e2[3], y1 = _e2[4];
                        canvas = document.createElement("canvas");
                        canvas.width = width2;
                        canvas.height = height2;
                        ctx = canvas.getContext("2d");
                        gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                        processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                          return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                        });
                        ctx.fillStyle = gradient_1;
                        ctx.fillRect(0, 0, width2, height2);
                        if (width2 > 0 && height2 > 0) {
                          pattern = this_1.ctx.createPattern(canvas, "repeat");
                          this_1.renderRepeat(path, pattern, x2, y2);
                        }
                      } else if (isRadialGradient(backgroundImage3)) {
                        _f = calculateBackgroundRendering(container, index2, [
                          null,
                          null,
                          null
                        ]), path = _f[0], left2 = _f[1], top_1 = _f[2], width2 = _f[3], height2 = _f[4];
                        position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                        x2 = getAbsoluteValue(position2[0], width2);
                        y2 = getAbsoluteValue(position2[position2.length - 1], height2);
                        _g = calculateRadius(backgroundImage3, x2, y2, width2, height2), rx = _g[0], ry = _g[1];
                        if (rx > 0 && ry > 0) {
                          radialGradient_1 = this_1.ctx.createRadialGradient(left2 + x2, top_1 + y2, 0, left2 + x2, top_1 + y2, rx);
                          processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                            return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                          });
                          this_1.path(path);
                          this_1.ctx.fillStyle = radialGradient_1;
                          if (rx !== ry) {
                            midX = container.bounds.left + 0.5 * container.bounds.width;
                            midY = container.bounds.top + 0.5 * container.bounds.height;
                            f2 = ry / rx;
                            invF = 1 / f2;
                            this_1.ctx.save();
                            this_1.ctx.translate(midX, midY);
                            this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                            this_1.ctx.translate(-midX, -midY);
                            this_1.ctx.fillRect(left2, invF * (top_1 - midY) + midY, width2, height2 * invF);
                            this_1.ctx.restore();
                          } else {
                            this_1.ctx.fill();
                          }
                        }
                      }
                      _h.label = 6;
                    case 6:
                      index2--;
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              };
              this_1 = this;
              _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
              _b2.label = 1;
            case 1:
              if (!(_i < _a2.length))
                return [3, 4];
              backgroundImage2 = _a2[_i];
              return [5, _loop_1(backgroundImage2)];
            case 2:
              _b2.sent();
              _b2.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          this.path(parsePathForBorder(curvePoints, side));
          this.ctx.fillStyle = asString(color2);
          this.ctx.fill();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width2, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function() {
        var outerPaths, innerPaths;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!(width2 < 3))
                return [3, 2];
              return [4, this.renderSolidBorder(color2, side, curvePoints)];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
            case 2:
              outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
              this.path(outerPaths);
              this.ctx.fillStyle = asString(color2);
              this.ctx.fill();
              innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
              this.path(innerPaths);
              this.ctx.fill();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        var styles2, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border2;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.applyEffects(paint.getEffects(
                2
                /* BACKGROUND_BORDERS */
              ));
              styles2 = paint.container.styles;
              hasBackground = !isTransparent(styles2.backgroundColor) || styles2.backgroundImage.length;
              borders = [
                { style: styles2.borderTopStyle, color: styles2.borderTopColor, width: styles2.borderTopWidth },
                { style: styles2.borderRightStyle, color: styles2.borderRightColor, width: styles2.borderRightWidth },
                { style: styles2.borderBottomStyle, color: styles2.borderBottomColor, width: styles2.borderBottomWidth },
                { style: styles2.borderLeftStyle, color: styles2.borderLeftColor, width: styles2.borderLeftWidth }
              ];
              backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles2.backgroundClip, 0), paint.curves);
              if (!(hasBackground || styles2.boxShadow.length))
                return [3, 2];
              this.ctx.save();
              this.path(backgroundPaintingArea);
              this.ctx.clip();
              if (!isTransparent(styles2.backgroundColor)) {
                this.ctx.fillStyle = asString(styles2.backgroundColor);
                this.ctx.fill();
              }
              return [4, this.renderBackgroundImage(paint.container)];
            case 1:
              _a2.sent();
              this.ctx.restore();
              styles2.boxShadow.slice(0).reverse().forEach(function(shadow) {
                _this.ctx.save();
                var borderBoxArea = calculateBorderBoxPath(paint.curves);
                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                if (shadow.inset) {
                  _this.path(borderBoxArea);
                  _this.ctx.clip();
                  _this.mask(shadowPaintingArea);
                } else {
                  _this.mask(borderBoxArea);
                  _this.ctx.clip();
                  _this.path(shadowPaintingArea);
                }
                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                _this.ctx.shadowOffsetY = shadow.offsetY.number;
                _this.ctx.shadowColor = asString(shadow.color);
                _this.ctx.shadowBlur = shadow.blur.number;
                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                _this.ctx.fill();
                _this.ctx.restore();
              });
              _a2.label = 2;
            case 2:
              side = 0;
              _i = 0, borders_1 = borders;
              _a2.label = 3;
            case 3:
              if (!(_i < borders_1.length))
                return [3, 13];
              border2 = borders_1[_i];
              if (!(border2.style !== 0 && !isTransparent(border2.color) && border2.width > 0))
                return [3, 11];
              if (!(border2.style === 2))
                return [3, 5];
              return [4, this.renderDashedDottedBorder(
                border2.color,
                border2.width,
                side,
                paint.curves,
                2
                /* DASHED */
              )];
            case 4:
              _a2.sent();
              return [3, 11];
            case 5:
              if (!(border2.style === 3))
                return [3, 7];
              return [4, this.renderDashedDottedBorder(
                border2.color,
                border2.width,
                side,
                paint.curves,
                3
                /* DOTTED */
              )];
            case 6:
              _a2.sent();
              return [3, 11];
            case 7:
              if (!(border2.style === 4))
                return [3, 9];
              return [4, this.renderDoubleBorder(border2.color, border2.width, side, paint.curves)];
            case 8:
              _a2.sent();
              return [3, 11];
            case 9:
              return [4, this.renderSolidBorder(border2.color, side, paint.curves)];
            case 10:
              _a2.sent();
              _a2.label = 11;
            case 11:
              side++;
              _a2.label = 12;
            case 12:
              _i++;
              return [3, 3];
            case 13:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width2, side, curvePoints, style2) {
      return __awaiter(this, void 0, void 0, function() {
        var strokePaths, boxPaths, startX, startY, endX, endY, length2, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
        return __generator(this, function(_a2) {
          this.ctx.save();
          strokePaths = parsePathForBorderStroke(curvePoints, side);
          boxPaths = parsePathForBorder(curvePoints, side);
          if (style2 === 2) {
            this.path(boxPaths);
            this.ctx.clip();
          }
          if (isBezierCurve(boxPaths[0])) {
            startX = boxPaths[0].start.x;
            startY = boxPaths[0].start.y;
          } else {
            startX = boxPaths[0].x;
            startY = boxPaths[0].y;
          }
          if (isBezierCurve(boxPaths[1])) {
            endX = boxPaths[1].end.x;
            endY = boxPaths[1].end.y;
          } else {
            endX = boxPaths[1].x;
            endY = boxPaths[1].y;
          }
          if (side === 0 || side === 2) {
            length2 = Math.abs(startX - endX);
          } else {
            length2 = Math.abs(startY - endY);
          }
          this.ctx.beginPath();
          if (style2 === 3) {
            this.formatPath(strokePaths);
          } else {
            this.formatPath(boxPaths.slice(0, 2));
          }
          dashLength = width2 < 3 ? width2 * 3 : width2 * 2;
          spaceLength = width2 < 3 ? width2 * 2 : width2;
          if (style2 === 3) {
            dashLength = width2;
            spaceLength = width2;
          }
          useLineDash = true;
          if (length2 <= dashLength * 2) {
            useLineDash = false;
          } else if (length2 <= dashLength * 2 + spaceLength) {
            multiplier = length2 / (2 * dashLength + spaceLength);
            dashLength *= multiplier;
            spaceLength *= multiplier;
          } else {
            numberOfDashes = Math.floor((length2 + spaceLength) / (dashLength + spaceLength));
            minSpace = (length2 - numberOfDashes * dashLength) / (numberOfDashes - 1);
            maxSpace = (length2 - (numberOfDashes + 1) * dashLength) / numberOfDashes;
            spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
          }
          if (useLineDash) {
            if (style2 === 3) {
              this.ctx.setLineDash([0, dashLength + spaceLength]);
            } else {
              this.ctx.setLineDash([dashLength, spaceLength]);
            }
          }
          if (style2 === 3) {
            this.ctx.lineCap = "round";
            this.ctx.lineWidth = width2;
          } else {
            this.ctx.lineWidth = width2 * 2 + 1.1;
          }
          this.ctx.strokeStyle = asString(color2);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
          if (style2 === 2) {
            if (isBezierCurve(boxPaths[0])) {
              path1 = boxPaths[3];
              path2 = boxPaths[0];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
            if (isBezierCurve(boxPaths[1])) {
              path1 = boxPaths[1];
              path2 = boxPaths[2];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
          }
          this.ctx.restore();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.render = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var stack;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
              }
              stack = parseStackingContexts(element);
              return [4, this.renderStack(stack)];
            case 1:
              _a2.sent();
              this.applyEffects([]);
              return [2, this.canvas];
          }
        });
      });
    };
    return CanvasRenderer2;
  }(Renderer)
);
var isTextInputElement = function(container) {
  if (container instanceof TextareaElementContainer) {
    return true;
  } else if (container instanceof SelectElementContainer) {
    return true;
  } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
    return true;
  }
  return false;
};
var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
  switch (clip) {
    case 0:
      return calculateBorderBoxPath(curves);
    case 2:
      return calculateContentBoxPath(curves);
    case 1:
    default:
      return calculatePaddingBoxPath(curves);
  }
};
var canvasTextAlign = function(textAlign2) {
  switch (textAlign2) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
};
var iOSBrokenFonts = ["-apple-system", "system-ui"];
var fixIOSSystemFonts = function(fontFamilies) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
    return iOSBrokenFonts.indexOf(fontFamily2) === -1;
  }) : fontFamilies;
};
var ForeignObjectRenderer = (
  /** @class */
  function(_super) {
    __extends(ForeignObjectRenderer2, _super);
    function ForeignObjectRenderer2(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
      _this.ctx = _this.canvas.getContext("2d");
      _this.options = options;
      _this.canvas.width = Math.floor(options.width * options.scale);
      _this.canvas.height = Math.floor(options.height * options.scale);
      _this.canvas.style.width = options.width + "px";
      _this.canvas.style.height = options.height + "px";
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
      return _this;
    }
    ForeignObjectRenderer2.prototype.render = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var svg, img;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
              return [4, loadSerializedSVG(svg)];
            case 1:
              img = _a2.sent();
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
              }
              this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
              return [2, this.canvas];
          }
        });
      });
    };
    return ForeignObjectRenderer2;
  }(Renderer)
);
var loadSerializedSVG = function(svg) {
  return new Promise(function(resolve2, reject) {
    var img = new Image();
    img.onload = function() {
      resolve2(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  });
};
var Logger = (
  /** @class */
  function() {
    function Logger2(_a2) {
      var id2 = _a2.id, enabled = _a2.enabled;
      this.id = id2;
      this.enabled = enabled;
      this.start = Date.now();
    }
    Logger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
          console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.prototype.getTime = function() {
      return Date.now() - this.start;
    };
    Logger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
          console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        }
      }
    };
    Logger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
          console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
          console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.instances = {};
    return Logger2;
  }()
);
var Context2 = (
  /** @class */
  function() {
    function Context3(options, windowBounds) {
      var _a2;
      this.windowBounds = windowBounds;
      this.instanceName = "#" + Context3.instanceCount++;
      this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
      this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
    }
    Context3.instanceCount = 1;
    return Context3;
  }()
);
var html2canvas = function(element, options) {
  if (options === void 0) {
    options = {};
  }
  return renderElement(element, options);
};
if (typeof window !== "undefined") {
  CacheStorage.setContext(window);
}
var renderElement = function(element, opts) {
  return __awaiter(void 0, void 0, void 0, function() {
    var ownerDocument2, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width2, height2, left2, top2, backgroundColor2, renderOptions, canvas, renderer, root2, renderer;
    var _b2, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t5;
    return __generator(this, function(_u) {
      switch (_u.label) {
        case 0:
          if (!element || typeof element !== "object") {
            return [2, Promise.reject("Invalid element provided as first argument")];
          }
          ownerDocument2 = element.ownerDocument;
          if (!ownerDocument2) {
            throw new Error("Element is not attached to a Document");
          }
          defaultView = ownerDocument2.defaultView;
          if (!defaultView) {
            throw new Error("Document is not attached to a Window");
          }
          resourceOptions = {
            allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
            imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
            proxy: opts.proxy,
            useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
          };
          contextOptions = __assign({ logging: (_e2 = opts.logging) !== null && _e2 !== void 0 ? _e2 : true, cache: opts.cache }, resourceOptions);
          windowOptions = {
            windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
            windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
            scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
            scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
          };
          windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
          context = new Context2(contextOptions, windowBounds);
          foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
          cloneOptions = {
            allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
            onclone: opts.onclone,
            ignoreElements: opts.ignoreElements,
            inlineImages: foreignObjectRendering,
            copyStyles: foreignObjectRendering
          };
          context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
          documentCloner = new DocumentCloner(context, element, cloneOptions);
          clonedElement = documentCloner.clonedReferenceElement;
          if (!clonedElement) {
            return [2, Promise.reject("Unable to find element in cloned iframe")];
          }
          return [4, documentCloner.toIFrame(ownerDocument2, windowBounds)];
        case 1:
          container = _u.sent();
          _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width2 = _a2.width, height2 = _a2.height, left2 = _a2.left, top2 = _a2.top;
          backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
          renderOptions = {
            canvas: opts.canvas,
            backgroundColor: backgroundColor2,
            scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
            x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left2,
            y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top2,
            width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width2),
            height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height2)
          };
          if (!foreignObjectRendering)
            return [3, 3];
          context.logger.debug("Document cloned, using foreign object rendering");
          renderer = new ForeignObjectRenderer(context, renderOptions);
          return [4, renderer.render(clonedElement)];
        case 2:
          canvas = _u.sent();
          return [3, 5];
        case 3:
          context.logger.debug("Document cloned, element located at " + left2 + "," + top2 + " with size " + width2 + "x" + height2 + " using computed rendering");
          context.logger.debug("Starting DOM parsing");
          root2 = parseTree(context, clonedElement);
          if (backgroundColor2 === root2.styles.backgroundColor) {
            root2.styles.backgroundColor = COLORS.TRANSPARENT;
          }
          context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
          renderer = new CanvasRenderer(context, renderOptions);
          return [4, renderer.render(root2)];
        case 4:
          canvas = _u.sent();
          _u.label = 5;
        case 5:
          if ((_t5 = opts.removeContainer) !== null && _t5 !== void 0 ? _t5 : true) {
            if (!DocumentCloner.destroy(container)) {
              context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
            }
          }
          context.logger.debug("Finished rendering");
          return [2, canvas];
      }
    });
  });
};
var parseBackgroundColor = function(context, element, backgroundColorOverride) {
  var ownerDocument2 = element.ownerDocument;
  var documentBackgroundColor = ownerDocument2.documentElement ? parseColor(context, getComputedStyle(ownerDocument2.documentElement).backgroundColor) : COLORS.TRANSPARENT;
  var bodyBackgroundColor = ownerDocument2.body ? parseColor(context, getComputedStyle(ownerDocument2.body).backgroundColor) : COLORS.TRANSPARENT;
  var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
  return element === ownerDocument2.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
};
const html2canvas_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: html2canvas
}, Symbol.toStringTag, { value: "Module" }));
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb2, start2) {
  var b2 = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b2[i2] = start2 += 1 << eb2[i2 - 1];
  }
  var r2 = new u32(b2[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j2 = b2[i2]; j2 < b2[i2 + 1]; ++j2) {
      r2[j2] = j2 - b2[i2] << 5 | i2;
    }
  }
  return [b2, r2];
};
var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];
var rev = new u16(32768);
for (var i$1 = 0; i$1 < 32768; ++i$1) {
  var x$1 = (i$1 & 43690) >>> 1 | (i$1 & 21845) << 1;
  x$1 = (x$1 & 52428) >>> 2 | (x$1 & 13107) << 2;
  x$1 = (x$1 & 61680) >>> 4 | (x$1 & 3855) << 4;
  rev[i$1] = ((x$1 & 65280) >>> 8 | (x$1 & 255) << 8) >>> 1;
}
var hMap = function(cd2, mb2, r2) {
  var s2 = cd2.length;
  var i2 = 0;
  var l2 = new u16(mb2);
  for (; i2 < s2; ++i2)
    ++l2[cd2[i2] - 1];
  var le2 = new u16(mb2);
  for (i2 = 0; i2 < mb2; ++i2) {
    le2[i2] = le2[i2 - 1] + l2[i2 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb2);
    var rvb = 15 - mb2;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd2[i2]) {
        var sv = i2 << 4 | cd2[i2];
        var r_1 = mb2 - cd2[i2];
        var v2 = le2[cd2[i2] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2)
      co[i2] = rev[le2[cd2[i2] - 1]++] >>> 15 - cd2[i2];
  }
  return co;
};
var flt = new u8(288);
for (var i$1 = 0; i$1 < 144; ++i$1)
  flt[i$1] = 8;
for (var i$1 = 144; i$1 < 256; ++i$1)
  flt[i$1] = 9;
for (var i$1 = 256; i$1 < 280; ++i$1)
  flt[i$1] = 7;
for (var i$1 = 280; i$1 < 288; ++i$1)
  flt[i$1] = 8;
var fdt = new u8(32);
for (var i$1 = 0; i$1 < 32; ++i$1)
  fdt[i$1] = 5;
var flm = /* @__PURE__ */ hMap(flt, 9, 0), flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0), fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a2) {
  var m2 = a2[0];
  for (var i2 = 1; i2 < a2.length; ++i2) {
    if (a2[i2] > m2)
      m2 = a2[i2];
  }
  return m2;
};
var bits = function(d2, p2, m2) {
  var o2 = p2 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8) >>> (p2 & 7) & m2;
};
var bits16 = function(d2, p2) {
  var o2 = p2 / 8 >> 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >>> (p2 & 7);
};
var shft = function(p2) {
  return (p2 / 8 >> 0) + (p2 & 7 && 1);
};
var slc = function(v2, s2, e2) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e2 == null || e2 > v2.length)
    e2 = v2.length;
  var n2 = new (v2 instanceof u16 ? u16 : v2 instanceof u32 ? u32 : u8)(e2 - s2);
  n2.set(v2.subarray(s2, e2));
  return n2;
};
var inflt = function(dat, buf, st2) {
  var sl2 = dat.length;
  var noBuf = !buf || st2;
  var noSt = !st2 || st2.i;
  if (!st2)
    st2 = {};
  if (!buf)
    buf = new u8(sl2 * 3);
  var cbuf = function(l3) {
    var bl2 = buf.length;
    if (l3 > bl2) {
      var nbuf = new u8(Math.max(bl2 * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st2.f || 0, pos = st2.p || 0, bt2 = st2.b || 0, lm = st2.l, dm = st2.d, lbt = st2.m, dbt = st2.n;
  var tbts = sl2 * 8;
  do {
    if (!lm) {
      st2.f = final = bits(dat, pos, 1);
      var type2 = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type2) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t3 = s2 + l2;
        if (t3 > sl2) {
          if (noSt)
            throw "unexpected EOF";
          break;
        }
        if (noBuf)
          cbuf(bt2 + l2);
        buf.set(dat.subarray(s2, t3), bt2);
        st2.b = bt2 += l2, st2.p = pos = t3 * 8;
        continue;
      } else if (type2 == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type2 == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl2 = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl2);
        var clt = new u8(19);
        for (var i2 = 0; i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        if (!noSt && pos + tl2 * (clb + 7) > tbts)
          break;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0; i2 < tl2; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s2 = r2 >>> 4;
          if (s2 < 16) {
            ldt[i2++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i2 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i2++] = c2;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt2 = ldt.subarray(hLit);
        lbt = max(lt2);
        dbt = max(dt2);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt2, dbt, 1);
      } else
        throw "invalid block type";
      if (pos > tbts)
        throw "unexpected EOF";
    }
    if (noBuf)
      cbuf(bt2 + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var mxa = lbt + dbt + 18;
    while (noSt || pos + mxa < tbts) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >>> 4;
      pos += c2 & 15;
      if (pos > tbts)
        throw "unexpected EOF";
      if (!c2)
        throw "invalid length/literal";
      if (sym < 256)
        buf[bt2++] = sym;
      else if (sym == 256) {
        lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b2 = fleb[i2];
          add = bits(dat, pos, (1 << b2) - 1) + fl[i2];
          pos += b2;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >>> 4;
        if (!d2)
          throw "invalid distance";
        pos += d2 & 15;
        var dt2 = fd[dsym];
        if (dsym > 3) {
          var b2 = fdeb[dsym];
          dt2 += bits16(dat, pos) & (1 << b2) - 1, pos += b2;
        }
        if (pos > tbts)
          throw "unexpected EOF";
        if (noBuf)
          cbuf(bt2 + 131072);
        var end2 = bt2 + add;
        for (; bt2 < end2; bt2 += 4) {
          buf[bt2] = buf[bt2 - dt2];
          buf[bt2 + 1] = buf[bt2 + 1 - dt2];
          buf[bt2 + 2] = buf[bt2 + 2 - dt2];
          buf[bt2 + 3] = buf[bt2 + 3 - dt2];
        }
        bt2 = end2;
      }
    }
    st2.l = lm, st2.p = pos, st2.b = bt2;
    if (lm)
      final = 1, st2.m = lbt, st2.d = dm, st2.n = dbt;
  } while (!final);
  return bt2 == buf.length ? buf : slc(buf, 0, bt2);
};
var wbits = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
};
var wbits16 = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 >> 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >>> 8;
  d2[o2 + 2] |= v2 >>> 16;
};
var hTree = function(d2, mb2) {
  var t3 = [];
  for (var i2 = 0; i2 < d2.length; ++i2) {
    if (d2[i2])
      t3.push({ s: i2, f: d2[i2] });
  }
  var s2 = t3.length;
  var t22 = t3.slice();
  if (!s2)
    return [new u8(0), 0];
  if (s2 == 1) {
    var v2 = new u8(t3[0].s + 1);
    v2[t3[0].s] = 1;
    return [v2, 1];
  }
  t3.sort(function(a2, b2) {
    return a2.f - b2.f;
  });
  t3.push({ s: -1, f: 25001 });
  var l2 = t3[0], r2 = t3[1], i0 = 0, i1 = 1, i22 = 2;
  t3[0] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  while (i1 != s2 - 1) {
    l2 = t3[t3[i0].f < t3[i22].f ? i0++ : i22++];
    r2 = t3[i0 != i1 && t3[i0].f < t3[i22].f ? i0++ : i22++];
    t3[i1++] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t3[i1 - 1], tr, 0);
  if (mbt > mb2) {
    var i2 = 0, dt2 = 0;
    var lft = mbt - mb2, cst = 1 << lft;
    t22.sort(function(a2, b2) {
      return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb2) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb2;
      } else
        break;
    }
    dt2 >>>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb2)
        dt2 -= 1 << mb2 - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt2; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb2) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb2;
  }
  return [new u8(tr), mbt];
};
var ln = function(n2, l2, d2) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
};
var lc = function(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2])
    ;
  var cl2 = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w2 = function(v2) {
    cl2[cli++] = v2;
  };
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c2[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c2[i2];
    }
  }
  return [cl2.subarray(0, cli), s2];
};
var clen = function(cf2, cl2) {
  var l2 = 0;
  for (var i2 = 0; i2 < cl2.length; ++i2)
    l2 += cf2[i2] * cl2[i2];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >>> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2)
    out[o2 + i2 + 4] = dat[i2];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf2, df2, eb2, li2, bs, bl2, p2) {
  wbits(out, p2++, final);
  ++lf2[256];
  var _a2 = hTree(lf2, 15), dlt = _a2[0], mlb = _a2[1];
  var _b2 = hTree(df2, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    lcfreq[lclt[i2] & 31]++;
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    lcfreq[lcdt[i2] & 31]++;
  var _e2 = hTree(lcfreq, 7), lct = _e2[0], mlcb = _e2[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl2 + 5 << 3;
  var ftlen = clen(lf2, flt) + clen(df2, fdt) + eb2;
  var dtlen = clen(lf2, dlt) + clen(df2, ddt) + eb2 + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p2, dat.subarray(bs, bs + bl2));
  var lm, ll2, dm, dl2;
  wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll2 = dlt, dm = hMap(ddt, mdb, 0), dl2 = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p2, nlc - 257);
    wbits(out, p2 + 5, ndc - 1);
    wbits(out, p2 + 10, nlcc - 4);
    p2 += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p2 + 3 * i2, lct[clim[i2]]);
    p2 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p2, llm[len]), p2 += lct[len];
        if (len > 15)
          wbits(out, p2, clct[i2] >>> 5 & 127), p2 += clct[i2] >>> 12;
      }
    }
  } else {
    lm = flm, ll2 = flt, dm = fdm, dl2 = fdt;
  }
  for (var i2 = 0; i2 < li2; ++i2) {
    if (syms[i2] > 255) {
      var len = syms[i2] >>> 18 & 31;
      wbits16(out, p2, lm[len + 257]), p2 += ll2[len + 257];
      if (len > 7)
        wbits(out, p2, syms[i2] >>> 23 & 31), p2 += fleb[len];
      var dst = syms[i2] & 31;
      wbits16(out, p2, dm[dst]), p2 += dl2[dst];
      if (dst > 3)
        wbits16(out, p2, syms[i2] >>> 5 & 8191), p2 += fdeb[dst];
    } else {
      wbits16(out, p2, lm[syms[i2]]), p2 += ll2[syms[i2]];
    }
  }
  wbits16(out, p2, lm[256]);
  return p2 + ll2[256];
};
var deo = /* @__PURE__ */ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et$1 = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, lst) {
  var s2 = dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.floor(s2 / 7e3)) + post);
  var w2 = o2.subarray(pre, o2.length - post);
  var pos = 0;
  if (!lvl || s2 < 8) {
    for (var i2 = 0; i2 <= s2; i2 += 65535) {
      var e2 = i2 + 65535;
      if (e2 < s2) {
        pos = wfblk(w2, pos, dat.subarray(i2, e2));
      } else {
        w2[i2] = lst;
        pos = wfblk(w2, pos, dat.subarray(i2, s2));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n2 = opt >>> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev2 = new u16(32768), head = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf2 = new u16(288), df2 = new u16(32);
    var lc_1 = 0, eb2 = 0, i2 = 0, li2 = 0, wi2 = 0, bs = 0;
    for (; i2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767;
      var pimod = head[hv];
      prev2[imod] = pimod;
      head[hv] = imod;
      if (wi2 <= i2) {
        var rem = s2 - i2;
        if ((lc_1 > 7e3 || li2 > 24576) && rem > 423) {
          pos = wblk(dat, w2, 0, syms, lf2, df2, eb2, li2, bs, i2 - bs, pos);
          li2 = lc_1 = eb2 = 0, bs = i2;
          for (var j2 = 0; j2 < 286; ++j2)
            lf2[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df2[j2] = 0;
        }
        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml2 = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
              var nl2 = 0;
              for (; nl2 < ml2 && dat[i2 + nl2] == dat[i2 + nl2 - dif]; ++nl2)
                ;
              if (nl2 > l2) {
                l2 = nl2, d2 = dif;
                if (nl2 > maxn)
                  break;
                var mmd = Math.min(dif, nl2 - 2);
                var md2 = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti2 = i2 - dif + j2 + 32768 & 32767;
                  var pti = prev2[ti2];
                  var cd2 = ti2 - pti + 32768 & 32767;
                  if (cd2 > md2)
                    md2 = cd2, pimod = ti2;
                }
              }
            }
            imod = pimod, pimod = prev2[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d2) {
          syms[li2++] = 268435456 | revfl[l2] << 18 | revfd[d2];
          var lin = revfl[l2] & 31, din = revfd[d2] & 31;
          eb2 += fleb[lin] + fdeb[din];
          ++lf2[257 + lin];
          ++df2[din];
          wi2 = i2 + l2;
          ++lc_1;
        } else {
          syms[li2++] = dat[i2];
          ++lf2[dat[i2]];
        }
      }
    }
    pos = wblk(dat, w2, lst, syms, lf2, df2, eb2, li2, bs, i2 - bs, pos);
    if (!lst)
      pos = wfblk(w2, pos, et$1);
  }
  return slc(o2, 0, pre + shft(pos) + post);
};
var adler = function() {
  var a2 = 1, b2 = 0;
  return {
    p: function(d2) {
      var n2 = a2, m2 = b2;
      var l2 = d2.length;
      for (var i2 = 0; i2 != l2; ) {
        var e2 = Math.min(i2 + 5552, l2);
        for (; i2 < e2; ++i2)
          n2 += d2[i2], m2 += n2;
        n2 %= 65521, m2 %= 65521;
      }
      a2 = n2, b2 = m2;
    },
    d: function() {
      return (a2 >>> 8 << 16 | (b2 & 255) << 8 | b2 >>> 8) + ((a2 & 255) << 23) * 2;
    }
  };
};
var dopt = function(dat, opt, pre, post, st2) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st2);
};
var wbytes = function(d2, b2, v2) {
  for (; v2; ++b2)
    d2[b2] = v2, v2 >>>= 8;
};
var zlh = function(c2, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c2[0] = 120, c2[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
};
var zlv = function(d2) {
  if ((d2[0] & 15) != 8 || d2[0] >>> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
    throw "invalid zlib data";
  if (d2[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function zlibSync(data, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var a2 = adler();
  a2.p(data);
  var d2 = dopt(data, opts, 2, 4);
  return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
}
function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
}
var n = function() {
  return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
}();
function i() {
  n.console && "function" == typeof n.console.log && n.console.log.apply(n.console, arguments);
}
var a = { log: i, warn: function(t3) {
  n.console && ("function" == typeof n.console.warn ? n.console.warn.apply(n.console, arguments) : i.call(null, arguments));
}, error: function(t3) {
  n.console && ("function" == typeof n.console.error ? n.console.error.apply(n.console, arguments) : i(t3));
} };
function o(t3, e2, r2) {
  var n2 = new XMLHttpRequest();
  n2.open("GET", t3), n2.responseType = "blob", n2.onload = function() {
    l(n2.response, e2, r2);
  }, n2.onerror = function() {
    a.error("could not download file");
  }, n2.send();
}
function s(t3) {
  var e2 = new XMLHttpRequest();
  e2.open("HEAD", t3, false);
  try {
    e2.send();
  } catch (t4) {
  }
  return e2.status >= 200 && e2.status <= 299;
}
function c(t3) {
  try {
    t3.dispatchEvent(new MouseEvent("click"));
  } catch (r2) {
    var e2 = document.createEvent("MouseEvents");
    e2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t3.dispatchEvent(e2);
  }
}
var u, h, l = n.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof$2(window)) || window !== n ? function() {
} : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t3, e2, r2) {
  var i2 = n.URL || n.webkitURL, a2 = document.createElement("a");
  e2 = e2 || t3.name || "download", a2.download = e2, a2.rel = "noopener", "string" == typeof t3 ? (a2.href = t3, a2.origin !== location.origin ? s(a2.href) ? o(t3, e2, r2) : c(a2, a2.target = "_blank") : c(a2)) : (a2.href = i2.createObjectURL(t3), setTimeout(function() {
    i2.revokeObjectURL(a2.href);
  }, 4e4), setTimeout(function() {
    c(a2);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e2, r2, n2) {
  if (r2 = r2 || e2.name || "download", "string" == typeof e2)
    if (s(e2))
      o(e2, r2, n2);
    else {
      var i2 = document.createElement("a");
      i2.href = e2, i2.target = "_blank", setTimeout(function() {
        c(i2);
      });
    }
  else
    navigator.msSaveOrOpenBlob(function(e3, r3) {
      return void 0 === r3 ? r3 = { autoBom: false } : "object" !== _typeof$2(r3) && (a.warn("Deprecated: Expected third argument to be a object"), r3 = { autoBom: !r3 }), r3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;
    }(e2, n2), r2);
} : function(e2, r2, i2, a2) {
  if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), "string" == typeof e2)
    return o(e2, r2, i2);
  var s2 = "application/octet-stream" === e2.type, c2 = /constructor/i.test(n.HTMLElement) || n.safari, u2 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((u2 || s2 && c2) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof$2(FileReader))) {
    var h2 = new FileReader();
    h2.onloadend = function() {
      var t3 = h2.result;
      t3 = u2 ? t3 : t3.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t3 : location = t3, a2 = null;
    }, h2.readAsDataURL(e2);
  } else {
    var l2 = n.URL || n.webkitURL, f2 = l2.createObjectURL(e2);
    a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
      l2.revokeObjectURL(f2);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function f(t3) {
  var e2;
  t3 = t3 || "", this.ok = false, "#" == t3.charAt(0) && (t3 = t3.substr(1, 6));
  t3 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t3 = (t3 = t3.replace(/ /g, "")).toLowerCase()] || t3;
  for (var r2 = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t4) {
    return [parseInt(t4[1]), parseInt(t4[2]), parseInt(t4[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t4) {
    return [parseInt(t4[1], 16), parseInt(t4[2], 16), parseInt(t4[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t4) {
    return [parseInt(t4[1] + t4[1], 16), parseInt(t4[2] + t4[2], 16), parseInt(t4[3] + t4[3], 16)];
  } }], n2 = 0; n2 < r2.length; n2++) {
    var i2 = r2[n2].re, a2 = r2[n2].process, o2 = i2.exec(t3);
    o2 && (e2 = a2(o2), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t4 = this.r.toString(16), e3 = this.g.toString(16), r3 = this.b.toString(16);
    return 1 == t4.length && (t4 = "0" + t4), 1 == e3.length && (e3 = "0" + e3), 1 == r3.length && (r3 = "0" + r3), "#" + t4 + e3 + r3;
  };
}
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function d(t3, e2) {
  var r2 = t3[0], n2 = t3[1], i2 = t3[2], a2 = t3[3];
  r2 = g(r2, n2, i2, a2, e2[0], 7, -680876936), a2 = g(a2, r2, n2, i2, e2[1], 12, -389564586), i2 = g(i2, a2, r2, n2, e2[2], 17, 606105819), n2 = g(n2, i2, a2, r2, e2[3], 22, -1044525330), r2 = g(r2, n2, i2, a2, e2[4], 7, -176418897), a2 = g(a2, r2, n2, i2, e2[5], 12, 1200080426), i2 = g(i2, a2, r2, n2, e2[6], 17, -1473231341), n2 = g(n2, i2, a2, r2, e2[7], 22, -45705983), r2 = g(r2, n2, i2, a2, e2[8], 7, 1770035416), a2 = g(a2, r2, n2, i2, e2[9], 12, -1958414417), i2 = g(i2, a2, r2, n2, e2[10], 17, -42063), n2 = g(n2, i2, a2, r2, e2[11], 22, -1990404162), r2 = g(r2, n2, i2, a2, e2[12], 7, 1804603682), a2 = g(a2, r2, n2, i2, e2[13], 12, -40341101), i2 = g(i2, a2, r2, n2, e2[14], 17, -1502002290), r2 = m(r2, n2 = g(n2, i2, a2, r2, e2[15], 22, 1236535329), i2, a2, e2[1], 5, -165796510), a2 = m(a2, r2, n2, i2, e2[6], 9, -1069501632), i2 = m(i2, a2, r2, n2, e2[11], 14, 643717713), n2 = m(n2, i2, a2, r2, e2[0], 20, -373897302), r2 = m(r2, n2, i2, a2, e2[5], 5, -701558691), a2 = m(a2, r2, n2, i2, e2[10], 9, 38016083), i2 = m(i2, a2, r2, n2, e2[15], 14, -660478335), n2 = m(n2, i2, a2, r2, e2[4], 20, -405537848), r2 = m(r2, n2, i2, a2, e2[9], 5, 568446438), a2 = m(a2, r2, n2, i2, e2[14], 9, -1019803690), i2 = m(i2, a2, r2, n2, e2[3], 14, -187363961), n2 = m(n2, i2, a2, r2, e2[8], 20, 1163531501), r2 = m(r2, n2, i2, a2, e2[13], 5, -1444681467), a2 = m(a2, r2, n2, i2, e2[2], 9, -51403784), i2 = m(i2, a2, r2, n2, e2[7], 14, 1735328473), r2 = v(r2, n2 = m(n2, i2, a2, r2, e2[12], 20, -1926607734), i2, a2, e2[5], 4, -378558), a2 = v(a2, r2, n2, i2, e2[8], 11, -2022574463), i2 = v(i2, a2, r2, n2, e2[11], 16, 1839030562), n2 = v(n2, i2, a2, r2, e2[14], 23, -35309556), r2 = v(r2, n2, i2, a2, e2[1], 4, -1530992060), a2 = v(a2, r2, n2, i2, e2[4], 11, 1272893353), i2 = v(i2, a2, r2, n2, e2[7], 16, -155497632), n2 = v(n2, i2, a2, r2, e2[10], 23, -1094730640), r2 = v(r2, n2, i2, a2, e2[13], 4, 681279174), a2 = v(a2, r2, n2, i2, e2[0], 11, -358537222), i2 = v(i2, a2, r2, n2, e2[3], 16, -722521979), n2 = v(n2, i2, a2, r2, e2[6], 23, 76029189), r2 = v(r2, n2, i2, a2, e2[9], 4, -640364487), a2 = v(a2, r2, n2, i2, e2[12], 11, -421815835), i2 = v(i2, a2, r2, n2, e2[15], 16, 530742520), r2 = b(r2, n2 = v(n2, i2, a2, r2, e2[2], 23, -995338651), i2, a2, e2[0], 6, -198630844), a2 = b(a2, r2, n2, i2, e2[7], 10, 1126891415), i2 = b(i2, a2, r2, n2, e2[14], 15, -1416354905), n2 = b(n2, i2, a2, r2, e2[5], 21, -57434055), r2 = b(r2, n2, i2, a2, e2[12], 6, 1700485571), a2 = b(a2, r2, n2, i2, e2[3], 10, -1894986606), i2 = b(i2, a2, r2, n2, e2[10], 15, -1051523), n2 = b(n2, i2, a2, r2, e2[1], 21, -2054922799), r2 = b(r2, n2, i2, a2, e2[8], 6, 1873313359), a2 = b(a2, r2, n2, i2, e2[15], 10, -30611744), i2 = b(i2, a2, r2, n2, e2[6], 15, -1560198380), n2 = b(n2, i2, a2, r2, e2[13], 21, 1309151649), r2 = b(r2, n2, i2, a2, e2[4], 6, -145523070), a2 = b(a2, r2, n2, i2, e2[11], 10, -1120210379), i2 = b(i2, a2, r2, n2, e2[2], 15, 718787259), n2 = b(n2, i2, a2, r2, e2[9], 21, -343485551), t3[0] = _(r2, t3[0]), t3[1] = _(n2, t3[1]), t3[2] = _(i2, t3[2]), t3[3] = _(a2, t3[3]);
}
function p(t3, e2, r2, n2, i2, a2) {
  return e2 = _(_(e2, t3), _(n2, a2)), _(e2 << i2 | e2 >>> 32 - i2, r2);
}
function g(t3, e2, r2, n2, i2, a2, o2) {
  return p(e2 & r2 | ~e2 & n2, t3, e2, i2, a2, o2);
}
function m(t3, e2, r2, n2, i2, a2, o2) {
  return p(e2 & n2 | r2 & ~n2, t3, e2, i2, a2, o2);
}
function v(t3, e2, r2, n2, i2, a2, o2) {
  return p(e2 ^ r2 ^ n2, t3, e2, i2, a2, o2);
}
function b(t3, e2, r2, n2, i2, a2, o2) {
  return p(r2 ^ (e2 | ~n2), t3, e2, i2, a2, o2);
}
function y(t3) {
  var e2, r2 = t3.length, n2 = [1732584193, -271733879, -1732584194, 271733878];
  for (e2 = 64; e2 <= t3.length; e2 += 64)
    d(n2, w(t3.substring(e2 - 64, e2)));
  t3 = t3.substring(e2 - 64);
  var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e2 = 0; e2 < t3.length; e2++)
    i2[e2 >> 2] |= t3.charCodeAt(e2) << (e2 % 4 << 3);
  if (i2[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55)
    for (d(n2, i2), e2 = 0; e2 < 16; e2++)
      i2[e2] = 0;
  return i2[14] = 8 * r2, d(n2, i2), n2;
}
function w(t3) {
  var e2, r2 = [];
  for (e2 = 0; e2 < 64; e2 += 4)
    r2[e2 >> 2] = t3.charCodeAt(e2) + (t3.charCodeAt(e2 + 1) << 8) + (t3.charCodeAt(e2 + 2) << 16) + (t3.charCodeAt(e2 + 3) << 24);
  return r2;
}
u = n.atob.bind(n), h = n.btoa.bind(n);
var N = "0123456789abcdef".split("");
function L(t3) {
  for (var e2 = "", r2 = 0; r2 < 4; r2++)
    e2 += N[t3 >> 8 * r2 + 4 & 15] + N[t3 >> 8 * r2 & 15];
  return e2;
}
function A(t3) {
  return String.fromCharCode((255 & t3) >> 0, (65280 & t3) >> 8, (16711680 & t3) >> 16, (4278190080 & t3) >> 24);
}
function x(t3) {
  return y(t3).map(A).join("");
}
var S = "5d41402abc4b2a76b9719d911017c592" != function(t3) {
  for (var e2 = 0; e2 < t3.length; e2++)
    t3[e2] = L(t3[e2]);
  return t3.join("");
}(y("hello"));
function _(t3, e2) {
  if (S) {
    var r2 = (65535 & t3) + (65535 & e2);
    return (t3 >> 16) + (e2 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
  }
  return t3 + e2 & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function P(t3, e2) {
  var r2, n2, i2, a2;
  if (t3 !== r2) {
    for (var o2 = (i2 = t3, a2 = 1 + (256 / t3.length >> 0), new Array(a2 + 1).join(i2)), s2 = [], c2 = 0; c2 < 256; c2++)
      s2[c2] = c2;
    var u2 = 0;
    for (c2 = 0; c2 < 256; c2++) {
      var h2 = s2[c2];
      u2 = (u2 + h2 + o2.charCodeAt(c2)) % 256, s2[c2] = s2[u2], s2[u2] = h2;
    }
    r2 = t3, n2 = s2;
  } else
    s2 = n2;
  var l2 = e2.length, f2 = 0, d2 = 0, p2 = "";
  for (c2 = 0; c2 < l2; c2++)
    d2 = (d2 + (h2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = h2, o2 = s2[(s2[f2] + s2[d2]) % 256], p2 += String.fromCharCode(e2.charCodeAt(c2) ^ o2);
  return p2;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t3, e2, r2, n2) {
  this.v = 1, this.r = 2;
  var i2 = 192;
  t3.forEach(function(t4) {
    if (void 0 !== k.perm)
      throw new Error("Invalid permission: " + t4);
    i2 += k[t4];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var a2 = (e2 + this.padding).substr(0, 32), o2 = (r2 + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = x(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n2)).substr(0, 5), this.U = P(this.encryptionKey, this.padding);
}
function F(t3) {
  if (/[^\u0000-\u00ff]/.test(t3))
    throw new Error("Invalid PDF Name Object: " + t3 + ", Only accept ASCII characters.");
  for (var e2 = "", r2 = t3.length, n2 = 0; n2 < r2; n2++) {
    var i2 = t3.charCodeAt(n2);
    if (i2 < 33 || 35 === i2 || 37 === i2 || 40 === i2 || 41 === i2 || 47 === i2 || 60 === i2 || 62 === i2 || 91 === i2 || 93 === i2 || 123 === i2 || 125 === i2 || i2 > 126)
      e2 += "#" + ("0" + i2.toString(16)).slice(-2);
    else
      e2 += t3[n2];
  }
  return e2;
}
function C(e2) {
  if ("object" !== _typeof$2(e2))
    throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var r2 = {};
  this.subscribe = function(t3, e3, n2) {
    if (n2 = n2 || false, "string" != typeof t3 || "function" != typeof e3 || "boolean" != typeof n2)
      throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    r2.hasOwnProperty(t3) || (r2[t3] = {});
    var i2 = Math.random().toString(35);
    return r2[t3][i2] = [e3, !!n2], i2;
  }, this.unsubscribe = function(t3) {
    for (var e3 in r2)
      if (r2[e3][t3])
        return delete r2[e3][t3], 0 === Object.keys(r2[e3]).length && delete r2[e3], true;
    return false;
  }, this.publish = function(t3) {
    if (r2.hasOwnProperty(t3)) {
      var i2 = Array.prototype.slice.call(arguments, 1), o2 = [];
      for (var s2 in r2[t3]) {
        var c2 = r2[t3][s2];
        try {
          c2[0].apply(e2, i2);
        } catch (t4) {
          n.console && a.error("jsPDF PubSub Error", t4.message, t4);
        }
        c2[1] && o2.push(s2);
      }
      o2.length && o2.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return r2;
  };
}
function j(t3) {
  if (!(this instanceof j))
    return new j(t3);
  var e2 = "opacity,stroke-opacity".split(",");
  for (var r2 in t3)
    t3.hasOwnProperty(r2) && e2.indexOf(r2) >= 0 && (this[r2] = t3[r2]);
  this.id = "", this.objectNumber = -1;
}
function O(t3, e2) {
  this.gState = t3, this.matrix = e2, this.id = "", this.objectNumber = -1;
}
function B(t3, e2, r2, n2, i2) {
  if (!(this instanceof B))
    return new B(t3, e2, r2, n2, i2);
  this.type = "axial" === t3 ? 2 : 3, this.coords = e2, this.colors = r2, O.call(this, n2, i2);
}
function M(t3, e2, r2, n2, i2) {
  if (!(this instanceof M))
    return new M(t3, e2, r2, n2, i2);
  this.boundingBox = t3, this.xStep = e2, this.yStep = r2, this.stream = "", this.cloneIndex = 0, O.call(this, n2, i2);
}
function E(e2) {
  var r2, i2 = "string" == typeof arguments[0] ? arguments[0] : "p", o2 = arguments[1], s2 = arguments[2], c2 = arguments[3], u2 = [], d2 = 1, p2 = 16, g2 = "S", m2 = null;
  "object" === _typeof$2(e2 = e2 || {}) && (i2 = e2.orientation, o2 = e2.unit || o2, s2 = e2.format || s2, c2 = e2.compress || e2.compressPdf || c2, null !== (m2 = e2.encryption || null) && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), d2 = "number" == typeof e2.userUnit ? Math.abs(e2.userUnit) : 1, void 0 !== e2.precision && (r2 = e2.precision), void 0 !== e2.floatPrecision && (p2 = e2.floatPrecision), g2 = e2.defaultPathOperation || "S"), u2 = e2.filters || (true === c2 ? ["FlateEncode"] : u2), o2 = o2 || "mm", i2 = ("" + (i2 || "P")).toLowerCase();
  var v2 = e2.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
  y2.__private__.PubSub = C;
  var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
    return w2;
  };
  y2.__private__.setPdfVersion = function(t3) {
    w2 = t3;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y2.__private__.getPageFormats = function() {
    return L2;
  };
  var A2 = y2.__private__.getPageFormat = function(t3) {
    return L2[t3];
  };
  s2 = s2 || "a4";
  var x2 = { COMPAT: "compat", ADVANCED: "advanced" }, S2 = x2.COMPAT;
  function _2() {
    this.saveGraphicsState(), lt2(new Vt2(_t5, 0, 0, -_t5, 0, Rr() * _t5).toString() + " cm"), this.setFontSize(this.getFontSize() / _t5), g2 = "n", S2 = x2.ADVANCED;
  }
  function P2() {
    this.restoreGraphicsState(), g2 = "S", S2 = x2.COMPAT;
  }
  var k2 = y2.__private__.combineFontStyleAndFontWeight = function(t3, e3) {
    if ("bold" == t3 && "normal" == e3 || "bold" == t3 && 400 == e3 || "normal" == t3 && "italic" == e3 || "bold" == t3 && "italic" == e3)
      throw new Error("Invalid Combination of fontweight and fontstyle");
    return e3 && (t3 = 400 == e3 || "normal" === e3 ? "italic" === t3 ? "italic" : "normal" : 700 != e3 && "bold" !== e3 || "normal" !== t3 ? (700 == e3 ? "bold" : e3) + "" + t3 : "bold"), t3;
  };
  y2.advancedAPI = function(t3) {
    var e3 = S2 === x2.COMPAT;
    return e3 && _2.call(this), "function" != typeof t3 || (t3(this), e3 && P2.call(this)), this;
  }, y2.compatAPI = function(t3) {
    var e3 = S2 === x2.ADVANCED;
    return e3 && P2.call(this), "function" != typeof t3 || (t3(this), e3 && _2.call(this)), this;
  }, y2.isAdvancedAPI = function() {
    return S2 === x2.ADVANCED;
  };
  var O2, q2 = function(t3) {
    if (S2 !== x2.ADVANCED)
      throw new Error(t3 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t3, e3) {
    var n2 = r2 || e3;
    if (isNaN(t3) || isNaN(n2))
      throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t3.toFixed(n2).replace(/0+$/, "");
  };
  O2 = y2.hpf = y2.__private__.hpf = "number" == typeof p2 ? function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, p2);
  } : "smart" === p2 ? function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, t3 > -1 && t3 < 1 ? 16 : 5);
  } : function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, 16);
  };
  var R2 = y2.f2 = y2.__private__.f2 = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t3, 2);
  }, T2 = y2.__private__.f3 = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t3, 3);
  }, U2 = y2.scale = y2.__private__.scale = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.scale");
    return S2 === x2.COMPAT ? t3 * _t5 : S2 === x2.ADVANCED ? t3 : void 0;
  }, z2 = function(t3) {
    return S2 === x2.COMPAT ? Rr() - t3 : S2 === x2.ADVANCED ? t3 : void 0;
  }, H4 = function(t3) {
    return U2(z2(t3));
  };
  y2.__private__.setPrecision = y2.setPrecision = function(t3) {
    "number" == typeof parseInt(t3, 10) && (r2 = parseInt(t3, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
    return V2;
  }, Y2 = y2.__private__.setFileId = function(t3) {
    return V2 = void 0 !== t3 && /^[a-fA-F0-9]{32}$/.test(t3) ? t3.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), null !== m2 && (Ye2 = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
  };
  y2.setFileId = function(t3) {
    return Y2(t3), this;
  }, y2.getFileId = function() {
    return G2();
  };
  var J2 = y2.__private__.convertDateToPDFDate = function(t3) {
    var e3 = t3.getTimezoneOffset(), r3 = e3 < 0 ? "+" : "-", n2 = Math.floor(Math.abs(e3 / 60)), i3 = Math.abs(e3 % 60), a2 = [r3, Q2(n2), "'", Q2(i3), "'"].join("");
    return ["D:", t3.getFullYear(), Q2(t3.getMonth() + 1), Q2(t3.getDate()), Q2(t3.getHours()), Q2(t3.getMinutes()), Q2(t3.getSeconds()), a2].join("");
  }, X2 = y2.__private__.convertPDFDateToDate = function(t3) {
    var e3 = parseInt(t3.substr(2, 4), 10), r3 = parseInt(t3.substr(6, 2), 10) - 1, n2 = parseInt(t3.substr(8, 2), 10), i3 = parseInt(t3.substr(10, 2), 10), a2 = parseInt(t3.substr(12, 2), 10), o3 = parseInt(t3.substr(14, 2), 10);
    return new Date(e3, r3, n2, i3, a2, o3, 0);
  }, K2 = y2.__private__.setCreationDate = function(t3) {
    var e3;
    if (void 0 === t3 && (t3 = /* @__PURE__ */ new Date()), t3 instanceof Date)
      e3 = J2(t3);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t3))
        throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e3 = t3;
    }
    return W2 = e3;
  }, Z2 = y2.__private__.getCreationDate = function(t3) {
    var e3 = W2;
    return "jsDate" === t3 && (e3 = X2(W2)), e3;
  };
  y2.setCreationDate = function(t3) {
    return K2(t3), this;
  }, y2.getCreationDate = function(t3) {
    return Z2(t3);
  };
  var $2, Q2 = y2.__private__.padd2 = function(t3) {
    return ("0" + parseInt(t3)).slice(-2);
  }, tt2 = y2.__private__.padd2Hex = function(t3) {
    return ("00" + (t3 = t3.toString())).substr(t3.length);
  }, et2 = 0, rt2 = [], nt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ct2 = nt2, ut2 = function() {
    et2 = 0, it2 = 0, nt2 = [], rt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2();
  };
  y2.__private__.setCustomOutputDestination = function(t3) {
    st2 = true, ct2 = t3;
  };
  var ht2 = function(t3) {
    st2 || (ct2 = t3);
  };
  y2.__private__.resetCustomOutputDestination = function() {
    st2 = false, ct2 = nt2;
  };
  var lt2 = y2.__private__.out = function(t3) {
    return t3 = t3.toString(), it2 += t3.length + 1, ct2.push(t3), ct2;
  }, ft2 = y2.__private__.write = function(t3) {
    return lt2(1 === arguments.length ? t3.toString() : Array.prototype.join.call(arguments, " "));
  }, dt2 = y2.__private__.getArrayBuffer = function(t3) {
    for (var e3 = t3.length, r3 = new ArrayBuffer(e3), n2 = new Uint8Array(r3); e3--; )
      n2[e3] = t3.charCodeAt(e3);
    return r3;
  }, pt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y2.__private__.getStandardFonts = function() {
    return pt2;
  };
  var gt2 = e2.fontSize || 16;
  y2.__private__.setFontSize = y2.setFontSize = function(t3) {
    return gt2 = S2 === x2.ADVANCED ? t3 / _t5 : t3, this;
  };
  var mt2, vt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
    return S2 === x2.COMPAT ? gt2 : gt2 * _t5;
  }, bt2 = e2.R2L || false;
  y2.__private__.setR2L = y2.setR2L = function(t3) {
    return bt2 = t3, this;
  }, y2.__private__.getR2L = y2.getR2L = function() {
    return bt2;
  };
  var yt2, wt2 = y2.__private__.setZoomMode = function(t3) {
    var e3 = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t3))
      mt2 = t3;
    else if (isNaN(t3)) {
      if (-1 === e3.indexOf(t3))
        throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t3 + '" is not recognized.');
      mt2 = t3;
    } else
      mt2 = parseInt(t3, 10);
  };
  y2.__private__.getZoomMode = function() {
    return mt2;
  };
  var Nt2, Lt2 = y2.__private__.setPageMode = function(t3) {
    if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t3))
      throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t3 + '" is not recognized.');
    yt2 = t3;
  };
  y2.__private__.getPageMode = function() {
    return yt2;
  };
  var At2 = y2.__private__.setLayoutMode = function(t3) {
    if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t3))
      throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t3 + '" is not recognized.');
    Nt2 = t3;
  };
  y2.__private__.getLayoutMode = function() {
    return Nt2;
  }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t3, e3, r3) {
    return wt2(t3), At2(e3), Lt2(r3), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y2.__private__.getDocumentProperty = function(t3) {
    if (-1 === Object.keys(xt2).indexOf(t3))
      throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t3];
  }, y2.__private__.getDocumentProperties = function() {
    return xt2;
  }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t3) {
    for (var e3 in xt2)
      xt2.hasOwnProperty(e3) && t3[e3] && (xt2[e3] = t3[e3]);
    return this;
  }, y2.__private__.setDocumentProperty = function(t3, e3) {
    if (-1 === Object.keys(xt2).indexOf(t3))
      throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t3] = e3;
  };
  var St2, _t5, Pt2, kt2, It2, Ft3 = {}, Ct2 = {}, jt2 = [], Ot2 = {}, Bt2 = {}, Mt2 = {}, Et3 = {}, qt2 = null, Dt2 = 0, Rt2 = [], Tt2 = new C(y2), Ut2 = e2.hotfixes || [], zt3 = {}, Ht2 = {}, Wt2 = [], Vt2 = function t3(e3, r3, n2, i3, a2, o3) {
    if (!(this instanceof t3))
      return new t3(e3, r3, n2, i3, a2, o3);
    isNaN(e3) && (e3 = 1), isNaN(r3) && (r3 = 0), isNaN(n2) && (n2 = 0), isNaN(i3) && (i3 = 1), isNaN(a2) && (a2 = 0), isNaN(o3) && (o3 = 0), this._matrix = [e3, r3, n2, i3, a2, o3];
  };
  Object.defineProperty(Vt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Vt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Vt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Vt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Vt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Vt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Vt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Vt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Vt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Vt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Vt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Vt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Vt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Vt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Vt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Vt2.prototype, "isIdentity", { get: function() {
    return 1 === this.sx && (0 === this.shy && (0 === this.shx && (1 === this.sy && (0 === this.tx && 0 === this.ty))));
  } }), Vt2.prototype.join = function(t3) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(O2).join(t3);
  }, Vt2.prototype.multiply = function(t3) {
    var e3 = t3.sx * this.sx + t3.shy * this.shx, r3 = t3.sx * this.shy + t3.shy * this.sy, n2 = t3.shx * this.sx + t3.sy * this.shx, i3 = t3.shx * this.shy + t3.sy * this.sy, a2 = t3.tx * this.sx + t3.ty * this.shx + this.tx, o3 = t3.tx * this.shy + t3.ty * this.sy + this.ty;
    return new Vt2(e3, r3, n2, i3, a2, o3);
  }, Vt2.prototype.decompose = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = Math.sqrt(t3 * t3 + e3 * e3), s3 = (t3 /= o3) * r3 + (e3 /= o3) * n2;
    r3 -= t3 * s3, n2 -= e3 * s3;
    var c3 = Math.sqrt(r3 * r3 + n2 * n2);
    return s3 /= c3, t3 * (n2 /= c3) < e3 * (r3 /= c3) && (t3 = -t3, e3 = -e3, s3 = -s3, o3 = -o3), { scale: new Vt2(o3, 0, 0, c3, 0, 0), translate: new Vt2(1, 0, 0, 1, i3, a2), rotate: new Vt2(t3, e3, -e3, t3, 0, 0), skew: new Vt2(1, 0, s3, 1, 0, 0) };
  }, Vt2.prototype.toString = function(t3) {
    return this.join(" ");
  }, Vt2.prototype.inversed = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty, o3 = 1 / (t3 * n2 - e3 * r3), s3 = n2 * o3, c3 = -e3 * o3, u3 = -r3 * o3, h2 = t3 * o3;
    return new Vt2(s3, c3, u3, h2, -s3 * i3 - u3 * a2, -c3 * i3 - h2 * a2);
  }, Vt2.prototype.applyToPoint = function(t3) {
    var e3 = t3.x * this.sx + t3.y * this.shx + this.tx, r3 = t3.x * this.shy + t3.y * this.sy + this.ty;
    return new Cr(e3, r3);
  }, Vt2.prototype.applyToRectangle = function(t3) {
    var e3 = this.applyToPoint(t3), r3 = this.applyToPoint(new Cr(t3.x + t3.w, t3.y + t3.h));
    return new jr(e3.x, e3.y, r3.x - e3.x, r3.y - e3.y);
  }, Vt2.prototype.clone = function() {
    var t3 = this.sx, e3 = this.shy, r3 = this.shx, n2 = this.sy, i3 = this.tx, a2 = this.ty;
    return new Vt2(t3, e3, r3, n2, i3, a2);
  }, y2.Matrix = Vt2;
  var Gt2 = y2.matrixMult = function(t3, e3) {
    return e3.multiply(t3);
  }, Yt2 = new Vt2(1, 0, 0, 1, 0, 0);
  y2.unitMatrix = y2.identityMatrix = Yt2;
  var Jt2 = function(t3, e3) {
    if (!Bt2[t3]) {
      var r3 = (e3 instanceof B ? "Sh" : "P") + (Object.keys(Ot2).length + 1).toString(10);
      e3.id = r3, Bt2[t3] = r3, Ot2[r3] = e3, Tt2.publish("addPattern", e3);
    }
  };
  y2.ShadingPattern = B, y2.TilingPattern = M, y2.addShadingPattern = function(t3, e3) {
    return q2("addShadingPattern()"), Jt2(t3, e3), this;
  }, y2.beginTilingPattern = function(t3) {
    q2("beginTilingPattern()"), Br(t3.boundingBox[0], t3.boundingBox[1], t3.boundingBox[2] - t3.boundingBox[0], t3.boundingBox[3] - t3.boundingBox[1], t3.matrix);
  }, y2.endTilingPattern = function(t3, e3) {
    q2("endTilingPattern()"), e3.stream = ot2[$2].join("\n"), Jt2(t3, e3), Tt2.publish("endTilingPattern", e3), Wt2.pop().restore();
  };
  var Xt3 = y2.__private__.newObject = function() {
    var t3 = Kt2();
    return Zt2(t3, true), t3;
  }, Kt2 = y2.__private__.newObjectDeferred = function() {
    return et2++, rt2[et2] = function() {
      return it2;
    }, et2;
  }, Zt2 = function(t3, e3) {
    return e3 = "boolean" == typeof e3 && e3, rt2[t3] = it2, e3 && lt2(t3 + " 0 obj"), t3;
  }, $t2 = y2.__private__.newAdditionalObject = function() {
    var t3 = { objId: Kt2(), content: "" };
    return at2.push(t3), t3;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t3) {
    var e3 = t3.split(" ");
    if (2 !== e3.length || "g" !== e3[1] && "G" !== e3[1]) {
      if (5 === e3.length && ("k" === e3[4] || "K" === e3[4])) {
        e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"];
      }
    } else {
      var r3 = parseFloat(e3[0]);
      e3 = [r3, r3, r3, "r"];
    }
    for (var n2 = "#", i3 = 0; i3 < 3; i3++)
      n2 += ("0" + Math.floor(255 * parseFloat(e3[i3])).toString(16)).slice(-2);
    return n2;
  }, re2 = y2.__private__.encodeColorString = function(e3) {
    var r3;
    "string" == typeof e3 && (e3 = { ch1: e3 });
    var n2 = e3.ch1, i3 = e3.ch2, a2 = e3.ch3, o3 = e3.ch4, s3 = "draw" === e3.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if ("string" == typeof n2 && "#" !== n2.charAt(0)) {
      var c3 = new f(n2);
      if (c3.ok)
        n2 = c3.toHex();
      else if (!/^\d*\.?\d*$/.test(n2))
        throw new Error('Invalid color "' + n2 + '" passed to jsPDF.encodeColorString.');
    }
    if ("string" == typeof n2 && /^#[0-9A-Fa-f]{3}$/.test(n2) && (n2 = "#" + n2[1] + n2[1] + n2[2] + n2[2] + n2[3] + n2[3]), "string" == typeof n2 && /^#[0-9A-Fa-f]{6}$/.test(n2)) {
      var u3 = parseInt(n2.substr(1), 16);
      n2 = u3 >> 16 & 255, i3 = u3 >> 8 & 255, a2 = 255 & u3;
    }
    if (void 0 === i3 || void 0 === o3 && n2 === i3 && i3 === a2)
      if ("string" == typeof n2)
        r3 = n2 + " " + s3[0];
      else
        switch (e3.precision) {
          case 2:
            r3 = R2(n2 / 255) + " " + s3[0];
            break;
          case 3:
          default:
            r3 = T2(n2 / 255) + " " + s3[0];
        }
    else if (void 0 === o3 || "object" === _typeof$2(o3)) {
      if (o3 && !isNaN(o3.a) && 0 === o3.a)
        return r3 = ["1.", "1.", "1.", s3[1]].join(" ");
      if ("string" == typeof n2)
        r3 = [n2, i3, a2, s3[1]].join(" ");
      else
        switch (e3.precision) {
          case 2:
            r3 = [R2(n2 / 255), R2(i3 / 255), R2(a2 / 255), s3[1]].join(" ");
            break;
          default:
          case 3:
            r3 = [T2(n2 / 255), T2(i3 / 255), T2(a2 / 255), s3[1]].join(" ");
        }
    } else if ("string" == typeof n2)
      r3 = [n2, i3, a2, o3, s3[2]].join(" ");
    else
      switch (e3.precision) {
        case 2:
          r3 = [R2(n2), R2(i3), R2(a2), R2(o3), s3[2]].join(" ");
          break;
        case 3:
        default:
          r3 = [T2(n2), T2(i3), T2(a2), T2(o3), s3[2]].join(" ");
      }
    return r3;
  }, ne2 = y2.__private__.getFilters = function() {
    return u2;
  }, ie2 = y2.__private__.putStream = function(t3) {
    var e3 = (t3 = t3 || {}).data || "", r3 = t3.filters || ne2(), n2 = t3.alreadyAppliedFilters || [], i3 = t3.addLength1 || false, a2 = e3.length, o3 = t3.objectId, s3 = function(t4) {
      return t4;
    };
    if (null !== m2 && void 0 === o3)
      throw new Error("ObjectId must be passed to putStream for file encryption");
    null !== m2 && (s3 = Ye2.encryptor(o3, 0));
    var c3 = {};
    true === r3 && (r3 = ["FlateEncode"]);
    var u3 = t3.additionalKeyValues || [], h2 = (c3 = void 0 !== E.API.processDataByFilters ? E.API.processDataByFilters(e3, r3) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(n2) ? n2.join(" ") : n2.toString());
    if (0 !== c3.data.length && (u3.push({ key: "Length", value: c3.data.length }), true === i3 && u3.push({ key: "Length1", value: a2 })), 0 != h2.length)
      if (h2.split("/").length - 1 == 1)
        u3.push({ key: "Filter", value: h2 });
      else {
        u3.push({ key: "Filter", value: "[" + h2 + "]" });
        for (var l2 = 0; l2 < u3.length; l2 += 1)
          if ("DecodeParms" === u3[l2].key) {
            for (var f2 = [], d3 = 0; d3 < c3.reverseChain.split("/").length - 1; d3 += 1)
              f2.push("null");
            f2.push(u3[l2].value), u3[l2].value = "[" + f2.join(" ") + "]";
          }
      }
    lt2("<<");
    for (var p3 = 0; p3 < u3.length; p3++)
      lt2("/" + u3[p3].key + " " + u3[p3].value);
    lt2(">>"), 0 !== c3.data.length && (lt2("stream"), lt2(s3(c3.data)), lt2("endstream"));
  }, ae2 = y2.__private__.putPage = function(t3) {
    var e3 = t3.number, r3 = t3.data, n2 = t3.objId, i3 = t3.contentsObjId;
    Zt2(n2, true), lt2("<</Type /Page"), lt2("/Parent " + t3.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t3.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(O2(t3.mediaBox.bottomLeftX)) + " " + parseFloat(O2(t3.mediaBox.bottomLeftY)) + " " + O2(t3.mediaBox.topRightX) + " " + O2(t3.mediaBox.topRightY) + "]"), null !== t3.cropBox && lt2("/CropBox [" + O2(t3.cropBox.bottomLeftX) + " " + O2(t3.cropBox.bottomLeftY) + " " + O2(t3.cropBox.topRightX) + " " + O2(t3.cropBox.topRightY) + "]"), null !== t3.bleedBox && lt2("/BleedBox [" + O2(t3.bleedBox.bottomLeftX) + " " + O2(t3.bleedBox.bottomLeftY) + " " + O2(t3.bleedBox.topRightX) + " " + O2(t3.bleedBox.topRightY) + "]"), null !== t3.trimBox && lt2("/TrimBox [" + O2(t3.trimBox.bottomLeftX) + " " + O2(t3.trimBox.bottomLeftY) + " " + O2(t3.trimBox.topRightX) + " " + O2(t3.trimBox.topRightY) + "]"), null !== t3.artBox && lt2("/ArtBox [" + O2(t3.artBox.bottomLeftX) + " " + O2(t3.artBox.bottomLeftY) + " " + O2(t3.artBox.topRightX) + " " + O2(t3.artBox.topRightY) + "]"), "number" == typeof t3.userUnit && 1 !== t3.userUnit && lt2("/UserUnit " + t3.userUnit), Tt2.publish("putPage", { objId: n2, pageContext: Rt2[e3], pageNumber: e3, page: r3 }), lt2("/Contents " + i3 + " 0 R"), lt2(">>"), lt2("endobj");
    var a2 = r3.join("\n");
    return S2 === x2.ADVANCED && (a2 += "\nQ"), Zt2(i3, true), ie2({ data: a2, filters: ne2(), objectId: i3 }), lt2("endobj"), n2;
  }, oe2 = y2.__private__.putPages = function() {
    var t3, e3, r3 = [];
    for (t3 = 1; t3 <= Dt2; t3++)
      Rt2[t3].objId = Kt2(), Rt2[t3].contentsObjId = Kt2();
    for (t3 = 1; t3 <= Dt2; t3++)
      r3.push(ae2({ number: t3, data: ot2[t3], objId: Rt2[t3].objId, contentsObjId: Rt2[t3].contentsObjId, mediaBox: Rt2[t3].mediaBox, cropBox: Rt2[t3].cropBox, bleedBox: Rt2[t3].bleedBox, trimBox: Rt2[t3].trimBox, artBox: Rt2[t3].artBox, userUnit: Rt2[t3].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var n2 = "/Kids [";
    for (e3 = 0; e3 < Dt2; e3++)
      n2 += r3[e3] + " 0 R ";
    lt2(n2 + "]"), lt2("/Count " + Dt2), lt2(">>"), lt2("endobj"), Tt2.publish("postPutPages");
  }, se2 = function(t3) {
    Tt2.publish("putFont", { font: t3, out: lt2, newObject: Xt3, putStream: ie2 }), true !== t3.isAlreadyPutted && (t3.objectNumber = Xt3(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + F(t3.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t3.encoding && lt2("/Encoding /" + t3.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ce2 = function() {
    for (var t3 in Ft3)
      Ft3.hasOwnProperty(t3) && (false === v2 || true === v2 && b2.hasOwnProperty(t3)) && se2(Ft3[t3]);
  }, ue2 = function(t3) {
    t3.objectNumber = Xt3();
    var e3 = [];
    e3.push({ key: "Type", value: "/XObject" }), e3.push({ key: "Subtype", value: "/Form" }), e3.push({ key: "BBox", value: "[" + [O2(t3.x), O2(t3.y), O2(t3.x + t3.width), O2(t3.y + t3.height)].join(" ") + "]" }), e3.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" });
    var r3 = t3.pages[1].join("\n");
    ie2({ data: r3, additionalKeyValues: e3, objectId: t3.objectNumber }), lt2("endobj");
  }, he2 = function() {
    for (var t3 in zt3)
      zt3.hasOwnProperty(t3) && ue2(zt3[t3]);
  }, le2 = function(t3, e3) {
    var r3, n2 = [], i3 = 1 / (e3 - 1);
    for (r3 = 0; r3 < 1; r3 += i3)
      n2.push(r3);
    if (n2.push(1), 0 != t3[0].offset) {
      var a2 = { offset: 0, color: t3[0].color };
      t3.unshift(a2);
    }
    if (1 != t3[t3.length - 1].offset) {
      var o3 = { offset: 1, color: t3[t3.length - 1].color };
      t3.push(o3);
    }
    for (var s3 = "", c3 = 0, u3 = 0; u3 < n2.length; u3++) {
      for (r3 = n2[u3]; r3 > t3[c3 + 1].offset; )
        c3++;
      var h2 = t3[c3].offset, l2 = (r3 - h2) / (t3[c3 + 1].offset - h2), f2 = t3[c3].color, d3 = t3[c3 + 1].color;
      s3 += tt2(Math.round((1 - l2) * f2[0] + l2 * d3[0]).toString(16)) + tt2(Math.round((1 - l2) * f2[1] + l2 * d3[1]).toString(16)) + tt2(Math.round((1 - l2) * f2[2] + l2 * d3[2]).toString(16));
    }
    return s3.trim();
  }, fe2 = function(t3, e3) {
    e3 || (e3 = 21);
    var r3 = Xt3(), n2 = le2(t3.colors, e3), i3 = [];
    i3.push({ key: "FunctionType", value: "0" }), i3.push({ key: "Domain", value: "[0.0 1.0]" }), i3.push({ key: "Size", value: "[" + e3 + "]" }), i3.push({ key: "BitsPerSample", value: "8" }), i3.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i3.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: n2, additionalKeyValues: i3, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: r3 }), lt2("endobj"), t3.objectNumber = Xt3(), lt2("<< /ShadingType " + t3.type), lt2("/ColorSpace /DeviceRGB");
    var a2 = "/Coords [" + O2(parseFloat(t3.coords[0])) + " " + O2(parseFloat(t3.coords[1])) + " ";
    2 === t3.type ? a2 += O2(parseFloat(t3.coords[2])) + " " + O2(parseFloat(t3.coords[3])) : a2 += O2(parseFloat(t3.coords[2])) + " " + O2(parseFloat(t3.coords[3])) + " " + O2(parseFloat(t3.coords[4])) + " " + O2(parseFloat(t3.coords[5])), lt2(a2 += "]"), t3.matrix && lt2("/Matrix [" + t3.matrix.toString() + "]"), lt2("/Function " + r3 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, de2 = function(t3, e3) {
    var r3 = Kt2(), n2 = Xt3();
    e3.push({ resourcesOid: r3, objectOid: n2 }), t3.objectNumber = n2;
    var i3 = [];
    i3.push({ key: "Type", value: "/Pattern" }), i3.push({ key: "PatternType", value: "1" }), i3.push({ key: "PaintType", value: "1" }), i3.push({ key: "TilingType", value: "1" }), i3.push({ key: "BBox", value: "[" + t3.boundingBox.map(O2).join(" ") + "]" }), i3.push({ key: "XStep", value: O2(t3.xStep) }), i3.push({ key: "YStep", value: O2(t3.yStep) }), i3.push({ key: "Resources", value: r3 + " 0 R" }), t3.matrix && i3.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" }), ie2({ data: t3.stream, additionalKeyValues: i3, objectId: t3.objectNumber }), lt2("endobj");
  }, pe2 = function(t3) {
    var e3;
    for (e3 in Ot2)
      Ot2.hasOwnProperty(e3) && (Ot2[e3] instanceof B ? fe2(Ot2[e3]) : Ot2[e3] instanceof M && de2(Ot2[e3], t3));
  }, ge2 = function(t3) {
    for (var e3 in t3.objectNumber = Xt3(), lt2("<<"), t3)
      switch (e3) {
        case "opacity":
          lt2("/ca " + R2(t3[e3]));
          break;
        case "stroke-opacity":
          lt2("/CA " + R2(t3[e3]));
      }
    lt2(">>"), lt2("endobj");
  }, me2 = function() {
    var t3;
    for (t3 in Mt2)
      Mt2.hasOwnProperty(t3) && ge2(Mt2[t3]);
  }, ve2 = function() {
    for (var t3 in lt2("/XObject <<"), zt3)
      zt3.hasOwnProperty(t3) && zt3[t3].objectNumber >= 0 && lt2("/" + t3 + " " + zt3[t3].objectNumber + " 0 R");
    Tt2.publish("putXobjectDict"), lt2(">>");
  }, be2 = function() {
    Ye2.oid = Xt3(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + Ye2.v), lt2("/R " + Ye2.r), lt2("/U <" + Ye2.toHexString(Ye2.U) + ">"), lt2("/O <" + Ye2.toHexString(Ye2.O) + ">"), lt2("/P " + Ye2.P), lt2(">>"), lt2("endobj");
  }, ye2 = function() {
    for (var t3 in lt2("/Font <<"), Ft3)
      Ft3.hasOwnProperty(t3) && (false === v2 || true === v2 && b2.hasOwnProperty(t3)) && lt2("/" + t3 + " " + Ft3[t3].objectNumber + " 0 R");
    lt2(">>");
  }, we2 = function() {
    if (Object.keys(Ot2).length > 0) {
      for (var t3 in lt2("/Shading <<"), Ot2)
        Ot2.hasOwnProperty(t3) && Ot2[t3] instanceof B && Ot2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Ot2[t3].objectNumber + " 0 R");
      Tt2.publish("putShadingPatternDict"), lt2(">>");
    }
  }, Ne2 = function(t3) {
    if (Object.keys(Ot2).length > 0) {
      for (var e3 in lt2("/Pattern <<"), Ot2)
        Ot2.hasOwnProperty(e3) && Ot2[e3] instanceof y2.TilingPattern && Ot2[e3].objectNumber >= 0 && Ot2[e3].objectNumber < t3 && lt2("/" + e3 + " " + Ot2[e3].objectNumber + " 0 R");
      Tt2.publish("putTilingPatternDict"), lt2(">>");
    }
  }, Le2 = function() {
    if (Object.keys(Mt2).length > 0) {
      var t3;
      for (t3 in lt2("/ExtGState <<"), Mt2)
        Mt2.hasOwnProperty(t3) && Mt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Mt2[t3].objectNumber + " 0 R");
      Tt2.publish("putGStateDict"), lt2(">>");
    }
  }, Ae2 = function(t3) {
    Zt2(t3.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), ye2(), we2(), Ne2(t3.objectOid), Le2(), ve2(), lt2(">>"), lt2("endobj");
  }, xe2 = function() {
    var t3 = [];
    ce2(), me2(), he2(), pe2(t3), Tt2.publish("putResources"), t3.forEach(Ae2), Ae2({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Tt2.publish("postPutResources");
  }, Se2 = function() {
    Tt2.publish("putAdditionalObjects");
    for (var t3 = 0; t3 < at2.length; t3++) {
      var e3 = at2[t3];
      Zt2(e3.objId, true), lt2(e3.content), lt2("endobj");
    }
    Tt2.publish("postPutAdditionalObjects");
  }, _e2 = function(t3) {
    Ct2[t3.fontName] = Ct2[t3.fontName] || {}, Ct2[t3.fontName][t3.fontStyle] = t3.id;
  }, Pe2 = function(t3, e3, r3, n2, i3) {
    var a2 = { id: "F" + (Object.keys(Ft3).length + 1).toString(10), postScriptName: t3, fontName: e3, fontStyle: r3, encoding: n2, isStandardFont: i3 || false, metadata: {} };
    return Tt2.publish("addFont", { font: a2, instance: this }), Ft3[a2.id] = a2, _e2(a2), a2.id;
  }, ke2 = function(t3) {
    for (var e3 = 0, r3 = pt2.length; e3 < r3; e3++) {
      var n2 = Pe2.call(this, t3[e3][0], t3[e3][1], t3[e3][2], pt2[e3][3], true);
      false === v2 && (b2[n2] = true);
      var i3 = t3[e3][0].split("-");
      _e2({ id: n2, fontName: i3[0], fontStyle: i3[1] || "" });
    }
    Tt2.publish("addFonts", { fonts: Ft3, dictionary: Ct2 });
  }, Ie2 = function(t3) {
    return t3.foo = function() {
      try {
        return t3.apply(this, arguments);
      } catch (t4) {
        var e3 = t4.stack || "";
        ~e3.indexOf(" at ") && (e3 = e3.split(" at ")[1]);
        var r3 = "Error in function " + e3.split("\n")[0].split("<")[0] + ": " + t4.message;
        if (!n.console)
          throw new Error(r3);
        n.console.error(r3, t4), n.alert && alert(r3);
      }
    }, t3.foo.bar = t3, t3.foo;
  }, Fe2 = function(t3, e3) {
    var r3, n2, i3, a2, o3, s3, c3, u3, h2;
    if (i3 = (e3 = e3 || {}).sourceEncoding || "Unicode", o3 = e3.outputEncoding, (e3.autoencode || o3) && Ft3[St2].metadata && Ft3[St2].metadata[i3] && Ft3[St2].metadata[i3].encoding && (a2 = Ft3[St2].metadata[i3].encoding, !o3 && Ft3[St2].encoding && (o3 = Ft3[St2].encoding), !o3 && a2.codePages && (o3 = a2.codePages[0]), "string" == typeof o3 && (o3 = a2[o3]), o3)) {
      for (c3 = false, s3 = [], r3 = 0, n2 = t3.length; r3 < n2; r3++)
        (u3 = o3[t3.charCodeAt(r3)]) ? s3.push(String.fromCharCode(u3)) : s3.push(t3[r3]), s3[r3].charCodeAt(0) >> 8 && (c3 = true);
      t3 = s3.join("");
    }
    for (r3 = t3.length; void 0 === c3 && 0 !== r3; )
      t3.charCodeAt(r3 - 1) >> 8 && (c3 = true), r3--;
    if (!c3)
      return t3;
    for (s3 = e3.noBOM ? [] : [254, 255], r3 = 0, n2 = t3.length; r3 < n2; r3++) {
      if ((h2 = (u3 = t3.charCodeAt(r3)) >> 8) >> 8)
        throw new Error("Character at position " + r3 + " of string '" + t3 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      s3.push(h2), s3.push(u3 - (h2 << 8));
    }
    return String.fromCharCode.apply(void 0, s3);
  }, Ce2 = y2.__private__.pdfEscape = y2.pdfEscape = function(t3, e3) {
    return Fe2(t3, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, je2 = y2.__private__.beginPage = function(t3) {
    ot2[++Dt2] = [], Rt2[Dt2] = { objId: 0, contentsObjId: 0, userUnit: Number(d2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t3[0]), topRightY: Number(t3[1]) } }, Me2(Dt2), ht2(ot2[$2]);
  }, Oe2 = function(t3, e3) {
    var r3, n2, o3;
    switch (i2 = e3 || i2, "string" == typeof t3 && (r3 = A2(t3.toLowerCase()), Array.isArray(r3) && (n2 = r3[0], o3 = r3[1])), Array.isArray(t3) && (n2 = t3[0] * _t5, o3 = t3[1] * _t5), isNaN(n2) && (n2 = s2[0], o3 = s2[1]), (n2 > 14400 || o3 > 14400) && (a.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), n2 = Math.min(14400, n2), o3 = Math.min(14400, o3)), s2 = [n2, o3], i2.substr(0, 1)) {
      case "l":
        o3 > n2 && (s2 = [o3, n2]);
        break;
      case "p":
        n2 > o3 && (s2 = [o3, n2]);
    }
    je2(s2), pr(fr), lt2(Lr), 0 !== kr && lt2(kr + " J"), 0 !== Ir && lt2(Ir + " j"), Tt2.publish("addPage", { pageNumber: Dt2 });
  }, Be2 = function(t3) {
    t3 > 0 && t3 <= Dt2 && (ot2.splice(t3, 1), Rt2.splice(t3, 1), Dt2--, $2 > Dt2 && ($2 = Dt2), this.setPage($2));
  }, Me2 = function(t3) {
    t3 > 0 && t3 <= Dt2 && ($2 = t3);
  }, Ee2 = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
    return ot2.length - 1;
  }, qe2 = function(t3, e3, r3) {
    var n2, i3 = void 0;
    return r3 = r3 || {}, t3 = void 0 !== t3 ? t3 : Ft3[St2].fontName, e3 = void 0 !== e3 ? e3 : Ft3[St2].fontStyle, n2 = t3.toLowerCase(), void 0 !== Ct2[n2] && void 0 !== Ct2[n2][e3] ? i3 = Ct2[n2][e3] : void 0 !== Ct2[t3] && void 0 !== Ct2[t3][e3] ? i3 = Ct2[t3][e3] : false === r3.disableWarning && a.warn("Unable to look up font label for font '" + t3 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i3 || r3.noFallback || null == (i3 = Ct2.times[e3]) && (i3 = Ct2.times.normal), i3;
  }, De2 = y2.__private__.putInfo = function() {
    var t3 = Xt3(), e3 = function(t4) {
      return t4;
    };
    for (var r3 in null !== m2 && (e3 = Ye2.encryptor(t3, 0)), lt2("<<"), lt2("/Producer (" + Ce2(e3("jsPDF " + E.version)) + ")"), xt2)
      xt2.hasOwnProperty(r3) && xt2[r3] && lt2("/" + r3.substr(0, 1).toUpperCase() + r3.substr(1) + " (" + Ce2(e3(xt2[r3])) + ")");
    lt2("/CreationDate (" + Ce2(e3(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, Re2 = y2.__private__.putCatalog = function(t3) {
    var e3 = (t3 = t3 || {}).rootDictionaryObjId || Qt2;
    switch (Xt3(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e3 + " 0 R"), mt2 || (mt2 = "fullwidth"), mt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var r3 = "" + mt2;
        "%" === r3.substr(r3.length - 1) && (mt2 = parseInt(mt2) / 100), "number" == typeof mt2 && lt2("/OpenAction [3 0 R /XYZ null null " + R2(mt2) + "]");
    }
    switch (Nt2 || (Nt2 = "continuous"), Nt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    yt2 && lt2("/PageMode /" + yt2), Tt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Te2 = y2.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), null !== m2 && lt2("/Encrypt " + Ye2.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, Ue2 = y2.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%ºß¬à");
  }, ze2 = y2.__private__.putXRef = function() {
    var t3 = "0000000000";
    lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
    for (var e3 = 1; e3 <= et2; e3++) {
      "function" == typeof rt2[e3] ? lt2((t3 + rt2[e3]()).slice(-10) + " 00000 n ") : void 0 !== rt2[e3] ? lt2((t3 + rt2[e3]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }
  }, He2 = y2.__private__.buildDocument = function() {
    ut2(), ht2(nt2), Tt2.publish("buildDocument"), Ue2(), oe2(), Se2(), xe2(), null !== m2 && be2(), De2(), Re2();
    var t3 = it2;
    return ze2(), Te2(), lt2("startxref"), lt2("" + t3), lt2("%%EOF"), ht2(ot2[$2]), nt2.join("\n");
  }, We2 = y2.__private__.getBlob = function(t3) {
    return new Blob([dt2(t3)], { type: "application/pdf" });
  }, Ve2 = y2.output = y2.__private__.output = Ie2(function(t3, e3) {
    switch ("string" == typeof (e3 = e3 || {}) ? e3 = { filename: e3 } : e3.filename = e3.filename || "generated.pdf", t3) {
      case void 0:
        return He2();
      case "save":
        y2.save(e3.filename);
        break;
      case "arraybuffer":
        return dt2(He2());
      case "blob":
        return We2(He2());
      case "bloburi":
      case "bloburl":
        if (void 0 !== n.URL && "function" == typeof n.URL.createObjectURL)
          return n.URL && n.URL.createObjectURL(We2(He2())) || void 0;
        a.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var r3 = "", i3 = He2();
        try {
          r3 = h(i3);
        } catch (t4) {
          r3 = h(unescape(encodeURIComponent(i3)));
        }
        return "data:application/pdf;filename=" + e3.filename + ";base64," + r3;
      case "pdfobjectnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var o3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e3.pdfObjectUrl && (o3 = e3.pdfObjectUrl, s3 = "");
          var c3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + o3 + '"' + s3 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");<\/script></body></html>", u3 = n.open();
          return null !== u3 && u3.document.write(c3), u3;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(n)) {
          var l2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', f2 = n.open();
          if (null !== f2) {
            f2.document.write(l2);
            var d3 = this;
            f2.document.documentElement.querySelector("#pdfViewer").onload = function() {
              f2.document.title = e3.filename, f2.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(d3.output("bloburl"));
            };
          }
          return f2;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if ("[object Window]" !== Object.prototype.toString.call(n))
          throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', g3 = n.open();
        if (null !== g3 && (g3.document.write(p3), g3.document.title = e3.filename), g3 || "undefined" == typeof safari)
          return g3;
        break;
      case "datauri":
      case "dataurl":
        return n.document.location.href = this.output("datauristring", e3);
      default:
        return null;
    }
  }), Ge2 = function(t3) {
    return true === Array.isArray(Ut2) && Ut2.indexOf(t3) > -1;
  };
  switch (o2) {
    case "pt":
      _t5 = 1;
      break;
    case "mm":
      _t5 = 72 / 25.4;
      break;
    case "cm":
      _t5 = 72 / 2.54;
      break;
    case "in":
      _t5 = 72;
      break;
    case "px":
      _t5 = 1 == Ge2("px_scaling") ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      _t5 = 12;
      break;
    case "ex":
      _t5 = 6;
      break;
    default:
      if ("number" != typeof o2)
        throw new Error("Invalid unit: " + o2);
      _t5 = o2;
  }
  var Ye2 = null;
  K2(), Y2();
  var Je2 = function(t3) {
    return null !== m2 ? Ye2.encryptor(t3, 0) : function(t4) {
      return t4;
    };
  }, Xe2 = y2.__private__.getPageInfo = y2.getPageInfo = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t3].objId, pageNumber: t3, pageContext: Rt2[t3] };
  }, Ke2 = y2.__private__.getPageInfoByObjId = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0)
      throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e3 in Rt2)
      if (Rt2[e3].objId === t3)
        break;
    return Xe2(e3);
  }, Ze2 = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y2.addPage = function() {
    return Oe2.apply(this, arguments), this;
  }, y2.setPage = function() {
    return Me2.apply(this, arguments), ht2.call(this, ot2[$2]), this;
  }, y2.insertPage = function(t3) {
    return this.addPage(), this.movePage($2, t3), this;
  }, y2.movePage = function(t3, e3) {
    var r3, n2;
    if (t3 > e3) {
      r3 = ot2[t3], n2 = Rt2[t3];
      for (var i3 = t3; i3 > e3; i3--)
        ot2[i3] = ot2[i3 - 1], Rt2[i3] = Rt2[i3 - 1];
      ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);
    } else if (t3 < e3) {
      r3 = ot2[t3], n2 = Rt2[t3];
      for (var a2 = t3; a2 < e3; a2++)
        ot2[a2] = ot2[a2 + 1], Rt2[a2] = Rt2[a2 + 1];
      ot2[e3] = r3, Rt2[e3] = n2, this.setPage(e3);
    }
    return this;
  }, y2.deletePage = function() {
    return Be2.apply(this, arguments), this;
  }, y2.__private__.text = y2.text = function(e3, r3, n2, i3, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3 = (i3 = i3 || {}).scope || this;
    if ("number" == typeof e3 && "number" == typeof r3 && ("string" == typeof n2 || Array.isArray(n2))) {
      var m3 = n2;
      n2 = r3, r3 = e3, e3 = m3;
    }
    if (arguments[3] instanceof Vt2 == false ? (c3 = arguments[4], u3 = arguments[5], "object" === _typeof$2(f2 = arguments[3]) && null !== f2 || ("string" == typeof c3 && (u3 = c3, c3 = null), "string" == typeof f2 && (u3 = f2, f2 = null), "number" == typeof f2 && (c3 = f2, f2 = null), i3 = { flags: f2, angle: c3, align: u3 })) : (q2("The transform parameter of text() with a Matrix value"), p3 = a2), isNaN(r3) || isNaN(n2) || null == e3)
      throw new Error("Invalid arguments passed to jsPDF.text");
    if (0 === e3.length)
      return g3;
    var v3 = "", y3 = false, w3 = "number" == typeof i3.lineHeightFactor ? i3.lineHeightFactor : lr, N3 = g3.internal.scaleFactor;
    function L3(t3) {
      return t3 = t3.split("	").join(Array(i3.TabLen || 9).join(" ")), Ce2(t3, f2);
    }
    function A3(t3) {
      for (var e4, r4 = t3.concat(), n3 = [], i4 = r4.length; i4--; )
        "string" == typeof (e4 = r4.shift()) ? n3.push(e4) : Array.isArray(t3) && (1 === e4.length || void 0 === e4[1] && void 0 === e4[2]) ? n3.push(e4[0]) : n3.push([e4[0], e4[1], e4[2]]);
      return n3;
    }
    function _3(t3, e4) {
      var r4;
      if ("string" == typeof t3)
        r4 = e4(t3)[0];
      else if (Array.isArray(t3)) {
        for (var n3, i4, a3 = t3.concat(), o4 = [], s4 = a3.length; s4--; )
          "string" == typeof (n3 = a3.shift()) ? o4.push(e4(n3)[0]) : Array.isArray(n3) && "string" == typeof n3[0] && (i4 = e4(n3[0], n3[1], n3[2]), o4.push([i4[0], i4[1], i4[2]]));
        r4 = o4;
      }
      return r4;
    }
    var P3 = false, k3 = true;
    if ("string" == typeof e3)
      P3 = true;
    else if (Array.isArray(e3)) {
      var I2 = e3.concat();
      s3 = [];
      for (var F2, C2 = I2.length; C2--; )
        ("string" != typeof (F2 = I2.shift()) || Array.isArray(F2) && "string" != typeof F2[0]) && (k3 = false);
      P3 = k3;
    }
    if (false === P3)
      throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
    "string" == typeof e3 && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
    var j2 = gt2 / g3.internal.scaleFactor, B3 = j2 * (w3 - 1);
    switch (i3.baseline) {
      case "bottom":
        n2 -= B3;
        break;
      case "top":
        n2 += j2 - B3;
        break;
      case "hanging":
        n2 += j2 - 2 * B3;
        break;
      case "middle":
        n2 += j2 / 2 - B3;
    }
    if ((l2 = i3.maxWidth || 0) > 0 && ("string" == typeof e3 ? e3 = g3.splitTextToSize(e3, l2) : "[object Array]" === Object.prototype.toString.call(e3) && (e3 = e3.reduce(function(t3, e4) {
      return t3.concat(g3.splitTextToSize(e4, l2));
    }, []))), o3 = { text: e3, x: r3, y: n2, options: i3, mutex: { pdfEscape: Ce2, activeFontKey: St2, fonts: Ft3, activeFontSize: gt2 } }, Tt2.publish("preProcessText", o3), e3 = o3.text, c3 = (i3 = o3.options).angle, p3 instanceof Vt2 == false && c3 && "number" == typeof c3) {
      c3 *= Math.PI / 180, 0 === i3.rotationDirection && (c3 = -c3), S2 === x2.ADVANCED && (c3 = -c3);
      var M2 = Math.cos(c3), E2 = Math.sin(c3);
      p3 = new Vt2(M2, E2, -E2, M2, 0, 0);
    } else
      c3 && c3 instanceof Vt2 && (p3 = c3);
    S2 !== x2.ADVANCED || p3 || (p3 = Yt2), void 0 !== (h2 = i3.charSpace || _r) && (v3 += O2(U2(h2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d3 = i3.horizontalScale) && (v3 += O2(100 * d3) + " Tz\n");
    i3.lang;
    var D3 = -1, R3 = void 0 !== i3.renderingMode ? i3.renderingMode : i3.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
    switch (R3) {
      case 0:
      case false:
      case "fill":
        D3 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        D3 = 1;
        break;
      case 2:
      case "fillThenStroke":
        D3 = 2;
        break;
      case 3:
      case "invisible":
        D3 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        D3 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        D3 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        D3 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        D3 = 7;
    }
    var z3 = void 0 !== T3.usedRenderingMode ? T3.usedRenderingMode : -1;
    -1 !== D3 ? v3 += D3 + " Tr\n" : -1 !== z3 && (v3 += "0 Tr\n"), -1 !== D3 && (T3.usedRenderingMode = D3), u3 = i3.align || "left";
    var H5, W3 = gt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft3[St2];
    h2 = i3.charSpace || _r, l2 = i3.maxWidth || 0, f2 = Object.assign({ autoencode: true, noBOM: true }, i3.flags);
    var Y3 = [];
    if ("[object Array]" === Object.prototype.toString.call(e3)) {
      var J3;
      s3 = A3(e3), "left" !== u3 && (H5 = s3.map(function(t3) {
        return g3.getStringUnitWidth(t3, { font: G3, charSpace: h2, fontSize: gt2, doKerning: false }) * gt2 / N3;
      }));
      var X3, K3 = 0;
      if ("right" === u3) {
        r3 -= H5[0], e3 = [], C2 = s3.length;
        for (var Z3 = 0; Z3 < C2; Z3++)
          0 === Z3 ? (X3 = br(r3), J3 = yr(n2)) : (X3 = U2(K3 - H5[Z3]), J3 = -W3), e3.push([s3[Z3], X3, J3]), K3 = H5[Z3];
      } else if ("center" === u3) {
        r3 -= H5[0] / 2, e3 = [], C2 = s3.length;
        for (var $3 = 0; $3 < C2; $3++)
          0 === $3 ? (X3 = br(r3), J3 = yr(n2)) : (X3 = U2((K3 - H5[$3]) / 2), J3 = -W3), e3.push([s3[$3], X3, J3]), K3 = H5[$3];
      } else if ("left" === u3) {
        e3 = [], C2 = s3.length;
        for (var Q3 = 0; Q3 < C2; Q3++)
          e3.push(s3[Q3]);
      } else {
        if ("justify" !== u3)
          throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        e3 = [], C2 = s3.length, l2 = 0 !== l2 ? l2 : V3;
        for (var tt3 = 0; tt3 < C2; tt3++)
          J3 = 0 === tt3 ? yr(n2) : -W3, X3 = 0 === tt3 ? br(r3) : 0, tt3 < C2 - 1 ? Y3.push(O2(U2((l2 - H5[tt3]) / (s3[tt3].split(" ").length - 1)))) : Y3.push(0), e3.push([s3[tt3], X3, J3]);
      }
    }
    var et3 = "boolean" == typeof i3.R2L ? i3.R2L : bt2;
    true === et3 && (e3 = _3(e3, function(t3, e4, r4) {
      return [t3.split("").reverse().join(""), e4, r4];
    })), o3 = { text: e3, x: r3, y: n2, options: i3, mutex: { pdfEscape: Ce2, activeFontKey: St2, fonts: Ft3, activeFontSize: gt2 } }, Tt2.publish("postProcessText", o3), e3 = o3.text, y3 = o3.mutex.isHex || false;
    var rt3 = Ft3[St2].encoding;
    "WinAnsiEncoding" !== rt3 && "StandardEncoding" !== rt3 || (e3 = _3(e3, function(t3, e4, r4) {
      return [L3(t3), e4, r4];
    })), s3 = A3(e3), e3 = [];
    for (var nt3, it3, at3, ot3 = 0, st3 = 1, ct3 = Array.isArray(s3[0]) ? st3 : ot3, ut3 = "", ht3 = function(t3, e4, r4) {
      var n3 = "";
      return r4 instanceof Vt2 ? (r4 = "number" == typeof i3.angle ? Gt2(r4, new Vt2(1, 0, 0, 1, t3, e4)) : Gt2(new Vt2(1, 0, 0, 1, t3, e4), r4), S2 === x2.ADVANCED && (r4 = Gt2(new Vt2(1, 0, 0, -1, 0, 0), r4)), n3 = r4.join(" ") + " Tm\n") : n3 = O2(t3) + " " + O2(e4) + " Td\n", n3;
    }, ft3 = 0; ft3 < s3.length; ft3++) {
      switch (ut3 = "", ct3) {
        case st3:
          at3 = (y3 ? "<" : "(") + s3[ft3][0] + (y3 ? ">" : ")"), nt3 = parseFloat(s3[ft3][1]), it3 = parseFloat(s3[ft3][2]);
          break;
        case ot3:
          at3 = (y3 ? "<" : "(") + s3[ft3] + (y3 ? ">" : ")"), nt3 = br(r3), it3 = yr(n2);
      }
      void 0 !== Y3 && void 0 !== Y3[ft3] && (ut3 = Y3[ft3] + " Tw\n"), 0 === ft3 ? e3.push(ut3 + ht3(nt3, it3, p3) + at3) : ct3 === ot3 ? e3.push(ut3 + at3) : ct3 === st3 && e3.push(ut3 + ht3(nt3, it3, p3) + at3);
    }
    e3 = ct3 === ot3 ? e3.join(" Tj\nT* ") : e3.join(" Tj\n"), e3 += " Tj\n";
    var dt3 = "BT\n/";
    return dt3 += St2 + " " + gt2 + " Tf\n", dt3 += O2(gt2 * w3) + " TL\n", dt3 += xr + "\n", dt3 += v3, dt3 += e3, lt2(dt3 += "ET"), b2[St2] = true, g3;
  };
  var $e2 = y2.__private__.clip = y2.clip = function(t3) {
    return lt2("evenodd" === t3 ? "W*" : "W"), this;
  };
  y2.clipEvenOdd = function() {
    return $e2("evenodd");
  }, y2.__private__.discardPath = y2.discardPath = function() {
    return lt2("n"), this;
  };
  var Qe2 = y2.__private__.isValidStyle = function(t3) {
    var e3 = false;
    return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t3) && (e3 = true), e3;
  };
  y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t3) {
    return Qe2(t3) && (g2 = t3), this;
  };
  var tr = y2.__private__.getStyle = y2.getStyle = function(t3) {
    var e3 = g2;
    switch (t3) {
      case "D":
      case "S":
        e3 = "S";
        break;
      case "F":
        e3 = "f";
        break;
      case "FD":
      case "DF":
        e3 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e3 = t3;
    }
    return e3;
  }, er = y2.close = function() {
    return lt2("h"), this;
  };
  y2.stroke = function() {
    return lt2("S"), this;
  }, y2.fill = function(t3) {
    return rr("f", t3), this;
  }, y2.fillEvenOdd = function(t3) {
    return rr("f*", t3), this;
  }, y2.fillStroke = function(t3) {
    return rr("B", t3), this;
  }, y2.fillStrokeEvenOdd = function(t3) {
    return rr("B*", t3), this;
  };
  var rr = function(e3, r3) {
    "object" === _typeof$2(r3) ? ar(r3, e3) : lt2(e3);
  }, nr = function(t3) {
    null === t3 || S2 === x2.ADVANCED && void 0 === t3 || (t3 = tr(t3), lt2(t3));
  };
  function ir(t3, e3, r3, n2, i3) {
    var a2 = new M(e3 || this.boundingBox, r3 || this.xStep, n2 || this.yStep, this.gState, i3 || this.matrix);
    a2.stream = this.stream;
    var o3 = t3 + "$$" + this.cloneIndex++ + "$$";
    return Jt2(o3, a2), a2;
  }
  var ar = function(t3, e3) {
    var r3 = Bt2[t3.key], n2 = Ot2[r3];
    if (n2 instanceof B)
      lt2("q"), lt2(or(e3)), n2.gState && y2.setGState(n2.gState), lt2(t3.matrix.toString() + " cm"), lt2("/" + r3 + " sh"), lt2("Q");
    else if (n2 instanceof M) {
      var i3 = new Vt2(1, 0, 0, -1, 0, Rr());
      t3.matrix && (i3 = i3.multiply(t3.matrix || Yt2), r3 = ir.call(n2, t3.key, t3.boundingBox, t3.xStep, t3.yStep, i3).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + r3 + " scn"), n2.gState && y2.setGState(n2.gState), lt2(e3), lt2("Q");
    }
  }, or = function(t3) {
    switch (t3) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, sr = y2.moveTo = function(t3, e3) {
    return lt2(O2(U2(t3)) + " " + O2(H4(e3)) + " m"), this;
  }, cr = y2.lineTo = function(t3, e3) {
    return lt2(O2(U2(t3)) + " " + O2(H4(e3)) + " l"), this;
  }, ur = y2.curveTo = function(t3, e3, r3, n2, i3, a2) {
    return lt2([O2(U2(t3)), O2(H4(e3)), O2(U2(r3)), O2(H4(n2)), O2(U2(i3)), O2(H4(a2)), "c"].join(" ")), this;
  };
  y2.__private__.line = y2.line = function(t3, e3, r3, n2, i3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe2(i3))
      throw new Error("Invalid arguments passed to jsPDF.line");
    return S2 === x2.COMPAT ? this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1], i3 || "S") : this.lines([[r3 - t3, n2 - e3]], t3, e3, [1, 1]).stroke();
  }, y2.__private__.lines = y2.lines = function(t3, e3, r3, n2, i3, a2) {
    var o3, s3, c3, u3, h2, l2, f2, d3, p3, g3, m3, v3;
    if ("number" == typeof t3 && (v3 = r3, r3 = e3, e3 = t3, t3 = v3), n2 = n2 || [1, 1], a2 = a2 || false, isNaN(e3) || isNaN(r3) || !Array.isArray(t3) || !Array.isArray(n2) || !Qe2(i3) || "boolean" != typeof a2)
      throw new Error("Invalid arguments passed to jsPDF.lines");
    for (sr(e3, r3), o3 = n2[0], s3 = n2[1], u3 = t3.length, g3 = e3, m3 = r3, c3 = 0; c3 < u3; c3++)
      2 === (h2 = t3[c3]).length ? (g3 = h2[0] * o3 + g3, m3 = h2[1] * s3 + m3, cr(g3, m3)) : (l2 = h2[0] * o3 + g3, f2 = h2[1] * s3 + m3, d3 = h2[2] * o3 + g3, p3 = h2[3] * s3 + m3, g3 = h2[4] * o3 + g3, m3 = h2[5] * s3 + m3, ur(l2, f2, d3, p3, g3, m3));
    return a2 && er(), nr(i3), this;
  }, y2.path = function(t3) {
    for (var e3 = 0; e3 < t3.length; e3++) {
      var r3 = t3[e3], n2 = r3.c;
      switch (r3.op) {
        case "m":
          sr(n2[0], n2[1]);
          break;
        case "l":
          cr(n2[0], n2[1]);
          break;
        case "c":
          ur.apply(this, n2);
          break;
        case "h":
          er();
      }
    }
    return this;
  }, y2.__private__.rect = y2.rect = function(t3, e3, r3, n2, i3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe2(i3))
      throw new Error("Invalid arguments passed to jsPDF.rect");
    return S2 === x2.COMPAT && (n2 = -n2), lt2([O2(U2(t3)), O2(H4(e3)), O2(U2(r3)), O2(U2(n2)), "re"].join(" ")), nr(i3), this;
  }, y2.__private__.triangle = y2.triangle = function(t3, e3, r3, n2, i3, a2, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe2(o3))
      throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[r3 - t3, n2 - e3], [i3 - r3, a2 - n2], [t3 - i3, e3 - a2]], t3, e3, [1, 1], o3, true), this;
  }, y2.__private__.roundedRect = y2.roundedRect = function(t3, e3, r3, n2, i3, a2, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || isNaN(i3) || isNaN(a2) || !Qe2(o3))
      throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s3 = 4 / 3 * (Math.SQRT2 - 1);
    return i3 = Math.min(i3, 0.5 * r3), a2 = Math.min(a2, 0.5 * n2), this.lines([[r3 - 2 * i3, 0], [i3 * s3, 0, i3, a2 - a2 * s3, i3, a2], [0, n2 - 2 * a2], [0, a2 * s3, -i3 * s3, a2, -i3, a2], [2 * i3 - r3, 0], [-i3 * s3, 0, -i3, -a2 * s3, -i3, -a2], [0, 2 * a2 - n2], [0, -a2 * s3, i3 * s3, -a2, i3, -a2]], t3 + i3, e3, [1, 1], o3, true), this;
  }, y2.__private__.ellipse = y2.ellipse = function(t3, e3, r3, n2, i3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n2) || !Qe2(i3))
      throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a2 = 4 / 3 * (Math.SQRT2 - 1) * r3, o3 = 4 / 3 * (Math.SQRT2 - 1) * n2;
    return sr(t3 + r3, e3), ur(t3 + r3, e3 - o3, t3 + a2, e3 - n2, t3, e3 - n2), ur(t3 - a2, e3 - n2, t3 - r3, e3 - o3, t3 - r3, e3), ur(t3 - r3, e3 + o3, t3 - a2, e3 + n2, t3, e3 + n2), ur(t3 + a2, e3 + n2, t3 + r3, e3 + o3, t3 + r3, e3), nr(i3), this;
  }, y2.__private__.circle = y2.circle = function(t3, e3, r3, n2) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || !Qe2(n2))
      throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t3, e3, r3, r3, n2);
  }, y2.setFont = function(t3, e3, r3) {
    return r3 && (e3 = k2(e3, r3)), St2 = qe2(t3, e3, { disableWarning: false }), this;
  };
  var hr = y2.__private__.getFont = y2.getFont = function() {
    return Ft3[qe2.apply(y2, arguments)];
  };
  y2.__private__.getFontList = y2.getFontList = function() {
    var t3, e3, r3 = {};
    for (t3 in Ct2)
      if (Ct2.hasOwnProperty(t3))
        for (e3 in r3[t3] = [], Ct2[t3])
          Ct2[t3].hasOwnProperty(e3) && r3[t3].push(e3);
    return r3;
  }, y2.addFont = function(t3, e3, r3, n2, i3) {
    var a2 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && -1 !== a2.indexOf(arguments[3]) ? i3 = arguments[3] : arguments[3] && -1 == a2.indexOf(arguments[3]) && (r3 = k2(r3, n2)), i3 = i3 || "Identity-H", Pe2.call(this, t3, e3, r3, i3);
  };
  var lr, fr = e2.lineWidth || 0.200025, dr = y2.__private__.getLineWidth = y2.getLineWidth = function() {
    return fr;
  }, pr = y2.__private__.setLineWidth = y2.setLineWidth = function(t3) {
    return fr = t3, lt2(O2(U2(t3)) + " w"), this;
  };
  y2.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function(t3, e3) {
    if (t3 = t3 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t3))
      throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t3 = t3.map(function(t4) {
      return O2(U2(t4));
    }).join(" "), e3 = O2(U2(e3)), lt2("[" + t3 + "] " + e3 + " d"), this;
  };
  var gr = y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return gt2 * lr;
  };
  var mr = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t3) {
    return "number" == typeof (t3 = t3 || 1.15) && (lr = t3), this;
  }, vr = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
    return lr;
  };
  mr(e2.lineHeight);
  var br = y2.__private__.getHorizontalCoordinate = function(t3) {
    return U2(t3);
  }, yr = y2.__private__.getVerticalCoordinate = function(t3) {
    return S2 === x2.ADVANCED ? t3 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t3);
  }, wr = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t3) {
    return O2(br(t3));
  }, Nr = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t3) {
    return O2(yr(t3));
  }, Lr = e2.strokeColor || "0 G";
  y2.__private__.getStrokeColor = y2.getDrawColor = function() {
    return ee2(Lr);
  }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t3, e3, r3, n2) {
    return Lr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: "draw", precision: 2 }), lt2(Lr), this;
  };
  var Ar = e2.fillColor || "0 g";
  y2.__private__.getFillColor = y2.getFillColor = function() {
    return ee2(Ar);
  }, y2.__private__.setFillColor = y2.setFillColor = function(t3, e3, r3, n2) {
    return Ar = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: "fill", precision: 2 }), lt2(Ar), this;
  };
  var xr = e2.textColor || "0 g", Sr = y2.__private__.getTextColor = y2.getTextColor = function() {
    return ee2(xr);
  };
  y2.__private__.setTextColor = y2.setTextColor = function(t3, e3, r3, n2) {
    return xr = re2({ ch1: t3, ch2: e3, ch3: r3, ch4: n2, pdfColorType: "text", precision: 3 }), this;
  };
  var _r = e2.charSpace, Pr = y2.__private__.getCharSpace = y2.getCharSpace = function() {
    return parseFloat(_r || 0);
  };
  y2.__private__.setCharSpace = y2.setCharSpace = function(t3) {
    if (isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return _r = t3, this;
  };
  var kr = 0;
  y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t3) {
    var e3 = y2.CapJoinStyles[t3];
    if (void 0 === e3)
      throw new Error("Line cap style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return kr = e3, lt2(e3 + " J"), this;
  };
  var Ir = 0;
  y2.__private__.setLineJoin = y2.setLineJoin = function(t3) {
    var e3 = y2.CapJoinStyles[t3];
    if (void 0 === e3)
      throw new Error("Line join style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Ir = e3, lt2(e3 + " j"), this;
  }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t3) {
    if (t3 = t3 || 0, isNaN(t3))
      throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(O2(U2(t3)) + " M"), this;
  }, y2.GState = j, y2.setGState = function(t3) {
    (t3 = "string" == typeof t3 ? Mt2[Et3[t3]] : Fr(null, t3)).equals(qt2) || (lt2("/" + t3.id + " gs"), qt2 = t3);
  };
  var Fr = function(t3, e3) {
    if (!t3 || !Et3[t3]) {
      var r3 = false;
      for (var n2 in Mt2)
        if (Mt2.hasOwnProperty(n2) && Mt2[n2].equals(e3)) {
          r3 = true;
          break;
        }
      if (r3)
        e3 = Mt2[n2];
      else {
        var i3 = "GS" + (Object.keys(Mt2).length + 1).toString(10);
        Mt2[i3] = e3, e3.id = i3;
      }
      return t3 && (Et3[t3] = e3.id), Tt2.publish("addGState", e3), e3;
    }
  };
  y2.addGState = function(t3, e3) {
    return Fr(t3, e3), this;
  }, y2.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: St2, size: gt2, color: xr }), this;
  }, y2.restoreGraphicsState = function() {
    lt2("Q");
    var t3 = jt2.pop();
    return St2 = t3.key, gt2 = t3.size, xr = t3.color, qt2 = null, this;
  }, y2.setCurrentTransformationMatrix = function(t3) {
    return lt2(t3.toString() + " cm"), this;
  }, y2.comment = function(t3) {
    return lt2("#" + t3), this;
  };
  var Cr = function(t3, e3) {
    var r3 = t3 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      isNaN(t4) || (r3 = parseFloat(t4));
    } });
    var n2 = e3 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return n2;
    }, set: function(t4) {
      isNaN(t4) || (n2 = parseFloat(t4));
    } });
    var i3 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      i3 = t4.toString();
    } }), this;
  }, jr = function(t3, e3, r3, n2) {
    Cr.call(this, t3, e3), this.type = "rect";
    var i3 = r3 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      isNaN(t4) || (i3 = parseFloat(t4));
    } });
    var a2 = n2 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a2;
    }, set: function(t4) {
      isNaN(t4) || (a2 = parseFloat(t4));
    } }), this;
  }, Or = function() {
    this.page = Dt2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = Pt2, this.y = kt2, this.matrix = It2, this.width = qr($2), this.height = Rr($2), this.outputDestination = ct2, this.id = "", this.objectNumber = -1;
  };
  Or.prototype.restore = function() {
    Dt2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, Pt2 = this.x, kt2 = this.y, It2 = this.matrix, Dr($2, this.width), Tr($2, this.height), ct2 = this.outputDestination;
  };
  var Br = function(t3, e3, r3, n2, i3) {
    Wt2.push(new Or()), Dt2 = $2 = 0, ot2 = [], Pt2 = t3, kt2 = e3, It2 = i3, je2([r3, n2]);
  }, Mr = function(t3) {
    if (Ht2[t3])
      Wt2.pop().restore();
    else {
      var e3 = new Or(), r3 = "Xo" + (Object.keys(zt3).length + 1).toString(10);
      e3.id = r3, Ht2[t3] = r3, zt3[r3] = e3, Tt2.publish("addFormObject", e3), Wt2.pop().restore();
    }
  };
  for (var Er in y2.beginFormObject = function(t3, e3, r3, n2, i3) {
    return Br(t3, e3, r3, n2, i3), this;
  }, y2.endFormObject = function(t3) {
    return Mr(t3), this;
  }, y2.doFormObject = function(t3, e3) {
    var r3 = zt3[Ht2[t3]];
    return lt2("q"), lt2(e3.toString() + " cm"), lt2("/" + r3.id + " Do"), lt2("Q"), this;
  }, y2.getFormObject = function(t3) {
    var e3 = zt3[Ht2[t3]];
    return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };
  }, y2.save = function(t3, e3) {
    return t3 = t3 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, false === e3.returnPromise ? (l(We2(He2()), t3), "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), this) : new Promise(function(e4, r3) {
      try {
        var i3 = l(We2(He2()), t3);
        "function" == typeof l.unload && n.setTimeout && setTimeout(l.unload, 911), e4(i3);
      } catch (t4) {
        r3(t4.message);
      }
    });
  }, E.API)
    E.API.hasOwnProperty(Er) && ("events" === Er && E.API.events.length ? function(t3, e3) {
      var r3, n2, i3;
      for (i3 = e3.length - 1; -1 !== i3; i3--)
        r3 = e3[i3][0], n2 = e3[i3][1], t3.subscribe.apply(t3, [r3].concat("function" == typeof n2 ? [n2] : n2));
    }(Tt2, E.API.events) : y2[Er] = E.API[Er]);
  var qr = y2.getPageWidth = function(t3) {
    return (Rt2[t3 = t3 || $2].mediaBox.topRightX - Rt2[t3].mediaBox.bottomLeftX) / _t5;
  }, Dr = y2.setPageWidth = function(t3, e3) {
    Rt2[t3].mediaBox.topRightX = e3 * _t5 + Rt2[t3].mediaBox.bottomLeftX;
  }, Rr = y2.getPageHeight = function(t3) {
    return (Rt2[t3 = t3 || $2].mediaBox.topRightY - Rt2[t3].mediaBox.bottomLeftY) / _t5;
  }, Tr = y2.setPageHeight = function(t3, e3) {
    Rt2[t3].mediaBox.topRightY = e3 * _t5 + Rt2[t3].mediaBox.bottomLeftY;
  };
  return y2.internal = { pdfEscape: Ce2, getStyle: tr, getFont: hr, getFontSize: vt2, getCharSpace: Pr, getTextColor: Sr, getLineHeight: gr, getLineHeightFactor: vr, getLineWidth: dr, write: ft2, getHorizontalCoordinate: br, getVerticalCoordinate: yr, getCoordinateString: wr, getVerticalCoordinateString: Nr, collections: {}, newObject: Xt3, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: ne2, putStream: ie2, events: Tt2, scaleFactor: _t5, pageSize: { getWidth: function() {
    return qr($2);
  }, setWidth: function(t3) {
    Dr($2, t3);
  }, getHeight: function() {
    return Rr($2);
  }, setHeight: function(t3) {
    Tr($2, t3);
  } }, encryptionOptions: m2, encryption: Ye2, getEncryptor: Je2, output: Ve2, getNumberOfPages: Ee2, pages: ot2, out: lt2, f2: R2, f3: T2, getPageInfo: Xe2, getPageInfoByObjId: Ke2, getCurrentPageInfo: Ze2, getPDFVersion: N2, Point: Cr, Rectangle: jr, Matrix: Vt2, hasHotfix: Ge2 }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
    return qr($2);
  }, set: function(t3) {
    Dr($2, t3);
  }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
    return Rr($2);
  }, set: function(t3) {
    Tr($2, t3);
  }, enumerable: true, configurable: true }), ke2.call(y2, pt2), St2 = "F1", Oe2(s2, i2), Tt2.publish("initialized"), y2;
}
I.prototype.lsbFirstWord = function(t3) {
  return String.fromCharCode(t3 >> 0 & 255, t3 >> 8 & 255, t3 >> 16 & 255, t3 >> 24 & 255);
}, I.prototype.toHexString = function(t3) {
  return t3.split("").map(function(t4) {
    return ("0" + (255 & t4.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t3) {
  for (var e2 = [], r2 = 0; r2 < t3.length; r2 += 2)
    e2.push(String.fromCharCode(parseInt(t3.substr(r2, 2), 16)));
  return e2.join("");
}, I.prototype.processOwnerPassword = function(t3, e2) {
  return P(x(e2).substr(0, 5), t3);
}, I.prototype.encryptor = function(t3, e2) {
  var r2 = x(this.encryptionKey + String.fromCharCode(255 & t3, t3 >> 8 & 255, t3 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);
  return function(t4) {
    return P(r2, t4);
  };
}, j.prototype.equals = function(e2) {
  var r2, n2 = "id,objectNumber,equals";
  if (!e2 || _typeof$2(e2) !== _typeof$2(this))
    return false;
  var i2 = 0;
  for (r2 in this)
    if (!(n2.indexOf(r2) >= 0)) {
      if (this.hasOwnProperty(r2) && !e2.hasOwnProperty(r2))
        return false;
      if (this[r2] !== e2[r2])
        return false;
      i2++;
    }
  for (r2 in e2)
    e2.hasOwnProperty(r2) && n2.indexOf(r2) < 0 && i2--;
  return 0 === i2;
}, E.API = { events: [] }, E.version = "2.5.1";
var q = E.API, D = 1, R = function(t3) {
  return t3.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, T = function(t3) {
  return t3.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, U = function(t3) {
  return t3.toFixed(2);
}, z = function(t3) {
  return t3.toFixed(5);
};
q.__acroform__ = {};
var H = function(t3, e2) {
  t3.prototype = Object.create(e2.prototype), t3.prototype.constructor = t3;
}, W = function(t3) {
  return t3 * D;
}, V = function(t3) {
  var e2 = new ut(), r2 = At.internal.getHeight(t3) || 0, n2 = At.internal.getWidth(t3) || 0;
  return e2.BBox = [0, 0, Number(U(n2)), Number(U(r2))], e2;
}, G = q.__acroform__.setBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t3 |= 1 << e2;
}, Y = q.__acroform__.clearBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t3 &= ~(1 << e2);
}, J = q.__acroform__.getBit = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return 0 == (t3 & 1 << e2) ? 0 : 1;
}, X = q.__acroform__.getBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return J(t3, e2 - 1);
}, K = q.__acroform__.setBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return G(t3, e2 - 1);
}, Z = q.__acroform__.clearBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2))
    throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return Y(t3, e2 - 1);
}, $ = q.__acroform__.calculateCoordinates = function(t3, e2) {
  var r2 = e2.internal.getHorizontalCoordinate, n2 = e2.internal.getVerticalCoordinate, i2 = t3[0], a2 = t3[1], o2 = t3[2], s2 = t3[3], c2 = {};
  return c2.lowerLeft_X = r2(i2) || 0, c2.lowerLeft_Y = n2(a2 + s2) || 0, c2.upperRight_X = r2(i2 + o2) || 0, c2.upperRight_Y = n2(a2) || 0, [Number(U(c2.lowerLeft_X)), Number(U(c2.lowerLeft_Y)), Number(U(c2.upperRight_X)), Number(U(c2.upperRight_Y))];
}, Q = function(t3) {
  if (t3.appearanceStreamContent)
    return t3.appearanceStreamContent;
  if (t3.V || t3.DV) {
    var e2 = [], r2 = t3._V || t3.DV, n2 = tt(t3, r2), i2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id;
    e2.push("/Tx BMC"), e2.push("q"), e2.push("BT"), e2.push(t3.scope.__private__.encodeColorString(t3.color)), e2.push("/" + i2 + " " + U(n2.fontSize) + " Tf"), e2.push("1 0 0 1 0 0 Tm"), e2.push(n2.text), e2.push("ET"), e2.push("Q"), e2.push("EMC");
    var a2 = V(t3);
    return a2.scope = t3.scope, a2.stream = e2.join("\n"), a2;
  }
}, tt = function(t3, e2) {
  var r2 = 0 === t3.fontSize ? t3.maxFontSize : t3.fontSize, n2 = { text: "", fontSize: "" }, i2 = (e2 = ")" == (e2 = "(" == e2.substr(0, 1) ? e2.substr(1) : e2).substr(e2.length - 1) ? e2.substr(0, e2.length - 1) : e2).split(" ");
  i2 = t3.multiline ? i2.map(function(t4) {
    return t4.split("\n");
  }) : i2.map(function(t4) {
    return [t4];
  });
  var a2 = r2, o2 = At.internal.getHeight(t3) || 0;
  o2 = o2 < 0 ? -o2 : o2;
  var s2 = At.internal.getWidth(t3) || 0;
  s2 = s2 < 0 ? -s2 : s2;
  var c2 = function(e3, r3, n3) {
    if (e3 + 1 < i2.length) {
      var a3 = r3 + " " + i2[e3 + 1][0];
      return et(a3, t3, n3).width <= s2 - 4;
    }
    return false;
  };
  a2++;
  t:
    for (; a2 > 0; ) {
      e2 = "", a2--;
      var u2, h2, l2 = et("3", t3, a2).height, f2 = t3.multiline ? o2 - a2 : (o2 - l2) / 2, d2 = f2 += 2, p2 = 0, g2 = 0, m2 = 0;
      if (a2 <= 0) {
        e2 = "(...) Tj\n", e2 += "% Width of Text: " + et(e2, t3, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
        break;
      }
      for (var v2 = "", b2 = 0, y2 = 0; y2 < i2.length; y2++)
        if (i2.hasOwnProperty(y2)) {
          var w2 = false;
          if (1 !== i2[y2].length && m2 !== i2[y2].length - 1) {
            if ((l2 + 2) * (b2 + 2) + 2 > o2)
              continue t;
            v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;
          } else {
            v2 = " " == (v2 += i2[y2][m2] + " ").substr(v2.length - 1) ? v2.substr(0, v2.length - 1) : v2;
            var N2 = parseInt(y2), L2 = c2(N2, v2, a2), A2 = y2 >= i2.length - 1;
            if (L2 && !A2) {
              v2 += " ", m2 = 0;
              continue;
            }
            if (L2 || A2) {
              if (A2)
                g2 = N2;
              else if (t3.multiline && (l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
            } else {
              if (!t3.multiline)
                continue t;
              if ((l2 + 2) * (b2 + 2) + 2 > o2)
                continue t;
              g2 = N2;
            }
          }
          for (var x2 = "", S2 = p2; S2 <= g2; S2++) {
            var _2 = i2[S2];
            if (t3.multiline) {
              if (S2 === g2) {
                x2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
                continue;
              }
              if (S2 === p2) {
                x2 += _2[_2.length - 1] + " ";
                continue;
              }
            }
            x2 += _2[0] + " ";
          }
          switch (x2 = " " == x2.substr(x2.length - 1) ? x2.substr(0, x2.length - 1) : x2, h2 = et(x2, t3, a2).width, t3.textAlign) {
            case "right":
              u2 = s2 - h2 - 2;
              break;
            case "center":
              u2 = (s2 - h2) / 2;
              break;
            case "left":
            default:
              u2 = 2;
          }
          e2 += U(u2) + " " + U(d2) + " Td\n", e2 += "(" + R(x2) + ") Tj\n", e2 += -U(u2) + " 0 Td\n", d2 = -(a2 + 2), h2 = 0, p2 = w2 ? g2 : g2 + 1, b2++, v2 = "";
        }
      break;
    }
  return n2.text = e2, n2.fontSize = a2, n2;
}, et = function(t3, e2, r2) {
  var n2 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i2 = e2.scope.getStringUnitWidth(t3, { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2);
  return { height: e2.scope.getStringUnitWidth("3", { font: n2, fontSize: parseFloat(r2), charSpace: 0 }) * parseFloat(r2) * 1.5, width: i2 };
}, rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false }, nt = function(t3, e2) {
  var r2 = { type: "reference", object: t3 };
  void 0 === e2.internal.getPageInfo(t3.page).pageContext.annotations.find(function(t4) {
    return t4.type === r2.type && t4.object === r2.object;
  }) && e2.internal.getPageInfo(t3.page).pageContext.annotations.push(r2);
}, it = function(e2, r2) {
  for (var n2 in e2)
    if (e2.hasOwnProperty(n2)) {
      var i2 = n2, a2 = e2[n2];
      r2.internal.newObjectDeferredBegin(a2.objId, true), "object" === _typeof$2(a2) && "function" == typeof a2.putStream && a2.putStream(), delete e2[i2];
    }
}, at = function(e2, r2) {
  if (r2.scope = e2, void 0 !== e2.internal && (void 0 === e2.internal.acroformPlugin || false === e2.internal.acroformPlugin.isInitialized)) {
    if (lt.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e2.internal.acroformPlugin.acroFormDictionaryRoot)
      throw new Error("Exception while creating AcroformDictionary");
    D = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new ht(), e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe("postPutResources", function() {
      !function(t3) {
        t3.internal.events.unsubscribe(t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t3.internal.acroformPlugin.printedOut = true;
      }(e2);
    }), e2.internal.events.subscribe("buildDocument", function() {
      !function(t3) {
        t3.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e3 = t3.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r3 in e3)
          if (e3.hasOwnProperty(r3)) {
            var n2 = e3[r3];
            n2.objId = void 0, n2.hasAnnotation && nt(n2, t3);
          }
      }(e2);
    }), e2.internal.events.subscribe("putCatalog", function() {
      !function(t3) {
        if (void 0 === t3.internal.acroformPlugin.acroFormDictionaryRoot)
          throw new Error("putCatalogCallback: Root missing.");
        t3.internal.write("/AcroForm " + t3.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      }(e2);
    }), e2.internal.events.subscribe("postPutPages", function(r3) {
      !function(e3, r4) {
        var n2 = !e3;
        for (var i2 in e3 || (r4.internal.newObjectDeferredBegin(r4.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), r4.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || r4.internal.acroformPlugin.acroFormDictionaryRoot.Kids)
          if (e3.hasOwnProperty(i2)) {
            var a2 = e3[i2], o2 = [], s2 = a2.Rect;
            if (a2.Rect && (a2.Rect = $(a2.Rect, r4)), r4.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = At.createDefaultAppearanceStream(a2), "object" === _typeof$2(a2) && "function" == typeof a2.getKeyValueListForStream && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
              var c2 = Q(a2);
              o2.push({ key: "AP", value: "<</N " + c2 + ">>" }), r4.internal.acroformPlugin.xForms.push(c2);
            }
            if (a2.appearanceStreamContent) {
              var u2 = "";
              for (var h2 in a2.appearanceStreamContent)
                if (a2.appearanceStreamContent.hasOwnProperty(h2)) {
                  var l2 = a2.appearanceStreamContent[h2];
                  if (u2 += "/" + h2 + " ", u2 += "<<", Object.keys(l2).length >= 1 || Array.isArray(l2)) {
                    for (var i2 in l2)
                      if (l2.hasOwnProperty(i2)) {
                        var f2 = l2[i2];
                        "function" == typeof f2 && (f2 = f2.call(r4, a2)), u2 += "/" + i2 + " " + f2 + " ", r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);
                      }
                  } else
                    "function" == typeof (f2 = l2) && (f2 = f2.call(r4, a2)), u2 += "/" + i2 + " " + f2, r4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || r4.internal.acroformPlugin.xForms.push(f2);
                  u2 += ">>";
                }
              o2.push({ key: "AP", value: "<<\n" + u2 + ">>" });
            }
            r4.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), r4.internal.out("endobj");
          }
        n2 && it(r4.internal.acroformPlugin.xForms, r4);
      }(r3, e2);
    }), e2.internal.acroformPlugin.isInitialized = true;
  }
}, ot = q.__acroform__.arrayToPdfArray = function(e2, r2, n2) {
  var i2 = function(t3) {
    return t3;
  };
  if (Array.isArray(e2)) {
    for (var a2 = "[", o2 = 0; o2 < e2.length; o2++)
      switch (0 !== o2 && (a2 += " "), _typeof$2(e2[o2])) {
        case "boolean":
        case "number":
        case "object":
          a2 += e2[o2].toString();
          break;
        case "string":
          "/" !== e2[o2].substr(0, 1) ? (void 0 !== r2 && n2 && (i2 = n2.internal.getEncryptor(r2)), a2 += "(" + R(i2(e2[o2].toString())) + ")") : a2 += e2[o2].toString();
      }
    return a2 += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
};
var st = function(t3, e2, r2) {
  var n2 = function(t4) {
    return t4;
  };
  return void 0 !== e2 && r2 && (n2 = r2.internal.getEncryptor(e2)), (t3 = t3 || "").toString(), t3 = "(" + R(n2(t3)) + ")";
}, ct = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (void 0 === this._objId) {
      if (void 0 === this.scope)
        return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t3) {
    this._objId = t3;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
};
ct.prototype.toString = function() {
  return this.objId + " 0 R";
}, ct.prototype.putStream = function() {
  var t3 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t3, objectId: this.objId }), this.scope.internal.out("endobj");
}, ct.prototype.getKeyValueListForStream = function() {
  var t3 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t4) {
    return "content" != t4 && "appearanceStreamContent" != t4 && "scope" != t4 && "objId" != t4 && "_" != t4.substring(0, 1);
  });
  for (var r2 in e2)
    if (false === Object.getOwnPropertyDescriptor(this, e2[r2]).configurable) {
      var n2 = e2[r2], i2 = this[n2];
      i2 && (Array.isArray(i2) ? t3.push({ key: n2, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ct ? (i2.scope = this.scope, t3.push({ key: n2, value: i2.objId + " 0 R" })) : "function" != typeof i2 && t3.push({ key: n2, value: i2 }));
    }
  return t3;
};
var ut = function() {
  ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t3, e2 = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e2;
  }, set: function(t4) {
    e2 = t4;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e3) {
    t3 = e3.trim();
  }, get: function() {
    return t3 || null;
  } });
};
H(ut, ct);
var ht = function() {
  ct.call(this);
  var t3, e2 = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e2.length > 0 ? e2 : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e2;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t3) {
      var e3 = function(t4) {
        return t4;
      };
      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(t3)) + ")";
    }
  }, set: function(e3) {
    t3 = e3;
  } });
};
H(ht, ct);
var lt = function t2() {
  ct.call(this);
  var e2 = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute F supplied.');
    e2 = t3;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(e2, 3));
  }, set: function(t3) {
    true === Boolean(t3) ? this.F = K(e2, 3) : this.F = Z(e2, 3);
  } });
  var r2 = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return r2;
  }, set: function(t3) {
    if (isNaN(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute Ff supplied.');
    r2 = t3;
  } });
  var n2 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (0 !== n2.length)
      return n2;
  }, set: function(t3) {
    n2 = void 0 !== t3 ? t3 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[0]) ? 0 : n2[0];
  }, set: function(t3) {
    n2[0] = t3;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[1]) ? 0 : n2[1];
  }, set: function(t3) {
    n2[1] = t3;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[2]) ? 0 : n2[2];
  }, set: function(t3) {
    n2[2] = t3;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !n2 || isNaN(n2[3]) ? 0 : n2[3];
  }, set: function(t3) {
    n2[3] = t3;
  } });
  var i2 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i2;
  }, set: function(t3) {
    switch (t3) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i2 = t3;
        break;
      default:
        throw new Error('Invalid value "' + t3 + '" for attribute FT supplied.');
    }
  } });
  var a2 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a2 || a2.length < 1) {
      if (this instanceof yt)
        return;
      a2 = "FieldObject" + t2.FieldNum++;
    }
    var e3 = function(t3) {
      return t3;
    };
    return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + R(e3(a2)) + ")";
  }, set: function(t3) {
    a2 = t3.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a2;
  }, set: function(t3) {
    a2 = t3;
  } });
  var o2 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o2;
  }, set: function(t3) {
    o2 = t3;
  } });
  var s2 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s2;
  }, set: function(t3) {
    s2 = t3;
  } });
  var c2 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return c2;
  }, set: function(t3) {
    c2 = t3;
  } });
  var u2 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return void 0 === u2 ? 50 / D : u2;
  }, set: function(t3) {
    u2 = t3;
  } });
  var h2 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return h2;
  }, set: function(t3) {
    h2 = t3;
  } });
  var l2 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!l2 || this instanceof yt || this instanceof Nt))
      return st(l2, this.objId, this.scope);
  }, set: function(t3) {
    t3 = t3.toString(), l2 = t3;
  } });
  var f2 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f2)
      return this instanceof mt == false ? st(f2, this.objId, this.scope) : f2;
  }, set: function(t3) {
    t3 = t3.toString(), f2 = this instanceof mt == false ? "(" === t3.substr(0, 1) ? T(t3.substr(1, t3.length - 2)) : T(t3) : t3;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T(f2.substr(1, f2.length - 1)) : f2;
  }, set: function(t3) {
    t3 = t3.toString(), f2 = this instanceof mt == true ? "/" + t3 : t3;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return d2;
  }, set: function(t3) {
    this.V = t3;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2)
      return this instanceof mt == false ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == false ? "(" === t3.substr(0, 1) ? T(t3.substr(1, t3.length - 2)) : T(t3) : t3;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == true ? T(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == true ? "/" + t3 : t3;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p2, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t3) {
    t3 = Boolean(t3), g2 = t3;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p2)
      return p2;
  }, set: function(t3) {
    p2 = t3;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 1));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 2));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 3));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3);
  } });
  var m2 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (null !== m2)
      return m2;
  }, set: function(t3) {
    if (-1 === [0, 1, 2].indexOf(t3))
      throw new Error('Invalid value "' + t3 + '" for attribute Q supplied.');
    m2 = t3;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t3;
    switch (m2) {
      case 0:
      default:
        t3 = "left";
        break;
      case 1:
        t3 = "center";
        break;
      case 2:
        t3 = "right";
    }
    return t3;
  }, configurable: true, enumerable: true, set: function(t3) {
    switch (t3) {
      case "right":
      case 2:
        m2 = 2;
        break;
      case "center":
      case 1:
        m2 = 1;
        break;
      case "left":
      case 0:
      default:
        m2 = 0;
    }
  } });
};
H(lt, ct);
var ft = function() {
  lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t3 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } });
  var e2 = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e2, this.objId, this.scope);
  }, set: function(t4) {
    var r2, n2;
    n2 = [], "string" == typeof (r2 = t4) && (n2 = function(t5, e3, r3) {
      r3 || (r3 = 1);
      for (var n3, i2 = []; n3 = e3.exec(t5); )
        i2.push(n3[r3]);
      return i2;
    }(r2, /\((.*?)\)/g)), e2 = n2;
  } }), this.getOptions = function() {
    return e2;
  }, this.setOptions = function(t4) {
    e2 = t4, this.sort && e2.sort();
  }, this.addOption = function(t4) {
    t4 = (t4 = t4 || "").toString(), e2.push(t4), this.sort && e2.sort();
  }, this.removeOption = function(t4, r2) {
    for (r2 = r2 || false, t4 = (t4 = t4 || "").toString(); -1 !== e2.indexOf(t4) && (e2.splice(e2.indexOf(t4), 1), false !== r2); )
      ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 18));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 19));
  }, set: function(t4) {
    true === this.combo && (true === Boolean(t4) ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 20));
  }, set: function(t4) {
    true === Boolean(t4) ? (this.Ff = K(this.Ff, 20), e2.sort()) : this.Ff = Z(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 22));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 27));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
};
H(ft, lt);
var dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
};
H(dt, ft);
var pt = function() {
  dt.call(this), this.combo = true;
};
H(pt, dt);
var gt = function() {
  pt.call(this), this.edit = true;
};
H(gt, pt);
var mt = function() {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 15));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 16));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 17));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var e2, r2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    if (this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(r2).length) {
      var e3, n2 = [];
      for (e3 in n2.push("<<"), r2)
        n2.push("/" + e3 + " (" + R(t3(r2[e3])) + ")");
      return n2.push(">>"), n2.join("\n");
    }
  }, set: function(e3) {
    "object" === _typeof$2(e3) && (r2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return r2.CA || "";
  }, set: function(t3) {
    "string" == typeof t3 && (r2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e2.substr(1, e2.length - 1);
  }, set: function(t3) {
    e2 = "/" + t3;
  } });
};
H(mt, lt);
var vt = function() {
  mt.call(this), this.pushButton = true;
};
H(vt, mt);
var bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t3 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = void 0 !== e2 ? e2 : [];
  } });
};
H(bt, mt);
var yt = function() {
  var e2, r2;
  lt.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return r2;
  }, set: function(t3) {
    r2 = t3;
  } });
  var n2, i2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    this.scope && (t3 = this.scope.internal.getEncryptor(this.objId));
    var e3, r3 = [];
    for (e3 in r3.push("<<"), i2)
      r3.push("/" + e3 + " (" + R(t3(i2[e3])) + ")");
    return r3.push(">>"), r3.join("\n");
  }, set: function(e3) {
    "object" === _typeof$2(e3) && (i2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i2.CA || "";
  }, set: function(t3) {
    "string" == typeof t3 && (i2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return n2;
  }, set: function(t3) {
    n2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return n2.substr(1, n2.length - 1);
  }, set: function(t3) {
    n2 = "/" + t3;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
H(yt, lt), bt.prototype.setAppearance = function(t3) {
  if (!("createAppearanceStream" in t3) || !("getCA" in t3))
    throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e2 in this.Kids)
    if (this.Kids.hasOwnProperty(e2)) {
      var r2 = this.Kids[e2];
      r2.appearanceStreamContent = t3.createAppearanceStream(r2.optionName), r2.caption = t3.getCA();
    }
}, bt.prototype.createOption = function(t3) {
  var e2 = new yt();
  return e2.Parent = this, e2.optionName = t3, this.Kids.push(e2), xt.call(this.scope, e2), e2;
};
var wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream();
};
H(wt, mt);
var Nt = function() {
  lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 13));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 21));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 23));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 24));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 25));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 26));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26);
  } });
  var t3 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = e2;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e2) {
    Number.isInteger(e2) && (t3 = e2);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
};
H(Nt, lt);
var Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(X(this.Ff, 14));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14);
  } }), this.password = true;
};
H(Lt, Nt);
var At = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } };
}, YesPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, i2 = t3.scope.__private__.encodeColorString(t3.color), a2 = tt(t3, t3.caption);
  return r2.push("0.749023 g"), r2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), r2.push("f"), r2.push("BMC"), r2.push("q"), r2.push("0 0 1 rg"), r2.push("/" + n2 + " " + U(a2.fontSize) + " Tf " + i2), r2.push("BT"), r2.push(a2.text), r2.push("ET"), r2.push("Q"), r2.push("EMC"), e2.stream = r2.join("\n"), e2;
}, YesNormal: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, n2 = t3.scope.__private__.encodeColorString(t3.color), i2 = [], a2 = At.internal.getHeight(t3), o2 = At.internal.getWidth(t3), s2 = tt(t3, t3.caption);
  return i2.push("1 g"), i2.push("0 0 " + U(o2) + " " + U(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + U(o2 - 1) + " " + U(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + r2 + " " + U(s2.fontSize) + " Tf " + n2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e2.stream = i2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [];
  return r2.push("0.749023 g"), r2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
} }, RadioButton: { Circle: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} };
  return e2.N[t3] = At.RadioButton.Circle.YesNormal, e2.D[t3] = At.RadioButton.Circle.YesPushDown, e2;
}, getCA: function() {
  return "l";
}, YesNormal: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = At.internal.Bezier_C, a2 = Number((n2 * i2).toFixed(5));
  return r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + a2 + " " + a2 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + a2 + " " + n2 + " -" + n2 + " " + a2 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + a2 + " -" + a2 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(a2 + " -" + n2 + " " + n2 + " -" + a2 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5)), o2 = Number((n2 * At.internal.Bezier_C).toFixed(5));
  return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), r2.push("0 g"), r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(n2 + " 0 m"), r2.push(n2 + " " + o2 + " " + o2 + " " + n2 + " 0 " + n2 + " c"), r2.push("-" + o2 + " " + n2 + " -" + n2 + " " + o2 + " -" + n2 + " 0 c"), r2.push("-" + n2 + " -" + o2 + " -" + o2 + " -" + n2 + " 0 -" + n2 + " c"), r2.push(o2 + " -" + n2 + " " + n2 + " -" + o2 + " " + n2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.getWidth(t3) <= At.internal.getHeight(t3) ? At.internal.getWidth(t3) / 4 : At.internal.getHeight(t3) / 4;
  n2 = Number((0.9 * n2).toFixed(5));
  var i2 = Number((2 * n2).toFixed(5)), a2 = Number((i2 * At.internal.Bezier_C).toFixed(5));
  return r2.push("0.749023 g"), r2.push("q"), r2.push("1 0 0 1 " + z(At.internal.getWidth(t3) / 2) + " " + z(At.internal.getHeight(t3) / 2) + " cm"), r2.push(i2 + " 0 m"), r2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), r2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), r2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), r2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), r2.push("f"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
} }, Cross: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} };
  return e2.N[t3] = At.RadioButton.Cross.YesNormal, e2.D[t3] = At.RadioButton.Cross.YesPushDown, e2;
}, getCA: function() {
  return "8";
}, YesNormal: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [], n2 = At.internal.calculateCross(t3);
  return r2.push("q"), r2.push("1 1 " + U(At.internal.getWidth(t3) - 2) + " " + U(At.internal.getHeight(t3) - 2) + " re"), r2.push("W"), r2.push("n"), r2.push(U(n2.x1.x) + " " + U(n2.x1.y) + " m"), r2.push(U(n2.x2.x) + " " + U(n2.x2.y) + " l"), r2.push(U(n2.x4.x) + " " + U(n2.x4.y) + " m"), r2.push(U(n2.x3.x) + " " + U(n2.x3.y) + " l"), r2.push("s"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = At.internal.calculateCross(t3), n2 = [];
  return n2.push("0.749023 g"), n2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), n2.push("f"), n2.push("q"), n2.push("1 1 " + U(At.internal.getWidth(t3) - 2) + " " + U(At.internal.getHeight(t3) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(U(r2.x1.x) + " " + U(r2.x1.y) + " m"), n2.push(U(r2.x2.x) + " " + U(r2.x2.y) + " l"), n2.push(U(r2.x4.x) + " " + U(r2.x4.y) + " m"), n2.push(U(r2.x3.x) + " " + U(r2.x3.y) + " l"), n2.push("s"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = V(t3);
  e2.scope = t3.scope;
  var r2 = [];
  return r2.push("0.749023 g"), r2.push("0 0 " + U(At.internal.getWidth(t3)) + " " + U(At.internal.getHeight(t3)) + " re"), r2.push("f"), e2.stream = r2.join("\n"), e2;
} } }, createDefaultAppearanceStream: function(t3) {
  var e2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, r2 = t3.scope.__private__.encodeColorString(t3.color);
  return "/" + e2 + " " + t3.fontSize + " Tf " + r2;
} };
At.internal = { Bezier_C: 0.551915024494, calculateCross: function(t3) {
  var e2 = At.internal.getWidth(t3), r2 = At.internal.getHeight(t3), n2 = Math.min(e2, r2);
  return { x1: { x: (e2 - n2) / 2, y: (r2 - n2) / 2 + n2 }, x2: { x: (e2 - n2) / 2 + n2, y: (r2 - n2) / 2 }, x3: { x: (e2 - n2) / 2, y: (r2 - n2) / 2 }, x4: { x: (e2 - n2) / 2 + n2, y: (r2 - n2) / 2 + n2 } };
} }, At.internal.getWidth = function(e2) {
  var r2 = 0;
  return "object" === _typeof$2(e2) && (r2 = W(e2.Rect[2])), r2;
}, At.internal.getHeight = function(e2) {
  var r2 = 0;
  return "object" === _typeof$2(e2) && (r2 = W(e2.Rect[3])), r2;
};
var xt = q.addField = function(t3) {
  if (at(this, t3), !(t3 instanceof lt))
    throw new Error("Invalid argument passed to jsPDF.addField.");
  var e2;
  return (e2 = t3).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t3.page = t3.scope.internal.getCurrentPageInfo().pageNumber, this;
};
q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At };
function _t(t3) {
  return t3.reduce(function(t4, e2, r2) {
    return t4[e2] = r2, t4;
  }, {});
}
!function(e2) {
  e2.__addimage__ = {};
  var r2 = "UNKNOWN", n2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i2 = e2.__addimage__.getImageFileTypeByImageData = function(t3, e3) {
    var i3, a3, o3, s3, c3, u2 = r2;
    if ("RGBA" === (e3 = e3 || r2) || void 0 !== t3.data && t3.data instanceof Uint8ClampedArray && "height" in t3 && "width" in t3)
      return "RGBA";
    if (x2(t3))
      for (c3 in n2)
        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
            if (void 0 !== o3[i3][a3] && o3[i3][a3] !== t3[a3]) {
              s3 = false;
              break;
            }
          if (true === s3) {
            u2 = c3;
            break;
          }
        }
    else
      for (c3 in n2)
        for (o3 = n2[c3], i3 = 0; i3 < o3.length; i3 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[i3].length; a3 += 1)
            if (void 0 !== o3[i3][a3] && o3[i3][a3] !== t3.charCodeAt(a3)) {
              s3 = false;
              break;
            }
          if (true === s3) {
            u2 = c3;
            break;
          }
        }
    return u2 === r2 && e3 !== r2 && (u2 = e3), u2;
  }, a2 = function t3(e3) {
    for (var r3 = this.internal.write, n3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); -1 !== i3.indexOf("FlateEncode"); )
      i3.splice(i3.indexOf("FlateEncode"), 1);
    e3.objectId = this.internal.newObject();
    var a3 = [];
    if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e3.width }), a3.push({ key: "Height", value: e3.height }), e3.colorSpace === b2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && void 0 !== e3.sMask ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e3.colorSpace }), e3.colorSpace === b2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e3.bitsPerComponent }), "decodeParameters" in e3 && void 0 !== e3.decodeParameters && a3.push({ key: "DecodeParms", value: "<<" + e3.decodeParameters + ">>" }), "transparency" in e3 && Array.isArray(e3.transparency)) {
      for (var o3 = "", s3 = 0, c3 = e3.transparency.length; s3 < c3; s3++)
        o3 += e3.transparency[s3] + " " + e3.transparency[s3] + " ";
      a3.push({ key: "Mask", value: "[" + o3 + "]" });
    }
    void 0 !== e3.sMask && a3.push({ key: "SMask", value: e3.objectId + 1 + " 0 R" });
    var u2 = void 0 !== e3.filter ? ["/" + e3.filter] : void 0;
    if (n3({ data: e3.data, additionalKeyValues: a3, alreadyAppliedFilters: u2, objectId: e3.objectId }), r3("endobj"), "sMask" in e3 && void 0 !== e3.sMask) {
      var h3 = "/Predictor " + e3.predictor + " /Colors 1 /BitsPerComponent " + e3.bitsPerComponent + " /Columns " + e3.width, l3 = { width: e3.width, height: e3.height, colorSpace: "DeviceGray", bitsPerComponent: e3.bitsPerComponent, decodeParameters: h3, data: e3.sMask };
      "filter" in e3 && (l3.filter = e3.filter), t3.call(this, l3);
    }
    if (e3.colorSpace === b2.INDEXED) {
      var f3 = this.internal.newObject();
      n3({ data: _2(new Uint8Array(e3.palette)), objectId: f3 }), r3("endobj");
    }
  }, o2 = function() {
    var t3 = this.internal.collections.addImage_images;
    for (var e3 in t3)
      a2.call(this, t3[e3]);
  }, s2 = function() {
    var t3, e3 = this.internal.collections.addImage_images, r3 = this.internal.write;
    for (var n3 in e3)
      r3("/I" + (t3 = e3[n3]).index, t3.objectId, "0", "R");
  }, c2 = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", o2), this.internal.events.subscribe("putXobjectDict", s2));
  }, h2 = function() {
    var t3 = this.internal.collections.addImage_images;
    return c2.call(this), t3;
  }, l2 = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, f2 = function(t3) {
    return "function" == typeof e2["process" + t3.toUpperCase()];
  }, d2 = function(e3) {
    return "object" === _typeof$2(e3) && 1 === e3.nodeType;
  }, p2 = function(t3, r3) {
    if ("IMG" === t3.nodeName && t3.hasAttribute("src")) {
      var n3 = "" + t3.getAttribute("src");
      if (0 === n3.indexOf("data:image/"))
        return u(unescape(n3).split("base64,").pop());
      var i3 = e2.loadFile(n3, true);
      if (void 0 !== i3)
        return i3;
    }
    if ("CANVAS" === t3.nodeName) {
      if (0 === t3.width || 0 === t3.height)
        throw new Error("Given canvas must have data. Canvas width: " + t3.width + ", height: " + t3.height);
      var a3;
      switch (r3) {
        case "PNG":
          a3 = "image/png";
          break;
        case "WEBP":
          a3 = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          a3 = "image/jpeg";
      }
      return u(t3.toDataURL(a3, 1).split("base64,").pop());
    }
  }, g2 = function(t3) {
    var e3 = this.internal.collections.addImage_images;
    if (e3) {
      for (var r3 in e3)
        if (t3 === e3[r3].alias)
          return e3[r3];
    }
  }, m2 = function(t3, e3, r3) {
    return t3 || e3 || (t3 = -96, e3 = -96), t3 < 0 && (t3 = -1 * r3.width * 72 / t3 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * r3.height * 72 / e3 / this.internal.scaleFactor), 0 === t3 && (t3 = e3 * r3.width / r3.height), 0 === e3 && (e3 = t3 * r3.height / r3.width), [t3, e3];
  }, v2 = function(t3, e3, r3, n3, i3, a3) {
    var o3 = m2.call(this, r3, n3, i3), s3 = this.internal.getCoordinateString, c3 = this.internal.getVerticalCoordinateString, u2 = h2.call(this);
    if (r3 = o3[0], n3 = o3[1], u2[i3.index] = i3, a3) {
      a3 *= Math.PI / 180;
      var l3 = Math.cos(a3), f3 = Math.sin(a3), d3 = function(t4) {
        return t4.toFixed(4);
      }, p3 = [d3(l3), d3(f3), d3(-1 * f3), d3(l3), 0, 0, "cm"];
    }
    this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t3), c3(e3 + n3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(r3), "0", "0", s3(n3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(r3), "0", "0", s3(n3), s3(t3), c3(e3 + n3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
  }, b2 = e2.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e2.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var y2 = e2.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, w2 = e2.__addimage__.sHashCode = function(t3) {
    var e3, r3, n3 = 0;
    if ("string" == typeof t3)
      for (r3 = t3.length, e3 = 0; e3 < r3; e3++)
        n3 = (n3 << 5) - n3 + t3.charCodeAt(e3), n3 |= 0;
    else if (x2(t3))
      for (r3 = t3.byteLength / 2, e3 = 0; e3 < r3; e3++)
        n3 = (n3 << 5) - n3 + t3[e3], n3 |= 0;
    return n3;
  }, N2 = e2.__addimage__.validateStringAsBase64 = function(t3) {
    (t3 = t3 || "").toString().trim();
    var e3 = true;
    return 0 === t3.length && (e3 = false), t3.length % 4 != 0 && (e3 = false), false === /^[A-Za-z0-9+/]+$/.test(t3.substr(0, t3.length - 2)) && (e3 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t3.substr(-2)) && (e3 = false), e3;
  }, L2 = e2.__addimage__.extractImageFromDataUrl = function(t3) {
    var e3 = (t3 = t3 || "").split("base64,"), r3 = null;
    if (2 === e3.length) {
      var n3 = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(e3[0]);
      Array.isArray(n3) && (r3 = { mimeType: n3[1], charset: n3[2], data: e3[1] });
    }
    return r3;
  }, A2 = e2.__addimage__.supportsArrayBuffer = function() {
    return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array;
  };
  e2.__addimage__.isArrayBuffer = function(t3) {
    return A2() && t3 instanceof ArrayBuffer;
  };
  var x2 = e2.__addimage__.isArrayBufferView = function(t3) {
    return A2() && "undefined" != typeof Uint32Array && (t3 instanceof Int8Array || t3 instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array);
  }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t3) {
    for (var e3 = t3.length, r3 = new Uint8Array(e3), n3 = 0; n3 < e3; n3++)
      r3[n3] = t3.charCodeAt(n3);
    return r3;
  }, _2 = e2.__addimage__.arrayBufferToBinaryString = function(t3) {
    for (var e3 = "", r3 = x2(t3) ? t3 : new Uint8Array(t3), n3 = 0; n3 < r3.length; n3 += 8192)
      e3 += String.fromCharCode.apply(null, r3.subarray(n3, n3 + 8192));
    return e3;
  };
  e2.addImage = function() {
    var e3, n3, i3, a3, o3, s3, u2, h3, l3;
    if ("number" == typeof arguments[1] ? (n3 = r2, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u2 = arguments[5], h3 = arguments[6], l3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u2 = arguments[6], h3 = arguments[7], l3 = arguments[8]), "object" === _typeof$2(e3 = arguments[0]) && !d2(e3) && "imageData" in e3) {
      var f3 = e3;
      e3 = f3.imageData, n3 = f3.format || n3 || r2, i3 = f3.x || i3 || 0, a3 = f3.y || a3 || 0, o3 = f3.w || f3.width || o3, s3 = f3.h || f3.height || s3, u2 = f3.alias || u2, h3 = f3.compression || h3, l3 = f3.rotation || f3.angle || l3;
    }
    var p3 = this.internal.getFilters();
    if (void 0 === h3 && -1 !== p3.indexOf("FlateEncode") && (h3 = "SLOW"), isNaN(i3) || isNaN(a3))
      throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c2.call(this);
    var g3 = P2.call(this, e3, n3, u2, h3);
    return v2.call(this, i3, a3, o3, s3, g3, l3), this;
  };
  var P2 = function(t3, n3, a3, o3) {
    var s3, c3, u2;
    if ("string" == typeof t3 && i2(t3) === r2) {
      t3 = unescape(t3);
      var h3 = k2(t3, false);
      ("" !== h3 || void 0 !== (h3 = e2.loadFile(t3, true))) && (t3 = h3);
    }
    if (d2(t3) && (t3 = p2(t3, n3)), n3 = i2(t3, n3), !f2(n3))
      throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
    if ((null == (u2 = a3) || 0 === u2.length) && (a3 = function(t4) {
      return "string" == typeof t4 || x2(t4) ? w2(t4) : x2(t4.data) ? w2(t4.data) : null;
    }(t3)), (s3 = g2.call(this, a3)) || (A2() && (t3 instanceof Uint8Array || "RGBA" === n3 || (c3 = t3, t3 = S2(t3))), s3 = this["process" + n3.toUpperCase()](t3, l2.call(this), a3, function(t4) {
      return t4 && "string" == typeof t4 && (t4 = t4.toUpperCase()), t4 in e2.image_compression ? t4 : y2.NONE;
    }(o3), c3)), !s3)
      throw new Error("An unknown error occurred whilst processing the image.");
    return s3;
  }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t3, e3) {
    var r3;
    e3 = "boolean" != typeof e3 || e3;
    var n3, i3 = "";
    if ("string" == typeof t3) {
      n3 = null !== (r3 = L2(t3)) ? r3.data : t3;
      try {
        i3 = u(n3);
      } catch (t4) {
        if (e3)
          throw N2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + t4.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return i3;
  };
  e2.getImageProperties = function(t3) {
    var n3, a3, o3 = "";
    if (d2(t3) && (t3 = p2(t3)), "string" == typeof t3 && i2(t3) === r2 && ("" === (o3 = k2(t3, false)) && (o3 = e2.loadFile(t3) || ""), t3 = o3), a3 = i2(t3), !f2(a3))
      throw new Error("addImage does not support files of type '" + a3 + "', please ensure that a plugin for '" + a3 + "' support is added.");
    if (!A2() || t3 instanceof Uint8Array || (t3 = S2(t3)), !(n3 = this["process" + a3.toUpperCase()](t3)))
      throw new Error("An unknown error occurred whilst processing the image");
    return n3.fileType = a3, n3;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = function(t4) {
    if (void 0 !== t4 && "" != t4)
      return true;
  };
  E.API.events.push(["addPage", function(t4) {
    this.internal.getPageInfo(t4.pageNumber).pageContext.annotations = [];
  }]), t3.events.push(["putPage", function(t4) {
    for (var r2, n2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t4.objId), c2 = t4.pageContext.annotations, u2 = false, h2 = 0; h2 < c2.length && !u2; h2++)
      switch ((r2 = c2[h2]).type) {
        case "link":
          (e2(r2.options.url) || e2(r2.options.pageNumber)) && (u2 = true);
          break;
        case "reference":
        case "text":
        case "freetext":
          u2 = true;
      }
    if (0 != u2) {
      this.internal.write("/Annots [");
      for (var l2 = 0; l2 < c2.length; l2++) {
        r2 = c2[l2];
        var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t4.objId);
        switch (r2.type) {
          case "reference":
            this.internal.write(" " + r2.object.objId + " 0 R ");
            break;
          case "text":
            var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = r2.title || "Note";
            i2 = "<</Type /Annot /Subtype /Text " + (n2 = "/Rect [" + a2(r2.bounds.x) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a2(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y) + "] ") + "/Contents (" + f2(m2(r2.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m2(v2)) + ") >>", p2.content = i2;
            var b2 = p2.objId + " 0 R";
            i2 = "<</Type /Annot /Subtype /Popup " + (n2 = "/Rect [" + a2(r2.bounds.x + 30) + " " + o2(r2.bounds.y + r2.bounds.h) + " " + a2(r2.bounds.x + r2.bounds.w + 30) + " " + o2(r2.bounds.y) + "] ") + " /Parent " + b2, r2.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
            break;
          case "freetext":
            n2 = "/Rect [" + a2(r2.bounds.x) + " " + o2(r2.bounds.y) + " " + a2(r2.bounds.x + r2.bounds.w) + " " + o2(r2.bounds.y + r2.bounds.h) + "] ";
            var y2 = r2.color || "#000000";
            i2 = "<</Type /Annot /Subtype /FreeText " + n2 + "/Contents (" + f2(d2(r2.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
            break;
          case "link":
            if (r2.options.name) {
              var w2 = this.annotations._nameMap[r2.options.name];
              r2.options.pageNumber = w2.page, r2.options.top = w2.y;
            } else
              r2.options.top || (r2.options.top = 0);
            if (n2 = "/Rect [" + r2.finalBounds.x + " " + r2.finalBounds.y + " " + r2.finalBounds.w + " " + r2.finalBounds.h + "] ", i2 = "", r2.options.url)
              i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(r2.options.url)) + ") >>";
            else if (r2.options.pageNumber) {
              switch (i2 = "<</Type /Annot /Subtype /Link " + n2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(r2.options.pageNumber).objId + " 0 R", r2.options.magFactor = r2.options.magFactor || "XYZ", r2.options.magFactor) {
                case "Fit":
                  i2 += " /Fit]";
                  break;
                case "FitH":
                  i2 += " /FitH " + r2.options.top + "]";
                  break;
                case "FitV":
                  r2.options.left = r2.options.left || 0, i2 += " /FitV " + r2.options.left + "]";
                  break;
                case "XYZ":
                default:
                  var N2 = o2(r2.options.top);
                  r2.options.left = r2.options.left || 0, void 0 === r2.options.zoom && (r2.options.zoom = 0), i2 += " /XYZ " + r2.options.left + " " + N2 + " " + r2.options.zoom + "]";
              }
            }
            "" != i2 && (i2 += " >>", this.internal.write(i2));
        }
      }
      this.internal.write("]");
    }
  }]), t3.createAnnotation = function(t4) {
    var e3 = this.internal.getCurrentPageInfo();
    switch (t4.type) {
      case "link":
        this.link(t4.bounds.x, t4.bounds.y, t4.bounds.w, t4.bounds.h, t4);
        break;
      case "text":
      case "freetext":
        e3.pageContext.annotations.push(t4);
    }
  }, t3.link = function(t4, e3, r2, n2, i2) {
    var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
    a2.pageContext.annotations.push({ finalBounds: { x: o2(t4), y: s2(e3), w: o2(t4 + r2), h: s2(e3 + n2) }, options: i2, type: "link" });
  }, t3.textWithLink = function(t4, e3, r2, n2) {
    var i2, a2, o2 = this.getTextWidth(t4), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (void 0 !== n2.maxWidth) {
      a2 = n2.maxWidth;
      var c2 = this.splitTextToSize(t4, a2).length;
      i2 = Math.ceil(s2 * c2);
    } else
      a2 = o2, i2 = s2;
    return this.text(t4, e3, r2, n2), r2 += 0.2 * s2, "center" === n2.align && (e3 -= o2 / 2), "right" === n2.align && (e3 -= o2), this.link(e3, r2 - s2, a2, i2, n2), o2;
  }, t3.getTextWidth = function(t4) {
    var e3 = this.internal.getFontSize();
    return this.getStringUnitWidth(t4) * e3 / this.internal.scaleFactor;
  };
}(E.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, r2 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
  t3.__arabicParser__ = {};
  var a2 = t3.__arabicParser__.isInArabicSubstitutionA = function(t4) {
    return void 0 !== e2[t4.charCodeAt(0)];
  }, o2 = t3.__arabicParser__.isArabicLetter = function(t4) {
    return "string" == typeof t4 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t4);
  }, s2 = t3.__arabicParser__.isArabicEndLetter = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length <= 2;
  }, c2 = t3.__arabicParser__.isArabicAlfLetter = function(t4) {
    return o2(t4) && i2.indexOf(t4.charCodeAt(0)) >= 0;
  };
  t3.__arabicParser__.arabicLetterHasIsolatedForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 1;
  };
  var u2 = t3.__arabicParser__.arabicLetterHasFinalForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 2;
  };
  t3.__arabicParser__.arabicLetterHasInitialForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 3;
  };
  var h2 = t3.__arabicParser__.arabicLetterHasMedialForm = function(t4) {
    return o2(t4) && a2(t4) && 4 == e2[t4.charCodeAt(0)].length;
  }, l2 = t3.__arabicParser__.resolveLigatures = function(t4) {
    var e3 = 0, n3 = r2, i3 = "", a3 = 0;
    for (e3 = 0; e3 < t4.length; e3 += 1)
      void 0 !== n3[t4.charCodeAt(e3)] ? (a3++, "number" == typeof (n3 = n3[t4.charCodeAt(e3)]) && (i3 += String.fromCharCode(n3), n3 = r2, a3 = 0), e3 === t4.length - 1 && (n3 = r2, i3 += t4.charAt(e3 - (a3 - 1)), e3 -= a3 - 1, a3 = 0)) : (n3 = r2, i3 += t4.charAt(e3 - a3), e3 -= a3, a3 = 0);
    return i3;
  };
  t3.__arabicParser__.isArabicDiacritic = function(t4) {
    return void 0 !== t4 && void 0 !== n2[t4.charCodeAt(0)];
  };
  var f2 = t3.__arabicParser__.getCorrectForm = function(t4, e3, r3) {
    return o2(t4) ? false === a2(t4) ? -1 : !u2(t4) || !o2(e3) && !o2(r3) || !o2(r3) && s2(e3) || s2(t4) && !o2(e3) || s2(t4) && c2(e3) || s2(t4) && s2(e3) ? 0 : h2(t4) && o2(e3) && !s2(e3) && o2(r3) && u2(r3) ? 3 : s2(t4) || !o2(r3) ? 1 : 2 : -1;
  }, d2 = function(t4) {
    var r3 = 0, n3 = 0, i3 = 0, a3 = "", s3 = "", c3 = "", u3 = (t4 = t4 || "").split("\\s+"), h3 = [];
    for (r3 = 0; r3 < u3.length; r3 += 1) {
      for (h3.push(""), n3 = 0; n3 < u3[r3].length; n3 += 1)
        a3 = u3[r3][n3], s3 = u3[r3][n3 - 1], c3 = u3[r3][n3 + 1], o2(a3) ? (i3 = f2(a3, s3, c3), h3[r3] += -1 !== i3 ? String.fromCharCode(e2[a3.charCodeAt(0)][i3]) : a3) : h3[r3] += a3;
      h3[r3] = l2(h3[r3]);
    }
    return h3.join(" ");
  }, p2 = t3.__arabicParser__.processArabic = t3.processArabic = function() {
    var t4, e3 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, r3 = [];
    if (Array.isArray(e3)) {
      var n3 = 0;
      for (r3 = [], n3 = 0; n3 < e3.length; n3 += 1)
        Array.isArray(e3[n3]) ? r3.push([d2(e3[n3][0]), e3[n3][1], e3[n3][2]]) : r3.push([d2(e3[n3])]);
      t4 = r3;
    } else
      t4 = d2(e3);
    return "string" == typeof arguments[0] ? t4 : (arguments[0].text = t4, arguments[0]);
  };
  t3.events.push(["preProcessText", p2]);
}(E.API), E.API.autoPrint = function(t3) {
  var e2;
  switch ((t3 = t3 || {}).variant = t3.variant || "non-conform", t3.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e2 + " 0 R");
      });
  }
  return this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = function() {
    var t4 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t4;
    }, set: function(e4) {
      t4 = e4;
    } });
    var e3 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e3;
    }, set: function(t5) {
      e3 = isNaN(t5) || false === Number.isInteger(t5) || t5 < 0 ? 150 : t5, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
    } });
    var r2 = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r2;
    }, set: function(t5) {
      r2 = isNaN(t5) || false === Number.isInteger(t5) || t5 < 0 ? 300 : t5, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r2 + 1);
    } });
    var n2 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return n2;
    }, set: function(t5) {
      n2 = t5;
    } });
    var i2 = {};
    Object.defineProperty(this, "style", { get: function() {
      return i2;
    }, set: function(t5) {
      i2 = t5;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e2.prototype.getContext = function(t4, e3) {
    var r2;
    if ("2d" !== (t4 = t4 || "2d"))
      return null;
    for (r2 in e3)
      this.pdf.context2d.hasOwnProperty(r2) && (this.pdf.context2d[r2] = e3[r2]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e2.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t3.events.push(["initialized", function() {
    this.canvas = new e2(), this.canvas.pdf = this;
  }]);
}(E.API), function(e2) {
  var r2 = { left: 0, top: 0, bottom: 0, right: 0 }, n2 = false, i2 = function() {
    void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, r2), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
  }, a2 = function() {
    this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
  }, o2 = function() {
    var t3 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t3;
    }, set: function(e4) {
      t3 = e4;
    } });
    var e3 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e3;
    }, set: function(t4) {
      e3 = t4;
    } });
    var r3 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      r3 = t4;
    } });
    var n3 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return n3;
    }, set: function(t4) {
      n3 = t4;
    } });
    var i3 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      i3 = t4;
    } });
    var a3 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a3;
    }, set: function(t4) {
      a3 = t4;
    } });
    var o3 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o3;
    }, set: function(t4) {
      o3 = t4;
    } }), this;
  };
  o2.prototype.clone = function() {
    return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o2.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e2.setHeaderFunction = function(t3) {
    return i2.call(this), this.internal.__cell__.headerFunction = "function" == typeof t3 ? t3 : void 0, this;
  }, e2.getTextDimensions = function(t3, e3) {
    i2.call(this);
    var r3 = (e3 = e3 || {}).fontSize || this.getFontSize(), n3 = e3.font || this.getFont(), a3 = e3.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, c3 = 0, u2 = this;
    if (!Array.isArray(t3) && "string" != typeof t3) {
      if ("number" != typeof t3)
        throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t3 = String(t3);
    }
    var h2 = e3.maxWidth;
    h2 > 0 ? "string" == typeof t3 ? t3 = this.splitTextToSize(t3, h2) : "[object Array]" === Object.prototype.toString.call(t3) && (t3 = t3.reduce(function(t4, e4) {
      return t4.concat(u2.splitTextToSize(e4, h2));
    }, [])) : t3 = Array.isArray(t3) ? t3 : [t3];
    for (var l2 = 0; l2 < t3.length; l2++)
      o3 < (c3 = this.getStringUnitWidth(t3[l2], { font: n3 }) * r3) && (o3 = c3);
    return 0 !== o3 && (s3 = t3.length), { w: o3 /= a3, h: Math.max((s3 * r3 * this.getLineHeightFactor() - r3 * (this.getLineHeightFactor() - 1)) / a3, 0) };
  }, e2.cellAddPage = function() {
    i2.call(this), this.addPage();
    var t3 = this.internal.__cell__.margins || r2;
    return this.internal.__cell__.lastCell = new o2(t3.left, t3.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s2 = e2.cell = function() {
    var t3;
    t3 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);
    var e3 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || r2, c3 = this.internal.__cell__.tableHeaderRow, u2 = this.internal.__cell__.printHeaders;
    return void 0 !== e3.lineNumber && (e3.lineNumber === t3.lineNumber ? (t3.x = (e3.x || 0) + (e3.width || 0), t3.y = e3.y || 0) : e3.y + e3.height + t3.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t3.y = s3.top, u2 && c3 && (this.printHeaderRow(t3.lineNumber, true), t3.y += c3[0].height)) : t3.y = e3.y + e3.height || t3.y), void 0 !== t3.text[0] && (this.rect(t3.x, t3.y, t3.width, t3.height, true === n2 ? "FD" : void 0), "right" === t3.align ? this.text(t3.text, t3.x + t3.width - a3, t3.y + a3, { align: "right", baseline: "top" }) : "center" === t3.align ? this.text(t3.text, t3.x + t3.width / 2, t3.y + a3, { align: "center", baseline: "top", maxWidth: t3.width - a3 - a3 }) : this.text(t3.text, t3.x + a3, t3.y + a3, { align: "left", baseline: "top", maxWidth: t3.width - a3 - a3 })), this.internal.__cell__.lastCell = t3, this;
  };
  e2.table = function(e3, n3, u2, h2, l2) {
    if (i2.call(this), !u2)
      throw new Error("No data for PDF table.");
    var f2, d2, p2, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], A2 = (l2 = l2 || {}).autoSize || false, x2 = false !== l2.printHeaders, S2 = l2.css && void 0 !== l2.css["font-size"] ? 16 * l2.css["font-size"] : l2.fontSize || 12, _2 = l2.margins || Object.assign({ width: this.getPageWidth() }, r2), P2 = "number" == typeof l2.padding ? l2.padding : 3, k2 = l2.headerBackgroundColor || "#c8c8c8", I2 = l2.headerTextColor || "#000";
    if (a2.call(this), this.internal.__cell__.printHeaders = x2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = I2, this.setFontSize(S2), null == h2)
      v2 = m2 = Object.keys(u2[0]), b2 = m2.map(function() {
        return "left";
      });
    else if (Array.isArray(h2) && "object" === _typeof$2(h2[0]))
      for (m2 = h2.map(function(t3) {
        return t3.name;
      }), v2 = h2.map(function(t3) {
        return t3.prompt || t3.name || "";
      }), b2 = h2.map(function(t3) {
        return t3.align || "left";
      }), f2 = 0; f2 < h2.length; f2 += 1)
        w2[h2[f2].name] = h2[f2].width * (19.049976 / 25.4);
    else
      Array.isArray(h2) && "string" == typeof h2[0] && (v2 = m2 = h2, b2 = m2.map(function() {
        return "left";
      }));
    if (A2 || Array.isArray(h2) && "string" == typeof h2[0])
      for (f2 = 0; f2 < m2.length; f2 += 1) {
        for (y2[g2 = m2[f2]] = u2.map(function(t3) {
          return t3[g2];
        }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d2.length; p2 += 1)
          N2.push(this.getTextDimensions(d2[p2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
      }
    if (x2) {
      var F2 = {};
      for (f2 = 0; f2 < m2.length; f2 += 1)
        F2[m2[f2]] = {}, F2[m2[f2]].text = v2[f2], F2[m2[f2]].align = b2[f2];
      var C2 = c2.call(this, F2, w2);
      L2 = m2.map(function(t3) {
        return new o2(e3, n3, w2[t3], C2, F2[t3].text, void 0, F2[t3].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var j2 = h2.reduce(function(t3, e4) {
      return t3[e4.name] = e4.align, t3;
    }, {});
    for (f2 = 0; f2 < u2.length; f2 += 1) {
      "rowStart" in l2 && l2.rowStart instanceof Function && l2.rowStart({ row: f2, data: u2[f2] }, this);
      var O2 = c2.call(this, u2[f2], w2);
      for (p2 = 0; p2 < m2.length; p2 += 1) {
        var B3 = u2[f2][m2[p2]];
        "cellStart" in l2 && l2.cellStart instanceof Function && l2.cellStart({ row: f2, col: p2, data: B3 }, this), s2.call(this, new o2(e3, n3, w2[m2[p2]], O2, B3, f2 + 2, j2[m2[p2]]));
      }
    }
    return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = n3, this;
  };
  var c2 = function(t3, e3) {
    var r3 = this.internal.__cell__.padding, n3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
    return Object.keys(t3).map(function(n4) {
      var i4 = t3[n4];
      return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e3[n4] - r3 - r3);
    }, this).map(function(t4) {
      return this.getLineHeightFactor() * t4.length * n3 / i3 + r3 + r3;
    }, this).reduce(function(t4, e4) {
      return Math.max(t4, e4);
    }, 0);
  };
  e2.setTableHeaderRow = function(t3) {
    i2.call(this), this.internal.__cell__.tableHeaderRow = t3;
  }, e2.printHeaderRow = function(t3, e3) {
    if (i2.call(this), !this.internal.__cell__.tableHeaderRow)
      throw new Error("Property tableHeaderRow does not exist.");
    var r3;
    if (n2 = true, "function" == typeof this.internal.__cell__.headerFunction) {
      var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var c3 = [], u2 = 0; u2 < this.internal.__cell__.tableHeaderRow.length; u2 += 1) {
      r3 = this.internal.__cell__.tableHeaderRow[u2].clone(), e3 && (r3.y = this.internal.__cell__.margins.top || 0, c3.push(r3)), r3.lineNumber = t3;
      var h2 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, r3), this.setTextColor(h2);
    }
    c3.length > 0 && this.setTableHeaderRow(c3), this.setFont(void 0, "normal"), n2 = false;
  };
}(E.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], It = _t(kt), Ft2 = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ct = _t(Ft2);
function jt(t3) {
  var e2 = t3.family.replace(/"|'/g, "").toLowerCase(), r2 = function(t4) {
    return Pt[t4 = t4 || "normal"] ? t4 : "normal";
  }(t3.style), n2 = function(t4) {
    if (!t4)
      return 400;
    if ("number" == typeof t4)
      return t4 >= 100 && t4 <= 900 && t4 % 100 == 0 ? t4 : 400;
    if (/^\d00$/.test(t4))
      return parseInt(t4);
    switch (t4) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(t3.weight), i2 = function(t4) {
    return "number" == typeof It[t4 = t4 || "normal"] ? t4 : "normal";
  }(t3.stretch);
  return { family: e2, style: r2, weight: n2, stretch: i2, src: t3.src || [], ref: t3.ref || { name: e2, style: [i2, r2, n2].join(" ") } };
}
function Ot(t3, e2, r2, n2) {
  var i2;
  for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 += n2)
    if (t3[e2[i2]])
      return t3[e2[i2]];
  for (i2 = r2; i2 >= 0 && i2 < e2.length; i2 -= n2)
    if (t3[e2[i2]])
      return t3[e2[i2]];
}
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function Et2(t3) {
  return [t3.stretch, t3.style, t3.weight, t3.family].join(" ");
}
function qt(t3, e2, r2) {
  for (var n2 = (r2 = r2 || {}).defaultFontFamily || "times", i2 = Object.assign({}, Bt, r2.genericFontFamilies || {}), a2 = null, o2 = null, s2 = 0; s2 < e2.length; ++s2)
    if (i2[(a2 = jt(e2[s2])).family] && (a2.family = i2[a2.family]), t3.hasOwnProperty(a2.family)) {
      o2 = t3[a2.family];
      break;
    }
  if (!(o2 = o2 || t3[n2]))
    throw new Error("Could not find a font-family for the rule '" + Et2(a2) + "' and default family '" + n2 + "'.");
  if (o2 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    var r3 = It[t4], n3 = r3 <= It.normal ? -1 : 1, i3 = Ot(e3, kt, r3, n3);
    if (!i3)
      throw new Error("Could not find a matching font-stretch value for " + t4);
    return i3;
  }(a2.stretch, o2), o2 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    for (var r3 = Pt[t4], n3 = 0; n3 < r3.length; ++n3)
      if (e3[r3[n3]])
        return e3[r3[n3]];
    throw new Error("Could not find a matching font-style for " + t4);
  }(a2.style, o2), !(o2 = function(t4, e3) {
    if (e3[t4])
      return e3[t4];
    if (400 === t4 && e3[500])
      return e3[500];
    if (500 === t4 && e3[400])
      return e3[400];
    var r3 = Ct[t4], n3 = Ot(e3, Ft2, r3, t4 < 400 ? -1 : 1);
    if (!n3)
      throw new Error("Could not find a matching font-weight for value " + t4);
    return n3;
  }(a2.weight, o2)))
    throw new Error("Failed to resolve a font for the rule '" + Et2(a2) + "'.");
  return o2;
}
function Dt(t3) {
  return t3.trimLeft();
}
function Rt(t3, e2) {
  for (var r2 = 0; r2 < t3.length; ) {
    if (t3.charAt(r2) === e2)
      return [t3.substring(0, r2), t3.substring(r2 + 1)];
    r2 += 1;
  }
  return null;
}
function Tt(t3) {
  var e2 = t3.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return null === e2 ? null : [e2[0], t3.substring(e2[0].length)];
}
var Ut, zt2, Ht, Wt = ["times"];
!function(e2) {
  var r2, n2, i2, o2, s2, c2, u2, h2, l2, d2 = function(t3) {
    return t3 = t3 || {}, this.isStrokeTransparent = t3.isStrokeTransparent || false, this.strokeOpacity = t3.strokeOpacity || 1, this.strokeStyle = t3.strokeStyle || "#000000", this.fillStyle = t3.fillStyle || "#000000", this.isFillTransparent = t3.isFillTransparent || false, this.fillOpacity = t3.fillOpacity || 1, this.font = t3.font || "10px sans-serif", this.textBaseline = t3.textBaseline || "alphabetic", this.textAlign = t3.textAlign || "left", this.lineWidth = t3.lineWidth || 1, this.lineJoin = t3.lineJoin || "miter", this.lineCap = t3.lineCap || "butt", this.path = t3.path || [], this.transform = void 0 !== t3.transform ? t3.transform.clone() : new h2(), this.globalCompositeOperation = t3.globalCompositeOperation || "normal", this.globalAlpha = t3.globalAlpha || 1, this.clip_path = t3.clip_path || [], this.currentPoint = t3.currentPoint || new c2(), this.miterLimit = t3.miterLimit || 10, this.lastPoint = t3.lastPoint || new c2(), this.lineDashOffset = t3.lineDashOffset || 0, this.lineDash = t3.lineDash || [], this.margin = t3.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t3.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t3.ignoreClearRect || t3.ignoreClearRect, this;
  };
  e2.events.push(["initialized", function() {
    this.context2d = new p2(this), r2 = this.internal.f2, n2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, o2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, c2 = this.internal.Point, u2 = this.internal.Rectangle, h2 = this.internal.Matrix, l2 = new d2();
  }]);
  var p2 = function(t3) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e3 = t3;
    Object.defineProperty(this, "pdf", { get: function() {
      return e3;
    } });
    var r3 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return r3;
    }, set: function(t4) {
      r3 = Boolean(t4);
    } });
    var n3 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return n3;
    }, set: function(t4) {
      n3 = Boolean(t4);
    } });
    var i3 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i3;
    }, set: function(t4) {
      isNaN(t4) || (i3 = t4);
    } });
    var a2 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a2;
    }, set: function(t4) {
      isNaN(t4) || (a2 = t4);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return l2.margin;
    }, set: function(t4) {
      var e4;
      "number" == typeof t4 ? e4 = [t4, t4, t4, t4] : ((e4 = new Array(4))[0] = t4[0], e4[1] = t4.length >= 2 ? t4[1] : e4[0], e4[2] = t4.length >= 3 ? t4[2] : e4[0], e4[3] = t4.length >= 4 ? t4[3] : e4[1]), l2.margin = e4;
    } });
    var o3 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o3;
    }, set: function(t4) {
      o3 = t4;
    } });
    var s3 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s3;
    }, set: function(t4) {
      s3 = t4;
    } });
    var c3 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return c3;
    }, set: function(t4) {
      c3 = t4;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return l2;
    }, set: function(t4) {
      t4 instanceof d2 && (l2 = t4);
    } }), Object.defineProperty(this, "path", { get: function() {
      return l2.path;
    }, set: function(t4) {
      l2.path = t4;
    } });
    var u3 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return u3;
    }, set: function(t4) {
      u3 = t4;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t4) {
      var e4;
      e4 = g2(t4), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = 0 === e4.a, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t4) {
      var e4 = g2(t4);
      this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = 0 === e4.a, this.ctx.strokeOpacity = e4.a, 0 === e4.a ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t4) {
      -1 !== ["butt", "round", "square"].indexOf(t4) && (this.ctx.lineCap = t4, this.pdf.setLineCap(t4));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.lineWidth = t4, this.pdf.setLineWidth(t4));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t4) {
      -1 !== ["bevel", "round", "miter"].indexOf(t4) && (this.ctx.lineJoin = t4, this.pdf.setLineJoin(t4));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.miterLimit = t4, this.pdf.setMiterLimit(t4));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t4) {
      this.ctx.textBaseline = t4;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t4) {
      -1 !== ["right", "end", "center", "left", "start"].indexOf(t4) && (this.ctx.textAlign = t4);
    } });
    var h3 = null;
    function f2(t4, e4) {
      if (null === h3) {
        var r4 = function(t5) {
          var e5 = [];
          return Object.keys(t5).forEach(function(r5) {
            t5[r5].forEach(function(t6) {
              var n4 = null;
              switch (t6) {
                case "bold":
                  n4 = { family: r5, weight: "bold" };
                  break;
                case "italic":
                  n4 = { family: r5, style: "italic" };
                  break;
                case "bolditalic":
                  n4 = { family: r5, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  n4 = { family: r5 };
              }
              null !== n4 && (n4.ref = { name: r5, style: t6 }, e5.push(n4));
            });
          }), e5;
        }(t4.getFontList());
        h3 = function(t5) {
          for (var e5 = {}, r5 = 0; r5 < t5.length; ++r5) {
            var n4 = jt(t5[r5]), i4 = n4.family, a3 = n4.stretch, o4 = n4.style, s4 = n4.weight;
            e5[i4] = e5[i4] || {}, e5[i4][a3] = e5[i4][a3] || {}, e5[i4][a3][o4] = e5[i4][a3][o4] || {}, e5[i4][a3][o4][s4] = n4;
          }
          return e5;
        }(r4.concat(e4));
      }
      return h3;
    }
    var p3 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return p3;
    }, set: function(t4) {
      h3 = null, p3 = t4;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t4) {
      var e4;
      if (this.ctx.font = t4, null !== (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t4))) {
        var r4 = e4[1], n4 = (e4[2], e4[3]), i4 = e4[4], a3 = (e4[5], e4[6]), o4 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
        i4 = "px" === o4 ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : "em" === o4 ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
        var s4 = function(t5) {
          var e5, r5, n5 = [], i5 = t5.trim();
          if ("" === i5)
            return Wt;
          if (i5 in Mt)
            return [Mt[i5]];
          for (; "" !== i5; ) {
            switch (r5 = null, e5 = (i5 = Dt(i5)).charAt(0)) {
              case '"':
              case "'":
                r5 = Rt(i5.substring(1), e5);
                break;
              default:
                r5 = Tt(i5);
            }
            if (null === r5)
              return Wt;
            if (n5.push(r5[0]), "" !== (i5 = Dt(r5[1])) && "," !== i5.charAt(0))
              return Wt;
            i5 = i5.replace(/^,/, "");
          }
          return n5;
        }(a3);
        if (this.fontFaces) {
          var c4 = qt(f2(this.pdf, this.fontFaces), s4.map(function(t5) {
            return { family: t5, stretch: "normal", weight: n4, style: r4 };
          }));
          this.pdf.setFont(c4.ref.name, c4.ref.style);
        } else {
          var u4 = "";
          ("bold" === n4 || parseInt(n4, 10) >= 700 || "bold" === r4) && (u4 = "bold"), "italic" === r4 && (u4 += "italic"), 0 === u4.length && (u4 = "normal");
          for (var h4 = "", l3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, d3 = 0; d3 < s4.length; d3++) {
            if (void 0 !== this.pdf.internal.getFont(s4[d3], u4, { noFallback: true, disableWarning: true })) {
              h4 = s4[d3];
              break;
            }
            if ("bolditalic" === u4 && void 0 !== this.pdf.internal.getFont(s4[d3], "bold", { noFallback: true, disableWarning: true }))
              h4 = s4[d3], u4 = "bold";
            else if (void 0 !== this.pdf.internal.getFont(s4[d3], "normal", { noFallback: true, disableWarning: true })) {
              h4 = s4[d3], u4 = "normal";
              break;
            }
          }
          if ("" === h4) {
            for (var p4 = 0; p4 < s4.length; p4++)
              if (l3[s4[p4]]) {
                h4 = l3[s4[p4]];
                break;
              }
          }
          h4 = "" === h4 ? "Times" : h4, this.pdf.setFont(h4, u4);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t4) {
      this.ctx.globalCompositeOperation = t4;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t4) {
      this.ctx.globalAlpha = t4;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t4) {
      this.ctx.lineDashOffset = t4, T2.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t4) {
      this.ctx.lineDash = t4, T2.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t4) {
      this.ctx.ignoreClearRect = Boolean(t4);
    } });
  };
  p2.prototype.setLineDash = function(t3) {
    this.lineDash = t3;
  }, p2.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p2.prototype.fill = function() {
    A2.call(this, "fill", false);
  }, p2.prototype.stroke = function() {
    A2.call(this, "stroke", false);
  }, p2.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p2.prototype.moveTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
    this.path.push({ type: "mt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(t3, e3);
  }, p2.prototype.closePath = function() {
    var e3 = new c2(0, 0), r3 = 0;
    for (r3 = this.path.length - 1; -1 !== r3; r3--)
      if ("begin" === this.path[r3].type && "object" === _typeof$2(this.path[r3 + 1]) && "number" == typeof this.path[r3 + 1].x) {
        e3 = new c2(this.path[r3 + 1].x, this.path[r3 + 1].y);
        break;
      }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c2(e3.x, e3.y);
  }, p2.prototype.lineTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var r3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
    this.path.push({ type: "lt", x: r3.x, y: r3.y }), this.ctx.lastPoint = new c2(r3.x, r3.y);
  }, p2.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), A2.call(this, null, true);
  }, p2.prototype.quadraticCurveTo = function(t3, e3, r3, n3) {
    if (isNaN(r3) || isNaN(n3) || isNaN(t3) || isNaN(e3))
      throw a.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i3 = this.ctx.transform.applyToPoint(new c2(r3, n3)), o3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
    this.path.push({ type: "qct", x1: o3.x, y1: o3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new c2(i3.x, i3.y);
  }, p2.prototype.bezierCurveTo = function(t3, e3, r3, n3, i3, o3) {
    if (isNaN(i3) || isNaN(o3) || isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s3 = this.ctx.transform.applyToPoint(new c2(i3, o3)), u3 = this.ctx.transform.applyToPoint(new c2(t3, e3)), h3 = this.ctx.transform.applyToPoint(new c2(r3, n3));
    this.path.push({ type: "bct", x1: u3.x, y1: u3.y, x2: h3.x, y2: h3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new c2(s3.x, s3.y);
  }, p2.prototype.arc = function(t3, e3, r3, n3, i3, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3))
      throw a.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (o3 = Boolean(o3), !this.ctx.transform.isIdentity) {
      var s3 = this.ctx.transform.applyToPoint(new c2(t3, e3));
      t3 = s3.x, e3 = s3.y;
      var u3 = this.ctx.transform.applyToPoint(new c2(0, r3)), h3 = this.ctx.transform.applyToPoint(new c2(0, 0));
      r3 = Math.sqrt(Math.pow(u3.x - h3.x, 2) + Math.pow(u3.y - h3.y, 2));
    }
    Math.abs(i3 - n3) >= 2 * Math.PI && (n3 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t3, y: e3, radius: r3, startAngle: n3, endAngle: i3, counterclockwise: o3 });
  }, p2.prototype.arcTo = function(t3, e3, r3, n3, i3) {
    throw new Error("arcTo not implemented.");
  }, p2.prototype.rect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3 + r3, e3 + n3), this.lineTo(t3, e3 + n3), this.lineTo(t3, e3), this.lineTo(t3 + r3, e3), this.lineTo(t3, e3);
  }, p2.prototype.fillRect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m2.call(this)) {
      var i3 = {};
      "butt" !== this.lineCap && (i3.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t3, e3, r3, n3), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
    }
  }, p2.prototype.strokeRect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v2.call(this) || (this.beginPath(), this.rect(t3, e3, r3, n3), this.stroke());
  }, p2.prototype.clearRect = function(t3, e3, r3, n3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3))
      throw a.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t3, e3, r3, n3));
  }, p2.prototype.save = function(t3) {
    t3 = "boolean" != typeof t3 || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)
      this.pdf.setPage(r3 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e3), t3) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var n3 = new d2(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = n3;
    }
  }, p2.prototype.restore = function(t3) {
    t3 = "boolean" != typeof t3 || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, r3 = 0; r3 < this.pdf.internal.getNumberOfPages(); r3++)
      this.pdf.setPage(r3 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e3), t3 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p2.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g2 = function(t3) {
    var e3, r3, n3, i3;
    if (true === t3.isCanvasGradient && (t3 = t3.getColor()), !t3)
      return { r: 0, g: 0, b: 0, a: 0, style: t3 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t3))
      e3 = 0, r3 = 0, n3 = 0, i3 = 0;
    else {
      var a2 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t3);
      if (null !== a2)
        e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = 1;
      else if (null !== (a2 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t3)))
        e3 = parseInt(a2[1]), r3 = parseInt(a2[2]), n3 = parseInt(a2[3]), i3 = parseFloat(a2[4]);
      else {
        if (i3 = 1, "string" == typeof t3 && "#" !== t3.charAt(0)) {
          var o3 = new f(t3);
          t3 = o3.ok ? o3.toHex() : "#000000";
        }
        4 === t3.length ? (e3 = t3.substring(1, 2), e3 += e3, r3 = t3.substring(2, 3), r3 += r3, n3 = t3.substring(3, 4), n3 += n3) : (e3 = t3.substring(1, 3), r3 = t3.substring(3, 5), n3 = t3.substring(5, 7)), e3 = parseInt(e3, 16), r3 = parseInt(r3, 16), n3 = parseInt(n3, 16);
      }
    }
    return { r: e3, g: r3, b: n3, a: i3, style: t3 };
  }, m2 = function() {
    return this.ctx.isFillTransparent || 0 == this.globalAlpha;
  }, v2 = function() {
    return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
  };
  p2.prototype.fillText = function(t3, e3, r3, n3) {
    if (isNaN(e3) || isNaN(r3) || "string" != typeof t3)
      throw a.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (n3 = isNaN(n3) ? void 0 : n3, !m2.call(this)) {
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t3, x: e3, y: r3, scale: o3, angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.strokeText = function(t3, e3, r3, n3) {
    if (isNaN(e3) || isNaN(r3) || "string" != typeof t3)
      throw a.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v2.call(this)) {
      n3 = isNaN(n3) ? void 0 : n3;
      var i3 = q2(this.ctx.transform.rotation), o3 = this.ctx.transform.scaleX;
      C2.call(this, { text: t3, x: e3, y: r3, scale: o3, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: n3 });
    }
  }, p2.prototype.measureText = function(t3) {
    if ("string" != typeof t3)
      throw a.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e3 = this.pdf, r3 = this.pdf.internal.scaleFactor, n3 = e3.internal.getFontSize(), i3 = e3.getStringUnitWidth(t3) * n3 / e3.internal.scaleFactor, o3 = function(t4) {
      var e4 = (t4 = t4 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e4;
      } }), this;
    };
    return new o3({ width: i3 *= Math.round(96 * r3 / 72 * 1e4) / 1e4 });
  }, p2.prototype.scale = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var r3 = new h2(t3, 0, 0, e3, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(r3);
  }, p2.prototype.rotate = function(t3) {
    if (isNaN(t3))
      throw a.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e3 = new h2(Math.cos(t3), Math.sin(t3), -Math.sin(t3), Math.cos(t3), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e3);
  }, p2.prototype.translate = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3))
      throw a.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var r3 = new h2(1, 0, 0, 1, t3, e3);
    this.ctx.transform = this.ctx.transform.multiply(r3);
  }, p2.prototype.transform = function(t3, e3, r3, n3, i3, o3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(r3) || isNaN(n3) || isNaN(i3) || isNaN(o3))
      throw a.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s3 = new h2(t3, e3, r3, n3, i3, o3);
    this.ctx.transform = this.ctx.transform.multiply(s3);
  }, p2.prototype.setTransform = function(t3, e3, r3, n3, i3, a2) {
    t3 = isNaN(t3) ? 1 : t3, e3 = isNaN(e3) ? 0 : e3, r3 = isNaN(r3) ? 0 : r3, n3 = isNaN(n3) ? 1 : n3, i3 = isNaN(i3) ? 0 : i3, a2 = isNaN(a2) ? 0 : a2, this.ctx.transform = new h2(t3, e3, r3, n3, i3, a2);
  };
  var b2 = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p2.prototype.drawImage = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {
    var l3 = this.pdf.getImageProperties(t3), f2 = 1, d3 = 1, p3 = 1, g3 = 1;
    void 0 !== n3 && void 0 !== s3 && (p3 = s3 / n3, g3 = c3 / i3, f2 = l3.width / n3 * s3 / n3, d3 = l3.height / i3 * c3 / i3), void 0 === a2 && (a2 = e3, o3 = r3, e3 = 0, r3 = 0), void 0 !== n3 && void 0 === s3 && (s3 = n3, c3 = i3), void 0 === n3 && void 0 === s3 && (s3 = l3.width, c3 = l3.height);
    for (var m3, v3 = this.ctx.transform.decompose(), w3 = q2(v3.rotate.shx), A3 = new h2(), S3 = (A3 = (A3 = (A3 = A3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new u2(a2 - e3 * p3, o3 - r3 * g3, n3 * f2, i3 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1)
      -1 === P3.indexOf(_3[k3]) && P3.push(_3[k3]);
    if (L2(P3), this.autoPaging)
      for (var I3 = P3[0], F3 = P3[P3.length - 1], C3 = I3; C3 < F3 + 1; C3++) {
        this.pdf.setPage(C3);
        var j3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = 1 === C3 ? this.posY + this.margin[0] : this.margin[0], B4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], E3 = 1 === C3 ? 0 : B4 + (C3 - 2) * M3;
        if (0 !== this.ctx.clip_path.length) {
          var D3 = this.path;
          m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset), x2.call(this, "fill", true), this.path = D3;
        }
        var R3 = JSON.parse(JSON.stringify(S3));
        R3 = N2([R3], this.posX + this.margin[3], -E3 + O3 + this.ctx.prevPageLastElemOffset)[0];
        var T3 = (C3 > I3 || C3 < F3) && b2.call(this);
        T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], j3, M3, null).clip().discardPath()), this.pdf.addImage(t3, "JPEG", R3.x, R3.y, R3.w, R3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
      }
    else
      this.pdf.addImage(t3, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y2 = function(t3, e3, r3) {
    var n3 = [];
    e3 = e3 || this.pdf.internal.pageSize.width, r3 = r3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i3 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t3.type) {
      default:
      case "mt":
      case "lt":
        n3.push(Math.floor((t3.y + i3) / r3) + 1);
        break;
      case "arc":
        n3.push(Math.floor((t3.y + i3 - t3.radius) / r3) + 1), n3.push(Math.floor((t3.y + i3 + t3.radius) / r3) + 1);
        break;
      case "qct":
        var a2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x, t3.y);
        n3.push(Math.floor((a2.y + i3) / r3) + 1), n3.push(Math.floor((a2.y + a2.h + i3) / r3) + 1);
        break;
      case "bct":
        var o3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);
        n3.push(Math.floor((o3.y + i3) / r3) + 1), n3.push(Math.floor((o3.y + o3.h + i3) / r3) + 1);
        break;
      case "rect":
        n3.push(Math.floor((t3.y + i3) / r3) + 1), n3.push(Math.floor((t3.y + t3.h + i3) / r3) + 1);
    }
    for (var s3 = 0; s3 < n3.length; s3 += 1)
      for (; this.pdf.internal.getNumberOfPages() < n3[s3]; )
        w2.call(this);
    return n3;
  }, w2 = function() {
    var t3 = this.fillStyle, e3 = this.strokeStyle, r3 = this.font, n3 = this.lineCap, i3 = this.lineWidth, a2 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t3, this.strokeStyle = e3, this.font = r3, this.lineCap = n3, this.lineWidth = i3, this.lineJoin = a2;
  }, N2 = function(t3, e3, r3) {
    for (var n3 = 0; n3 < t3.length; n3++)
      switch (t3[n3].type) {
        case "bct":
          t3[n3].x2 += e3, t3[n3].y2 += r3;
        case "qct":
          t3[n3].x1 += e3, t3[n3].y1 += r3;
        case "mt":
        case "lt":
        case "arc":
        default:
          t3[n3].x += e3, t3[n3].y += r3;
      }
    return t3;
  }, L2 = function(t3) {
    return t3.sort(function(t4, e3) {
      return t4 - e3;
    });
  }, A2 = function(t3, e3) {
    for (var r3, n3, i3 = this.fillStyle, a2 = this.strokeStyle, o3 = this.lineCap, s3 = this.lineWidth, c3 = Math.abs(s3 * this.ctx.transform.scaleX), u3 = this.lineJoin, h3 = JSON.parse(JSON.stringify(this.path)), l3 = JSON.parse(JSON.stringify(this.path)), f2 = [], d3 = 0; d3 < l3.length; d3++)
      if (void 0 !== l3[d3].x)
        for (var p3 = y2.call(this, l3[d3]), g3 = 0; g3 < p3.length; g3 += 1)
          -1 === f2.indexOf(p3[g3]) && f2.push(p3[g3]);
    for (var m3 = 0; m3 < f2.length; m3++)
      for (; this.pdf.internal.getNumberOfPages() < f2[m3]; )
        w2.call(this);
    if (L2(f2), this.autoPaging)
      for (var v3 = f2[0], A3 = f2[f2.length - 1], S3 = v3; S3 < A3 + 1; S3++) {
        this.pdf.setPage(S3), this.fillStyle = i3, this.strokeStyle = a2, this.lineCap = o3, this.lineWidth = c3, this.lineJoin = u3;
        var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], I3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], F3 = 1 === S3 ? 0 : k3 + (S3 - 2) * I3;
        if (0 !== this.ctx.clip_path.length) {
          var C3 = this.path;
          r3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(r3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), x2.call(this, t3, true), this.path = C3;
        }
        if (n3 = JSON.parse(JSON.stringify(h3)), this.path = N2(n3, this.posX + this.margin[3], -F3 + P3 + this.ctx.prevPageLastElemOffset), false === e3 || 0 === S3) {
          var j3 = (S3 > v3 || S3 < A3) && b2.call(this);
          j3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, I3, null).clip().discardPath()), x2.call(this, t3, e3), j3 && this.pdf.restoreGraphicsState();
        }
        this.lineWidth = s3;
      }
    else
      this.lineWidth = c3, x2.call(this, t3, e3), this.lineWidth = s3;
    this.path = h3;
  }, x2 = function(t3, e3) {
    if (("stroke" !== t3 || e3 || !v2.call(this)) && ("stroke" === t3 || e3 || !m2.call(this))) {
      for (var r3, n3, i3 = [], a2 = this.path, o3 = 0; o3 < a2.length; o3++) {
        var s3 = a2[o3];
        switch (s3.type) {
          case "begin":
            i3.push({ begin: true });
            break;
          case "close":
            i3.push({ close: true });
            break;
          case "mt":
            i3.push({ start: s3, deltas: [], abs: [] });
            break;
          case "lt":
            var c3 = i3.length;
            if (a2[o3 - 1] && !isNaN(a2[o3 - 1].x) && (r3 = [s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], c3 > 0)) {
              for (; c3 >= 0; c3--)
                if (true !== i3[c3 - 1].close && true !== i3[c3 - 1].begin) {
                  i3[c3 - 1].deltas.push(r3), i3[c3 - 1].abs.push(s3);
                  break;
                }
            }
            break;
          case "bct":
            r3 = [s3.x1 - a2[o3 - 1].x, s3.y1 - a2[o3 - 1].y, s3.x2 - a2[o3 - 1].x, s3.y2 - a2[o3 - 1].y, s3.x - a2[o3 - 1].x, s3.y - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
            break;
          case "qct":
            var u3 = a2[o3 - 1].x + 2 / 3 * (s3.x1 - a2[o3 - 1].x), h3 = a2[o3 - 1].y + 2 / 3 * (s3.y1 - a2[o3 - 1].y), l3 = s3.x + 2 / 3 * (s3.x1 - s3.x), f2 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p3 = s3.y;
            r3 = [u3 - a2[o3 - 1].x, h3 - a2[o3 - 1].y, l3 - a2[o3 - 1].x, f2 - a2[o3 - 1].y, d3 - a2[o3 - 1].x, p3 - a2[o3 - 1].y], i3[i3.length - 1].deltas.push(r3);
            break;
          case "arc":
            i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
        }
      }
      n3 = e3 ? null : "stroke" === t3 ? "stroke" : "fill";
      for (var g3 = false, b3 = 0; b3 < i3.length; b3++)
        if (i3[b3].arc)
          for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
            var N3 = y3[w3];
            "arc" === N3.type ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e3, !g3) : j2.call(this, N3.x, N3.y), g3 = true;
          }
        else if (true === i3[b3].close)
          this.pdf.internal.out("h"), g3 = false;
        else if (true !== i3[b3].begin) {
          var L3 = i3[b3].start.x, A3 = i3[b3].start.y;
          O2.call(this, i3[b3].deltas, L3, A3), g3 = true;
        }
      n3 && k2.call(this, n3), e3 && I2.call(this);
    }
  }, S2 = function(t3) {
    var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, r3 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t3 - r3;
      case "top":
        return t3 + e3 - r3;
      case "hanging":
        return t3 + e3 - 2 * r3;
      case "middle":
        return t3 + e3 / 2 - r3;
      case "ideographic":
        return t3;
      case "alphabetic":
      default:
        return t3;
    }
  }, _2 = function(t3) {
    return t3 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p2.prototype.createLinearGradient = function() {
    var t3 = function() {
    };
    return t3.colorStops = [], t3.addColorStop = function(t4, e3) {
      this.colorStops.push([t4, e3]);
    }, t3.getColor = function() {
      return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
    }, t3.isCanvasGradient = true, t3;
  }, p2.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p2.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = function(t3, e3, r3, n3, i3, a2, o3, s3, c3) {
    for (var u3 = M2.call(this, r3, n3, i3, a2), h3 = 0; h3 < u3.length; h3++) {
      var l3 = u3[h3];
      0 === h3 && (c3 ? F2.call(this, l3.x1 + t3, l3.y1 + e3) : j2.call(this, l3.x1 + t3, l3.y1 + e3)), B3.call(this, t3, e3, l3.x2, l3.y2, l3.x3, l3.y3, l3.x4, l3.y4);
    }
    s3 ? I2.call(this) : k2.call(this, o3);
  }, k2 = function(t3) {
    switch (t3) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, I2 = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, F2 = function(t3, e3) {
    this.pdf.internal.out(n2(t3) + " " + i2(e3) + " m");
  }, C2 = function(t3) {
    var e3;
    switch (t3.align) {
      case "right":
      case "end":
        e3 = "right";
        break;
      case "center":
        e3 = "center";
        break;
      case "left":
      case "start":
      default:
        e3 = "left";
    }
    var r3 = this.pdf.getTextDimensions(t3.text), n3 = S2.call(this, t3.y), i3 = _2.call(this, n3) - r3.h, a2 = this.ctx.transform.applyToPoint(new c2(t3.x, n3)), o3 = this.ctx.transform.decompose(), s3 = new h2();
    s3 = (s3 = (s3 = s3.multiply(o3.translate)).multiply(o3.skew)).multiply(o3.scale);
    for (var l3, f2, d3, p3 = this.ctx.transform.applyToRectangle(new u2(t3.x, n3, r3.w, r3.h)), g3 = s3.applyToRectangle(new u2(t3.x, i3, r3.w, r3.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1)
      -1 === v3.indexOf(m3[w3]) && v3.push(m3[w3]);
    if (L2(v3), this.autoPaging)
      for (var A3 = v3[0], P3 = v3[v3.length - 1], k3 = A3; k3 < P3 + 1; k3++) {
        this.pdf.setPage(k3);
        var I3 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], F3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], C3 = this.pdf.internal.pageSize.height - this.margin[2], j3 = C3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B4 = O3 - this.margin[3], M3 = 1 === k3 ? 0 : F3 + (k3 - 2) * j3;
        if (0 !== this.ctx.clip_path.length) {
          var E3 = this.path;
          l3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(l3, this.posX + this.margin[3], -1 * M3 + I3), x2.call(this, "fill", true), this.path = E3;
        }
        var q3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0];
        t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale);
        var D3 = "text" !== this.autoPaging;
        if (D3 || q3.y + q3.h <= C3) {
          if (D3 || q3.y >= I3 && q3.x <= O3) {
            var R3 = D3 ? t3.text : this.pdf.splitTextToSize(t3.text, t3.maxWidth || O3 - q3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M3 + I3 + this.ctx.prevPageLastElemOffset)[0], U2 = D3 && (k3 > A3 || k3 < P3) && b2.call(this);
            U2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B4, j3, null).clip().discardPath()), this.pdf.text(R3, T3.x, T3.y, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode }), U2 && this.pdf.restoreGraphicsState();
          }
        } else
          q3.y < C3 && (this.ctx.prevPageLastElemOffset += C3 - q3.y);
        t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
      }
    else
      t3.scale >= 0.01 && (f2 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f2 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale), this.pdf.text(t3.text, a2.x + this.posX, a2.y + this.posY, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode, maxWidth: t3.maxWidth }), t3.scale >= 0.01 && (this.pdf.setFontSize(f2), this.lineWidth = d3);
  }, j2 = function(t3, e3, r3, a2) {
    r3 = r3 || 0, a2 = a2 || 0, this.pdf.internal.out(n2(t3 + r3) + " " + i2(e3 + a2) + " l");
  }, O2 = function(t3, e3, r3) {
    return this.pdf.lines(t3, e3, r3, null, null);
  }, B3 = function(t3, e3, n3, i3, a2, c3, u3, h3) {
    this.pdf.internal.out([r2(o2(n3 + t3)), r2(s2(i3 + e3)), r2(o2(a2 + t3)), r2(s2(c3 + e3)), r2(o2(u3 + t3)), r2(s2(h3 + e3)), "c"].join(" "));
  }, M2 = function(t3, e3, r3, n3) {
    for (var i3 = 2 * Math.PI, a2 = Math.PI / 2; e3 > r3; )
      e3 -= i3;
    var o3 = Math.abs(r3 - e3);
    o3 < i3 && n3 && (o3 = i3 - o3);
    for (var s3 = [], c3 = n3 ? -1 : 1, u3 = e3; o3 > 1e-5; ) {
      var h3 = u3 + c3 * Math.min(o3, a2);
      s3.push(E2.call(this, t3, u3, h3)), o3 -= Math.abs(h3 - u3), u3 = h3;
    }
    return s3;
  }, E2 = function(t3, e3, r3) {
    var n3 = (r3 - e3) / 2, i3 = t3 * Math.cos(n3), a2 = t3 * Math.sin(n3), o3 = i3, s3 = -a2, c3 = o3 * o3 + s3 * s3, u3 = c3 + o3 * i3 + s3 * a2, h3 = 4 / 3 * (Math.sqrt(2 * c3 * u3) - u3) / (o3 * a2 - s3 * i3), l3 = o3 - h3 * s3, f2 = s3 + h3 * o3, d3 = l3, p3 = -f2, g3 = n3 + e3, m3 = Math.cos(g3), v3 = Math.sin(g3);
    return { x1: t3 * Math.cos(e3), y1: t3 * Math.sin(e3), x2: l3 * m3 - f2 * v3, y2: l3 * v3 + f2 * m3, x3: d3 * m3 - p3 * v3, y3: d3 * v3 + p3 * m3, x4: t3 * Math.cos(r3), y4: t3 * Math.sin(r3) };
  }, q2 = function(t3) {
    return 180 * t3 / Math.PI;
  }, D2 = function(t3, e3, r3, n3, i3, a2) {
    var o3 = t3 + 0.5 * (r3 - t3), s3 = e3 + 0.5 * (n3 - e3), c3 = i3 + 0.5 * (r3 - i3), h3 = a2 + 0.5 * (n3 - a2), l3 = Math.min(t3, i3, o3, c3), f2 = Math.max(t3, i3, o3, c3), d3 = Math.min(e3, a2, s3, h3), p3 = Math.max(e3, a2, s3, h3);
    return new u2(l3, d3, f2 - l3, p3 - d3);
  }, R2 = function(t3, e3, r3, n3, i3, a2, o3, s3) {
    var c3, h3, l3, f2, d3, p3, g3, m3, v3, b3, y3, w3, N3, L3, A3 = r3 - t3, x3 = n3 - e3, S3 = i3 - r3, _3 = a2 - n3, P3 = o3 - i3, k3 = s3 - a2;
    for (h3 = 0; h3 < 41; h3++)
      v3 = (g3 = (l3 = t3 + (c3 = h3 / 40) * A3) + c3 * ((d3 = r3 + c3 * S3) - l3)) + c3 * (d3 + c3 * (i3 + c3 * P3 - d3) - g3), b3 = (m3 = (f2 = e3 + c3 * x3) + c3 * ((p3 = n3 + c3 * _3) - f2)) + c3 * (p3 + c3 * (a2 + c3 * k3 - p3) - m3), 0 == h3 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
    return new u2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
  }, T2 = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t3, e3, r3 = (t3 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t3, lineDashOffset: e3 }));
      this.prevLineDash !== r3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = r3);
    }
  };
}(E.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var r2 = function(t4) {
    var e2, r3, n3, i3, a3, o2, s2, c2, u2, h2;
    for (r3 = [], n3 = 0, i3 = (t4 += e2 = "\0\0\0\0".slice(t4.length % 4 || 4)).length; i3 > n3; n3 += 4)
      0 !== (a3 = (t4.charCodeAt(n3) << 24) + (t4.charCodeAt(n3 + 1) << 16) + (t4.charCodeAt(n3 + 2) << 8) + t4.charCodeAt(n3 + 3)) ? (o2 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (h2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, r3.push(o2 + 33, s2 + 33, c2 + 33, u2 + 33, h2 + 33)) : r3.push(122);
    return function(t5, e3) {
      for (var r4 = e3; r4 > 0; r4--)
        t5.pop();
    }(r3, e2.length), String.fromCharCode.apply(String, r3) + "~>";
  }, n2 = function(t4) {
    var e2, r3, n3, i3, a3, o2 = String, s2 = "length", c2 = 255, u2 = "charCodeAt", h2 = "slice", l2 = "replace";
    for (t4[h2](-2), t4 = t4[h2](0, -2)[l2](/\s/g, "")[l2]("z", "!!!!!"), n3 = [], i3 = 0, a3 = (t4 += e2 = "uuuuu"[h2](t4[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5)
      r3 = 52200625 * (t4[u2](i3) - 33) + 614125 * (t4[u2](i3 + 1) - 33) + 7225 * (t4[u2](i3 + 2) - 33) + 85 * (t4[u2](i3 + 3) - 33) + (t4[u2](i3 + 4) - 33), n3.push(c2 & r3 >> 24, c2 & r3 >> 16, c2 & r3 >> 8, c2 & r3);
    return function(t5, e3) {
      for (var r4 = e3; r4 > 0; r4--)
        t5.pop();
    }(n3, e2[s2]), o2.fromCharCode.apply(o2, n3);
  }, i2 = function(t4) {
    var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if (-1 !== (t4 = t4.replace(/\s/g, "")).indexOf(">") && (t4 = t4.substr(0, t4.indexOf(">"))), t4.length % 2 && (t4 += "0"), false === e2.test(t4))
      return "";
    for (var r3 = "", n3 = 0; n3 < t4.length; n3 += 2)
      r3 += String.fromCharCode("0x" + (t4[n3] + t4[n3 + 1]));
    return r3;
  }, a2 = function(t4) {
    for (var r3 = new Uint8Array(t4.length), n3 = t4.length; n3--; )
      r3[n3] = t4.charCodeAt(n3);
    return t4 = (r3 = zlibSync(r3)).reduce(function(t5, e2) {
      return t5 + String.fromCharCode(e2);
    }, "");
  };
  t3.processDataByFilters = function(t4, e2) {
    var o2 = 0, s2 = t4 || "", c2 = [];
    for ("string" == typeof (e2 = e2 || []) && (e2 = [e2]), o2 = 0; o2 < e2.length; o2 += 1)
      switch (e2[o2]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          s2 = n2(s2), c2.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          s2 = r2(s2), c2.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          s2 = i2(s2), c2.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          s2 = s2.split("").map(function(t5) {
            return ("0" + t5.charCodeAt().toString(16)).slice(-2);
          }).join("") + ">", c2.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          s2 = a2(s2), c2.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + e2[o2] + '" is not implemented');
      }
    return { data: s2, reverseChain: c2.reverse().join(" ") };
  };
}(E.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  t3.loadFile = function(t4, e2, r2) {
    return function(t5, e3, r3) {
      e3 = false !== e3, r3 = "function" == typeof r3 ? r3 : function() {
      };
      var n2 = void 0;
      try {
        n2 = function(t6, e4, r4) {
          var n3 = new XMLHttpRequest(), i2 = 0, a2 = function(t7) {
            var e5 = t7.length, r5 = [], n4 = String.fromCharCode;
            for (i2 = 0; i2 < e5; i2 += 1)
              r5.push(n4(255 & t7.charCodeAt(i2)));
            return r5.join("");
          };
          if (n3.open("GET", t6, !e4), n3.overrideMimeType("text/plain; charset=x-user-defined"), false === e4 && (n3.onload = function() {
            200 === n3.status ? r4(a2(this.responseText)) : r4(void 0);
          }), n3.send(null), e4 && 200 === n3.status)
            return a2(n3.responseText);
        }(t5, e3, r3);
      } catch (t6) {
      }
      return n2;
    }(t4, e2, r2);
  }, t3.loadImageFile = t3.loadFile;
}(E.API), function(e2) {
  function r2() {
    return (n.html2canvas ? Promise.resolve(n.html2canvas) : __vitePreload(() => Promise.resolve().then(() => html2canvas_esm), true ? void 0 : void 0, import.meta.url)).catch(function(t3) {
      return Promise.reject(new Error("Could not load html2canvas: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  function i2() {
    return (n.DOMPurify ? Promise.resolve(n.DOMPurify) : __vitePreload(() => import("./purify.es-eef49b8a.js"), true ? [] : void 0, import.meta.url)).catch(function(t3) {
      return Promise.reject(new Error("Could not load dompurify: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  var a2 = function(e3) {
    var r3 = _typeof$2(e3);
    return "undefined" === r3 ? "undefined" : "string" === r3 || e3 instanceof String ? "string" : "number" === r3 || e3 instanceof Number ? "number" : "function" === r3 || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && 1 === e3.nodeType ? "element" : "object" === r3 ? "object" : "unknown";
  }, o2 = function(t3, e3) {
    var r3 = document.createElement(t3);
    for (var n2 in e3.className && (r3.className = e3.className), e3.innerHTML && e3.dompurify && (r3.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style)
      r3.style[n2] = e3.style[n2];
    return r3;
  }, s2 = function t3(e3) {
    var r3 = Object.assign(t3.convert(Promise.resolve()), JSON.parse(JSON.stringify(t3.template))), n2 = t3.convert(Promise.resolve(), r3);
    return n2 = (n2 = n2.setProgress(1, t3, 1, [t3])).set(e3);
  };
  (s2.prototype = Object.create(Promise.prototype)).constructor = s2, s2.convert = function(t3, e3) {
    return t3.__proto__ = e3 || s2.prototype, t3;
  }, s2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s2.prototype.from = function(t3, e3) {
    return this.then(function() {
      switch (e3 = e3 || function(t4) {
        switch (a2(t4)) {
          case "string":
            return "string";
          case "element":
            return "canvas" === t4.nodeName.toLowerCase() ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(t3)) {
        case "string":
          return this.then(i2).then(function(e4) {
            return this.set({ src: o2("div", { innerHTML: t3, dompurify: e4 }) });
          });
        case "element":
          return this.set({ src: t3 });
        case "canvas":
          return this.set({ canvas: t3 });
        case "img":
          return this.set({ img: t3 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s2.prototype.to = function(t3) {
    switch (t3) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s2.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t3 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e3 = function t4(e4, r3) {
        for (var n2 = 3 === e4.nodeType ? document.createTextNode(e4.nodeValue) : e4.cloneNode(false), i3 = e4.firstChild; i3; i3 = i3.nextSibling)
          true !== r3 && 1 === i3.nodeType && "SCRIPT" === i3.nodeName || n2.appendChild(t4(i3, r3));
        return 1 === e4.nodeType && ("CANVAS" === e4.nodeName ? (n2.width = e4.width, n2.height = e4.height, n2.getContext("2d").drawImage(e4, 0, 0)) : "TEXTAREA" !== e4.nodeName && "SELECT" !== e4.nodeName || (n2.value = e4.value), n2.addEventListener("load", function() {
          n2.scrollTop = e4.scrollTop, n2.scrollLeft = e4.scrollLeft;
        }, true)), n2;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      "BODY" === e3.tagName && (t3.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t3 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s2.prototype.toCanvas = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(r2).then(function(t4) {
      var e3 = Object.assign({}, this.opt.html2canvas);
      return delete e3.onrendered, t4(this.prop.container, e3);
    }).then(function(t4) {
      (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toContext2d = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(r2).then(function(t4) {
      var e3 = this.opt.jsPDF, r3 = this.opt.fontFaces, n2 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i3 = Object.assign({ async: true, allowTaint: true, scale: n2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i3.onrendered, e3.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = r3, r3)
        for (var a3 = 0; a3 < r3.length; ++a3) {
          var o3 = r3[a3], s3 = o3.src.find(function(t5) {
            return "truetype" === t5.format;
          });
          s3 && e3.addFont(s3.url, o3.ref.name, o3.ref.style);
        }
      return i3.windowHeight = i3.windowHeight || 0, i3.windowHeight = 0 == i3.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i3.windowHeight, e3.context2d.save(true), t4(this.prop.container, i3);
    }).then(function(t4) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, s2.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t3 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t3;
    });
  }, s2.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s2.prototype.output = function(t3, e3, r3) {
    return "img" === (r3 = r3 || "pdf").toLowerCase() || "image" === r3.toLowerCase() ? this.outputImg(t3, e3) : this.outputPdf(t3, e3);
  }, s2.prototype.outputPdf = function(t3, e3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t3, e3);
    });
  }, s2.prototype.outputImg = function(t3) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t3) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t3 + '" is not supported.';
      }
    });
  }, s2.prototype.save = function(t3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t3 ? { filename: t3 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s2.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s2.prototype.set = function(t3) {
    if ("object" !== a2(t3))
      return this;
    var e3 = Object.keys(t3 || {}).map(function(e4) {
      if (e4 in s2.template.prop)
        return function() {
          this.prop[e4] = t3[e4];
        };
      switch (e4) {
        case "margin":
          return this.setMargin.bind(this, t3.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t3.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t3.pageSize);
        default:
          return function() {
            this.opt[e4] = t3[e4];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e3);
    });
  }, s2.prototype.get = function(t3, e3) {
    return this.then(function() {
      var r3 = t3 in s2.template.prop ? this.prop[t3] : this.opt[t3];
      return e3 ? e3(r3) : r3;
    });
  }, s2.prototype.setMargin = function(t3) {
    return this.then(function() {
      switch (a2(t3)) {
        case "number":
          t3 = [t3, t3, t3, t3];
        case "array":
          if (2 === t3.length && (t3 = [t3[0], t3[1], t3[0], t3[1]]), 4 === t3.length)
            break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t3;
    }).then(this.setPageSize);
  }, s2.prototype.setPageSize = function(t3) {
    function e3(t4, e4) {
      return Math.floor(t4 * e4 / 72 * 96);
    }
    return this.then(function() {
      (t3 = t3 || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t3.inner = { width: t3.width - this.opt.margin[1] - this.opt.margin[3], height: t3.height - this.opt.margin[0] - this.opt.margin[2] }, t3.inner.px = { width: e3(t3.inner.width, t3.k), height: e3(t3.inner.height, t3.k) }, t3.inner.ratio = t3.inner.height / t3.inner.width), this.prop.pageSize = t3;
    });
  }, s2.prototype.setProgress = function(t3, e3, r3, n2) {
    return null != t3 && (this.progress.val = t3), null != e3 && (this.progress.state = e3), null != r3 && (this.progress.n = r3), null != n2 && (this.progress.stack = n2), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s2.prototype.updateProgress = function(t3, e3, r3, n2) {
    return this.setProgress(t3 ? this.progress.val + t3 : null, e3 || null, r3 ? this.progress.n + r3 : null, n2 ? this.progress.stack.concat(n2) : null);
  }, s2.prototype.then = function(t3, e3) {
    var r3 = this;
    return this.thenCore(t3, e3, function(t4, e4) {
      return r3.updateProgress(null, null, 1, [t4]), Promise.prototype.then.call(this, function(e5) {
        return r3.updateProgress(null, t4), e5;
      }).then(t4, e4).then(function(t5) {
        return r3.updateProgress(1), t5;
      });
    });
  }, s2.prototype.thenCore = function(t3, e3, r3) {
    r3 = r3 || Promise.prototype.then;
    t3 && (t3 = t3.bind(this)), e3 && (e3 = e3.bind(this));
    var n2 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? this : s2.convert(Object.assign({}, this), Promise.prototype), i3 = r3.call(n2, t3, e3);
    return s2.convert(i3, this.__proto__);
  }, s2.prototype.thenExternal = function(t3, e3) {
    return Promise.prototype.then.call(this, t3, e3);
  }, s2.prototype.thenList = function(t3) {
    var e3 = this;
    return t3.forEach(function(t4) {
      e3 = e3.thenCore(t4);
    }), e3;
  }, s2.prototype.catch = function(t3) {
    t3 && (t3 = t3.bind(this));
    var e3 = Promise.prototype.catch.call(this, t3);
    return s2.convert(e3, this);
  }, s2.prototype.catchExternal = function(t3) {
    return Promise.prototype.catch.call(this, t3);
  }, s2.prototype.error = function(t3) {
    return this.then(function() {
      throw new Error(t3);
    });
  }, s2.prototype.using = s2.prototype.set, s2.prototype.saveAs = s2.prototype.save, s2.prototype.export = s2.prototype.output, s2.prototype.run = s2.prototype.then, E.getPageSize = function(e3, r3, n2) {
    if ("object" === _typeof$2(e3)) {
      var i3 = e3;
      e3 = i3.orientation, r3 = i3.unit || r3, n2 = i3.format || n2;
    }
    r3 = r3 || "mm", n2 = n2 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
    var a3, o3 = ("" + n2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (r3) {
      case "pt":
        a3 = 1;
        break;
      case "mm":
        a3 = 72 / 25.4;
        break;
      case "cm":
        a3 = 72 / 2.54;
        break;
      case "in":
        a3 = 72;
        break;
      case "px":
        a3 = 0.75;
        break;
      case "pc":
      case "em":
        a3 = 12;
        break;
      case "ex":
        a3 = 6;
        break;
      default:
        throw "Invalid unit: " + r3;
    }
    var c2, u2 = 0, h2 = 0;
    if (s3.hasOwnProperty(o3))
      u2 = s3[o3][1] / a3, h2 = s3[o3][0] / a3;
    else
      try {
        u2 = n2[1], h2 = n2[0];
      } catch (t3) {
        throw new Error("Invalid format: " + n2);
      }
    if ("p" === e3 || "portrait" === e3)
      e3 = "p", h2 > u2 && (c2 = h2, h2 = u2, u2 = c2);
    else {
      if ("l" !== e3 && "landscape" !== e3)
        throw "Invalid orientation: " + e3;
      e3 = "l", u2 > h2 && (c2 = h2, h2 = u2, u2 = c2);
    }
    return { width: h2, height: u2, unit: r3, k: a3, orientation: e3 };
  }, e2.html = function(t3, e3) {
    (e3 = e3 || {}).callback = e3.callback || function() {
    }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(jt) : null;
    var r3 = new s2(e3);
    return e3.worker ? r3 : r3.from(t3).doCallback();
  };
}(E.API), E.API.addJS = function(t3) {
  return Ht = t3, this.internal.events.subscribe("postPutResources", function() {
    Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    void 0 !== Ut && void 0 !== zt2 && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2;
  t3.events.push(["postPutResources", function() {
    var t4 = this, r2 = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0)
      for (var n2 = t4.outline.render().split(/\r\n/), i2 = 0; i2 < n2.length; i2++) {
        var a2 = n2[i2], o2 = r2.exec(a2);
        if (null != o2) {
          var s2 = o2[1];
          t4.internal.newObjectDeferredBegin(s2, false);
        }
        t4.internal.write(a2);
      }
    if (this.outline.createNamedDestinations) {
      var c2 = this.internal.pages.length, u2 = [];
      for (i2 = 0; i2 < c2; i2++) {
        var h2 = t4.internal.newObject();
        u2.push(h2);
        var l2 = t4.internal.getPageInfo(i2 + 1);
        t4.internal.write("<< /D[" + l2.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f2 = t4.internal.newObject();
      t4.internal.write("<< /Names [ ");
      for (i2 = 0; i2 < u2.length; i2++)
        t4.internal.write("(page_" + (i2 + 1) + ")" + u2[i2] + " 0 R");
      t4.internal.write(" ] >>", "endobj"), e2 = t4.internal.newObject(), t4.internal.write("<< /Dests " + f2 + " 0 R"), t4.internal.write(">>", "endobj");
    }
  }]), t3.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e2 + " 0 R"));
  }]), t3.events.push(["initialized", function() {
    var t4 = this;
    t4.outline = { createNamedDestinations: false, root: { children: [] } }, t4.outline.add = function(t5, e3, r2) {
      var n2 = { title: e3, options: r2, children: [] };
      return null == t5 && (t5 = this.root), t5.children.push(n2), n2;
    }, t4.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t4, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t4.outline.genIds_r = function(e3) {
      e3.id = t4.internal.newObjectDeferred();
      for (var r2 = 0; r2 < e3.children.length; r2++)
        this.genIds_r(e3.children[r2]);
    }, t4.outline.renderRoot = function(t5) {
      this.objStart(t5), this.line("/Type /Outlines"), t5.children.length > 0 && (this.line("/First " + this.makeRef(t5.children[0])), this.line("/Last " + this.makeRef(t5.children[t5.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t5)), this.objEnd();
    }, t4.outline.renderItems = function(e3) {
      for (var r2 = this.ctx.pdf.internal.getVerticalCoordinateString, n2 = 0; n2 < e3.children.length; n2++) {
        var i2 = e3.children[n2];
        this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e3)), n2 > 0 && this.line("/Prev " + this.makeRef(e3.children[n2 - 1])), n2 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[n2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
        var a2 = this.count = this.count_r({ count: 0 }, i2);
        if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
          var o2 = t4.internal.getPageInfo(i2.options.pageNumber);
          this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + r2(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s2 = 0; s2 < e3.children.length; s2++)
        this.renderItems(e3.children[s2]);
    }, t4.outline.line = function(t5) {
      this.ctx.val += t5 + "\r\n";
    }, t4.outline.makeRef = function(t5) {
      return t5.id + " 0 R";
    }, t4.outline.makeString = function(e3) {
      return "(" + t4.internal.pdfEscape(e3) + ")";
    }, t4.outline.objStart = function(t5) {
      this.ctx.val += "\r\n" + t5.id + " 0 obj\r\n<<\r\n";
    }, t4.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t4.outline.count_r = function(t5, e3) {
      for (var r2 = 0; r2 < e3.children.length; r2++)
        t5.count++, this.count_r(t5, e3.children[r2]);
      return t5.count;
    };
  }]);
}(E.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = [192, 193, 194, 195, 196, 197, 198, 199];
  t3.processJPEG = function(t4, r2, n2, i2, a2, o2) {
    var s2, c2 = this.decode.DCT_DECODE, u2 = null;
    if ("string" == typeof t4 || this.__addimage__.isArrayBuffer(t4) || this.__addimage__.isArrayBufferView(t4)) {
      switch (t4 = a2 || t4, t4 = this.__addimage__.isArrayBuffer(t4) ? new Uint8Array(t4) : t4, (s2 = function(t5) {
        for (var r3, n3 = 256 * t5.charCodeAt(4) + t5.charCodeAt(5), i3 = t5.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
          if (o3 += n3, -1 !== e2.indexOf(t5.charCodeAt(o3 + 1))) {
            r3 = 256 * t5.charCodeAt(o3 + 5) + t5.charCodeAt(o3 + 6), a3 = { width: 256 * t5.charCodeAt(o3 + 7) + t5.charCodeAt(o3 + 8), height: r3, numcomponents: t5.charCodeAt(o3 + 9) };
            break;
          }
          n3 = 256 * t5.charCodeAt(o3 + 2) + t5.charCodeAt(o3 + 3);
        }
        return a3;
      }(t4 = this.__addimage__.isArrayBufferView(t4) ? this.__addimage__.arrayBufferToBinaryString(t4) : t4)).numcomponents) {
        case 1:
          o2 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o2 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o2 = this.color_spaces.DEVICE_RGB;
      }
      u2 = { data: t4, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: c2, index: r2, alias: n2 };
    }
    return u2;
  };
}(E.API);
var Vt, Gt, Yt, Jt, Xt2, Kt = function() {
  var t3, e2, i2;
  function a2(t4) {
    var e3, r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2, d2, p2;
    for (this.data = t4, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o3 = null; ; ) {
      switch (e3 = this.readUInt32(), u2 = function() {
        var t5, e4;
        for (e4 = [], t5 = 0; t5 < 4; ++t5)
          e4.push(String.fromCharCode(this.data[this.pos++]));
        return e4;
      }.call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(e3);
          break;
        case "fcTL":
          o3 && this.animation.frames.push(o3), this.pos += 4, o3 = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, a3 = this.readUInt16(), i3 = this.readUInt16() || 100, o3.delay = 1e3 * a3 / i3, o3.disposeOp = this.data[this.pos++], o3.blendOp = this.data[this.pos++], o3.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for ("fdAT" === u2 && (this.pos += 4, e3 -= 4), t4 = (null != o3 ? o3.data : void 0) || this.imgData, f2 = 0; 0 <= e3 ? f2 < e3 : f2 > e3; 0 <= e3 ? ++f2 : --f2)
            t4.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (n2 = this.palette.length / 3, this.transparency.indexed = this.read(e3), this.transparency.indexed.length > n2)
                throw new Error("More transparent colors than palette size");
              if ((h2 = n2 - this.transparency.indexed.length) > 0)
                for (d2 = 0; 0 <= h2 ? d2 < h2 : d2 > h2; 0 <= h2 ? ++d2 : --d2)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(e3)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(e3);
          }
          break;
        case "tEXt":
          s2 = (l2 = this.read(e3)).indexOf(0), c2 = String.fromCharCode.apply(String, l2.slice(0, s2)), this.text[c2] = String.fromCharCode.apply(String, l2.slice(s2 + 1));
          break;
        case "IEND":
          return o3 && this.animation.frames.push(o3), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = 4 === (p2 = this.colorType) || 6 === p2, r2 = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * r2, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += e3;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  }
  a2.prototype.read = function(t4) {
    var e3, r2;
    for (r2 = [], e3 = 0; 0 <= t4 ? e3 < t4 : e3 > t4; 0 <= t4 ? ++e3 : --e3)
      r2.push(this.data[this.pos++]);
    return r2;
  }, a2.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, a2.prototype.decodePixels = function(t4) {
    var e3 = this.pixelBitlength / 8, n2 = new Uint8Array(this.width * this.height * e3), i3 = 0, a3 = this;
    if (null == t4 && (t4 = this.imgData), 0 === t4.length)
      return new Uint8Array(0);
    function o3(r2, o4, s2, c2) {
      var u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2 = Math.ceil((a3.width - r2) / s2), C2 = Math.ceil((a3.height - o4) / c2), j2 = a3.width == F2 && a3.height == C2;
      for (L2 = e3 * F2, w2 = j2 ? n2 : new Uint8Array(L2 * C2), p2 = t4.length, N2 = 0, h2 = 0; N2 < C2 && i3 < p2; ) {
        switch (t4[i3++]) {
          case 0:
            for (f2 = S2 = 0; S2 < L2; f2 = S2 += 1)
              w2[h2++] = t4[i3++];
            break;
          case 1:
            for (f2 = _2 = 0; _2 < L2; f2 = _2 += 1)
              u2 = t4[i3++], d2 = f2 < e3 ? 0 : w2[h2 - e3], w2[h2++] = (u2 + d2) % 256;
            break;
          case 2:
            for (f2 = P2 = 0; P2 < L2; f2 = P2 += 1)
              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (A2 + u2) % 256;
            break;
          case 3:
            for (f2 = k2 = 0; k2 < L2; f2 = k2 += 1)
              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], A2 = N2 && w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], w2[h2++] = (u2 + Math.floor((d2 + A2) / 2)) % 256;
            break;
          case 4:
            for (f2 = I2 = 0; I2 < L2; f2 = I2 += 1)
              u2 = t4[i3++], l2 = (f2 - f2 % e3) / e3, d2 = f2 < e3 ? 0 : w2[h2 - e3], 0 === N2 ? A2 = x2 = 0 : (A2 = w2[(N2 - 1) * L2 + l2 * e3 + f2 % e3], x2 = l2 && w2[(N2 - 1) * L2 + (l2 - 1) * e3 + f2 % e3]), g2 = d2 + A2 - x2, m2 = Math.abs(g2 - d2), b2 = Math.abs(g2 - A2), y2 = Math.abs(g2 - x2), v2 = m2 <= b2 && m2 <= y2 ? d2 : b2 <= y2 ? A2 : x2, w2[h2++] = (u2 + v2) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + t4[i3 - 1]);
        }
        if (!j2) {
          var O2 = ((o4 + N2 * c2) * a3.width + r2) * e3, B3 = N2 * L2;
          for (f2 = 0; f2 < F2; f2 += 1) {
            for (var M2 = 0; M2 < e3; M2 += 1)
              n2[O2++] = w2[B3++];
            O2 += (s2 - 1) * e3;
          }
        }
        N2++;
      }
    }
    return t4 = unzlibSync(t4), 1 == a3.interlaceMethod ? (o3(0, 0, 8, 8), o3(4, 0, 8, 8), o3(0, 4, 4, 8), o3(2, 0, 4, 4), o3(0, 2, 2, 4), o3(1, 0, 2, 2), o3(0, 1, 1, 2)) : o3(0, 0, 1, 1), n2;
  }, a2.prototype.decodePalette = function() {
    var t4, e3, r2, n2, i3, a3, o3, s2, c2;
    for (r2 = this.palette, a3 = this.transparency.indexed || [], i3 = new Uint8Array((a3.length || 0) + r2.length), n2 = 0, t4 = 0, e3 = o3 = 0, s2 = r2.length; o3 < s2; e3 = o3 += 3)
      i3[n2++] = r2[e3], i3[n2++] = r2[e3 + 1], i3[n2++] = r2[e3 + 2], i3[n2++] = null != (c2 = a3[t4++]) ? c2 : 255;
    return i3;
  }, a2.prototype.copyToImageData = function(t4, e3) {
    var r2, n2, i3, a3, o3, s2, c2, u2, h2, l2, f2;
    if (n2 = this.colors, h2 = null, r2 = this.hasAlphaChannel, this.palette.length && (h2 = null != (f2 = this._decodedPalette) ? f2 : this._decodedPalette = this.decodePalette(), n2 = 4, r2 = true), u2 = (i3 = t4.data || t4).length, o3 = h2 || e3, a3 = s2 = 0, 1 === n2)
      for (; a3 < u2; )
        c2 = h2 ? 4 * e3[a3 / 4] : s2, l2 = o3[c2++], i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = l2, i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;
    else
      for (; a3 < u2; )
        c2 = h2 ? 4 * e3[a3 / 4] : s2, i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = o3[c2++], i3[a3++] = r2 ? o3[c2++] : 255, s2 = c2;
  }, a2.prototype.decode = function() {
    var t4;
    return t4 = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t4, this.decodePixels()), t4;
  };
  var o2 = function() {
    if ("[object Window]" === Object.prototype.toString.call(n)) {
      try {
        e2 = n.document.createElement("canvas"), i2 = e2.getContext("2d");
      } catch (t4) {
        return false;
      }
      return true;
    }
    return false;
  };
  return o2(), t3 = function(t4) {
    var r2;
    if (true === o2())
      return i2.width = t4.width, i2.height = t4.height, i2.clearRect(0, 0, t4.width, t4.height), i2.putImageData(t4, 0, 0), (r2 = new Image()).src = e2.toDataURL(), r2;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, a2.prototype.decodeFrames = function(e3) {
    var r2, n2, i3, a3, o3, s2, c2, u2;
    if (this.animation) {
      for (u2 = [], n2 = o3 = 0, s2 = (c2 = this.animation.frames).length; o3 < s2; n2 = ++o3)
        r2 = c2[n2], i3 = e3.createImageData(r2.width, r2.height), a3 = this.decodePixels(new Uint8Array(r2.data)), this.copyToImageData(i3, a3), r2.imageData = i3, u2.push(r2.image = t3(i3));
      return u2;
    }
  }, a2.prototype.renderFrame = function(t4, e3) {
    var r2, n2, i3;
    return r2 = (n2 = this.animation.frames)[e3], i3 = n2[e3 - 1], 0 === e3 && t4.clearRect(0, 0, this.width, this.height), 1 === (null != i3 ? i3.disposeOp : void 0) ? t4.clearRect(i3.xOffset, i3.yOffset, i3.width, i3.height) : 2 === (null != i3 ? i3.disposeOp : void 0) && t4.putImageData(i3.imageData, i3.xOffset, i3.yOffset), 0 === r2.blendOp && t4.clearRect(r2.xOffset, r2.yOffset, r2.width, r2.height), t4.drawImage(r2.image, r2.xOffset, r2.yOffset);
  }, a2.prototype.animate = function(t4) {
    var e3, r2, n2, i3, a3, o3, s2 = this;
    return r2 = 0, o3 = this.animation, i3 = o3.numFrames, n2 = o3.frames, a3 = o3.numPlays, (e3 = function() {
      var o4, c2;
      if (o4 = r2++ % i3, c2 = n2[o4], s2.renderFrame(t4, o4), i3 > 1 && r2 / i3 < a3)
        return s2.animation._timeout = setTimeout(e3, c2.delay);
    })();
  }, a2.prototype.stopAnimation = function() {
    var t4;
    return clearTimeout(null != (t4 = this.animation) ? t4._timeout : void 0);
  }, a2.prototype.render = function(t4) {
    var e3, r2;
    return t4._png && t4._png.stopAnimation(), t4._png = this, t4.width = this.width, t4.height = this.height, e3 = t4.getContext("2d"), this.animation ? (this.decodeFrames(e3), this.animate(e3)) : (r2 = e3.createImageData(this.width, this.height), this.copyToImageData(r2, this.decodePixels()), e3.putImageData(r2, 0, 0));
  }, a2;
}();
/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
/**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */
function Zt(t3) {
  var e2 = 0;
  if (71 !== t3[e2++] || 73 !== t3[e2++] || 70 !== t3[e2++] || 56 !== t3[e2++] || 56 != (t3[e2++] + 1 & 253) || 97 !== t3[e2++])
    throw new Error("Invalid GIF 87a/89a header.");
  var r2 = t3[e2++] | t3[e2++] << 8, n2 = t3[e2++] | t3[e2++] << 8, i2 = t3[e2++], a2 = i2 >> 7, o2 = 1 << (7 & i2) + 1;
  t3[e2++];
  t3[e2++];
  var s2 = null, c2 = null;
  a2 && (s2 = e2, c2 = o2, e2 += 3 * o2);
  var u2 = true, h2 = [], l2 = 0, f2 = null, d2 = 0, p2 = null;
  for (this.width = r2, this.height = n2; u2 && e2 < t3.length; )
    switch (t3[e2++]) {
      case 33:
        switch (t3[e2++]) {
          case 255:
            if (11 !== t3[e2] || 78 == t3[e2 + 1] && 69 == t3[e2 + 2] && 84 == t3[e2 + 3] && 83 == t3[e2 + 4] && 67 == t3[e2 + 5] && 65 == t3[e2 + 6] && 80 == t3[e2 + 7] && 69 == t3[e2 + 8] && 50 == t3[e2 + 9] && 46 == t3[e2 + 10] && 48 == t3[e2 + 11] && 3 == t3[e2 + 12] && 1 == t3[e2 + 13] && 0 == t3[e2 + 16])
              e2 += 14, p2 = t3[e2++] | t3[e2++] << 8, e2++;
            else
              for (e2 += 12; ; ) {
                if (!((P2 = t3[e2++]) >= 0))
                  throw Error("Invalid block size");
                if (0 === P2)
                  break;
                e2 += P2;
              }
            break;
          case 249:
            if (4 !== t3[e2++] || 0 !== t3[e2 + 4])
              throw new Error("Invalid graphics extension block.");
            var g2 = t3[e2++];
            l2 = t3[e2++] | t3[e2++] << 8, f2 = t3[e2++], 0 == (1 & g2) && (f2 = null), d2 = g2 >> 2 & 7, e2++;
            break;
          case 254:
            for (; ; ) {
              if (!((P2 = t3[e2++]) >= 0))
                throw Error("Invalid block size");
              if (0 === P2)
                break;
              e2 += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t3[e2 - 1].toString(16));
        }
        break;
      case 44:
        var m2 = t3[e2++] | t3[e2++] << 8, v2 = t3[e2++] | t3[e2++] << 8, b2 = t3[e2++] | t3[e2++] << 8, y2 = t3[e2++] | t3[e2++] << 8, w2 = t3[e2++], N2 = w2 >> 6 & 1, L2 = 1 << (7 & w2) + 1, A2 = s2, x2 = c2, S2 = false;
        if (w2 >> 7) {
          S2 = true;
          A2 = e2, x2 = L2, e2 += 3 * L2;
        }
        var _2 = e2;
        for (e2++; ; ) {
          var P2;
          if (!((P2 = t3[e2++]) >= 0))
            throw Error("Invalid block size");
          if (0 === P2)
            break;
          e2 += P2;
        }
        h2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: A2, palette_size: x2, data_offset: _2, data_length: e2 - _2, transparent_index: f2, interlaced: !!N2, delay: l2, disposal: d2 });
        break;
      case 59:
        u2 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t3[e2 - 1].toString(16));
    }
  this.numFrames = function() {
    return h2.length;
  }, this.loopCount = function() {
    return p2;
  }, this.frameInfo = function(t4) {
    if (t4 < 0 || t4 >= h2.length)
      throw new Error("Frame index out of range.");
    return h2[t4];
  }, this.decodeAndBlitFrameBGRA = function(e3, n3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t3, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p3 = f3, g3 = 4 * h3;
    true === i3.interlaced && (g3 += 4 * r2 * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p3 += 4;
      else {
        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
        n3[p3++] = L3, n3[p3++] = N3, n3[p3++] = w3, n3[p3++] = 255;
      }
      --l3;
    }
  }, this.decodeAndBlitFrameRGBA = function(e3, n3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    $t(t3, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, c3 = i3.transparent_index;
    null === c3 && (c3 = 256);
    var u3 = i3.width, h3 = r2 - u3, l3 = u3, f3 = 4 * (i3.y * r2 + i3.x), d3 = 4 * ((i3.y + i3.height) * r2 + i3.x), p3 = f3, g3 = 4 * h3;
    true === i3.interlaced && (g3 += 4 * r2 * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === l3 && (l3 = u3, (p3 += g3) >= d3 && (g3 = 4 * h3 + 4 * r2 * (m3 - 1), p3 = f3 + (u3 + h3) * (m3 << 1), m3 >>= 1)), y3 === c3)
        p3 += 4;
      else {
        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
        n3[p3++] = w3, n3[p3++] = N3, n3[p3++] = L3, n3[p3++] = 255;
      }
      --l3;
    }
  };
}
function $t(t3, e2, r2, n2) {
  for (var i2 = t3[e2++], o2 = 1 << i2, s2 = o2 + 1, c2 = s2 + 1, u2 = i2 + 1, h2 = (1 << u2) - 1, l2 = 0, f2 = 0, d2 = 0, p2 = t3[e2++], g2 = new Int32Array(4096), m2 = null; ; ) {
    for (; l2 < 16 && 0 !== p2; )
      f2 |= t3[e2++] << l2, l2 += 8, 1 === p2 ? p2 = t3[e2++] : --p2;
    if (l2 < u2)
      break;
    var v2 = f2 & h2;
    if (f2 >>= u2, l2 -= u2, v2 !== o2) {
      if (v2 === s2)
        break;
      for (var b2 = v2 < c2 ? v2 : m2, y2 = 0, w2 = b2; w2 > o2; )
        w2 = g2[w2] >> 8, ++y2;
      var N2 = w2;
      if (d2 + y2 + (b2 !== v2 ? 1 : 0) > n2)
        return void a.log("Warning, gif stream longer than expected.");
      r2[d2++] = N2;
      var L2 = d2 += y2;
      for (b2 !== v2 && (r2[d2++] = N2), w2 = b2; y2--; )
        w2 = g2[w2], r2[--L2] = 255 & w2, w2 >>= 8;
      null !== m2 && c2 < 4096 && (g2[c2++] = m2 << 8 | N2, c2 >= h2 + 1 && u2 < 12 && (++u2, h2 = h2 << 1 | 1)), m2 = v2;
    } else
      c2 = s2 + 1, h2 = (1 << (u2 = i2 + 1)) - 1, m2 = null;
  }
  return d2 !== n2 && a.log("Warning, gif stream shorter than expected."), r2;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Qt(t3) {
  var e2, r2, n2, i2, a2, o2 = Math.floor, s2 = new Array(64), c2 = new Array(64), u2 = new Array(64), h2 = new Array(64), l2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), A2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], x2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], I2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], C2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function j2(t4, e3) {
    for (var r3 = 0, n3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
      for (var o3 = 1; o3 <= t4[a3]; o3++)
        i3[e3[n3]] = [], i3[e3[n3]][0] = r3, i3[e3[n3]][1] = a3, n3++, r3++;
      r3 *= 2;
    }
    return i3;
  }
  function O2(t4) {
    for (var e3 = t4[0], r3 = t4[1] - 1; r3 >= 0; )
      e3 & 1 << r3 && (m2 |= 1 << v2), r3--, --v2 < 0 && (255 == m2 ? (B3(255), B3(0)) : B3(m2), v2 = 7, m2 = 0);
  }
  function B3(t4) {
    g2.push(t4);
  }
  function M2(t4) {
    B3(t4 >> 8 & 255), B3(255 & t4);
  }
  function E2(t4, e3, r3, n3, i3) {
    for (var a3, o3 = i3[0], s3 = i3[240], c3 = function(t5, e4) {
      var r4, n4, i4, a4, o4, s4, c4, u4, h4, l3, f3 = 0;
      for (h4 = 0; h4 < 8; ++h4) {
        r4 = t5[f3], n4 = t5[f3 + 1], i4 = t5[f3 + 2], a4 = t5[f3 + 3], o4 = t5[f3 + 4], s4 = t5[f3 + 5], c4 = t5[f3 + 6];
        var p3 = r4 + (u4 = t5[f3 + 7]), g4 = r4 - u4, m4 = n4 + c4, v4 = n4 - c4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p3 + w4, A3 = p3 - w4, x3 = m4 + b4, S3 = m4 - b4;
        t5[f3] = L3 + x3, t5[f3 + 4] = L3 - x3;
        var _3 = 0.707106781 * (S3 + A3);
        t5[f3 + 2] = A3 + _3, t5[f3 + 6] = A3 - _3;
        var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, I3 = 1.306562965 * S3 + P3, F3 = 0.707106781 * (x3 = y4 + v4), C3 = g4 + F3, j3 = g4 - F3;
        t5[f3 + 5] = j3 + k3, t5[f3 + 3] = j3 - k3, t5[f3 + 1] = C3 + I3, t5[f3 + 7] = C3 - I3, f3 += 8;
      }
      for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
        r4 = t5[f3], n4 = t5[f3 + 8], i4 = t5[f3 + 16], a4 = t5[f3 + 24], o4 = t5[f3 + 32], s4 = t5[f3 + 40], c4 = t5[f3 + 48];
        var O3 = r4 + (u4 = t5[f3 + 56]), B4 = r4 - u4, M3 = n4 + c4, E3 = n4 - c4, q3 = i4 + s4, D2 = i4 - s4, R2 = a4 + o4, T2 = a4 - o4, U2 = O3 + R2, z2 = O3 - R2, H4 = M3 + q3, W2 = M3 - q3;
        t5[f3] = U2 + H4, t5[f3 + 32] = U2 - H4;
        var V2 = 0.707106781 * (W2 + z2);
        t5[f3 + 16] = z2 + V2, t5[f3 + 48] = z2 - V2;
        var G2 = 0.382683433 * ((U2 = T2 + D2) - (W2 = E3 + B4)), Y2 = 0.5411961 * U2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H4 = D2 + E3), K2 = B4 + X2, Z2 = B4 - X2;
        t5[f3 + 40] = Z2 + Y2, t5[f3 + 24] = Z2 - Y2, t5[f3 + 8] = K2 + J2, t5[f3 + 56] = K2 - J2, f3++;
      }
      for (h4 = 0; h4 < 64; ++h4)
        l3 = t5[h4] * e4[h4], d2[h4] = l3 > 0 ? l3 + 0.5 | 0 : l3 - 0.5 | 0;
      return d2;
    }(t4, e3), u3 = 0; u3 < 64; ++u3)
      p2[A2[u3]] = c3[u3];
    var h3 = p2[0] - r3;
    r3 = p2[0], 0 == h3 ? O2(n3[0]) : (O2(n3[f2[a3 = 32767 + h3]]), O2(l2[a3]));
    for (var g3 = 63; g3 > 0 && 0 == p2[g3]; )
      g3--;
    if (0 == g3)
      return O2(o3), r3;
    for (var m3, v3 = 1; v3 <= g3; ) {
      for (var b3 = v3; 0 == p2[v3] && v3 <= g3; )
        ++v3;
      var y3 = v3 - b3;
      if (y3 >= 16) {
        m3 = y3 >> 4;
        for (var w3 = 1; w3 <= m3; ++w3)
          O2(s3);
        y3 &= 15;
      }
      a3 = 32767 + p2[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(l2[a3]), v3++;
    }
    return 63 != g3 && O2(o3), r3;
  }
  function q2(t4) {
    (t4 = Math.min(Math.max(t4, 1), 100), a2 != t4) && (!function(t5) {
      for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], r3 = 0; r3 < 64; r3++) {
        var n3 = o2((e3[r3] * t5 + 50) / 100);
        n3 = Math.min(Math.max(n3, 1), 255), s2[A2[r3]] = n3;
      }
      for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
        var l3 = o2((i3[a3] * t5 + 50) / 100);
        l3 = Math.min(Math.max(l3, 1), 255), c2[A2[a3]] = l3;
      }
      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p3 = 0; p3 < 8; p3++)
        for (var g3 = 0; g3 < 8; g3++)
          u2[d3] = 1 / (s2[A2[d3]] * f3[p3] * f3[g3] * 8), h2[d3] = 1 / (c2[A2[d3]] * f3[p3] * f3[g3] * 8), d3++;
    }(t4 < 50 ? Math.floor(5e3 / t4) : Math.floor(200 - 2 * t4)), a2 = t4);
  }
  this.encode = function(t4, a3) {
    a3 && q2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B3(74), B3(70), B3(73), B3(70), B3(0), B3(1), B3(1), B3(0), M2(1), M2(1), B3(0), B3(0), function() {
      M2(65499), M2(132), B3(0);
      for (var t5 = 0; t5 < 64; t5++)
        B3(s2[t5]);
      B3(1);
      for (var e3 = 0; e3 < 64; e3++)
        B3(c2[e3]);
    }(), function(t5, e3) {
      M2(65472), M2(17), B3(8), M2(e3), M2(t5), B3(3), B3(1), B3(17), B3(0), B3(2), B3(17), B3(1), B3(3), B3(17), B3(1);
    }(t4.width, t4.height), function() {
      M2(65476), M2(418), B3(0);
      for (var t5 = 0; t5 < 16; t5++)
        B3(x2[t5 + 1]);
      for (var e3 = 0; e3 <= 11; e3++)
        B3(S2[e3]);
      B3(16);
      for (var r3 = 0; r3 < 16; r3++)
        B3(_2[r3 + 1]);
      for (var n3 = 0; n3 <= 161; n3++)
        B3(P2[n3]);
      B3(1);
      for (var i3 = 0; i3 < 16; i3++)
        B3(k2[i3 + 1]);
      for (var a4 = 0; a4 <= 11; a4++)
        B3(I2[a4]);
      B3(17);
      for (var o4 = 0; o4 < 16; o4++)
        B3(F2[o4 + 1]);
      for (var s3 = 0; s3 <= 161; s3++)
        B3(C2[s3]);
    }(), M2(65498), M2(12), B3(3), B3(1), B3(0), B3(2), B3(17), B3(3), B3(17), B3(0), B3(63), B3(0);
    var o3 = 0, l3 = 0, f3 = 0;
    m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
    for (var d3, p3, N3, A3, j3, D2, R2, T2, U2, z2 = t4.data, H4 = t4.width, W2 = t4.height, V2 = 4 * H4, G2 = 0; G2 < W2; ) {
      for (d3 = 0; d3 < V2; ) {
        for (j3 = V2 * G2 + d3, R2 = -1, T2 = 0, U2 = 0; U2 < 64; U2++)
          D2 = j3 + (T2 = U2 >> 3) * V2 + (R2 = 4 * (7 & U2)), G2 + T2 >= W2 && (D2 -= V2 * (G2 + 1 + T2 - W2)), d3 + R2 >= V2 && (D2 -= d3 + R2 - V2 + 4), p3 = z2[D2++], N3 = z2[D2++], A3 = z2[D2++], b2[U2] = (L2[p3] + L2[N3 + 256 >> 0] + L2[A3 + 512 >> 0] >> 16) - 128, y2[U2] = (L2[p3 + 768 >> 0] + L2[N3 + 1024 >> 0] + L2[A3 + 1280 >> 0] >> 16) - 128, w2[U2] = (L2[p3 + 1280 >> 0] + L2[N3 + 1536 >> 0] + L2[A3 + 1792 >> 0] >> 16) - 128;
        o3 = E2(b2, u2, o3, e2, n2), l3 = E2(y2, h2, l3, r2, i2), f3 = E2(w2, h2, f3, r2, i2), d3 += 32;
      }
      G2 += 8;
    }
    if (v2 >= 0) {
      var Y2 = [];
      Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t3 = t3 || 50, function() {
    for (var t4 = String.fromCharCode, e3 = 0; e3 < 256; e3++)
      N2[e3] = t4(e3);
  }(), e2 = j2(x2, S2), r2 = j2(k2, I2), n2 = j2(_2, P2), i2 = j2(F2, C2), function() {
    for (var t4 = 1, e3 = 2, r3 = 1; r3 <= 15; r3++) {
      for (var n3 = t4; n3 < e3; n3++)
        f2[32767 + n3] = r3, l2[32767 + n3] = [], l2[32767 + n3][1] = r3, l2[32767 + n3][0] = n3;
      for (var i3 = -(e3 - 1); i3 <= -t4; i3++)
        f2[32767 + i3] = r3, l2[32767 + i3] = [], l2[32767 + i3][1] = r3, l2[32767 + i3][0] = e3 - 1 + i3;
      t4 <<= 1, e3 <<= 1;
    }
  }(), function() {
    for (var t4 = 0; t4 < 256; t4++)
      L2[t4] = 19595 * t4, L2[t4 + 256 >> 0] = 38470 * t4, L2[t4 + 512 >> 0] = 7471 * t4 + 32768, L2[t4 + 768 >> 0] = -11059 * t4, L2[t4 + 1024 >> 0] = -21709 * t4, L2[t4 + 1280 >> 0] = 32768 * t4 + 8421375, L2[t4 + 1536 >> 0] = -27439 * t4, L2[t4 + 1792 >> 0] = -5329 * t4;
  }(), q2(t3);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function te(t3, e2) {
  if (this.pos = 0, this.buffer = t3, this.datav = new DataView(t3.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag))
    throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function ee(t3) {
  function e2(t4) {
    if (!t4)
      throw Error("assert :P");
  }
  function r2(t4, e3, r3) {
    for (var n3 = 0; 4 > n3; n3++)
      if (t4[e3 + n3] != r3.charCodeAt(n3))
        return true;
    return false;
  }
  function n2(t4, e3, r3, n3, i3) {
    for (var a3 = 0; a3 < i3; a3++)
      t4[e3 + a3] = r3[n3 + a3];
  }
  function i2(t4, e3, r3, n3) {
    for (var i3 = 0; i3 < n3; i3++)
      t4[e3 + i3] = r3;
  }
  function a2(t4) {
    return new Int32Array(t4);
  }
  function o2(t4, e3) {
    for (var r3 = [], n3 = 0; n3 < t4; n3++)
      r3.push(new e3());
    return r3;
  }
  function s2(t4, e3) {
    var r3 = [];
    return function t5(r4, n3, i3) {
      for (var a3 = i3[n3], o3 = 0; o3 < a3 && (r4.push(i3.length > n3 + 1 ? [] : new e3()), !(i3.length < n3 + 1)); o3++)
        t5(r4[o3], n3 + 1, i3);
    }(r3, 0, t4), r3;
  }
  var c2 = function() {
    var t4 = this;
    function c3(t5, e3) {
      for (var r3 = 1 << e3 - 1 >>> 0; t5 & r3; )
        r3 >>>= 1;
      return r3 ? (t5 & r3 - 1) + r3 : t5;
    }
    function u3(t5, r3, n3, i3, a3) {
      e2(!(i3 % n3));
      do {
        t5[r3 + (i3 -= n3)] = a3;
      } while (0 < i3);
    }
    function h3(t5, r3, n3, i3, o3) {
      if (e2(2328 >= o3), 512 >= o3)
        var s3 = a2(512);
      else if (null == (s3 = a2(o3)))
        return 0;
      return function(t6, r4, n4, i4, o4, s4) {
        var h4, f4, d4 = r4, p4 = 1 << n4, g4 = a2(16), m4 = a2(16);
        for (e2(0 != o4), e2(null != i4), e2(null != t6), e2(0 < n4), f4 = 0; f4 < o4; ++f4) {
          if (15 < i4[f4])
            return 0;
          ++g4[i4[f4]];
        }
        if (g4[0] == o4)
          return 0;
        for (m4[1] = 0, h4 = 1; 15 > h4; ++h4) {
          if (g4[h4] > 1 << h4)
            return 0;
          m4[h4 + 1] = m4[h4] + g4[h4];
        }
        for (f4 = 0; f4 < o4; ++f4)
          h4 = i4[f4], 0 < i4[f4] && (s4[m4[h4]++] = f4);
        if (1 == m4[15])
          return (i4 = new l3()).g = 0, i4.value = s4[0], u3(t6, d4, 1, p4, i4), p4;
        var v4, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L4 = 1, A4 = 1 << n4;
        for (f4 = 0, h4 = 1, o4 = 2; h4 <= n4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
            return 0;
          for (; 0 < g4[h4]; --g4[h4])
            (i4 = new l3()).g = h4, i4.value = s4[f4++], u3(t6, d4 + w4, o4, A4, i4), w4 = c3(w4, h4);
        }
        for (h4 = n4 + 1, o4 = 2; 15 >= h4; ++h4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[h4]))
            return 0;
          for (; 0 < g4[h4]; --g4[h4]) {
            if (i4 = new l3(), (w4 & y4) != b4) {
              for (d4 += A4, v4 = 1 << (b4 = h4) - n4; 15 > b4 && !(0 >= (v4 -= g4[b4])); )
                ++b4, v4 <<= 1;
              p4 += A4 = 1 << (v4 = b4 - n4), t6[r4 + (b4 = w4 & y4)].g = v4 + n4, t6[r4 + b4].value = d4 - r4 - b4;
            }
            i4.g = h4 - n4, i4.value = s4[f4++], u3(t6, d4 + (w4 >> n4), o4, A4, i4), w4 = c3(w4, h4);
          }
        }
        return N4 != 2 * m4[15] - 1 ? 0 : p4;
      }(t5, r3, n3, i3, o3, s3);
    }
    function l3() {
      this.value = this.g = 0;
    }
    function f3() {
      this.value = this.g = 0;
    }
    function d3() {
      this.G = o2(5, l3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Dr, f3);
    }
    function p3(t5, r3, n3, i3) {
      e2(null != t5), e2(null != r3), e2(2147483648 > i3), t5.Ca = 254, t5.I = 0, t5.b = -8, t5.Ka = 0, t5.oa = r3, t5.pa = n3, t5.Jd = r3, t5.Yc = n3 + i3, t5.Zc = 4 <= i3 ? n3 + i3 - 4 + 1 : n3, _2(t5);
    }
    function g3(t5, e3) {
      for (var r3 = 0; 0 < e3--; )
        r3 |= k2(t5, 128) << e3;
      return r3;
    }
    function m3(t5, e3) {
      var r3 = g3(t5, e3);
      return P2(t5) ? -r3 : r3;
    }
    function v3(t5, r3, n3, i3) {
      var a3, o3 = 0;
      for (e2(null != t5), e2(null != r3), e2(4294967288 > i3), t5.Sb = i3, t5.Ra = 0, t5.u = 0, t5.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3)
        o3 += r3[n3 + a3] << 8 * a3;
      t5.Ra = o3, t5.bb = i3, t5.oa = r3, t5.pa = n3;
    }
    function b3(t5) {
      for (; 8 <= t5.u && t5.bb < t5.Sb; )
        t5.Ra >>>= 8, t5.Ra += t5.oa[t5.pa + t5.bb] << Ur - 8 >>> 0, ++t5.bb, t5.u -= 8;
      A3(t5) && (t5.h = 1, t5.u = 0);
    }
    function y3(t5, r3) {
      if (e2(0 <= r3), !t5.h && r3 <= Tr) {
        var n3 = L3(t5) & Rr[r3];
        return t5.u += r3, b3(t5), n3;
      }
      return t5.h = 1, t5.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N3() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t5) {
      return t5.Ra >>> (t5.u & Ur - 1) >>> 0;
    }
    function A3(t5) {
      return e2(t5.bb <= t5.Sb), t5.h || t5.bb == t5.Sb && t5.u > Ur;
    }
    function x2(t5, e3) {
      t5.u = e3, t5.h = A3(t5);
    }
    function S2(t5) {
      t5.u >= zr && (e2(t5.u >= zr), b3(t5));
    }
    function _2(t5) {
      e2(null != t5 && null != t5.oa), t5.pa < t5.Zc ? (t5.I = (t5.oa[t5.pa++] | t5.I << 8) >>> 0, t5.b += 8) : (e2(null != t5 && null != t5.oa), t5.pa < t5.Yc ? (t5.b += 8, t5.I = t5.oa[t5.pa++] | t5.I << 8) : t5.Ka ? t5.b = 0 : (t5.I <<= 8, t5.b += 8, t5.Ka = 1));
    }
    function P2(t5) {
      return g3(t5, 1);
    }
    function k2(t5, e3) {
      var r3 = t5.Ca;
      0 > t5.b && _2(t5);
      var n3 = t5.b, i3 = r3 * e3 >>> 8, a3 = (t5.I >>> n3 > i3) + 0;
      for (a3 ? (r3 -= i3, t5.I -= i3 + 1 << n3 >>> 0) : r3 = i3 + 1, n3 = r3, i3 = 0; 256 <= n3; )
        i3 += 8, n3 >>= 8;
      return n3 = 7 ^ i3 + Hr[n3], t5.b -= n3, t5.Ca = (r3 << n3) - 1, a3;
    }
    function I2(t5, e3, r3) {
      t5[e3 + 0] = r3 >> 24 & 255, t5[e3 + 1] = r3 >> 16 & 255, t5[e3 + 2] = r3 >> 8 & 255, t5[e3 + 3] = r3 >> 0 & 255;
    }
    function F2(t5, e3) {
      return t5[e3 + 0] << 0 | t5[e3 + 1] << 8;
    }
    function C2(t5, e3) {
      return F2(t5, e3) | t5[e3 + 2] << 16;
    }
    function j2(t5, e3) {
      return F2(t5, e3) | F2(t5, e3 + 2) << 16;
    }
    function O2(t5, r3) {
      var n3 = 1 << r3;
      return e2(null != t5), e2(0 < r3), t5.X = a2(n3), null == t5.X ? 0 : (t5.Mb = 32 - r3, t5.Xa = r3, 1);
    }
    function B3(t5, r3) {
      e2(null != t5), e2(null != r3), e2(t5.Xa == r3.Xa), n2(r3.X, 0, t5.X, 0, 1 << r3.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function E2(t5, r3, n3, i3) {
      e2(null != n3), e2(null != i3);
      var a3 = n3[0], o3 = i3[0];
      return 0 == a3 && (a3 = (t5 * o3 + r3 / 2) / r3), 0 == o3 && (o3 = (r3 * a3 + t5 / 2) / t5), 0 >= a3 || 0 >= o3 ? 0 : (n3[0] = a3, i3[0] = o3, 1);
    }
    function q2(t5, e3) {
      return t5 + (1 << e3) - 1 >>> e3;
    }
    function D2(t5, e3) {
      return ((4278255360 & t5) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t5) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
    }
    function R2(e3, r3) {
      t4[r3] = function(r4, n3, i3, a3, o3, s3, c4) {
        var u4;
        for (u4 = 0; u4 < o3; ++u4) {
          var h4 = t4[e3](s3[c4 + u4 - 1], i3, a3 + u4);
          s3[c4 + u4] = D2(r4[n3 + u4], h4);
        }
      };
    }
    function T2() {
      this.ud = this.hd = this.jd = 0;
    }
    function U2(t5, e3) {
      return ((4278124286 & (t5 ^ e3)) >>> 1) + (t5 & e3) >>> 0;
    }
    function z2(t5) {
      return 0 <= t5 && 256 > t5 ? t5 : 0 > t5 ? 0 : 255 < t5 ? 255 : void 0;
    }
    function H4(t5, e3) {
      return z2(t5 + (t5 - e3 + 0.5 >> 1));
    }
    function W2(t5, e3, r3) {
      return Math.abs(e3 - r3) - Math.abs(t5 - r3);
    }
    function V2(t5, e3, r3, n3, i3, a3, o3) {
      for (n3 = a3[o3 - 1], r3 = 0; r3 < i3; ++r3)
        a3[o3 + r3] = n3 = D2(t5[e3 + r3], n3);
    }
    function G2(t5, e3, r3, n3, i3) {
      var a3;
      for (a3 = 0; a3 < r3; ++a3) {
        var o3 = t5[e3 + a3], s3 = o3 >> 8 & 255, c4 = 16711935 & (c4 = (c4 = 16711935 & o3) + ((s3 << 16) + s3));
        n3[i3 + a3] = (4278255360 & o3) + c4 >>> 0;
      }
    }
    function Y2(t5, e3) {
      e3.jd = t5 >> 0 & 255, e3.hd = t5 >> 8 & 255, e3.ud = t5 >> 16 & 255;
    }
    function J2(t5, e3, r3, n3, i3, a3) {
      var o3;
      for (o3 = 0; o3 < n3; ++o3) {
        var s3 = e3[r3 + o3], c4 = s3 >>> 8, u4 = s3, h4 = 255 & (h4 = (h4 = s3 >>> 16) + ((t5.jd << 24 >> 24) * (c4 << 24 >> 24) >>> 5));
        u4 = 255 & (u4 = (u4 = u4 + ((t5.hd << 24 >> 24) * (c4 << 24 >> 24) >>> 5)) + ((t5.ud << 24 >> 24) * (h4 << 24 >> 24) >>> 5));
        i3[a3 + o3] = (4278255360 & s3) + (h4 << 16) + u4;
      }
    }
    function X2(e3, r3, n3, i3, a3) {
      t4[r3] = function(t5, e4, r4, n4, o3, s3, c4, u4, h4) {
        for (n4 = c4; n4 < u4; ++n4)
          for (c4 = 0; c4 < h4; ++c4)
            o3[s3++] = a3(r4[i3(t5[e4++])]);
      }, t4[e3] = function(e4, r4, o3, s3, c4, u4, h4) {
        var l4 = 8 >> e4.b, f4 = e4.Ea, d4 = e4.K[0], p4 = e4.w;
        if (8 > l4)
          for (e4 = (1 << e4.b) - 1, p4 = (1 << l4) - 1; r4 < o3; ++r4) {
            var g4, m4 = 0;
            for (g4 = 0; g4 < f4; ++g4)
              g4 & e4 || (m4 = i3(s3[c4++])), u4[h4++] = a3(d4[m4 & p4]), m4 >>= l4;
          }
        else
          t4["VP8LMapColor" + n3](s3, c4, d4, p4, u4, h4, r4, o3, f4);
      };
    }
    function K2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = t5[e3++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255;
      }
    }
    function Z2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = t5[e3++];
        n3[i3++] = a3 >> 16 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 24 & 255;
      }
    }
    function $2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = (o3 = t5[e3++]) >> 16 & 240 | o3 >> 12 & 15, o3 = o3 >> 0 & 240 | o3 >> 28 & 15;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    function Q2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = (o3 = t5[e3++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
        n3[i3++] = a3, n3[i3++] = o3;
      }
    }
    function tt2(t5, e3, r3, n3, i3) {
      for (r3 = e3 + r3; e3 < r3; ) {
        var a3 = t5[e3++];
        n3[i3++] = a3 >> 0 & 255, n3[i3++] = a3 >> 8 & 255, n3[i3++] = a3 >> 16 & 255;
      }
    }
    function et2(t5, e3, r3, i3, a3, o3) {
      if (0 == o3)
        for (r3 = e3 + r3; e3 < r3; )
          I2(i3, ((o3 = t5[e3++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
      else
        n2(i3, a3, t5, e3, r3);
    }
    function rt2(e3, r3) {
      t4[r3][0] = t4[e3 + "0"], t4[r3][1] = t4[e3 + "1"], t4[r3][2] = t4[e3 + "2"], t4[r3][3] = t4[e3 + "3"], t4[r3][4] = t4[e3 + "4"], t4[r3][5] = t4[e3 + "5"], t4[r3][6] = t4[e3 + "6"], t4[r3][7] = t4[e3 + "7"], t4[r3][8] = t4[e3 + "8"], t4[r3][9] = t4[e3 + "9"], t4[r3][10] = t4[e3 + "10"], t4[r3][11] = t4[e3 + "11"], t4[r3][12] = t4[e3 + "12"], t4[r3][13] = t4[e3 + "13"], t4[r3][14] = t4[e3 + "0"], t4[r3][15] = t4[e3 + "0"];
    }
    function nt2(t5) {
      return t5 == Hn2 || t5 == Wn2 || t5 == Vn2 || t5 == Gn2;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ct2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ut2(t5) {
      return alert("todo:WebPSamplerProcessPlane"), t5.T;
    }
    function ht2(t5, e3) {
      var r3 = t5.T, i3 = e3.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t5.ka * i3.A, s3 = vi2[e3.ba.S], c4 = t5.y, u4 = t5.O, h4 = t5.f, l4 = t5.N, f4 = t5.ea, d4 = t5.W, p4 = e3.cc, g4 = e3.dc, m4 = e3.Mc, v4 = e3.Nc, b4 = t5.ka, y4 = t5.ka + t5.T, w4 = t5.U, N4 = w4 + 1 >> 1;
      for (0 == b4 ? s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3, null, null, w4) : (s3(e3.ec, e3.fc, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4), ++r3); b4 + 2 < y4; b4 += 2)
        p4 = h4, g4 = l4, m4 = f4, v4 = d4, l4 += t5.Rc, d4 += t5.Rc, o3 += 2 * i3.A, s3(c4, (u4 += 2 * t5.fa) - t5.fa, c4, u4, p4, g4, m4, v4, h4, l4, f4, d4, a3, o3 - i3.A, a3, o3, w4);
      return u4 += t5.fa, t5.j + y4 < t5.o ? (n2(e3.ec, e3.fc, c4, u4, w4), n2(e3.cc, e3.dc, h4, l4, N4), n2(e3.Mc, e3.Nc, f4, d4, N4), r3--) : 1 & y4 || s3(c4, u4, null, null, h4, l4, f4, d4, h4, l4, f4, d4, a3, o3 + i3.A, null, null, w4), r3;
    }
    function lt2(t5, r3, n3) {
      var i3 = t5.F, a3 = [t5.J];
      if (null != i3) {
        var o3 = t5.U, s3 = r3.ba.S, c4 = s3 == Tn2 || s3 == Vn2;
        r3 = r3.ba.f.RGBA;
        var u4 = [0], h4 = t5.ka;
        u4[0] = t5.T, t5.Kb && (0 == h4 ? --u4[0] : (--h4, a3[0] -= t5.width), t5.j + t5.ka + t5.T == t5.o && (u4[0] = t5.o - t5.j - h4));
        var l4 = r3.eb;
        h4 = r3.fb + h4 * r3.A;
        t5 = Sn2(i3, a3[0], t5.width, o3, u4, l4, h4 + (c4 ? 0 : 3), r3.A), e2(n3 == u4), t5 && nt2(s3) && An2(l4, h4, c4, o3, u4, r3.A);
      }
      return 0;
    }
    function ft2(t5) {
      var e3 = t5.ma, r3 = e3.ba.S, n3 = 11 > r3, i3 = r3 == qn2 || r3 == Rn2 || r3 == Tn2 || r3 == Un2 || 12 == r3 || nt2(r3);
      if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mr(e3.Oa, t5, i3 ? 11 : 12))
        return 0;
      if (i3 && nt2(r3) && br(), t5.da)
        alert("todo:use_scaling");
      else {
        if (n3) {
          if (e3.Ib = ut2, t5.Kb) {
            if (r3 = t5.U + 1 >> 1, e3.memory = a2(t5.U + 2 * r3), null == e3.memory)
              return 0;
            e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t5.U, e3.Mc = e3.cc, e3.Nc = e3.dc + r3, e3.Ib = ht2, br();
          }
        } else
          alert("todo:EmitYUV");
        i3 && (e3.Jb = lt2, n3 && mr());
      }
      if (n3 && !Ci2) {
        for (t5 = 0; 256 > t5; ++t5)
          ji2[t5] = 89858 * (t5 - 128) + _i >> Si2, Mi2[t5] = -22014 * (t5 - 128) + _i, Bi2[t5] = -45773 * (t5 - 128), Oi2[t5] = 113618 * (t5 - 128) + _i >> Si2;
        for (t5 = Pi2; t5 < ki2; ++t5)
          e3 = 76283 * (t5 - 16) + _i >> Si2, Ei2[t5 - Pi2] = Vt2(e3, 255), qi2[t5 - Pi2] = Vt2(e3 + 8 >> 4, 15);
        Ci2 = 1;
      }
      return 1;
    }
    function dt2(t5) {
      var r3 = t5.ma, n3 = t5.U, i3 = t5.T;
      return e2(!(1 & t5.ka)), 0 >= n3 || 0 >= i3 ? 0 : (n3 = r3.Ib(t5, r3), null != r3.Jb && r3.Jb(t5, r3, n3), r3.Dc += n3, 1);
    }
    function pt2(t5) {
      t5.ma.memory = null;
    }
    function gt2(t5, e3, r3, n3) {
      return 47 != y3(t5, 8) ? 0 : (e3[0] = y3(t5, 14) + 1, r3[0] = y3(t5, 14) + 1, n3[0] = y3(t5, 1), 0 != y3(t5, 3) ? 0 : !t5.h);
    }
    function mt2(t5, e3) {
      if (4 > t5)
        return t5 + 1;
      var r3 = t5 - 2 >> 1;
      return (2 + (1 & t5) << r3) + y3(e3, r3) + 1;
    }
    function vt2(t5, e3) {
      return 120 < e3 ? e3 - 120 : 1 <= (r3 = ((r3 = $n2[e3 - 1]) >> 4) * t5 + (8 - (15 & r3))) ? r3 : 1;
      var r3;
    }
    function bt2(t5, e3, r3) {
      var n3 = L3(r3), i3 = t5[e3 += 255 & n3].g - 8;
      return 0 < i3 && (x2(r3, r3.u + 8), n3 = L3(r3), e3 += t5[e3].value, e3 += n3 & (1 << i3) - 1), x2(r3, r3.u + t5[e3].g), t5[e3].value;
    }
    function yt2(t5, r3, n3) {
      return n3.g += t5.g, n3.value += t5.value << r3 >>> 0, e2(8 >= n3.g), t5.g;
    }
    function wt2(t5, r3, n3) {
      var i3 = t5.xc;
      return e2((r3 = 0 == i3 ? 0 : t5.vc[t5.md * (n3 >> i3) + (r3 >> i3)]) < t5.Wb), t5.Ya[r3];
    }
    function Nt2(t5, r3, i3, a3) {
      var o3 = t5.ab, s3 = t5.c * r3, c4 = t5.C;
      r3 = c4 + r3;
      var u4 = i3, h4 = a3;
      for (a3 = t5.Ta, i3 = t5.Ua; 0 < o3--; ) {
        var l4 = t5.gc[o3], f4 = c4, d4 = r3, p4 = u4, g4 = h4, m4 = (h4 = a3, u4 = i3, l4.Ea);
        switch (e2(f4 < d4), e2(d4 <= l4.nc), l4.hc) {
          case 2:
            Gr(p4, g4, (d4 - f4) * m4, h4, u4);
            break;
          case 0:
            var v4 = f4, b4 = d4, y4 = h4, w4 = u4, N4 = (_3 = l4).Ea;
            0 == v4 && (Wr(p4, g4, null, null, 1, y4, w4), V2(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
            for (var L4 = 1 << _3.b, A4 = L4 - 1, x3 = q2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * x3; v4 < b4; ) {
              var P3 = S3, k3 = _3, I3 = 1;
              for (Vr(p4, g4, y4, w4 - N4, 1, y4, w4); I3 < N4; ) {
                var F3 = (I3 & ~A4) + L4;
                F3 > N4 && (F3 = N4), (0, Zr[P3[k3++] >> 8 & 15])(p4, g4 + +I3, y4, w4 + I3 - N4, F3 - I3, y4, w4 + I3), I3 = F3;
              }
              g4 += N4, w4 += N4, ++v4 & A4 || (_3 += x3);
            }
            d4 != l4.nc && n2(h4, u4 - m4, h4, u4 + (d4 - f4 - 1) * m4, m4);
            break;
          case 1:
            for (m4 = p4, b4 = g4, N4 = (p4 = l4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << l4.b) - 1)), v4 = q2(p4, l4.b), L4 = l4.K, l4 = l4.w + (f4 >> l4.b) * v4; f4 < d4; ) {
              for (A4 = L4, x3 = l4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; )
                Y2(A4[x3++], S3), $r(S3, m4, b4, g4, h4, u4), b4 += g4, u4 += g4;
              b4 < P3 && (Y2(A4[x3++], S3), $r(S3, m4, b4, N4, h4, u4), b4 += N4, u4 += N4), ++f4 & y4 || (l4 += v4);
            }
            break;
          case 3:
            if (p4 == h4 && g4 == u4 && 0 < l4.b) {
              for (b4 = h4, p4 = m4 = u4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * q2(l4.Ea, l4.b)), g4 = h4, y4 = u4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4)
                v4[w4] = g4[y4 + w4];
              for (w4 = N4 - 1; 0 <= w4; --w4)
                b4[p4 + w4] = v4[w4];
              Yr(l4, f4, d4, h4, m4, h4, u4);
            } else
              Yr(l4, f4, d4, p4, g4, h4, u4);
        }
        u4 = a3, h4 = i3;
      }
      h4 != i3 && n2(a3, i3, u4, h4, s3);
    }
    function Lt2(t5, r3) {
      var n3 = t5.V, i3 = t5.Ba + t5.c * t5.C, a3 = r3 - t5.C;
      if (e2(r3 <= t5.l.o), e2(16 >= a3), 0 < a3) {
        var o3 = t5.l, s3 = t5.Ta, c4 = t5.Ua, u4 = o3.width;
        if (Nt2(t5, a3, n3, i3), a3 = c4 = [c4], e2((n3 = t5.C) < (i3 = r3)), e2(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), n3 < o3.j) {
          var h4 = o3.j - n3;
          n3 = o3.j;
          a3[0] += h4 * u4;
        }
        if (n3 >= i3 ? n3 = 0 : (a3[0] += 4 * o3.v, o3.ka = n3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - n3, n3 = 1), n3) {
          if (c4 = c4[0], 11 > (n3 = t5.ca).S) {
            var l4 = n3.f.RGBA, f4 = (i3 = n3.S, a3 = o3.U, o3 = o3.T, h4 = l4.eb, l4.A), d4 = o3;
            for (l4 = l4.fb + t5.Ma * l4.A; 0 < d4--; ) {
              var p4 = s3, g4 = c4, m4 = a3, v4 = h4, b4 = l4;
              switch (i3) {
                case En2:
                  Qr(p4, g4, m4, v4, b4);
                  break;
                case qn2:
                  tn2(p4, g4, m4, v4, b4);
                  break;
                case Hn2:
                  tn2(p4, g4, m4, v4, b4), An2(v4, b4, 0, m4, 1, 0);
                  break;
                case Dn2:
                  nn2(p4, g4, m4, v4, b4);
                  break;
                case Rn2:
                  et2(p4, g4, m4, v4, b4, 1);
                  break;
                case Wn2:
                  et2(p4, g4, m4, v4, b4, 1), An2(v4, b4, 0, m4, 1, 0);
                  break;
                case Tn2:
                  et2(p4, g4, m4, v4, b4, 0);
                  break;
                case Vn2:
                  et2(p4, g4, m4, v4, b4, 0), An2(v4, b4, 1, m4, 1, 0);
                  break;
                case Un2:
                  en2(p4, g4, m4, v4, b4);
                  break;
                case Gn2:
                  en2(p4, g4, m4, v4, b4), xn2(v4, b4, m4, 1, 0);
                  break;
                case zn2:
                  rn2(p4, g4, m4, v4, b4);
                  break;
                default:
                  e2(0);
              }
              c4 += u4, l4 += f4;
            }
            t5.Ma += o3;
          } else
            alert("todo:EmitRescaledRowsYUVA");
          e2(t5.Ma <= n3.height);
        }
      }
      t5.C = r3, e2(t5.C <= t5.i);
    }
    function At2(t5) {
      var e3;
      if (0 < t5.ua)
        return 0;
      for (e3 = 0; e3 < t5.Wb; ++e3) {
        var r3 = t5.Ya[e3].G, n3 = t5.Ya[e3].H;
        if (0 < r3[1][n3[1] + 0].g || 0 < r3[2][n3[2] + 0].g || 0 < r3[3][n3[3] + 0].g)
          return 0;
      }
      return 1;
    }
    function xt2(t5, r3, n3, i3, a3, o3) {
      if (0 != t5.Z) {
        var s3 = t5.qd, c4 = t5.rd;
        for (e2(null != mi2[t5.Z]); r3 < n3; ++r3)
          mi2[t5.Z](s3, c4, i3, a3, i3, a3, o3), s3 = i3, c4 = a3, a3 += o3;
        t5.qd = s3, t5.rd = c4;
      }
    }
    function St2(t5, r3) {
      var n3 = t5.l.ma, i3 = 0 == n3.Z || 1 == n3.Z ? t5.l.j : t5.C;
      i3 = t5.C < i3 ? i3 : t5.C;
      if (e2(r3 <= t5.l.o), r3 > i3) {
        var a3 = t5.l.width, o3 = n3.ca, s3 = n3.tb + a3 * i3, c4 = t5.V, u4 = t5.Ba + t5.c * i3, h4 = t5.gc;
        e2(1 == t5.ab), e2(3 == h4[0].hc), Xr(h4[0], i3, r3, c4, u4, o3, s3), xt2(n3, i3, r3, o3, s3, a3);
      }
      t5.C = t5.Ma = r3;
    }
    function _t5(t5, r3, n3, i3, a3, o3, s3) {
      var c4 = t5.$ / i3, u4 = t5.$ % i3, h4 = t5.m, l4 = t5.s, f4 = n3 + t5.$, d4 = f4;
      a3 = n3 + i3 * a3;
      var p4 = n3 + i3 * o3, g4 = 280 + l4.ua, m4 = t5.Pb ? c4 : 16777216, v4 = 0 < l4.ua ? l4.Wa : null, b4 = l4.wc, y4 = f4 < p4 ? wt2(l4, u4, c4) : null;
      e2(t5.C < o3), e2(p4 <= a3);
      var w4 = false;
      t:
        for (; ; ) {
          for (; w4 || f4 < p4; ) {
            var N4 = 0;
            if (c4 >= m4) {
              var _3 = f4 - n3;
              e2((m4 = t5).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B3(m4.s.Wa, m4.s.vb), m4 = c4 + ti2;
            }
            if (u4 & b4 || (y4 = wt2(l4, u4, c4)), e2(null != y4), y4.Qb && (r3[f4] = y4.qb, w4 = true), !w4)
              if (S2(h4), y4.jc) {
                N4 = h4, _3 = r3;
                var P3 = f4, k3 = y4.pd[L3(N4) & Dr - 1];
                e2(y4.jc), 256 > k3.g ? (x2(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (x2(N4, N4.u + k3.g - 256), e2(256 <= k3.value), N4 = k3.value), 0 == N4 && (w4 = true);
              } else
                N4 = bt2(y4.G[0], y4.H[0], h4);
            if (h4.h)
              break;
            if (w4 || 256 > N4) {
              if (!w4)
                if (y4.nd)
                  r3[f4] = (y4.qb | N4 << 8) >>> 0;
                else {
                  if (S2(h4), w4 = bt2(y4.G[1], y4.H[1], h4), S2(h4), _3 = bt2(y4.G[2], y4.H[2], h4), P3 = bt2(y4.G[3], y4.H[3], h4), h4.h)
                    break;
                  r3[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
                }
              if (w4 = false, ++f4, ++u4 >= i3 && (u4 = 0, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t5, c4), null != v4))
                for (; d4 < f4; )
                  N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else if (280 > N4) {
              if (N4 = mt2(N4 - 256, h4), _3 = bt2(y4.G[4], y4.H[4], h4), S2(h4), _3 = vt2(i3, _3 = mt2(_3, h4)), h4.h)
                break;
              if (f4 - n3 < _3 || a3 - f4 < N4)
                break t;
              for (P3 = 0; P3 < N4; ++P3)
                r3[f4 + P3] = r3[f4 + P3 - _3];
              for (f4 += N4, u4 += N4; u4 >= i3; )
                u4 -= i3, ++c4, null != s3 && c4 <= o3 && !(c4 % 16) && s3(t5, c4);
              if (e2(f4 <= a3), u4 & b4 && (y4 = wt2(l4, u4, c4)), null != v4)
                for (; d4 < f4; )
                  N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else {
              if (!(N4 < g4))
                break t;
              for (w4 = N4 - 280, e2(null != v4); d4 < f4; )
                N4 = r3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
              N4 = f4, e2(!(w4 >>> (_3 = v4).Xa)), r3[N4] = _3.X[w4], w4 = true;
            }
            w4 || e2(h4.h == A3(h4));
          }
          if (t5.Pb && h4.h && f4 < a3)
            e2(t5.m.h), t5.a = 5, t5.m = t5.wd, t5.$ = t5.xd, 0 < t5.s.ua && B3(t5.s.vb, t5.s.Wa);
          else {
            if (h4.h)
              break t;
            null != s3 && s3(t5, c4 > o3 ? o3 : c4), t5.a = 0, t5.$ = f4 - n3;
          }
          return 1;
        }
      return t5.a = 3, 0;
    }
    function Pt2(t5) {
      e2(null != t5), t5.vc = null, t5.yc = null, t5.Ya = null;
      var r3 = t5.Wa;
      null != r3 && (r3.X = null), t5.vb = null, e2(null != t5);
    }
    function kt2() {
      var e3 = new or();
      return null == e3 ? null : (e3.a = 0, e3.xb = gi2, rt2("Predictor", "VP8LPredictors"), rt2("Predictor", "VP8LPredictors_C"), rt2("PredictorAdd", "VP8LPredictorsAdd"), rt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gr = G2, $r = J2, Qr = K2, tn2 = Z2, en2 = $2, rn2 = Q2, nn2 = tt2, t4.VP8LMapColor32b = Jr, t4.VP8LMapColor8b = Kr, e3);
    }
    function It2(t5, r3, n3, s3, c4) {
      var u4 = 1, f4 = [t5], p4 = [r3], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
      t:
        for (; ; ) {
          if (n3)
            for (; u4 && y3(g4, 1); ) {
              var w4 = f4, N4 = p4, A4 = s3, _3 = 1, P3 = A4.m, k3 = A4.gc[A4.ab], I3 = y3(P3, 2);
              if (A4.Oc & 1 << I3)
                u4 = 0;
              else {
                switch (A4.Oc |= 1 << I3, k3.hc = I3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++A4.ab, e2(4 >= A4.ab), I3) {
                  case 0:
                  case 1:
                    k3.b = y3(P3, 3) + 2, _3 = It2(q2(k3.Ea, k3.b), q2(k3.nc, k3.b), 0, A4, k3.K), k3.K = k3.K[0];
                    break;
                  case 3:
                    var F3, C3 = y3(P3, 8) + 1, j3 = 16 < C3 ? 0 : 4 < C3 ? 1 : 2 < C3 ? 2 : 3;
                    if (w4[0] = q2(k3.Ea, j3), k3.b = j3, F3 = _3 = It2(C3, 1, 0, A4, k3.K)) {
                      var B4, M3 = C3, E3 = k3, R3 = 1 << (8 >> E3.b), T3 = a2(R3);
                      if (null == T3)
                        F3 = 0;
                      else {
                        var U3 = E3.K[0], z3 = E3.w;
                        for (T3[0] = E3.K[0][0], B4 = 1; B4 < 1 * M3; ++B4)
                          T3[B4] = D2(U3[z3 + B4], T3[B4 - 1]);
                        for (; B4 < 4 * R3; ++B4)
                          T3[B4] = 0;
                        E3.K[0] = null, E3.K[0] = T3, F3 = 1;
                      }
                    }
                    _3 = F3;
                    break;
                  case 2:
                    break;
                  default:
                    e2(0);
                }
                u4 = _3;
              }
            }
          if (f4 = f4[0], p4 = p4[0], u4 && y3(g4, 1) && !(u4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
            s3.a = 3;
            break t;
          }
          var H5;
          if (H5 = u4)
            e: {
              var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p4, K3 = b4, Z3 = n3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, rt3 = 0, nt3 = Qn2[K3];
              r:
                for (; ; ) {
                  if (Z3 && y3($3, 1)) {
                    var it3 = y3($3, 3) + 2, at3 = q2(J3, it3), ot3 = q2(X3, it3), st3 = at3 * ot3;
                    if (!It2(at3, ot3, 0, Y3, tt3))
                      break r;
                    for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                      var ct3 = tt3[W3] >> 8 & 65535;
                      tt3[W3] = ct3, ct3 >= et3 && (et3 = ct3 + 1);
                    }
                  }
                  if ($3.h)
                    break r;
                  for (V3 = 0; 5 > V3; ++V3) {
                    var ut3 = Xn[V3];
                    !V3 && 0 < K3 && (ut3 += 1 << K3), rt3 < ut3 && (rt3 = ut3);
                  }
                  var ht3 = o2(et3 * nt3, l3), lt3 = et3, ft3 = o2(lt3, d3);
                  if (null == ft3)
                    var dt3 = null;
                  else
                    e2(65536 >= lt3), dt3 = ft3;
                  var pt3 = a2(rt3);
                  if (null == dt3 || null == pt3 || null == ht3) {
                    Y3.a = 1;
                    break r;
                  }
                  var gt3 = ht3;
                  for (W3 = G3 = 0; W3 < et3; ++W3) {
                    var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                    for (V3 = 0; 5 > V3; ++V3) {
                      ut3 = Xn[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ut3 += 1 << K3);
                      n: {
                        var At3, xt3 = ut3, St3 = Y3, kt3 = pt3, Ft4 = gt3, Ct3 = G3, jt3 = 0, Ot3 = St3.m, Bt3 = y3(Ot3, 1);
                        if (i2(kt3, 0, 0, xt3), Bt3) {
                          var Mt3 = y3(Ot3, 1) + 1, Et4 = y3(Ot3, 1), qt3 = y3(Ot3, 0 == Et4 ? 1 : 8);
                          kt3[qt3] = 1, 2 == Mt3 && (kt3[qt3 = y3(Ot3, 8)] = 1);
                          var Dt3 = 1;
                        } else {
                          var Rt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                          if (19 < Tt3) {
                            St3.a = 3;
                            var Ut3 = 0;
                            break n;
                          }
                          for (At3 = 0; At3 < Tt3; ++At3)
                            Rt3[Zn[At3]] = y3(Ot3, 3);
                          var zt4 = void 0, Ht3 = void 0, Wt3 = St3, Vt3 = Rt3, Gt3 = xt3, Yt3 = kt3, Jt3 = 0, Xt4 = Wt3.m, Kt3 = 8, Zt3 = o2(128, l3);
                          i:
                            for (; h3(Zt3, 0, 7, Vt3, 19); ) {
                              if (y3(Xt4, 1)) {
                                var $t3 = 2 + 2 * y3(Xt4, 3);
                                if ((zt4 = 2 + y3(Xt4, $t3)) > Gt3)
                                  break i;
                              } else
                                zt4 = Gt3;
                              for (Ht3 = 0; Ht3 < Gt3 && zt4--; ) {
                                S2(Xt4);
                                var Qt3 = Zt3[0 + (127 & L3(Xt4))];
                                x2(Xt4, Xt4.u + Qt3.g);
                                var te3 = Qt3.value;
                                if (16 > te3)
                                  Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                                else {
                                  var ee3 = 16 == te3, re3 = te3 - 16, ne3 = Jn[re3], ie3 = y3(Xt4, Yn2[re3]) + ne3;
                                  if (Ht3 + ie3 > Gt3)
                                    break i;
                                  for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; )
                                    Yt3[Ht3++] = ae3;
                                }
                              }
                              Jt3 = 1;
                              break i;
                            }
                          Jt3 || (Wt3.a = 3), Dt3 = Jt3;
                        }
                        (Dt3 = Dt3 && !Ot3.h) && (jt3 = h3(Ft4, Ct3, 8, kt3, xt3)), Dt3 && 0 != jt3 ? Ut3 = jt3 : (St3.a = 3, Ut3 = 0);
                      }
                      if (0 == Ut3)
                        break r;
                      if (Nt3 && 1 == Kn2[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += Ut3, 3 >= V3) {
                        var oe3, se3 = pt3[0];
                        for (oe3 = 1; oe3 < ut3; ++oe3)
                          pt3[oe3] > se3 && (se3 = pt3[oe3]);
                        Lt3 += se3;
                      }
                    }
                    if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                      var ce3, ue3 = mt3;
                      for (ce3 = 0; ce3 < Dr; ++ce3) {
                        var he3 = ce3, le3 = ue3.pd[he3], fe3 = ue3.G[0][ue3.H[0] + he3];
                        256 <= fe3.value ? (le3.g = fe3.g + 256, le3.value = fe3.value) : (le3.g = 0, le3.value = 0, he3 >>= yt2(fe3, 8, le3), he3 >>= yt2(ue3.G[1][ue3.H[1] + he3], 16, le3), he3 >>= yt2(ue3.G[2][ue3.H[2] + he3], 0, le3), yt2(ue3.G[3][ue3.H[3] + he3], 24, le3));
                      }
                    }
                  }
                  Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = ht3, H5 = 1;
                  break e;
                }
              H5 = 0;
            }
          if (!(u4 = H5)) {
            s3.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
              s3.a = 1, u4 = 0;
              break t;
            }
          } else
            m4.ua = 0;
          var de3 = s3, pe3 = f4, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
          if (de3.c = pe3, de3.i = ge3, me3.md = q2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, n3) {
            s3.xb = pi2;
            break t;
          }
          if (null == (v4 = a2(f4 * p4))) {
            s3.a = 1, u4 = 0;
            break t;
          }
          u4 = (u4 = _t5(s3, v4, 0, f4, p4, p4, null)) && !g4.h;
          break t;
        }
      return u4 ? (null != c4 ? c4[0] = v4 : (e2(null == v4), e2(n3)), s3.$ = 0, n3 || Pt2(m4)) : Pt2(m4), u4;
    }
    function Ft3(t5, r3) {
      var n3 = t5.c * t5.i, i3 = n3 + r3 + 16 * r3;
      return e2(t5.c <= r3), t5.V = a2(i3), null == t5.V ? (t5.Ta = null, t5.Ua = 0, t5.a = 1, 0) : (t5.Ta = t5.V, t5.Ua = t5.Ba + n3 + r3, 1);
    }
    function Ct2(t5, r3) {
      var n3 = t5.C, i3 = r3 - n3, a3 = t5.V, o3 = t5.Ba + t5.c * n3;
      for (e2(r3 <= t5.l.o); 0 < i3; ) {
        var s3 = 16 < i3 ? 16 : i3, c4 = t5.l.ma, u4 = t5.l.width, h4 = u4 * s3, l4 = c4.ca, f4 = c4.tb + u4 * n3, d4 = t5.Ta, p4 = t5.Ua;
        Nt2(t5, s3, a3, o3), _n2(d4, p4, l4, f4, h4), xt2(c4, n3, n3 + s3, l4, f4, u4), i3 -= s3, a3 += s3 * t5.c, n3 += s3;
      }
      e2(n3 == r3), t5.C = t5.Ma = r3;
    }
    function jt2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
    }
    function Mt2() {
      this.Yb = function() {
        var t5 = [];
        return function t6(e3, r3, n3) {
          for (var i3 = n3[r3], a3 = 0; a3 < i3 && (e3.push(n3.length > r3 + 1 ? [] : 0), !(n3.length < r3 + 1)); a3++)
            t6(e3[a3], r3 + 1, n3);
        }(t5, 0, [3, 11]), t5;
      }();
    }
    function Et3() {
      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
    }
    function qt2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
    }
    function Dt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Rt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function Ut2() {
      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function zt3() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.ya = Array(new Ut2()), this.aa = 0, this.l = new Gt2();
    }
    function Ht2() {
      this.y = a2(16), this.f = a2(8), this.ea = a2(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new jt2(), this.Kc = new Ot2(), this.ed = new qt2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new zt3(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new Et3(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Rt2()), this.sb = 0, this.wa = Array(new Dt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ut2()), this.L = this.aa = 0, this.gd = s2([4, 2], Dt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t5 = new Wt2();
      return null != t5 && (t5.a = 0, t5.sc = "OK", t5.cb = 0, t5.Xb = 0, ni2 || (ni2 = Zt2)), t5;
    }
    function Jt2(t5, e3, r3) {
      return 0 == t5.a && (t5.a = e3, t5.sc = r3, t5.cb = 0), 0;
    }
    function Xt3(t5, e3, r3) {
      return 3 <= r3 && 157 == t5[e3 + 0] && 1 == t5[e3 + 1] && 42 == t5[e3 + 2];
    }
    function Kt2(t5, r3) {
      if (null == t5)
        return 0;
      if (t5.a = 0, t5.sc = "OK", null == r3)
        return Jt2(t5, 2, "null VP8Io passed to VP8GetHeaders()");
      var n3 = r3.data, a3 = r3.w, o3 = r3.ha;
      if (4 > o3)
        return Jt2(t5, 7, "Truncated header.");
      var s3 = n3[a3 + 0] | n3[a3 + 1] << 8 | n3[a3 + 2] << 16, c4 = t5.Od;
      if (c4.Rb = !(1 & s3), c4.td = s3 >> 1 & 7, c4.yd = s3 >> 4 & 1, c4.ub = s3 >> 5, 3 < c4.td)
        return Jt2(t5, 3, "Incorrect keyframe parameters.");
      if (!c4.yd)
        return Jt2(t5, 4, "Frame not displayable.");
      a3 += 3, o3 -= 3;
      var u4 = t5.Kc;
      if (c4.Rb) {
        if (7 > o3)
          return Jt2(t5, 7, "cannot parse picture header");
        if (!Xt3(n3, a3, o3))
          return Jt2(t5, 3, "Bad code word");
        u4.c = 16383 & (n3[a3 + 4] << 8 | n3[a3 + 3]), u4.Td = n3[a3 + 4] >> 6, u4.i = 16383 & (n3[a3 + 6] << 8 | n3[a3 + 5]), u4.Ud = n3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t5.za = u4.c + 15 >> 4, t5.Ub = u4.i + 15 >> 4, r3.width = u4.c, r3.height = u4.i, r3.Da = 0, r3.j = 0, r3.v = 0, r3.va = r3.width, r3.o = r3.height, r3.da = 0, r3.ib = r3.width, r3.hb = r3.height, r3.U = r3.width, r3.T = r3.height, i2((s3 = t5.Pa).jb, 0, 255, s3.jb.length), e2(null != (s3 = t5.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
      }
      if (c4.ub > o3)
        return Jt2(t5, 7, "bad partition length");
      p3(s3 = t5.m, n3, a3, c4.ub), a3 += c4.ub, o3 -= c4.ub, c4.Rb && (u4.Ld = P2(s3), u4.Kd = P2(s3)), u4 = t5.Qa;
      var h4, l4 = t5.Pa;
      if (e2(null != s3), e2(null != u4), u4.Cb = P2(s3), u4.Cb) {
        if (u4.Bb = P2(s3), P2(s3)) {
          for (u4.Fb = P2(s3), h4 = 0; 4 > h4; ++h4)
            u4.Zb[h4] = P2(s3) ? m3(s3, 7) : 0;
          for (h4 = 0; 4 > h4; ++h4)
            u4.Lb[h4] = P2(s3) ? m3(s3, 6) : 0;
        }
        if (u4.Bb)
          for (h4 = 0; 3 > h4; ++h4)
            l4.jb[h4] = P2(s3) ? g3(s3, 8) : 255;
      } else
        u4.Bb = 0;
      if (s3.Ka)
        return Jt2(t5, 3, "cannot parse segment header");
      if ((u4 = t5.ed).zd = P2(s3), u4.Tb = g3(s3, 6), u4.wb = g3(s3, 3), u4.Pc = P2(s3), u4.Pc && P2(s3)) {
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.vd[l4] = m3(s3, 6));
        for (l4 = 0; 4 > l4; ++l4)
          P2(s3) && (u4.od[l4] = m3(s3, 6));
      }
      if (t5.L = 0 == u4.Tb ? 0 : u4.zd ? 1 : 2, s3.Ka)
        return Jt2(t5, 3, "cannot parse filter header");
      var f4 = o3;
      if (o3 = h4 = a3, a3 = h4 + f4, u4 = f4, t5.Xb = (1 << g3(t5.m, 2)) - 1, f4 < 3 * (l4 = t5.Xb))
        n3 = 7;
      else {
        for (h4 += 3 * l4, u4 -= 3 * l4, f4 = 0; f4 < l4; ++f4) {
          var d4 = n3[o3 + 0] | n3[o3 + 1] << 8 | n3[o3 + 2] << 16;
          d4 > u4 && (d4 = u4), p3(t5.Jc[+f4], n3, h4, d4), h4 += d4, u4 -= d4, o3 += 3;
        }
        p3(t5.Jc[+l4], n3, h4, u4), n3 = h4 < a3 ? 0 : 5;
      }
      if (0 != n3)
        return Jt2(t5, n3, "cannot parse partitions");
      for (n3 = g3(h4 = t5.m, 7), o3 = P2(h4) ? m3(h4, 4) : 0, a3 = P2(h4) ? m3(h4, 4) : 0, u4 = P2(h4) ? m3(h4, 4) : 0, l4 = P2(h4) ? m3(h4, 4) : 0, h4 = P2(h4) ? m3(h4, 4) : 0, f4 = t5.Qa, d4 = 0; 4 > d4; ++d4) {
        if (f4.Cb) {
          var v4 = f4.Zb[d4];
          f4.Fb || (v4 += n3);
        } else {
          if (0 < d4) {
            t5.pb[d4] = t5.pb[0];
            continue;
          }
          v4 = n3;
        }
        var b4 = t5.pb[d4];
        b4.Sc[0] = ei2[Vt2(v4 + o3, 127)], b4.Sc[1] = ri2[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ei2[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ri2[Vt2(v4 + u4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ei2[Vt2(v4 + l4, 117)], b4.Qc[1] = ri2[Vt2(v4 + h4, 127)], b4.lc = v4 + h4;
      }
      if (!c4.Rb)
        return Jt2(t5, 4, "Not a key frame.");
      for (P2(s3), c4 = t5.Pa, n3 = 0; 4 > n3; ++n3) {
        for (o3 = 0; 8 > o3; ++o3)
          for (a3 = 0; 3 > a3; ++a3)
            for (u4 = 0; 11 > u4; ++u4)
              l4 = k2(s3, ui2[n3][o3][a3][u4]) ? g3(s3, 8) : si2[n3][o3][a3][u4], c4.Wc[n3][o3].Yb[a3][u4] = l4;
        for (o3 = 0; 17 > o3; ++o3)
          c4.Xc[n3][o3] = c4.Wc[n3][hi2[o3]];
      }
      return t5.kc = P2(s3), t5.kc && (t5.Bd = g3(s3, 8)), t5.cb = 1;
    }
    function Zt2(t5, e3, r3, n3, i3, a3, o3) {
      var s3 = e3[i3].Yb[r3];
      for (r3 = 0; 16 > i3; ++i3) {
        if (!k2(t5, s3[r3 + 0]))
          return i3;
        for (; !k2(t5, s3[r3 + 1]); )
          if (s3 = e3[++i3].Yb[0], r3 = 0, 16 == i3)
            return 16;
        var c4 = e3[i3 + 1].Yb;
        if (k2(t5, s3[r3 + 2])) {
          var u4 = t5, h4 = 0;
          if (k2(u4, (f4 = s3)[(l4 = r3) + 3]))
            if (k2(u4, f4[l4 + 6])) {
              for (s3 = 0, l4 = 2 * (h4 = k2(u4, f4[l4 + 8])) + (f4 = k2(u4, f4[l4 + 9 + h4])), h4 = 0, f4 = ii2[l4]; f4[s3]; ++s3)
                h4 += h4 + k2(u4, f4[s3]);
              h4 += 3 + (8 << l4);
            } else
              k2(u4, f4[l4 + 7]) ? (h4 = 7 + 2 * k2(u4, 165), h4 += k2(u4, 145)) : h4 = 5 + k2(u4, 159);
          else
            h4 = k2(u4, f4[l4 + 4]) ? 3 + k2(u4, f4[l4 + 5]) : 2;
          s3 = c4[2];
        } else
          h4 = 1, s3 = c4[1];
        c4 = o3 + ai2[i3], 0 > (u4 = t5).b && _2(u4);
        var l4, f4 = u4.b, d4 = (l4 = u4.Ca >> 1) - (u4.I >> f4) >> 31;
        --u4.b, u4.Ca += d4, u4.Ca |= 1, u4.I -= (l4 + 1 & d4) << f4, a3[c4] = ((h4 ^ d4) - d4) * n3[(0 < i3) + 0];
      }
      return 16;
    }
    function $t2(t5) {
      var e3 = t5.rb[t5.sb - 1];
      e3.la = 0, e3.Na = 0, i2(t5.zc, 0, 0, t5.zc.length), t5.ja = 0;
    }
    function Qt2(t5, r3) {
      if (null == t5)
        return 0;
      if (null == r3)
        return Jt2(t5, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!t5.cb && !Kt2(t5, r3))
        return 0;
      if (e2(t5.cb), null == r3.ac || r3.ac(r3)) {
        r3.ob && (t5.L = 0);
        var s3 = Ri2[t5.L];
        if (2 == t5.L ? (t5.yb = 0, t5.zb = 0) : (t5.yb = r3.v - s3 >> 4, t5.zb = r3.j - s3 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = r3.o + 15 + s3 >> 4, t5.Hb = r3.va + 15 + s3 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {
          var c4 = t5.ed;
          for (s3 = 0; 4 > s3; ++s3) {
            var u4;
            if (t5.Qa.Cb) {
              var h4 = t5.Qa.Lb[s3];
              t5.Qa.Fb || (h4 += c4.Tb);
            } else
              h4 = c4.Tb;
            for (u4 = 0; 1 >= u4; ++u4) {
              var l4 = t5.gd[s3][u4], f4 = h4;
              if (c4.Pc && (f4 += c4.vd[0], u4 && (f4 += c4.od[0])), 0 < (f4 = 0 > f4 ? 0 : 63 < f4 ? 63 : f4)) {
                var d4 = f4;
                0 < c4.wb && ((d4 = 4 < c4.wb ? d4 >> 2 : d4 >> 1) > 9 - c4.wb && (d4 = 9 - c4.wb)), 1 > d4 && (d4 = 1), l4.dd = d4, l4.tc = 2 * f4 + d4, l4.ld = 40 <= f4 ? 2 : 15 <= f4 ? 1 : 0;
              } else
                l4.tc = 0;
              l4.La = u4;
            }
          }
        }
        s3 = 0;
      } else
        Jt2(t5, 6, "Frame setup failed"), s3 = t5.a;
      if (s3 = 0 == s3) {
        if (s3) {
          t5.$c = 0, 0 < t5.Aa || (t5.Ic = Ui2);
          t: {
            s3 = t5.Ic;
            c4 = 4 * (d4 = t5.za);
            var p4 = 32 * d4, g4 = d4 + 1, m4 = 0 < t5.L ? d4 * (0 < t5.Aa ? 2 : 1) : 0, v4 = (2 == t5.Aa ? 2 : 1) * d4;
            if ((l4 = c4 + 832 + (u4 = 3 * (16 * s3 + Ri2[t5.L]) / 2 * p4) + (h4 = null != t5.Fa && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != l4)
              s3 = 0;
            else {
              if (l4 > t5.Vb) {
                if (t5.Vb = 0, t5.Ec = a2(l4), t5.Fc = 0, null == t5.Ec) {
                  s3 = Jt2(t5, 1, "no memory during frame initialization.");
                  break t;
                }
                t5.Vb = l4;
              }
              l4 = t5.Ec, f4 = t5.Fc, t5.Ac = l4, t5.Bc = f4, f4 += c4, t5.Gd = o2(p4, Ht2), t5.Hd = 0, t5.rb = o2(g4 + 1, Rt2), t5.sb = 1, t5.wa = m4 ? o2(m4, Dt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d4), e2(true), t5.oc = l4, t5.pc = f4, f4 += 832, t5.ya = o2(v4, Ut2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, 2 == t5.Aa && (t5.D.aa += d4), t5.R = 16 * d4, t5.B = 8 * d4, d4 = (p4 = Ri2[t5.L]) * t5.R, p4 = p4 / 2 * t5.B, t5.sa = l4, t5.ta = f4 + d4, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s3 * t5.R + p4, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s3 * t5.B + p4, t5.$c = 0, f4 += u4, t5.mb = h4 ? l4 : null, t5.nb = h4 ? f4 : null, e2(f4 + h4 <= t5.Fc + t5.Vb), $t2(t5), i2(t5.Ac, t5.Bc, 0, c4), s3 = 1;
            }
          }
          if (s3) {
            if (r3.ka = 0, r3.y = t5.sa, r3.O = t5.ta, r3.f = t5.qa, r3.N = t5.ra, r3.ea = t5.Ha, r3.Vd = t5.Ia, r3.fa = t5.R, r3.Rc = t5.B, r3.F = null, r3.J = 0, !Cn2) {
              for (s3 = -255; 255 >= s3; ++s3)
                Pn2[255 + s3] = 0 > s3 ? -s3 : s3;
              for (s3 = -1020; 1020 >= s3; ++s3)
                kn2[1020 + s3] = -128 > s3 ? -128 : 127 < s3 ? 127 : s3;
              for (s3 = -112; 112 >= s3; ++s3)
                In2[112 + s3] = -16 > s3 ? -16 : 15 < s3 ? 15 : s3;
              for (s3 = -255; 510 >= s3; ++s3)
                Fn2[255 + s3] = 0 > s3 ? 0 : 255 < s3 ? 255 : s3;
              Cn2 = 1;
            }
            an2 = ue2, on2 = ae2, cn2 = oe2, un2 = se2, hn2 = ce2, sn2 = ie2, ln2 = Je2, fn3 = Xe2, dn2 = $e2, pn2 = Qe2, gn2 = Ke2, mn2 = Ze2, vn2 = tr, bn2 = er, yn2 = ze2, wn2 = He2, Nn2 = We2, Ln2 = Ve2, fi2[0] = xe2, fi2[1] = le2, fi2[2] = Le2, fi2[3] = Ae2, fi2[4] = Se2, fi2[5] = Pe2, fi2[6] = _e2, fi2[7] = ke2, fi2[8] = Fe2, fi2[9] = Ie2, li2[0] = ve2, li2[1] = de2, li2[2] = pe2, li2[3] = ge2, li2[4] = be2, li2[5] = ye2, li2[6] = we2, di2[0] = Be2, di2[1] = fe2, di2[2] = Ce2, di2[3] = je2, di2[4] = Ee2, di2[5] = Me2, di2[6] = qe2, s3 = 1;
          } else
            s3 = 0;
        }
        s3 && (s3 = function(t6, r4) {
          for (t6.M = 0; t6.M < t6.Va; ++t6.M) {
            var o3, s4 = t6.Jc[t6.M & t6.Xb], c5 = t6.m, u5 = t6;
            for (o3 = 0; o3 < u5.za; ++o3) {
              var h5 = c5, l5 = u5, f5 = l5.Ac, d5 = l5.Bc + 4 * o3, p5 = l5.zc, g5 = l5.ya[l5.aa + o3];
              if (l5.Qa.Bb ? g5.$b = k2(h5, l5.Pa.jb[0]) ? 2 + k2(h5, l5.Pa.jb[2]) : k2(h5, l5.Pa.jb[1]) : g5.$b = 0, l5.kc && (g5.Ad = k2(h5, l5.Bd)), g5.Za = !k2(h5, 145) + 0, g5.Za) {
                var m5 = g5.Ob, v5 = 0;
                for (l5 = 0; 4 > l5; ++l5) {
                  var b4, y4 = p5[0 + l5];
                  for (b4 = 0; 4 > b4; ++b4) {
                    y4 = ci2[f5[d5 + b4]][y4];
                    for (var w4 = oi2[k2(h5, y4[0])]; 0 < w4; )
                      w4 = oi2[2 * w4 + k2(h5, y4[w4])];
                    y4 = -w4, f5[d5 + b4] = y4;
                  }
                  n2(m5, v5, f5, d5, 4), v5 += 4, p5[0 + l5] = y4;
                }
              } else
                y4 = k2(h5, 156) ? k2(h5, 128) ? 1 : 3 : k2(h5, 163) ? 2 : 0, g5.Ob[0] = y4, i2(f5, d5, y4, 4), i2(p5, 0, y4, 4);
              g5.Dd = k2(h5, 142) ? k2(h5, 114) ? k2(h5, 183) ? 1 : 3 : 2 : 0;
            }
            if (u5.m.Ka)
              return Jt2(t6, 7, "Premature end-of-partition0 encountered.");
            for (; t6.ja < t6.za; ++t6.ja) {
              if (u5 = s4, h5 = (c5 = t6).rb[c5.sb - 1], f5 = c5.rb[c5.sb + c5.ja], o3 = c5.ya[c5.aa + c5.ja], d5 = c5.kc ? o3.Ad : 0)
                h5.la = f5.la = 0, o3.Za || (h5.Na = f5.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
              else {
                var N4, L4;
                h5 = f5, f5 = u5, d5 = c5.Pa.Xc, p5 = c5.ya[c5.aa + c5.ja], g5 = c5.pb[p5.$b];
                if (l5 = p5.ad, m5 = 0, v5 = c5.rb[c5.sb - 1], y4 = b4 = 0, i2(l5, m5, 0, 384), p5.Za)
                  var A4 = 0, x3 = d5[3];
                else {
                  w4 = a2(16);
                  var S3 = h5.Na + v5.Na;
                  if (S3 = ni2(f5, d5[1], S3, g5.Eb, 0, w4, 0), h5.Na = v5.Na = (0 < S3) + 0, 1 < S3)
                    an2(w4, 0, l5, m5);
                  else {
                    var _3 = w4[0] + 3 >> 3;
                    for (w4 = 0; 256 > w4; w4 += 16)
                      l5[m5 + w4] = _3;
                  }
                  A4 = 1, x3 = d5[0];
                }
                var P3 = 15 & h5.la, I3 = 15 & v5.la;
                for (w4 = 0; 4 > w4; ++w4) {
                  var F3 = 1 & I3;
                  for (_3 = L4 = 0; 4 > _3; ++_3)
                    P3 = P3 >> 1 | (F3 = (S3 = ni2(f5, x3, S3 = F3 + (1 & P3), g5.Sc, A4, l5, m5)) > A4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                  P3 >>= 4, I3 = I3 >> 1 | F3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                }
                for (x3 = P3, A4 = I3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                  for (L4 = 0, P3 = h5.la >> 4 + N4, I3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                    for (F3 = 1 & I3, _3 = 0; 2 > _3; ++_3)
                      S3 = F3 + (1 & P3), P3 = P3 >> 1 | (F3 = 0 < (S3 = ni2(f5, d5[2], S3, g5.Qc, 0, l5, m5))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != l5[m5 + 0]), m5 += 16;
                    P3 >>= 2, I3 = I3 >> 1 | F3 << 5;
                  }
                  y4 |= L4 << 4 * N4, x3 |= P3 << 4 << N4, A4 |= (240 & I3) << N4;
                }
                h5.la = x3, v5.la = A4, p5.Hc = b4, p5.Gc = y4, p5.ia = 43690 & y4 ? 0 : g5.ia, d5 = !(b4 | y4);
              }
              if (0 < c5.L && (c5.wa[c5.Y + c5.ja] = c5.gd[o3.$b][o3.Za], c5.wa[c5.Y + c5.ja].La |= !d5), u5.Ka)
                return Jt2(t6, 7, "Premature end-of-file encountered.");
            }
            if ($t2(t6), c5 = r4, u5 = 1, o3 = (s4 = t6).D, h5 = 0 < s4.L && s4.M >= s4.zb && s4.M <= s4.Va, 0 == s4.Aa)
              t: {
                if (o3.M = s4.M, o3.uc = h5, Or(s4, o3), u5 = 1, o3 = (L4 = s4.D).Nb, h5 = (y4 = Ri2[s4.L]) * s4.R, f5 = y4 / 2 * s4.B, w4 = 16 * o3 * s4.R, _3 = 8 * o3 * s4.B, d5 = s4.sa, p5 = s4.ta - h5 + w4, g5 = s4.qa, l5 = s4.ra - f5 + _3, m5 = s4.Ha, v5 = s4.Ia - f5 + _3, I3 = 0 == (P3 = L4.M), b4 = P3 >= s4.Va - 1, 2 == s4.Aa && Or(s4, L4), L4.uc)
                  for (F3 = (S3 = s4).D.M, e2(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                    A4 = L4, x3 = F3;
                    var C3 = (j3 = (U3 = S3).D).Nb;
                    N4 = U3.R;
                    var j3 = j3.wa[j3.Y + A4], O3 = U3.sa, B4 = U3.ta + 16 * C3 * N4 + 16 * A4, M3 = j3.dd, E3 = j3.tc;
                    if (0 != E3)
                      if (e2(3 <= E3), 1 == U3.L)
                        0 < A4 && wn2(O3, B4, N4, E3 + 4), j3.La && Ln2(O3, B4, N4, E3), 0 < x3 && yn2(O3, B4, N4, E3 + 4), j3.La && Nn2(O3, B4, N4, E3);
                      else {
                        var q3 = U3.B, D3 = U3.qa, R3 = U3.ra + 8 * C3 * q3 + 8 * A4, T3 = U3.Ha, U3 = U3.Ia + 8 * C3 * q3 + 8 * A4;
                        C3 = j3.ld;
                        0 < A4 && (fn3(O3, B4, N4, E3 + 4, M3, C3), pn2(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (mn2(O3, B4, N4, E3, M3, C3), bn2(D3, R3, T3, U3, q3, E3, M3, C3)), 0 < x3 && (ln2(O3, B4, N4, E3 + 4, M3, C3), dn2(D3, R3, T3, U3, q3, E3 + 4, M3, C3)), j3.La && (gn2(O3, B4, N4, E3, M3, C3), vn2(D3, R3, T3, U3, q3, E3, M3, C3));
                      }
                  }
                if (s4.ia && alert("todo:DitherRow"), null != c5.put) {
                  if (L4 = 16 * P3, P3 = 16 * (P3 + 1), I3 ? (c5.y = s4.sa, c5.O = s4.ta + w4, c5.f = s4.qa, c5.N = s4.ra + _3, c5.ea = s4.Ha, c5.W = s4.Ia + _3) : (L4 -= y4, c5.y = d5, c5.O = p5, c5.f = g5, c5.N = l5, c5.ea = m5, c5.W = v5), b4 || (P3 -= y4), P3 > c5.o && (P3 = c5.o), c5.F = null, c5.J = null, null != s4.Fa && 0 < s4.Fa.length && L4 < P3 && (c5.J = lr(s4, c5, L4, P3 - L4), c5.F = s4.mb, null == c5.F && 0 == c5.F.length)) {
                    u5 = Jt2(s4, 3, "Could not decode alpha data.");
                    break t;
                  }
                  L4 < c5.j && (y4 = c5.j - L4, L4 = c5.j, e2(!(1 & y4)), c5.O += s4.R * y4, c5.N += s4.B * (y4 >> 1), c5.W += s4.B * (y4 >> 1), null != c5.F && (c5.J += c5.width * y4)), L4 < P3 && (c5.O += c5.v, c5.N += c5.v >> 1, c5.W += c5.v >> 1, null != c5.F && (c5.J += c5.v), c5.ka = L4 - c5.j, c5.U = c5.va - c5.v, c5.T = P3 - L4, u5 = c5.put(c5));
                }
                o3 + 1 != s4.Ic || b4 || (n2(s4.sa, s4.ta - h5, d5, p5 + 16 * s4.R, h5), n2(s4.qa, s4.ra - f5, g5, l5 + 8 * s4.B, f5), n2(s4.Ha, s4.Ia - f5, m5, v5 + 8 * s4.B, f5));
              }
            if (!u5)
              return Jt2(t6, 6, "Output aborted.");
          }
          return 1;
        }(t5, r3)), null != r3.bc && r3.bc(r3), s3 &= 1;
      }
      return s3 ? (t5.cb = 0, s3) : 0;
    }
    function te2(t5, e3, r3, n3, i3) {
      i3 = t5[e3 + r3 + 32 * n3] + (i3 >> 3), t5[e3 + r3 + 32 * n3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
    }
    function ee2(t5, e3, r3, n3, i3, a3) {
      te2(t5, e3, 0, r3, n3 + i3), te2(t5, e3, 1, r3, n3 + a3), te2(t5, e3, 2, r3, n3 - a3), te2(t5, e3, 3, r3, n3 - i3);
    }
    function re2(t5) {
      return (20091 * t5 >> 16) + t5;
    }
    function ne2(t5, e3, r3, n3) {
      var i3, o3 = 0, s3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var c4 = t5[e3 + 0] + t5[e3 + 8], u4 = t5[e3 + 0] - t5[e3 + 8], h4 = (35468 * t5[e3 + 4] >> 16) - re2(t5[e3 + 12]), l4 = re2(t5[e3 + 4]) + (35468 * t5[e3 + 12] >> 16);
        s3[o3 + 0] = c4 + l4, s3[o3 + 1] = u4 + h4, s3[o3 + 2] = u4 - h4, s3[o3 + 3] = c4 - l4, o3 += 4, e3++;
      }
      for (i3 = o3 = 0; 4 > i3; ++i3)
        c4 = (t5 = s3[o3 + 0] + 4) + s3[o3 + 8], u4 = t5 - s3[o3 + 8], h4 = (35468 * s3[o3 + 4] >> 16) - re2(s3[o3 + 12]), te2(r3, n3, 0, 0, c4 + (l4 = re2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), te2(r3, n3, 1, 0, u4 + h4), te2(r3, n3, 2, 0, u4 - h4), te2(r3, n3, 3, 0, c4 - l4), o3++, n3 += 32;
    }
    function ie2(t5, e3, r3, n3) {
      var i3 = t5[e3 + 0] + 4, a3 = 35468 * t5[e3 + 4] >> 16, o3 = re2(t5[e3 + 4]), s3 = 35468 * t5[e3 + 1] >> 16;
      ee2(r3, n3, 0, i3 + o3, t5 = re2(t5[e3 + 1]), s3), ee2(r3, n3, 1, i3 + a3, t5, s3), ee2(r3, n3, 2, i3 - a3, t5, s3), ee2(r3, n3, 3, i3 - o3, t5, s3);
    }
    function ae2(t5, e3, r3, n3, i3) {
      ne2(t5, e3, r3, n3), i3 && ne2(t5, e3 + 16, r3, n3 + 4);
    }
    function oe2(t5, e3, r3, n3) {
      on2(t5, e3 + 0, r3, n3, 1), on2(t5, e3 + 32, r3, n3 + 128, 1);
    }
    function se2(t5, e3, r3, n3) {
      var i3;
      for (t5 = t5[e3 + 0] + 4, i3 = 0; 4 > i3; ++i3)
        for (e3 = 0; 4 > e3; ++e3)
          te2(r3, n3, e3, i3, t5);
    }
    function ce2(t5, e3, r3, n3) {
      t5[e3 + 0] && un2(t5, e3 + 0, r3, n3), t5[e3 + 16] && un2(t5, e3 + 16, r3, n3 + 4), t5[e3 + 32] && un2(t5, e3 + 32, r3, n3 + 128), t5[e3 + 48] && un2(t5, e3 + 48, r3, n3 + 128 + 4);
    }
    function ue2(t5, e3, r3, n3) {
      var i3, o3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var s3 = t5[e3 + 0 + i3] + t5[e3 + 12 + i3], c4 = t5[e3 + 4 + i3] + t5[e3 + 8 + i3], u4 = t5[e3 + 4 + i3] - t5[e3 + 8 + i3], h4 = t5[e3 + 0 + i3] - t5[e3 + 12 + i3];
        o3[0 + i3] = s3 + c4, o3[8 + i3] = s3 - c4, o3[4 + i3] = h4 + u4, o3[12 + i3] = h4 - u4;
      }
      for (i3 = 0; 4 > i3; ++i3)
        s3 = (t5 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], c4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], u4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], h4 = t5 - o3[3 + 4 * i3], r3[n3 + 0] = s3 + c4 >> 3, r3[n3 + 16] = h4 + u4 >> 3, r3[n3 + 32] = s3 - c4 >> 3, r3[n3 + 48] = h4 - u4 >> 3, n3 += 64;
    }
    function he2(t5, e3, r3) {
      var n3, i3 = e3 - 32, a3 = Bn2, o3 = 255 - t5[i3 - 1];
      for (n3 = 0; n3 < r3; ++n3) {
        var s3, c4 = a3, u4 = o3 + t5[e3 - 1];
        for (s3 = 0; s3 < r3; ++s3)
          t5[e3 + s3] = c4[u4 + t5[i3 + s3]];
        e3 += 32;
      }
    }
    function le2(t5, e3) {
      he2(t5, e3, 4);
    }
    function fe2(t5, e3) {
      he2(t5, e3, 8);
    }
    function de2(t5, e3) {
      he2(t5, e3, 16);
    }
    function pe2(t5, e3) {
      var r3;
      for (r3 = 0; 16 > r3; ++r3)
        n2(t5, e3 + 32 * r3, t5, e3 - 32, 16);
    }
    function ge2(t5, e3) {
      var r3;
      for (r3 = 16; 0 < r3; --r3)
        i2(t5, e3, t5[e3 - 1], 16), e3 += 32;
    }
    function me2(t5, e3, r3) {
      var n3;
      for (n3 = 0; 16 > n3; ++n3)
        i2(e3, r3 + 32 * n3, t5, 16);
    }
    function ve2(t5, e3) {
      var r3, n3 = 16;
      for (r3 = 0; 16 > r3; ++r3)
        n3 += t5[e3 - 1 + 32 * r3] + t5[e3 + r3 - 32];
      me2(n3 >> 5, t5, e3);
    }
    function be2(t5, e3) {
      var r3, n3 = 8;
      for (r3 = 0; 16 > r3; ++r3)
        n3 += t5[e3 - 1 + 32 * r3];
      me2(n3 >> 4, t5, e3);
    }
    function ye2(t5, e3) {
      var r3, n3 = 8;
      for (r3 = 0; 16 > r3; ++r3)
        n3 += t5[e3 + r3 - 32];
      me2(n3 >> 4, t5, e3);
    }
    function we2(t5, e3) {
      me2(128, t5, e3);
    }
    function Ne2(t5, e3, r3) {
      return t5 + 2 * e3 + r3 + 2 >> 2;
    }
    function Le2(t5, e3) {
      var r3, i3 = e3 - 32;
      i3 = new Uint8Array([Ne2(t5[i3 - 1], t5[i3 + 0], t5[i3 + 1]), Ne2(t5[i3 + 0], t5[i3 + 1], t5[i3 + 2]), Ne2(t5[i3 + 1], t5[i3 + 2], t5[i3 + 3]), Ne2(t5[i3 + 2], t5[i3 + 3], t5[i3 + 4])]);
      for (r3 = 0; 4 > r3; ++r3)
        n2(t5, e3 + 32 * r3, i3, 0, i3.length);
    }
    function Ae2(t5, e3) {
      var r3 = t5[e3 - 1], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
      I2(t5, e3 + 0, 16843009 * Ne2(t5[e3 - 1 - 32], r3, n3)), I2(t5, e3 + 32, 16843009 * Ne2(r3, n3, i3)), I2(t5, e3 + 64, 16843009 * Ne2(n3, i3, a3)), I2(t5, e3 + 96, 16843009 * Ne2(i3, a3, a3));
    }
    function xe2(t5, e3) {
      var r3, n3 = 4;
      for (r3 = 0; 4 > r3; ++r3)
        n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      for (n3 >>= 3, r3 = 0; 4 > r3; ++r3)
        i2(t5, e3 + 32 * r3, n3, 4);
    }
    function Se2(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 96] = Ne2(n3, i3, t5[e3 - 1 + 96]), t5[e3 + 1 + 96] = t5[e3 + 0 + 64] = Ne2(r3, n3, i3), t5[e3 + 2 + 96] = t5[e3 + 1 + 64] = t5[e3 + 0 + 32] = Ne2(a3, r3, n3), t5[e3 + 3 + 96] = t5[e3 + 2 + 64] = t5[e3 + 1 + 32] = t5[e3 + 0 + 0] = Ne2(o3, a3, r3), t5[e3 + 3 + 64] = t5[e3 + 2 + 32] = t5[e3 + 1 + 0] = Ne2(s3, o3, a3), t5[e3 + 3 + 32] = t5[e3 + 2 + 0] = Ne2(c4, s3, o3), t5[e3 + 3 + 0] = Ne2(u4, c4, s3);
    }
    function _e2(t5, e3) {
      var r3 = t5[e3 + 1 - 32], n3 = t5[e3 + 2 - 32], i3 = t5[e3 + 3 - 32], a3 = t5[e3 + 4 - 32], o3 = t5[e3 + 5 - 32], s3 = t5[e3 + 6 - 32], c4 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = Ne2(t5[e3 + 0 - 32], r3, n3), t5[e3 + 1 + 0] = t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 2 + 0] = t5[e3 + 1 + 32] = t5[e3 + 0 + 64] = Ne2(n3, i3, a3), t5[e3 + 3 + 0] = t5[e3 + 2 + 32] = t5[e3 + 1 + 64] = t5[e3 + 0 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 64] = t5[e3 + 1 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = t5[e3 + 2 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, c4);
    }
    function Pe2(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32], u4 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 1 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 2 + 64] = o3 + s3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 3 + 64] = s3 + c4 + 1 >> 1, t5[e3 + 3 + 0] = c4 + u4 + 1 >> 1, t5[e3 + 0 + 96] = Ne2(i3, n3, r3), t5[e3 + 0 + 64] = Ne2(n3, r3, a3), t5[e3 + 0 + 32] = t5[e3 + 1 + 96] = Ne2(r3, a3, o3), t5[e3 + 1 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 2 + 32] = t5[e3 + 3 + 96] = Ne2(o3, s3, c4), t5[e3 + 3 + 32] = Ne2(s3, c4, u4);
    }
    function ke2(t5, e3) {
      var r3 = t5[e3 + 0 - 32], n3 = t5[e3 + 1 - 32], i3 = t5[e3 + 2 - 32], a3 = t5[e3 + 3 - 32], o3 = t5[e3 + 4 - 32], s3 = t5[e3 + 5 - 32], c4 = t5[e3 + 6 - 32], u4 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 0 + 64] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 1 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 3 + 0] = t5[e3 + 2 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = Ne2(r3, n3, i3), t5[e3 + 1 + 32] = t5[e3 + 0 + 96] = Ne2(n3, i3, a3), t5[e3 + 2 + 32] = t5[e3 + 1 + 96] = Ne2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 96] = Ne2(a3, o3, s3), t5[e3 + 3 + 64] = Ne2(o3, s3, c4), t5[e3 + 3 + 96] = Ne2(s3, c4, u4);
    }
    function Ie2(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
      t5[e3 + 0 + 0] = r3 + n3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 0 + 32] = n3 + i3 + 1 >> 1, t5[e3 + 2 + 32] = t5[e3 + 0 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 1 + 0] = Ne2(r3, n3, i3), t5[e3 + 3 + 0] = t5[e3 + 1 + 32] = Ne2(n3, i3, a3), t5[e3 + 3 + 32] = t5[e3 + 1 + 64] = Ne2(i3, a3, a3), t5[e3 + 3 + 64] = t5[e3 + 2 + 64] = t5[e3 + 0 + 96] = t5[e3 + 1 + 96] = t5[e3 + 2 + 96] = t5[e3 + 3 + 96] = a3;
    }
    function Fe2(t5, e3) {
      var r3 = t5[e3 - 1 + 0], n3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96], o3 = t5[e3 - 1 - 32], s3 = t5[e3 + 0 - 32], c4 = t5[e3 + 1 - 32], u4 = t5[e3 + 2 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 2 + 32] = r3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = t5[e3 + 2 + 64] = n3 + r3 + 1 >> 1, t5[e3 + 0 + 64] = t5[e3 + 2 + 96] = i3 + n3 + 1 >> 1, t5[e3 + 0 + 96] = a3 + i3 + 1 >> 1, t5[e3 + 3 + 0] = Ne2(s3, c4, u4), t5[e3 + 2 + 0] = Ne2(o3, s3, c4), t5[e3 + 1 + 0] = t5[e3 + 3 + 32] = Ne2(r3, o3, s3), t5[e3 + 1 + 32] = t5[e3 + 3 + 64] = Ne2(n3, r3, o3), t5[e3 + 1 + 64] = t5[e3 + 3 + 96] = Ne2(i3, n3, r3), t5[e3 + 1 + 96] = Ne2(a3, i3, n3);
    }
    function Ce2(t5, e3) {
      var r3;
      for (r3 = 0; 8 > r3; ++r3)
        n2(t5, e3 + 32 * r3, t5, e3 - 32, 8);
    }
    function je2(t5, e3) {
      var r3;
      for (r3 = 0; 8 > r3; ++r3)
        i2(t5, e3, t5[e3 - 1], 8), e3 += 32;
    }
    function Oe2(t5, e3, r3) {
      var n3;
      for (n3 = 0; 8 > n3; ++n3)
        i2(e3, r3 + 32 * n3, t5, 8);
    }
    function Be2(t5, e3) {
      var r3, n3 = 8;
      for (r3 = 0; 8 > r3; ++r3)
        n3 += t5[e3 + r3 - 32] + t5[e3 - 1 + 32 * r3];
      Oe2(n3 >> 4, t5, e3);
    }
    function Me2(t5, e3) {
      var r3, n3 = 4;
      for (r3 = 0; 8 > r3; ++r3)
        n3 += t5[e3 + r3 - 32];
      Oe2(n3 >> 3, t5, e3);
    }
    function Ee2(t5, e3) {
      var r3, n3 = 4;
      for (r3 = 0; 8 > r3; ++r3)
        n3 += t5[e3 - 1 + 32 * r3];
      Oe2(n3 >> 3, t5, e3);
    }
    function qe2(t5, e3) {
      Oe2(128, t5, e3);
    }
    function De2(t5, e3, r3) {
      var n3 = t5[e3 - r3], i3 = t5[e3 + 0], a3 = 3 * (i3 - n3) + jn2[1020 + t5[e3 - 2 * r3] - t5[e3 + r3]], o3 = On2[112 + (a3 + 4 >> 3)];
      t5[e3 - r3] = Bn2[255 + n3 + On2[112 + (a3 + 3 >> 3)]], t5[e3 + 0] = Bn2[255 + i3 - o3];
    }
    function Re2(t5, e3, r3, n3) {
      var i3 = t5[e3 + 0], a3 = t5[e3 + r3];
      return Mn2[255 + t5[e3 - 2 * r3] - t5[e3 - r3]] > n3 || Mn2[255 + a3 - i3] > n3;
    }
    function Te2(t5, e3, r3, n3) {
      return 4 * Mn2[255 + t5[e3 - r3] - t5[e3 + 0]] + Mn2[255 + t5[e3 - 2 * r3] - t5[e3 + r3]] <= n3;
    }
    function Ue2(t5, e3, r3, n3, i3) {
      var a3 = t5[e3 - 3 * r3], o3 = t5[e3 - 2 * r3], s3 = t5[e3 - r3], c4 = t5[e3 + 0], u4 = t5[e3 + r3], h4 = t5[e3 + 2 * r3], l4 = t5[e3 + 3 * r3];
      return 4 * Mn2[255 + s3 - c4] + Mn2[255 + o3 - u4] > n3 ? 0 : Mn2[255 + t5[e3 - 4 * r3] - a3] <= i3 && Mn2[255 + a3 - o3] <= i3 && Mn2[255 + o3 - s3] <= i3 && Mn2[255 + l4 - h4] <= i3 && Mn2[255 + h4 - u4] <= i3 && Mn2[255 + u4 - c4] <= i3;
    }
    function ze2(t5, e3, r3, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te2(t5, e3 + n3, r3, i3) && De2(t5, e3 + n3, r3);
    }
    function He2(t5, e3, r3, n3) {
      var i3 = 2 * n3 + 1;
      for (n3 = 0; 16 > n3; ++n3)
        Te2(t5, e3 + n3 * r3, 1, i3) && De2(t5, e3 + n3 * r3, 1);
    }
    function We2(t5, e3, r3, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3)
        ze2(t5, e3 += 4 * r3, r3, n3);
    }
    function Ve2(t5, e3, r3, n3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3)
        He2(t5, e3 += 4, r3, n3);
    }
    function Ge2(t5, e3, r3, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Ue2(t5, e3, r3, a3, o3))
          if (Re2(t5, e3, r3, s3))
            De2(t5, e3, r3);
          else {
            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - 2 * h4], f4 = c4[u4 - h4], d4 = c4[u4 + 0], p4 = c4[u4 + h4], g4 = c4[u4 + 2 * h4], m4 = 27 * (b4 = jn2[1020 + 3 * (d4 - f4) + jn2[1020 + l4 - p4]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            c4[u4 - 3 * h4] = Bn2[255 + c4[u4 - 3 * h4] + b4], c4[u4 - 2 * h4] = Bn2[255 + l4 + v4], c4[u4 - h4] = Bn2[255 + f4 + m4], c4[u4 + 0] = Bn2[255 + d4 - m4], c4[u4 + h4] = Bn2[255 + p4 - v4], c4[u4 + 2 * h4] = Bn2[255 + g4 - b4];
          }
        e3 += n3;
      }
    }
    function Ye2(t5, e3, r3, n3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Ue2(t5, e3, r3, a3, o3))
          if (Re2(t5, e3, r3, s3))
            De2(t5, e3, r3);
          else {
            var c4 = t5, u4 = e3, h4 = r3, l4 = c4[u4 - h4], f4 = c4[u4 + 0], d4 = c4[u4 + h4], p4 = On2[112 + ((g4 = 3 * (f4 - l4)) + 4 >> 3)], g4 = On2[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
            c4[u4 - 2 * h4] = Bn2[255 + c4[u4 - 2 * h4] + m4], c4[u4 - h4] = Bn2[255 + l4 + g4], c4[u4 + 0] = Bn2[255 + f4 - p4], c4[u4 + h4] = Bn2[255 + d4 - m4];
          }
        e3 += n3;
      }
    }
    function Je2(t5, e3, r3, n3, i3, a3) {
      Ge2(t5, e3, r3, 1, 16, n3, i3, a3);
    }
    function Xe2(t5, e3, r3, n3, i3, a3) {
      Ge2(t5, e3, 1, r3, 16, n3, i3, a3);
    }
    function Ke2(t5, e3, r3, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye2(t5, e3 += 4 * r3, r3, 1, 16, n3, i3, a3);
    }
    function Ze2(t5, e3, r3, n3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3)
        Ye2(t5, e3 += 4, 1, r3, 16, n3, i3, a3);
    }
    function $e2(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ge2(t5, e3, i3, 1, 8, a3, o3, s3), Ge2(r3, n3, i3, 1, 8, a3, o3, s3);
    }
    function Qe2(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ge2(t5, e3, 1, i3, 8, a3, o3, s3), Ge2(r3, n3, 1, i3, 8, a3, o3, s3);
    }
    function tr(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ye2(t5, e3 + 4 * i3, i3, 1, 8, a3, o3, s3), Ye2(r3, n3 + 4 * i3, i3, 1, 8, a3, o3, s3);
    }
    function er(t5, e3, r3, n3, i3, a3, o3, s3) {
      Ye2(t5, e3 + 4, 1, i3, 8, a3, o3, s3), Ye2(r3, n3 + 4, 1, i3, 8, a3, o3, s3);
    }
    function rr() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ct2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nr() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function ir() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function ar() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new l3();
    }
    function or() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new ar(), this.ab = 0, this.gc = o2(4, ir), this.Oc = 0;
    }
    function sr() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function cr(t5, e3, r3, n3, i3, a3, o3) {
      for (t5 = null == t5 ? 0 : t5[e3 + 0], e3 = 0; e3 < o3; ++e3)
        i3[a3 + e3] = t5 + r3[n3 + e3] & 255, t5 = i3[a3 + e3];
    }
    function ur(t5, e3, r3, n3, i3, a3, o3) {
      var s3;
      if (null == t5)
        cr(null, null, r3, n3, i3, a3, o3);
      else
        for (s3 = 0; s3 < o3; ++s3)
          i3[a3 + s3] = t5[e3 + s3] + r3[n3 + s3] & 255;
    }
    function hr(t5, e3, r3, n3, i3, a3, o3) {
      if (null == t5)
        cr(null, null, r3, n3, i3, a3, o3);
      else {
        var s3, c4 = t5[e3 + 0], u4 = c4, h4 = c4;
        for (s3 = 0; s3 < o3; ++s3)
          u4 = h4 + (c4 = t5[e3 + s3]) - u4, h4 = r3[n3 + s3] + (-256 & u4 ? 0 > u4 ? 0 : 255 : u4) & 255, u4 = c4, i3[a3 + s3] = h4;
      }
    }
    function lr(t5, r3, i3, o3) {
      var s3 = r3.width, c4 = r3.o;
      if (e2(null != t5 && null != r3), 0 > i3 || 0 >= o3 || i3 + o3 > c4)
        return null;
      if (!t5.Cc) {
        if (null == t5.ga) {
          var u4;
          if (t5.ga = new sr(), (u4 = null == t5.ga) || (u4 = r3.width * r3.o, e2(0 == t5.Gb.length), t5.Gb = a2(u4), t5.Uc = 0, null == t5.Gb ? u4 = 0 : (t5.mb = t5.Gb, t5.nb = t5.Uc, t5.rc = null, u4 = 1), u4 = !u4), !u4) {
            u4 = t5.ga;
            var h4 = t5.Fa, l4 = t5.P, f4 = t5.qc, d4 = t5.mb, p4 = t5.nb, g4 = l4 + 1, m4 = f4 - 1, b4 = u4.l;
            if (e2(null != h4 && null != d4 && null != r3), mi2[0] = null, mi2[1] = cr, mi2[2] = ur, mi2[3] = hr, u4.ca = d4, u4.tb = p4, u4.c = r3.width, u4.i = r3.height, e2(0 < u4.c && 0 < u4.i), 1 >= f4)
              r3 = 0;
            else if (u4.$a = h4[l4 + 0] >> 0 & 3, u4.Z = h4[l4 + 0] >> 2 & 3, u4.Lc = h4[l4 + 0] >> 4 & 3, l4 = h4[l4 + 0] >> 6 & 3, 0 > u4.$a || 1 < u4.$a || 4 <= u4.Z || 1 < u4.Lc || l4)
              r3 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = u4, b4.width = r3.width, b4.height = r3.height, b4.Da = r3.Da, b4.v = r3.v, b4.va = r3.va, b4.j = r3.j, b4.o = r3.o, u4.$a)
              t: {
                e2(1 == u4.$a), r3 = kt2();
                e:
                  for (; ; ) {
                    if (null == r3) {
                      r3 = 0;
                      break t;
                    }
                    if (e2(null != u4), u4.mc = r3, r3.c = u4.c, r3.i = u4.i, r3.l = u4.l, r3.l.ma = u4, r3.l.width = u4.c, r3.l.height = u4.i, r3.a = 0, v3(r3.m, h4, g4, m4), !It2(u4.c, u4.i, 1, r3, null))
                      break e;
                    if (1 == r3.ab && 3 == r3.gc[0].hc && At2(r3.s) ? (u4.ic = 1, h4 = r3.c * r3.i, r3.Ta = null, r3.Ua = 0, r3.V = a2(h4), r3.Ba = 0, null == r3.V ? (r3.a = 1, r3 = 0) : r3 = 1) : (u4.ic = 0, r3 = Ft3(r3, u4.c)), !r3)
                      break e;
                    r3 = 1;
                    break t;
                  }
                u4.mc = null, r3 = 0;
              }
            else
              r3 = m4 >= u4.c * u4.i;
            u4 = !r3;
          }
          if (u4)
            return null;
          1 != t5.ga.Lc ? t5.Ga = 0 : o3 = c4 - i3;
        }
        e2(null != t5.ga), e2(i3 + o3 <= c4);
        t: {
          if (r3 = (h4 = t5.ga).c, c4 = h4.l.o, 0 == h4.$a) {
            if (g4 = t5.rc, m4 = t5.Vc, b4 = t5.Fa, l4 = t5.P + 1 + i3 * r3, f4 = t5.mb, d4 = t5.nb + i3 * r3, e2(l4 <= t5.P + t5.qc), 0 != h4.Z)
              for (e2(null != mi2[h4.Z]), u4 = 0; u4 < o3; ++u4)
                mi2[h4.Z](g4, m4, b4, l4, f4, d4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;
            else
              for (u4 = 0; u4 < o3; ++u4)
                n2(f4, d4, b4, l4, r3), g4 = f4, m4 = d4, d4 += r3, l4 += r3;
            t5.rc = g4, t5.Vc = m4;
          } else {
            if (e2(null != h4.mc), r3 = i3 + o3, e2(null != (u4 = h4.mc)), e2(r3 <= u4.i), u4.C >= r3)
              r3 = 1;
            else if (h4.ic || mr(), h4.ic) {
              h4 = u4.V, g4 = u4.Ba, m4 = u4.c;
              var y4 = u4.i, w4 = (b4 = 1, l4 = u4.$ / m4, f4 = u4.$ % m4, d4 = u4.m, p4 = u4.s, u4.$), N4 = m4 * y4, L4 = m4 * r3, x3 = p4.wc, _3 = w4 < L4 ? wt2(p4, f4, l4) : null;
              e2(w4 <= N4), e2(r3 <= y4), e2(At2(p4));
              e:
                for (; ; ) {
                  for (; !d4.h && w4 < L4; ) {
                    if (f4 & x3 || (_3 = wt2(p4, f4, l4)), e2(null != _3), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4)))
                      h4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++l4 <= r3 && !(l4 % 16) && St2(u4, l4));
                    else {
                      if (!(280 > y4)) {
                        b4 = 0;
                        break e;
                      }
                      y4 = mt2(y4 - 256, d4);
                      var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                      if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0; P3 < y4; ++P3)
                        h4[g4 + w4 + P3] = h4[g4 + w4 + P3 - k3];
                      for (w4 += y4, f4 += y4; f4 >= m4; )
                        f4 -= m4, ++l4 <= r3 && !(l4 % 16) && St2(u4, l4);
                      w4 < L4 && f4 & x3 && (_3 = wt2(p4, f4, l4));
                    }
                    e2(d4.h == A3(d4));
                  }
                  St2(u4, l4 > r3 ? r3 : l4);
                  break e;
                }
              !b4 || d4.h && w4 < N4 ? (b4 = 0, u4.a = d4.h ? 5 : 3) : u4.$ = w4, r3 = b4;
            } else
              r3 = _t5(u4, u4.V, u4.Ba, u4.c, u4.i, r3, Ct2);
            if (!r3) {
              o3 = 0;
              break t;
            }
          }
          i3 + o3 >= c4 && (t5.Cc = 1), o3 = 1;
        }
        if (!o3)
          return null;
        if (t5.Cc && (null != (o3 = t5.ga) && (o3.mc = null), t5.ga = null, 0 < t5.Ga))
          return alert("todo:WebPDequantizeLevels"), null;
      }
      return t5.nb + i3 * s3;
    }
    function fr(t5, e3, r3, n3, i3, a3) {
      for (; 0 < i3--; ) {
        var o3, s3 = t5, c4 = e3 + (r3 ? 1 : 0), u4 = t5, h4 = e3 + (r3 ? 0 : 3);
        for (o3 = 0; o3 < n3; ++o3) {
          var l4 = u4[h4 + 4 * o3];
          255 != l4 && (l4 *= 32897, s3[c4 + 4 * o3 + 0] = s3[c4 + 4 * o3 + 0] * l4 >> 23, s3[c4 + 4 * o3 + 1] = s3[c4 + 4 * o3 + 1] * l4 >> 23, s3[c4 + 4 * o3 + 2] = s3[c4 + 4 * o3 + 2] * l4 >> 23);
        }
        e3 += a3;
      }
    }
    function dr(t5, e3, r3, n3, i3) {
      for (; 0 < n3--; ) {
        var a3;
        for (a3 = 0; a3 < r3; ++a3) {
          var o3 = t5[e3 + 2 * a3 + 0], s3 = 15 & (u4 = t5[e3 + 2 * a3 + 1]), c4 = 4369 * s3, u4 = (240 & u4 | u4 >> 4) * c4 >> 16;
          t5[e3 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * c4 >> 16 & 240 | (15 & o3 | o3 << 4) * c4 >> 16 >> 4 & 15, t5[e3 + 2 * a3 + 1] = 240 & u4 | s3;
        }
        e3 += i3;
      }
    }
    function pr(t5, e3, r3, n3, i3, a3, o3, s3) {
      var c4, u4, h4 = 255;
      for (u4 = 0; u4 < i3; ++u4) {
        for (c4 = 0; c4 < n3; ++c4) {
          var l4 = t5[e3 + c4];
          a3[o3 + 4 * c4] = l4, h4 &= l4;
        }
        e3 += r3, o3 += s3;
      }
      return 255 != h4;
    }
    function gr(t5, e3, r3, n3, i3) {
      var a3;
      for (a3 = 0; a3 < i3; ++a3)
        r3[n3 + a3] = t5[e3 + a3] >> 8;
    }
    function mr() {
      An2 = fr, xn2 = dr, Sn2 = pr, _n2 = gr;
    }
    function vr(r3, n3, i3) {
      t4[r3] = function(t5, r4, a3, o3, s3, c4, u4, h4, l4, f4, d4, p4, g4, m4, v4, b4, y4) {
        var w4, N4 = y4 - 1 >> 1, L4 = s3[c4 + 0] | u4[h4 + 0] << 16, A4 = l4[f4 + 0] | d4[p4 + 0] << 16;
        e2(null != t5);
        var x3 = 3 * L4 + A4 + 131074 >> 2;
        for (n3(t5[r4 + 0], 255 & x3, x3 >> 16, g4, m4), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + 0], 255 & x3, x3 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
          var S3 = s3[c4 + w4] | u4[h4 + w4] << 16, _3 = l4[f4 + w4] | d4[p4 + w4] << 16, P3 = L4 + S3 + A4 + _3 + 524296, k3 = P3 + 2 * (S3 + A4) >> 3;
          x3 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, n3(t5[r4 + 2 * w4 - 1], 255 & x3, x3 >> 16, g4, m4 + (2 * w4 - 1) * i3), n3(t5[r4 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), null != a3 && (x3 = P3 + A4 >> 1, L4 = k3 + _3 >> 1, n3(a3[o3 + 2 * w4 - 1], 255 & x3, x3 >> 16, v4, b4 + (2 * w4 - 1) * i3), n3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L4 = S3, A4 = _3;
        }
        1 & y4 || (x3 = 3 * L4 + A4 + 131074 >> 2, n3(t5[r4 + y4 - 1], 255 & x3, x3 >> 16, g4, m4 + (y4 - 1) * i3), null != a3 && (x3 = 3 * A4 + L4 + 131074 >> 2, n3(a3[o3 + y4 - 1], 255 & x3, x3 >> 16, v4, b4 + (y4 - 1) * i3)));
      };
    }
    function br() {
      vi2[En2] = bi2, vi2[qn2] = wi2, vi2[Dn2] = yi2, vi2[Rn2] = Ni2, vi2[Tn2] = Li2, vi2[Un2] = Ai2, vi2[zn2] = xi2, vi2[Hn2] = wi2, vi2[Wn2] = Ni2, vi2[Vn2] = Li2, vi2[Gn2] = Ai2;
    }
    function yr(t5) {
      return t5 & ~Fi2 ? 0 > t5 ? 0 : 255 : t5 >> Ii2;
    }
    function wr(t5, e3) {
      return yr((19077 * t5 >> 8) + (26149 * e3 >> 8) - 14234);
    }
    function Nr(t5, e3, r3) {
      return yr((19077 * t5 >> 8) - (6419 * e3 >> 8) - (13320 * r3 >> 8) + 8708);
    }
    function Lr(t5, e3) {
      return yr((19077 * t5 >> 8) + (33050 * e3 >> 8) - 17685);
    }
    function Ar(t5, e3, r3, n3, i3) {
      n3[i3 + 0] = wr(t5, r3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = Lr(t5, e3);
    }
    function xr(t5, e3, r3, n3, i3) {
      n3[i3 + 0] = Lr(t5, e3), n3[i3 + 1] = Nr(t5, e3, r3), n3[i3 + 2] = wr(t5, r3);
    }
    function Sr(t5, e3, r3, n3, i3) {
      var a3 = Nr(t5, e3, r3);
      e3 = a3 << 3 & 224 | Lr(t5, e3) >> 3, n3[i3 + 0] = 248 & wr(t5, r3) | a3 >> 5, n3[i3 + 1] = e3;
    }
    function _r(t5, e3, r3, n3, i3) {
      var a3 = 240 & Lr(t5, e3) | 15;
      n3[i3 + 0] = 240 & wr(t5, r3) | Nr(t5, e3, r3) >> 4, n3[i3 + 1] = a3;
    }
    function Pr(t5, e3, r3, n3, i3) {
      n3[i3 + 0] = 255, Ar(t5, e3, r3, n3, i3 + 1);
    }
    function kr(t5, e3, r3, n3, i3) {
      xr(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;
    }
    function Ir(t5, e3, r3, n3, i3) {
      Ar(t5, e3, r3, n3, i3), n3[i3 + 3] = 255;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Fr(e3, r3, n3) {
      t4[e3] = function(t5, e4, i3, a3, o3, s3, c4, u4, h4) {
        for (var l4 = u4 + (-2 & h4) * n3; u4 != l4; )
          r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4), r3(t5[e4 + 1], i3[a3 + 0], o3[s3 + 0], c4, u4 + n3), e4 += 2, ++a3, ++s3, u4 += 2 * n3;
        1 & h4 && r3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], c4, u4);
      };
    }
    function Cr(t5, e3, r3) {
      return 0 == r3 ? 0 == t5 ? 0 == e3 ? 6 : 5 : 0 == e3 ? 4 : 0 : r3;
    }
    function jr(t5, e3, r3, n3, i3) {
      switch (t5 >>> 30) {
        case 3:
          on2(e3, r3, n3, i3, 0);
          break;
        case 2:
          sn2(e3, r3, n3, i3);
          break;
        case 1:
          un2(e3, r3, n3, i3);
      }
    }
    function Or(t5, e3) {
      var r3, a3, o3 = e3.M, s3 = e3.Nb, c4 = t5.oc, u4 = t5.pc + 40, h4 = t5.oc, l4 = t5.pc + 584, f4 = t5.oc, d4 = t5.pc + 600;
      for (r3 = 0; 16 > r3; ++r3)
        c4[u4 + 32 * r3 - 1] = 129;
      for (r3 = 0; 8 > r3; ++r3)
        h4[l4 + 32 * r3 - 1] = 129, f4[d4 + 32 * r3 - 1] = 129;
      for (0 < o3 ? c4[u4 - 1 - 32] = h4[l4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i2(c4, u4 - 32 - 1, 127, 21), i2(h4, l4 - 32 - 1, 127, 9), i2(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t5.za; ++a3) {
        var p4 = e3.ya[e3.aa + a3];
        if (0 < a3) {
          for (r3 = -1; 16 > r3; ++r3)
            n2(c4, u4 + 32 * r3 - 4, c4, u4 + 32 * r3 + 12, 4);
          for (r3 = -1; 8 > r3; ++r3)
            n2(h4, l4 + 32 * r3 - 4, h4, l4 + 32 * r3 + 4, 4), n2(f4, d4 + 32 * r3 - 4, f4, d4 + 32 * r3 + 4, 4);
        }
        var g4 = t5.Gd, m4 = t5.Hd + a3, v4 = p4.ad, b4 = p4.Hc;
        if (0 < o3 && (n2(c4, u4 - 32, g4[m4].y, 0, 16), n2(h4, l4 - 32, g4[m4].f, 0, 8), n2(f4, d4 - 32, g4[m4].ea, 0, 8)), p4.Za) {
          var y4 = c4, w4 = u4 - 32 + 16;
          for (0 < o3 && (a3 >= t5.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : n2(y4, w4, g4[m4 + 1].y, 0, 4)), r3 = 0; 4 > r3; r3++)
            y4[w4 + 128 + r3] = y4[w4 + 256 + r3] = y4[w4 + 384 + r3] = y4[w4 + 0 + r3];
          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)
            y4 = c4, w4 = u4 + Di2[r3], fi2[p4.Ob[r3]](y4, w4), jr(b4, v4, 16 * +r3, y4, w4);
        } else if (y4 = Cr(a3, o3, p4.Ob[0]), li2[y4](c4, u4), 0 != b4)
          for (r3 = 0; 16 > r3; ++r3, b4 <<= 2)
            jr(b4, v4, 16 * +r3, c4, u4 + Di2[r3]);
        for (r3 = p4.Gc, y4 = Cr(a3, o3, p4.Dd), di2[y4](h4, l4), di2[y4](f4, d4), b4 = v4, y4 = h4, w4 = l4, 255 & (p4 = r3 >> 0) && (170 & p4 ? cn2(b4, 256, y4, w4) : hn2(b4, 256, y4, w4)), p4 = f4, b4 = d4, 255 & (r3 >>= 8) && (170 & r3 ? cn2(v4, 320, p4, b4) : hn2(v4, 320, p4, b4)), o3 < t5.Ub - 1 && (n2(g4[m4].y, 0, c4, u4 + 480, 16), n2(g4[m4].f, 0, h4, l4 + 224, 8), n2(g4[m4].ea, 0, f4, d4 + 224, 8)), r3 = 8 * s3 * t5.B, g4 = t5.sa, m4 = t5.ta + 16 * a3 + 16 * s3 * t5.R, v4 = t5.qa, p4 = t5.ra + 8 * a3 + r3, b4 = t5.Ha, y4 = t5.Ia + 8 * a3 + r3, r3 = 0; 16 > r3; ++r3)
          n2(g4, m4 + r3 * t5.R, c4, u4 + 32 * r3, 16);
        for (r3 = 0; 8 > r3; ++r3)
          n2(v4, p4 + r3 * t5.B, h4, l4 + 32 * r3, 8), n2(b4, y4 + r3 * t5.B, f4, d4 + 32 * r3, 8);
      }
    }
    function Br(t5, n3, i3, a3, o3, s3, c4, u4, h4) {
      var l4 = [0], f4 = [0], d4 = 0, p4 = null != h4 ? h4.kd : 0, g4 = null != h4 ? h4 : new nr();
      if (null == t5 || 12 > i3)
        return 7;
      g4.data = t5, g4.w = n3, g4.ha = i3, n3 = [n3], i3 = [i3], g4.gb = [g4.gb];
      t: {
        var m4 = n3, b4 = i3, y4 = g4.gb;
        if (e2(null != t5), e2(null != b4), e2(null != y4), y4[0] = 0, 12 <= b4[0] && !r2(t5, m4[0], "RIFF")) {
          if (r2(t5, m4[0] + 8, "WEBP")) {
            y4 = 3;
            break t;
          }
          var w4 = j2(t5, m4[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y4 = 3;
            break t;
          }
          if (p4 && w4 > b4[0] - 8) {
            y4 = 7;
            break t;
          }
          y4[0] = w4, m4[0] += 12, b4[0] -= 12;
        }
        y4 = 0;
      }
      if (0 != y4)
        return y4;
      for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
        t: {
          var L4 = t5;
          b4 = n3, y4 = i3;
          var A4 = l4, x3 = f4, S3 = m4 = [0];
          if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0])
            y4 = 7;
          else {
            if (!r2(L4, b4[0], "VP8X")) {
              if (10 != j2(L4, b4[0] + 4)) {
                y4 = 3;
                break t;
              }
              if (18 > y4[0]) {
                y4 = 7;
                break t;
              }
              var _3 = j2(L4, b4[0] + 8), P3 = 1 + C2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + C2(L4, b4[0] + 15))) {
                y4 = 3;
                break t;
              }
              null != S3 && (S3[0] = _3), null != A4 && (A4[0] = P3), null != x3 && (x3[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
            }
            y4 = 0;
          }
        }
        if (d4 = d4[0], m4 = m4[0], 0 != y4)
          return y4;
        if (b4 = !!(2 & m4), !w4 && d4)
          return 3;
        if (null != s3 && (s3[0] = !!(16 & m4)), null != c4 && (c4[0] = b4), null != u4 && (u4[0] = 0), c4 = l4[0], m4 = f4[0], d4 && b4 && null == h4) {
          y4 = 0;
          break;
        }
        if (4 > i3) {
          y4 = 7;
          break;
        }
        if (w4 && d4 || !w4 && !d4 && !r2(t5, n3[0], "ALPH")) {
          i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _3 = t5, y4 = n3, w4 = i3;
            var k3 = g4.gb;
            A4 = g4.na, x3 = g4.P, S3 = g4.Sa;
            P3 = 22, e2(null != _3), e2(null != w4), L4 = y4[0];
            var I3 = w4[0];
            for (e2(null != A4), e2(null != S3), A4[0] = null, x3[0] = null, S3[0] = 0; ; ) {
              if (y4[0] = L4, w4[0] = I3, 8 > I3) {
                y4 = 7;
                break t;
              }
              var F3 = j2(_3, L4 + 4);
              if (4294967286 < F3) {
                y4 = 3;
                break t;
              }
              var O3 = 8 + F3 + 1 & -2;
              if (P3 += O3, 0 < k3 && P3 > k3) {
                y4 = 3;
                break t;
              }
              if (!r2(_3, L4, "VP8 ") || !r2(_3, L4, "VP8L")) {
                y4 = 0;
                break t;
              }
              if (I3[0] < O3) {
                y4 = 7;
                break t;
              }
              r2(_3, L4, "ALPH") || (A4[0] = _3, x3[0] = L4 + 8, S3[0] = F3), L4 += O3, I3 -= O3;
            }
          }
          if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y4)
            break;
        }
        i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t:
          if (k3 = t5, y4 = n3, w4 = i3, A4 = g4.gb[0], x3 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !r2(k3, _3, "VP8 "), P3 = !r2(k3, _3, "VP8L"), e2(null != k3), e2(null != w4), e2(null != x3), e2(null != S3), 8 > w4[0])
            y4 = 7;
          else {
            if (L4 || P3) {
              if (k3 = j2(k3, _3 + 4), 12 <= A4 && k3 > A4 - 12) {
                y4 = 3;
                break t;
              }
              if (p4 && k3 > w4[0] - 8) {
                y4 = 7;
                break t;
              }
              x3[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else
              S3[0] = 5 <= w4[0] && 47 == k3[_3 + 0] && !(k3[_3 + 4] >> 5), x3[0] = w4[0];
            y4 = 0;
          }
        if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], n3 = n3[0], 0 != y4)
          break;
        if (4294967286 < g4.Ja)
          return 3;
        if (null == u4 || b4 || (u4[0] = g4.xa ? 2 : 1), c4 = [c4], m4 = [m4], g4.xa) {
          if (5 > i3) {
            y4 = 7;
            break;
          }
          u4 = c4, p4 = m4, b4 = s3, null == t5 || 5 > i3 ? t5 = 0 : 5 <= i3 && 47 == t5[n3 + 0] && !(t5[n3 + 4] >> 5) ? (w4 = [0], k3 = [0], A4 = [0], v3(x3 = new N3(), t5, n3, i3), gt2(x3, w4, k3, A4) ? (null != u4 && (u4[0] = w4[0]), null != p4 && (p4[0] = k3[0]), null != b4 && (b4[0] = A4[0]), t5 = 1) : t5 = 0) : t5 = 0;
        } else {
          if (10 > i3) {
            y4 = 7;
            break;
          }
          u4 = m4, null == t5 || 10 > i3 || !Xt3(t5, n3 + 3, i3 - 3) ? t5 = 0 : (p4 = t5[n3 + 0] | t5[n3 + 1] << 8 | t5[n3 + 2] << 16, b4 = 16383 & (t5[n3 + 7] << 8 | t5[n3 + 6]), t5 = 16383 & (t5[n3 + 9] << 8 | t5[n3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t5 ? t5 = 0 : (c4 && (c4[0] = b4), u4 && (u4[0] = t5), t5 = 1));
        }
        if (!t5)
          return 3;
        if (c4 = c4[0], m4 = m4[0], d4 && (l4[0] != c4 || f4[0] != m4))
          return 3;
        null != h4 && (h4[0] = g4, h4.offset = n3 - h4.w, e2(4294967286 > n3 - h4.w), e2(h4.offset == h4.ha - i3));
        break;
      }
      return 0 == y4 || 7 == y4 && d4 && null == h4 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a3 && (a3[0] = c4), null != o3 && (o3[0] = m4), 0) : y4;
    }
    function Mr(t5, e3, r3) {
      var n3 = e3.width, i3 = e3.height, a3 = 0, o3 = 0, s3 = n3, c4 = i3;
      if (e3.Da = null != t5 && 0 < t5.Da, e3.Da && (s3 = t5.cd, c4 = t5.bd, a3 = t5.v, o3 = t5.j, 11 > r3 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= c4 || a3 + s3 > n3 || o3 + c4 > i3))
        return 0;
      if (e3.v = a3, e3.j = o3, e3.va = a3 + s3, e3.o = o3 + c4, e3.U = s3, e3.T = c4, e3.da = null != t5 && 0 < t5.da, e3.da) {
        if (!E2(s3, c4, r3 = [t5.ib], a3 = [t5.hb]))
          return 0;
        e3.ib = r3[0], e3.hb = a3[0];
      }
      return e3.ob = null != t5 && t5.ob, e3.Kb = null == t5 || !t5.Sd, e3.da && (e3.ob = e3.ib < 3 * n3 / 4 && e3.hb < 3 * i3 / 4, e3.Kb = 0), 1;
    }
    function Er(t5) {
      if (null == t5)
        return 2;
      if (11 > t5.S) {
        var e3 = t5.f.RGBA;
        e3.fb += (t5.height - 1) * e3.A, e3.A = -e3.A;
      } else
        e3 = t5.f.kb, t5 = t5.height, e3.O += (t5 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t5 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t5 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, null != e3.F && (e3.J += (t5 - 1) * e3.lb, e3.lb = -e3.lb);
      return 0;
    }
    function qr(t5, e3, r3, n3) {
      if (null == n3 || 0 >= t5 || 0 >= e3)
        return 2;
      if (null != r3) {
        if (r3.Da) {
          var i3 = r3.cd, o3 = r3.bd, s3 = -2 & r3.v, c4 = -2 & r3.j;
          if (0 > s3 || 0 > c4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t5 || c4 + o3 > e3)
            return 2;
          t5 = i3, e3 = o3;
        }
        if (r3.da) {
          if (!E2(t5, e3, i3 = [r3.ib], o3 = [r3.hb]))
            return 2;
          t5 = i3[0], e3 = o3[0];
        }
      }
      n3.width = t5, n3.height = e3;
      t: {
        var u4 = n3.width, h4 = n3.height;
        if (t5 = n3.S, 0 >= u4 || 0 >= h4 || !(t5 >= En2 && 13 > t5))
          t5 = 2;
        else {
          if (0 >= n3.Rd && null == n3.sd) {
            s3 = o3 = i3 = e3 = 0;
            var l4 = (c4 = u4 * zi2[t5]) * h4;
            if (11 > t5 || (o3 = (h4 + 1) / 2 * (e3 = (u4 + 1) / 2), 12 == t5 && (s3 = (i3 = u4) * h4)), null == (h4 = a2(l4 + 2 * o3 + s3))) {
              t5 = 1;
              break t;
            }
            n3.sd = h4, 11 > t5 ? ((u4 = n3.f.RGBA).eb = h4, u4.fb = 0, u4.A = c4, u4.size = l4) : ((u4 = n3.f.kb).y = h4, u4.O = 0, u4.fa = c4, u4.Fd = l4, u4.f = h4, u4.N = 0 + l4, u4.Ab = e3, u4.Cd = o3, u4.ea = h4, u4.W = 0 + l4 + o3, u4.Db = e3, u4.Ed = o3, 12 == t5 && (u4.F = h4, u4.J = 0 + l4 + 2 * o3), u4.Tc = s3, u4.lb = i3);
          }
          if (e3 = 1, i3 = n3.S, o3 = n3.width, s3 = n3.height, i3 >= En2 && 13 > i3)
            if (11 > i3)
              t5 = n3.f.RGBA, e3 &= (c4 = Math.abs(t5.A)) * (s3 - 1) + o3 <= t5.size, e3 &= c4 >= o3 * zi2[i3], e3 &= null != t5.eb;
            else {
              t5 = n3.f.kb, c4 = (o3 + 1) / 2, l4 = (s3 + 1) / 2, u4 = Math.abs(t5.fa);
              h4 = Math.abs(t5.Ab);
              var f4 = Math.abs(t5.Db), d4 = Math.abs(t5.lb), p4 = d4 * (s3 - 1) + o3;
              e3 &= u4 * (s3 - 1) + o3 <= t5.Fd, e3 &= h4 * (l4 - 1) + c4 <= t5.Cd, e3 = (e3 &= f4 * (l4 - 1) + c4 <= t5.Ed) & u4 >= o3 & h4 >= c4 & f4 >= c4, e3 &= null != t5.y, e3 &= null != t5.f, e3 &= null != t5.ea, 12 == i3 && (e3 &= d4 >= o3, e3 &= p4 <= t5.Tc, e3 &= null != t5.F);
            }
          else
            e3 = 0;
          t5 = e3 ? 0 : 2;
        }
      }
      return 0 != t5 || null != r3 && r3.fd && (t5 = Er(n3)), t5;
    }
    var Dr = 64, Rr = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tr = 24, Ur = 32, zr = 8, Hr = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    R2("Predictor0", "PredictorAdd0"), t4.Predictor0 = function() {
      return 4278190080;
    }, t4.Predictor1 = function(t5) {
      return t5;
    }, t4.Predictor2 = function(t5, e3, r3) {
      return e3[r3 + 0];
    }, t4.Predictor3 = function(t5, e3, r3) {
      return e3[r3 + 1];
    }, t4.Predictor4 = function(t5, e3, r3) {
      return e3[r3 - 1];
    }, t4.Predictor5 = function(t5, e3, r3) {
      return U2(U2(t5, e3[r3 + 1]), e3[r3 + 0]);
    }, t4.Predictor6 = function(t5, e3, r3) {
      return U2(t5, e3[r3 - 1]);
    }, t4.Predictor7 = function(t5, e3, r3) {
      return U2(t5, e3[r3 + 0]);
    }, t4.Predictor8 = function(t5, e3, r3) {
      return U2(e3[r3 - 1], e3[r3 + 0]);
    }, t4.Predictor9 = function(t5, e3, r3) {
      return U2(e3[r3 + 0], e3[r3 + 1]);
    }, t4.Predictor10 = function(t5, e3, r3) {
      return U2(U2(t5, e3[r3 - 1]), U2(e3[r3 + 0], e3[r3 + 1]));
    }, t4.Predictor11 = function(t5, e3, r3) {
      var n3 = e3[r3 + 0];
      return 0 >= W2(n3 >> 24 & 255, t5 >> 24 & 255, (e3 = e3[r3 - 1]) >> 24 & 255) + W2(n3 >> 16 & 255, t5 >> 16 & 255, e3 >> 16 & 255) + W2(n3 >> 8 & 255, t5 >> 8 & 255, e3 >> 8 & 255) + W2(255 & n3, 255 & t5, 255 & e3) ? n3 : t5;
    }, t4.Predictor12 = function(t5, e3, r3) {
      var n3 = e3[r3 + 0];
      return (z2((t5 >> 24 & 255) + (n3 >> 24 & 255) - ((e3 = e3[r3 - 1]) >> 24 & 255)) << 24 | z2((t5 >> 16 & 255) + (n3 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | z2((t5 >> 8 & 255) + (n3 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | z2((255 & t5) + (255 & n3) - (255 & e3))) >>> 0;
    }, t4.Predictor13 = function(t5, e3, r3) {
      var n3 = e3[r3 - 1];
      return (H4((t5 = U2(t5, e3[r3 + 0])) >> 24 & 255, n3 >> 24 & 255) << 24 | H4(t5 >> 16 & 255, n3 >> 16 & 255) << 16 | H4(t5 >> 8 & 255, n3 >> 8 & 255) << 8 | H4(t5 >> 0 & 255, n3 >> 0 & 255)) >>> 0;
    };
    var Wr = t4.PredictorAdd0;
    t4.PredictorAdd1 = V2, R2("Predictor2", "PredictorAdd2"), R2("Predictor3", "PredictorAdd3"), R2("Predictor4", "PredictorAdd4"), R2("Predictor5", "PredictorAdd5"), R2("Predictor6", "PredictorAdd6"), R2("Predictor7", "PredictorAdd7"), R2("Predictor8", "PredictorAdd8"), R2("Predictor9", "PredictorAdd9"), R2("Predictor10", "PredictorAdd10"), R2("Predictor11", "PredictorAdd11"), R2("Predictor12", "PredictorAdd12"), R2("Predictor13", "PredictorAdd13");
    var Vr = t4.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t5) {
      return t5 >> 8 & 255;
    }, function(t5) {
      return t5;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t5) {
      return t5;
    }, function(t5) {
      return t5 >> 8 & 255;
    });
    var Gr, Yr = t4.ColorIndexInverseTransform, Jr = t4.MapARGB, Xr = t4.VP8LColorIndexInverseTransformAlpha, Kr = t4.MapAlpha, Zr = t4.VP8LPredictorsAdd = [];
    Zr.length = 16, (t4.VP8LPredictors = []).length = 16, (t4.VP8LPredictorsAdd_C = []).length = 16, (t4.VP8LPredictors_C = []).length = 16;
    var $r, Qr, tn2, en2, rn2, nn2, an2, on2, sn2, cn2, un2, hn2, ln2, fn3, dn2, pn2, gn2, mn2, vn2, bn2, yn2, wn2, Nn2, Ln2, An2, xn2, Sn2, _n2, Pn2 = a2(511), kn2 = a2(2041), In2 = a2(225), Fn2 = a2(767), Cn2 = 0, jn2 = kn2, On2 = In2, Bn2 = Fn2, Mn2 = Pn2, En2 = 0, qn2 = 1, Dn2 = 2, Rn2 = 3, Tn2 = 4, Un2 = 5, zn2 = 6, Hn2 = 7, Wn2 = 8, Vn2 = 9, Gn2 = 10, Yn2 = [2, 3, 7], Jn = [3, 3, 11], Xn = [280, 256, 256, 256, 40], Kn2 = [0, 1, 1, 1, 0], Zn = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], $n2 = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Qn2 = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], ti2 = 8, ei2 = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ri2 = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni2 = null, ii2 = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ai2 = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], oi2 = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], si2 = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], ci2 = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui2 = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], hi2 = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li2 = [], fi2 = [], di2 = [], pi2 = 1, gi2 = 2, mi2 = [], vi2 = [];
    vr("UpsampleRgbLinePair", Ar, 3), vr("UpsampleBgrLinePair", xr, 3), vr("UpsampleRgbaLinePair", Ir, 4), vr("UpsampleBgraLinePair", kr, 4), vr("UpsampleArgbLinePair", Pr, 4), vr("UpsampleRgba4444LinePair", _r, 2), vr("UpsampleRgb565LinePair", Sr, 2);
    var bi2 = t4.UpsampleRgbLinePair, yi2 = t4.UpsampleBgrLinePair, wi2 = t4.UpsampleRgbaLinePair, Ni2 = t4.UpsampleBgraLinePair, Li2 = t4.UpsampleArgbLinePair, Ai2 = t4.UpsampleRgba4444LinePair, xi2 = t4.UpsampleRgb565LinePair, Si2 = 16, _i = 1 << Si2 - 1, Pi2 = -227, ki2 = 482, Ii2 = 6, Fi2 = (256 << Ii2) - 1, Ci2 = 0, ji2 = a2(256), Oi2 = a2(256), Bi2 = a2(256), Mi2 = a2(256), Ei2 = a2(ki2 - Pi2), qi2 = a2(ki2 - Pi2);
    Fr("YuvToRgbRow", Ar, 3), Fr("YuvToBgrRow", xr, 3), Fr("YuvToRgbaRow", Ir, 4), Fr("YuvToBgraRow", kr, 4), Fr("YuvToArgbRow", Pr, 4), Fr("YuvToRgba4444Row", _r, 2), Fr("YuvToRgb565Row", Sr, 2);
    var Di2 = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri2 = [0, 2, 8], Ti2 = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ui2 = 1;
    this.WebPDecodeRGBA = function(t5, r3, n3, i3, a3) {
      var o3 = qn2, s3 = new rr(), c4 = new ot2();
      s3.ba = c4, c4.S = o3, c4.width = [c4.width], c4.height = [c4.height];
      var u4 = c4.width, h4 = c4.height, l4 = new st2();
      if (null == l4 || null == t5)
        var f4 = 2;
      else
        e2(null != l4), f4 = Br(t5, r3, n3, l4.width, l4.height, l4.Pd, l4.Qd, l4.format, null);
      if (0 != f4 ? u4 = 0 : (null != u4 && (u4[0] = l4.width[0]), null != h4 && (h4[0] = l4.height[0]), u4 = 1), u4) {
        c4.width = c4.width[0], c4.height = c4.height[0], null != i3 && (i3[0] = c4.width), null != a3 && (a3[0] = c4.height);
        t: {
          if (i3 = new Gt2(), (a3 = new nr()).data = t5, a3.w = r3, a3.ha = n3, a3.kd = 1, r3 = [0], e2(null != a3), (0 == (t5 = Br(a3.data, a3.w, a3.ha, null, null, null, r3, null, a3)) || 7 == t5) && r3[0] && (t5 = 4), 0 == (r3 = t5)) {
            if (e2(null != s3), i3.data = a3.data, i3.w = a3.w + a3.offset, i3.ha = a3.ha - a3.offset, i3.put = dt2, i3.ac = ft2, i3.bc = pt2, i3.ma = s3, a3.xa) {
              if (null == (t5 = kt2())) {
                s3 = 1;
                break t;
              }
              if (function(t6, r4) {
                var n4 = [0], i4 = [0], a4 = [0];
                e:
                  for (; ; ) {
                    if (null == t6)
                      return 0;
                    if (null == r4)
                      return t6.a = 2, 0;
                    if (t6.l = r4, t6.a = 0, v3(t6.m, r4.data, r4.w, r4.ha), !gt2(t6.m, n4, i4, a4)) {
                      t6.a = 3;
                      break e;
                    }
                    if (t6.xb = gi2, r4.width = n4[0], r4.height = i4[0], !It2(n4[0], i4[0], 1, t6, null))
                      break e;
                    return 1;
                  }
                return e2(0 != t6.a), 0;
              }(t5, i3)) {
                if (i3 = 0 == (r3 = qr(i3.width, i3.height, s3.Oa, s3.ba))) {
                  e: {
                    i3 = t5;
                    r:
                      for (; ; ) {
                        if (null == i3) {
                          i3 = 0;
                          break e;
                        }
                        if (e2(null != i3.s.yc), e2(null != i3.s.Ya), e2(0 < i3.s.Wb), e2(null != (n3 = i3.l)), e2(null != (a3 = n3.ma)), 0 != i3.xb) {
                          if (i3.ca = a3.ba, i3.tb = a3.tb, e2(null != i3.ca), !Mr(a3.Oa, n3, Rn2)) {
                            i3.a = 2;
                            break r;
                          }
                          if (!Ft3(i3, n3.width))
                            break r;
                          if (n3.da)
                            break r;
                          if ((n3.da || nt2(i3.ca.S)) && mr(), 11 > i3.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != i3.ca.f.kb.F && mr()), i3.Pb && 0 < i3.s.ua && null == i3.s.vb.X && !O2(i3.s.vb, i3.s.Wa.Xa)) {
                            i3.a = 1;
                            break r;
                          }
                          i3.xb = 0;
                        }
                        if (!_t5(i3, i3.V, i3.Ba, i3.c, i3.i, n3.o, Lt2))
                          break r;
                        a3.Dc = i3.Ma, i3 = 1;
                        break e;
                      }
                    e2(0 != i3.a), i3 = 0;
                  }
                  i3 = !i3;
                }
                i3 && (r3 = t5.a);
              } else
                r3 = t5.a;
            } else {
              if (null == (t5 = new Yt2())) {
                s3 = 1;
                break t;
              }
              if (t5.Fa = a3.na, t5.P = a3.P, t5.qc = a3.Sa, Kt2(t5, i3)) {
                if (0 == (r3 = qr(i3.width, i3.height, s3.Oa, s3.ba))) {
                  if (t5.Aa = 0, n3 = s3.Oa, e2(null != (a3 = t5)), null != n3) {
                    if (0 < (u4 = 0 > (u4 = n3.Md) ? 0 : 100 < u4 ? 255 : 255 * u4 / 100)) {
                      for (h4 = l4 = 0; 4 > h4; ++h4)
                        12 > (f4 = a3.pb[h4]).lc && (f4.ia = u4 * Ti2[0 > f4.lc ? 0 : f4.lc] >> 3), l4 |= f4.ia;
                      l4 && (alert("todo:VP8InitRandom"), a3.ia = 1);
                    }
                    a3.Ga = n3.Id, 100 < a3.Ga ? a3.Ga = 100 : 0 > a3.Ga && (a3.Ga = 0);
                  }
                  Qt2(t5, i3) || (r3 = t5.a);
                }
              } else
                r3 = t5.a;
            }
            0 == r3 && null != s3.Oa && s3.Oa.fd && (r3 = Er(s3.ba));
          }
          s3 = r3;
        }
        o3 = 0 != s3 ? null : 11 > o3 ? c4.f.RGBA.eb : c4.f.kb.y;
      } else
        o3 = null;
      return o3;
    };
    var zi2 = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function u2(t4, e3) {
    for (var r3 = "", n3 = 0; n3 < 4; n3++)
      r3 += String.fromCharCode(t4[e3++]);
    return r3;
  }
  function h2(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16) >>> 0;
  }
  function l2(t4, e3) {
    return (t4[e3 + 0] << 0 | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24) >>> 0;
  }
  new c2();
  var f2 = [0], d2 = [0], p2 = [], g2 = new c2(), m2 = t3, v2 = function(t4, e3) {
    var r3 = {}, n3 = 0, i3 = false, a3 = 0, o3 = 0;
    if (r3.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    function(t5, e4, r4, n4) {
      for (var i4 = 0; i4 < n4; i4++)
        if (t5[e4 + i4] != r4.charCodeAt(i4))
          return true;
      return false;
    }(t4, e3, "RIFF", 4)) {
      var s3, c3;
      l2(t4, e3 += 4);
      for (e3 += 8; e3 < t4.length; ) {
        var f3 = u2(t4, e3), d3 = l2(t4, e3 += 4);
        e3 += 4;
        var p3 = d3 + (1 & d3);
        switch (f3) {
          case "VP8 ":
          case "VP8L":
            void 0 === r3.frames[n3] && (r3.frames[n3] = {});
            (v3 = r3.frames[n3]).src_off = i3 ? o3 : e3 - 8, v3.src_size = a3 + d3 + 8, n3++, i3 && (i3 = false, a3 = 0, o3 = 0);
            break;
          case "VP8X":
            (v3 = r3.header = {}).feature_flags = t4[e3];
            var g3 = e3 + 4;
            v3.canvas_width = 1 + h2(t4, g3);
            g3 += 3;
            v3.canvas_height = 1 + h2(t4, g3);
            g3 += 3;
            break;
          case "ALPH":
            i3 = true, a3 = p3 + 8, o3 = e3 - 8;
            break;
          case "ANIM":
            (v3 = r3.header).bgcolor = l2(t4, e3);
            g3 = e3 + 4;
            v3.loop_count = (s3 = t4)[(c3 = g3) + 0] << 0 | s3[c3 + 1] << 8;
            g3 += 2;
            break;
          case "ANMF":
            var m3, v3;
            (v3 = r3.frames[n3] = {}).offset_x = 2 * h2(t4, e3), e3 += 3, v3.offset_y = 2 * h2(t4, e3), e3 += 3, v3.width = 1 + h2(t4, e3), e3 += 3, v3.height = 1 + h2(t4, e3), e3 += 3, v3.duration = h2(t4, e3), e3 += 3, m3 = t4[e3++], v3.dispose = 1 & m3, v3.blend = m3 >> 1 & 1;
        }
        "ANMF" != f3 && (e3 += p3);
      }
      return r3;
    }
  }(m2, 0);
  v2.response = m2, v2.rgbaoutput = true, v2.dataurl = false;
  var b2 = v2.header ? v2.header : null, y2 = v2.frames ? v2.frames : null;
  if (b2) {
    b2.loop_counter = b2.loop_count, f2 = [b2.canvas_height], d2 = [b2.canvas_width];
    for (var w2 = 0; w2 < y2.length && 0 != y2[w2].blend; w2++)
      ;
  }
  var N2 = y2[0], L2 = g2.WebPDecodeRGBA(m2, N2.src_off, N2.src_size, d2, f2);
  N2.rgba = L2, N2.imgwidth = d2[0], N2.imgheight = f2[0];
  for (var A2 = 0; A2 < d2[0] * f2[0] * 4; A2++)
    p2[A2] = L2[A2];
  return this.width = d2, this.height = f2, this.data = p2, this;
}
!function(t3) {
  var r2 = function() {
    return "function" == typeof zlibSync;
  }, n2 = function(r3, n3, a3, h3) {
    var l3 = 4, f3 = s2;
    switch (h3) {
      case t3.image_compression.FAST:
        l3 = 1, f3 = o2;
        break;
      case t3.image_compression.MEDIUM:
        l3 = 6, f3 = c2;
        break;
      case t3.image_compression.SLOW:
        l3 = 9, f3 = u2;
    }
    r3 = i2(r3, n3, a3, f3);
    var d2 = zlibSync(r3, { level: l3 });
    return t3.__addimage__.arrayBufferToBinaryString(d2);
  }, i2 = function(t4, e2, r3, n3) {
    for (var i3, a3, o3, s3 = t4.length / e2, c3 = new Uint8Array(t4.length + s3), u3 = l2(), h3 = 0; h3 < s3; h3 += 1) {
      if (o3 = h3 * e2, i3 = t4.subarray(o3, o3 + e2), n3)
        c3.set(n3(i3, r3, a3), o3 + h3);
      else {
        for (var d2, p2 = u3.length, g2 = []; d2 < p2; d2 += 1)
          g2[d2] = u3[d2](i3, r3, a3);
        var m2 = f2(g2.concat());
        c3.set(g2[m2], o3 + h3);
      }
      a3 = i3;
    }
    return c3;
  }, a2 = function(t4) {
    var e2 = Array.apply([], t4);
    return e2.unshift(0), e2;
  }, o2 = function(t4, e2) {
    var r3, n3 = [], i3 = t4.length;
    n3[0] = 1;
    for (var a3 = 0; a3 < i3; a3 += 1)
      r3 = t4[a3 - e2] || 0, n3[a3 + 1] = t4[a3] - r3 + 256 & 255;
    return n3;
  }, s2 = function(t4, e2, r3) {
    var n3, i3 = [], a3 = t4.length;
    i3[0] = 2;
    for (var o3 = 0; o3 < a3; o3 += 1)
      n3 = r3 && r3[o3] || 0, i3[o3 + 1] = t4[o3] - n3 + 256 & 255;
    return i3;
  }, c2 = function(t4, e2, r3) {
    var n3, i3, a3 = [], o3 = t4.length;
    a3[0] = 3;
    for (var s3 = 0; s3 < o3; s3 += 1)
      n3 = t4[s3 - e2] || 0, i3 = r3 && r3[s3] || 0, a3[s3 + 1] = t4[s3] + 256 - (n3 + i3 >>> 1) & 255;
    return a3;
  }, u2 = function(t4, e2, r3) {
    var n3, i3, a3, o3, s3 = [], c3 = t4.length;
    s3[0] = 4;
    for (var u3 = 0; u3 < c3; u3 += 1)
      n3 = t4[u3 - e2] || 0, i3 = r3 && r3[u3] || 0, a3 = r3 && r3[u3 - e2] || 0, o3 = h2(n3, i3, a3), s3[u3 + 1] = t4[u3] - o3 + 256 & 255;
    return s3;
  }, h2 = function(t4, e2, r3) {
    if (t4 === e2 && e2 === r3)
      return t4;
    var n3 = Math.abs(e2 - r3), i3 = Math.abs(t4 - r3), a3 = Math.abs(t4 + e2 - r3 - r3);
    return n3 <= i3 && n3 <= a3 ? t4 : i3 <= a3 ? e2 : r3;
  }, l2 = function() {
    return [a2, o2, s2, c2, u2];
  }, f2 = function(t4) {
    var e2 = t4.map(function(t5) {
      return t5.reduce(function(t6, e3) {
        return t6 + Math.abs(e3);
      }, 0);
    });
    return e2.indexOf(Math.min.apply(null, e2));
  };
  t3.processPNG = function(e2, i3, a3, o3) {
    var s3, c3, u3, h3, l3, f3, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2 = this.decode.FLATE_DECODE, A2 = "";
    if (this.__addimage__.isArrayBuffer(e2) && (e2 = new Uint8Array(e2)), this.__addimage__.isArrayBufferView(e2)) {
      if (e2 = (u3 = new Kt(e2)).imgData, c3 = u3.bits, s3 = u3.colorSpace, l3 = u3.colors, -1 !== [4, 6].indexOf(u3.colorType)) {
        if (8 === u3.bits) {
          g2 = (p2 = 32 == u3.pixelBitlength ? new Uint32Array(u3.decodePixels().buffer) : 16 == u3.pixelBitlength ? new Uint16Array(u3.decodePixels().buffer) : new Uint8Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * u3.colors), m2 = new Uint8Array(g2);
          var x2, S2 = u3.pixelBitlength - u3.bits;
          for (w2 = 0, N2 = 0; w2 < g2; w2++) {
            for (y2 = p2[w2], x2 = 0; x2 < S2; )
              v2[N2++] = y2 >>> x2 & 255, x2 += u3.bits;
            m2[w2] = y2 >>> x2 & 255;
          }
        }
        if (16 === u3.bits) {
          g2 = (p2 = new Uint32Array(u3.decodePixels().buffer)).length, v2 = new Uint8Array(g2 * (32 / u3.pixelBitlength) * u3.colors), m2 = new Uint8Array(g2 * (32 / u3.pixelBitlength)), b2 = u3.colors > 1, w2 = 0, N2 = 0;
          for (var _2 = 0; w2 < g2; )
            y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255, b2 && (v2[N2++] = y2 >>> 16 & 255, y2 = p2[w2++], v2[N2++] = y2 >>> 0 & 255), m2[_2++] = y2 >>> 16 & 255;
          c3 = 8;
        }
        o3 !== t3.image_compression.NONE && r2() ? (e2 = n2(v2, u3.width * u3.colors, u3.colors, o3), d2 = n2(m2, u3.width, 1, o3)) : (e2 = v2, d2 = m2, L2 = void 0);
      }
      if (3 === u3.colorType && (s3 = this.color_spaces.INDEXED, f3 = u3.palette, u3.transparency.indexed)) {
        var P2 = u3.transparency.indexed, k2 = 0;
        for (w2 = 0, g2 = P2.length; w2 < g2; ++w2)
          k2 += P2[w2];
        if ((k2 /= 255) === g2 - 1 && -1 !== P2.indexOf(0))
          h3 = [P2.indexOf(0)];
        else if (k2 !== g2) {
          for (p2 = u3.decodePixels(), m2 = new Uint8Array(p2.length), w2 = 0, g2 = p2.length; w2 < g2; w2++)
            m2[w2] = P2[p2[w2]];
          d2 = n2(m2, u3.width, 1);
        }
      }
      var I2 = function(e3) {
        var r3;
        switch (e3) {
          case t3.image_compression.FAST:
            r3 = 11;
            break;
          case t3.image_compression.MEDIUM:
            r3 = 13;
            break;
          case t3.image_compression.SLOW:
            r3 = 14;
            break;
          default:
            r3 = 12;
        }
        return r3;
      }(o3);
      return L2 === this.decode.FLATE_DECODE && (A2 = "/Predictor " + I2 + " "), A2 += "/Colors " + l3 + " /BitsPerComponent " + c3 + " /Columns " + u3.width, (this.__addimage__.isArrayBuffer(e2) || this.__addimage__.isArrayBufferView(e2)) && (e2 = this.__addimage__.arrayBufferToBinaryString(e2)), (d2 && this.__addimage__.isArrayBuffer(d2) || this.__addimage__.isArrayBufferView(d2)) && (d2 = this.__addimage__.arrayBufferToBinaryString(d2)), { alias: a3, data: e2, index: i3, filter: L2, decodeParameters: A2, transparency: h3, palette: f3, sMask: d2, predictor: I2, width: u3.width, height: u3.height, bitsPerComponent: c3, colorSpace: s3 };
    }
  };
}(E.API), function(t3) {
  t3.processGIF89A = function(e2, r2, n2, i2) {
    var a2 = new Zt(e2), o2 = a2.width, s2 = a2.height, c2 = [];
    a2.decodeAndBlitFrameRGBA(0, c2);
    var u2 = { data: c2, width: o2, height: s2 }, h2 = new Qt(100).encode(u2, 100);
    return t3.processJPEG.call(this, h2, r2, n2, i2);
  }, t3.processGIF87A = t3.processGIF89A;
}(E.API), te.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t3 = 0 === this.colors ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t3);
    for (var e2 = 0; e2 < t3; e2++) {
      var r2 = this.datav.getUint8(this.pos++, true), n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
      this.palette[e2] = { red: i2, green: n2, blue: r2, quad: a2 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, te.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t3 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
    this.data = new Uint8Array(e2), this[t3]();
  } catch (t4) {
    a.log("bit decode error:" + t4);
  }
}, te.prototype.bit1 = function() {
  var t3, e2 = Math.ceil(this.width / 8), r2 = e2 % 4;
  for (t3 = this.height - 1; t3 >= 0; t3--) {
    for (var n2 = this.bottom_up ? t3 : this.height - 1 - t3, i2 = 0; i2 < e2; i2++)
      for (var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
        var c2 = this.palette[a2 >> 7 - s2 & 1];
        this.data[o2 + 4 * s2] = c2.blue, this.data[o2 + 4 * s2 + 1] = c2.green, this.data[o2 + 4 * s2 + 2] = c2.red, this.data[o2 + 4 * s2 + 3] = 255;
      }
    0 !== r2 && (this.pos += 4 - r2);
  }
}, te.prototype.bit4 = function() {
  for (var t3 = Math.ceil(this.width / 2), e2 = t3 % 4, r2 = this.height - 1; r2 >= 0; r2--) {
    for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < t3; i2++) {
      var a2 = this.datav.getUint8(this.pos++, true), o2 = n2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, c2 = 15 & a2, u2 = this.palette[s2];
      if (this.data[o2] = u2.blue, this.data[o2 + 1] = u2.green, this.data[o2 + 2] = u2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width)
        break;
      u2 = this.palette[c2], this.data[o2 + 4] = u2.blue, this.data[o2 + 4 + 1] = u2.green, this.data[o2 + 4 + 2] = u2.red, this.data[o2 + 4 + 3] = 255;
    }
    0 !== e2 && (this.pos += 4 - e2);
  }
}, te.prototype.bit8 = function() {
  for (var t3 = this.width % 4, e2 = this.height - 1; e2 >= 0; e2--) {
    for (var r2 = this.bottom_up ? e2 : this.height - 1 - e2, n2 = 0; n2 < this.width; n2++) {
      var i2 = this.datav.getUint8(this.pos++, true), a2 = r2 * this.width * 4 + 4 * n2;
      if (i2 < this.palette.length) {
        var o2 = this.palette[i2];
        this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
      } else
        this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
    }
    0 !== t3 && (this.pos += 4 - t3);
  }
}, te.prototype.bit15 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = this.height - 1; r2 >= 0; r2--) {
    for (var n2 = this.bottom_up ? r2 : this.height - 1 - r2, i2 = 0; i2 < this.width; i2++) {
      var a2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o2 = (a2 & e2) / e2 * 255 | 0, s2 = (a2 >> 5 & e2) / e2 * 255 | 0, c2 = (a2 >> 10 & e2) / e2 * 255 | 0, u2 = a2 >> 15 ? 255 : 0, h2 = n2 * this.width * 4 + 4 * i2;
      this.data[h2] = c2, this.data[h2 + 1] = s2, this.data[h2 + 2] = o2, this.data[h2 + 3] = u2;
    }
    this.pos += t3;
  }
}, te.prototype.bit16 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), r2 = parseInt("111111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
    for (var i2 = this.bottom_up ? n2 : this.height - 1 - n2, a2 = 0; a2 < this.width; a2++) {
      var o2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s2 = (o2 & e2) / e2 * 255 | 0, c2 = (o2 >> 5 & r2) / r2 * 255 | 0, u2 = (o2 >> 11) / e2 * 255 | 0, h2 = i2 * this.width * 4 + 4 * a2;
      this.data[h2] = u2, this.data[h2 + 1] = c2, this.data[h2 + 2] = s2, this.data[h2 + 3] = 255;
    }
    this.pos += t3;
  }
}, te.prototype.bit24 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--) {
    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e2 * this.width * 4 + 4 * r2;
      this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = n2, this.data[o2 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, te.prototype.bit32 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--)
    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, r2 = 0; r2 < this.width; r2++) {
      var n2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e2 * this.width * 4 + 4 * r2;
      this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = n2, this.data[s2 + 3] = o2;
    }
}, te.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  t3.processBMP = function(e2, r2, n2, i2) {
    var a2 = new te(e2, false), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t3.processJPEG.call(this, u2, r2, n2, i2);
  };
}(E.API), ee.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  t3.processWEBP = function(e2, r2, n2, i2) {
    var a2 = new ee(e2), o2 = a2.width, s2 = a2.height, c2 = { data: a2.getData(), width: o2, height: s2 }, u2 = new Qt(100).encode(c2, 100);
    return t3.processJPEG.call(this, u2, r2, n2, i2);
  };
}(E.API), E.API.processRGBA = function(t3, e2, r2) {
  for (var n2 = t3.data, i2 = n2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, c2 = 0, u2 = 0; u2 < i2; u2 += 4) {
    var h2 = n2[u2], l2 = n2[u2 + 1], f2 = n2[u2 + 2], d2 = n2[u2 + 3];
    a2[s2++] = h2, a2[s2++] = l2, a2[s2++] = f2, o2[c2++] = d2;
  }
  var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e2, alias: r2, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t3.width, height: t3.height };
}, E.API.setLanguage = function(t3) {
  return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t3] && (this.internal.languageSettings.languageCode = t3, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Vt = E.API, Gt = Vt.getCharWidthsArray = function(e2, r2) {
  var n2, i2, a2 = (r2 = r2 || {}).font || this.internal.getFont(), o2 = r2.fontSize || this.internal.getFontSize(), s2 = r2.charSpace || this.internal.getCharSpace(), c2 = r2.widths ? r2.widths : a2.metadata.Unicode.widths, u2 = c2.fof ? c2.fof : 1, h2 = r2.kerning ? r2.kerning : a2.metadata.Unicode.kerning, l2 = h2.fof ? h2.fof : 1, f2 = false !== r2.doKerning, d2 = 0, p2 = e2.length, g2 = 0, m2 = c2[0] || u2, v2 = [];
  for (n2 = 0; n2 < p2; n2++)
    i2 = e2.charCodeAt(n2), "function" == typeof a2.metadata.widthOfString ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && "object" === _typeof$2(h2[i2]) && !isNaN(parseInt(h2[i2][g2], 10)) ? h2[i2][g2] / l2 : 0, v2.push((c2[i2] || m2) / u2 + d2)), g2 = i2;
  return v2;
}, Yt = Vt.getStringUnitWidth = function(t3, e2) {
  var r2 = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), n2 = e2.font || this.internal.getFont(), i2 = e2.charSpace || this.internal.getCharSpace();
  return Vt.processArabic && (t3 = Vt.processArabic(t3)), "function" == typeof n2.metadata.widthOfString ? n2.metadata.widthOfString(t3, r2, i2) / r2 : Gt.apply(this, arguments).reduce(function(t4, e3) {
    return t4 + e3;
  }, 0);
}, Jt = function(t3, e2, r2, n2) {
  for (var i2 = [], a2 = 0, o2 = t3.length, s2 = 0; a2 !== o2 && s2 + e2[a2] < r2; )
    s2 += e2[a2], a2++;
  i2.push(t3.slice(0, a2));
  var c2 = a2;
  for (s2 = 0; a2 !== o2; )
    s2 + e2[a2] > n2 && (i2.push(t3.slice(c2, a2)), s2 = 0, c2 = a2), s2 += e2[a2], a2++;
  return c2 !== a2 && i2.push(t3.slice(c2, a2)), i2;
}, Xt2 = function(t3, e2, r2) {
  r2 || (r2 = {});
  var n2, i2, a2, o2, s2, c2, u2, h2 = [], l2 = [h2], f2 = r2.textIndent || 0, d2 = 0, p2 = 0, g2 = t3.split(" "), m2 = Gt.apply(this, [" ", r2])[0];
  if (c2 = -1 === r2.lineIndent ? g2[0].length + 2 : r2.lineIndent || 0) {
    var v2 = Array(c2).join(" "), b2 = [];
    g2.map(function(t4) {
      (t4 = t4.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t4.map(function(t5, e3) {
        return (e3 && t5.length ? "\n" : "") + t5;
      })) : b2.push(t4[0]);
    }), g2 = b2, c2 = Yt.apply(this, [v2, r2]);
  }
  for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
    var y2 = 0;
    if (n2 = g2[a2], c2 && "\n" == n2[0] && (n2 = n2.substr(1), y2 = 1), f2 + d2 + (p2 = (i2 = Gt.apply(this, [n2, r2])).reduce(function(t4, e3) {
      return t4 + e3;
    }, 0)) > e2 || y2) {
      if (p2 > e2) {
        for (s2 = Jt.apply(this, [n2, i2, e2 - (f2 + d2), e2]), h2.push(s2.shift()), h2 = [s2.pop()]; s2.length; )
          l2.push([s2.shift()]);
        p2 = i2.slice(n2.length - (h2[0] ? h2[0].length : 0)).reduce(function(t4, e3) {
          return t4 + e3;
        }, 0);
      } else
        h2 = [n2];
      l2.push(h2), f2 = p2 + c2, d2 = m2;
    } else
      h2.push(n2), f2 += d2 + p2, d2 = m2;
  }
  return u2 = c2 ? function(t4, e3) {
    return (e3 ? v2 : "") + t4.join(" ");
  } : function(t4) {
    return t4.join(" ");
  }, l2.map(u2);
}, Vt.splitTextToSize = function(t3, e2, r2) {
  var n2, i2 = (r2 = r2 || {}).fontSize || this.internal.getFontSize(), a2 = function(t4) {
    if (t4.widths && t4.kerning)
      return { widths: t4.widths, kerning: t4.kerning };
    var e3 = this.internal.getFont(t4.fontName, t4.fontStyle);
    return e3.metadata.Unicode ? { widths: e3.metadata.Unicode.widths || { 0: 1 }, kerning: e3.metadata.Unicode.kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }.call(this, r2);
  n2 = Array.isArray(t3) ? t3 : String(t3).split(/\r?\n/);
  var o2 = 1 * this.internal.scaleFactor * e2 / i2;
  a2.textIndent = r2.textIndent ? 1 * r2.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = r2.lineIndent;
  var s2, c2, u2 = [];
  for (s2 = 0, c2 = n2.length; s2 < c2; s2++)
    u2 = u2.concat(Xt2.apply(this, [n2[s2], o2, a2]));
  return u2;
}, function(e2) {
  e2.__fontmetrics__ = e2.__fontmetrics__ || {};
  for (var r2 = "klmnopqrstuvwxyz", n2 = {}, i2 = {}, a2 = 0; a2 < r2.length; a2++)
    n2[r2[a2]] = "0123456789abcdef"[a2], i2["0123456789abcdef"[a2]] = r2[a2];
  var o2 = function(t3) {
    return "0x" + parseInt(t3, 10).toString(16);
  }, s2 = e2.__fontmetrics__.compress = function(e3) {
    var r3, n3, a3, c3, u3 = ["{"];
    for (var h3 in e3) {
      if (r3 = e3[h3], isNaN(parseInt(h3, 10)) ? n3 = "'" + h3 + "'" : (h3 = parseInt(h3, 10), n3 = (n3 = o2(h3).slice(2)).slice(0, -1) + i2[n3.slice(-1)]), "number" == typeof r3)
        r3 < 0 ? (a3 = o2(r3).slice(3), c3 = "-") : (a3 = o2(r3).slice(2), c3 = ""), a3 = c3 + a3.slice(0, -1) + i2[a3.slice(-1)];
      else {
        if ("object" !== _typeof$2(r3))
          throw new Error("Don't know what to do with value type " + _typeof$2(r3) + ".");
        a3 = s2(r3);
      }
      u3.push(n3 + a3);
    }
    return u3.push("}"), u3.join("");
  }, c2 = e2.__fontmetrics__.uncompress = function(t3) {
    if ("string" != typeof t3)
      throw new Error("Invalid argument passed to uncompress.");
    for (var e3, r3, i3, a3, o3 = {}, s3 = 1, c3 = o3, u3 = [], h3 = "", l3 = "", f2 = t3.length - 1, d2 = 1; d2 < f2; d2 += 1)
      "'" == (a3 = t3[d2]) ? e3 ? (i3 = e3.join(""), e3 = void 0) : e3 = [] : e3 ? e3.push(a3) : "{" == a3 ? (u3.push([c3, i3]), c3 = {}, i3 = void 0) : "}" == a3 ? ((r3 = u3.pop())[0][r3[1]] = c3, i3 = void 0, c3 = r3[0]) : "-" == a3 ? s3 = -1 : void 0 === i3 ? n2.hasOwnProperty(a3) ? (h3 += n2[a3], i3 = parseInt(h3, 16) * s3, s3 = 1, h3 = "") : h3 += a3 : n2.hasOwnProperty(a3) ? (l3 += n2[a3], c3[i3] = parseInt(l3, 16) * s3, s3 = 1, i3 = void 0, l3 = "") : l3 += a3;
    return o3;
  }, u2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: u2, "Courier-Bold": u2, "Courier-BoldOblique": u2, "Courier-Oblique": u2, Helvetica: u2, "Helvetica-Bold": u2, "Helvetica-BoldOblique": u2, "Helvetica-Oblique": u2, "Times-Roman": u2, "Times-Bold": u2, "Times-BoldItalic": u2, "Times-Italic": u2 } }, l2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e2.events.push(["addFont", function(t3) {
    var e3 = t3.font, r3 = l2.Unicode[e3.postScriptName];
    r3 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = r3.widths, e3.metadata.Unicode.kerning = r3.kerning);
    var n3 = h2.Unicode[e3.postScriptName];
    n3 && (e3.metadata.Unicode.encoding = n3, e3.encoding = n3.codePages[0]);
  }]);
}(E.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = function(t4) {
    for (var e3 = t4.length, r2 = new Uint8Array(e3), n2 = 0; n2 < e3; n2++)
      r2[n2] = t4.charCodeAt(n2);
    return r2;
  };
  t3.API.events.push(["addFont", function(r2) {
    var n2 = void 0, i2 = r2.font, a2 = r2.instance;
    if (!i2.isStandardFont) {
      if (void 0 === a2)
        throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      if ("string" != typeof (n2 = false === a2.existsFileInVFS(i2.postScriptName) ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName)))
        throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      !function(r3, n3) {
        n3 = /^\x00\x01\x00\x00/.test(n3) ? e2(n3) : e2(u(n3)), r3.metadata = t3.API.TTFFont.open(n3), r3.metadata.Unicode = r3.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, r3.metadata.glyIdsUsed = [0];
      }(i2, n2);
    }
  }]);
}(E), /** @license
 * Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t3) {
  function e2() {
    return (n.canvg ? Promise.resolve(n.canvg) : __vitePreload(() => import("./index.es-e5dd5417.js"), true ? [] : void 0, import.meta.url)).catch(function(t4) {
      return Promise.reject(new Error("Could not load canvg: " + t4));
    }).then(function(t4) {
      return t4.default ? t4.default : t4;
    });
  }
  E.API.addSvgAsImage = function(t4, r2, n2, i2, o2, s2, c2, u2) {
    if (isNaN(r2) || isNaN(n2))
      throw a.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(i2) || isNaN(o2))
      throw a.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var h2 = document.createElement("canvas");
    h2.width = i2, h2.height = o2;
    var l2 = h2.getContext("2d");
    l2.fillStyle = "#fff", l2.fillRect(0, 0, h2.width, h2.height);
    var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
    return e2().then(function(e3) {
      return e3.fromString(l2, t4, f2);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t5) {
      return t5.render(f2);
    }).then(function() {
      d2.addImage(h2.toDataURL("image/jpeg", 1), r2, n2, i2, o2, c2, u2);
    });
  };
}(), E.API.putTotalPages = function(t3) {
  var e2, r2 = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t3, "g"), r2 = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t3, this.internal.getFont()), "g"), r2 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n2 = 1; n2 <= this.internal.getNumberOfPages(); n2++)
    for (var i2 = 0; i2 < this.internal.pages[n2].length; i2++)
      this.internal.pages[n2][i2] = this.internal.pages[n2][i2].replace(e2, r2);
  return this;
}, E.API.viewerPreferences = function(e2, r2) {
  var n2;
  e2 = e2 || {}, r2 = r2 || false;
  var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, c2 = Object.keys(s2), u2 = [], h2 = 0, l2 = 0, f2 = 0;
  function d2(t3, e3) {
    var r3, n3 = false;
    for (r3 = 0; r3 < t3.length; r3 += 1)
      t3[r3] === e3 && (n3 = true);
    return n3;
  }
  if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), n2 = this.internal.viewerpreferences.configuration, "reset" === e2 || true === r2) {
    var p2 = c2.length;
    for (f2 = 0; f2 < p2; f2 += 1)
      n2[c2[f2]].value = n2[c2[f2]].defaultValue, n2[c2[f2]].explicitSet = false;
  }
  if ("object" === _typeof$2(e2)) {
    for (a2 in e2)
      if (o2 = e2[a2], d2(c2, a2) && void 0 !== o2) {
        if ("boolean" === n2[a2].type && "boolean" == typeof o2)
          n2[a2].value = o2;
        else if ("name" === n2[a2].type && d2(n2[a2].valueSet, o2))
          n2[a2].value = o2;
        else if ("integer" === n2[a2].type && Number.isInteger(o2))
          n2[a2].value = o2;
        else if ("array" === n2[a2].type) {
          for (h2 = 0; h2 < o2.length; h2 += 1)
            if (i2 = true, 1 === o2[h2].length && "number" == typeof o2[h2][0])
              u2.push(String(o2[h2] - 1));
            else if (o2[h2].length > 1) {
              for (l2 = 0; l2 < o2[h2].length; l2 += 1)
                "number" != typeof o2[h2][l2] && (i2 = false);
              true === i2 && u2.push([o2[h2][0] - 1, o2[h2][1] - 1].join(" "));
            }
          n2[a2].value = "[" + u2.join(" ") + "]";
        } else
          n2[a2].value = n2[a2].defaultValue;
        n2[a2].explicitSet = true;
      }
  }
  return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    var t3, e3 = [];
    for (t3 in n2)
      true === n2[t3].explicitSet && ("name" === n2[t3].type ? e3.push("/" + t3 + " /" + n2[t3].value) : e3.push("/" + t3 + " " + n2[t3].value));
    0 !== e3.length && this.internal.write("/ViewerPreferences\n<<\n" + e3.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = n2, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
function(t3) {
  var e2 = function() {
    var t4 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), r3 = unescape(encodeURIComponent(t4)), n2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = r3.length + n2.length + i2.length + e3.length + a2.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e3 + r3 + n2 + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
  }, r2 = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  t3.addMetadata = function(t4, n2) {
    return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t4, namespaceuri: n2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", r2), this.internal.events.subscribe("postPutResources", e2)), this;
  };
}(E.API), function(t3) {
  var e2 = t3.API, r2 = e2.pdfEscape16 = function(t4, e3) {
    for (var r3, n3 = e3.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t4.length; o2 < s2; ++o2) {
      if (r3 = e3.metadata.characterToGlyph(t4.charCodeAt(o2)), e3.metadata.glyIdsUsed.push(r3), e3.metadata.toUnicode[r3] = t4.charCodeAt(o2), -1 == n3.indexOf(r3) && (n3.push(r3), n3.push([parseInt(e3.metadata.widthOfGlyph(r3), 10)])), "0" == r3)
        return a2.join("");
      r3 = r3.toString(16), a2.push(i3[4 - r3.length], r3);
    }
    return a2.join("");
  }, n2 = function(t4) {
    var e3, r3, n3, i3, a2, o2, s2;
    for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", n3 = [], o2 = 0, s2 = (r3 = Object.keys(t4).sort(function(t5, e4) {
      return t5 - e4;
    })).length; o2 < s2; o2++)
      e3 = r3[o2], n3.length >= 100 && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar", n3 = []), void 0 !== t4[e3] && null !== t4[e3] && "function" == typeof t4[e3].toString && (i3 = ("0000" + t4[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), n3.push("<" + e3 + "><" + i3 + ">"));
    return n3.length && (a2 += "\n" + n3.length + " beginbfchar\n" + n3.join("\n") + "\nendbfchar\n"), a2 += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r3.metadata instanceof t3.API.TTFFont && "Identity-H" === r3.encoding) {
        for (var s2 = r3.metadata.Unicode.widths, c2 = r3.metadata.subset.encode(r3.metadata.glyIdsUsed, 1), u2 = "", h2 = 0; h2 < c2.length; h2++)
          u2 += String.fromCharCode(c2[h2]);
        var l2 = a2();
        o2({ data: u2, addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: f2 }), i3("endobj");
        var d2 = a2();
        i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + F(r3.fontName)), i3("/FontFile2 " + l2 + " 0 R"), i3("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i3("/Flags " + r3.metadata.flags), i3("/StemV " + r3.metadata.stemV), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3(">>"), i3("endobj");
        var p2 = a2();
        i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + F(r3.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t3.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + r3.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), r3.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + F(r3.fontName)), i3("/Encoding /" + r3.encoding), i3("/DescendantFonts [" + p2 + " 0 R]"), i3(">>"), i3("endobj"), r3.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  e2.events.push(["putFont", function(e3) {
    !function(e4) {
      var r3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (r3.metadata instanceof t3.API.TTFFont && "WinAnsiEncoding" === r3.encoding) {
        for (var s2 = r3.metadata.rawData, c2 = "", u2 = 0; u2 < s2.length; u2++)
          c2 += String.fromCharCode(s2[u2]);
        var h2 = a2();
        o2({ data: c2, addLength1: true, objectId: h2 }), i3("endobj");
        var l2 = a2();
        o2({ data: n2(r3.metadata.toUnicode), addLength1: true, objectId: l2 }), i3("endobj");
        var f2 = a2();
        i3("<<"), i3("/Descent " + r3.metadata.decender), i3("/CapHeight " + r3.metadata.capHeight), i3("/StemV " + r3.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + h2 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t3.API.PDFObject.convert(r3.metadata.bbox)), i3("/FontName /" + F(r3.fontName)), i3("/ItalicAngle " + r3.metadata.italicAngle), i3("/Ascent " + r3.metadata.ascender), i3(">>"), i3("endobj"), r3.objectNumber = a2();
        for (var d2 = 0; d2 < r3.metadata.hmtx.widths.length; d2++)
          r3.metadata.hmtx.widths[d2] = parseInt(r3.metadata.hmtx.widths[d2] * (1e3 / r3.metadata.head.unitsPerEm));
        i3("<</Subtype/TrueType/Type/Font/ToUnicode " + l2 + " 0 R/BaseFont/" + F(r3.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + r3.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t3.API.PDFObject.convert(r3.metadata.hmtx.widths) + ">>"), i3("endobj"), r3.isAlreadyPutted = true;
      }
    }(e3);
  }]);
  var i2 = function(t4) {
    var e3, n3 = t4.text || "", i3 = t4.x, a2 = t4.y, o2 = t4.options || {}, s2 = t4.mutex || {}, c2 = s2.pdfEscape, u2 = s2.activeFontKey, h2 = s2.fonts, l2 = u2, f2 = "", d2 = 0, p2 = "", g2 = h2[l2].encoding;
    if ("Identity-H" !== h2[l2].encoding)
      return { text: n3, x: i3, y: a2, options: o2, mutex: s2 };
    for (p2 = n3, l2 = u2, Array.isArray(n3) && (p2 = n3[0]), d2 = 0; d2 < p2.length; d2 += 1)
      h2[l2].metadata.hasOwnProperty("cmap") && (e3 = h2[l2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e3 || p2[d2].charCodeAt(0) < 256 && h2[l2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d2] : f2 += "";
    var m2 = "";
    return parseInt(l2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m2 = c2(f2, l2).split("").map(function(t5) {
      return t5.charCodeAt(0).toString(16);
    }).join("") : "Identity-H" === g2 && (m2 = r2(f2, h2[l2])), s2.isHex = true, { text: m2, x: i3, y: a2, options: o2, mutex: s2 };
  };
  e2.events.push(["postProcessText", function(t4) {
    var e3 = t4.text || "", r3 = [], n3 = { text: e3, x: t4.x, y: t4.y, options: t4.options, mutex: t4.mutex };
    if (Array.isArray(e3)) {
      var a2 = 0;
      for (a2 = 0; a2 < e3.length; a2 += 1)
        Array.isArray(e3[a2]) && 3 === e3[a2].length ? r3.push([i2(Object.assign({}, n3, { text: e3[a2][0] })).text, e3[a2][1], e3[a2][2]]) : r3.push(i2(Object.assign({}, n3, { text: e3[a2] })).text);
      t4.text = r3;
    } else
      t4.text = i2(Object.assign({}, n3, { text: e3 })).text;
  }]);
}(E), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function(t3) {
  var e2 = function() {
    return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
  };
  t3.existsFileInVFS = function(t4) {
    return e2.call(this), void 0 !== this.internal.vFS[t4];
  }, t3.addFileToVFS = function(t4, r2) {
    return e2.call(this), this.internal.vFS[t4] = r2, this;
  }, t3.getFileFromVFS = function(t4) {
    return e2.call(this), void 0 !== this.internal.vFS[t4] ? this.internal.vFS[t4] : null;
  };
}(E.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
function(t3) {
  t3.__bidiEngine__ = t3.prototype.__bidiEngine__ = function(t4) {
    var r3, n2, i2, a2, o2, s2, c2, u2 = e2, h2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], l2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
    this.__bidiEngine__ = {};
    var b2 = function(t5) {
      var e3 = t5.charCodeAt(), r4 = e3 >> 8, n3 = d2[r4];
      return void 0 !== n3 ? u2[256 * n3 + (255 & e3)] : 252 === r4 || 253 === r4 ? "AL" : g2.test(r4) ? "L" : 8 === r4 ? "R" : "N";
    }, y2 = function(t5) {
      for (var e3, r4 = 0; r4 < t5.length; r4++) {
        if ("L" === (e3 = b2(t5.charAt(r4))))
          return false;
        if ("R" === e3)
          return true;
      }
      return false;
    }, w2 = function(t5, e3, o3, s3) {
      var c3, u3, h3, l3, f3 = e3[s3];
      switch (f3) {
        case "L":
        case "R":
          m2 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m2 && (f3 = "AN");
          break;
        case "AL":
          m2 = true, f3 = "R";
          break;
        case "WS":
          f3 = "N";
          break;
        case "CS":
          s3 < 1 || s3 + 1 >= e3.length || "EN" !== (c3 = o3[s3 - 1]) && "AN" !== c3 || "EN" !== (u3 = e3[s3 + 1]) && "AN" !== u3 ? f3 = "N" : m2 && (u3 = "AN"), f3 = u3 === c3 ? u3 : "N";
          break;
        case "ES":
          f3 = "EN" === (c3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e3.length && "EN" === e3[s3 + 1] ? "EN" : "N";
          break;
        case "ET":
          if (s3 > 0 && "EN" === o3[s3 - 1]) {
            f3 = "EN";
            break;
          }
          if (m2) {
            f3 = "N";
            break;
          }
          for (h3 = s3 + 1, l3 = e3.length; h3 < l3 && "ET" === e3[h3]; )
            h3++;
          f3 = h3 < l3 && "EN" === e3[h3] ? "EN" : "N";
          break;
        case "NSM":
          if (i2 && !a2) {
            for (l3 = e3.length, h3 = s3 + 1; h3 < l3 && "NSM" === e3[h3]; )
              h3++;
            if (h3 < l3) {
              var d3 = t5[s3], p3 = d3 >= 1425 && d3 <= 2303 || 64286 === d3;
              if (c3 = e3[h3], p3 && ("R" === c3 || "AL" === c3)) {
                f3 = "R";
                break;
              }
            }
          }
          f3 = s3 < 1 || "B" === (c3 = e3[s3 - 1]) ? "N" : o3[s3 - 1];
          break;
        case "B":
          m2 = false, r3 = true, f3 = v2;
          break;
        case "S":
          n2 = true, f3 = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m2 = false;
          break;
        case "BN":
          f3 = "N";
      }
      return f3;
    }, N2 = function(t5, e3, r4) {
      var n3 = t5.split("");
      return r4 && L2(n3, r4, { hiLevel: v2 }), n3.reverse(), e3 && e3.reverse(), n3.join("");
    }, L2 = function(t5, e3, i3) {
      var a3, o3, s3, c3, u3, d3 = -1, p3 = t5.length, g3 = 0, y3 = [], N3 = v2 ? l2 : h2, L3 = [];
      for (m2 = false, r3 = false, n2 = false, o3 = 0; o3 < p3; o3++)
        L3[o3] = b2(t5[o3]);
      for (s3 = 0; s3 < p3; s3++) {
        if (u3 = g3, y3[s3] = w2(t5, L3, y3, s3), a3 = 240 & (g3 = N3[u3][f2[y3[s3]]]), g3 &= 15, e3[s3] = c3 = N3[g3][5], a3 > 0)
          if (16 === a3) {
            for (o3 = d3; o3 < s3; o3++)
              e3[o3] = 1;
            d3 = -1;
          } else
            d3 = -1;
        if (N3[g3][6])
          -1 === d3 && (d3 = s3);
        else if (d3 > -1) {
          for (o3 = d3; o3 < s3; o3++)
            e3[o3] = c3;
          d3 = -1;
        }
        "B" === L3[s3] && (e3[s3] = 0), i3.hiLevel |= c3;
      }
      n2 && function(t6, e4, r4) {
        for (var n3 = 0; n3 < r4; n3++)
          if ("S" === t6[n3]) {
            e4[n3] = v2;
            for (var i4 = n3 - 1; i4 >= 0 && "WS" === t6[i4]; i4--)
              e4[i4] = v2;
          }
      }(L3, e3, p3);
    }, A2 = function(t5, e3, n3, i3, a3) {
      if (!(a3.hiLevel < t5)) {
        if (1 === t5 && 1 === v2 && !r3)
          return e3.reverse(), void (n3 && n3.reverse());
        for (var o3, s3, c3, u3, h3 = e3.length, l3 = 0; l3 < h3; ) {
          if (i3[l3] >= t5) {
            for (c3 = l3 + 1; c3 < h3 && i3[c3] >= t5; )
              c3++;
            for (u3 = l3, s3 = c3 - 1; u3 < s3; u3++, s3--)
              o3 = e3[u3], e3[u3] = e3[s3], e3[s3] = o3, n3 && (o3 = n3[u3], n3[u3] = n3[s3], n3[s3] = o3);
            l3 = c3;
          }
          l3++;
        }
      }
    }, x2 = function(t5, e3, r4) {
      var n3 = t5.split(""), i3 = { hiLevel: v2 };
      return r4 || (r4 = []), L2(n3, r4, i3), function(t6, e4, r5) {
        if (0 !== r5.hiLevel && c2)
          for (var n4, i4 = 0; i4 < t6.length; i4++)
            1 === e4[i4] && (n4 = p2.indexOf(t6[i4])) >= 0 && (t6[i4] = p2[n4 + 1]);
      }(n3, r4, i3), A2(2, n3, e3, r4, i3), A2(1, n3, e3, r4, i3), n3.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(t5, e3, r4) {
      if (function(t6, e4) {
        if (e4)
          for (var r5 = 0; r5 < t6.length; r5++)
            e4[r5] = r5;
        void 0 === a2 && (a2 = y2(t6)), void 0 === s2 && (s2 = y2(t6));
      }(t5, e3), i2 || !o2 || s2)
        if (i2 && o2 && a2 ^ s2)
          v2 = a2 ? 1 : 0, t5 = N2(t5, e3, r4);
        else if (!i2 && o2 && s2)
          v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);
        else if (!i2 || a2 || o2 || s2) {
          if (i2 && !o2 && a2 ^ s2)
            t5 = N2(t5, e3), a2 ? (v2 = 0, t5 = x2(t5, e3, r4)) : (v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3));
          else if (i2 && a2 && !o2 && s2)
            v2 = 1, t5 = x2(t5, e3, r4), t5 = N2(t5, e3);
          else if (!i2 && !o2 && a2 ^ s2) {
            var n3 = c2;
            a2 ? (v2 = 1, t5 = x2(t5, e3, r4), v2 = 0, c2 = false, t5 = x2(t5, e3, r4), c2 = n3) : (v2 = 0, t5 = x2(t5, e3, r4), t5 = N2(t5, e3), v2 = 1, c2 = false, t5 = x2(t5, e3, r4), c2 = n3, t5 = N2(t5, e3));
          }
        } else
          v2 = 0, t5 = x2(t5, e3, r4);
      else
        v2 = a2 ? 1 : 0, t5 = x2(t5, e3, r4);
      return t5;
    }, this.__bidiEngine__.setOptions = function(t5) {
      t5 && (i2 = t5.isInputVisual, o2 = t5.isOutputVisual, a2 = t5.isInputRtl, s2 = t5.isOutputRtl, c2 = t5.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t4), this.__bidiEngine__;
  };
  var e2 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], r2 = new t3.__bidiEngine__({ isInputVisual: true });
  t3.API.events.push(["postProcessText", function(t4) {
    var e3 = t4.text, n2 = (t4.x, t4.y, t4.options || {}), i2 = (t4.mutex, n2.lang, []);
    if (n2.isInputVisual = "boolean" != typeof n2.isInputVisual || n2.isInputVisual, r2.setOptions(n2), "[object Array]" === Object.prototype.toString.call(e3)) {
      var a2 = 0;
      for (i2 = [], a2 = 0; a2 < e3.length; a2 += 1)
        "[object Array]" === Object.prototype.toString.call(e3[a2]) ? i2.push([r2.doBidiReorder(e3[a2][0]), e3[a2][1], e3[a2][2]]) : i2.push([r2.doBidiReorder(e3[a2])]);
      t4.text = i2;
    } else
      t4.text = r2.doBidiReorder(e3);
    r2.setOptions({ isInputVisual: true });
  }]);
}(E), E.API.TTFFont = function() {
  function t3(t4) {
    var e2;
    if (this.rawData = t4, e2 = this.contents = new ne(t4), this.contents.pos = 4, "ttcf" === e2.readString(4))
      throw new Error("TTCF not supported.");
    e2.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF();
  }
  return t3.open = function(e2) {
    return new t3(e2);
  }, t3.prototype.parse = function() {
    return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t3.prototype.registerTTF = function() {
    var t4, e2, r2, n2, i2;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = function() {
      var e3, r3, n3, i3;
      for (i3 = [], e3 = 0, r3 = (n3 = this.bbox).length; e3 < r3; e3++)
        t4 = n3[e3], i3.push(Math.round(t4 * this.scaleFactor));
      return i3;
    }.call(this), this.stemV = 0, this.post.exists ? (r2 = 255 & (n2 = this.post.italic_angle), 0 != (32768 & (e2 = n2 >> 16)) && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + "." + r2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i2 = this.familyClass) || 2 === i2 || 3 === i2 || 4 === i2 || 5 === i2 || 7 === i2, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode)
      throw new Error("No unicode cmap for font");
  }, t3.prototype.characterToGlyph = function(t4) {
    var e2;
    return (null != (e2 = this.cmap.unicode) ? e2.codeMap[t4] : void 0) || 0;
  }, t3.prototype.widthOfGlyph = function(t4) {
    var e2;
    return e2 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t4).advance * e2;
  }, t3.prototype.widthOfString = function(t4, e2, r2) {
    var n2, i2, a2, o2;
    for (a2 = 0, i2 = 0, o2 = (t4 = "" + t4).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2)
      n2 = t4.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(n2)) + r2 * (1e3 / e2) || 0;
    return a2 * (e2 / 1e3);
  }, t3.prototype.lineHeight = function(t4, e2) {
    var r2;
    return null == e2 && (e2 = false), r2 = e2 ? this.lineGap : 0, (this.ascender + r2 - this.decender) / 1e3 * t4;
  }, t3;
}();
var re, ne = function() {
  function t3(t4) {
    this.data = null != t4 ? t4 : [], this.pos = 0, this.length = this.data.length;
  }
  return t3.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t3.prototype.writeByte = function(t4) {
    return this.data[this.pos++] = t4;
  }, t3.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t3.prototype.writeUInt32 = function(t4) {
    return this.writeByte(t4 >>> 24 & 255), this.writeByte(t4 >> 16 & 255), this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt32 = function() {
    var t4;
    return (t4 = this.readUInt32()) >= 2147483648 ? t4 - 4294967296 : t4;
  }, t3.prototype.writeInt32 = function(t4) {
    return t4 < 0 && (t4 += 4294967296), this.writeUInt32(t4);
  }, t3.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t3.prototype.writeUInt16 = function(t4) {
    return this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt16 = function() {
    var t4;
    return (t4 = this.readUInt16()) >= 32768 ? t4 - 65536 : t4;
  }, t3.prototype.writeInt16 = function(t4) {
    return t4 < 0 && (t4 += 65536), this.writeUInt16(t4);
  }, t3.prototype.readString = function(t4) {
    var e2, r2;
    for (r2 = [], e2 = 0; 0 <= t4 ? e2 < t4 : e2 > t4; e2 = 0 <= t4 ? ++e2 : --e2)
      r2[e2] = String.fromCharCode(this.readByte());
    return r2.join("");
  }, t3.prototype.writeString = function(t4) {
    var e2, r2, n2;
    for (n2 = [], e2 = 0, r2 = t4.length; 0 <= r2 ? e2 < r2 : e2 > r2; e2 = 0 <= r2 ? ++e2 : --e2)
      n2.push(this.writeByte(t4.charCodeAt(e2)));
    return n2;
  }, t3.prototype.readShort = function() {
    return this.readInt16();
  }, t3.prototype.writeShort = function(t4) {
    return this.writeInt16(t4);
  }, t3.prototype.readLongLong = function() {
    var t4, e2, r2, n2, i2, a2, o2, s2;
    return t4 = this.readByte(), e2 = this.readByte(), r2 = this.readByte(), n2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t4 ? -1 * (72057594037927940 * (255 ^ t4) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ r2) + 4294967296 * (255 ^ n2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t4 + 281474976710656 * e2 + 1099511627776 * r2 + 4294967296 * n2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
  }, t3.prototype.writeLongLong = function(t4) {
    var e2, r2;
    return e2 = Math.floor(t4 / 4294967296), r2 = 4294967295 & t4, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(r2 >> 24 & 255), this.writeByte(r2 >> 16 & 255), this.writeByte(r2 >> 8 & 255), this.writeByte(255 & r2);
  }, t3.prototype.readInt = function() {
    return this.readInt32();
  }, t3.prototype.writeInt = function(t4) {
    return this.writeInt32(t4);
  }, t3.prototype.read = function(t4) {
    var e2, r2;
    for (e2 = [], r2 = 0; 0 <= t4 ? r2 < t4 : r2 > t4; r2 = 0 <= t4 ? ++r2 : --r2)
      e2.push(this.readByte());
    return e2;
  }, t3.prototype.write = function(t4) {
    var e2, r2, n2, i2;
    for (i2 = [], r2 = 0, n2 = t4.length; r2 < n2; r2++)
      e2 = t4[r2], i2.push(this.writeByte(e2));
    return i2;
  }, t3;
}(), ie = function() {
  var t3;
  function e2(t4) {
    var e3, r2, n2;
    for (this.scalarType = t4.readInt(), this.tableCount = t4.readShort(), this.searchRange = t4.readShort(), this.entrySelector = t4.readShort(), this.rangeShift = t4.readShort(), this.tables = {}, r2 = 0, n2 = this.tableCount; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2)
      e3 = { tag: t4.readString(4), checksum: t4.readInt(), offset: t4.readInt(), length: t4.readInt() }, this.tables[e3.tag] = e3;
  }
  return e2.prototype.encode = function(e3) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2;
    for (p2 in f2 = Object.keys(e3).length, s2 = Math.log(2), h2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(h2 / s2), u2 = 16 * f2 - h2, (n2 = new ne()).writeInt(this.scalarType), n2.writeShort(f2), n2.writeShort(h2), n2.writeShort(a2), n2.writeShort(u2), i2 = 16 * f2, c2 = n2.pos + i2, o2 = null, d2 = [], e3)
      for (l2 = e3[p2], n2.writeString(p2), n2.writeInt(t3(l2)), n2.writeInt(c2), n2.writeInt(l2.length), d2 = d2.concat(l2), "head" === p2 && (o2 = c2), c2 += l2.length; c2 % 4; )
        d2.push(0), c2++;
    return n2.write(d2), r2 = 2981146554 - t3(n2.data), n2.pos = o2 + 8, n2.writeUInt32(r2), n2.data;
  }, t3 = function(t4) {
    var e3, r2, n2, i2;
    for (t4 = ve.call(t4); t4.length % 4; )
      t4.push(0);
    for (n2 = new ne(t4), r2 = 0, e3 = 0, i2 = t4.length; e3 < i2; e3 = e3 += 4)
      r2 += n2.readUInt32();
    return 4294967295 & r2;
  }, e2;
}(), ae = {}.hasOwnProperty, oe = function(t3, e2) {
  for (var r2 in e2)
    ae.call(e2, r2) && (t3[r2] = e2[r2]);
  function n2() {
    this.constructor = t3;
  }
  return n2.prototype = e2.prototype, t3.prototype = new n2(), t3.__super__ = e2.prototype, t3;
};
re = function() {
  function t3(t4) {
    var e2;
    this.file = t4, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));
  }
  return t3.prototype.parse = function() {
  }, t3.prototype.encode = function() {
  }, t3.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t3;
}();
var se = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "head", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.revision = t4.readInt(), this.checkSumAdjustment = t4.readInt(), this.magicNumber = t4.readInt(), this.flags = t4.readShort(), this.unitsPerEm = t4.readShort(), this.created = t4.readLongLong(), this.modified = t4.readLongLong(), this.xMin = t4.readShort(), this.yMin = t4.readShort(), this.xMax = t4.readShort(), this.yMax = t4.readShort(), this.macStyle = t4.readShort(), this.lowestRecPPEM = t4.readShort(), this.fontDirectionHint = t4.readShort(), this.indexToLocFormat = t4.readShort(), this.glyphDataFormat = t4.readShort();
  }, e2.prototype.encode = function(t4) {
    var e3;
    return (e3 = new ne()).writeInt(this.version), e3.writeInt(this.revision), e3.writeInt(this.checkSumAdjustment), e3.writeInt(this.magicNumber), e3.writeShort(this.flags), e3.writeShort(this.unitsPerEm), e3.writeLongLong(this.created), e3.writeLongLong(this.modified), e3.writeShort(this.xMin), e3.writeShort(this.yMin), e3.writeShort(this.xMax), e3.writeShort(this.yMax), e3.writeShort(this.macStyle), e3.writeShort(this.lowestRecPPEM), e3.writeShort(this.fontDirectionHint), e3.writeShort(t4), e3.writeShort(this.glyphDataFormat), e3.data;
  }, e2;
}(), ce = function() {
  function t3(t4, e2) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2;
    switch (this.platformID = t4.readUInt16(), this.encodingID = t4.readShort(), this.offset = e2 + t4.readInt(), h2 = t4.pos, t4.pos = this.offset, this.format = t4.readUInt16(), this.length = t4.readUInt16(), this.language = t4.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
      case 0:
        for (s2 = 0; s2 < 256; ++s2)
          this.codeMap[s2] = t4.readByte();
        break;
      case 4:
        for (f2 = t4.readUInt16(), l2 = f2 / 2, t4.pos += 6, i2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), t4.pos += 2, p2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), c2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), u2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= l2 ? e3 < l2 : e3 > l2; s2 = 0 <= l2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), n2 = (this.length - t4.pos + this.offset) / 2, o2 = function() {
          var e3, r3;
          for (r3 = [], s2 = e3 = 0; 0 <= n2 ? e3 < n2 : e3 > n2; s2 = 0 <= n2 ? ++e3 : --e3)
            r3.push(t4.readUInt16());
          return r3;
        }(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2)
          for (g2 = i2[s2], r2 = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; r2 = d2 <= g2 ? ++v2 : --v2)
            0 === u2[s2] ? a2 = r2 + c2[s2] : 0 !== (a2 = o2[u2[s2] / 2 + (r2 - d2) - (l2 - s2)] || 0) && (a2 += c2[s2]), this.codeMap[r2] = 65535 & a2;
    }
    t4.pos = h2;
  }
  return t3.encode = function(t4, e2) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, A2, x2, S2, _2, P2, k2, I2, F2, C2, j2, O2, B3, M2, E2, q2, D2, R2, T2, U2, z2, H4, W2, V2, G2, Y2;
    switch (I2 = new ne(), a2 = Object.keys(t4).sort(function(t5, e3) {
      return t5 - e3;
    }), e2) {
      case "macroman":
        for (p2 = 0, g2 = function() {
          var t5 = [];
          for (d2 = 0; d2 < 256; ++d2)
            t5.push(0);
          return t5;
        }(), v2 = { 0: 0 }, i2 = {}, F2 = 0, B3 = a2.length; F2 < B3; F2++)
          null == v2[W2 = t4[n2 = a2[F2]]] && (v2[W2] = ++p2), i2[n2] = { old: t4[n2], new: v2[t4[n2]] }, g2[n2] = v2[t4[n2]];
        return I2.writeUInt16(1), I2.writeUInt16(0), I2.writeUInt32(12), I2.writeUInt16(0), I2.writeUInt16(262), I2.writeUInt16(0), I2.write(g2), { charMap: i2, subtable: I2.data, maxGlyphID: p2 + 1 };
      case "unicode":
        for (P2 = [], h2 = [], b2 = 0, v2 = {}, r2 = {}, m2 = c2 = null, C2 = 0, M2 = a2.length; C2 < M2; C2++)
          null == v2[w2 = t4[n2 = a2[C2]]] && (v2[w2] = ++b2), r2[n2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - n2, null != m2 && o2 === c2 || (m2 && h2.push(m2), P2.push(n2), c2 = o2), m2 = n2;
        for (m2 && h2.push(m2), h2.push(65535), P2.push(65535), S2 = 2 * (x2 = P2.length), A2 = 2 * Math.pow(Math.log(x2) / Math.LN2, 2), l2 = Math.log(A2 / 2) / Math.LN2, L2 = 2 * x2 - A2, s2 = [], N2 = [], f2 = [], d2 = j2 = 0, E2 = P2.length; j2 < E2; d2 = ++j2) {
          if (_2 = P2[d2], u2 = h2[d2], 65535 === _2) {
            s2.push(0), N2.push(0);
            break;
          }
          if (_2 - (k2 = r2[_2].new) >= 32768)
            for (s2.push(0), N2.push(2 * (f2.length + x2 - d2)), n2 = O2 = _2; _2 <= u2 ? O2 <= u2 : O2 >= u2; n2 = _2 <= u2 ? ++O2 : --O2)
              f2.push(r2[n2].new);
          else
            s2.push(k2 - _2), N2.push(0);
        }
        for (I2.writeUInt16(3), I2.writeUInt16(1), I2.writeUInt32(12), I2.writeUInt16(4), I2.writeUInt16(16 + 8 * x2 + 2 * f2.length), I2.writeUInt16(0), I2.writeUInt16(S2), I2.writeUInt16(A2), I2.writeUInt16(l2), I2.writeUInt16(L2), z2 = 0, q2 = h2.length; z2 < q2; z2++)
          n2 = h2[z2], I2.writeUInt16(n2);
        for (I2.writeUInt16(0), H4 = 0, D2 = P2.length; H4 < D2; H4++)
          n2 = P2[H4], I2.writeUInt16(n2);
        for (V2 = 0, R2 = s2.length; V2 < R2; V2++)
          o2 = s2[V2], I2.writeUInt16(o2);
        for (G2 = 0, T2 = N2.length; G2 < T2; G2++)
          y2 = N2[G2], I2.writeUInt16(y2);
        for (Y2 = 0, U2 = f2.length; Y2 < U2; Y2++)
          p2 = f2[Y2], I2.writeUInt16(p2);
        return { charMap: r2, subtable: I2.data, maxGlyphID: b2 + 1 };
    }
  }, t3;
}(), ue = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "cmap", e2.prototype.parse = function(t4) {
    var e3, r2, n2;
    for (t4.pos = this.offset, this.version = t4.readUInt16(), n2 = t4.readUInt16(), this.tables = [], this.unicode = null, r2 = 0; 0 <= n2 ? r2 < n2 : r2 > n2; r2 = 0 <= n2 ? ++r2 : --r2)
      e3 = new ce(t4, this.offset), this.tables.push(e3), e3.isUnicode && null == this.unicode && (this.unicode = e3);
    return true;
  }, e2.encode = function(t4, e3) {
    var r2, n2;
    return null == e3 && (e3 = "macroman"), r2 = ce.encode(t4, e3), (n2 = new ne()).writeUInt16(0), n2.writeUInt16(1), r2.table = n2.data.concat(r2.subtable), r2;
  }, e2;
}(), he = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hhea", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.ascender = t4.readShort(), this.decender = t4.readShort(), this.lineGap = t4.readShort(), this.advanceWidthMax = t4.readShort(), this.minLeftSideBearing = t4.readShort(), this.minRightSideBearing = t4.readShort(), this.xMaxExtent = t4.readShort(), this.caretSlopeRise = t4.readShort(), this.caretSlopeRun = t4.readShort(), this.caretOffset = t4.readShort(), t4.pos += 8, this.metricDataFormat = t4.readShort(), this.numberOfMetrics = t4.readUInt16();
  }, e2;
}(), le = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "OS/2", e2.prototype.parse = function(t4) {
    if (t4.pos = this.offset, this.version = t4.readUInt16(), this.averageCharWidth = t4.readShort(), this.weightClass = t4.readUInt16(), this.widthClass = t4.readUInt16(), this.type = t4.readShort(), this.ySubscriptXSize = t4.readShort(), this.ySubscriptYSize = t4.readShort(), this.ySubscriptXOffset = t4.readShort(), this.ySubscriptYOffset = t4.readShort(), this.ySuperscriptXSize = t4.readShort(), this.ySuperscriptYSize = t4.readShort(), this.ySuperscriptXOffset = t4.readShort(), this.ySuperscriptYOffset = t4.readShort(), this.yStrikeoutSize = t4.readShort(), this.yStrikeoutPosition = t4.readShort(), this.familyClass = t4.readShort(), this.panose = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 10; ++e3)
        r2.push(t4.readByte());
      return r2;
    }(), this.charRange = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 4; ++e3)
        r2.push(t4.readInt());
      return r2;
    }(), this.vendorID = t4.readString(4), this.selection = t4.readShort(), this.firstCharIndex = t4.readShort(), this.lastCharIndex = t4.readShort(), this.version > 0 && (this.ascent = t4.readShort(), this.descent = t4.readShort(), this.lineGap = t4.readShort(), this.winAscent = t4.readShort(), this.winDescent = t4.readShort(), this.codePageRange = function() {
      var e3, r2;
      for (r2 = [], e3 = 0; e3 < 2; e3 = ++e3)
        r2.push(t4.readInt());
      return r2;
    }(), this.version > 1))
      return this.xHeight = t4.readShort(), this.capHeight = t4.readShort(), this.defaultChar = t4.readShort(), this.breakChar = t4.readShort(), this.maxContext = t4.readShort();
  }, e2;
}(), fe = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "post", e2.prototype.parse = function(t4) {
    var e3, r2, n2;
    switch (t4.pos = this.offset, this.format = t4.readInt(), this.italicAngle = t4.readInt(), this.underlinePosition = t4.readShort(), this.underlineThickness = t4.readShort(), this.isFixedPitch = t4.readInt(), this.minMemType42 = t4.readInt(), this.maxMemType42 = t4.readInt(), this.minMemType1 = t4.readInt(), this.maxMemType1 = t4.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var i2;
        for (r2 = t4.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= r2 ? i2 < r2 : i2 > r2; i2 = 0 <= r2 ? ++i2 : --i2)
          this.glyphNameIndex.push(t4.readUInt16());
        for (this.names = [], n2 = []; t4.pos < this.offset + this.length; )
          e3 = t4.readByte(), n2.push(this.names.push(t4.readString(e3)));
        return n2;
      case 151552:
        return r2 = t4.readUInt16(), this.offsets = t4.read(r2);
      case 196608:
        break;
      case 262144:
        return this.map = function() {
          var e4, r3, n3;
          for (n3 = [], i2 = e4 = 0, r3 = this.file.maxp.numGlyphs; 0 <= r3 ? e4 < r3 : e4 > r3; i2 = 0 <= r3 ? ++e4 : --e4)
            n3.push(t4.readUInt32());
          return n3;
        }.call(this);
    }
  }, e2;
}(), de = function(t3, e2) {
  this.raw = t3, this.length = t3.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;
}, pe = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "name", e2.prototype.parse = function(t4) {
    var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2, l2;
    for (t4.pos = this.offset, t4.readShort(), e3 = t4.readShort(), o2 = t4.readShort(), r2 = [], i2 = 0; 0 <= e3 ? i2 < e3 : i2 > e3; i2 = 0 <= e3 ? ++i2 : --i2)
      r2.push({ platformID: t4.readShort(), encodingID: t4.readShort(), languageID: t4.readShort(), nameID: t4.readShort(), length: t4.readShort(), offset: this.offset + o2 + t4.readShort() });
    for (s2 = {}, i2 = u2 = 0, h2 = r2.length; u2 < h2; i2 = ++u2)
      n2 = r2[i2], t4.pos = n2.offset, c2 = t4.readString(n2.length), a2 = new de(c2, n2), null == s2[l2 = n2.nameID] && (s2[l2] = []), s2[n2.nameID].push(a2);
    this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
    try {
      this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (t5) {
      this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
  }, e2;
}(), ge = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "maxp", e2.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.numGlyphs = t4.readUInt16(), this.maxPoints = t4.readUInt16(), this.maxContours = t4.readUInt16(), this.maxCompositePoints = t4.readUInt16(), this.maxComponentContours = t4.readUInt16(), this.maxZones = t4.readUInt16(), this.maxTwilightPoints = t4.readUInt16(), this.maxStorage = t4.readUInt16(), this.maxFunctionDefs = t4.readUInt16(), this.maxInstructionDefs = t4.readUInt16(), this.maxStackElements = t4.readUInt16(), this.maxSizeOfInstructions = t4.readUInt16(), this.maxComponentElements = t4.readUInt16(), this.maxComponentDepth = t4.readUInt16();
  }, e2;
}(), me = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "hmtx", e2.prototype.parse = function(t4) {
    var e3, r2, n2, i2, a2, o2, s2;
    for (t4.pos = this.offset, this.metrics = [], e3 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e3 < o2 : e3 > o2; e3 = 0 <= o2 ? ++e3 : --e3)
      this.metrics.push({ advance: t4.readUInt16(), lsb: t4.readInt16() });
    for (n2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var r3, i3;
      for (i3 = [], e3 = r3 = 0; 0 <= n2 ? r3 < n2 : r3 > n2; e3 = 0 <= n2 ? ++r3 : --r3)
        i3.push(t4.readInt16());
      return i3;
    }(), this.widths = function() {
      var t5, e4, r3, n3;
      for (n3 = [], t5 = 0, e4 = (r3 = this.metrics).length; t5 < e4; t5++)
        i2 = r3[t5], n3.push(i2.advance);
      return n3;
    }.call(this), r2 = this.widths[this.widths.length - 1], s2 = [], e3 = a2 = 0; 0 <= n2 ? a2 < n2 : a2 > n2; e3 = 0 <= n2 ? ++a2 : --a2)
      s2.push(this.widths.push(r2));
    return s2;
  }, e2.prototype.forGlyph = function(t4) {
    return t4 in this.metrics ? this.metrics[t4] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t4 - this.metrics.length] };
  }, e2;
}(), ve = [].slice, be = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "glyf", e2.prototype.parse = function() {
    return this.cache = {};
  }, e2.prototype.glyphFor = function(t4) {
    var e3, r2, n2, i2, a2, o2, s2, c2, u2, h2;
    return t4 in this.cache ? this.cache[t4] : (i2 = this.file.loca, e3 = this.file.contents, r2 = i2.indexOf(t4), 0 === (n2 = i2.lengthOf(t4)) ? this.cache[t4] = null : (e3.pos = this.offset + r2, a2 = (o2 = new ne(e3.read(n2))).readShort(), c2 = o2.readShort(), h2 = o2.readShort(), s2 = o2.readShort(), u2 = o2.readShort(), this.cache[t4] = -1 === a2 ? new we(o2, c2, h2, s2, u2) : new ye(o2, a2, c2, h2, s2, u2), this.cache[t4]));
  }, e2.prototype.encode = function(t4, e3, r2) {
    var n2, i2, a2, o2, s2;
    for (a2 = [], i2 = [], o2 = 0, s2 = e3.length; o2 < s2; o2++)
      n2 = t4[e3[o2]], i2.push(a2.length), n2 && (a2 = a2.concat(n2.encode(r2)));
    return i2.push(a2.length), { table: a2, offsets: i2 };
  }, e2;
}(), ye = function() {
  function t3(t4, e2, r2, n2, i2, a2) {
    this.raw = t4, this.numberOfContours = e2, this.xMin = r2, this.yMin = n2, this.xMax = i2, this.yMax = a2, this.compound = false;
  }
  return t3.prototype.encode = function() {
    return this.raw.data;
  }, t3;
}(), we = function() {
  function t3(t4, e2, r2, n2, i2) {
    var a2, o2;
    for (this.raw = t4, this.xMin = e2, this.yMin = r2, this.xMax = n2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; )
      a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
  }
  return t3.prototype.encode = function() {
    var t4, e2, r2;
    for (e2 = new ne(ve.call(this.raw.data)), t4 = 0, r2 = this.glyphIDs.length; t4 < r2; ++t4)
      e2.pos = this.glyphOffsets[t4];
    return e2.data;
  }, t3;
}(), Ne = function(t3) {
  function e2() {
    return e2.__super__.constructor.apply(this, arguments);
  }
  return oe(e2, re), e2.prototype.tag = "loca", e2.prototype.parse = function(t4) {
    var e3, r2;
    return t4.pos = this.offset, e3 = this.file.head.indexToLocFormat, this.offsets = 0 === e3 ? function() {
      var e4, n2;
      for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 2)
        n2.push(2 * t4.readUInt16());
      return n2;
    }.call(this) : function() {
      var e4, n2;
      for (n2 = [], r2 = 0, e4 = this.length; r2 < e4; r2 += 4)
        n2.push(t4.readUInt32());
      return n2;
    }.call(this);
  }, e2.prototype.indexOf = function(t4) {
    return this.offsets[t4];
  }, e2.prototype.lengthOf = function(t4) {
    return this.offsets[t4 + 1] - this.offsets[t4];
  }, e2.prototype.encode = function(t4, e3) {
    for (var r2 = new Uint32Array(this.offsets.length), n2 = 0, i2 = 0, a2 = 0; a2 < r2.length; ++a2)
      if (r2[a2] = n2, i2 < e3.length && e3[i2] == a2) {
        ++i2, r2[a2] = n2;
        var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
        s2 > 0 && (n2 += s2);
      }
    for (var c2 = new Array(4 * r2.length), u2 = 0; u2 < r2.length; ++u2)
      c2[4 * u2 + 3] = 255 & r2[u2], c2[4 * u2 + 2] = (65280 & r2[u2]) >> 8, c2[4 * u2 + 1] = (16711680 & r2[u2]) >> 16, c2[4 * u2] = (4278190080 & r2[u2]) >> 24;
    return c2;
  }, e2;
}(), Le = function() {
  function t3(t4) {
    this.font = t4, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return t3.prototype.generateCmap = function() {
    var t4, e2, r2, n2, i2;
    for (e2 in n2 = this.font.cmap.tables[0].codeMap, t4 = {}, i2 = this.subset)
      r2 = i2[e2], t4[e2] = n2[r2];
    return t4;
  }, t3.prototype.glyphsFor = function(t4) {
    var e2, r2, n2, i2, a2, o2, s2;
    for (n2 = {}, a2 = 0, o2 = t4.length; a2 < o2; a2++)
      n2[i2 = t4[a2]] = this.font.glyf.glyphFor(i2);
    for (i2 in e2 = [], n2)
      (null != (r2 = n2[i2]) ? r2.compound : void 0) && e2.push.apply(e2, r2.glyphIDs);
    if (e2.length > 0)
      for (i2 in s2 = this.glyphsFor(e2))
        r2 = s2[i2], n2[i2] = r2;
    return n2;
  }, t3.prototype.encode = function(t4, e2) {
    var r2, n2, i2, a2, o2, s2, c2, u2, h2, l2, f2, d2, p2, g2, m2;
    for (n2 in r2 = ue.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t4), f2 = { 0: 0 }, m2 = r2.charMap)
      f2[(s2 = m2[n2]).old] = s2.new;
    for (d2 in l2 = r2.maxGlyphID, a2)
      d2 in f2 || (f2[d2] = l2++);
    return u2 = function(t5) {
      var e3, r3;
      for (e3 in r3 = {}, t5)
        r3[t5[e3]] = e3;
      return r3;
    }(f2), h2 = Object.keys(u2).sort(function(t5, e3) {
      return t5 - e3;
    }), p2 = function() {
      var t5, e3, r3;
      for (r3 = [], t5 = 0, e3 = h2.length; t5 < e3; t5++)
        o2 = h2[t5], r3.push(u2[o2]);
      return r3;
    }(), i2 = this.font.glyf.encode(a2, p2, f2), c2 = this.font.loca.encode(i2.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: c2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e2) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
  }, t3;
}();
E.API.PDFObject = function() {
  var t3;
  function e2() {
  }
  return t3 = function(t4, e3) {
    return (Array(e3 + 1).join("0") + t4).slice(-e3);
  }, e2.convert = function(r2) {
    var n2, i2, a2, o2;
    if (Array.isArray(r2))
      return "[" + function() {
        var t4, i3, a3;
        for (a3 = [], t4 = 0, i3 = r2.length; t4 < i3; t4++)
          n2 = r2[t4], a3.push(e2.convert(n2));
        return a3;
      }().join(" ") + "]";
    if ("string" == typeof r2)
      return "/" + r2;
    if (null != r2 ? r2.isString : void 0)
      return "(" + r2 + ")";
    if (r2 instanceof Date)
      return "(D:" + t3(r2.getUTCFullYear(), 4) + t3(r2.getUTCMonth(), 2) + t3(r2.getUTCDate(), 2) + t3(r2.getUTCHours(), 2) + t3(r2.getUTCMinutes(), 2) + t3(r2.getUTCSeconds(), 2) + "Z)";
    if ("[object Object]" === {}.toString.call(r2)) {
      for (i2 in a2 = ["<<"], r2)
        o2 = r2[i2], a2.push("/" + i2 + " " + e2.convert(o2));
      return a2.push(">>"), a2.join("\n");
    }
    return "" + r2;
  }, e2;
}();
const $234747a9630b4642$export$bc7c183068c332b6 = 3.77952755906;
let $234747a9630b4642$export$3e4ff2216a90b8a4;
(function(Resolution) {
  Resolution[Resolution["LOW"] = 1] = "LOW";
  Resolution[Resolution["NORMAL"] = 2] = "NORMAL";
  Resolution[Resolution["MEDIUM"] = 3] = "MEDIUM";
  Resolution[Resolution["HIGH"] = 7] = "HIGH";
  Resolution[Resolution["EXTREME"] = 12] = "EXTREME";
})($234747a9630b4642$export$3e4ff2216a90b8a4 || ($234747a9630b4642$export$3e4ff2216a90b8a4 = {}));
let $234747a9630b4642$export$e717bcf55e1dfb40;
(function(Margin) {
  Margin[Margin["NONE"] = 0] = "NONE";
  Margin[Margin["SMALL"] = 5] = "SMALL";
  Margin[Margin["MEDIUM"] = 10] = "MEDIUM";
  Margin[Margin["LARGE"] = 25] = "LARGE";
})($234747a9630b4642$export$e717bcf55e1dfb40 || ($234747a9630b4642$export$e717bcf55e1dfb40 = {}));
const $234747a9630b4642$export$93ca5d3f8675ae4c = {
  method: "save",
  resolution: $234747a9630b4642$export$3e4ff2216a90b8a4.MEDIUM,
  page: {
    margin: $234747a9630b4642$export$e717bcf55e1dfb40.NONE,
    format: "A4",
    orientation: "portrait"
  },
  canvas: {
    mimeType: "image/jpeg",
    qualityRatio: 1,
    useCORS: true,
    logging: false
  },
  overrides: {}
};
class $d6bf1d6779fcee23$export$2e2bcd8739ae039 {
  constructor(canvas, options) {
    this.canvas = canvas;
    this.options = options;
    this.pdf = new E({
      format: this.options.page.format,
      orientation: this.options.page.orientation,
      ...this.options.overrides?.pdf,
      unit: "mm"
    });
  }
  getMarginTopMM() {
    const margin2 = typeof this.options.page.margin === "object" ? this.options.page.margin.top : this.options.page.margin;
    return Number(margin2);
  }
  getMarginLeftMM() {
    const margin2 = typeof this.options.page.margin === "object" ? this.options.page.margin.left : this.options.page.margin;
    return Number(margin2);
  }
  getMarginRightMM() {
    const margin2 = typeof this.options.page.margin === "object" ? this.options.page.margin.right : this.options.page.margin;
    return Number(margin2);
  }
  getMarginBottomMM() {
    const margin2 = typeof this.options.page.margin === "object" ? this.options.page.margin.bottom : this.options.page.margin;
    return Number(margin2);
  }
  getMarginTop() {
    return this.getMarginTopMM() * $234747a9630b4642$export$bc7c183068c332b6;
  }
  getMarginBottom() {
    return this.getMarginBottomMM() * $234747a9630b4642$export$bc7c183068c332b6;
  }
  getMarginLeft() {
    return this.getMarginLeftMM() * $234747a9630b4642$export$bc7c183068c332b6;
  }
  getMarginRight() {
    return this.getMarginRightMM() * $234747a9630b4642$export$bc7c183068c332b6;
  }
  getScale() {
    return this.options.resolution;
  }
  getPageHeight() {
    return this.getPageHeightMM() * $234747a9630b4642$export$bc7c183068c332b6;
  }
  getPageHeightMM() {
    return this.pdf.internal.pageSize.height;
  }
  getPageWidthMM() {
    return this.pdf.internal.pageSize.width;
  }
  getPageWidth() {
    return this.getPageWidthMM() * $234747a9630b4642$export$bc7c183068c332b6;
  }
  getOriginalCanvasWidth() {
    return this.canvas.width / this.getScale();
  }
  getOriginalCanvasHeight() {
    return this.canvas.height / this.getScale();
  }
  getCanvasPageAvailableHeight() {
    return this.getPageAvailableHeight() * this.getScale() * this.getHorizontalFitFactor();
  }
  getPageAvailableWidth() {
    return this.getPageWidth() - (this.getMarginLeft() + this.getMarginRight());
  }
  getPageAvailableHeight() {
    return this.getPageHeight() - (this.getMarginTop() + this.getMarginBottom());
  }
  getPageAvailableWidthMM() {
    return this.getPageAvailableWidth() / $234747a9630b4642$export$bc7c183068c332b6;
  }
  getPageAvailableHeightMM() {
    return this.getPageAvailableHeight() / $234747a9630b4642$export$bc7c183068c332b6;
  }
  getNumberPages() {
    return Math.ceil(this.canvas.height / this.getCanvasPageAvailableHeight());
  }
  getHorizontalFitFactor() {
    if (this.getPageAvailableWidth() < this.getOriginalCanvasWidth())
      return this.getOriginalCanvasWidth() / this.getPageAvailableWidth();
    return 1;
  }
  getCanvasOffsetY(pageNumber) {
    return this.getCanvasPageAvailableHeight() * (pageNumber - 1);
  }
  getCanvasHeightLeft(pageNumber) {
    return this.canvas.height - this.getCanvasOffsetY(pageNumber);
  }
  getCanvasPageHeight(pageNumber) {
    if (this.canvas.height < this.getCanvasPageAvailableHeight())
      return this.canvas.height;
    const canvasHeightPending = this.getCanvasHeightLeft(pageNumber);
    return canvasHeightPending < this.getCanvasPageAvailableHeight() ? canvasHeightPending : this.getCanvasPageAvailableHeight();
  }
  getCanvasPageWidth() {
    return this.canvas.width;
  }
  createCanvasPage(pageNumber) {
    const canvasPageWidth = this.getCanvasPageWidth();
    const canvasPageHeight = this.getCanvasPageHeight(pageNumber);
    const canvasPage = document.createElement("canvas");
    canvasPage.setAttribute("width", String(canvasPageWidth));
    canvasPage.setAttribute("height", String(canvasPageHeight));
    const ctx = canvasPage.getContext("2d");
    ctx.drawImage(this.canvas, 0, this.getCanvasOffsetY(pageNumber), this.canvas.width, canvasPageHeight, 0, 0, this.canvas.width, canvasPageHeight);
    return canvasPage;
  }
  convert() {
    let pageNumber = 1;
    const numberPages = this.getNumberPages();
    while (pageNumber <= numberPages) {
      if (pageNumber > 1)
        this.pdf.addPage(this.options.page.format, this.options.page.orientation);
      const canvasPage = this.createCanvasPage(pageNumber);
      const pageImageDataURL = canvasPage.toDataURL(this.options.canvas.mimeType, this.options.canvas.qualityRatio);
      this.pdf.setPage(pageNumber);
      this.pdf.addImage({
        imageData: pageImageDataURL,
        width: canvasPage.width / (this.getScale() * $234747a9630b4642$export$bc7c183068c332b6 * this.getHorizontalFitFactor()),
        height: canvasPage.height / (this.getScale() * $234747a9630b4642$export$bc7c183068c332b6 * this.getHorizontalFitFactor()),
        x: this.getMarginLeftMM(),
        y: this.getMarginTopMM()
      });
      pageNumber += 1;
    }
    return this.pdf;
  }
}
const $fab42eb3dee39b5b$export$697e52778de11d88 = (options) => {
  if (!options)
    return $234747a9630b4642$export$93ca5d3f8675ae4c;
  return {
    ...$234747a9630b4642$export$93ca5d3f8675ae4c,
    ...options,
    canvas: {
      ...$234747a9630b4642$export$93ca5d3f8675ae4c.canvas,
      ...options.canvas
    },
    page: {
      ...$234747a9630b4642$export$93ca5d3f8675ae4c.page,
      ...options.page
    }
  };
};
const $149c1bd638913645$var$getTargetElement = (targetRefOrFunction) => {
  if (typeof targetRefOrFunction === "function")
    return targetRefOrFunction();
  return targetRefOrFunction?.current;
};
const $149c1bd638913645$export$398b9fbd663a6614 = (usePDFoptions) => {
  const targetRef = reactExports.useRef();
  const toPDF = reactExports.useCallback((toPDFoptions) => {
    return $149c1bd638913645$var$generatePDF(targetRef, usePDFoptions ?? toPDFoptions);
  }, [
    targetRef,
    usePDFoptions
  ]);
  return {
    targetRef,
    toPDF
  };
};
const $149c1bd638913645$var$generatePDF = async (targetRefOrFunction, customOptions) => {
  const options = $fab42eb3dee39b5b$export$697e52778de11d88(customOptions);
  const targetElement = $149c1bd638913645$var$getTargetElement(targetRefOrFunction);
  if (!targetElement) {
    console.error("Unable to get the target element.");
    return;
  }
  const canvas = await html2canvas(targetElement, {
    useCORS: options.canvas.useCORS,
    logging: options.canvas.logging,
    scale: options.resolution,
    ...options.overrides?.canvas
  });
  const converter = new $d6bf1d6779fcee23$export$2e2bcd8739ae039(canvas, options);
  const pdf = converter.convert();
  switch (options.method) {
    case "build":
      return pdf;
    case "open":
      window.open(pdf.output("bloburl"), "_blank");
      return pdf;
    case "save":
    default: {
      const pdfFilename = options.filename ?? `${(/* @__PURE__ */ new Date()).getTime()}.pdf`;
      await pdf.save(pdfFilename, {
        returnPromise: true
      });
      return pdf;
    }
  }
};
function Receipt({ subTotal, tax, total }) {
  const { toPDF, targetRef } = $149c1bd638913645$export$398b9fbd663a6614();
  const [data, setData] = React.useState([]);
  const dbasePath = useSelector((state) => state.database.dbasePath);
  const amountPaid = useSelector(
    (state) => state.purchase.amountPaid
  );
  async function getCarts() {
    try {
      const db2 = await getDatabase(dbasePath);
      const existingData = await db2?.carts.find().exec();
      if (existingData) {
        setData(existingData[0]?._data);
      }
    } catch (error) {
      console.log("CATCH ERROR ::: ", error);
    }
  }
  React.useEffect(() => {
    getCarts();
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      px: 2,
      pb: 2,
      display: "flex",
      flexDirection: "column",
      justifyContent: "start",
      alignItems: "center",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            ref: targetRef,
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "center",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box$1,
                {
                  display: "flex",
                  flexDirection: "row",
                  justifyContent: "center",
                  alignItems: "center",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: brandLogo, alt: "", width: 128 })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 22, fontWeight: 900, pt: 2, children: ` Invoice #${data?.id}` }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Box$1,
                {
                  pt: 2,
                  px: 2,
                  width: "50%",
                  display: "flex",
                  flexDirection: "column",
                  justifyContent: "center",
                  alignItems: "center",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { variant: "body2", textAlign: "center", children: `4/6 Ikorodu-Epe Rd, opposite Sabo Market, Ikorodu 104101, Lagos.2349079772482, 09079772482contactus@Drugstoreng.com` })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, pt: 2, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 5, md: 5, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "gray", children: "Description" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 1, md: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "gray", children: "Qty" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 3, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "gray", children: "Unit Price" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 3, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "gray", children: "Total" }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { py: 1, width: "100%", children: data && data.items?.map((el2, index2) => {
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, spacing: 2, pb: 1, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 5, md: 5, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "gray", textAlign: "left", children: el2?.name }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 1, md: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "gray", children: el2?.quantity }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 3, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    NumericFormat,
                    {
                      style: {
                        fontSize: 15,
                        fontFamily: "sans-serif",
                        color: "gray"
                      },
                      value: parseInt(el2?.unitPrice).toFixed(2),
                      displayType: "text",
                      thousandSeparator: true,
                      prefix: "₦"
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, sm: 3, md: 3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    NumericFormat,
                    {
                      style: {
                        fontSize: 15,
                        fontFamily: "sans-serif",
                        color: "gray"
                      },
                      value: (parseInt(el2?.unitPrice) * el2?.quantity).toFixed(
                        2
                      ),
                      displayType: "text",
                      thousandSeparator: true,
                      prefix: "₦"
                    }
                  ) })
                ] }, index2);
              }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { height: 1.1, width: "100%", bgcolor: "#ccc" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Box$1, { p: 2, width: "90%", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Grid$1,
                  {
                    px: 1,
                    py: 0.25,
                    container: true,
                    spacing: 2,
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Box$1,
                        {
                          width: "100%",
                          display: "flex",
                          flexDirection: "row",
                          justifyContent: "start",
                          alignItems: "center",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Typography$1,
                              {
                                fontSize: 14,
                                color: "gray",
                                component: Grid$1,
                                item: true,
                                sm: 6,
                                md: 6,
                                children: "Sub Total: "
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              NumericFormat,
                              {
                                style: {
                                  fontSize: 15,
                                  fontFamily: "sans-serif",
                                  color: "gray"
                                },
                                value: (subTotal ?? 0).toFixed(2),
                                displayType: "text",
                                thousandSeparator: true,
                                prefix: "₦"
                              }
                            )
                          ]
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Box$1,
                        {
                          width: "100%",
                          display: "flex",
                          flexDirection: "row",
                          justifyContent: "start",
                          alignItems: "center",
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              Typography$1,
                              {
                                fontSize: 14,
                                color: "gray",
                                component: Grid$1,
                                item: true,
                                sm: 6,
                                md: 6,
                                children: "Cash Paid: "
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              NumericFormat,
                              {
                                style: {
                                  fontSize: 15,
                                  fontFamily: "sans-serif",
                                  color: "gray"
                                },
                                value: (amountPaid ?? 0).toFixed(2),
                                displayType: "text",
                                thousandSeparator: true,
                                prefix: "₦"
                              }
                            )
                          ]
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Grid$1,
                  {
                    px: 1,
                    py: 0.25,
                    container: true,
                    spacing: 2,
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        Typography$1,
                        {
                          fontSize: 14,
                          color: "gray",
                          component: Grid$1,
                          item: true,
                          sm: 6,
                          md: 6,
                          children: [
                            "Tax: ₦",
                            tax
                          ]
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Typography$1,
                        {
                          fontSize: 14,
                          color: "gray",
                          component: Grid$1,
                          item: true,
                          sm: 6,
                          md: 6,
                          children: "Change: ₦"
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Grid$1,
                  {
                    px: 1,
                    py: 0.25,
                    container: true,
                    spacing: 2,
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Typography$1,
                        {
                          fontSize: 14,
                          color: "gray",
                          component: Grid$1,
                          item: true,
                          sm: 6,
                          md: 6,
                          children: "Total Discount: ₦0.0"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Typography$1,
                        {
                          fontSize: 14,
                          color: "gray",
                          component: Grid$1,
                          item: true,
                          sm: 6,
                          md: 6,
                          children: "Note: Nil"
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Grid$1,
                  {
                    px: 1,
                    py: 0.25,
                    container: true,
                    spacing: 2,
                    display: "flex",
                    flexDirection: "row",
                    justifyContent: "space-between",
                    alignItems: "center",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Typography$1,
                      {
                        fontSize: 14,
                        color: "gray",
                        component: Grid$1,
                        item: true,
                        sm: 6,
                        md: 6,
                        children: [
                          "Total: ₦",
                          total
                        ]
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { height: 1.1, width: "100%", bgcolor: "#ccc" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Box$1,
                {
                  p: 2,
                  width: "40%",
                  display: "flex",
                  flexDirection: "column",
                  justifyContent: "center",
                  alignItems: "center",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$1, { fontSize: 14, color: "gray", children: [
                      "Date: ",
                      `${Date.now().toLocaleString("en-GB")}`
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$1, { fontSize: 14, color: "gray", children: [
                      "Staff: ",
                      `Sarah Olatoye`
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(Typography$1, { fontSize: 14, color: "gray", children: [
                      "Device: ",
                      `Till 09`
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            onClick: async () => {
              toPDF();
              try {
                const db2 = await getDatabase(dbasePath);
                if (db2) {
                  await db2.carts.remove();
                }
              } catch (error) {
                console.log("ERR :: ", error);
              }
            },
            fullWidth: true,
            variant: "contained",
            sx: { p: 1 },
            children: "Print"
          }
        )
      ]
    }
  );
}
const PaymentMethod = () => {
  const [openReceipt, setOpenReceipt] = React.useState(false);
  const [isConfirmed, setConfirmed] = React.useState(false);
  const [isTouched, setTouched] = React.useState(false);
  const [organized, setOrganized] = React.useState([]);
  const [cashPaid, setCashPaid] = React.useState(0);
  const [open2, setOpen] = React.useState(false);
  const [change, setChange$1] = React.useState(0);
  const currLocation = useLocation();
  const navigate = useNavigate();
  const dispatch = useDispatch();
  const theme2 = useTheme();
  const {
    paymentMethod,
    tax,
    total,
    subTotal,
    customerName,
    orderNo,
    itemsOrdered,
    bank,
    accName,
    accNum
  } = currLocation.state;
  const currentCustomer = useSelector(
    (state) => state.customers.currentCustomer
  );
  const currentBusinessLocation = useSelector(
    (state) => state.business_locations.currentBusinessLocation
  );
  const isOnline2 = useSelector(
    (state) => state.loader.isOnline
  );
  const shouldReload = useSelector(
    (state) => state.loader.shouldReload
  );
  React.useEffect(() => {
    if (itemsOrdered) {
      const filtered = itemsOrdered?.map((item) => {
        return {
          product_id: parseInt(item?.productId),
          variation_id: parseInt(item?.variationId) || parseInt(item?.productId),
          quantity: item?.quantity,
          unit_price: parseInt(item?.unitPrice),
          product_type: item?.productType,
          line_discount_type: "fixed",
          line_discount_amount: 0,
          item_tax: 0,
          enable_stock: 1,
          product_unit_id: item?.productUnitId,
          sub_unit_id: item?.productUnitId,
          base_unit_multiplier: 1
        };
      });
      setOrganized(filtered);
    }
  }, [itemsOrdered]);
  const sell = async () => {
    try {
      setOpen(false);
      dispatch(setLoading(true));
      dispatch(setChange(change));
      dispatch(setAmountPaid(cashPaid));
      const paymentObj = {
        amount: paymentMethod?.name?.toLowerCase().includes("cash") ? cashPaid : total,
        method: paymentMethod?.name,
        note: `Payment for #${orderNo} by ${customerName}`
      };
      const payload = {
        _token: localStorage.getItem("accessToken"),
        location_id: currentBusinessLocation?.id,
        contact_id: parseInt(currentCustomer?.id) || 12,
        transaction_date: formatDate(/* @__PURE__ */ new Date()),
        invoice_no: `${orderNo}`,
        final_total: total,
        status: "final",
        sale_note: "Sell from DrugStore desktop application",
        staff_note: "",
        is_suspend: 0,
        price_group: 0,
        recur_interval_type: "days",
        delivered_to: `${customerName}`,
        shipping_charges_modal: 0,
        shipping_status_modal: null,
        change_return: paymentMethod?.name?.toLowerCase().includes("cash") ? change : 0,
        additional_notes: "",
        products: organized,
        payments: [paymentObj]
      };
      if (isOnline2) {
        await APIService.createSell({
          sells: [payload]
        });
        dispatch(setReload(!shouldReload));
      } else {
        console.log("OFFLINE SALE ... ");
        const pendingSells = await window.electron.pendingSells();
        console.log("CURRENT PENDING SELLS  ", pendingSells);
        window.electron.sendPendingSellsDataToMain(
          JSON?.stringify([{ sells: [payload] }])
        );
        window.electron.sendCartDataToMain(JSON?.parse("[]"));
      }
      window.electron.sendCartDataToMain(JSON?.parse("[]"));
      dispatch(setLoading(false));
      _t$1.success("Order successfully sold!", {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(DoneAll, { color: "success" }),
        style: {
          backgroundColor: theme2.palette.success.light,
          color: theme2.palette.success.dark,
          paddingLeft: 24,
          paddingRight: 24,
          paddingTop: 16,
          paddingBottom: 16,
          fontSize: 21
        },
        position: "top-center"
      });
      setConfirmed(true);
    } catch (error) {
      dispatch(setLoading(false));
      console.log("SELL ERROR :: ", error);
    }
  };
  const renderConfirmAlert = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      pt: 4,
      px: 3,
      pb: 3,
      display: "flex",
      flexDirection: "column",
      justifyContent: "start",
      alignItems: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { children: ` Are you sure you want to confirm reception of this payment?` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { gutterBottom: true, children: ` Action can not be undone.` }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            pt: 2,
            display: "flex",
            flexDirection: "column",
            justifyContent: "start",
            alignItems: "stretch",
            width: "100%",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "text",
                  sx: { textTransform: "capitalize", color: "black", p: 1.5, mb: 1 },
                  onClick: async () => {
                    setOpen(false);
                  },
                  children: "Cancel"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "contained",
                  sx: { textTransform: "capitalize", color: "white", p: 1.5, mt: 1 },
                  onClick: () => {
                    sell();
                  },
                  children: "Confirm"
                }
              )
            ]
          }
        )
      ]
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      height: "100vh",
      width: "100vw",
      display: "flex",
      position: "relative",
      flexDirection: "column",
      justifyContent: "start",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CustomDialog,
          {
            open: open2,
            showClose: false,
            setOpen,
            content: renderConfirmAlert
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CustomDialog,
          {
            open: openReceipt,
            setOpen: setOpenReceipt,
            content: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Receipt,
              {
                paymentMethod: paymentMethod?.name,
                subTotal,
                tax,
                total
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box$1,
          {
            display: "flex",
            flexDirection: "row",
            px: 3,
            pt: 1,
            top: 100,
            position: "fixed",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton$1, { onClick: () => navigate("/dashboard/"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardBackspace, { fontSize: "large", sx: { color: "black" } }) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            mx: 6,
            px: 4,
            flex: 1,
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Typography$1,
                {
                  fontSize: 28,
                  gutterBottom: true,
                  color: "black",
                  fontWeight: 900,
                  textTransform: "capitalize",
                  children: `${paymentMethod?.label.toLowerCase().includes("cash") ? "Collect Cash" : paymentMethod?.label.toLowerCase().includes("credit") ? "Credit Payment for " + customerName : paymentMethod?.label} `
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Card$1,
                {
                  sx: {
                    boxShadow: "rgba(50, 50, 93, 0.25) 0px 6px 12px -2px, rgba(0, 0, 0, 0.3) 0px 3px 7px -3px",
                    border: "none",
                    borderRadius: 2,
                    minWidth: "50%",
                    mt: 1,
                    mb: 4,
                    display: "flex",
                    justifyContent: "center"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Box$1,
                    {
                      pb: 4,
                      width: "65%",
                      display: "flex",
                      flexDirection: "column",
                      justifyContent: "start",
                      alignItems: "stretch",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar$1, {}),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Box$1,
                          {
                            px: 4,
                            pb: 1,
                            display: !paymentMethod?.name?.toLowerCase().includes("credit") ? "none" : "flex",
                            flexDirection: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 16, fontWeight: 700, children: "Credit Limit" }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                NumericFormat,
                                {
                                  style: {
                                    fontSize: 20,
                                    fontWeight: 500,
                                    fontFamily: "sans-serif"
                                  },
                                  value: parseInt("30000").toFixed(2),
                                  displayType: "text",
                                  thousandSeparator: true,
                                  prefix: "₦"
                                }
                              )
                            ]
                          }
                        ),
                        paymentMethod?.name?.toLowerCase().includes("cash") ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$1, {}),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Box$1,
                          {
                            px: 4,
                            pt: paymentMethod?.name?.toLowerCase().includes("cash") ? 0 : 2,
                            pb: 1,
                            display: "flex",
                            flexDirection: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 16, fontWeight: 500, children: "Sub Total" }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                NumericFormat,
                                {
                                  style: {
                                    fontSize: 16,
                                    fontWeight: 500,
                                    fontFamily: "sans-serif"
                                  },
                                  value: subTotal.toFixed(2),
                                  displayType: "text",
                                  thousandSeparator: true,
                                  prefix: "₦"
                                }
                              )
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Box$1,
                          {
                            px: 4,
                            py: 1,
                            display: "flex",
                            flexDirection: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 16, fontWeight: 500, children: "Total Discount" }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { color: "black", fontSize: 16, fontWeight: 700, children: "0%" })
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Box$1,
                          {
                            px: 4,
                            py: 1,
                            display: "flex",
                            flexDirection: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 16, fontWeight: 500, children: "Tax" }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                NumericFormat,
                                {
                                  style: {
                                    fontSize: 16,
                                    fontWeight: 500,
                                    fontFamily: "sans-serif"
                                  },
                                  value: tax.toFixed(2),
                                  displayType: "text",
                                  thousandSeparator: true,
                                  prefix: "₦"
                                }
                              )
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Box$1,
                          {
                            px: 4,
                            pt: 1,
                            display: "flex",
                            flexDirection: "row",
                            justifyContent: "space-between",
                            alignItems: "center",
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { fontSize: 16, fontWeight: 500, children: "Total" }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                NumericFormat,
                                {
                                  style: {
                                    fontSize: 16,
                                    fontWeight: 500,
                                    fontFamily: "sans-serif"
                                  },
                                  value: total.toFixed(2),
                                  displayType: "text",
                                  thousandSeparator: true,
                                  prefix: "₦"
                                }
                              )
                            ]
                          }
                        ),
                        paymentMethod?.name?.toLowerCase().includes("cash") && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { my: 1, width: "100%", height: 1.2, bgcolor: "#eee" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            Box$1,
                            {
                              px: 4,
                              py: 2,
                              display: "flex",
                              flexDirection: "row",
                              justifyContent: "space-between",
                              alignItems: "center",
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { flex: 1, fontSize: 16, fontWeight: 500, children: "Cash Paid" }),
                                /* @__PURE__ */ jsxRuntimeExports.jsx(
                                  NumericFormat,
                                  {
                                    placeholder: "₦0.0",
                                    variant: "filled",
                                    prefix: "₦",
                                    required: true,
                                    label: "",
                                    size: "small",
                                    thousandSeparator: true,
                                    value: cashPaid,
                                    InputLabelProps: { shrink: false },
                                    InputProps: {
                                      disableUnderline: true,
                                      style: {
                                        height: 32,
                                        paddingBottom: 10
                                      }
                                    },
                                    sx: { width: 100 },
                                    onChange: (e2) => {
                                      setCashPaid(parseInt(e2.target.value));
                                      setTouched(true);
                                      const result = parseInt(
                                        e2.target.value.replace("₦", "").replace(",", "")
                                      ) - total;
                                      setChange$1(result);
                                    },
                                    customInput: TextField$1,
                                    error: Boolean(isTouched && cashPaid === 0),
                                    helperText: isTouched && cashPaid === 0 ? "Cashpaid is required" : null
                                  }
                                )
                              ]
                            }
                          )
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { textAlign: "center", children: `${paymentMethod?.label}`.toLowerCase().includes("transfer") ? "Pay" : `${paymentMethod?.label}`.toLowerCase().includes("cash") ? "Change Due" : "Amount Due" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          NumericFormat,
                          {
                            style: {
                              fontSize: 21,
                              fontWeight: 500,
                              textAlign: "center",
                              fontFamily: "sans-serif"
                            },
                            value: (`${paymentMethod?.label}`.toLowerCase().includes("cash") ? change : total).toFixed(2),
                            displayType: "text",
                            thousandSeparator: true,
                            prefix: "₦"
                          }
                        ),
                        paymentMethod?.name.includes("transfer") ? /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Typography$1,
                          {
                            display: paymentMethod?.name?.includes("transfer") ? "flex" : "none",
                            textAlign: "center",
                            color: "gray",
                            fontWeight: 600,
                            fontSize: 18,
                            children: accNum
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          Box$1,
                          {
                            display: paymentMethod?.name?.includes("transfer") ? "flex" : "none",
                            flexDirection: "row",
                            justifyContent: "center",
                            alignItems: "center",
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                Typography$1,
                                {
                                  gutterBottom: true,
                                  textAlign: "center",
                                  color: "gray",
                                  pr: 2,
                                  children: bank
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                Typography$1,
                                {
                                  gutterBottom: true,
                                  textAlign: "center",
                                  color: "gray",
                                  pl: 2,
                                  children: accName
                                }
                              )
                            ]
                          }
                        )
                      ]
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "contained",
                  sx: { textTransform: "capitalize", px: 6, py: 2 },
                  onClick: isConfirmed ? () => {
                    setOpenReceipt(true);
                  } : () => {
                    setOpen(true);
                  },
                  children: isConfirmed ? "Print Receipt" : `${paymentMethod?.label}`.toLowerCase().includes("transfer") ? "Confirm Transfer Manually" : `${paymentMethod?.label}`.toLowerCase().includes("credit") ? "Add Order on Credit" : "Print Receipt"
                }
              ),
              isConfirmed && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "text",
                  sx: {
                    textTransform: "capitalize",
                    px: 6,
                    py: 1.5,
                    mt: 0.5,
                    color: "black"
                  },
                  onClick: () => navigate("/dashboard/home"),
                  children: "Skip"
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
      ]
    }
  );
};
const initialState$1 = {
  dbasePath: ""
};
const authSlice$1 = createSlice({
  name: "database",
  initialState: initialState$1,
  reducers: {
    setDatabasePath: (state, action) => {
      state.dbasePath = action.payload;
    }
  }
});
const { setDatabasePath } = authSlice$1.actions;
const databaseReducer = authSlice$1.reducer;
const noop = () => {
};
const UNDEFINED = (
  /*#__NOINLINE__*/
  noop()
);
const OBJECT = Object;
const isUndefined = (v2) => v2 === UNDEFINED;
const isFunction2 = (v2) => typeof v2 == "function";
const mergeObjects = (a2, b2) => ({
  ...a2,
  ...b2
});
const isPromiseLike = (x2) => isFunction2(x2.then);
const table = /* @__PURE__ */ new WeakMap();
let counter = 0;
const stableHash = (arg) => {
  const type2 = typeof arg;
  const constructor = arg && arg.constructor;
  const isDate2 = constructor == Date;
  let result;
  let index2;
  if (OBJECT(arg) === arg && !isDate2 && constructor != RegExp) {
    result = table.get(arg);
    if (result)
      return result;
    result = ++counter + "~";
    table.set(arg, result);
    if (constructor == Array) {
      result = "@";
      for (index2 = 0; index2 < arg.length; index2++) {
        result += stableHash(arg[index2]) + ",";
      }
      table.set(arg, result);
    }
    if (constructor == OBJECT) {
      result = "#";
      const keys3 = OBJECT.keys(arg).sort();
      while (!isUndefined(index2 = keys3.pop())) {
        if (!isUndefined(arg[index2])) {
          result += index2 + ":" + stableHash(arg[index2]) + ",";
        }
      }
      table.set(arg, result);
    }
  } else {
    result = isDate2 ? arg.toJSON() : type2 == "symbol" ? arg.toString() : type2 == "string" ? JSON.stringify(arg) : "" + arg;
  }
  return result;
};
const SWRGlobalState = /* @__PURE__ */ new WeakMap();
const EMPTY_CACHE = {};
const INITIAL_CACHE = {};
const STR_UNDEFINED = "undefined";
const isWindowDefined = typeof window != STR_UNDEFINED;
const isDocumentDefined = typeof document != STR_UNDEFINED;
const hasRequestAnimationFrame = () => isWindowDefined && typeof window["requestAnimationFrame"] != STR_UNDEFINED;
const createCacheHelper = (cache2, key) => {
  const state = SWRGlobalState.get(cache2);
  return [
    // Getter
    () => !isUndefined(key) && cache2.get(key) || EMPTY_CACHE,
    // Setter
    (info) => {
      if (!isUndefined(key)) {
        const prev2 = cache2.get(key);
        if (!(key in INITIAL_CACHE)) {
          INITIAL_CACHE[key] = prev2;
        }
        state[5](key, mergeObjects(prev2, info), prev2 || EMPTY_CACHE);
      }
    },
    // Subscriber
    state[6],
    // Get server cache snapshot
    () => {
      if (!isUndefined(key)) {
        if (key in INITIAL_CACHE)
          return INITIAL_CACHE[key];
      }
      return !isUndefined(key) && cache2.get(key) || EMPTY_CACHE;
    }
  ];
};
let online = true;
const isOnline = () => online;
const [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  noop,
  noop
];
const isVisible = () => {
  const visibilityState = isDocumentDefined && document.visibilityState;
  return isUndefined(visibilityState) || visibilityState !== "hidden";
};
const initFocus = (callback) => {
  if (isDocumentDefined) {
    document.addEventListener("visibilitychange", callback);
  }
  onWindowEvent("focus", callback);
  return () => {
    if (isDocumentDefined) {
      document.removeEventListener("visibilitychange", callback);
    }
    offWindowEvent("focus", callback);
  };
};
const initReconnect = (callback) => {
  const onOnline = () => {
    online = true;
    callback();
  };
  const onOffline = () => {
    online = false;
  };
  onWindowEvent("online", onOnline);
  onWindowEvent("offline", onOffline);
  return () => {
    offWindowEvent("online", onOnline);
    offWindowEvent("offline", onOffline);
  };
};
const preset = {
  isOnline,
  isVisible
};
const defaultConfigOptions = {
  initFocus,
  initReconnect
};
const IS_REACT_LEGACY = !React.useId;
const IS_SERVER = !isWindowDefined || "Deno" in window;
const rAF = (f2) => hasRequestAnimationFrame() ? window["requestAnimationFrame"](f2) : setTimeout(f2, 1);
const useIsomorphicLayoutEffect = IS_SERVER ? reactExports.useEffect : reactExports.useLayoutEffect;
const navigatorConnection = typeof navigator !== "undefined" && navigator.connection;
const slowConnection = !IS_SERVER && navigatorConnection && ([
  "slow-2g",
  "2g"
].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);
const serialize = (key) => {
  if (isFunction2(key)) {
    try {
      key = key();
    } catch (err) {
      key = "";
    }
  }
  const args = key;
  key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "";
  return [
    key,
    args
  ];
};
let __timestamp = 0;
const getTimestamp = () => ++__timestamp;
const FOCUS_EVENT = 0;
const RECONNECT_EVENT = 1;
const MUTATE_EVENT = 2;
const ERROR_REVALIDATE_EVENT = 3;
var events = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT,
  FOCUS_EVENT,
  MUTATE_EVENT,
  RECONNECT_EVENT
};
async function internalMutate(...args) {
  const [cache2, _key, _data, _opts] = args;
  const options = mergeObjects({
    populateCache: true,
    throwOnError: true
  }, typeof _opts === "boolean" ? {
    revalidate: _opts
  } : _opts || {});
  let populateCache = options.populateCache;
  const rollbackOnErrorOption = options.rollbackOnError;
  let optimisticData = options.optimisticData;
  const revalidate = options.revalidate !== false;
  const rollbackOnError = (error) => {
    return typeof rollbackOnErrorOption === "function" ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;
  };
  const throwOnError = options.throwOnError;
  if (isFunction2(_key)) {
    const keyFilter = _key;
    const matchedKeys = [];
    const it2 = cache2.keys();
    for (const key of it2) {
      if (
        // Skip the special useSWRInfinite and useSWRSubscription keys.
        !/^\$(inf|sub)\$/.test(key) && keyFilter(cache2.get(key)._k)
      ) {
        matchedKeys.push(key);
      }
    }
    return Promise.all(matchedKeys.map(mutateByKey));
  }
  return mutateByKey(_key);
  async function mutateByKey(_k) {
    const [key] = serialize(_k);
    if (!key)
      return;
    const [get, set] = createCacheHelper(cache2, key);
    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
    const startRevalidate = () => {
      const revalidators = EVENT_REVALIDATORS[key];
      if (revalidate) {
        delete FETCH[key];
        delete PRELOAD[key];
        if (revalidators && revalidators[0]) {
          return revalidators[0](MUTATE_EVENT).then(() => get().data);
        }
      }
      return get().data;
    };
    if (args.length < 3) {
      return startRevalidate();
    }
    let data = _data;
    let error;
    const beforeMutationTs = getTimestamp();
    MUTATION[key] = [
      beforeMutationTs,
      0
    ];
    const hasOptimisticData = !isUndefined(optimisticData);
    const state = get();
    const displayedData = state.data;
    const currentData = state._c;
    const committedData = isUndefined(currentData) ? displayedData : currentData;
    if (hasOptimisticData) {
      optimisticData = isFunction2(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;
      set({
        data: optimisticData,
        _c: committedData
      });
    }
    if (isFunction2(data)) {
      try {
        data = data(committedData);
      } catch (err) {
        error = err;
      }
    }
    if (data && isPromiseLike(data)) {
      data = await data.catch((err) => {
        error = err;
      });
      if (beforeMutationTs !== MUTATION[key][0]) {
        if (error)
          throw error;
        return data;
      } else if (error && hasOptimisticData && rollbackOnError(error)) {
        populateCache = true;
        set({
          data: committedData,
          _c: UNDEFINED
        });
      }
    }
    if (populateCache) {
      if (!error) {
        if (isFunction2(populateCache)) {
          const populateCachedData = populateCache(data, committedData);
          set({
            data: populateCachedData,
            error: UNDEFINED,
            _c: UNDEFINED
          });
        } else {
          set({
            data,
            error: UNDEFINED,
            _c: UNDEFINED
          });
        }
      }
    }
    MUTATION[key][1] = getTimestamp();
    Promise.resolve(startRevalidate()).then(() => {
      set({
        _c: UNDEFINED
      });
    });
    if (error) {
      if (throwOnError)
        throw error;
      return;
    }
    return data;
  }
}
const revalidateAllKeys = (revalidators, type2) => {
  for (const key in revalidators) {
    if (revalidators[key][0])
      revalidators[key][0](type2);
  }
};
const initCache = (provider, options) => {
  if (!SWRGlobalState.has(provider)) {
    const opts = mergeObjects(defaultConfigOptions, options);
    const EVENT_REVALIDATORS = {};
    const mutate2 = internalMutate.bind(UNDEFINED, provider);
    let unmount = noop;
    const subscriptions = {};
    const subscribe = (key, callback) => {
      const subs = subscriptions[key] || [];
      subscriptions[key] = subs;
      subs.push(callback);
      return () => subs.splice(subs.indexOf(callback), 1);
    };
    const setter = (key, value, prev2) => {
      provider.set(key, value);
      const subs = subscriptions[key];
      if (subs) {
        for (const fn3 of subs) {
          fn3(value, prev2);
        }
      }
    };
    const initProvider = () => {
      if (!SWRGlobalState.has(provider)) {
        SWRGlobalState.set(provider, [
          EVENT_REVALIDATORS,
          {},
          {},
          {},
          mutate2,
          setter,
          subscribe
        ]);
        if (!IS_SERVER) {
          const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));
          const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
          unmount = () => {
            releaseFocus && releaseFocus();
            releaseReconnect && releaseReconnect();
            SWRGlobalState.delete(provider);
          };
        }
      }
    };
    initProvider();
    return [
      provider,
      mutate2,
      initProvider,
      unmount
    ];
  }
  return [
    provider,
    SWRGlobalState.get(provider)[4]
  ];
};
const onErrorRetry = (_2, __, config2, revalidate, opts) => {
  const maxRetryCount = config2.errorRetryCount;
  const currentRetryCount = opts.retryCount;
  const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config2.errorRetryInterval;
  if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {
    return;
  }
  setTimeout(revalidate, timeout, opts);
};
const compare = (currentData, newData) => stableHash(currentData) == stableHash(newData);
const [cache, mutate] = initCache(/* @__PURE__ */ new Map());
const defaultConfig = mergeObjects(
  {
    // events
    onLoadingSlow: noop,
    onSuccess: noop,
    onError: noop,
    onErrorRetry,
    onDiscarded: noop,
    // switches
    revalidateOnFocus: true,
    revalidateOnReconnect: true,
    revalidateIfStale: true,
    shouldRetryOnError: true,
    // timeouts
    errorRetryInterval: slowConnection ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: slowConnection ? 5e3 : 3e3,
    // providers
    compare,
    isPaused: () => false,
    cache,
    mutate,
    fallback: {}
  },
  // use web preset by default
  preset
);
const mergeConfigs = (a2, b2) => {
  const v2 = mergeObjects(a2, b2);
  if (b2) {
    const { use: u1, fallback: f1 } = a2;
    const { use: u2, fallback: f2 } = b2;
    if (u1 && u2) {
      v2.use = u1.concat(u2);
    }
    if (f1 && f2) {
      v2.fallback = mergeObjects(f1, f2);
    }
  }
  return v2;
};
const SWRConfigContext = reactExports.createContext({});
const SWRConfig$1 = (props) => {
  const { value } = props;
  const parentConfig = reactExports.useContext(SWRConfigContext);
  const isFunctionalConfig = isFunction2(value);
  const config2 = reactExports.useMemo(() => isFunctionalConfig ? value(parentConfig) : value, [
    isFunctionalConfig,
    parentConfig,
    value
  ]);
  const extendedConfig = reactExports.useMemo(() => isFunctionalConfig ? config2 : mergeConfigs(parentConfig, config2), [
    isFunctionalConfig,
    parentConfig,
    config2
  ]);
  const provider = config2 && config2.provider;
  const cacheContextRef = reactExports.useRef(UNDEFINED);
  if (provider && !cacheContextRef.current) {
    cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config2);
  }
  const cacheContext = cacheContextRef.current;
  if (cacheContext) {
    extendedConfig.cache = cacheContext[0];
    extendedConfig.mutate = cacheContext[1];
  }
  useIsomorphicLayoutEffect(() => {
    if (cacheContext) {
      cacheContext[2] && cacheContext[2]();
      return cacheContext[3];
    }
  }, []);
  return reactExports.createElement(SWRConfigContext.Provider, mergeObjects(props, {
    value: extendedConfig
  }));
};
const INFINITE_PREFIX = "$inf$";
const enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;
const use$1 = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];
const setupDevTools = () => {
  if (enableDevtools) {
    window.__SWR_DEVTOOLS_REACT__ = React;
  }
};
const normalize = (args) => {
  return isFunction2(args[1]) ? [
    args[0],
    args[1],
    args[2] || {}
  ] : [
    args[0],
    null,
    (args[1] === null ? args[2] : args[1]) || {}
  ];
};
const useSWRConfig = () => {
  return mergeObjects(defaultConfig, reactExports.useContext(SWRConfigContext));
};
const middleware = (useSWRNext) => (key_, fetcher_, config2) => {
  const fetcher = fetcher_ && ((...args) => {
    const [key] = serialize(key_);
    const [, , , PRELOAD] = SWRGlobalState.get(cache);
    if (key.startsWith(INFINITE_PREFIX)) {
      return fetcher_(...args);
    }
    const req = PRELOAD[key];
    if (isUndefined(req))
      return fetcher_(...args);
    delete PRELOAD[key];
    return req;
  });
  return useSWRNext(key_, fetcher, config2);
};
const BUILT_IN_MIDDLEWARE = use$1.concat(middleware);
const withArgs = (hook) => {
  return function useSWRArgs(...args) {
    const fallbackConfig = useSWRConfig();
    const [key, fn3, _config] = normalize(args);
    const config2 = mergeConfigs(fallbackConfig, _config);
    let next2 = hook;
    const { use: use2 } = config2;
    const middleware2 = (use2 || []).concat(BUILT_IN_MIDDLEWARE);
    for (let i2 = middleware2.length; i2--; ) {
      next2 = middleware2[i2](next2);
    }
    return next2(key, fn3 || config2.fetcher || null, config2);
  };
};
const subscribeCallback = (key, callbacks, callback) => {
  const keyedRevalidators = callbacks[key] || (callbacks[key] = []);
  keyedRevalidators.push(callback);
  return () => {
    const index2 = keyedRevalidators.indexOf(callback);
    if (index2 >= 0) {
      keyedRevalidators[index2] = keyedRevalidators[keyedRevalidators.length - 1];
      keyedRevalidators.pop();
    }
  };
};
setupDevTools();
const use = React.use || ((promise2) => {
  if (promise2.status === "pending") {
    throw promise2;
  } else if (promise2.status === "fulfilled") {
    return promise2.value;
  } else if (promise2.status === "rejected") {
    throw promise2.reason;
  } else {
    promise2.status = "pending";
    promise2.then((v2) => {
      promise2.status = "fulfilled";
      promise2.value = v2;
    }, (e2) => {
      promise2.status = "rejected";
      promise2.reason = e2;
    });
    throw promise2;
  }
});
const WITH_DEDUPE = {
  dedupe: true
};
const useSWRHandler = (_key, fetcher, config2) => {
  const { cache: cache2, compare: compare2, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData } = config2;
  const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
  const [key, fnArg] = serialize(_key);
  const initialMountedRef = reactExports.useRef(false);
  const unmountedRef = reactExports.useRef(false);
  const keyRef = reactExports.useRef(key);
  const fetcherRef = reactExports.useRef(fetcher);
  const configRef = reactExports.useRef(config2);
  const getConfig = () => configRef.current;
  const isActive = () => getConfig().isVisible() && getConfig().isOnline();
  const [getCache2, setCache2, subscribeCache, getInitialCache] = createCacheHelper(cache2, key);
  const stateDependencies = reactExports.useRef({}).current;
  const fallback = isUndefined(fallbackData) ? config2.fallback[key] : fallbackData;
  const isEqual2 = (prev2, current) => {
    for (const _2 in stateDependencies) {
      const t3 = _2;
      if (t3 === "data") {
        if (!compare2(prev2[t3], current[t3])) {
          if (!isUndefined(prev2[t3])) {
            return false;
          }
          if (!compare2(returnedData, current[t3])) {
            return false;
          }
        }
      } else {
        if (current[t3] !== prev2[t3]) {
          return false;
        }
      }
    }
    return true;
  };
  const getSnapshot = reactExports.useMemo(() => {
    const shouldStartRequest = (() => {
      if (!key)
        return false;
      if (!fetcher)
        return false;
      if (!isUndefined(revalidateOnMount))
        return revalidateOnMount;
      if (getConfig().isPaused())
        return false;
      if (suspense)
        return false;
      if (!isUndefined(revalidateIfStale))
        return revalidateIfStale;
      return true;
    })();
    const getSelectedCache = (state) => {
      const snapshot = mergeObjects(state);
      delete snapshot._k;
      if (!shouldStartRequest) {
        return snapshot;
      }
      return {
        isValidating: true,
        isLoading: true,
        ...snapshot
      };
    };
    const cachedData2 = getCache2();
    const initialData = getInitialCache();
    const clientSnapshot = getSelectedCache(cachedData2);
    const serverSnapshot = cachedData2 === initialData ? clientSnapshot : getSelectedCache(initialData);
    let memorizedSnapshot = clientSnapshot;
    return [
      () => {
        const newSnapshot = getSelectedCache(getCache2());
        const compareResult = isEqual2(newSnapshot, memorizedSnapshot);
        if (compareResult) {
          memorizedSnapshot.data = newSnapshot.data;
          memorizedSnapshot.isLoading = newSnapshot.isLoading;
          memorizedSnapshot.isValidating = newSnapshot.isValidating;
          memorizedSnapshot.error = newSnapshot.error;
          return memorizedSnapshot;
        } else {
          memorizedSnapshot = newSnapshot;
          return newSnapshot;
        }
      },
      () => serverSnapshot
    ];
  }, [
    cache2,
    key
  ]);
  const cached = shimExports.useSyncExternalStore(reactExports.useCallback(
    (callback) => subscribeCache(key, (current, prev2) => {
      if (!isEqual2(prev2, current))
        callback();
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      cache2,
      key
    ]
  ), getSnapshot[0], getSnapshot[1]);
  const isInitialMount = !initialMountedRef.current;
  const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;
  const cachedData = cached.data;
  const data = isUndefined(cachedData) ? fallback : cachedData;
  const error = cached.error;
  const laggyDataRef = reactExports.useRef(data);
  const returnedData = keepPreviousData ? isUndefined(cachedData) ? laggyDataRef.current : cachedData : data;
  const shouldDoInitialRevalidation = (() => {
    if (hasRevalidator && !isUndefined(error))
      return false;
    if (isInitialMount && !isUndefined(revalidateOnMount))
      return revalidateOnMount;
    if (getConfig().isPaused())
      return false;
    if (suspense)
      return isUndefined(data) ? false : revalidateIfStale;
    return isUndefined(data) || revalidateIfStale;
  })();
  const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);
  const isValidating = isUndefined(cached.isValidating) ? defaultValidatingState : cached.isValidating;
  const isLoading = isUndefined(cached.isLoading) ? defaultValidatingState : cached.isLoading;
  const revalidate = reactExports.useCallback(
    async (revalidateOpts) => {
      const currentFetcher = fetcherRef.current;
      if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {
        return false;
      }
      let newData;
      let startAt;
      let loading = true;
      const opts = revalidateOpts || {};
      const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;
      const callbackSafeguard = () => {
        if (IS_REACT_LEGACY) {
          return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;
        }
        return key === keyRef.current;
      };
      const finalState = {
        isValidating: false,
        isLoading: false
      };
      const finishRequestAndUpdateState = () => {
        setCache2(finalState);
      };
      const cleanupState = () => {
        const requestInfo = FETCH[key];
        if (requestInfo && requestInfo[1] === startAt) {
          delete FETCH[key];
        }
      };
      const initialState2 = {
        isValidating: true
      };
      if (isUndefined(getCache2().data)) {
        initialState2.isLoading = true;
      }
      try {
        if (shouldStartNewRequest) {
          setCache2(initialState2);
          if (config2.loadingTimeout && isUndefined(getCache2().data)) {
            setTimeout(() => {
              if (loading && callbackSafeguard()) {
                getConfig().onLoadingSlow(key, config2);
              }
            }, config2.loadingTimeout);
          }
          FETCH[key] = [
            currentFetcher(fnArg),
            getTimestamp()
          ];
        }
        [newData, startAt] = FETCH[key];
        newData = await newData;
        if (shouldStartNewRequest) {
          setTimeout(cleanupState, config2.dedupingInterval);
        }
        if (!FETCH[key] || FETCH[key][1] !== startAt) {
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        finalState.error = UNDEFINED;
        const mutationInfo = MUTATION[key];
        if (!isUndefined(mutationInfo) && // case 1
        (startAt <= mutationInfo[0] || // case 2
        startAt <= mutationInfo[1] || // case 3
        mutationInfo[1] === 0)) {
          finishRequestAndUpdateState();
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onDiscarded(key);
            }
          }
          return false;
        }
        const cacheData = getCache2().data;
        finalState.data = compare2(cacheData, newData) ? cacheData : newData;
        if (shouldStartNewRequest) {
          if (callbackSafeguard()) {
            getConfig().onSuccess(newData, key, config2);
          }
        }
      } catch (err) {
        cleanupState();
        const currentConfig = getConfig();
        const { shouldRetryOnError } = currentConfig;
        if (!currentConfig.isPaused()) {
          finalState.error = err;
          if (shouldStartNewRequest && callbackSafeguard()) {
            currentConfig.onError(err, key, currentConfig);
            if (shouldRetryOnError === true || isFunction2(shouldRetryOnError) && shouldRetryOnError(err)) {
              if (isActive()) {
                currentConfig.onErrorRetry(err, key, currentConfig, (_opts) => {
                  const revalidators = EVENT_REVALIDATORS[key];
                  if (revalidators && revalidators[0]) {
                    revalidators[0](events.ERROR_REVALIDATE_EVENT, _opts);
                  }
                }, {
                  retryCount: (opts.retryCount || 0) + 1,
                  dedupe: true
                });
              }
            }
          }
        }
      }
      loading = false;
      finishRequestAndUpdateState();
      return true;
    },
    // `setState` is immutable, and `eventsCallback`, `fnArg`, and
    // `keyValidating` are depending on `key`, so we can exclude them from
    // the deps array.
    //
    // FIXME:
    // `fn` and `config` might be changed during the lifecycle,
    // but they might be changed every render like this.
    // `useSWR('key', () => fetch('/api/'), { suspense: true })`
    // So we omit the values from the deps array
    // even though it might cause unexpected behaviors.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      key,
      cache2
    ]
  );
  const boundMutate = reactExports.useCallback(
    // Use callback to make sure `keyRef.current` returns latest result every time
    (...args) => {
      return internalMutate(cache2, keyRef.current, ...args);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  useIsomorphicLayoutEffect(() => {
    fetcherRef.current = fetcher;
    configRef.current = config2;
    if (!isUndefined(cachedData)) {
      laggyDataRef.current = cachedData;
    }
  });
  useIsomorphicLayoutEffect(() => {
    if (!key)
      return;
    const softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
    let nextFocusRevalidatedAt = 0;
    const onRevalidate = (type2, opts = {}) => {
      if (type2 == events.FOCUS_EVENT) {
        const now2 = Date.now();
        if (getConfig().revalidateOnFocus && now2 > nextFocusRevalidatedAt && isActive()) {
          nextFocusRevalidatedAt = now2 + getConfig().focusThrottleInterval;
          softRevalidate();
        }
      } else if (type2 == events.RECONNECT_EVENT) {
        if (getConfig().revalidateOnReconnect && isActive()) {
          softRevalidate();
        }
      } else if (type2 == events.MUTATE_EVENT) {
        return revalidate();
      } else if (type2 == events.ERROR_REVALIDATE_EVENT) {
        return revalidate(opts);
      }
      return;
    };
    const unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);
    unmountedRef.current = false;
    keyRef.current = key;
    initialMountedRef.current = true;
    setCache2({
      _k: fnArg
    });
    if (shouldDoInitialRevalidation) {
      if (isUndefined(data) || IS_SERVER) {
        softRevalidate();
      } else {
        rAF(softRevalidate);
      }
    }
    return () => {
      unmountedRef.current = true;
      unsubEvents();
    };
  }, [
    key
  ]);
  useIsomorphicLayoutEffect(() => {
    let timer;
    function next2() {
      const interval = isFunction2(refreshInterval) ? refreshInterval(getCache2().data) : refreshInterval;
      if (interval && timer !== -1) {
        timer = setTimeout(execute, interval);
      }
    }
    function execute() {
      if (!getCache2().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {
        revalidate(WITH_DEDUPE).then(next2);
      } else {
        next2();
      }
    }
    next2();
    return () => {
      if (timer) {
        clearTimeout(timer);
        timer = -1;
      }
    };
  }, [
    refreshInterval,
    refreshWhenHidden,
    refreshWhenOffline,
    key
  ]);
  reactExports.useDebugValue(returnedData);
  if (suspense && isUndefined(data) && key) {
    if (!IS_REACT_LEGACY && IS_SERVER) {
      throw new Error("Fallback data is required when using suspense in SSR.");
    }
    fetcherRef.current = fetcher;
    configRef.current = config2;
    unmountedRef.current = false;
    const req = PRELOAD[key];
    if (!isUndefined(req)) {
      const promise2 = boundMutate(req);
      use(promise2);
    }
    if (isUndefined(error)) {
      const promise2 = revalidate(WITH_DEDUPE);
      if (!isUndefined(returnedData)) {
        promise2.status = "fulfilled";
        promise2.value = true;
      }
      use(promise2);
    } else {
      throw error;
    }
  }
  return {
    mutate: boundMutate,
    get data() {
      stateDependencies.data = true;
      return returnedData;
    },
    get error() {
      stateDependencies.error = true;
      return error;
    },
    get isValidating() {
      stateDependencies.isValidating = true;
      return isValidating;
    },
    get isLoading() {
      stateDependencies.isLoading = true;
      return isLoading;
    }
  };
};
const SWRConfig = OBJECT.defineProperty(SWRConfig$1, "defaultValue", {
  value: defaultConfig
});
const useSWR = withArgs(useSWRHandler);
function useSales(locationId, userId) {
  const { data, mutate: mutate2, error } = useSWR(`/connector/api/sell?location_id=${locationId}?user_id=${userId}?per_page=${-1}`);
  const loading = !data && !error;
  const loggedOut = error && error?.message === "No token provided." || error?.response?.status === 401 || error?.response?.status === 403 || error?.response?.data?.message === "No user found!" || data?.accountStatus === "frozen";
  return {
    loading,
    loggedOut,
    data,
    mutate: mutate2
  };
}
function useProducts() {
  const { data, mutate: mutate2, error } = useSWR("/connector/api/product");
  const loading = !data && !error;
  const loggedOut = error && error?.message === "No token provided." || error?.response?.status === 401 || error?.response?.status === 403 || error?.response?.data?.message === "No user found!" || data?.accountStatus === "frozen";
  return {
    loading,
    loggedOut,
    data,
    mutate: mutate2
  };
}
function useCategories() {
  const { data, mutate: mutate2, error } = useSWR("/connector/api/taxonomy");
  const loading = !data && !error;
  const loggedOut = error && error?.message === "No token provided." || error?.response?.status === 401 || error?.response?.status === 403 || error?.response?.data?.message === "No user found!" || data?.accountStatus === "frozen";
  return {
    loading,
    loggedOut,
    data,
    mutate: mutate2
  };
}
function App() {
  const dispatch = useDispatch();
  const userId = parseInt(`${localStorage.getItem("userId") ?? 0}`);
  const location_ID = parseInt(
    `${localStorage.getItem("location_id") ?? 0}`
  );
  const business_ID = parseInt(
    `${localStorage.getItem("business_id") ?? 0}`
  );
  const accessToken = localStorage.getItem("accessToken");
  const isLoading = useSelector((state) => state.loader.isLoading);
  const isOnline2 = useSelector((state) => state.loader.isOnline);
  const shouldReload = useSelector(
    (state) => state.loader.shouldReload
  );
  const { data: salesData } = useSales(location_ID, userId);
  const { data: productData } = useProducts();
  const { data: categoriesData } = useCategories();
  const getDbPath = async () => {
    const response = await window.electron?.ping();
    localStorage.setItem("dbPath", response);
    dispatch(setDatabasePath(response));
  };
  React.useEffect(() => {
    if (salesData) {
      dispatch(setSales(salesData?.data));
      dispatch(setSalesMeta(salesData?.meta));
      window.electron.sendSalesSummaryDataToMain(
        JSON.stringify(salesData?.data)
      );
    }
    if (productData) {
      window.electron.sendDataToMain(JSON.stringify(productData?.data));
      dispatch(setProducts(productData?.data));
      dispatch(setFilteredProducts(productData?.data));
    }
    if (categoriesData) {
      window.electron.sendCategoriesDataToMain(
        JSON.stringify(categoriesData?.data)
      );
      dispatch(setCategories(categoriesData?.data));
    }
  }, [salesData, productData, categoriesData, dispatch]);
  React.useEffect(() => {
    getDbPath();
  });
  const checkOnlineStatus = async () => {
    try {
      const online2 = await fetch("https://www.google.com");
      return online2.status >= 200 && online2.status < 300;
    } catch (err) {
      return false;
    }
  };
  React.useEffect(() => {
    const inte = setInterval(async () => {
      const result = await checkOnlineStatus();
      dispatch(setOnline(result));
      console.log("CURRENT STATUS :: ", result ? "ONLINE" : "OFFLINE");
    }, 3e3);
    return () => {
      clearInterval(inte);
    };
  });
  React.useEffect(() => {
    const loadCart = async () => {
      try {
        const dbPath = localStorage.getItem("dbPath");
        const carts = await window.electron.carts();
        const drafts = await window.electron.drafts();
        const db2 = await getDatabase(`${dbPath}`);
        console.log("CART FROM MAIN :: ", carts);
        console.log("DRAFT FROM MAIN :: ", drafts);
        const sanitizedCart = JSON.parse(JSON.parse(carts));
        const sanitizedDraft = JSON.parse(JSON.parse(drafts));
        console.log("SANITIZED  CART  FROM  MAIN   :: ", sanitizedCart);
        console.log("SANITIZED  DRAFT  FROM  MAIN   :: ", sanitizedDraft);
        await db2?.carts?.insert(sanitizedCart);
        await db2?.drafts?.insert(sanitizedDraft);
        window.electron.sendCartDataToMain(JSON?.parse(carts));
        window.electron.sendDraftDataToMain(JSON?.parse(drafts));
      } catch (error) {
        console.log(error);
      }
    };
    loadCart();
    setTimeout(() => {
      loadCart();
    }, 6e3);
  }, []);
  React.useEffect(() => {
    const initLogic = async () => {
      if (isOnline2 && accessToken) {
        APIService.getBusinessLocations().then(async (res) => {
          console.log("BUSINESS LOCATIONS REPORT ==>> ", res.data);
          dispatch(setBusinessLocations(res?.data));
          window.electron.sendBusinessLocationDataToMain(
            JSON.stringify(res?.data)
          );
          if (localStorage.getItem("locationId") && localStorage.getItem("businessId")) {
            const locationID = localStorage.getItem("locationId");
            const bizID = localStorage.getItem("businessId");
            console.log("LOCATION ID CHECKINSON HERE ::  ", locationID);
            console.log("BUSINESS ID CHECKINSON HERE ::  ", bizID);
            const currLocation = res?.data?.filter(
              (item) => `${item?.business_id}`.toLowerCase() === `${bizID}`.toLowerCase() && `${item?.location_id}`.toLowerCase() === `${locationID}`.toLowerCase()
            );
            console.log("CURRENT BUSINESS LOCATION ===>>> ", currLocation);
            dispatch(setCurrentBusinessLocation(currLocation[0]));
          }
        }).catch((error) => {
          console.log("ERRO BIZ METHOD ==> ", error);
        });
        APIService.getProductsStockReport().then((res) => {
          console.log("STOCK REPORT ==>> ", res);
        }).catch((error) => {
          console.log("ERRO STOCK REPORT ==> ", error);
        });
        APIService.getCustomers().then(async (res) => {
          console.log("CUSTOMERS ==>> ", res);
          window.electron.sendCustomersDataToMain(JSON.stringify(res?.data));
          dispatch(setCustomerMeta(res?.meta));
          const filtered = res?.data?.filter(
            (item) => item?.type.toLowerCase() === "customer"
          );
          dispatch(setCustomers(filtered));
        }).catch((error) => {
          console.log("ERRO STOCK REPORT ==> ", error);
        });
        if (salesData) {
          dispatch(setSales(salesData?.data));
          dispatch(setSalesMeta(salesData?.meta));
          window.electron.sendSalesSummaryDataToMain(
            JSON.stringify(salesData?.data)
          );
        }
      } else {
        try {
          const businessLocations = await window.electron.bizLocations();
          const copybusinessLocations = businessLocations ?? [];
          dispatch(
            setBusinessLocations(JSON.parse(JSON.parse(copybusinessLocations)))
          );
          console.log(
            "OFFLINE BUSINESS LOCATIONS :: ",
            JSON.parse(copybusinessLocations)
          );
          window.electron.sendBusinessLocationDataToMain(
            JSON.parse(businessLocations)
          );
          if (localStorage.getItem("locationId") && localStorage.getItem("businessId")) {
            const data = JSON.parse(JSON.parse(copybusinessLocations));
            console.log("LOCATION ID, BIZ ID, ", data);
            if (data) {
              const currLocation = data.filter(
                (item) => `${item?.location_id}`.toLowerCase() === localStorage.getItem("locationId")?.toLowerCase() && `${item?.business_id}`.toLowerCase() === localStorage.getItem("businessId")?.toString().toLowerCase()
              );
              console.log("CURRENT BUSINESS LOCATION ==> ", currLocation);
              dispatch(setCurrentBusinessLocation(currLocation[0]));
            }
          }
          const categories = await window.electron.categories();
          dispatch(setCategories(JSON.parse(JSON.parse(categories))));
          window.electron.sendCategoriesDataToMain(JSON.parse(categories));
          const products = await window.electron.products();
          console.log("OFFLINE PRODUCTS :: ", products);
          dispatch(setProducts(JSON.parse(JSON.parse(products))));
          dispatch(setFilteredProducts(JSON.parse(JSON.parse(products))));
          window.electron.sendDataToMain(JSON.parse(products));
          const customers = await window.electron.customers();
          dispatch(setCustomers(JSON.parse(JSON.parse(customers))));
          window.electron.sendCustomersDataToMain(JSON.parse(customers));
          const salesSummary = await window.electron.salesSummary();
          window.electron.sendSalesSummaryDataToMain(JSON.parse(salesSummary));
          const salesParsed = JSON.parse(JSON.parse(salesSummary));
          if (location_ID && business_ID) {
            const filteredSales = salesParsed?.filter(
              (item) => item?.location_id === location_ID && item?.business_id === business_ID
            );
            dispatch(setSales(filteredSales));
          }
        } catch (error) {
          console.log("ERROOR :: ", error);
        }
      }
      const pendingSells = await window.electron.pendingSells();
      window.electron.sendPendingSellsDataToMain(JSON.parse(pendingSells));
    };
    initLogic();
  }, [isOnline2, accessToken, shouldReload, salesData, dispatch, location_ID, business_ID]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Ie, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Backdrop$1, { open: isLoading, sx: { zIndex: 1e4 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress$1, { color: "secondary" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(LoginScreen, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "/dashboard", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Dashboard, {}), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "/dashboard",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/dashboard/home", replace: true })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/dashboard/home", element: /* @__PURE__ */ jsxRuntimeExports.jsx(HomeScreen, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/dashboard/activity", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Activity, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/dashboard/reports", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Reports, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/dashboard/customers", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Customers, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/dashboard/customers/new", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AddCustomer, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/dashboard/supports", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Support, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/dashboard/paymentmethod", element: /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentMethod, {}) })
      ] })
    ] })
  ] });
}
const index = "";
const theme = createTheme({
  palette: {
    primary: {
      main: "#356CAA",
      light: "#CCE4F2",
      dark: "#0B1841"
    },
    secondary: {
      main: "#bbb",
      light: "#f5f5f8"
    },
    info: {
      main: "#07B4B4"
    },
    success: {
      main: "#42AEA3",
      dark: "#1F655E",
      light: "#E8FFFE"
    }
  },
  components: {
    MuiTextField: {
      styleOverrides: {
        root: {
          "& .MuiInputBase-root": {
            border: "none"
            // Remove the border
          }
        }
      }
    },
    MuiContainer: {
      styleOverrides: {
        root: {
          width: "95%",
          maxWidth: "94%"
        },
        disableGutters: true
      }
    },
    MuiAvatar: {
      styleOverrides: {
        circular: {
          ":root": {
            border: "2px solid"
          }
        }
      }
    },
    MuiTypography: {
      styleOverrides: {
        root: {
          fontFamily: "PublicSans, serif"
        }
      }
    },
    MuiAutocomplete: {
      styleOverrides: {
        inputRoot: {
          border: "none"
        }
      }
    },
    MuiInput: {
      styleOverrides: {
        root: {
          disableUnderline: true
        }
      }
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: "capitalize"
        }
      }
    },
    MuiTab: {
      styleOverrides: {
        root: {
          textTransform: "capitalize"
        }
      }
    }
  }
});
const initialState = {
  isAuth: false,
  profile: null
};
const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    setAuth: (state, action) => {
      state.isAuth = action.payload;
    },
    setProfile: (state, action) => {
      state.profile = action.payload;
    }
  }
});
const authReducer = authSlice.reducer;
const store = configureStore({
  reducer: {
    loader: loaderReducer,
    auth: authReducer,
    search: searchReducer,
    purchase: purchaseReducer,
    product: productReducer,
    category: categoryReducer,
    database: databaseReducer,
    customers: customerReducer,
    business_locations: businessLocationsReducer
  }
});
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, { theme, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { store, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SWRConfig,
    {
      value: {
        refreshInterval: 3 * 60 * 1e3,
        // 3 mins
        fetcher: (url) => APIService.fetcher(url)
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
    }
  ) }) }) })
);
export {
  _defineProperty as _,
  commonjsGlobal as c,
  getDefaultExportFromCjs as g
};
