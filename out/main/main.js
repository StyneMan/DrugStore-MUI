"use strict";
const electron$1 = require("electron");
const path$1 = require("node:path");
const require$$3 = require("util");
const fs$3 = require("fs");
const require$$5 = require("crypto");
const require$$6 = require("os");
const require$$7 = require("events");
const require$$8 = require("net");
const require$$0$3 = require("path");
const require$$0$4 = require("constants");
const require$$0$5 = require("stream");
const require$$5$1 = require("assert");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path$1);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var electron = {};
var rxStorageIpcRenderer = {};
var cjs = {};
var Observable$2 = {};
var Subscriber = {};
var isFunction$1 = {};
Object.defineProperty(isFunction$1, "__esModule", { value: true });
isFunction$1.isFunction = void 0;
function isFunction(value) {
  return typeof value === "function";
}
isFunction$1.isFunction = isFunction;
var Subscription$1 = {};
var UnsubscriptionError = {};
var createErrorClass$1 = {};
Object.defineProperty(createErrorClass$1, "__esModule", { value: true });
createErrorClass$1.createErrorClass = void 0;
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
createErrorClass$1.createErrorClass = createErrorClass;
Object.defineProperty(UnsubscriptionError, "__esModule", { value: true });
UnsubscriptionError.UnsubscriptionError = void 0;
var createErrorClass_1$5 = createErrorClass$1;
UnsubscriptionError.UnsubscriptionError = createErrorClass_1$5.createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
var arrRemove$1 = {};
Object.defineProperty(arrRemove$1, "__esModule", { value: true });
arrRemove$1.arrRemove = void 0;
function arrRemove(arr2, item) {
  if (arr2) {
    var index = arr2.indexOf(item);
    0 <= index && arr2.splice(index, 1);
  }
}
arrRemove$1.arrRemove = arrRemove;
var __values$8 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$i = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$h = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(Subscription$1, "__esModule", { value: true });
Subscription$1.isSubscription = Subscription$1.EMPTY_SUBSCRIPTION = Subscription$1.Subscription = void 0;
var isFunction_1$p = isFunction$1;
var UnsubscriptionError_1 = UnsubscriptionError;
var arrRemove_1$7 = arrRemove$1;
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values$8(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction_1$p.isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values$8(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                errors = __spreadArray$h(__spreadArray$h([], __read$i(errors)), __read$i(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError_1.UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove_1$7.arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove_1$7.arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
Subscription$1.Subscription = Subscription;
Subscription$1.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction_1$p.isFunction(value.remove) && isFunction_1$p.isFunction(value.add) && isFunction_1$p.isFunction(value.unsubscribe);
}
Subscription$1.isSubscription = isSubscription;
function execFinalizer(finalizer) {
  if (isFunction_1$p.isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {};
Object.defineProperty(config, "__esModule", { value: true });
config.config = void 0;
config.config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var reportUnhandledError$1 = {};
var timeoutProvider = {};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutProvider = void 0;
  exports.timeoutProvider = {
    setTimeout: function(handler, timeout2) {
      var args2 = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args2[_i - 2] = arguments[_i];
      }
      var delegate = exports.timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout2], __read2(args2)));
      }
      return setTimeout.apply(void 0, __spreadArray2([handler, timeout2], __read2(args2)));
    },
    clearTimeout: function(handle) {
      var delegate = exports.timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };
})(timeoutProvider);
Object.defineProperty(reportUnhandledError$1, "__esModule", { value: true });
reportUnhandledError$1.reportUnhandledError = void 0;
var config_1$2 = config;
var timeoutProvider_1 = timeoutProvider;
function reportUnhandledError(err) {
  timeoutProvider_1.timeoutProvider.setTimeout(function() {
    var onUnhandledError = config_1$2.config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
reportUnhandledError$1.reportUnhandledError = reportUnhandledError;
var noop$2 = {};
Object.defineProperty(noop$2, "__esModule", { value: true });
noop$2.noop = void 0;
function noop$1() {
}
noop$2.noop = noop$1;
var NotificationFactories = {};
Object.defineProperty(NotificationFactories, "__esModule", { value: true });
NotificationFactories.createNotification = NotificationFactories.nextNotification = NotificationFactories.errorNotification = NotificationFactories.COMPLETE_NOTIFICATION = void 0;
NotificationFactories.COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
NotificationFactories.errorNotification = errorNotification;
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
NotificationFactories.nextNotification = nextNotification;
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
NotificationFactories.createNotification = createNotification;
var errorContext$1 = {};
Object.defineProperty(errorContext$1, "__esModule", { value: true });
errorContext$1.captureError = errorContext$1.errorContext = void 0;
var config_1$1 = config;
var context = null;
function errorContext(cb) {
  if (config_1$1.config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
errorContext$1.errorContext = errorContext;
function captureError(err) {
  if (config_1$1.config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}
errorContext$1.captureError = captureError;
(function(exports) {
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
  var isFunction_12 = isFunction$1;
  var Subscription_12 = Subscription$1;
  var config_12 = config;
  var reportUnhandledError_12 = reportUnhandledError$1;
  var noop_12 = noop$2;
  var NotificationFactories_1 = NotificationFactories;
  var timeoutProvider_12 = timeoutProvider;
  var errorContext_12 = errorContext$1;
  var Subscriber2 = function(_super) {
    __extends2(Subscriber3, _super);
    function Subscriber3(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (Subscription_12.isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = exports.EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber3.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber3.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber3.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber3.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber3.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber3.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber3.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber3.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber3;
  }(Subscription_12.Subscription);
  exports.Subscriber = Subscriber2;
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends2(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction_12.isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config_12.config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber2);
  exports.SafeSubscriber = SafeSubscriber;
  function handleUnhandledError(error) {
    if (config_12.config.useDeprecatedSynchronousErrorHandling) {
      errorContext_12.captureError(error);
    } else {
      reportUnhandledError_12.reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config_12.config.onStoppedNotification;
    onStoppedNotification && timeoutProvider_12.timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  exports.EMPTY_OBSERVER = {
    closed: true,
    next: noop_12.noop,
    error: defaultErrorHandler,
    complete: noop_12.noop
  };
})(Subscriber);
var observable = {};
Object.defineProperty(observable, "__esModule", { value: true });
observable.observable = void 0;
observable.observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var pipe$1 = {};
var identity$1 = {};
Object.defineProperty(identity$1, "__esModule", { value: true });
identity$1.identity = void 0;
function identity(x) {
  return x;
}
identity$1.identity = identity;
Object.defineProperty(pipe$1, "__esModule", { value: true });
pipe$1.pipeFromArray = pipe$1.pipe = void 0;
var identity_1$e = identity$1;
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
pipe$1.pipe = pipe;
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity_1$e.identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
pipe$1.pipeFromArray = pipeFromArray;
Object.defineProperty(Observable$2, "__esModule", { value: true });
Observable$2.Observable = void 0;
var Subscriber_1$3 = Subscriber;
var Subscription_1$8 = Subscription$1;
var observable_1$2 = observable;
var pipe_1$2 = pipe$1;
var config_1 = config;
var isFunction_1$o = isFunction$1;
var errorContext_1$1 = errorContext$1;
var Observable$1 = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1$3.SafeSubscriber(observerOrNext, error, complete);
    errorContext_1$1.errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new Subscriber_1$3.SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable_1$2.observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipe_1$2.pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
Observable$2.Observable = Observable$1;
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction_1$o.isFunction(value.next) && isFunction_1$o.isFunction(value.error) && isFunction_1$o.isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber_1$3.Subscriber || isObserver(value) && Subscription_1$8.isSubscription(value);
}
var ConnectableObservable$1 = {};
var refCount$1 = {};
var lift = {};
Object.defineProperty(lift, "__esModule", { value: true });
lift.operate = lift.hasLift = void 0;
var isFunction_1$n = isFunction$1;
function hasLift(source) {
  return isFunction_1$n.isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
lift.hasLift = hasLift;
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
lift.operate = operate;
var OperatorSubscriber$1 = {};
var __extends$f = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(OperatorSubscriber$1, "__esModule", { value: true });
OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber$1.createOperatorSubscriber = void 0;
var Subscriber_1$2 = Subscriber;
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
OperatorSubscriber$1.createOperatorSubscriber = createOperatorSubscriber;
var OperatorSubscriber = function(_super) {
  __extends$f(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber_1$2.Subscriber);
OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber;
Object.defineProperty(refCount$1, "__esModule", { value: true });
refCount$1.refCount = void 0;
var lift_1$14 = lift;
var OperatorSubscriber_1$V = OperatorSubscriber$1;
function refCount() {
  return lift_1$14.operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = OperatorSubscriber_1$V.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}
refCount$1.refCount = refCount;
var __extends$e = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(ConnectableObservable$1, "__esModule", { value: true });
ConnectableObservable$1.ConnectableObservable = void 0;
var Observable_1$n = Observable$2;
var Subscription_1$7 = Subscription$1;
var refCount_1 = refCount$1;
var OperatorSubscriber_1$U = OperatorSubscriber$1;
var lift_1$13 = lift;
var ConnectableObservable = function(_super) {
  __extends$e(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (lift_1$13.hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription_1$7.Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(OperatorSubscriber_1$U.createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription_1$7.Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount_1.refCount()(this);
  };
  return ConnectableObservable2;
}(Observable_1$n.Observable);
ConnectableObservable$1.ConnectableObservable = ConnectableObservable;
var animationFrames$1 = {};
var performanceTimestampProvider = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.performanceTimestampProvider = void 0;
  exports.performanceTimestampProvider = {
    now: function() {
      return (exports.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: void 0
  };
})(performanceTimestampProvider);
var animationFrameProvider = {};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrameProvider = void 0;
  var Subscription_12 = Subscription$1;
  exports.animationFrameProvider = {
    schedule: function(callback) {
      var request = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = exports.animationFrameProvider.delegate;
      if (delegate) {
        request = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle = request(function(timestamp2) {
        cancel = void 0;
        callback(timestamp2);
      });
      return new Subscription_12.Subscription(function() {
        return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
      });
    },
    requestAnimationFrame: function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read2(args2)));
    },
    cancelAnimationFrame: function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read2(args2)));
    },
    delegate: void 0
  };
})(animationFrameProvider);
Object.defineProperty(animationFrames$1, "__esModule", { value: true });
animationFrames$1.animationFrames = void 0;
var Observable_1$m = Observable$2;
var performanceTimestampProvider_1 = performanceTimestampProvider;
var animationFrameProvider_1$1 = animationFrameProvider;
function animationFrames(timestampProvider) {
  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
}
animationFrames$1.animationFrames = animationFrames;
function animationFramesFactory(timestampProvider) {
  return new Observable_1$m.Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider_1$1.animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now2 = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now2 : timestamp2,
            elapsed: now2 - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider_1$1.animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
var Subject$1 = {};
var ObjectUnsubscribedError = {};
Object.defineProperty(ObjectUnsubscribedError, "__esModule", { value: true });
ObjectUnsubscribedError.ObjectUnsubscribedError = void 0;
var createErrorClass_1$4 = createErrorClass$1;
ObjectUnsubscribedError.ObjectUnsubscribedError = createErrorClass_1$4.createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var __extends$d = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values$7 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(Subject$1, "__esModule", { value: true });
Subject$1.AnonymousSubject = Subject$1.Subject = void 0;
var Observable_1$l = Observable$2;
var Subscription_1$6 = Subscription$1;
var ObjectUnsubscribedError_1 = ObjectUnsubscribedError;
var arrRemove_1$6 = arrRemove$1;
var errorContext_1 = errorContext$1;
var Subject = function(_super) {
  __extends$d(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext_1.errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values$7(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext_1.errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext_1.errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return Subscription_1$6.EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription_1$6.Subscription(function() {
      _this.currentObservers = null;
      arrRemove_1$6.arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable_1$l.Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable_1$l.Observable);
Subject$1.Subject = Subject;
var AnonymousSubject = function(_super) {
  __extends$d(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1$6.EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
Subject$1.AnonymousSubject = AnonymousSubject;
var BehaviorSubject$1 = {};
var __extends$c = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(BehaviorSubject$1, "__esModule", { value: true });
BehaviorSubject$1.BehaviorSubject = void 0;
var Subject_1$e = Subject$1;
var BehaviorSubject = function(_super) {
  __extends$c(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject_1$e.Subject);
BehaviorSubject$1.BehaviorSubject = BehaviorSubject;
var ReplaySubject$1 = {};
var dateTimestampProvider = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dateTimestampProvider = void 0;
  exports.dateTimestampProvider = {
    now: function() {
      return (exports.dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };
})(dateTimestampProvider);
var __extends$b = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(ReplaySubject$1, "__esModule", { value: true });
ReplaySubject$1.ReplaySubject = void 0;
var Subject_1$d = Subject$1;
var dateTimestampProvider_1$2 = dateTimestampProvider;
var ReplaySubject = function(_super) {
  __extends$b(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider_1$2.dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last2 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now2; i += 2) {
        last2 = i;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
}(Subject_1$d.Subject);
ReplaySubject$1.ReplaySubject = ReplaySubject;
var AsyncSubject$1 = {};
var __extends$a = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(AsyncSubject$1, "__esModule", { value: true });
AsyncSubject$1.AsyncSubject = void 0;
var Subject_1$c = Subject$1;
var AsyncSubject = function(_super) {
  __extends$a(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject_1$c.Subject);
AsyncSubject$1.AsyncSubject = AsyncSubject;
var asap$2 = {};
var AsapAction$1 = {};
var AsyncAction$1 = {};
var Action$2 = {};
var __extends$9 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(Action$2, "__esModule", { value: true });
Action$2.Action = void 0;
var Subscription_1$5 = Subscription$1;
var Action$1 = function(_super) {
  __extends$9(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    return this;
  };
  return Action2;
}(Subscription_1$5.Subscription);
Action$2.Action = Action$1;
var intervalProvider = {};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intervalProvider = void 0;
  exports.intervalProvider = {
    setInterval: function(handler, timeout2) {
      var args2 = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args2[_i - 2] = arguments[_i];
      }
      var delegate = exports.intervalProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout2], __read2(args2)));
      }
      return setInterval.apply(void 0, __spreadArray2([handler, timeout2], __read2(args2)));
    },
    clearInterval: function(handle) {
      var delegate = exports.intervalProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: void 0
  };
})(intervalProvider);
var __extends$8 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(AsyncAction$1, "__esModule", { value: true });
AsyncAction$1.AsyncAction = void 0;
var Action_1 = Action$2;
var intervalProvider_1 = intervalProvider;
var arrRemove_1$5 = arrRemove$1;
var AsyncAction = function(_super) {
  __extends$8(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider_1.intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions2 = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove_1$5.arrRemove(actions2, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action_1.Action);
AsyncAction$1.AsyncAction = AsyncAction;
var immediateProvider = {};
var Immediate = {};
Object.defineProperty(Immediate, "__esModule", { value: true });
Immediate.TestTools = Immediate.Immediate = void 0;
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
Immediate.Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};
Immediate.TestTools = {
  pending: function() {
    return Object.keys(activeHandles).length;
  }
};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
      to[j] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immediateProvider = void 0;
  var Immediate_1 = Immediate;
  var setImmediate2 = Immediate_1.Immediate.setImmediate, clearImmediate = Immediate_1.Immediate.clearImmediate;
  exports.immediateProvider = {
    setImmediate: function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray2([], __read2(args2)));
    },
    clearImmediate: function(handle) {
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
    },
    delegate: void 0
  };
})(immediateProvider);
var __extends$7 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(AsapAction$1, "__esModule", { value: true });
AsapAction$1.AsapAction = void 0;
var AsyncAction_1$3 = AsyncAction$1;
var immediateProvider_1 = immediateProvider;
var AsapAction = function(_super) {
  __extends$7(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions2 = scheduler.actions;
    if (id != null && ((_a = actions2[actions2.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider_1.immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction_1$3.AsyncAction);
AsapAction$1.AsapAction = AsapAction;
var AsapScheduler$1 = {};
var AsyncScheduler$1 = {};
var Scheduler$1 = {};
Object.defineProperty(Scheduler$1, "__esModule", { value: true });
Scheduler$1.Scheduler = void 0;
var dateTimestampProvider_1$1 = dateTimestampProvider;
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider_1$1.dateTimestampProvider.now;
  return Scheduler2;
}();
Scheduler$1.Scheduler = Scheduler;
var __extends$6 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(AsyncScheduler$1, "__esModule", { value: true });
AsyncScheduler$1.AsyncScheduler = void 0;
var Scheduler_1 = Scheduler$1;
var AsyncScheduler = function(_super) {
  __extends$6(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler_1.Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions2 = this.actions;
    if (this._active) {
      actions2.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions2.shift());
    this._active = false;
    if (error) {
      while (action = actions2.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler_1.Scheduler);
AsyncScheduler$1.AsyncScheduler = AsyncScheduler;
var __extends$5 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(AsapScheduler$1, "__esModule", { value: true });
AsapScheduler$1.AsapScheduler = void 0;
var AsyncScheduler_1$3 = AsyncScheduler$1;
var AsapScheduler = function(_super) {
  __extends$5(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions2 = this.actions;
    var error;
    action = action || actions2.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions2[0]) && action.id === flushId && actions2.shift());
    this._active = false;
    if (error) {
      while ((action = actions2[0]) && action.id === flushId && actions2.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler_1$3.AsyncScheduler);
AsapScheduler$1.AsapScheduler = AsapScheduler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.asap = exports.asapScheduler = void 0;
  var AsapAction_1 = AsapAction$1;
  var AsapScheduler_1 = AsapScheduler$1;
  exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
  exports.asap = exports.asapScheduler;
})(asap$2);
var async = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.async = exports.asyncScheduler = void 0;
  var AsyncAction_12 = AsyncAction$1;
  var AsyncScheduler_12 = AsyncScheduler$1;
  exports.asyncScheduler = new AsyncScheduler_12.AsyncScheduler(AsyncAction_12.AsyncAction);
  exports.async = exports.asyncScheduler;
})(async);
var queue$1 = {};
var QueueAction$1 = {};
var __extends$4 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(QueueAction$1, "__esModule", { value: true });
QueueAction$1.QueueAction = void 0;
var AsyncAction_1$2 = AsyncAction$1;
var QueueAction = function(_super) {
  __extends$4(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction_1$2.AsyncAction);
QueueAction$1.QueueAction = QueueAction;
var QueueScheduler$1 = {};
var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(QueueScheduler$1, "__esModule", { value: true });
QueueScheduler$1.QueueScheduler = void 0;
var AsyncScheduler_1$2 = AsyncScheduler$1;
var QueueScheduler = function(_super) {
  __extends$3(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler_1$2.AsyncScheduler);
QueueScheduler$1.QueueScheduler = QueueScheduler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.queue = exports.queueScheduler = void 0;
  var QueueAction_1 = QueueAction$1;
  var QueueScheduler_1 = QueueScheduler$1;
  exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
  exports.queue = exports.queueScheduler;
})(queue$1);
var animationFrame = {};
var AnimationFrameAction$1 = {};
var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(AnimationFrameAction$1, "__esModule", { value: true });
AnimationFrameAction$1.AnimationFrameAction = void 0;
var AsyncAction_1$1 = AsyncAction$1;
var animationFrameProvider_1 = animationFrameProvider;
var AnimationFrameAction = function(_super) {
  __extends$2(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions2 = scheduler.actions;
    if (id != null && ((_a = actions2[actions2.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction_1$1.AsyncAction);
AnimationFrameAction$1.AnimationFrameAction = AnimationFrameAction;
var AnimationFrameScheduler$1 = {};
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(AnimationFrameScheduler$1, "__esModule", { value: true });
AnimationFrameScheduler$1.AnimationFrameScheduler = void 0;
var AsyncScheduler_1$1 = AsyncScheduler$1;
var AnimationFrameScheduler = function(_super) {
  __extends$1(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions2 = this.actions;
    var error;
    action = action || actions2.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions2[0]) && action.id === flushId && actions2.shift());
    this._active = false;
    if (error) {
      while ((action = actions2[0]) && action.id === flushId && actions2.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler_1$1.AsyncScheduler);
AnimationFrameScheduler$1.AnimationFrameScheduler = AnimationFrameScheduler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrame = exports.animationFrameScheduler = void 0;
  var AnimationFrameAction_1 = AnimationFrameAction$1;
  var AnimationFrameScheduler_1 = AnimationFrameScheduler$1;
  exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
  exports.animationFrame = exports.animationFrameScheduler;
})(animationFrame);
var VirtualTimeScheduler$1 = {};
var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(VirtualTimeScheduler$1, "__esModule", { value: true });
VirtualTimeScheduler$1.VirtualAction = VirtualTimeScheduler$1.VirtualTimeScheduler = void 0;
var AsyncAction_1 = AsyncAction$1;
var Subscription_1$4 = Subscription$1;
var AsyncScheduler_1 = AsyncScheduler$1;
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions2 = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions2[0]) && action.delay <= maxFrames) {
      actions2.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions2.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler_1.AsyncScheduler);
VirtualTimeScheduler$1.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription_1$4.Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions2 = scheduler.actions;
    actions2.push(this);
    actions2.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction_1.AsyncAction);
VirtualTimeScheduler$1.VirtualAction = VirtualAction;
var Notification = {};
var empty = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.empty = exports.EMPTY = void 0;
  var Observable_12 = Observable$2;
  exports.EMPTY = new Observable_12.Observable(function(subscriber) {
    return subscriber.complete();
  });
  function empty2(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
  }
  exports.empty = empty2;
  function emptyScheduled(scheduler) {
    return new Observable_12.Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  }
})(empty);
var of$1 = {};
var args = {};
var isScheduler$1 = {};
Object.defineProperty(isScheduler$1, "__esModule", { value: true });
isScheduler$1.isScheduler = void 0;
var isFunction_1$m = isFunction$1;
function isScheduler(value) {
  return value && isFunction_1$m.isFunction(value.schedule);
}
isScheduler$1.isScheduler = isScheduler;
Object.defineProperty(args, "__esModule", { value: true });
args.popNumber = args.popScheduler = args.popResultSelector = void 0;
var isFunction_1$l = isFunction$1;
var isScheduler_1$3 = isScheduler$1;
function last$4(arr2) {
  return arr2[arr2.length - 1];
}
function popResultSelector(args2) {
  return isFunction_1$l.isFunction(last$4(args2)) ? args2.pop() : void 0;
}
args.popResultSelector = popResultSelector;
function popScheduler(args2) {
  return isScheduler_1$3.isScheduler(last$4(args2)) ? args2.pop() : void 0;
}
args.popScheduler = popScheduler;
function popNumber(args2, defaultValue) {
  return typeof last$4(args2) === "number" ? args2.pop() : defaultValue;
}
args.popNumber = popNumber;
var from$1 = {};
var scheduled$1 = {};
var scheduleObservable$1 = {};
var innerFrom$1 = {};
var isArrayLike = {};
Object.defineProperty(isArrayLike, "__esModule", { value: true });
isArrayLike.isArrayLike = void 0;
isArrayLike.isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};
var isPromise$2 = {};
Object.defineProperty(isPromise$2, "__esModule", { value: true });
isPromise$2.isPromise = void 0;
var isFunction_1$k = isFunction$1;
function isPromise$1(value) {
  return isFunction_1$k.isFunction(value === null || value === void 0 ? void 0 : value.then);
}
isPromise$2.isPromise = isPromise$1;
var isInteropObservable$1 = {};
Object.defineProperty(isInteropObservable$1, "__esModule", { value: true });
isInteropObservable$1.isInteropObservable = void 0;
var observable_1$1 = observable;
var isFunction_1$j = isFunction$1;
function isInteropObservable(input) {
  return isFunction_1$j.isFunction(input[observable_1$1.observable]);
}
isInteropObservable$1.isInteropObservable = isInteropObservable;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: true });
isAsyncIterable$1.isAsyncIterable = void 0;
var isFunction_1$i = isFunction$1;
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction_1$i.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var throwUnobservableError = {};
Object.defineProperty(throwUnobservableError, "__esModule", { value: true });
throwUnobservableError.createInvalidObservableTypeError = void 0;
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
throwUnobservableError.createInvalidObservableTypeError = createInvalidObservableTypeError;
var isIterable$1 = {};
var iterator = {};
Object.defineProperty(iterator, "__esModule", { value: true });
iterator.iterator = iterator.getSymbolIterator = void 0;
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
iterator.getSymbolIterator = getSymbolIterator;
iterator.iterator = getSymbolIterator();
Object.defineProperty(isIterable$1, "__esModule", { value: true });
isIterable$1.isIterable = void 0;
var iterator_1$1 = iterator;
var isFunction_1$h = isFunction$1;
function isIterable(input) {
  return isFunction_1$h.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1$1.iterator]);
}
isIterable$1.isIterable = isIterable;
var isReadableStreamLike$1 = {};
var __generator$2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __await = commonjsGlobal && commonjsGlobal.__await || function(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
};
Object.defineProperty(isReadableStreamLike$1, "__esModule", { value: true });
isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = void 0;
var isFunction_1$g = isFunction$1;
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator$2(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
function isReadableStreamLike(obj) {
  return isFunction_1$g.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __asyncValues = commonjsGlobal && commonjsGlobal.__asyncValues || function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values$6 === "function" ? __values$6(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var __values$6 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(innerFrom$1, "__esModule", { value: true });
innerFrom$1.fromReadableStreamLike = innerFrom$1.fromAsyncIterable = innerFrom$1.fromIterable = innerFrom$1.fromPromise = innerFrom$1.fromArrayLike = innerFrom$1.fromInteropObservable = innerFrom$1.innerFrom = void 0;
var isArrayLike_1$2 = isArrayLike;
var isPromise_1$1 = isPromise$2;
var Observable_1$k = Observable$2;
var isInteropObservable_1$1 = isInteropObservable$1;
var isAsyncIterable_1$1 = isAsyncIterable$1;
var throwUnobservableError_1$1 = throwUnobservableError;
var isIterable_1$1 = isIterable$1;
var isReadableStreamLike_1$2 = isReadableStreamLike$1;
var isFunction_1$f = isFunction$1;
var reportUnhandledError_1 = reportUnhandledError$1;
var observable_1 = observable;
function innerFrom(input) {
  if (input instanceof Observable_1$k.Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable_1$1.isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike_1$2.isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise_1$1.isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable_1$1.isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable_1$1.isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike_1$2.isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw throwUnobservableError_1$1.createInvalidObservableTypeError(input);
}
innerFrom$1.innerFrom = innerFrom;
function fromInteropObservable(obj) {
  return new Observable_1$k.Observable(function(subscriber) {
    var obs = obj[observable_1.observable]();
    if (isFunction_1$f.isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
innerFrom$1.fromInteropObservable = fromInteropObservable;
function fromArrayLike(array2) {
  return new Observable_1$k.Observable(function(subscriber) {
    for (var i = 0; i < array2.length && !subscriber.closed; i++) {
      subscriber.next(array2[i]);
    }
    subscriber.complete();
  });
}
innerFrom$1.fromArrayLike = fromArrayLike;
function fromPromise(promise) {
  return new Observable_1$k.Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError_1.reportUnhandledError);
  });
}
innerFrom$1.fromPromise = fromPromise;
function fromIterable(iterable) {
  return new Observable_1$k.Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values$6(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
innerFrom$1.fromIterable = fromIterable;
function fromAsyncIterable(asyncIterable) {
  return new Observable_1$k.Observable(function(subscriber) {
    process$1(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
innerFrom$1.fromAsyncIterable = fromAsyncIterable;
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(isReadableStreamLike_1$2.readableStreamLikeToAsyncGenerator(readableStream));
}
innerFrom$1.fromReadableStreamLike = fromReadableStreamLike;
function process$1(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator$1(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
var observeOn$1 = {};
var executeSchedule$1 = {};
Object.defineProperty(executeSchedule$1, "__esModule", { value: true });
executeSchedule$1.executeSchedule = void 0;
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}
executeSchedule$1.executeSchedule = executeSchedule;
Object.defineProperty(observeOn$1, "__esModule", { value: true });
observeOn$1.observeOn = void 0;
var executeSchedule_1$6 = executeSchedule$1;
var lift_1$12 = lift;
var OperatorSubscriber_1$T = OperatorSubscriber$1;
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return lift_1$12.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$T.createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule_1$6.executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule_1$6.executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule_1$6.executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}
observeOn$1.observeOn = observeOn;
var subscribeOn$1 = {};
Object.defineProperty(subscribeOn$1, "__esModule", { value: true });
subscribeOn$1.subscribeOn = void 0;
var lift_1$11 = lift;
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return lift_1$11.operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}
subscribeOn$1.subscribeOn = subscribeOn;
Object.defineProperty(scheduleObservable$1, "__esModule", { value: true });
scheduleObservable$1.scheduleObservable = void 0;
var innerFrom_1$D = innerFrom$1;
var observeOn_1$2 = observeOn$1;
var subscribeOn_1$2 = subscribeOn$1;
function scheduleObservable(input, scheduler) {
  return innerFrom_1$D.innerFrom(input).pipe(subscribeOn_1$2.subscribeOn(scheduler), observeOn_1$2.observeOn(scheduler));
}
scheduleObservable$1.scheduleObservable = scheduleObservable;
var schedulePromise$1 = {};
Object.defineProperty(schedulePromise$1, "__esModule", { value: true });
schedulePromise$1.schedulePromise = void 0;
var innerFrom_1$C = innerFrom$1;
var observeOn_1$1 = observeOn$1;
var subscribeOn_1$1 = subscribeOn$1;
function schedulePromise(input, scheduler) {
  return innerFrom_1$C.innerFrom(input).pipe(subscribeOn_1$1.subscribeOn(scheduler), observeOn_1$1.observeOn(scheduler));
}
schedulePromise$1.schedulePromise = schedulePromise;
var scheduleArray$1 = {};
Object.defineProperty(scheduleArray$1, "__esModule", { value: true });
scheduleArray$1.scheduleArray = void 0;
var Observable_1$j = Observable$2;
function scheduleArray(input, scheduler) {
  return new Observable_1$j.Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
scheduleArray$1.scheduleArray = scheduleArray;
var scheduleIterable$1 = {};
Object.defineProperty(scheduleIterable$1, "__esModule", { value: true });
scheduleIterable$1.scheduleIterable = void 0;
var Observable_1$i = Observable$2;
var iterator_1 = iterator;
var isFunction_1$e = isFunction$1;
var executeSchedule_1$5 = executeSchedule$1;
function scheduleIterable(input, scheduler) {
  return new Observable_1$i.Observable(function(subscriber) {
    var iterator2;
    executeSchedule_1$5.executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator_1.iterator]();
      executeSchedule_1$5.executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction_1$e.isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
scheduleIterable$1.scheduleIterable = scheduleIterable;
var scheduleAsyncIterable$1 = {};
Object.defineProperty(scheduleAsyncIterable$1, "__esModule", { value: true });
scheduleAsyncIterable$1.scheduleAsyncIterable = void 0;
var Observable_1$h = Observable$2;
var executeSchedule_1$4 = executeSchedule$1;
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable_1$h.Observable(function(subscriber) {
    executeSchedule_1$4.executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule_1$4.executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
scheduleAsyncIterable$1.scheduleAsyncIterable = scheduleAsyncIterable;
var scheduleReadableStreamLike$1 = {};
Object.defineProperty(scheduleReadableStreamLike$1, "__esModule", { value: true });
scheduleReadableStreamLike$1.scheduleReadableStreamLike = void 0;
var scheduleAsyncIterable_1$1 = scheduleAsyncIterable$1;
var isReadableStreamLike_1$1 = isReadableStreamLike$1;
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable_1$1.scheduleAsyncIterable(isReadableStreamLike_1$1.readableStreamLikeToAsyncGenerator(input), scheduler);
}
scheduleReadableStreamLike$1.scheduleReadableStreamLike = scheduleReadableStreamLike;
Object.defineProperty(scheduled$1, "__esModule", { value: true });
scheduled$1.scheduled = void 0;
var scheduleObservable_1 = scheduleObservable$1;
var schedulePromise_1 = schedulePromise$1;
var scheduleArray_1 = scheduleArray$1;
var scheduleIterable_1$1 = scheduleIterable$1;
var scheduleAsyncIterable_1 = scheduleAsyncIterable$1;
var isInteropObservable_1 = isInteropObservable$1;
var isPromise_1 = isPromise$2;
var isArrayLike_1$1 = isArrayLike;
var isIterable_1 = isIterable$1;
var isAsyncIterable_1 = isAsyncIterable$1;
var throwUnobservableError_1 = throwUnobservableError;
var isReadableStreamLike_1 = isReadableStreamLike$1;
var scheduleReadableStreamLike_1 = scheduleReadableStreamLike$1;
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable_1.isInteropObservable(input)) {
      return scheduleObservable_1.scheduleObservable(input, scheduler);
    }
    if (isArrayLike_1$1.isArrayLike(input)) {
      return scheduleArray_1.scheduleArray(input, scheduler);
    }
    if (isPromise_1.isPromise(input)) {
      return schedulePromise_1.schedulePromise(input, scheduler);
    }
    if (isAsyncIterable_1.isAsyncIterable(input)) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable_1.isIterable(input)) {
      return scheduleIterable_1$1.scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike_1.isReadableStreamLike(input)) {
      return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw throwUnobservableError_1.createInvalidObservableTypeError(input);
}
scheduled$1.scheduled = scheduled;
Object.defineProperty(from$1, "__esModule", { value: true });
from$1.from = void 0;
var scheduled_1 = scheduled$1;
var innerFrom_1$B = innerFrom$1;
function from(input, scheduler) {
  return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1$B.innerFrom(input);
}
from$1.from = from;
Object.defineProperty(of$1, "__esModule", { value: true });
of$1.of = void 0;
var args_1$c = args;
var from_1$6 = from$1;
function of() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$c.popScheduler(args2);
  return from_1$6.from(args2, scheduler);
}
of$1.of = of;
var throwError$1 = {};
Object.defineProperty(throwError$1, "__esModule", { value: true });
throwError$1.throwError = void 0;
var Observable_1$g = Observable$2;
var isFunction_1$d = isFunction$1;
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction_1$d.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable_1$g.Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}
throwError$1.throwError = throwError;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
  var empty_12 = empty;
  var of_12 = of$1;
  var throwError_1 = throwError$1;
  var isFunction_12 = isFunction$1;
  (function(NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
  })(exports.NotificationKind || (exports.NotificationKind = {}));
  var Notification2 = function() {
    function Notification3(kind, value, error) {
      this.kind = kind;
      this.value = value;
      this.error = error;
      this.hasValue = kind === "N";
    }
    Notification3.prototype.observe = function(observer) {
      return observeNotification(this, observer);
    };
    Notification3.prototype.do = function(nextHandler, errorHandler, completeHandler) {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
    };
    Notification3.prototype.accept = function(nextOrObserver, error, complete) {
      var _a;
      return isFunction_12.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
    };
    Notification3.prototype.toObservable = function() {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      var result = kind === "N" ? of_12.of(value) : kind === "E" ? throwError_1.throwError(function() {
        return error;
      }) : kind === "C" ? empty_12.EMPTY : 0;
      if (!result) {
        throw new TypeError("Unexpected notification kind " + kind);
      }
      return result;
    };
    Notification3.createNext = function(value) {
      return new Notification3("N", value);
    };
    Notification3.createError = function(err) {
      return new Notification3("E", void 0, err);
    };
    Notification3.createComplete = function() {
      return Notification3.completeNotification;
    };
    Notification3.completeNotification = new Notification3("C");
    return Notification3;
  }();
  exports.Notification = Notification2;
  function observeNotification(notification, observer) {
    var _a, _b, _c;
    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
    if (typeof kind !== "string") {
      throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
  }
  exports.observeNotification = observeNotification;
})(Notification);
var isObservable$1 = {};
Object.defineProperty(isObservable$1, "__esModule", { value: true });
isObservable$1.isObservable = void 0;
var Observable_1$f = Observable$2;
var isFunction_1$c = isFunction$1;
function isObservable(obj) {
  return !!obj && (obj instanceof Observable_1$f.Observable || isFunction_1$c.isFunction(obj.lift) && isFunction_1$c.isFunction(obj.subscribe));
}
isObservable$1.isObservable = isObservable;
var lastValueFrom$1 = {};
var EmptyError = {};
Object.defineProperty(EmptyError, "__esModule", { value: true });
EmptyError.EmptyError = void 0;
var createErrorClass_1$3 = createErrorClass$1;
EmptyError.EmptyError = createErrorClass_1$3.createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
Object.defineProperty(lastValueFrom$1, "__esModule", { value: true });
lastValueFrom$1.lastValueFrom = void 0;
var EmptyError_1$5 = EmptyError;
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve(_value);
        } else if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError_1$5.EmptyError());
        }
      }
    });
  });
}
lastValueFrom$1.lastValueFrom = lastValueFrom;
var firstValueFrom$1 = {};
Object.defineProperty(firstValueFrom$1, "__esModule", { value: true });
firstValueFrom$1.firstValueFrom = void 0;
var EmptyError_1$4 = EmptyError;
var Subscriber_1$1 = Subscriber;
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new Subscriber_1$1.SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError_1$4.EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
firstValueFrom$1.firstValueFrom = firstValueFrom;
var ArgumentOutOfRangeError = {};
Object.defineProperty(ArgumentOutOfRangeError, "__esModule", { value: true });
ArgumentOutOfRangeError.ArgumentOutOfRangeError = void 0;
var createErrorClass_1$2 = createErrorClass$1;
ArgumentOutOfRangeError.ArgumentOutOfRangeError = createErrorClass_1$2.createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});
var NotFoundError$1 = {};
Object.defineProperty(NotFoundError$1, "__esModule", { value: true });
NotFoundError$1.NotFoundError = void 0;
var createErrorClass_1$1 = createErrorClass$1;
NotFoundError$1.NotFoundError = createErrorClass_1$1.createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});
var SequenceError = {};
Object.defineProperty(SequenceError, "__esModule", { value: true });
SequenceError.SequenceError = void 0;
var createErrorClass_1 = createErrorClass$1;
SequenceError.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});
var timeout = {};
var isDate = {};
Object.defineProperty(isDate, "__esModule", { value: true });
isDate.isValidDate = void 0;
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
isDate.isValidDate = isValidDate;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeout = exports.TimeoutError = void 0;
  var async_12 = async;
  var isDate_12 = isDate;
  var lift_12 = lift;
  var innerFrom_12 = innerFrom$1;
  var createErrorClass_12 = createErrorClass$1;
  var OperatorSubscriber_12 = OperatorSubscriber$1;
  var executeSchedule_12 = executeSchedule$1;
  exports.TimeoutError = createErrorClass_12.createErrorClass(function(_super) {
    return function TimeoutErrorImpl(info) {
      if (info === void 0) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    };
  });
  function timeout2(config2, schedulerArg) {
    var _a = isDate_12.isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_12.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
    if (first2 == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return lift_12.operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = function(delay2) {
        timerSubscription = executeSchedule_12.executeSchedule(subscriber, scheduler, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom_12.innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err) {
            subscriber.error(err);
          }
        }, delay2);
      };
      originalSourceSubscription = source.subscribe(OperatorSubscriber_12.createOperatorSubscriber(subscriber, function(value) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value);
        each > 0 && startTimer(each);
      }, void 0, void 0, function() {
        if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
    });
  }
  exports.timeout = timeout2;
  function timeoutErrorFactory(info) {
    throw new exports.TimeoutError(info);
  }
})(timeout);
var bindCallback$1 = {};
var bindCallbackInternals$1 = {};
var mapOneOrManyArgs$1 = {};
var map$2 = {};
Object.defineProperty(map$2, "__esModule", { value: true });
map$2.map = void 0;
var lift_1$10 = lift;
var OperatorSubscriber_1$S = OperatorSubscriber$1;
function map$1(project2, thisArg) {
  return lift_1$10.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$S.createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project2.call(thisArg, value, index++));
    }));
  });
}
map$2.map = map$1;
var __read$h = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$g = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(mapOneOrManyArgs$1, "__esModule", { value: true });
mapOneOrManyArgs$1.mapOneOrManyArgs = void 0;
var map_1$5 = map$2;
var isArray$4 = Array.isArray;
function callOrApply(fn, args2) {
  return isArray$4(args2) ? fn.apply(void 0, __spreadArray$g([], __read$h(args2))) : fn(args2);
}
function mapOneOrManyArgs(fn) {
  return map_1$5.map(function(args2) {
    return callOrApply(fn, args2);
  });
}
mapOneOrManyArgs$1.mapOneOrManyArgs = mapOneOrManyArgs;
var __read$g = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$f = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(bindCallbackInternals$1, "__esModule", { value: true });
bindCallbackInternals$1.bindCallbackInternals = void 0;
var isScheduler_1$2 = isScheduler$1;
var Observable_1$e = Observable$2;
var subscribeOn_1 = subscribeOn$1;
var mapOneOrManyArgs_1$6 = mapOneOrManyArgs$1;
var observeOn_1 = observeOn$1;
var AsyncSubject_1$1 = AsyncSubject$1;
function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler_1$2.isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args2).pipe(mapOneOrManyArgs_1$6.mapOneOrManyArgs(resultSelector));
      };
    }
  }
  if (scheduler) {
    return function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args2).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    };
  }
  return function() {
    var _this = this;
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var subject = new AsyncSubject_1$1.AsyncSubject();
    var uninitialized = true;
    return new Observable_1$e.Observable(function(subscriber) {
      var subs = subject.subscribe(subscriber);
      if (uninitialized) {
        uninitialized = false;
        var isAsync_1 = false;
        var isComplete_1 = false;
        callbackFunc.apply(_this, __spreadArray$f(__spreadArray$f([], __read$g(args2)), [
          function() {
            var results = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              results[_i2] = arguments[_i2];
            }
            if (isNodeStyle) {
              var err = results.shift();
              if (err != null) {
                subject.error(err);
                return;
              }
            }
            subject.next(1 < results.length ? results : results[0]);
            isComplete_1 = true;
            if (isAsync_1) {
              subject.complete();
            }
          }
        ]));
        if (isComplete_1) {
          subject.complete();
        }
        isAsync_1 = true;
      }
      return subs;
    });
  };
}
bindCallbackInternals$1.bindCallbackInternals = bindCallbackInternals;
Object.defineProperty(bindCallback$1, "__esModule", { value: true });
bindCallback$1.bindCallback = void 0;
var bindCallbackInternals_1$1 = bindCallbackInternals$1;
function bindCallback(callbackFunc, resultSelector, scheduler) {
  return bindCallbackInternals_1$1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
}
bindCallback$1.bindCallback = bindCallback;
var bindNodeCallback$1 = {};
Object.defineProperty(bindNodeCallback$1, "__esModule", { value: true });
bindNodeCallback$1.bindNodeCallback = void 0;
var bindCallbackInternals_1 = bindCallbackInternals$1;
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
}
bindNodeCallback$1.bindNodeCallback = bindNodeCallback;
var combineLatest$3 = {};
var argsArgArrayOrObject$1 = {};
Object.defineProperty(argsArgArrayOrObject$1, "__esModule", { value: true });
argsArgArrayOrObject$1.argsArgArrayOrObject = void 0;
var isArray$3 = Array.isArray;
var getPrototypeOf$2 = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(args2) {
  if (args2.length === 1) {
    var first_1 = args2[0];
    if (isArray$3(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys2 = getKeys(first_1);
      return {
        args: keys2.map(function(key) {
          return first_1[key];
        }),
        keys: keys2
      };
    }
  }
  return { args: args2, keys: null };
}
argsArgArrayOrObject$1.argsArgArrayOrObject = argsArgArrayOrObject;
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf$2(obj) === objectProto;
}
var createObject$1 = {};
Object.defineProperty(createObject$1, "__esModule", { value: true });
createObject$1.createObject = void 0;
function createObject(keys2, values) {
  return keys2.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}
createObject$1.createObject = createObject;
Object.defineProperty(combineLatest$3, "__esModule", { value: true });
combineLatest$3.combineLatestInit = combineLatest$3.combineLatest = void 0;
var Observable_1$d = Observable$2;
var argsArgArrayOrObject_1$1 = argsArgArrayOrObject$1;
var from_1$5 = from$1;
var identity_1$d = identity$1;
var mapOneOrManyArgs_1$5 = mapOneOrManyArgs$1;
var args_1$b = args;
var createObject_1$1 = createObject$1;
var OperatorSubscriber_1$R = OperatorSubscriber$1;
var executeSchedule_1$3 = executeSchedule$1;
function combineLatest$2() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$b.popScheduler(args2);
  var resultSelector = args_1$b.popResultSelector(args2);
  var _a = argsArgArrayOrObject_1$1.argsArgArrayOrObject(args2), observables = _a.args, keys2 = _a.keys;
  if (observables.length === 0) {
    return from_1$5.from([], scheduler);
  }
  var result = new Observable_1$d.Observable(combineLatestInit(observables, scheduler, keys2 ? function(values) {
    return createObject_1$1.createObject(keys2, values);
  } : identity_1$d.identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs_1$5.mapOneOrManyArgs(resultSelector)) : result;
}
combineLatest$3.combineLatest = combineLatest$2;
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity_1$d.identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from_1$5.from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(OperatorSubscriber_1$R.createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
combineLatest$3.combineLatestInit = combineLatestInit;
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule_1$3.executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
var concat$5 = {};
var concatAll$1 = {};
var mergeAll$1 = {};
var mergeMap$1 = {};
var mergeInternals$1 = {};
Object.defineProperty(mergeInternals$1, "__esModule", { value: true });
mergeInternals$1.mergeInternals = void 0;
var innerFrom_1$A = innerFrom$1;
var executeSchedule_1$2 = executeSchedule$1;
var OperatorSubscriber_1$Q = OperatorSubscriber$1;
function mergeInternals(source, subscriber, project2, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom_1$A.innerFrom(project2(value, index++)).subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule_1$2.executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
mergeInternals$1.mergeInternals = mergeInternals;
Object.defineProperty(mergeMap$1, "__esModule", { value: true });
mergeMap$1.mergeMap = void 0;
var map_1$4 = map$2;
var innerFrom_1$z = innerFrom$1;
var lift_1$$ = lift;
var mergeInternals_1$2 = mergeInternals$1;
var isFunction_1$b = isFunction$1;
function mergeMap(project2, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction_1$b.isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map_1$4.map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom_1$z.innerFrom(project2(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return lift_1$$.operate(function(source, subscriber) {
    return mergeInternals_1$2.mergeInternals(source, subscriber, project2, concurrent);
  });
}
mergeMap$1.mergeMap = mergeMap;
Object.defineProperty(mergeAll$1, "__esModule", { value: true });
mergeAll$1.mergeAll = void 0;
var mergeMap_1$6 = mergeMap$1;
var identity_1$c = identity$1;
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap_1$6.mergeMap(identity_1$c.identity, concurrent);
}
mergeAll$1.mergeAll = mergeAll;
Object.defineProperty(concatAll$1, "__esModule", { value: true });
concatAll$1.concatAll = void 0;
var mergeAll_1$2 = mergeAll$1;
function concatAll() {
  return mergeAll_1$2.mergeAll(1);
}
concatAll$1.concatAll = concatAll;
Object.defineProperty(concat$5, "__esModule", { value: true });
concat$5.concat = void 0;
var concatAll_1$1 = concatAll$1;
var args_1$a = args;
var from_1$4 = from$1;
function concat$4() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  return concatAll_1$1.concatAll()(from_1$4.from(args2, args_1$a.popScheduler(args2)));
}
concat$5.concat = concat$4;
var connectable$1 = {};
var defer$1 = {};
Object.defineProperty(defer$1, "__esModule", { value: true });
defer$1.defer = void 0;
var Observable_1$c = Observable$2;
var innerFrom_1$y = innerFrom$1;
function defer(observableFactory) {
  return new Observable_1$c.Observable(function(subscriber) {
    innerFrom_1$y.innerFrom(observableFactory()).subscribe(subscriber);
  });
}
defer$1.defer = defer;
Object.defineProperty(connectable$1, "__esModule", { value: true });
connectable$1.connectable = void 0;
var Subject_1$b = Subject$1;
var Observable_1$b = Observable$2;
var defer_1$2 = defer$1;
var DEFAULT_CONFIG$1 = {
  connector: function() {
    return new Subject_1$b.Subject();
  },
  resetOnDisconnect: true
};
function connectable(source, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG$1;
  }
  var connection = null;
  var connector = config2.connector, _a = config2.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
  var subject = connector();
  var result = new Observable_1$b.Observable(function(subscriber) {
    return subject.subscribe(subscriber);
  });
  result.connect = function() {
    if (!connection || connection.closed) {
      connection = defer_1$2.defer(function() {
        return source;
      }).subscribe(subject);
      if (resetOnDisconnect) {
        connection.add(function() {
          return subject = connector();
        });
      }
    }
    return connection;
  };
  return result;
}
connectable$1.connectable = connectable;
var forkJoin$1 = {};
Object.defineProperty(forkJoin$1, "__esModule", { value: true });
forkJoin$1.forkJoin = void 0;
var Observable_1$a = Observable$2;
var argsArgArrayOrObject_1 = argsArgArrayOrObject$1;
var innerFrom_1$x = innerFrom$1;
var args_1$9 = args;
var OperatorSubscriber_1$P = OperatorSubscriber$1;
var mapOneOrManyArgs_1$4 = mapOneOrManyArgs$1;
var createObject_1 = createObject$1;
function forkJoin() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var resultSelector = args_1$9.popResultSelector(args2);
  var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args2), sources = _a.args, keys2 = _a.keys;
  var result = new Observable_1$a.Observable(function(subscriber) {
    var length = sources.length;
    if (!length) {
      subscriber.complete();
      return;
    }
    var values = new Array(length);
    var remainingCompletions = length;
    var remainingEmissions = length;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom_1$x.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1$P.createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys2 ? createObject_1.createObject(keys2, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs_1$4.mapOneOrManyArgs(resultSelector)) : result;
}
forkJoin$1.forkJoin = forkJoin;
var fromEvent$1 = {};
var __read$f = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
Object.defineProperty(fromEvent$1, "__esModule", { value: true });
fromEvent$1.fromEvent = void 0;
var innerFrom_1$w = innerFrom$1;
var Observable_1$9 = Observable$2;
var mergeMap_1$5 = mergeMap$1;
var isArrayLike_1 = isArrayLike;
var isFunction_1$a = isFunction$1;
var mapOneOrManyArgs_1$3 = mapOneOrManyArgs$1;
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options2, resultSelector) {
  if (isFunction_1$a.isFunction(options2)) {
    resultSelector = options2;
    options2 = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options2).pipe(mapOneOrManyArgs_1$3.mapOneOrManyArgs(resultSelector));
  }
  var _a = __read$f(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options2);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add2 = _a[0], remove = _a[1];
  if (!add2) {
    if (isArrayLike_1.isArrayLike(target)) {
      return mergeMap_1$5.mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options2);
      })(innerFrom_1$w.innerFrom(target));
    }
  }
  if (!add2) {
    throw new TypeError("Invalid event target");
  }
  return new Observable_1$9.Observable(function(subscriber) {
    var handler = function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return subscriber.next(1 < args2.length ? args2 : args2[0]);
    };
    add2(handler);
    return function() {
      return remove(handler);
    };
  });
}
fromEvent$1.fromEvent = fromEvent;
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction_1$a.isFunction(target.addListener) && isFunction_1$a.isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction_1$a.isFunction(target.on) && isFunction_1$a.isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction_1$a.isFunction(target.addEventListener) && isFunction_1$a.isFunction(target.removeEventListener);
}
var fromEventPattern$1 = {};
Object.defineProperty(fromEventPattern$1, "__esModule", { value: true });
fromEventPattern$1.fromEventPattern = void 0;
var Observable_1$8 = Observable$2;
var isFunction_1$9 = isFunction$1;
var mapOneOrManyArgs_1$2 = mapOneOrManyArgs$1;
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1$2.mapOneOrManyArgs(resultSelector));
  }
  return new Observable_1$8.Observable(function(subscriber) {
    var handler = function() {
      var e = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e[_i] = arguments[_i];
      }
      return subscriber.next(e.length === 1 ? e[0] : e);
    };
    var retValue = addHandler(handler);
    return isFunction_1$9.isFunction(removeHandler) ? function() {
      return removeHandler(handler, retValue);
    } : void 0;
  });
}
fromEventPattern$1.fromEventPattern = fromEventPattern;
var generate$1 = {};
var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(generate$1, "__esModule", { value: true });
generate$1.generate = void 0;
var identity_1$b = identity$1;
var isScheduler_1$1 = isScheduler$1;
var defer_1$1 = defer$1;
var scheduleIterable_1 = scheduleIterable$1;
function generate(initialStateOrOptions, condition, iterate2, resultSelectorOrScheduler, scheduler) {
  var _a, _b;
  var resultSelector;
  var initialState;
  if (arguments.length === 1) {
    _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate2 = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1$b.identity : _b, scheduler = _a.scheduler;
  } else {
    initialState = initialStateOrOptions;
    if (!resultSelectorOrScheduler || isScheduler_1$1.isScheduler(resultSelectorOrScheduler)) {
      resultSelector = identity_1$b.identity;
      scheduler = resultSelectorOrScheduler;
    } else {
      resultSelector = resultSelectorOrScheduler;
    }
  }
  function gen() {
    var state;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          state = initialState;
          _a2.label = 1;
        case 1:
          if (!(!condition || condition(state)))
            return [3, 4];
          return [4, resultSelector(state)];
        case 2:
          _a2.sent();
          _a2.label = 3;
        case 3:
          state = iterate2(state);
          return [3, 1];
        case 4:
          return [2];
      }
    });
  }
  return defer_1$1.defer(scheduler ? function() {
    return scheduleIterable_1.scheduleIterable(gen(), scheduler);
  } : gen);
}
generate$1.generate = generate;
var iif$1 = {};
Object.defineProperty(iif$1, "__esModule", { value: true });
iif$1.iif = void 0;
var defer_1 = defer$1;
function iif(condition, trueResult, falseResult) {
  return defer_1.defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
iif$1.iif = iif;
var interval$1 = {};
var timer$1 = {};
Object.defineProperty(timer$1, "__esModule", { value: true });
timer$1.timer = void 0;
var Observable_1$7 = Observable$2;
var async_1$a = async;
var isScheduler_1 = isScheduler$1;
var isDate_1$1 = isDate;
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async_1$a.async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler_1.isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable_1$7.Observable(function(subscriber) {
    var due = isDate_1$1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
timer$1.timer = timer;
Object.defineProperty(interval$1, "__esModule", { value: true });
interval$1.interval = void 0;
var async_1$9 = async;
var timer_1$5 = timer$1;
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async_1$9.asyncScheduler;
  }
  if (period < 0) {
    period = 0;
  }
  return timer_1$5.timer(period, period, scheduler);
}
interval$1.interval = interval;
var merge$5 = {};
Object.defineProperty(merge$5, "__esModule", { value: true });
merge$5.merge = void 0;
var mergeAll_1$1 = mergeAll$1;
var innerFrom_1$v = innerFrom$1;
var empty_1$6 = empty;
var args_1$8 = args;
var from_1$3 = from$1;
function merge$4() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$8.popScheduler(args2);
  var concurrent = args_1$8.popNumber(args2, Infinity);
  var sources = args2;
  return !sources.length ? empty_1$6.EMPTY : sources.length === 1 ? innerFrom_1$v.innerFrom(sources[0]) : mergeAll_1$1.mergeAll(concurrent)(from_1$3.from(sources, scheduler));
}
merge$5.merge = merge$4;
var never = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.never = exports.NEVER = void 0;
  var Observable_12 = Observable$2;
  var noop_12 = noop$2;
  exports.NEVER = new Observable_12.Observable(noop_12.noop);
  function never2() {
    return exports.NEVER;
  }
  exports.never = never2;
})(never);
var onErrorResumeNext$1 = {};
var argsOrArgArray$1 = {};
Object.defineProperty(argsOrArgArray$1, "__esModule", { value: true });
argsOrArgArray$1.argsOrArgArray = void 0;
var isArray$2 = Array.isArray;
function argsOrArgArray(args2) {
  return args2.length === 1 && isArray$2(args2[0]) ? args2[0] : args2;
}
argsOrArgArray$1.argsOrArgArray = argsOrArgArray;
Object.defineProperty(onErrorResumeNext$1, "__esModule", { value: true });
onErrorResumeNext$1.onErrorResumeNext = void 0;
var Observable_1$6 = Observable$2;
var argsOrArgArray_1$6 = argsOrArgArray$1;
var OperatorSubscriber_1$O = OperatorSubscriber$1;
var noop_1$c = noop$2;
var innerFrom_1$u = innerFrom$1;
function onErrorResumeNext() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var nextSources = argsOrArgArray_1$6.argsOrArgArray(sources);
  return new Observable_1$6.Observable(function(subscriber) {
    var sourceIndex = 0;
    var subscribeNext = function() {
      if (sourceIndex < nextSources.length) {
        var nextSource = void 0;
        try {
          nextSource = innerFrom_1$u.innerFrom(nextSources[sourceIndex++]);
        } catch (err) {
          subscribeNext();
          return;
        }
        var innerSubscriber = new OperatorSubscriber_1$O.OperatorSubscriber(subscriber, void 0, noop_1$c.noop, noop_1$c.noop);
        nextSource.subscribe(innerSubscriber);
        innerSubscriber.add(subscribeNext);
      } else {
        subscriber.complete();
      }
    };
    subscribeNext();
  });
}
onErrorResumeNext$1.onErrorResumeNext = onErrorResumeNext;
var pairs$1 = {};
Object.defineProperty(pairs$1, "__esModule", { value: true });
pairs$1.pairs = void 0;
var from_1$2 = from$1;
function pairs(obj, scheduler) {
  return from_1$2.from(Object.entries(obj), scheduler);
}
pairs$1.pairs = pairs;
var partition$3 = {};
var not$3 = {};
Object.defineProperty(not$3, "__esModule", { value: true });
not$3.not = void 0;
function not$2(pred, thisArg) {
  return function(value, index) {
    return !pred.call(thisArg, value, index);
  };
}
not$3.not = not$2;
var filter$2 = {};
Object.defineProperty(filter$2, "__esModule", { value: true });
filter$2.filter = void 0;
var lift_1$_ = lift;
var OperatorSubscriber_1$N = OperatorSubscriber$1;
function filter$1(predicate, thisArg) {
  return lift_1$_.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$N.createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
filter$2.filter = filter$1;
Object.defineProperty(partition$3, "__esModule", { value: true });
partition$3.partition = void 0;
var not_1$1 = not$3;
var filter_1$5 = filter$2;
var innerFrom_1$t = innerFrom$1;
function partition$2(source, predicate, thisArg) {
  return [filter_1$5.filter(predicate, thisArg)(innerFrom_1$t.innerFrom(source)), filter_1$5.filter(not_1$1.not(predicate, thisArg))(innerFrom_1$t.innerFrom(source))];
}
partition$3.partition = partition$2;
var race$3 = {};
Object.defineProperty(race$3, "__esModule", { value: true });
race$3.raceInit = race$3.race = void 0;
var Observable_1$5 = Observable$2;
var innerFrom_1$s = innerFrom$1;
var argsOrArgArray_1$5 = argsOrArgArray$1;
var OperatorSubscriber_1$M = OperatorSubscriber$1;
function race$2() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray_1$5.argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom_1$s.innerFrom(sources[0]) : new Observable_1$5.Observable(raceInit(sources));
}
race$3.race = race$2;
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom_1$s.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1$M.createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s = 0; s < subscriptions.length; s++) {
            s !== i2 && subscriptions[s].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}
race$3.raceInit = raceInit;
var range$2 = {};
Object.defineProperty(range$2, "__esModule", { value: true });
range$2.range = void 0;
var Observable_1$4 = Observable$2;
var empty_1$5 = empty;
function range$1(start, count2, scheduler) {
  if (count2 == null) {
    count2 = start;
    start = 0;
  }
  if (count2 <= 0) {
    return empty_1$5.EMPTY;
  }
  var end = count2 + start;
  return new Observable_1$4.Observable(scheduler ? function(subscriber) {
    var n = start;
    return scheduler.schedule(function() {
      if (n < end) {
        subscriber.next(n++);
        this.schedule();
      } else {
        subscriber.complete();
      }
    });
  } : function(subscriber) {
    var n = start;
    while (n < end && !subscriber.closed) {
      subscriber.next(n++);
    }
    subscriber.complete();
  });
}
range$2.range = range$1;
var using$1 = {};
Object.defineProperty(using$1, "__esModule", { value: true });
using$1.using = void 0;
var Observable_1$3 = Observable$2;
var innerFrom_1$r = innerFrom$1;
var empty_1$4 = empty;
function using(resourceFactory, observableFactory) {
  return new Observable_1$3.Observable(function(subscriber) {
    var resource = resourceFactory();
    var result = observableFactory(resource);
    var source = result ? innerFrom_1$r.innerFrom(result) : empty_1$4.EMPTY;
    source.subscribe(subscriber);
    return function() {
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
using$1.using = using;
var zip$4 = {};
var __read$e = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$e = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(zip$4, "__esModule", { value: true });
zip$4.zip = void 0;
var Observable_1$2 = Observable$2;
var innerFrom_1$q = innerFrom$1;
var argsOrArgArray_1$4 = argsOrArgArray$1;
var empty_1$3 = empty;
var OperatorSubscriber_1$L = OperatorSubscriber$1;
var args_1$7 = args;
function zip$3() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var resultSelector = args_1$7.popResultSelector(args2);
  var sources = argsOrArgArray_1$4.argsOrArgArray(args2);
  return sources.length ? new Observable_1$2.Observable(function(subscriber) {
    var buffers = sources.map(function() {
      return [];
    });
    var completed = sources.map(function() {
      return false;
    });
    subscriber.add(function() {
      buffers = completed = null;
    });
    var _loop_1 = function(sourceIndex2) {
      innerFrom_1$q.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1$L.createOperatorSubscriber(subscriber, function(value) {
        buffers[sourceIndex2].push(value);
        if (buffers.every(function(buffer2) {
          return buffer2.length;
        })) {
          var result = buffers.map(function(buffer2) {
            return buffer2.shift();
          });
          subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray$e([], __read$e(result))) : result);
          if (buffers.some(function(buffer2, i) {
            return !buffer2.length && completed[i];
          })) {
            subscriber.complete();
          }
        }
      }, function() {
        completed[sourceIndex2] = true;
        !buffers[sourceIndex2].length && subscriber.complete();
      }));
    };
    for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
    return function() {
      buffers = completed = null;
    };
  }) : empty_1$3.EMPTY;
}
zip$4.zip = zip$3;
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
var audit$1 = {};
Object.defineProperty(audit$1, "__esModule", { value: true });
audit$1.audit = void 0;
var lift_1$Z = lift;
var innerFrom_1$p = innerFrom$1;
var OperatorSubscriber_1$K = OperatorSubscriber$1;
function audit(durationSelector) {
  return lift_1$Z.operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var isComplete = false;
    var endDuration = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
      isComplete && subscriber.complete();
    };
    var cleanupDuration = function() {
      durationSubscriber = null;
      isComplete && subscriber.complete();
    };
    source.subscribe(OperatorSubscriber_1$K.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
      if (!durationSubscriber) {
        innerFrom_1$p.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1$K.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
      }
    }, function() {
      isComplete = true;
      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
    }));
  });
}
audit$1.audit = audit;
var auditTime$1 = {};
Object.defineProperty(auditTime$1, "__esModule", { value: true });
auditTime$1.auditTime = void 0;
var async_1$8 = async;
var audit_1 = audit$1;
var timer_1$4 = timer$1;
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$8.asyncScheduler;
  }
  return audit_1.audit(function() {
    return timer_1$4.timer(duration, scheduler);
  });
}
auditTime$1.auditTime = auditTime;
var buffer$1 = {};
Object.defineProperty(buffer$1, "__esModule", { value: true });
buffer$1.buffer = void 0;
var lift_1$Y = lift;
var noop_1$b = noop$2;
var OperatorSubscriber_1$J = OperatorSubscriber$1;
var innerFrom_1$o = innerFrom$1;
function buffer(closingNotifier) {
  return lift_1$Y.operate(function(source, subscriber) {
    var currentBuffer = [];
    source.subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(subscriber, function(value) {
      return currentBuffer.push(value);
    }, function() {
      subscriber.next(currentBuffer);
      subscriber.complete();
    }));
    innerFrom_1$o.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(subscriber, function() {
      var b = currentBuffer;
      currentBuffer = [];
      subscriber.next(b);
    }, noop_1$b.noop));
    return function() {
      currentBuffer = null;
    };
  });
}
buffer$1.buffer = buffer;
var bufferCount$1 = {};
var __values$5 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferCount$1, "__esModule", { value: true });
bufferCount$1.bufferCount = void 0;
var lift_1$X = lift;
var OperatorSubscriber_1$I = OperatorSubscriber$1;
var arrRemove_1$4 = arrRemove$1;
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
  return lift_1$X.operate(function(source, subscriber) {
    var buffers = [];
    var count2 = 0;
    source.subscribe(OperatorSubscriber_1$I.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a, e_2, _b;
      var toEmit = null;
      if (count2++ % startBufferEvery === 0) {
        buffers.push([]);
      }
      try {
        for (var buffers_1 = __values$5(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
          if (bufferSize <= buffer2.length) {
            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
            toEmit.push(buffer2);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
            _a.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (toEmit) {
        try {
          for (var toEmit_1 = __values$5(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
            var buffer2 = toEmit_1_1.value;
            arrRemove_1$4.arrRemove(buffers, buffer2);
            subscriber.next(buffer2);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
              _b.call(toEmit_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    }, function() {
      var e_3, _a;
      try {
        for (var buffers_2 = __values$5(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
          var buffer2 = buffers_2_1.value;
          subscriber.next(buffer2);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
            _a.call(buffers_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffers = null;
    }));
  });
}
bufferCount$1.bufferCount = bufferCount;
var bufferTime$1 = {};
var __values$4 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferTime$1, "__esModule", { value: true });
bufferTime$1.bufferTime = void 0;
var Subscription_1$3 = Subscription$1;
var lift_1$W = lift;
var OperatorSubscriber_1$H = OperatorSubscriber$1;
var arrRemove_1$3 = arrRemove$1;
var async_1$7 = async;
var args_1$6 = args;
var executeSchedule_1$1 = executeSchedule$1;
function bufferTime(bufferTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler = (_a = args_1$6.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1$7.asyncScheduler;
  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxBufferSize = otherArgs[1] || Infinity;
  return lift_1$W.operate(function(source, subscriber) {
    var bufferRecords = [];
    var restartOnEmit = false;
    var emit = function(record) {
      var buffer2 = record.buffer, subs = record.subs;
      subs.unsubscribe();
      arrRemove_1$3.arrRemove(bufferRecords, record);
      subscriber.next(buffer2);
      restartOnEmit && startBuffer();
    };
    var startBuffer = function() {
      if (bufferRecords) {
        var subs = new Subscription_1$3.Subscription();
        subscriber.add(subs);
        var buffer2 = [];
        var record_1 = {
          buffer: buffer2,
          subs
        };
        bufferRecords.push(record_1);
        executeSchedule_1$1.executeSchedule(subs, scheduler, function() {
          return emit(record_1);
        }, bufferTimeSpan);
      }
    };
    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
      executeSchedule_1$1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
    } else {
      restartOnEmit = true;
    }
    startBuffer();
    var bufferTimeSubscriber = OperatorSubscriber_1$H.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a2;
      var recordsCopy = bufferRecords.slice();
      try {
        for (var recordsCopy_1 = __values$4(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
          var record = recordsCopy_1_1.value;
          var buffer2 = record.buffer;
          buffer2.push(value);
          maxBufferSize <= buffer2.length && emit(record);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
            _a2.call(recordsCopy_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
        subscriber.next(bufferRecords.shift().buffer);
      }
      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
      subscriber.complete();
      subscriber.unsubscribe();
    }, void 0, function() {
      return bufferRecords = null;
    });
    source.subscribe(bufferTimeSubscriber);
  });
}
bufferTime$1.bufferTime = bufferTime;
var bufferToggle$1 = {};
var __values$3 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferToggle$1, "__esModule", { value: true });
bufferToggle$1.bufferToggle = void 0;
var Subscription_1$2 = Subscription$1;
var lift_1$V = lift;
var innerFrom_1$n = innerFrom$1;
var OperatorSubscriber_1$G = OperatorSubscriber$1;
var noop_1$a = noop$2;
var arrRemove_1$2 = arrRemove$1;
function bufferToggle(openings, closingSelector) {
  return lift_1$V.operate(function(source, subscriber) {
    var buffers = [];
    innerFrom_1$n.innerFrom(openings).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, function(openValue) {
      var buffer2 = [];
      buffers.push(buffer2);
      var closingSubscription = new Subscription_1$2.Subscription();
      var emitBuffer = function() {
        arrRemove_1$2.arrRemove(buffers, buffer2);
        subscriber.next(buffer2);
        closingSubscription.unsubscribe();
      };
      closingSubscription.add(innerFrom_1$n.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, emitBuffer, noop_1$a.noop)));
    }, noop_1$a.noop));
    source.subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var buffers_1 = __values$3(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
            _a.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (buffers.length > 0) {
        subscriber.next(buffers.shift());
      }
      subscriber.complete();
    }));
  });
}
bufferToggle$1.bufferToggle = bufferToggle;
var bufferWhen$1 = {};
Object.defineProperty(bufferWhen$1, "__esModule", { value: true });
bufferWhen$1.bufferWhen = void 0;
var lift_1$U = lift;
var noop_1$9 = noop$2;
var OperatorSubscriber_1$F = OperatorSubscriber$1;
var innerFrom_1$m = innerFrom$1;
function bufferWhen(closingSelector) {
  return lift_1$U.operate(function(source, subscriber) {
    var buffer2 = null;
    var closingSubscriber = null;
    var openBuffer = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      var b = buffer2;
      buffer2 = [];
      b && subscriber.next(b);
      innerFrom_1$m.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1$F.createOperatorSubscriber(subscriber, openBuffer, noop_1$9.noop));
    };
    openBuffer();
    source.subscribe(OperatorSubscriber_1$F.createOperatorSubscriber(subscriber, function(value) {
      return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
    }, function() {
      buffer2 && subscriber.next(buffer2);
      subscriber.complete();
    }, void 0, function() {
      return buffer2 = closingSubscriber = null;
    }));
  });
}
bufferWhen$1.bufferWhen = bufferWhen;
var catchError$1 = {};
Object.defineProperty(catchError$1, "__esModule", { value: true });
catchError$1.catchError = void 0;
var innerFrom_1$l = innerFrom$1;
var OperatorSubscriber_1$E = OperatorSubscriber$1;
var lift_1$T = lift;
function catchError(selector) {
  return lift_1$T.operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(OperatorSubscriber_1$E.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom_1$l.innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
catchError$1.catchError = catchError;
var combineAll = {};
var combineLatestAll$1 = {};
var joinAllInternals$1 = {};
var toArray$2 = {};
var reduce$2 = {};
var scanInternals$1 = {};
Object.defineProperty(scanInternals$1, "__esModule", { value: true });
scanInternals$1.scanInternals = void 0;
var OperatorSubscriber_1$D = OperatorSubscriber$1;
function scanInternals(accumulator2, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(OperatorSubscriber_1$D.createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator2(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}
scanInternals$1.scanInternals = scanInternals;
Object.defineProperty(reduce$2, "__esModule", { value: true });
reduce$2.reduce = void 0;
var scanInternals_1$1 = scanInternals$1;
var lift_1$S = lift;
function reduce$1(accumulator2, seed) {
  return lift_1$S.operate(scanInternals_1$1.scanInternals(accumulator2, seed, arguments.length >= 2, false, true));
}
reduce$2.reduce = reduce$1;
Object.defineProperty(toArray$2, "__esModule", { value: true });
toArray$2.toArray = void 0;
var reduce_1$3 = reduce$2;
var lift_1$R = lift;
var arrReducer = function(arr2, value) {
  return arr2.push(value), arr2;
};
function toArray$1() {
  return lift_1$R.operate(function(source, subscriber) {
    reduce_1$3.reduce(arrReducer, [])(source).subscribe(subscriber);
  });
}
toArray$2.toArray = toArray$1;
Object.defineProperty(joinAllInternals$1, "__esModule", { value: true });
joinAllInternals$1.joinAllInternals = void 0;
var identity_1$a = identity$1;
var mapOneOrManyArgs_1$1 = mapOneOrManyArgs$1;
var pipe_1$1 = pipe$1;
var mergeMap_1$4 = mergeMap$1;
var toArray_1 = toArray$2;
function joinAllInternals(joinFn, project2) {
  return pipe_1$1.pipe(toArray_1.toArray(), mergeMap_1$4.mergeMap(function(sources) {
    return joinFn(sources);
  }), project2 ? mapOneOrManyArgs_1$1.mapOneOrManyArgs(project2) : identity_1$a.identity);
}
joinAllInternals$1.joinAllInternals = joinAllInternals;
Object.defineProperty(combineLatestAll$1, "__esModule", { value: true });
combineLatestAll$1.combineLatestAll = void 0;
var combineLatest_1$2 = combineLatest$3;
var joinAllInternals_1$1 = joinAllInternals$1;
function combineLatestAll(project2) {
  return joinAllInternals_1$1.joinAllInternals(combineLatest_1$2.combineLatest, project2);
}
combineLatestAll$1.combineLatestAll = combineLatestAll;
Object.defineProperty(combineAll, "__esModule", { value: true });
combineAll.combineAll = void 0;
var combineLatestAll_1 = combineLatestAll$1;
combineAll.combineAll = combineLatestAll_1.combineLatestAll;
var combineLatestWith$1 = {};
var combineLatest$1 = {};
var __read$d = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$d = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(combineLatest$1, "__esModule", { value: true });
combineLatest$1.combineLatest = void 0;
var combineLatest_1$1 = combineLatest$3;
var lift_1$Q = lift;
var argsOrArgArray_1$3 = argsOrArgArray$1;
var mapOneOrManyArgs_1 = mapOneOrManyArgs$1;
var pipe_1 = pipe$1;
var args_1$5 = args;
function combineLatest() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var resultSelector = args_1$5.popResultSelector(args2);
  return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray$d([], __read$d(args2))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1$Q.operate(function(source, subscriber) {
    combineLatest_1$1.combineLatestInit(__spreadArray$d([source], __read$d(argsOrArgArray_1$3.argsOrArgArray(args2))))(subscriber);
  });
}
combineLatest$1.combineLatest = combineLatest;
var __read$c = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$c = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(combineLatestWith$1, "__esModule", { value: true });
combineLatestWith$1.combineLatestWith = void 0;
var combineLatest_1 = combineLatest$1;
function combineLatestWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return combineLatest_1.combineLatest.apply(void 0, __spreadArray$c([], __read$c(otherSources)));
}
combineLatestWith$1.combineLatestWith = combineLatestWith;
var concatMap$1 = {};
Object.defineProperty(concatMap$1, "__esModule", { value: true });
concatMap$1.concatMap = void 0;
var mergeMap_1$3 = mergeMap$1;
var isFunction_1$8 = isFunction$1;
function concatMap(project2, resultSelector) {
  return isFunction_1$8.isFunction(resultSelector) ? mergeMap_1$3.mergeMap(project2, resultSelector, 1) : mergeMap_1$3.mergeMap(project2, 1);
}
concatMap$1.concatMap = concatMap;
var concatMapTo$1 = {};
Object.defineProperty(concatMapTo$1, "__esModule", { value: true });
concatMapTo$1.concatMapTo = void 0;
var concatMap_1 = concatMap$1;
var isFunction_1$7 = isFunction$1;
function concatMapTo(innerObservable, resultSelector) {
  return isFunction_1$7.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
    return innerObservable;
  }, resultSelector) : concatMap_1.concatMap(function() {
    return innerObservable;
  });
}
concatMapTo$1.concatMapTo = concatMapTo;
var concatWith$1 = {};
var concat$3 = {};
var __read$b = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$b = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(concat$3, "__esModule", { value: true });
concat$3.concat = void 0;
var lift_1$P = lift;
var concatAll_1 = concatAll$1;
var args_1$4 = args;
var from_1$1 = from$1;
function concat$2() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$4.popScheduler(args2);
  return lift_1$P.operate(function(source, subscriber) {
    concatAll_1.concatAll()(from_1$1.from(__spreadArray$b([source], __read$b(args2)), scheduler)).subscribe(subscriber);
  });
}
concat$3.concat = concat$2;
var __read$a = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$a = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(concatWith$1, "__esModule", { value: true });
concatWith$1.concatWith = void 0;
var concat_1$3 = concat$3;
function concatWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return concat_1$3.concat.apply(void 0, __spreadArray$a([], __read$a(otherSources)));
}
concatWith$1.concatWith = concatWith;
var connect$1 = {};
var fromSubscribable$1 = {};
Object.defineProperty(fromSubscribable$1, "__esModule", { value: true });
fromSubscribable$1.fromSubscribable = void 0;
var Observable_1$1 = Observable$2;
function fromSubscribable(subscribable) {
  return new Observable_1$1.Observable(function(subscriber) {
    return subscribable.subscribe(subscriber);
  });
}
fromSubscribable$1.fromSubscribable = fromSubscribable;
Object.defineProperty(connect$1, "__esModule", { value: true });
connect$1.connect = void 0;
var Subject_1$a = Subject$1;
var innerFrom_1$k = innerFrom$1;
var lift_1$O = lift;
var fromSubscribable_1 = fromSubscribable$1;
var DEFAULT_CONFIG = {
  connector: function() {
    return new Subject_1$a.Subject();
  }
};
function connect(selector, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG;
  }
  var connector = config2.connector;
  return lift_1$O.operate(function(source, subscriber) {
    var subject = connector();
    innerFrom_1$k.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
    subscriber.add(source.subscribe(subject));
  });
}
connect$1.connect = connect;
var count$3 = {};
Object.defineProperty(count$3, "__esModule", { value: true });
count$3.count = void 0;
var reduce_1$2 = reduce$2;
function count$2(predicate) {
  return reduce_1$2.reduce(function(total, value, i) {
    return !predicate || predicate(value, i) ? total + 1 : total;
  }, 0);
}
count$3.count = count$2;
var debounce$1 = {};
Object.defineProperty(debounce$1, "__esModule", { value: true });
debounce$1.debounce = void 0;
var lift_1$N = lift;
var noop_1$8 = noop$2;
var OperatorSubscriber_1$C = OperatorSubscriber$1;
var innerFrom_1$j = innerFrom$1;
function debounce(durationSelector) {
  return lift_1$N.operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var emit = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    source.subscribe(OperatorSubscriber_1$C.createOperatorSubscriber(subscriber, function(value) {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      hasValue = true;
      lastValue = value;
      durationSubscriber = OperatorSubscriber_1$C.createOperatorSubscriber(subscriber, emit, noop_1$8.noop);
      innerFrom_1$j.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = durationSubscriber = null;
    }));
  });
}
debounce$1.debounce = debounce;
var debounceTime$1 = {};
Object.defineProperty(debounceTime$1, "__esModule", { value: true });
debounceTime$1.debounceTime = void 0;
var async_1$6 = async;
var lift_1$M = lift;
var OperatorSubscriber_1$B = OperatorSubscriber$1;
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$6.asyncScheduler;
  }
  return lift_1$M.operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now2 = scheduler.now();
      if (now2 < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now2);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(OperatorSubscriber_1$B.createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}
debounceTime$1.debounceTime = debounceTime;
var defaultIfEmpty$1 = {};
Object.defineProperty(defaultIfEmpty$1, "__esModule", { value: true });
defaultIfEmpty$1.defaultIfEmpty = void 0;
var lift_1$L = lift;
var OperatorSubscriber_1$A = OperatorSubscriber$1;
function defaultIfEmpty(defaultValue) {
  return lift_1$L.operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(OperatorSubscriber_1$A.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
defaultIfEmpty$1.defaultIfEmpty = defaultIfEmpty;
var delay$1 = {};
var delayWhen$1 = {};
var take$1 = {};
Object.defineProperty(take$1, "__esModule", { value: true });
take$1.take = void 0;
var empty_1$2 = empty;
var lift_1$K = lift;
var OperatorSubscriber_1$z = OperatorSubscriber$1;
function take(count2) {
  return count2 <= 0 ? function() {
    return empty_1$2.EMPTY;
  } : lift_1$K.operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(OperatorSubscriber_1$z.createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
take$1.take = take;
var ignoreElements$1 = {};
Object.defineProperty(ignoreElements$1, "__esModule", { value: true });
ignoreElements$1.ignoreElements = void 0;
var lift_1$J = lift;
var OperatorSubscriber_1$y = OperatorSubscriber$1;
var noop_1$7 = noop$2;
function ignoreElements() {
  return lift_1$J.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$y.createOperatorSubscriber(subscriber, noop_1$7.noop));
  });
}
ignoreElements$1.ignoreElements = ignoreElements;
var mapTo$1 = {};
Object.defineProperty(mapTo$1, "__esModule", { value: true });
mapTo$1.mapTo = void 0;
var map_1$3 = map$2;
function mapTo(value) {
  return map_1$3.map(function() {
    return value;
  });
}
mapTo$1.mapTo = mapTo;
Object.defineProperty(delayWhen$1, "__esModule", { value: true });
delayWhen$1.delayWhen = void 0;
var concat_1$2 = concat$5;
var take_1$2 = take$1;
var ignoreElements_1 = ignoreElements$1;
var mapTo_1 = mapTo$1;
var mergeMap_1$2 = mergeMap$1;
var innerFrom_1$i = innerFrom$1;
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return concat_1$2.concat(subscriptionDelay.pipe(take_1$2.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap_1$2.mergeMap(function(value, index) {
    return innerFrom_1$i.innerFrom(delayDurationSelector(value, index)).pipe(take_1$2.take(1), mapTo_1.mapTo(value));
  });
}
delayWhen$1.delayWhen = delayWhen;
Object.defineProperty(delay$1, "__esModule", { value: true });
delay$1.delay = void 0;
var async_1$5 = async;
var delayWhen_1 = delayWhen$1;
var timer_1$3 = timer$1;
function delay(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$5.asyncScheduler;
  }
  var duration = timer_1$3.timer(due, scheduler);
  return delayWhen_1.delayWhen(function() {
    return duration;
  });
}
delay$1.delay = delay;
var dematerialize$1 = {};
Object.defineProperty(dematerialize$1, "__esModule", { value: true });
dematerialize$1.dematerialize = void 0;
var Notification_1$1 = Notification;
var lift_1$I = lift;
var OperatorSubscriber_1$x = OperatorSubscriber$1;
function dematerialize() {
  return lift_1$I.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$x.createOperatorSubscriber(subscriber, function(notification) {
      return Notification_1$1.observeNotification(notification, subscriber);
    }));
  });
}
dematerialize$1.dematerialize = dematerialize;
var distinct$1 = {};
Object.defineProperty(distinct$1, "__esModule", { value: true });
distinct$1.distinct = void 0;
var lift_1$H = lift;
var OperatorSubscriber_1$w = OperatorSubscriber$1;
var noop_1$6 = noop$2;
var innerFrom_1$h = innerFrom$1;
function distinct(keySelector, flushes) {
  return lift_1$H.operate(function(source, subscriber) {
    var distinctKeys = /* @__PURE__ */ new Set();
    source.subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(subscriber, function(value) {
      var key = keySelector ? keySelector(value) : value;
      if (!distinctKeys.has(key)) {
        distinctKeys.add(key);
        subscriber.next(value);
      }
    }));
    flushes && innerFrom_1$h.innerFrom(flushes).subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(subscriber, function() {
      return distinctKeys.clear();
    }, noop_1$6.noop));
  });
}
distinct$1.distinct = distinct;
var distinctUntilChanged$1 = {};
Object.defineProperty(distinctUntilChanged$1, "__esModule", { value: true });
distinctUntilChanged$1.distinctUntilChanged = void 0;
var identity_1$9 = identity$1;
var lift_1$G = lift;
var OperatorSubscriber_1$v = OperatorSubscriber$1;
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity_1$9.identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return lift_1$G.operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(OperatorSubscriber_1$v.createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
distinctUntilChanged$1.distinctUntilChanged = distinctUntilChanged;
function defaultCompare(a, b) {
  return a === b;
}
var distinctUntilKeyChanged$1 = {};
Object.defineProperty(distinctUntilKeyChanged$1, "__esModule", { value: true });
distinctUntilKeyChanged$1.distinctUntilKeyChanged = void 0;
var distinctUntilChanged_1 = distinctUntilChanged$1;
function distinctUntilKeyChanged(key, compare2) {
  return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
    return compare2 ? compare2(x[key], y[key]) : x[key] === y[key];
  });
}
distinctUntilKeyChanged$1.distinctUntilKeyChanged = distinctUntilKeyChanged;
var elementAt$1 = {};
var throwIfEmpty$1 = {};
Object.defineProperty(throwIfEmpty$1, "__esModule", { value: true });
throwIfEmpty$1.throwIfEmpty = void 0;
var EmptyError_1$3 = EmptyError;
var lift_1$F = lift;
var OperatorSubscriber_1$u = OperatorSubscriber$1;
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return lift_1$F.operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(OperatorSubscriber_1$u.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
throwIfEmpty$1.throwIfEmpty = throwIfEmpty;
function defaultErrorFactory() {
  return new EmptyError_1$3.EmptyError();
}
Object.defineProperty(elementAt$1, "__esModule", { value: true });
elementAt$1.elementAt = void 0;
var ArgumentOutOfRangeError_1 = ArgumentOutOfRangeError;
var filter_1$4 = filter$2;
var throwIfEmpty_1$2 = throwIfEmpty$1;
var defaultIfEmpty_1$2 = defaultIfEmpty$1;
var take_1$1 = take$1;
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter_1$4.filter(function(v, i) {
      return i === index;
    }), take_1$1.take(1), hasDefaultValue ? defaultIfEmpty_1$2.defaultIfEmpty(defaultValue) : throwIfEmpty_1$2.throwIfEmpty(function() {
      return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }));
  };
}
elementAt$1.elementAt = elementAt;
var endWith$1 = {};
var __read$9 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$9 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(endWith$1, "__esModule", { value: true });
endWith$1.endWith = void 0;
var concat_1$1 = concat$5;
var of_1 = of$1;
function endWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return function(source) {
    return concat_1$1.concat(source, of_1.of.apply(void 0, __spreadArray$9([], __read$9(values))));
  };
}
endWith$1.endWith = endWith;
var every$1 = {};
Object.defineProperty(every$1, "__esModule", { value: true });
every$1.every = void 0;
var lift_1$E = lift;
var OperatorSubscriber_1$t = OperatorSubscriber$1;
function every(predicate, thisArg) {
  return lift_1$E.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$t.createOperatorSubscriber(subscriber, function(value) {
      if (!predicate.call(thisArg, value, index++, source)) {
        subscriber.next(false);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}
every$1.every = every;
var exhaust = {};
var exhaustAll$1 = {};
var exhaustMap$1 = {};
Object.defineProperty(exhaustMap$1, "__esModule", { value: true });
exhaustMap$1.exhaustMap = void 0;
var map_1$2 = map$2;
var innerFrom_1$g = innerFrom$1;
var lift_1$D = lift;
var OperatorSubscriber_1$s = OperatorSubscriber$1;
function exhaustMap(project2, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a, i) {
        return innerFrom_1$g.innerFrom(project2(a, i)).pipe(map_1$2.map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }
  return lift_1$D.operate(function(source, subscriber) {
    var index = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(OperatorSubscriber_1$s.createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = OperatorSubscriber_1$s.createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom_1$g.innerFrom(project2(outerValue, index++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}
exhaustMap$1.exhaustMap = exhaustMap;
Object.defineProperty(exhaustAll$1, "__esModule", { value: true });
exhaustAll$1.exhaustAll = void 0;
var exhaustMap_1 = exhaustMap$1;
var identity_1$8 = identity$1;
function exhaustAll() {
  return exhaustMap_1.exhaustMap(identity_1$8.identity);
}
exhaustAll$1.exhaustAll = exhaustAll;
Object.defineProperty(exhaust, "__esModule", { value: true });
exhaust.exhaust = void 0;
var exhaustAll_1 = exhaustAll$1;
exhaust.exhaust = exhaustAll_1.exhaustAll;
var expand$1 = {};
Object.defineProperty(expand$1, "__esModule", { value: true });
expand$1.expand = void 0;
var lift_1$C = lift;
var mergeInternals_1$1 = mergeInternals$1;
function expand(project2, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
  return lift_1$C.operate(function(source, subscriber) {
    return mergeInternals_1$1.mergeInternals(source, subscriber, project2, concurrent, void 0, true, scheduler);
  });
}
expand$1.expand = expand;
var finalize$1 = {};
Object.defineProperty(finalize$1, "__esModule", { value: true });
finalize$1.finalize = void 0;
var lift_1$B = lift;
function finalize(callback) {
  return lift_1$B.operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}
finalize$1.finalize = finalize;
var find$1 = {};
Object.defineProperty(find$1, "__esModule", { value: true });
find$1.createFind = find$1.find = void 0;
var lift_1$A = lift;
var OperatorSubscriber_1$r = OperatorSubscriber$1;
function find(predicate, thisArg) {
  return lift_1$A.operate(createFind(predicate, thisArg, "value"));
}
find$1.find = find;
function createFind(predicate, thisArg, emit) {
  var findIndex2 = emit === "index";
  return function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$r.createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      if (predicate.call(thisArg, value, i, source)) {
        subscriber.next(findIndex2 ? i : value);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(findIndex2 ? -1 : void 0);
      subscriber.complete();
    }));
  };
}
find$1.createFind = createFind;
var findIndex$1 = {};
Object.defineProperty(findIndex$1, "__esModule", { value: true });
findIndex$1.findIndex = void 0;
var lift_1$z = lift;
var find_1 = find$1;
function findIndex(predicate, thisArg) {
  return lift_1$z.operate(find_1.createFind(predicate, thisArg, "index"));
}
findIndex$1.findIndex = findIndex;
var first$3 = {};
Object.defineProperty(first$3, "__esModule", { value: true });
first$3.first = void 0;
var EmptyError_1$2 = EmptyError;
var filter_1$3 = filter$2;
var take_1 = take$1;
var defaultIfEmpty_1$1 = defaultIfEmpty$1;
var throwIfEmpty_1$1 = throwIfEmpty$1;
var identity_1$7 = identity$1;
function first$2(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter_1$3.filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity_1$7.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1$1.defaultIfEmpty(defaultValue) : throwIfEmpty_1$1.throwIfEmpty(function() {
      return new EmptyError_1$2.EmptyError();
    }));
  };
}
first$3.first = first$2;
var groupBy$1 = {};
Object.defineProperty(groupBy$1, "__esModule", { value: true });
groupBy$1.groupBy = void 0;
var Observable_1 = Observable$2;
var innerFrom_1$f = innerFrom$1;
var Subject_1$9 = Subject$1;
var lift_1$y = lift;
var OperatorSubscriber_1$q = OperatorSubscriber$1;
function groupBy(keySelector, elementOrOptions, duration, connector) {
  return lift_1$y.operate(function(source, subscriber) {
    var element2;
    if (!elementOrOptions || typeof elementOrOptions === "function") {
      element2 = elementOrOptions;
    } else {
      duration = elementOrOptions.duration, element2 = elementOrOptions.element, connector = elementOrOptions.connector;
    }
    var groups = /* @__PURE__ */ new Map();
    var notify = function(cb) {
      groups.forEach(cb);
      cb(subscriber);
    };
    var handleError = function(err) {
      return notify(function(consumer) {
        return consumer.error(err);
      });
    };
    var activeGroups = 0;
    var teardownAttempted = false;
    var groupBySourceSubscriber = new OperatorSubscriber_1$q.OperatorSubscriber(subscriber, function(value) {
      try {
        var key_1 = keySelector(value);
        var group_12 = groups.get(key_1);
        if (!group_12) {
          groups.set(key_1, group_12 = connector ? connector() : new Subject_1$9.Subject());
          var grouped = createGroupedObservable(key_1, group_12);
          subscriber.next(grouped);
          if (duration) {
            var durationSubscriber_1 = OperatorSubscriber_1$q.createOperatorSubscriber(group_12, function() {
              group_12.complete();
              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
            }, void 0, void 0, function() {
              return groups.delete(key_1);
            });
            groupBySourceSubscriber.add(innerFrom_1$f.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
          }
        }
        group_12.next(element2 ? element2(value) : value);
      } catch (err) {
        handleError(err);
      }
    }, function() {
      return notify(function(consumer) {
        return consumer.complete();
      });
    }, handleError, function() {
      return groups.clear();
    }, function() {
      teardownAttempted = true;
      return activeGroups === 0;
    });
    source.subscribe(groupBySourceSubscriber);
    function createGroupedObservable(key, groupSubject) {
      var result = new Observable_1.Observable(function(groupSubscriber) {
        activeGroups++;
        var innerSub = groupSubject.subscribe(groupSubscriber);
        return function() {
          innerSub.unsubscribe();
          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
        };
      });
      result.key = key;
      return result;
    }
  });
}
groupBy$1.groupBy = groupBy;
var isEmpty$1 = {};
Object.defineProperty(isEmpty$1, "__esModule", { value: true });
isEmpty$1.isEmpty = void 0;
var lift_1$x = lift;
var OperatorSubscriber_1$p = OperatorSubscriber$1;
function isEmpty() {
  return lift_1$x.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$p.createOperatorSubscriber(subscriber, function() {
      subscriber.next(false);
      subscriber.complete();
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}
isEmpty$1.isEmpty = isEmpty;
var last$3 = {};
var takeLast$1 = {};
var __values$2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(takeLast$1, "__esModule", { value: true });
takeLast$1.takeLast = void 0;
var empty_1$1 = empty;
var lift_1$w = lift;
var OperatorSubscriber_1$o = OperatorSubscriber$1;
function takeLast(count2) {
  return count2 <= 0 ? function() {
    return empty_1$1.EMPTY;
  } : lift_1$w.operate(function(source, subscriber) {
    var buffer2 = [];
    source.subscribe(OperatorSubscriber_1$o.createOperatorSubscriber(subscriber, function(value) {
      buffer2.push(value);
      count2 < buffer2.length && buffer2.shift();
    }, function() {
      var e_1, _a;
      try {
        for (var buffer_1 = __values$2(buffer2), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
          var value = buffer_1_1.value;
          subscriber.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
            _a.call(buffer_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffer2 = null;
    }));
  });
}
takeLast$1.takeLast = takeLast;
Object.defineProperty(last$3, "__esModule", { value: true });
last$3.last = void 0;
var EmptyError_1$1 = EmptyError;
var filter_1$2 = filter$2;
var takeLast_1 = takeLast$1;
var throwIfEmpty_1 = throwIfEmpty$1;
var defaultIfEmpty_1 = defaultIfEmpty$1;
var identity_1$6 = identity$1;
function last$2(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter_1$2.filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity_1$6.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
      return new EmptyError_1$1.EmptyError();
    }));
  };
}
last$3.last = last$2;
var materialize$1 = {};
Object.defineProperty(materialize$1, "__esModule", { value: true });
materialize$1.materialize = void 0;
var Notification_1 = Notification;
var lift_1$v = lift;
var OperatorSubscriber_1$n = OperatorSubscriber$1;
function materialize() {
  return lift_1$v.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$n.createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(Notification_1.Notification.createNext(value));
    }, function() {
      subscriber.next(Notification_1.Notification.createComplete());
      subscriber.complete();
    }, function(err) {
      subscriber.next(Notification_1.Notification.createError(err));
      subscriber.complete();
    }));
  });
}
materialize$1.materialize = materialize;
var max$2 = {};
Object.defineProperty(max$2, "__esModule", { value: true });
max$2.max = void 0;
var reduce_1$1 = reduce$2;
var isFunction_1$6 = isFunction$1;
function max$1(comparer) {
  return reduce_1$1.reduce(isFunction_1$6.isFunction(comparer) ? function(x, y) {
    return comparer(x, y) > 0 ? x : y;
  } : function(x, y) {
    return x > y ? x : y;
  });
}
max$2.max = max$1;
var flatMap = {};
Object.defineProperty(flatMap, "__esModule", { value: true });
flatMap.flatMap = void 0;
var mergeMap_1$1 = mergeMap$1;
flatMap.flatMap = mergeMap_1$1.mergeMap;
var mergeMapTo$1 = {};
Object.defineProperty(mergeMapTo$1, "__esModule", { value: true });
mergeMapTo$1.mergeMapTo = void 0;
var mergeMap_1 = mergeMap$1;
var isFunction_1$5 = isFunction$1;
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction_1$5.isFunction(resultSelector)) {
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap_1.mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
mergeMapTo$1.mergeMapTo = mergeMapTo;
var mergeScan$1 = {};
Object.defineProperty(mergeScan$1, "__esModule", { value: true });
mergeScan$1.mergeScan = void 0;
var lift_1$u = lift;
var mergeInternals_1 = mergeInternals$1;
function mergeScan(accumulator2, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return lift_1$u.operate(function(source, subscriber) {
    var state = seed;
    return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
      return accumulator2(state, value, index);
    }, concurrent, function(value) {
      state = value;
    }, false, void 0, function() {
      return state = null;
    });
  });
}
mergeScan$1.mergeScan = mergeScan;
var mergeWith$1 = {};
var merge$3 = {};
var __read$8 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$8 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(merge$3, "__esModule", { value: true });
merge$3.merge = void 0;
var lift_1$t = lift;
var argsOrArgArray_1$2 = argsOrArgArray$1;
var mergeAll_1 = mergeAll$1;
var args_1$3 = args;
var from_1 = from$1;
function merge$2() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$3.popScheduler(args2);
  var concurrent = args_1$3.popNumber(args2, Infinity);
  args2 = argsOrArgArray_1$2.argsOrArgArray(args2);
  return lift_1$t.operate(function(source, subscriber) {
    mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray$8([source], __read$8(args2)), scheduler)).subscribe(subscriber);
  });
}
merge$3.merge = merge$2;
var __read$7 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$7 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(mergeWith$1, "__esModule", { value: true });
mergeWith$1.mergeWith = void 0;
var merge_1 = merge$3;
function mergeWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return merge_1.merge.apply(void 0, __spreadArray$7([], __read$7(otherSources)));
}
mergeWith$1.mergeWith = mergeWith;
var min$2 = {};
Object.defineProperty(min$2, "__esModule", { value: true });
min$2.min = void 0;
var reduce_1 = reduce$2;
var isFunction_1$4 = isFunction$1;
function min$1(comparer) {
  return reduce_1.reduce(isFunction_1$4.isFunction(comparer) ? function(x, y) {
    return comparer(x, y) < 0 ? x : y;
  } : function(x, y) {
    return x < y ? x : y;
  });
}
min$2.min = min$1;
var multicast$1 = {};
Object.defineProperty(multicast$1, "__esModule", { value: true });
multicast$1.multicast = void 0;
var ConnectableObservable_1$2 = ConnectableObservable$1;
var isFunction_1$3 = isFunction$1;
var connect_1$1 = connect$1;
function multicast(subjectOrSubjectFactory, selector) {
  var subjectFactory = isFunction_1$3.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
    return subjectOrSubjectFactory;
  };
  if (isFunction_1$3.isFunction(selector)) {
    return connect_1$1.connect(selector, {
      connector: subjectFactory
    });
  }
  return function(source) {
    return new ConnectableObservable_1$2.ConnectableObservable(source, subjectFactory);
  };
}
multicast$1.multicast = multicast;
var onErrorResumeNextWith$1 = {};
var __read$6 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$6 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(onErrorResumeNextWith$1, "__esModule", { value: true });
onErrorResumeNextWith$1.onErrorResumeNext = onErrorResumeNextWith$1.onErrorResumeNextWith = void 0;
var argsOrArgArray_1$1 = argsOrArgArray$1;
var onErrorResumeNext_1 = onErrorResumeNext$1;
function onErrorResumeNextWith() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var nextSources = argsOrArgArray_1$1.argsOrArgArray(sources);
  return function(source) {
    return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray$6([source], __read$6(nextSources)));
  };
}
onErrorResumeNextWith$1.onErrorResumeNextWith = onErrorResumeNextWith;
onErrorResumeNextWith$1.onErrorResumeNext = onErrorResumeNextWith;
var pairwise$1 = {};
Object.defineProperty(pairwise$1, "__esModule", { value: true });
pairwise$1.pairwise = void 0;
var lift_1$s = lift;
var OperatorSubscriber_1$m = OperatorSubscriber$1;
function pairwise() {
  return lift_1$s.operate(function(source, subscriber) {
    var prev;
    var hasPrev = false;
    source.subscribe(OperatorSubscriber_1$m.createOperatorSubscriber(subscriber, function(value) {
      var p = prev;
      prev = value;
      hasPrev && subscriber.next([p, value]);
      hasPrev = true;
    }));
  });
}
pairwise$1.pairwise = pairwise;
var pluck$1 = {};
Object.defineProperty(pluck$1, "__esModule", { value: true });
pluck$1.pluck = void 0;
var map_1$1 = map$2;
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return map_1$1.map(function(x) {
    var currentProp = x;
    for (var i = 0; i < length; i++) {
      var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
      if (typeof p !== "undefined") {
        currentProp = p;
      } else {
        return void 0;
      }
    }
    return currentProp;
  });
}
pluck$1.pluck = pluck;
var publish$1 = {};
Object.defineProperty(publish$1, "__esModule", { value: true });
publish$1.publish = void 0;
var Subject_1$8 = Subject$1;
var multicast_1$1 = multicast$1;
var connect_1 = connect$1;
function publish(selector) {
  return selector ? function(source) {
    return connect_1.connect(selector)(source);
  } : function(source) {
    return multicast_1$1.multicast(new Subject_1$8.Subject())(source);
  };
}
publish$1.publish = publish;
var publishBehavior$1 = {};
Object.defineProperty(publishBehavior$1, "__esModule", { value: true });
publishBehavior$1.publishBehavior = void 0;
var BehaviorSubject_1 = BehaviorSubject$1;
var ConnectableObservable_1$1 = ConnectableObservable$1;
function publishBehavior(initialValue) {
  return function(source) {
    var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
    return new ConnectableObservable_1$1.ConnectableObservable(source, function() {
      return subject;
    });
  };
}
publishBehavior$1.publishBehavior = publishBehavior;
var publishLast$1 = {};
Object.defineProperty(publishLast$1, "__esModule", { value: true });
publishLast$1.publishLast = void 0;
var AsyncSubject_1 = AsyncSubject$1;
var ConnectableObservable_1 = ConnectableObservable$1;
function publishLast() {
  return function(source) {
    var subject = new AsyncSubject_1.AsyncSubject();
    return new ConnectableObservable_1.ConnectableObservable(source, function() {
      return subject;
    });
  };
}
publishLast$1.publishLast = publishLast;
var publishReplay$1 = {};
Object.defineProperty(publishReplay$1, "__esModule", { value: true });
publishReplay$1.publishReplay = void 0;
var ReplaySubject_1$1 = ReplaySubject$1;
var multicast_1 = multicast$1;
var isFunction_1$2 = isFunction$1;
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
  if (selectorOrScheduler && !isFunction_1$2.isFunction(selectorOrScheduler)) {
    timestampProvider = selectorOrScheduler;
  }
  var selector = isFunction_1$2.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
  return function(source) {
    return multicast_1.multicast(new ReplaySubject_1$1.ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source);
  };
}
publishReplay$1.publishReplay = publishReplay;
var raceWith$1 = {};
var __read$5 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$5 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(raceWith$1, "__esModule", { value: true });
raceWith$1.raceWith = void 0;
var race_1 = race$3;
var lift_1$r = lift;
var identity_1$5 = identity$1;
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity_1$5.identity : lift_1$r.operate(function(source, subscriber) {
    race_1.raceInit(__spreadArray$5([source], __read$5(otherSources)))(subscriber);
  });
}
raceWith$1.raceWith = raceWith;
var repeat$1 = {};
Object.defineProperty(repeat$1, "__esModule", { value: true });
repeat$1.repeat = void 0;
var empty_1 = empty;
var lift_1$q = lift;
var OperatorSubscriber_1$l = OperatorSubscriber$1;
var innerFrom_1$e = innerFrom$1;
var timer_1$2 = timer$1;
function repeat(countOrConfig) {
  var _a;
  var count2 = Infinity;
  var delay2;
  if (countOrConfig != null) {
    if (typeof countOrConfig === "object") {
      _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
    } else {
      count2 = countOrConfig;
    }
  }
  return count2 <= 0 ? function() {
    return empty_1.EMPTY;
  } : lift_1$q.operate(function(source, subscriber) {
    var soFar = 0;
    var sourceSub;
    var resubscribe = function() {
      sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
      sourceSub = null;
      if (delay2 != null) {
        var notifier = typeof delay2 === "number" ? timer_1$2.timer(delay2) : innerFrom_1$e.innerFrom(delay2(soFar));
        var notifierSubscriber_1 = OperatorSubscriber_1$l.createOperatorSubscriber(subscriber, function() {
          notifierSubscriber_1.unsubscribe();
          subscribeToSource();
        });
        notifier.subscribe(notifierSubscriber_1);
      } else {
        subscribeToSource();
      }
    };
    var subscribeToSource = function() {
      var syncUnsub = false;
      sourceSub = source.subscribe(OperatorSubscriber_1$l.createOperatorSubscriber(subscriber, void 0, function() {
        if (++soFar < count2) {
          if (sourceSub) {
            resubscribe();
          } else {
            syncUnsub = true;
          }
        } else {
          subscriber.complete();
        }
      }));
      if (syncUnsub) {
        resubscribe();
      }
    };
    subscribeToSource();
  });
}
repeat$1.repeat = repeat;
var repeatWhen$1 = {};
Object.defineProperty(repeatWhen$1, "__esModule", { value: true });
repeatWhen$1.repeatWhen = void 0;
var innerFrom_1$d = innerFrom$1;
var Subject_1$7 = Subject$1;
var lift_1$p = lift;
var OperatorSubscriber_1$k = OperatorSubscriber$1;
function repeatWhen(notifier) {
  return lift_1$p.operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var completions$;
    var isNotifierComplete = false;
    var isMainComplete = false;
    var checkComplete = function() {
      return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
    };
    var getCompletionSubject = function() {
      if (!completions$) {
        completions$ = new Subject_1$7.Subject();
        innerFrom_1$d.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1$k.createOperatorSubscriber(subscriber, function() {
          if (innerSub) {
            subscribeForRepeatWhen();
          } else {
            syncResub = true;
          }
        }, function() {
          isNotifierComplete = true;
          checkComplete();
        }));
      }
      return completions$;
    };
    var subscribeForRepeatWhen = function() {
      isMainComplete = false;
      innerSub = source.subscribe(OperatorSubscriber_1$k.createOperatorSubscriber(subscriber, void 0, function() {
        isMainComplete = true;
        !checkComplete() && getCompletionSubject().next();
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRepeatWhen();
      }
    };
    subscribeForRepeatWhen();
  });
}
repeatWhen$1.repeatWhen = repeatWhen;
var retry$2 = {};
Object.defineProperty(retry$2, "__esModule", { value: true });
retry$2.retry = void 0;
var lift_1$o = lift;
var OperatorSubscriber_1$j = OperatorSubscriber$1;
var identity_1$4 = identity$1;
var timer_1$1 = timer$1;
var innerFrom_1$c = innerFrom$1;
function retry$1(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity_1$4.identity : lift_1$o.operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(OperatorSubscriber_1$j.createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer_1$1.timer(delay2) : innerFrom_1$c.innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1$j.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}
retry$2.retry = retry$1;
var retryWhen$1 = {};
Object.defineProperty(retryWhen$1, "__esModule", { value: true });
retryWhen$1.retryWhen = void 0;
var innerFrom_1$b = innerFrom$1;
var Subject_1$6 = Subject$1;
var lift_1$n = lift;
var OperatorSubscriber_1$i = OperatorSubscriber$1;
function retryWhen(notifier) {
  return lift_1$n.operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var errors$;
    var subscribeForRetryWhen = function() {
      innerSub = source.subscribe(OperatorSubscriber_1$i.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        if (!errors$) {
          errors$ = new Subject_1$6.Subject();
          innerFrom_1$b.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1$i.createOperatorSubscriber(subscriber, function() {
            return innerSub ? subscribeForRetryWhen() : syncResub = true;
          }));
        }
        if (errors$) {
          errors$.next(err);
        }
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRetryWhen();
      }
    };
    subscribeForRetryWhen();
  });
}
retryWhen$1.retryWhen = retryWhen;
var sample$2 = {};
Object.defineProperty(sample$2, "__esModule", { value: true });
sample$2.sample = void 0;
var innerFrom_1$a = innerFrom$1;
var lift_1$m = lift;
var noop_1$5 = noop$2;
var OperatorSubscriber_1$h = OperatorSubscriber$1;
function sample$1(notifier) {
  return lift_1$m.operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    source.subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
    }));
    innerFrom_1$a.innerFrom(notifier).subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(subscriber, function() {
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    }, noop_1$5.noop));
  });
}
sample$2.sample = sample$1;
var sampleTime$1 = {};
Object.defineProperty(sampleTime$1, "__esModule", { value: true });
sampleTime$1.sampleTime = void 0;
var async_1$4 = async;
var sample_1 = sample$2;
var interval_1 = interval$1;
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$4.asyncScheduler;
  }
  return sample_1.sample(interval_1.interval(period, scheduler));
}
sampleTime$1.sampleTime = sampleTime;
var scan$1 = {};
Object.defineProperty(scan$1, "__esModule", { value: true });
scan$1.scan = void 0;
var lift_1$l = lift;
var scanInternals_1 = scanInternals$1;
function scan(accumulator2, seed) {
  return lift_1$l.operate(scanInternals_1.scanInternals(accumulator2, seed, arguments.length >= 2, true));
}
scan$1.scan = scan;
var sequenceEqual$1 = {};
Object.defineProperty(sequenceEqual$1, "__esModule", { value: true });
sequenceEqual$1.sequenceEqual = void 0;
var lift_1$k = lift;
var OperatorSubscriber_1$g = OperatorSubscriber$1;
var innerFrom_1$9 = innerFrom$1;
function sequenceEqual(compareTo, comparator) {
  if (comparator === void 0) {
    comparator = function(a, b) {
      return a === b;
    };
  }
  return lift_1$k.operate(function(source, subscriber) {
    var aState = createState();
    var bState = createState();
    var emit = function(isEqual2) {
      subscriber.next(isEqual2);
      subscriber.complete();
    };
    var createSubscriber = function(selfState, otherState) {
      var sequenceEqualSubscriber = OperatorSubscriber_1$g.createOperatorSubscriber(subscriber, function(a) {
        var buffer2 = otherState.buffer, complete = otherState.complete;
        if (buffer2.length === 0) {
          complete ? emit(false) : selfState.buffer.push(a);
        } else {
          !comparator(a, buffer2.shift()) && emit(false);
        }
      }, function() {
        selfState.complete = true;
        var complete = otherState.complete, buffer2 = otherState.buffer;
        complete && emit(buffer2.length === 0);
        sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
      });
      return sequenceEqualSubscriber;
    };
    source.subscribe(createSubscriber(aState, bState));
    innerFrom_1$9.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
  });
}
sequenceEqual$1.sequenceEqual = sequenceEqual;
function createState() {
  return {
    buffer: [],
    complete: false
  };
}
var share$1 = {};
var __read$4 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$4 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(share$1, "__esModule", { value: true });
share$1.share = void 0;
var innerFrom_1$8 = innerFrom$1;
var Subject_1$5 = Subject$1;
var Subscriber_1 = Subscriber;
var lift_1$j = lift;
function share(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _a = options2.connector, connector = _a === void 0 ? function() {
    return new Subject_1$5.Subject();
  } : _a, _b = options2.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options2.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options2.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return lift_1$j.operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom_1$8.innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
share$1.share = share;
function handleReset(reset, on) {
  var args2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args2[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new Subscriber_1.SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom_1$8.innerFrom(on.apply(void 0, __spreadArray$4([], __read$4(args2)))).subscribe(onSubscriber);
}
var shareReplay$1 = {};
Object.defineProperty(shareReplay$1, "__esModule", { value: true });
shareReplay$1.shareReplay = void 0;
var ReplaySubject_1 = ReplaySubject$1;
var share_1 = share$1;
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share_1.share({
    connector: function() {
      return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}
shareReplay$1.shareReplay = shareReplay;
var single$1 = {};
Object.defineProperty(single$1, "__esModule", { value: true });
single$1.single = void 0;
var EmptyError_1 = EmptyError;
var SequenceError_1 = SequenceError;
var NotFoundError_1 = NotFoundError$1;
var lift_1$i = lift;
var OperatorSubscriber_1$f = OperatorSubscriber$1;
function single(predicate) {
  return lift_1$i.operate(function(source, subscriber) {
    var hasValue = false;
    var singleValue;
    var seenValue = false;
    var index = 0;
    source.subscribe(OperatorSubscriber_1$f.createOperatorSubscriber(subscriber, function(value) {
      seenValue = true;
      if (!predicate || predicate(value, index++, source)) {
        hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
        hasValue = true;
        singleValue = value;
      }
    }, function() {
      if (hasValue) {
        subscriber.next(singleValue);
        subscriber.complete();
      } else {
        subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
      }
    }));
  });
}
single$1.single = single;
var skip$2 = {};
Object.defineProperty(skip$2, "__esModule", { value: true });
skip$2.skip = void 0;
var filter_1$1 = filter$2;
function skip$1(count2) {
  return filter_1$1.filter(function(_, index) {
    return count2 <= index;
  });
}
skip$2.skip = skip$1;
var skipLast$1 = {};
Object.defineProperty(skipLast$1, "__esModule", { value: true });
skipLast$1.skipLast = void 0;
var identity_1$3 = identity$1;
var lift_1$h = lift;
var OperatorSubscriber_1$e = OperatorSubscriber$1;
function skipLast(skipCount) {
  return skipCount <= 0 ? identity_1$3.identity : lift_1$h.operate(function(source, subscriber) {
    var ring = new Array(skipCount);
    var seen = 0;
    source.subscribe(OperatorSubscriber_1$e.createOperatorSubscriber(subscriber, function(value) {
      var valueIndex = seen++;
      if (valueIndex < skipCount) {
        ring[valueIndex] = value;
      } else {
        var index = valueIndex % skipCount;
        var oldValue = ring[index];
        ring[index] = value;
        subscriber.next(oldValue);
      }
    }));
    return function() {
      ring = null;
    };
  });
}
skipLast$1.skipLast = skipLast;
var skipUntil$1 = {};
Object.defineProperty(skipUntil$1, "__esModule", { value: true });
skipUntil$1.skipUntil = void 0;
var lift_1$g = lift;
var OperatorSubscriber_1$d = OperatorSubscriber$1;
var innerFrom_1$7 = innerFrom$1;
var noop_1$4 = noop$2;
function skipUntil(notifier) {
  return lift_1$g.operate(function(source, subscriber) {
    var taking = false;
    var skipSubscriber = OperatorSubscriber_1$d.createOperatorSubscriber(subscriber, function() {
      skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
      taking = true;
    }, noop_1$4.noop);
    innerFrom_1$7.innerFrom(notifier).subscribe(skipSubscriber);
    source.subscribe(OperatorSubscriber_1$d.createOperatorSubscriber(subscriber, function(value) {
      return taking && subscriber.next(value);
    }));
  });
}
skipUntil$1.skipUntil = skipUntil;
var skipWhile$1 = {};
Object.defineProperty(skipWhile$1, "__esModule", { value: true });
skipWhile$1.skipWhile = void 0;
var lift_1$f = lift;
var OperatorSubscriber_1$c = OperatorSubscriber$1;
function skipWhile(predicate) {
  return lift_1$f.operate(function(source, subscriber) {
    var taking = false;
    var index = 0;
    source.subscribe(OperatorSubscriber_1$c.createOperatorSubscriber(subscriber, function(value) {
      return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
    }));
  });
}
skipWhile$1.skipWhile = skipWhile;
var startWith$1 = {};
Object.defineProperty(startWith$1, "__esModule", { value: true });
startWith$1.startWith = void 0;
var concat_1 = concat$5;
var args_1$2 = args;
var lift_1$e = lift;
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = args_1$2.popScheduler(values);
  return lift_1$e.operate(function(source, subscriber) {
    (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
  });
}
startWith$1.startWith = startWith;
var switchAll$1 = {};
var switchMap$1 = {};
Object.defineProperty(switchMap$1, "__esModule", { value: true });
switchMap$1.switchMap = void 0;
var innerFrom_1$6 = innerFrom$1;
var lift_1$d = lift;
var OperatorSubscriber_1$b = OperatorSubscriber$1;
function switchMap(project2, resultSelector) {
  return lift_1$d.operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(OperatorSubscriber_1$b.createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom_1$6.innerFrom(project2(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1$b.createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
switchMap$1.switchMap = switchMap;
Object.defineProperty(switchAll$1, "__esModule", { value: true });
switchAll$1.switchAll = void 0;
var switchMap_1$2 = switchMap$1;
var identity_1$2 = identity$1;
function switchAll() {
  return switchMap_1$2.switchMap(identity_1$2.identity);
}
switchAll$1.switchAll = switchAll;
var switchMapTo$1 = {};
Object.defineProperty(switchMapTo$1, "__esModule", { value: true });
switchMapTo$1.switchMapTo = void 0;
var switchMap_1$1 = switchMap$1;
var isFunction_1$1 = isFunction$1;
function switchMapTo(innerObservable, resultSelector) {
  return isFunction_1$1.isFunction(resultSelector) ? switchMap_1$1.switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap_1$1.switchMap(function() {
    return innerObservable;
  });
}
switchMapTo$1.switchMapTo = switchMapTo;
var switchScan$1 = {};
Object.defineProperty(switchScan$1, "__esModule", { value: true });
switchScan$1.switchScan = void 0;
var switchMap_1 = switchMap$1;
var lift_1$c = lift;
function switchScan(accumulator2, seed) {
  return lift_1$c.operate(function(source, subscriber) {
    var state = seed;
    switchMap_1.switchMap(function(value, index) {
      return accumulator2(state, value, index);
    }, function(_, innerValue) {
      return state = innerValue, innerValue;
    })(source).subscribe(subscriber);
    return function() {
      state = null;
    };
  });
}
switchScan$1.switchScan = switchScan;
var takeUntil$1 = {};
Object.defineProperty(takeUntil$1, "__esModule", { value: true });
takeUntil$1.takeUntil = void 0;
var lift_1$b = lift;
var OperatorSubscriber_1$a = OperatorSubscriber$1;
var innerFrom_1$5 = innerFrom$1;
var noop_1$3 = noop$2;
function takeUntil(notifier) {
  return lift_1$b.operate(function(source, subscriber) {
    innerFrom_1$5.innerFrom(notifier).subscribe(OperatorSubscriber_1$a.createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop_1$3.noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
takeUntil$1.takeUntil = takeUntil;
var takeWhile$1 = {};
Object.defineProperty(takeWhile$1, "__esModule", { value: true });
takeWhile$1.takeWhile = void 0;
var lift_1$a = lift;
var OperatorSubscriber_1$9 = OperatorSubscriber$1;
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return lift_1$a.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$9.createOperatorSubscriber(subscriber, function(value) {
      var result = predicate(value, index++);
      (result || inclusive) && subscriber.next(value);
      !result && subscriber.complete();
    }));
  });
}
takeWhile$1.takeWhile = takeWhile;
var tap$1 = {};
Object.defineProperty(tap$1, "__esModule", { value: true });
tap$1.tap = void 0;
var isFunction_1 = isFunction$1;
var lift_1$9 = lift;
var OperatorSubscriber_1$8 = OperatorSubscriber$1;
var identity_1$1 = identity$1;
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? lift_1$9.operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(OperatorSubscriber_1$8.createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity_1$1.identity;
}
tap$1.tap = tap;
var throttle$1 = {};
Object.defineProperty(throttle$1, "__esModule", { value: true });
throttle$1.throttle = void 0;
var lift_1$8 = lift;
var OperatorSubscriber_1$7 = OperatorSubscriber$1;
var innerFrom_1$4 = innerFrom$1;
function throttle(durationSelector, config2) {
  return lift_1$8.operate(function(source, subscriber) {
    var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    var cleanupThrottling = function() {
      throttled = null;
      isComplete && subscriber.complete();
    };
    var startThrottle = function(value) {
      return throttled = innerFrom_1$4.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    };
    var send = function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}
throttle$1.throttle = throttle;
var throttleTime$1 = {};
Object.defineProperty(throttleTime$1, "__esModule", { value: true });
throttleTime$1.throttleTime = void 0;
var async_1$3 = async;
var throttle_1 = throttle$1;
var timer_1 = timer$1;
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async_1$3.asyncScheduler;
  }
  var duration$ = timer_1.timer(duration, scheduler);
  return throttle_1.throttle(function() {
    return duration$;
  }, config2);
}
throttleTime$1.throttleTime = throttleTime;
var timeInterval$1 = {};
Object.defineProperty(timeInterval$1, "__esModule", { value: true });
timeInterval$1.TimeInterval = timeInterval$1.timeInterval = void 0;
var async_1$2 = async;
var lift_1$7 = lift;
var OperatorSubscriber_1$6 = OperatorSubscriber$1;
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$2.asyncScheduler;
  }
  return lift_1$7.operate(function(source, subscriber) {
    var last2 = scheduler.now();
    source.subscribe(OperatorSubscriber_1$6.createOperatorSubscriber(subscriber, function(value) {
      var now2 = scheduler.now();
      var interval2 = now2 - last2;
      last2 = now2;
      subscriber.next(new TimeInterval(value, interval2));
    }));
  });
}
timeInterval$1.timeInterval = timeInterval;
var TimeInterval = function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();
timeInterval$1.TimeInterval = TimeInterval;
var timeoutWith$1 = {};
Object.defineProperty(timeoutWith$1, "__esModule", { value: true });
timeoutWith$1.timeoutWith = void 0;
var async_1$1 = async;
var isDate_1 = isDate;
var timeout_1 = timeout;
function timeoutWith(due, withObservable, scheduler) {
  var first2;
  var each;
  var _with;
  scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1$1.async;
  if (isDate_1.isValidDate(due)) {
    first2 = due;
  } else if (typeof due === "number") {
    each = due;
  }
  if (withObservable) {
    _with = function() {
      return withObservable;
    };
  } else {
    throw new TypeError("No observable provided to switch to");
  }
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return timeout_1.timeout({
    first: first2,
    each,
    scheduler,
    with: _with
  });
}
timeoutWith$1.timeoutWith = timeoutWith;
var timestamp$1 = {};
Object.defineProperty(timestamp$1, "__esModule", { value: true });
timestamp$1.timestamp = void 0;
var dateTimestampProvider_1 = dateTimestampProvider;
var map_1 = map$2;
function timestamp(timestampProvider) {
  if (timestampProvider === void 0) {
    timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
  }
  return map_1.map(function(value) {
    return { value, timestamp: timestampProvider.now() };
  });
}
timestamp$1.timestamp = timestamp;
var window$2 = {};
Object.defineProperty(window$2, "__esModule", { value: true });
window$2.window = void 0;
var Subject_1$4 = Subject$1;
var lift_1$6 = lift;
var OperatorSubscriber_1$5 = OperatorSubscriber$1;
var noop_1$2 = noop$2;
var innerFrom_1$3 = innerFrom$1;
function window$1(windowBoundaries) {
  return lift_1$6.operate(function(source, subscriber) {
    var windowSubject = new Subject_1$4.Subject();
    subscriber.next(windowSubject.asObservable());
    var errorHandler = function(err) {
      windowSubject.error(err);
      subscriber.error(err);
    };
    source.subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function(value) {
      return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
    }, function() {
      windowSubject.complete();
      subscriber.complete();
    }, errorHandler));
    innerFrom_1$3.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function() {
      windowSubject.complete();
      subscriber.next(windowSubject = new Subject_1$4.Subject());
    }, noop_1$2.noop, errorHandler));
    return function() {
      windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
      windowSubject = null;
    };
  });
}
window$2.window = window$1;
var windowCount$1 = {};
var __values$1 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(windowCount$1, "__esModule", { value: true });
windowCount$1.windowCount = void 0;
var Subject_1$3 = Subject$1;
var lift_1$5 = lift;
var OperatorSubscriber_1$4 = OperatorSubscriber$1;
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
  return lift_1$5.operate(function(source, subscriber) {
    var windows = [new Subject_1$3.Subject()];
    var count2 = 0;
    subscriber.next(windows[0].asObservable());
    source.subscribe(OperatorSubscriber_1$4.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var windows_1 = __values$1(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
          var window_1 = windows_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
            _a.call(windows_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var c = count2 - windowSize + 1;
      if (c >= 0 && c % startEvery === 0) {
        windows.shift().complete();
      }
      if (++count2 % startEvery === 0) {
        var window_2 = new Subject_1$3.Subject();
        windows.push(window_2);
        subscriber.next(window_2.asObservable());
      }
    }, function() {
      while (windows.length > 0) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, function(err) {
      while (windows.length > 0) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    }, function() {
      windows = null;
    }));
  });
}
windowCount$1.windowCount = windowCount;
var windowTime$1 = {};
Object.defineProperty(windowTime$1, "__esModule", { value: true });
windowTime$1.windowTime = void 0;
var Subject_1$2 = Subject$1;
var async_1 = async;
var Subscription_1$1 = Subscription$1;
var lift_1$4 = lift;
var OperatorSubscriber_1$3 = OperatorSubscriber$1;
var arrRemove_1$1 = arrRemove$1;
var args_1$1 = args;
var executeSchedule_1 = executeSchedule$1;
function windowTime(windowTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler = (_a = args_1$1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
  var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxWindowSize = otherArgs[1] || Infinity;
  return lift_1$4.operate(function(source, subscriber) {
    var windowRecords = [];
    var restartOnClose = false;
    var closeWindow = function(record) {
      var window2 = record.window, subs = record.subs;
      window2.complete();
      subs.unsubscribe();
      arrRemove_1$1.arrRemove(windowRecords, record);
      restartOnClose && startWindow();
    };
    var startWindow = function() {
      if (windowRecords) {
        var subs = new Subscription_1$1.Subscription();
        subscriber.add(subs);
        var window_1 = new Subject_1$2.Subject();
        var record_1 = {
          window: window_1,
          subs,
          seen: 0
        };
        windowRecords.push(record_1);
        subscriber.next(window_1.asObservable());
        executeSchedule_1.executeSchedule(subs, scheduler, function() {
          return closeWindow(record_1);
        }, windowTimeSpan);
      }
    };
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
    } else {
      restartOnClose = true;
    }
    startWindow();
    var loop = function(cb) {
      return windowRecords.slice().forEach(cb);
    };
    var terminate = function(cb) {
      loop(function(_a2) {
        var window2 = _a2.window;
        return cb(window2);
      });
      cb(subscriber);
      subscriber.unsubscribe();
    };
    source.subscribe(OperatorSubscriber_1$3.createOperatorSubscriber(subscriber, function(value) {
      loop(function(record) {
        record.window.next(value);
        maxWindowSize <= ++record.seen && closeWindow(record);
      });
    }, function() {
      return terminate(function(consumer) {
        return consumer.complete();
      });
    }, function(err) {
      return terminate(function(consumer) {
        return consumer.error(err);
      });
    }));
    return function() {
      windowRecords = null;
    };
  });
}
windowTime$1.windowTime = windowTime;
var windowToggle$1 = {};
var __values = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(windowToggle$1, "__esModule", { value: true });
windowToggle$1.windowToggle = void 0;
var Subject_1$1 = Subject$1;
var Subscription_1 = Subscription$1;
var lift_1$3 = lift;
var innerFrom_1$2 = innerFrom$1;
var OperatorSubscriber_1$2 = OperatorSubscriber$1;
var noop_1$1 = noop$2;
var arrRemove_1 = arrRemove$1;
function windowToggle(openings, closingSelector) {
  return lift_1$3.operate(function(source, subscriber) {
    var windows = [];
    var handleError = function(err) {
      while (0 < windows.length) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    };
    innerFrom_1$2.innerFrom(openings).subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function(openValue) {
      var window2 = new Subject_1$1.Subject();
      windows.push(window2);
      var closingSubscription = new Subscription_1.Subscription();
      var closeWindow = function() {
        arrRemove_1.arrRemove(windows, window2);
        window2.complete();
        closingSubscription.unsubscribe();
      };
      var closingNotifier;
      try {
        closingNotifier = innerFrom_1$2.innerFrom(closingSelector(openValue));
      } catch (err) {
        handleError(err);
        return;
      }
      subscriber.next(window2.asObservable());
      closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, closeWindow, noop_1$1.noop, handleError)));
    }, noop_1$1.noop));
    source.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      var windowsCopy = windows.slice();
      try {
        for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
          var window_1 = windowsCopy_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
            _a.call(windowsCopy_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (0 < windows.length) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, handleError, function() {
      while (0 < windows.length) {
        windows.shift().unsubscribe();
      }
    }));
  });
}
windowToggle$1.windowToggle = windowToggle;
var windowWhen$1 = {};
Object.defineProperty(windowWhen$1, "__esModule", { value: true });
windowWhen$1.windowWhen = void 0;
var Subject_1 = Subject$1;
var lift_1$2 = lift;
var OperatorSubscriber_1$1 = OperatorSubscriber$1;
var innerFrom_1$1 = innerFrom$1;
function windowWhen(closingSelector) {
  return lift_1$2.operate(function(source, subscriber) {
    var window2;
    var closingSubscriber;
    var handleError = function(err) {
      window2.error(err);
      subscriber.error(err);
    };
    var openWindow = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window2 === null || window2 === void 0 ? void 0 : window2.complete();
      window2 = new Subject_1.Subject();
      subscriber.next(window2.asObservable());
      var closingNotifier;
      try {
        closingNotifier = innerFrom_1$1.innerFrom(closingSelector());
      } catch (err) {
        handleError(err);
        return;
      }
      closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
    };
    openWindow();
    source.subscribe(OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, function(value) {
      return window2.next(value);
    }, function() {
      window2.complete();
      subscriber.complete();
    }, handleError, function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window2 = null;
    }));
  });
}
windowWhen$1.windowWhen = windowWhen;
var withLatestFrom$1 = {};
var __read$3 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$3 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(withLatestFrom$1, "__esModule", { value: true });
withLatestFrom$1.withLatestFrom = void 0;
var lift_1$1 = lift;
var OperatorSubscriber_1 = OperatorSubscriber$1;
var innerFrom_1 = innerFrom$1;
var identity_1 = identity$1;
var noop_1 = noop$2;
var args_1 = args;
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project2 = args_1.popResultSelector(inputs);
  return lift_1$1.operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i2) {
      innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        otherValues[i2] = value;
        if (!ready && !hasValue[i2]) {
          hasValue[i2] = true;
          (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
        }
      }, noop_1.noop));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray$3([value], __read$3(otherValues));
        subscriber.next(project2 ? project2.apply(void 0, __spreadArray$3([], __read$3(values))) : values);
      }
    }));
  });
}
withLatestFrom$1.withLatestFrom = withLatestFrom;
var zipAll$1 = {};
Object.defineProperty(zipAll$1, "__esModule", { value: true });
zipAll$1.zipAll = void 0;
var zip_1$2 = zip$4;
var joinAllInternals_1 = joinAllInternals$1;
function zipAll(project2) {
  return joinAllInternals_1.joinAllInternals(zip_1$2.zip, project2);
}
zipAll$1.zipAll = zipAll;
var zipWith$1 = {};
var zip$2 = {};
var __read$2 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(zip$2, "__esModule", { value: true });
zip$2.zip = void 0;
var zip_1$1 = zip$4;
var lift_1 = lift;
function zip$1() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return lift_1.operate(function(source, subscriber) {
    zip_1$1.zip.apply(void 0, __spreadArray$2([source], __read$2(sources))).subscribe(subscriber);
  });
}
zip$2.zip = zip$1;
var __read$1 = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$1 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(zipWith$1, "__esModule", { value: true });
zipWith$1.zipWith = void 0;
var zip_1 = zip$2;
function zipWith() {
  var otherInputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherInputs[_i] = arguments[_i];
  }
  return zip_1.zip.apply(void 0, __spreadArray$1([], __read$1(otherInputs)));
}
zipWith$1.zipWith = zipWith;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
  exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
  exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
  exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
  var Observable_12 = Observable$2;
  Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
    return Observable_12.Observable;
  } });
  var ConnectableObservable_12 = ConnectableObservable$1;
  Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
    return ConnectableObservable_12.ConnectableObservable;
  } });
  var observable_12 = observable;
  Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
    return observable_12.observable;
  } });
  var animationFrames_1 = animationFrames$1;
  Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
    return animationFrames_1.animationFrames;
  } });
  var Subject_12 = Subject$1;
  Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
    return Subject_12.Subject;
  } });
  var BehaviorSubject_12 = BehaviorSubject$1;
  Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
    return BehaviorSubject_12.BehaviorSubject;
  } });
  var ReplaySubject_12 = ReplaySubject$1;
  Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
    return ReplaySubject_12.ReplaySubject;
  } });
  var AsyncSubject_12 = AsyncSubject$1;
  Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
    return AsyncSubject_12.AsyncSubject;
  } });
  var asap_1 = asap$2;
  Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
    return asap_1.asap;
  } });
  Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
    return asap_1.asapScheduler;
  } });
  var async_12 = async;
  Object.defineProperty(exports, "async", { enumerable: true, get: function() {
    return async_12.async;
  } });
  Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
    return async_12.asyncScheduler;
  } });
  var queue_1 = queue$1;
  Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
    return queue_1.queue;
  } });
  Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
    return queue_1.queueScheduler;
  } });
  var animationFrame_1 = animationFrame;
  Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
    return animationFrame_1.animationFrame;
  } });
  Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
    return animationFrame_1.animationFrameScheduler;
  } });
  var VirtualTimeScheduler_1 = VirtualTimeScheduler$1;
  Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualTimeScheduler;
  } });
  Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualAction;
  } });
  var Scheduler_12 = Scheduler$1;
  Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
    return Scheduler_12.Scheduler;
  } });
  var Subscription_12 = Subscription$1;
  Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
    return Subscription_12.Subscription;
  } });
  var Subscriber_12 = Subscriber;
  Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
    return Subscriber_12.Subscriber;
  } });
  var Notification_12 = Notification;
  Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
    return Notification_12.Notification;
  } });
  Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
    return Notification_12.NotificationKind;
  } });
  var pipe_12 = pipe$1;
  Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
    return pipe_12.pipe;
  } });
  var noop_12 = noop$2;
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return noop_12.noop;
  } });
  var identity_12 = identity$1;
  Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
    return identity_12.identity;
  } });
  var isObservable_1 = isObservable$1;
  Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
    return isObservable_1.isObservable;
  } });
  var lastValueFrom_1 = lastValueFrom$1;
  Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
    return lastValueFrom_1.lastValueFrom;
  } });
  var firstValueFrom_1 = firstValueFrom$1;
  Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
    return firstValueFrom_1.firstValueFrom;
  } });
  var ArgumentOutOfRangeError_12 = ArgumentOutOfRangeError;
  Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
    return ArgumentOutOfRangeError_12.ArgumentOutOfRangeError;
  } });
  var EmptyError_12 = EmptyError;
  Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
    return EmptyError_12.EmptyError;
  } });
  var NotFoundError_12 = NotFoundError$1;
  Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
    return NotFoundError_12.NotFoundError;
  } });
  var ObjectUnsubscribedError_12 = ObjectUnsubscribedError;
  Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
    return ObjectUnsubscribedError_12.ObjectUnsubscribedError;
  } });
  var SequenceError_12 = SequenceError;
  Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
    return SequenceError_12.SequenceError;
  } });
  var timeout_12 = timeout;
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_12.TimeoutError;
  } });
  var UnsubscriptionError_12 = UnsubscriptionError;
  Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
    return UnsubscriptionError_12.UnsubscriptionError;
  } });
  var bindCallback_1 = bindCallback$1;
  Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
    return bindCallback_1.bindCallback;
  } });
  var bindNodeCallback_1 = bindNodeCallback$1;
  Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
    return bindNodeCallback_1.bindNodeCallback;
  } });
  var combineLatest_12 = combineLatest$3;
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_12.combineLatest;
  } });
  var concat_12 = concat$5;
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_12.concat;
  } });
  var connectable_1 = connectable$1;
  Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
    return connectable_1.connectable;
  } });
  var defer_12 = defer$1;
  Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
    return defer_12.defer;
  } });
  var empty_12 = empty;
  Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
    return empty_12.empty;
  } });
  var forkJoin_1 = forkJoin$1;
  Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
    return forkJoin_1.forkJoin;
  } });
  var from_12 = from$1;
  Object.defineProperty(exports, "from", { enumerable: true, get: function() {
    return from_12.from;
  } });
  var fromEvent_1 = fromEvent$1;
  Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
    return fromEvent_1.fromEvent;
  } });
  var fromEventPattern_1 = fromEventPattern$1;
  Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
    return fromEventPattern_1.fromEventPattern;
  } });
  var generate_1 = generate$1;
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return generate_1.generate;
  } });
  var iif_1 = iif$1;
  Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
    return iif_1.iif;
  } });
  var interval_12 = interval$1;
  Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
    return interval_12.interval;
  } });
  var merge_12 = merge$5;
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_12.merge;
  } });
  var never_1 = never;
  Object.defineProperty(exports, "never", { enumerable: true, get: function() {
    return never_1.never;
  } });
  var of_12 = of$1;
  Object.defineProperty(exports, "of", { enumerable: true, get: function() {
    return of_12.of;
  } });
  var onErrorResumeNext_12 = onErrorResumeNext$1;
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNext_12.onErrorResumeNext;
  } });
  var pairs_1 = pairs$1;
  Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
    return pairs_1.pairs;
  } });
  var partition_1 = partition$3;
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var race_12 = race$3;
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_12.race;
  } });
  var range_1 = range$2;
  Object.defineProperty(exports, "range", { enumerable: true, get: function() {
    return range_1.range;
  } });
  var throwError_1 = throwError$1;
  Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
    return throwError_1.throwError;
  } });
  var timer_12 = timer$1;
  Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
    return timer_12.timer;
  } });
  var using_1 = using$1;
  Object.defineProperty(exports, "using", { enumerable: true, get: function() {
    return using_1.using;
  } });
  var zip_12 = zip$4;
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_12.zip;
  } });
  var scheduled_12 = scheduled$1;
  Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
    return scheduled_12.scheduled;
  } });
  var empty_2 = empty;
  Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
    return empty_2.EMPTY;
  } });
  var never_2 = never;
  Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
    return never_2.NEVER;
  } });
  __exportStar(types, exports);
  var config_12 = config;
  Object.defineProperty(exports, "config", { enumerable: true, get: function() {
    return config_12.config;
  } });
  var audit_12 = audit$1;
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_12.audit;
  } });
  var auditTime_1 = auditTime$1;
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = buffer$1;
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = bufferCount$1;
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = bufferTime$1;
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = bufferToggle$1;
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = bufferWhen$1;
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = catchError$1;
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = combineAll;
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_12 = combineLatestAll$1;
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_12.combineLatestAll;
  } });
  var combineLatestWith_1 = combineLatestWith$1;
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concatAll_12 = concatAll$1;
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_12.concatAll;
  } });
  var concatMap_12 = concatMap$1;
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_12.concatMap;
  } });
  var concatMapTo_1 = concatMapTo$1;
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = concatWith$1;
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_12 = connect$1;
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_12.connect;
  } });
  var count_1 = count$3;
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = debounce$1;
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = debounceTime$1;
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_12 = defaultIfEmpty$1;
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_12.defaultIfEmpty;
  } });
  var delay_1 = delay$1;
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_12 = delayWhen$1;
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_12.delayWhen;
  } });
  var dematerialize_1 = dematerialize$1;
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = distinct$1;
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_12 = distinctUntilChanged$1;
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_12.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = distinctUntilKeyChanged$1;
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = elementAt$1;
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = endWith$1;
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = every$1;
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = exhaust;
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_12 = exhaustAll$1;
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_12.exhaustAll;
  } });
  var exhaustMap_12 = exhaustMap$1;
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_12.exhaustMap;
  } });
  var expand_1 = expand$1;
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_12 = filter$2;
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_12.filter;
  } });
  var finalize_1 = finalize$1;
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_12 = find$1;
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_12.find;
  } });
  var findIndex_1 = findIndex$1;
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = first$3;
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = groupBy$1;
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_12 = ignoreElements$1;
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_12.ignoreElements;
  } });
  var isEmpty_1 = isEmpty$1;
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = last$3;
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_12 = map$2;
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_12.map;
  } });
  var mapTo_12 = mapTo$1;
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_12.mapTo;
  } });
  var materialize_1 = materialize$1;
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = max$2;
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var mergeAll_12 = mergeAll$1;
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_12.mergeAll;
  } });
  var flatMap_1 = flatMap;
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_12 = mergeMap$1;
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_12.mergeMap;
  } });
  var mergeMapTo_1 = mergeMapTo$1;
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = mergeScan$1;
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = mergeWith$1;
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = min$2;
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_12 = multicast$1;
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_12.multicast;
  } });
  var observeOn_12 = observeOn$1;
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_12.observeOn;
  } });
  var onErrorResumeNextWith_1 = onErrorResumeNextWith$1;
  Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNextWith;
  } });
  var pairwise_1 = pairwise$1;
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var pluck_1 = pluck$1;
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = publish$1;
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = publishBehavior$1;
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = publishLast$1;
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = publishReplay$1;
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var raceWith_12 = raceWith$1;
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_12.raceWith;
  } });
  var reduce_12 = reduce$2;
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_12.reduce;
  } });
  var repeat_1 = repeat$1;
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = repeatWhen$1;
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = retry$2;
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = retryWhen$1;
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_12 = refCount$1;
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_12.refCount;
  } });
  var sample_12 = sample$2;
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_12.sample;
  } });
  var sampleTime_1 = sampleTime$1;
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = scan$1;
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = sequenceEqual$1;
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_12 = share$1;
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_12.share;
  } });
  var shareReplay_1 = shareReplay$1;
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = single$1;
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = skip$2;
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = skipLast$1;
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = skipUntil$1;
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = skipWhile$1;
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = startWith$1;
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_12 = subscribeOn$1;
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_12.subscribeOn;
  } });
  var switchAll_1 = switchAll$1;
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_12 = switchMap$1;
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_12.switchMap;
  } });
  var switchMapTo_1 = switchMapTo$1;
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = switchScan$1;
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_12 = take$1;
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_12.take;
  } });
  var takeLast_12 = takeLast$1;
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_12.takeLast;
  } });
  var takeUntil_1 = takeUntil$1;
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = takeWhile$1;
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = tap$1;
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_12 = throttle$1;
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_12.throttle;
  } });
  var throttleTime_1 = throttleTime$1;
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_12 = throwIfEmpty$1;
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_12.throwIfEmpty;
  } });
  var timeInterval_1 = timeInterval$1;
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_2 = timeout;
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_2.timeout;
  } });
  var timeoutWith_1 = timeoutWith$1;
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = timestamp$1;
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_12 = toArray$2;
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_12.toArray;
  } });
  var window_1 = window$2;
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = windowCount$1;
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = windowTime$1;
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = windowToggle$1;
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = windowWhen$1;
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = withLatestFrom$1;
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zipAll_1 = zipAll$1;
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = zipWith$1;
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
})(cjs);
var storageRemote = {};
var rxStorageRemote = {};
var utils = {};
var utilsArray = {};
Object.defineProperty(utilsArray, "__esModule", {
  value: true
});
utilsArray.appendToArray = appendToArray;
utilsArray.arrayFilterNotEmpty = arrayFilterNotEmpty;
utilsArray.asyncFilter = asyncFilter;
utilsArray.batchArray = batchArray;
utilsArray.countUntilNotMatching = countUntilNotMatching;
utilsArray.isMaybeReadonlyArray = isMaybeReadonlyArray;
utilsArray.lastOfArray = lastOfArray;
utilsArray.maxOfNumbers = maxOfNumbers;
utilsArray.removeOneFromArrayIfMatches = removeOneFromArrayIfMatches;
utilsArray.shuffleArray = shuffleArray;
utilsArray.sumNumberArray = sumNumberArray;
utilsArray.toArray = toArray;
function lastOfArray(ar) {
  return ar[ar.length - 1];
}
function shuffleArray(arr2) {
  return arr2.slice(0).sort(() => Math.random() - 0.5);
}
function toArray(input) {
  return Array.isArray(input) ? input.slice(0) : [input];
}
function batchArray(array2, batchSize) {
  array2 = array2.slice(0);
  var ret = [];
  while (array2.length) {
    var batch = array2.splice(0, batchSize);
    ret.push(batch);
  }
  return ret;
}
function removeOneFromArrayIfMatches(ar, condition) {
  ar = ar.slice();
  var i = ar.length;
  var done = false;
  while (i-- && !done) {
    if (condition(ar[i])) {
      done = true;
      ar.splice(i, 1);
    }
  }
  return ar;
}
function isMaybeReadonlyArray(x) {
  return Array.isArray(x);
}
function arrayFilterNotEmpty(value) {
  if (value === null || value === void 0) {
    return false;
  }
  return true;
}
function countUntilNotMatching(ar, matchingFn) {
  var count2 = 0;
  var idx = -1;
  for (var _item of ar) {
    idx = idx + 1;
    var matching = matchingFn(_item, idx);
    if (matching) {
      count2 = count2 + 1;
    } else {
      break;
    }
  }
  return count2;
}
async function asyncFilter(array2, predicate) {
  var filters = await Promise.all(array2.map(predicate));
  return array2.filter((...[, index]) => filters[index]);
}
function sumNumberArray(array2) {
  var count2 = 0;
  for (var i = array2.length; i--; ) {
    count2 += array2[i];
  }
  return count2;
}
function maxOfNumbers(arr2) {
  return Math.max(...arr2);
}
function appendToArray(ar, add2) {
  var amount = add2.length;
  for (var i = 0; i < amount; ++i) {
    var element2 = add2[i];
    ar.push(element2);
  }
}
var utilsBlob = {};
var utilsBase64 = {};
var base64 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : commonjsGlobal, function() {
    var version = "3.7.5";
    var VERSION = version;
    var _hasatob = typeof atob === "function";
    var _hasbtoa = typeof btoa === "function";
    var _hasBuffer = typeof Buffer === "function";
    var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
    var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
    var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var b64chs = Array.prototype.slice.call(b64ch);
    var b64tab = function(a) {
      var tab = {};
      a.forEach(function(c, i) {
        return tab[c] = i;
      });
      return tab;
    }(b64chs);
    var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    var _fromCC = String.fromCharCode.bind(String);
    var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it) {
      return new Uint8Array(Array.prototype.slice.call(it, 0));
    };
    var _mkUriSafe = function(src2) {
      return src2.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
        return m0 == "+" ? "-" : "_";
      });
    };
    var _tidyB64 = function(s) {
      return s.replace(/[^A-Za-z0-9\+\/]/g, "");
    };
    var btoaPolyfill = function(bin) {
      var u32, c0, c1, c2, asc = "";
      var pad2 = bin.length % 3;
      for (var i = 0; i < bin.length; ) {
        if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
          throw new TypeError("invalid character found");
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
      }
      return pad2 ? asc.slice(0, pad2 - 3) + "===".substring(pad2) : asc;
    };
    var _btoa = _hasbtoa ? function(bin) {
      return btoa(bin);
    } : _hasBuffer ? function(bin) {
      return Buffer.from(bin, "binary").toString("base64");
    } : btoaPolyfill;
    var _fromUint8Array = _hasBuffer ? function(u8a) {
      return Buffer.from(u8a).toString("base64");
    } : function(u8a) {
      var maxargs = 4096;
      var strs = [];
      for (var i = 0, l = u8a.length; i < l; i += maxargs) {
        strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
      }
      return _btoa(strs.join(""));
    };
    var fromUint8Array = function(u8a, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    };
    var cb_utob = function(c) {
      if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      } else {
        var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
        return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
      return u.replace(re_utob, cb_utob);
    };
    var _encode = _hasBuffer ? function(s) {
      return Buffer.from(s, "utf8").toString("base64");
    } : _TE ? function(s) {
      return _fromUint8Array(_TE.encode(s));
    } : function(s) {
      return _btoa(utob(s));
    };
    var encode = function(src2, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_encode(src2)) : _encode(src2);
    };
    var encodeURI2 = function(src2) {
      return encode(src2, true);
    };
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
      switch (cccc.length) {
        case 4:
          var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
          return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
        case 3:
          return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
        default:
          return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
      }
    };
    var btou = function(b) {
      return b.replace(re_btou, cb_btou);
    };
    var atobPolyfill = function(asc) {
      asc = asc.replace(/\s+/g, "");
      if (!b64re.test(asc))
        throw new TypeError("malformed base64.");
      asc += "==".slice(2 - (asc.length & 3));
      var u24, bin = "", r1, r2;
      for (var i = 0; i < asc.length; ) {
        u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
      }
      return bin;
    };
    var _atob = _hasatob ? function(asc) {
      return atob(_tidyB64(asc));
    } : _hasBuffer ? function(asc) {
      return Buffer.from(asc, "base64").toString("binary");
    } : atobPolyfill;
    var _toUint8Array = _hasBuffer ? function(a) {
      return _U8Afrom(Buffer.from(a, "base64"));
    } : function(a) {
      return _U8Afrom(_atob(a).split("").map(function(c) {
        return c.charCodeAt(0);
      }));
    };
    var toUint8Array = function(a) {
      return _toUint8Array(_unURI(a));
    };
    var _decode = _hasBuffer ? function(a) {
      return Buffer.from(a, "base64").toString("utf8");
    } : _TD ? function(a) {
      return _TD.decode(_toUint8Array(a));
    } : function(a) {
      return btou(_atob(a));
    };
    var _unURI = function(a) {
      return _tidyB64(a.replace(/[-_]/g, function(m0) {
        return m0 == "-" ? "+" : "/";
      }));
    };
    var decode = function(src2) {
      return _decode(_unURI(src2));
    };
    var isValid = function(src2) {
      if (typeof src2 !== "string")
        return false;
      var s = src2.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
    };
    var _noEnum = function(v) {
      return {
        value: v,
        enumerable: false,
        writable: true,
        configurable: true
      };
    };
    var extendString = function() {
      var _add = function(name, body) {
        return Object.defineProperty(String.prototype, name, _noEnum(body));
      };
      _add("fromBase64", function() {
        return decode(this);
      });
      _add("toBase64", function(urlsafe) {
        return encode(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return encode(this, true);
      });
      _add("toBase64URL", function() {
        return encode(this, true);
      });
      _add("toUint8Array", function() {
        return toUint8Array(this);
      });
    };
    var extendUint8Array = function() {
      var _add = function(name, body) {
        return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
      };
      _add("toBase64", function(urlsafe) {
        return fromUint8Array(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return fromUint8Array(this, true);
      });
      _add("toBase64URL", function() {
        return fromUint8Array(this, true);
      });
    };
    var extendBuiltins = function() {
      extendString();
      extendUint8Array();
    };
    var gBase64 = {
      version,
      VERSION,
      atob: _atob,
      atobPolyfill,
      btoa: _btoa,
      btoaPolyfill,
      fromBase64: decode,
      toBase64: encode,
      encode,
      encodeURI: encodeURI2,
      encodeURL: encodeURI2,
      utob,
      btou,
      decode,
      isValid,
      fromUint8Array,
      toUint8Array,
      extendString,
      extendUint8Array,
      extendBuiltins
    };
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(function(k) {
      return gBase64.Base64[k] = gBase64[k];
    });
    return gBase64;
  });
})(base64);
var base64Exports = base64.exports;
Object.defineProperty(utilsBase64, "__esModule", {
  value: true
});
utilsBase64.arrayBufferToBase64 = arrayBufferToBase64;
utilsBase64.b64DecodeUnicode = b64DecodeUnicode;
utilsBase64.b64EncodeUnicode = b64EncodeUnicode;
utilsBase64.base64ToArrayBuffer = base64ToArrayBuffer;
var _jsBase = base64Exports;
function b64EncodeUnicode(str) {
  return (0, _jsBase.encode)(str);
}
function b64DecodeUnicode(str) {
  return (0, _jsBase.decode)(str);
}
function arrayBufferToBase64(buffer2) {
  var binary = "";
  var bytes = new Uint8Array(buffer2);
  var len = bytes.byteLength;
  for (var i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
function base64ToArrayBuffer(base642) {
  var binary_string = atob(base642);
  var len = binary_string.length;
  var bytes = new Uint8Array(len);
  for (var i = 0; i < len; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }
  return bytes.buffer;
}
Object.defineProperty(utilsBlob, "__esModule", {
  value: true
});
utilsBlob.blobToBase64String = blobToBase64String;
utilsBlob.blobToString = blobToString;
utilsBlob.createBlob = createBlob;
utilsBlob.createBlobFromBase64 = createBlobFromBase64;
utilsBlob.getBlobSize = getBlobSize;
utilsBlob.isBlob = isBlob;
var _utilsBase = utilsBase64;
function createBlob(data, type2) {
  var blob = new Blob([data], {
    type: type2
  });
  return blob;
}
async function createBlobFromBase64(base64String, type2) {
  var base64Response = await fetch("data:" + type2 + ";base64," + base64String);
  var blob = await base64Response.blob();
  return blob;
}
function isBlob(data) {
  if (data instanceof Blob || typeof Buffer !== "undefined" && Buffer.isBuffer(data)) {
    return true;
  } else {
    return false;
  }
}
function blobToString(blob) {
  var blobType = Object.prototype.toString.call(blob);
  if (blobType === "[object Uint8Array]") {
    blob = new Blob([blob]);
  }
  if (typeof blob === "string") {
    return Promise.resolve(blob);
  }
  return blob.text();
}
async function blobToBase64String(blob) {
  if (typeof blob === "string") {
    return blob;
  }
  var blobType = Object.prototype.toString.call(blob);
  if (blobType === "[object Uint8Array]") {
    blob = new Blob([blob]);
  }
  var fetchUrl = URL.createObjectURL(blob);
  var arrayBuffer = await fetch(fetchUrl).then((res) => res.arrayBuffer());
  return (0, _utilsBase.arrayBufferToBase64)(arrayBuffer);
}
function getBlobSize(blob) {
  return blob.size;
}
var utilsRevision = {};
Object.defineProperty(utilsRevision, "__esModule", {
  value: true
});
utilsRevision.createRevision = createRevision;
utilsRevision.getHeightOfRevision = getHeightOfRevision;
utilsRevision.parseRevision = parseRevision;
function parseRevision(revision) {
  var split2 = revision.split("-");
  if (split2.length !== 2) {
    throw new Error("malformatted revision: " + revision);
  }
  return {
    height: parseInt(split2[0], 10),
    hash: split2[1]
  };
}
function getHeightOfRevision(revision) {
  var ret = parseInt(revision.split("-")[0], 10);
  return ret;
}
function createRevision(databaseInstanceToken, previousDocData) {
  var previousRevision = previousDocData ? previousDocData._rev : null;
  var previousRevisionHeight = previousRevision ? parseRevision(previousRevision).height : 0;
  var newRevisionHeight = previousRevisionHeight + 1;
  return newRevisionHeight + "-" + databaseInstanceToken;
}
var utilsDocument = {};
Object.defineProperty(utilsDocument, "__esModule", {
  value: true
});
utilsDocument.RX_META_LWT_MINIMUM = void 0;
utilsDocument.areRxDocumentArraysEqual = areRxDocumentArraysEqual;
utilsDocument.getDefaultRevision = getDefaultRevision;
utilsDocument.getDefaultRxDocumentMeta = getDefaultRxDocumentMeta;
utilsDocument.getSortDocumentsByLastWriteTimeComparator = getSortDocumentsByLastWriteTimeComparator;
utilsDocument.sortDocumentsByLastWriteTime = sortDocumentsByLastWriteTime;
utilsDocument.stripMetaDataFromDocument = stripMetaDataFromDocument;
var RX_META_LWT_MINIMUM = 1;
utilsDocument.RX_META_LWT_MINIMUM = RX_META_LWT_MINIMUM;
function getDefaultRxDocumentMeta() {
  return {
    /**
     * Set this to 1 to not waste performance
     * while calling new Date()..
     * The storage wrappers will anyway update
     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()
     */
    lwt: RX_META_LWT_MINIMUM
  };
}
function getDefaultRevision() {
  return "";
}
function stripMetaDataFromDocument(docData) {
  return Object.assign({}, docData, {
    _meta: void 0,
    _deleted: void 0,
    _rev: void 0
  });
}
function areRxDocumentArraysEqual(primaryPath, ar1, ar2) {
  if (ar1.length !== ar2.length) {
    return false;
  }
  var i = 0;
  var len = ar1.length;
  while (i < len) {
    var row1 = ar1[i];
    var row2 = ar2[i];
    i++;
    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {
      return false;
    }
  }
  return true;
}
function getSortDocumentsByLastWriteTimeComparator(primaryPath) {
  return (a, b) => {
    if (a._meta.lwt === b._meta.lwt) {
      if (b[primaryPath] < a[primaryPath]) {
        return 1;
      } else {
        return -1;
      }
    } else {
      return a._meta.lwt - b._meta.lwt;
    }
  };
}
function sortDocumentsByLastWriteTime(primaryPath, docs) {
  return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));
}
var utilsHash = {};
var dist$2 = {};
const defaults = Object.freeze({
  ignoreUnknown: false,
  respectType: false,
  respectFunctionNames: false,
  respectFunctionProperties: false,
  unorderedObjects: true,
  unorderedArrays: false,
  unorderedSets: false,
  excludeKeys: void 0,
  excludeValues: void 0,
  replacer: void 0
});
function objectHash(object2, options2) {
  if (options2) {
    options2 = { ...defaults, ...options2 };
  } else {
    options2 = defaults;
  }
  const hasher = createHasher(options2);
  hasher.dispatch(object2);
  return hasher.toString();
}
const defaultPrototypesKeys = Object.freeze([
  "prototype",
  "__proto__",
  "constructor"
]);
function createHasher(options2) {
  let buff = "";
  let context2 = /* @__PURE__ */ new Map();
  const write = (str) => {
    buff += str;
  };
  return {
    toString() {
      return buff;
    },
    getContext() {
      return context2;
    },
    dispatch(value) {
      if (options2.replacer) {
        value = options2.replacer(value);
      }
      const type2 = value === null ? "null" : typeof value;
      return this[type2](value);
    },
    object(object2) {
      if (object2 && typeof object2.toJSON === "function") {
        return this.object(object2.toJSON());
      }
      const objString = Object.prototype.toString.call(object2);
      let objType = "";
      const objectLength = objString.length;
      if (objectLength < 10) {
        objType = "unknown:[" + objString + "]";
      } else {
        objType = objString.slice(8, objectLength - 1);
      }
      objType = objType.toLowerCase();
      let objectNumber = null;
      if ((objectNumber = context2.get(object2)) === void 0) {
        context2.set(object2, context2.size);
      } else {
        return this.dispatch("[CIRCULAR:" + objectNumber + "]");
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object2)) {
        write("buffer:");
        return write(object2.toString("utf8"));
      }
      if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
        if (this[objType]) {
          this[objType](object2);
        } else if (!options2.ignoreUnknown) {
          this.unkown(object2, objType);
        }
      } else {
        let keys2 = Object.keys(object2);
        if (options2.unorderedObjects) {
          keys2 = keys2.sort();
        }
        let extraKeys = [];
        if (options2.respectType !== false && !isNativeFunction$1(object2)) {
          extraKeys = defaultPrototypesKeys;
        }
        if (options2.excludeKeys) {
          keys2 = keys2.filter((key) => {
            return !options2.excludeKeys(key);
          });
          extraKeys = extraKeys.filter((key) => {
            return !options2.excludeKeys(key);
          });
        }
        write("object:" + (keys2.length + extraKeys.length) + ":");
        const dispatchForKey = (key) => {
          this.dispatch(key);
          write(":");
          if (!options2.excludeValues) {
            this.dispatch(object2[key]);
          }
          write(",");
        };
        for (const key of keys2) {
          dispatchForKey(key);
        }
        for (const key of extraKeys) {
          dispatchForKey(key);
        }
      }
    },
    array(arr2, unordered) {
      unordered = unordered === void 0 ? options2.unorderedArrays !== false : unordered;
      write("array:" + arr2.length + ":");
      if (!unordered || arr2.length <= 1) {
        for (const entry of arr2) {
          this.dispatch(entry);
        }
        return;
      }
      const contextAdditions = /* @__PURE__ */ new Map();
      const entries2 = arr2.map((entry) => {
        const hasher = createHasher(options2);
        hasher.dispatch(entry);
        for (const [key, value] of hasher.getContext()) {
          contextAdditions.set(key, value);
        }
        return hasher.toString();
      });
      context2 = contextAdditions;
      entries2.sort();
      return this.array(entries2, false);
    },
    date(date2) {
      return write("date:" + date2.toJSON());
    },
    symbol(sym) {
      return write("symbol:" + sym.toString());
    },
    unkown(value, type2) {
      write(type2);
      if (!value) {
        return;
      }
      write(":");
      if (value && typeof value.entries === "function") {
        return this.array(
          Array.from(value.entries()),
          true
          /* ordered */
        );
      }
    },
    error(err) {
      return write("error:" + err.toString());
    },
    boolean(bool) {
      return write("bool:" + bool);
    },
    string(string2) {
      write("string:" + string2.length + ":");
      write(string2);
    },
    function(fn) {
      write("fn:");
      if (isNativeFunction$1(fn)) {
        this.dispatch("[native]");
      } else {
        this.dispatch(fn.toString());
      }
      if (options2.respectFunctionNames !== false) {
        this.dispatch("function-name:" + String(fn.name));
      }
      if (options2.respectFunctionProperties) {
        this.object(fn);
      }
    },
    number(number) {
      return write("number:" + number);
    },
    xml(xml) {
      return write("xml:" + xml.toString());
    },
    null() {
      return write("Null");
    },
    undefined() {
      return write("Undefined");
    },
    regexp(regex2) {
      return write("regex:" + regex2.toString());
    },
    uint8array(arr2) {
      write("uint8array:");
      return this.dispatch(Array.prototype.slice.call(arr2));
    },
    uint8clampedarray(arr2) {
      write("uint8clampedarray:");
      return this.dispatch(Array.prototype.slice.call(arr2));
    },
    int8array(arr2) {
      write("int8array:");
      return this.dispatch(Array.prototype.slice.call(arr2));
    },
    uint16array(arr2) {
      write("uint16array:");
      return this.dispatch(Array.prototype.slice.call(arr2));
    },
    int16array(arr2) {
      write("int16array:");
      return this.dispatch(Array.prototype.slice.call(arr2));
    },
    uint32array(arr2) {
      write("uint32array:");
      return this.dispatch(Array.prototype.slice.call(arr2));
    },
    int32array(arr2) {
      write("int32array:");
      return this.dispatch(Array.prototype.slice.call(arr2));
    },
    float32array(arr2) {
      write("float32array:");
      return this.dispatch(Array.prototype.slice.call(arr2));
    },
    float64array(arr2) {
      write("float64array:");
      return this.dispatch(Array.prototype.slice.call(arr2));
    },
    arraybuffer(arr2) {
      write("arraybuffer:");
      return this.dispatch(new Uint8Array(arr2));
    },
    url(url) {
      return write("url:" + url.toString());
    },
    map(map2) {
      write("map:");
      const arr2 = [...map2];
      return this.array(arr2, options2.unorderedSets !== false);
    },
    set(set2) {
      write("set:");
      const arr2 = [...set2];
      return this.array(arr2, options2.unorderedSets !== false);
    },
    file(file) {
      write("file:");
      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
    },
    blob() {
      if (options2.ignoreUnknown) {
        return write("[blob]");
      }
      throw new Error(
        'Hashing Blob objects is currently not supported\nUse "options.replacer" or "options.ignoreUnknown"\n'
      );
    },
    domwindow() {
      return write("domwindow");
    },
    bigint(number) {
      return write("bigint:" + number.toString());
    },
    /* Node.js standard native objects */
    process() {
      return write("process");
    },
    timer() {
      return write("timer");
    },
    pipe() {
      return write("pipe");
    },
    tcp() {
      return write("tcp");
    },
    udp() {
      return write("udp");
    },
    tty() {
      return write("tty");
    },
    statwatcher() {
      return write("statwatcher");
    },
    securecontext() {
      return write("securecontext");
    },
    connection() {
      return write("connection");
    },
    zlib() {
      return write("zlib");
    },
    context() {
      return write("context");
    },
    nodescript() {
      return write("nodescript");
    },
    httpparser() {
      return write("httpparser");
    },
    dataview() {
      return write("dataview");
    },
    signal() {
      return write("signal");
    },
    fsevent() {
      return write("fsevent");
    },
    tlswrap() {
      return write("tlswrap");
    }
  };
}
const nativeFunc = "[native code] }";
const nativeFuncLength = nativeFunc.length;
function isNativeFunction$1(f) {
  if (typeof f !== "function") {
    return false;
  }
  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;
}
class WordArray {
  constructor(words, sigBytes) {
    words = this.words = words || [];
    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;
  }
  toString(encoder) {
    return (encoder || Hex).stringify(this);
  }
  concat(wordArray) {
    this.clamp();
    if (this.sigBytes % 4) {
      for (let i = 0; i < wordArray.sigBytes; i++) {
        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;
      }
    } else {
      for (let j = 0; j < wordArray.sigBytes; j += 4) {
        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];
      }
    }
    this.sigBytes += wordArray.sigBytes;
    return this;
  }
  clamp() {
    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;
    this.words.length = Math.ceil(this.sigBytes / 4);
  }
  clone() {
    return new WordArray([...this.words]);
  }
}
const Hex = {
  stringify(wordArray) {
    const hexChars = [];
    for (let i = 0; i < wordArray.sigBytes; i++) {
      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));
    }
    return hexChars.join("");
  }
};
const Base64 = {
  stringify(wordArray) {
    const keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const base64Chars = [];
    for (let i = 0; i < wordArray.sigBytes; i += 3) {
      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
      const triplet = byte1 << 16 | byte2 << 8 | byte3;
      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {
        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));
      }
    }
    return base64Chars.join("");
  }
};
const Latin1 = {
  parse(latin1Str) {
    const latin1StrLength = latin1Str.length;
    const words = [];
    for (let i = 0; i < latin1StrLength; i++) {
      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
    }
    return new WordArray(words, latin1StrLength);
  }
};
const Utf8 = {
  parse(utf8Str) {
    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  }
};
class BufferedBlockAlgorithm {
  constructor() {
    this._data = new WordArray();
    this._nDataBytes = 0;
    this._minBufferSize = 0;
    this.blockSize = 512 / 32;
  }
  reset() {
    this._data = new WordArray();
    this._nDataBytes = 0;
  }
  _append(data) {
    if (typeof data === "string") {
      data = Utf8.parse(data);
    }
    this._data.concat(data);
    this._nDataBytes += data.sigBytes;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _doProcessBlock(_dataWords, _offset) {
  }
  _process(doFlush) {
    let processedWords;
    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);
    if (doFlush) {
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }
    const nWordsReady = nBlocksReady * this.blockSize;
    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);
    if (nWordsReady) {
      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {
        this._doProcessBlock(this._data.words, offset);
      }
      processedWords = this._data.words.splice(0, nWordsReady);
      this._data.sigBytes -= nBytesReady;
    }
    return new WordArray(processedWords, nBytesReady);
  }
}
class Hasher extends BufferedBlockAlgorithm {
  update(messageUpdate) {
    this._append(messageUpdate);
    this._process();
    return this;
  }
  finalize(messageUpdate) {
    if (messageUpdate) {
      this._append(messageUpdate);
    }
  }
}
const H = [
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
];
const K = [
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
];
const W = [];
class SHA256 extends Hasher {
  constructor() {
    super(...arguments);
    this._hash = new WordArray([...H]);
  }
  reset() {
    super.reset();
    this._hash = new WordArray([...H]);
  }
  _doProcessBlock(M, offset) {
    const H2 = this._hash.words;
    let a = H2[0];
    let b = H2[1];
    let c = H2[2];
    let d = H2[3];
    let e = H2[4];
    let f = H2[5];
    let g = H2[6];
    let h = H2[7];
    for (let i = 0; i < 64; i++) {
      if (i < 16) {
        W[i] = M[offset + i] | 0;
      } else {
        const gamma0x = W[i - 15];
        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
        const gamma1x = W[i - 2];
        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
      }
      const ch = e & f ^ ~e & g;
      const maj = a & b ^ a & c ^ b & c;
      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
      const t1 = h + sigma1 + ch + K[i] + W[i];
      const t2 = sigma0 + maj;
      h = g;
      g = f;
      f = e;
      e = d + t1 | 0;
      d = c;
      c = b;
      b = a;
      a = t1 + t2 | 0;
    }
    H2[0] = H2[0] + a | 0;
    H2[1] = H2[1] + b | 0;
    H2[2] = H2[2] + c | 0;
    H2[3] = H2[3] + d | 0;
    H2[4] = H2[4] + e | 0;
    H2[5] = H2[5] + f | 0;
    H2[6] = H2[6] + g | 0;
    H2[7] = H2[7] + h | 0;
  }
  finalize(messageUpdate) {
    super.finalize(messageUpdate);
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = this._data.sigBytes * 8;
    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(
      nBitsTotal / 4294967296
    );
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
    this._data.sigBytes = this._data.words.length * 4;
    this._process();
    return this._hash;
  }
}
function sha256(message) {
  return new SHA256().finalize(message).toString();
}
function sha256base64(message) {
  return new SHA256().finalize(message).toString(Base64);
}
function hash(object2, options2 = {}) {
  const hashed = typeof object2 === "string" ? object2 : objectHash(object2, options2);
  return sha256base64(hashed).slice(0, 10);
}
function murmurHash(key, seed = 0) {
  if (typeof key === "string") {
    key = createBuffer(key);
  }
  let i = 0;
  let h1 = seed;
  let k1;
  let h1b;
  const remainder = key.length & 3;
  const bytes = key.length - remainder;
  const c1 = 3432918353;
  const c2 = 461845907;
  while (i < bytes) {
    k1 = key[i] & 255 | (key[++i] & 255) << 8 | (key[++i] & 255) << 16 | (key[++i] & 255) << 24;
    ++i;
    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
    h1 ^= k1;
    h1 = h1 << 13 | h1 >>> 19;
    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;
    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);
  }
  k1 = 0;
  switch (remainder) {
    case 3: {
      k1 ^= (key[i + 2] & 255) << 16;
      break;
    }
    case 2: {
      k1 ^= (key[i + 1] & 255) << 8;
      break;
    }
    case 1: {
      k1 ^= key[i] & 255;
      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
      h1 ^= k1;
    }
  }
  h1 ^= key.length;
  h1 ^= h1 >>> 16;
  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 13;
  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 16;
  return h1 >>> 0;
}
function createBuffer(val) {
  return new TextEncoder().encode(val);
}
function isEqual(object1, object2, hashOptions = {}) {
  if (object1 === object2) {
    return true;
  }
  if (objectHash(object1, hashOptions) === objectHash(object2, hashOptions)) {
    return true;
  }
  return false;
}
function diff(obj1, obj2, opts = {}) {
  const h1 = _toHashedObject(obj1, opts);
  const h2 = _toHashedObject(obj2, opts);
  return _diff(h1, h2, opts);
}
function _diff(h1, h2, opts = {}) {
  const diffs = [];
  const allProps = /* @__PURE__ */ new Set([
    ...Object.keys(h1.props || {}),
    ...Object.keys(h2.props || {})
  ]);
  if (h1.props && h2.props) {
    for (const prop of allProps) {
      const p1 = h1.props[prop];
      const p2 = h2.props[prop];
      if (p1 && p2) {
        diffs.push(..._diff(h1.props?.[prop], h2.props?.[prop], opts));
      } else if (p1 || p2) {
        diffs.push(
          new DiffEntry((p2 || p1).key, p1 ? "removed" : "added", p2, p1)
        );
      }
    }
  }
  if (allProps.size === 0 && h1.hash !== h2.hash) {
    diffs.push(new DiffEntry((h2 || h1).key, "changed", h2, h1));
  }
  return diffs;
}
function _toHashedObject(obj, opts, key = "") {
  if (obj && typeof obj !== "object") {
    return new DiffHashedObject(key, obj, objectHash(obj, opts));
  }
  const props2 = {};
  const hashes = [];
  for (const _key in obj) {
    props2[_key] = _toHashedObject(
      obj[_key],
      opts,
      key ? `${key}.${_key}` : _key
    );
    hashes.push(props2[_key].hash);
  }
  return new DiffHashedObject(key, obj, `{${hashes.join(":")}}`, props2);
}
class DiffEntry {
  // eslint-disable-next-line no-useless-constructor
  constructor(key, type2, newValue, oldValue) {
    this.key = key;
    this.type = type2;
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
  toString() {
    return this.toJSON();
  }
  toJSON() {
    switch (this.type) {
      case "added": {
        return `Added   \`${this.key}\``;
      }
      case "removed": {
        return `Removed \`${this.key}\``;
      }
      case "changed": {
        return `Changed \`${this.key}\` from \`${this.oldValue?.toString() || "-"}\` to \`${this.newValue.toString()}\``;
      }
    }
  }
}
class DiffHashedObject {
  // eslint-disable-next-line no-useless-constructor
  constructor(key, value, hash2, props2) {
    this.key = key;
    this.value = value;
    this.hash = hash2;
    this.props = props2;
  }
  toString() {
    if (this.props) {
      return `{${Object.keys(this.props).join(",")}}`;
    } else {
      return JSON.stringify(this.value);
    }
  }
  toJSON() {
    const k = this.key || ".";
    if (this.props) {
      return `${k}({${Object.keys(this.props).join(",")}})`;
    }
    return `${k}(${this.value})`;
  }
}
dist$2.diff = diff;
dist$2.hash = hash;
dist$2.isEqual = isEqual;
dist$2.murmurHash = murmurHash;
dist$2.objectHash = objectHash;
dist$2.sha256 = sha256;
dist$2.sha256base64 = sha256base64;
Object.defineProperty(utilsHash, "__esModule", {
  value: true
});
utilsHash.defaultHashSha256 = defaultHashSha256;
var _ohash = dist$2;
function defaultHashSha256(input) {
  return (0, _ohash.sha256)(input);
}
var utilsPromise = {};
Object.defineProperty(utilsPromise, "__esModule", {
  value: true
});
utilsPromise.PROMISE_RESOLVE_VOID = utilsPromise.PROMISE_RESOLVE_TRUE = utilsPromise.PROMISE_RESOLVE_NULL = utilsPromise.PROMISE_RESOLVE_FALSE = void 0;
utilsPromise.nextTick = nextTick;
utilsPromise.promiseSeries = promiseSeries;
utilsPromise.promiseWait = promiseWait;
utilsPromise.requestIdleCallbackIfAvailable = requestIdleCallbackIfAvailable;
utilsPromise.requestIdlePromise = requestIdlePromise;
utilsPromise.toPromise = toPromise;
function nextTick() {
  return new Promise((res) => setTimeout(res, 0));
}
function promiseWait(ms = 0) {
  return new Promise((res) => setTimeout(res, ms));
}
function toPromise(maybePromise) {
  if (maybePromise && typeof maybePromise.then === "function") {
    return maybePromise;
  } else {
    return Promise.resolve(maybePromise);
  }
}
var PROMISE_RESOLVE_TRUE = Promise.resolve(true);
utilsPromise.PROMISE_RESOLVE_TRUE = PROMISE_RESOLVE_TRUE;
var PROMISE_RESOLVE_FALSE = Promise.resolve(false);
utilsPromise.PROMISE_RESOLVE_FALSE = PROMISE_RESOLVE_FALSE;
var PROMISE_RESOLVE_NULL = Promise.resolve(null);
utilsPromise.PROMISE_RESOLVE_NULL = PROMISE_RESOLVE_NULL;
var PROMISE_RESOLVE_VOID = Promise.resolve();
utilsPromise.PROMISE_RESOLVE_VOID = PROMISE_RESOLVE_VOID;
var idlePromiseQueue = PROMISE_RESOLVE_VOID;
function requestIdlePromise(timeout2 = void 0) {
  idlePromiseQueue = idlePromiseQueue.then(() => {
    if (typeof requestIdleCallback === "function") {
      return new Promise((res) => {
        requestIdleCallback(() => res(), {
          timeout: timeout2
        });
      });
    } else {
      return promiseWait(0);
    }
  });
  return idlePromiseQueue;
}
function requestIdleCallbackIfAvailable(fun) {
  if (typeof requestIdleCallback === "function") {
    requestIdleCallback(() => {
      fun();
    });
  }
}
function promiseSeries(tasks, initial) {
  return tasks.reduce((current, next) => current.then(next), Promise.resolve(initial));
}
var utilsString = {};
Object.defineProperty(utilsString, "__esModule", {
  value: true
});
utilsString.RANDOM_STRING = void 0;
utilsString.arrayBufferToString = arrayBufferToString;
utilsString.isFolderPath = isFolderPath;
utilsString.randomCouchString = randomCouchString;
utilsString.stringToArrayBuffer = stringToArrayBuffer;
utilsString.trimDots = trimDots;
utilsString.ucfirst = ucfirst;
function randomCouchString(length = 10) {
  var text = "";
  var possible = "abcdefghijklmnopqrstuvwxyz";
  for (var i = 0; i < length; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
var RANDOM_STRING = "Fz7SZXPmYJujkzjY1rpXWvlWBqoGAfAX";
utilsString.RANDOM_STRING = RANDOM_STRING;
function ucfirst(str) {
  str += "";
  var f = str.charAt(0).toUpperCase();
  return f + str.substr(1);
}
function trimDots(str) {
  while (str.charAt(0) === ".") {
    str = str.substr(1);
  }
  while (str.slice(-1) === ".") {
    str = str.slice(0, -1);
  }
  return str;
}
function isFolderPath(name) {
  if (name.includes("/") || // unix
  name.includes("\\")) {
    return true;
  } else {
    return false;
  }
}
function arrayBufferToString(buf) {
  return String.fromCharCode.apply(null, new Uint16Array(buf));
}
function stringToArrayBuffer(str) {
  var buf = new ArrayBuffer(str.length * 2);
  var bufView = new Uint16Array(buf);
  for (var i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}
var utilsObjectDeepEqual = {};
Object.defineProperty(utilsObjectDeepEqual, "__esModule", {
  value: true
});
utilsObjectDeepEqual.deepEqual = deepEqual;
function deepEqual(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length;
    var i;
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!deepEqual(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    var keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys2[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      var key = keys2[i];
      if (!deepEqual(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}
var utilsObjectDotProp = {};
Object.defineProperty(utilsObjectDotProp, "__esModule", {
  value: true
});
utilsObjectDotProp.deepKeys = deepKeys;
utilsObjectDotProp.deleteProperty = deleteProperty;
utilsObjectDotProp.getProperty = getProperty;
utilsObjectDotProp.hasProperty = hasProperty;
utilsObjectDotProp.setProperty = setProperty;
var isObject$1 = (value) => {
  var type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
var disallowedKeys = /* @__PURE__ */ new Set(["__proto__", "prototype", "constructor"]);
var digits = new Set("0123456789");
function getPathSegments(path2) {
  var parts = [];
  var currentSegment = "";
  var currentPart = "start";
  var isIgnoring = false;
  for (var character of path2) {
    switch (character) {
      case "\\": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (isIgnoring) {
          currentSegment += character;
        }
        currentPart = "property";
        isIgnoring = !isIgnoring;
        break;
      }
      case ".": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "property";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character;
          break;
        }
        if (disallowedKeys.has(currentSegment)) {
          return [];
        }
        parts.push(currentSegment);
        currentSegment = "";
        currentPart = "property";
        break;
      }
      case "[": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "index";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character;
          break;
        }
        if (currentPart === "property") {
          if (disallowedKeys.has(currentSegment)) {
            return [];
          }
          parts.push(currentSegment);
          currentSegment = "";
        }
        currentPart = "index";
        break;
      }
      case "]": {
        if (currentPart === "index") {
          parts.push(Number.parseInt(currentSegment, 10));
          currentSegment = "";
          currentPart = "indexEnd";
          break;
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
      }
      default: {
        if (currentPart === "index" && !digits.has(character)) {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (currentPart === "start") {
          currentPart = "property";
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += "\\";
        }
        currentSegment += character;
      }
    }
  }
  if (isIgnoring) {
    currentSegment += "\\";
  }
  switch (currentPart) {
    case "property": {
      if (disallowedKeys.has(currentSegment)) {
        return [];
      }
      parts.push(currentSegment);
      break;
    }
    case "index": {
      throw new Error("Index was not closed");
    }
    case "start": {
      parts.push("");
      break;
    }
  }
  return parts;
}
function isStringIndex(object2, key) {
  if (typeof key !== "number" && Array.isArray(object2)) {
    var index = Number.parseInt(key, 10);
    return Number.isInteger(index) && object2[index] === object2[key];
  }
  return false;
}
function assertNotStringIndex(object2, key) {
  if (isStringIndex(object2, key)) {
    throw new Error("Cannot use string index");
  }
}
function getProperty(object2, path2, value) {
  if (Array.isArray(path2)) {
    path2 = path2.join(".");
  }
  if (!isObject$1(object2) || typeof path2 !== "string") {
    return value === void 0 ? object2 : value;
  }
  var pathArray = getPathSegments(path2);
  if (pathArray.length === 0) {
    return value;
  }
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    if (isStringIndex(object2, key)) {
      object2 = index === pathArray.length - 1 ? void 0 : null;
    } else {
      object2 = object2[key];
    }
    if (object2 === void 0 || object2 === null) {
      if (index !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object2 === void 0 ? value : object2;
}
function setProperty(object2, path2, value) {
  if (Array.isArray(path2)) {
    path2 = path2.join(".");
  }
  if (!isObject$1(object2) || typeof path2 !== "string") {
    return object2;
  }
  var root = object2;
  var pathArray = getPathSegments(path2);
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    assertNotStringIndex(object2, key);
    if (index === pathArray.length - 1) {
      object2[key] = value;
    } else if (!isObject$1(object2[key])) {
      object2[key] = typeof pathArray[index + 1] === "number" ? [] : {};
    }
    object2 = object2[key];
  }
  return root;
}
function deleteProperty(object2, path2) {
  if (!isObject$1(object2) || typeof path2 !== "string") {
    return false;
  }
  var pathArray = getPathSegments(path2);
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    assertNotStringIndex(object2, key);
    if (index === pathArray.length - 1) {
      delete object2[key];
      return true;
    }
    object2 = object2[key];
    if (!isObject$1(object2)) {
      return false;
    }
  }
}
function hasProperty(object2, path2) {
  if (!isObject$1(object2) || typeof path2 !== "string") {
    return false;
  }
  var pathArray = getPathSegments(path2);
  if (pathArray.length === 0) {
    return false;
  }
  for (var key of pathArray) {
    if (!isObject$1(object2) || !(key in object2) || isStringIndex(object2, key)) {
      return false;
    }
    object2 = object2[key];
  }
  return true;
}
function escapePath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return path2.replace(/[\\.[]/g, "\\$&");
}
function entries(value) {
  if (Array.isArray(value)) {
    return value.map((v, index) => [index, v]);
  }
  return Object.entries(value);
}
function stringifyPath(pathSegments) {
  var result = "";
  for (var [index, segment] of entries(pathSegments)) {
    if (typeof segment === "number") {
      result += "[" + segment + "]";
    } else {
      segment = escapePath(segment);
      result += index === 0 ? segment : "." + segment;
    }
  }
  return result;
}
function* deepKeysIterator(object2, currentPath = []) {
  if (!isObject$1(object2)) {
    if (currentPath.length > 0) {
      yield stringifyPath(currentPath);
    }
    return;
  }
  for (var [key, value] of entries(object2)) {
    yield* deepKeysIterator(value, [...currentPath, key]);
  }
}
function deepKeys(object2) {
  return [...deepKeysIterator(object2)];
}
var utilsObject = {};
Object.defineProperty(utilsObject, "__esModule", {
  value: true
});
utilsObject.clone = void 0;
utilsObject.deepFreeze = deepFreeze;
utilsObject.firstPropertyNameOfObject = firstPropertyNameOfObject;
utilsObject.firstPropertyValueOfObject = firstPropertyValueOfObject;
utilsObject.flatClone = flatClone;
utilsObject.flattenObject = flattenObject;
utilsObject.getFromObjectOrThrow = getFromObjectOrThrow;
utilsObject.objectPathMonad = objectPathMonad;
utilsObject.overwriteGetterForCaching = overwriteGetterForCaching;
utilsObject.sortObject = sortObject;
utilsObject.stringifyFilter = stringifyFilter;
function deepFreeze(o) {
  Object.freeze(o);
  Object.getOwnPropertyNames(o).forEach(function(prop) {
    if (o.hasOwnProperty(prop) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
}
function objectPathMonad(objectPath) {
  var split2 = objectPath.split(".");
  var splitLength = split2.length;
  if (splitLength === 1) {
    return (obj) => obj[objectPath];
  }
  return (obj) => {
    var currentVal = obj;
    for (var i = 0; i < splitLength; ++i) {
      var subPath = split2[i];
      currentVal = currentVal[subPath];
      if (typeof currentVal === "undefined") {
        return currentVal;
      }
    }
    return currentVal;
  };
}
function getFromObjectOrThrow(obj, key) {
  var val = obj[key];
  if (!val) {
    throw new Error("missing value from object " + key);
  }
  return val;
}
function flattenObject(ob) {
  var toReturn = {};
  for (var i in ob) {
    if (!ob.hasOwnProperty(i))
      continue;
    if (typeof ob[i] === "object") {
      var flatObject = flattenObject(ob[i]);
      for (var x in flatObject) {
        if (!flatObject.hasOwnProperty(x))
          continue;
        toReturn[i + "." + x] = flatObject[x];
      }
    } else {
      toReturn[i] = ob[i];
    }
  }
  return toReturn;
}
function flatClone(obj) {
  return Object.assign({}, obj);
}
function firstPropertyNameOfObject(obj) {
  return Object.keys(obj)[0];
}
function firstPropertyValueOfObject(obj) {
  var key = Object.keys(obj)[0];
  return obj[key];
}
function sortObject(obj, noArraySort = false) {
  if (!obj)
    return obj;
  if (!noArraySort && Array.isArray(obj)) {
    return obj.sort((a, b) => {
      if (typeof a === "string" && typeof b === "string")
        return a.localeCompare(b);
      if (typeof a === "object")
        return 1;
      else
        return -1;
    }).map((i) => sortObject(i, noArraySort));
  }
  if (typeof obj === "object" && !Array.isArray(obj)) {
    if (obj instanceof RegExp) {
      return obj;
    }
    var out2 = {};
    Object.keys(obj).sort((a, b) => a.localeCompare(b)).forEach((key) => {
      out2[key] = sortObject(obj[key], noArraySort);
    });
    return out2;
  }
  return obj;
}
function deepClone$1(src2) {
  if (!src2) {
    return src2;
  }
  if (src2 === null || typeof src2 !== "object") {
    return src2;
  }
  if (Array.isArray(src2)) {
    var ret = new Array(src2.length);
    var i = ret.length;
    while (i--) {
      ret[i] = deepClone$1(src2[i]);
    }
    return ret;
  }
  var dest = {};
  for (var key in src2) {
    dest[key] = deepClone$1(src2[key]);
  }
  return dest;
}
var clone$3 = deepClone$1;
utilsObject.clone = clone$3;
function overwriteGetterForCaching(obj, getterName, value) {
  Object.defineProperty(obj, getterName, {
    get: function() {
      return value;
    }
  });
  return value;
}
function stringifyFilter(key, value) {
  if (value instanceof RegExp) {
    return value.toString();
  }
  return value;
}
var utilsMap = {};
Object.defineProperty(utilsMap, "__esModule", {
  value: true
});
utilsMap.getFromMapOrCreate = getFromMapOrCreate;
utilsMap.getFromMapOrThrow = getFromMapOrThrow;
function getFromMapOrThrow(map2, key) {
  var val = map2.get(key);
  if (typeof val === "undefined") {
    throw new Error("missing value from map " + key);
  }
  return val;
}
function getFromMapOrCreate(map2, index, creator, ifWasThere) {
  var value = map2.get(index);
  if (typeof value === "undefined") {
    value = creator();
    map2.set(index, value);
  } else if (ifWasThere) {
    ifWasThere(value);
  }
  return value;
}
var utilsError = {};
Object.defineProperty(utilsError, "__esModule", {
  value: true
});
utilsError.errorToPlainJson = errorToPlainJson;
utilsError.pluginMissing = pluginMissing;
var _utilsString = utilsString;
function pluginMissing(pluginKey) {
  var keyParts = pluginKey.split("-");
  var pluginName = "RxDB";
  keyParts.forEach((part) => {
    pluginName += (0, _utilsString.ucfirst)(part);
  });
  pluginName += "Plugin";
  return new Error("You are using a function which must be overwritten by a plugin.\n        You should either prevent the usage of this function or add the plugin via:\n            import { " + pluginName + " } from 'rxdb/plugins/" + pluginKey + "';\n            addRxPlugin(" + pluginName + ");\n        ");
}
function errorToPlainJson(err) {
  var ret = {
    name: err.name,
    message: err.message,
    rxdb: err.rxdb,
    parameters: err.parameters,
    code: err.code,
    /**
     * stack must be last to make it easier to read the json in a console.
     * Also we ensure that each linebreak is spaced so that the chrome devtools
     * shows urls to the source code that can be clicked to inspect
     * the correct place in the code.
     */
    stack: !err.stack ? void 0 : err.stack.replaceAll("\n", " \n ")
  };
  return ret;
}
var utilsTime = {};
Object.defineProperty(utilsTime, "__esModule", {
  value: true
});
utilsTime.now = now$2;
var _lastNow = 0;
function now$2() {
  var ret = (/* @__PURE__ */ new Date()).getTime();
  ret = ret + 0.01;
  if (ret <= _lastNow) {
    ret = _lastNow + 0.01;
  }
  var twoDecimals = parseFloat(ret.toFixed(2));
  _lastNow = twoDecimals;
  return twoDecimals;
}
var utilsRegex = {};
var utilsOther = {};
Object.defineProperty(utilsOther, "__esModule", {
  value: true
});
utilsOther.RXJS_SHARE_REPLAY_DEFAULTS = void 0;
utilsOther.ensureInteger = ensureInteger;
utilsOther.ensureNotFalsy = ensureNotFalsy;
utilsOther.runXTimes = runXTimes;
function runXTimes(xTimes, fn) {
  new Array(xTimes).fill(0).forEach((_v, idx) => fn(idx));
}
function ensureNotFalsy(obj) {
  if (!obj) {
    throw new Error("ensureNotFalsy() is falsy");
  }
  return obj;
}
function ensureInteger(obj) {
  if (!Number.isInteger(obj)) {
    throw new Error("ensureInteger() is falsy");
  }
  return obj;
}
var RXJS_SHARE_REPLAY_DEFAULTS = {
  bufferSize: 1,
  refCount: true
};
utilsOther.RXJS_SHARE_REPLAY_DEFAULTS = RXJS_SHARE_REPLAY_DEFAULTS;
Object.defineProperty(utilsRegex, "__esModule", {
  value: true
});
utilsRegex.REGEX_PARSE_REGEX_EXPRESSION = utilsRegex.REGEX_ALL_PIPES = utilsRegex.REGEX_ALL_DOTS = void 0;
utilsRegex.parseRegex = parseRegex;
var _utilsOther = utilsOther;
var REGEX_ALL_DOTS = /\./g;
utilsRegex.REGEX_ALL_DOTS = REGEX_ALL_DOTS;
var REGEX_ALL_PIPES = /\|/g;
utilsRegex.REGEX_ALL_PIPES = REGEX_ALL_PIPES;
var REGEX_PARSE_REGEX_EXPRESSION = /(\/?)(.+)\1([a-z]*)/i;
utilsRegex.REGEX_PARSE_REGEX_EXPRESSION = REGEX_PARSE_REGEX_EXPRESSION;
function parseRegex(regex2) {
  var matches = (0, _utilsOther.ensureNotFalsy)(regex2.toString().match(REGEX_PARSE_REGEX_EXPRESSION));
  return {
    pattern: matches[2],
    flags: matches[3]
  };
}
var utilsRxdbVersion = {};
Object.defineProperty(utilsRxdbVersion, "__esModule", {
  value: true
});
utilsRxdbVersion.RXDB_VERSION = void 0;
var RXDB_VERSION = "14.17.1";
utilsRxdbVersion.RXDB_VERSION = RXDB_VERSION;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _utilsArray = utilsArray;
  Object.keys(_utilsArray).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsArray[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsArray[key];
      }
    });
  });
  var _utilsBlob = utilsBlob;
  Object.keys(_utilsBlob).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsBlob[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsBlob[key];
      }
    });
  });
  var _utilsBase2 = utilsBase64;
  Object.keys(_utilsBase2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsBase2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsBase2[key];
      }
    });
  });
  var _utilsRevision = utilsRevision;
  Object.keys(_utilsRevision).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsRevision[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsRevision[key];
      }
    });
  });
  var _utilsDocument = utilsDocument;
  Object.keys(_utilsDocument).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsDocument[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsDocument[key];
      }
    });
  });
  var _utilsHash = utilsHash;
  Object.keys(_utilsHash).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsHash[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsHash[key];
      }
    });
  });
  var _utilsPromise = utilsPromise;
  Object.keys(_utilsPromise).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsPromise[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsPromise[key];
      }
    });
  });
  var _utilsString2 = utilsString;
  Object.keys(_utilsString2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsString2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsString2[key];
      }
    });
  });
  var _utilsObjectDeepEqual = utilsObjectDeepEqual;
  Object.keys(_utilsObjectDeepEqual).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsObjectDeepEqual[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsObjectDeepEqual[key];
      }
    });
  });
  var _utilsObjectDotProp = utilsObjectDotProp;
  Object.keys(_utilsObjectDotProp).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsObjectDotProp[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsObjectDotProp[key];
      }
    });
  });
  var _utilsObject = utilsObject;
  Object.keys(_utilsObject).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsObject[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsObject[key];
      }
    });
  });
  var _utilsMap = utilsMap;
  Object.keys(_utilsMap).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsMap[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsMap[key];
      }
    });
  });
  var _utilsError = utilsError;
  Object.keys(_utilsError).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsError[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsError[key];
      }
    });
  });
  var _utilsTime = utilsTime;
  Object.keys(_utilsTime).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsTime[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsTime[key];
      }
    });
  });
  var _utilsRegex = utilsRegex;
  Object.keys(_utilsRegex).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsRegex[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsRegex[key];
      }
    });
  });
  var _utilsOther2 = utilsOther;
  Object.keys(_utilsOther2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsOther2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsOther2[key];
      }
    });
  });
  var _utilsRxdbVersion = utilsRxdbVersion;
  Object.keys(_utilsRxdbVersion).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsRxdbVersion[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsRxdbVersion[key];
      }
    });
  });
})(utils);
var messageChannelCache = {};
Object.defineProperty(messageChannelCache, "__esModule", {
  value: true
});
messageChannelCache.OPEN_REMOTE_MESSAGE_CHANNELS = messageChannelCache.MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER = messageChannelCache.CACHE_ITEM_BY_MESSAGE_CHANNEL = void 0;
messageChannelCache.closeMessageChannel = closeMessageChannel;
messageChannelCache.getMessageChannel = getMessageChannel;
var _utils$w = utils;
var MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER = /* @__PURE__ */ new Map();
messageChannelCache.MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER = MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER;
var CACHE_ITEM_BY_MESSAGE_CHANNEL = /* @__PURE__ */ new WeakMap();
messageChannelCache.CACHE_ITEM_BY_MESSAGE_CHANNEL = CACHE_ITEM_BY_MESSAGE_CHANNEL;
var OPEN_REMOTE_MESSAGE_CHANNELS = /* @__PURE__ */ new Set();
messageChannelCache.OPEN_REMOTE_MESSAGE_CHANNELS = OPEN_REMOTE_MESSAGE_CHANNELS;
function getMessageChannelCache(identifier) {
  return (0, _utils$w.getFromMapOrCreate)(MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER, identifier, () => /* @__PURE__ */ new Map());
}
function getMessageChannel(settings, cacheKeys, keepAlive = false) {
  var cacheKey = getCacheKey(settings, cacheKeys);
  var cacheItem = (0, _utils$w.getFromMapOrCreate)(getMessageChannelCache(settings.identifier), cacheKey, () => {
    var newCacheItem = {
      identifier: settings.identifier,
      cacheKey,
      keepAlive,
      refCount: 1,
      messageChannel: settings.messageChannelCreator().then((messageChannel) => {
        OPEN_REMOTE_MESSAGE_CHANNELS.add(messageChannel);
        CACHE_ITEM_BY_MESSAGE_CHANNEL.set(messageChannel, newCacheItem);
        return messageChannel;
      })
    };
    return newCacheItem;
  }, (existingCacheItem) => {
    existingCacheItem.refCount = existingCacheItem.refCount + 1;
  });
  return cacheItem.messageChannel;
}
function closeMessageChannel(messageChannel) {
  var cacheItem = (0, _utils$w.getFromMapOrThrow)(CACHE_ITEM_BY_MESSAGE_CHANNEL, messageChannel);
  cacheItem.refCount = cacheItem.refCount - 1;
  if (cacheItem.refCount === 0 && !cacheItem.keepAlive) {
    getMessageChannelCache(cacheItem.identifier).delete(cacheItem.cacheKey);
    OPEN_REMOTE_MESSAGE_CHANNELS.delete(messageChannel);
    return messageChannel.close();
  } else {
    return _utils$w.PROMISE_RESOLVE_VOID;
  }
}
function getCacheKey(settings, cacheKeys) {
  cacheKeys = cacheKeys.slice(0);
  cacheKeys.unshift(settings.identifier);
  return cacheKeys.join("||");
}
var rxStorageHelper = {};
var overwritable$1 = {};
Object.defineProperty(overwritable$1, "__esModule", {
  value: true
});
overwritable$1.overwritable = void 0;
var overwritable = {
  /**
   * if this method is overwritten with one
   * that returns true, we do additional checks
   * which help the developer but have bad performance
   */
  isDevMode() {
    return false;
  },
  /**
   * Deep freezes and object when in dev-mode.
   * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.
   * Also, we can ensure the readonly state via typescript
   * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
   */
  deepFreezeWhenDevMode(obj) {
    return obj;
  },
  /**
   * overwritten to map error-codes to text-messages
   */
  tunnelErrorMessage(message) {
    return "RxDB Error-Code " + message + ".\n        Error messages are not included in RxDB core to reduce build size.\n        - To find out what this error means, either use the dev-mode-plugin https://rxdb.info/dev-mode.html\n        - or search for the error code here: https://github.com/pubkey/rxdb/search?q=" + message + "\n        ";
  }
};
overwritable$1.overwritable = overwritable;
var rxError = {};
var interopRequireDefault$1 = { exports: {} };
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault$1);
var interopRequireDefaultExports$1 = interopRequireDefault$1.exports;
var createClass = { exports: {} };
var toPropertyKey = { exports: {} };
var _typeof$2 = { exports: {} };
var hasRequired_typeof;
function require_typeof() {
  if (hasRequired_typeof)
    return _typeof$2.exports;
  hasRequired_typeof = 1;
  (function(module) {
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof$2);
  return _typeof$2.exports;
}
var toPrimitive = { exports: {} };
var hasRequiredToPrimitive;
function requireToPrimitive() {
  if (hasRequiredToPrimitive)
    return toPrimitive.exports;
  hasRequiredToPrimitive = 1;
  (function(module) {
    var _typeof2 = require_typeof()["default"];
    function _toPrimitive(input, hint) {
      if (_typeof2(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof2(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(toPrimitive);
  return toPrimitive.exports;
}
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  if (hasRequiredToPropertyKey)
    return toPropertyKey.exports;
  hasRequiredToPropertyKey = 1;
  (function(module) {
    var _typeof2 = require_typeof()["default"];
    var toPrimitive2 = requireToPrimitive();
    function _toPropertyKey(arg) {
      var key = toPrimitive2(arg, "string");
      return _typeof2(key) === "symbol" ? key : String(key);
    }
    module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(toPropertyKey);
  return toPropertyKey.exports;
}
var hasRequiredCreateClass;
function requireCreateClass() {
  if (hasRequiredCreateClass)
    return createClass.exports;
  hasRequiredCreateClass = 1;
  (function(module) {
    var toPropertyKey2 = requireToPropertyKey();
    function _defineProperties(target, props2) {
      for (var i = 0; i < props2.length; i++) {
        var descriptor = props2[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey2(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(createClass);
  return createClass.exports;
}
var inheritsLoose = { exports: {} };
var setPrototypeOf = { exports: {} };
var hasRequiredSetPrototypeOf;
function requireSetPrototypeOf() {
  if (hasRequiredSetPrototypeOf)
    return setPrototypeOf.exports;
  hasRequiredSetPrototypeOf = 1;
  (function(module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _setPrototypeOf(o, p);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(setPrototypeOf);
  return setPrototypeOf.exports;
}
var hasRequiredInheritsLoose;
function requireInheritsLoose() {
  if (hasRequiredInheritsLoose)
    return inheritsLoose.exports;
  hasRequiredInheritsLoose = 1;
  (function(module) {
    var setPrototypeOf2 = requireSetPrototypeOf();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      setPrototypeOf2(subClass, superClass);
    }
    module.exports = _inheritsLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(inheritsLoose);
  return inheritsLoose.exports;
}
var wrapNativeSuper = { exports: {} };
var getPrototypeOf$1 = { exports: {} };
var hasRequiredGetPrototypeOf;
function requireGetPrototypeOf() {
  if (hasRequiredGetPrototypeOf)
    return getPrototypeOf$1.exports;
  hasRequiredGetPrototypeOf = 1;
  (function(module) {
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _getPrototypeOf(o);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(getPrototypeOf$1);
  return getPrototypeOf$1.exports;
}
var isNativeFunction = { exports: {} };
var hasRequiredIsNativeFunction;
function requireIsNativeFunction() {
  if (hasRequiredIsNativeFunction)
    return isNativeFunction.exports;
  hasRequiredIsNativeFunction = 1;
  (function(module) {
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(isNativeFunction);
  return isNativeFunction.exports;
}
var construct = { exports: {} };
var isNativeReflectConstruct = { exports: {} };
var hasRequiredIsNativeReflectConstruct;
function requireIsNativeReflectConstruct() {
  if (hasRequiredIsNativeReflectConstruct)
    return isNativeReflectConstruct.exports;
  hasRequiredIsNativeReflectConstruct = 1;
  (function(module) {
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(isNativeReflectConstruct);
  return isNativeReflectConstruct.exports;
}
var hasRequiredConstruct;
function requireConstruct() {
  if (hasRequiredConstruct)
    return construct.exports;
  hasRequiredConstruct = 1;
  (function(module) {
    var setPrototypeOf2 = requireSetPrototypeOf();
    var isNativeReflectConstruct2 = requireIsNativeReflectConstruct();
    function _construct(Parent, args2, Class) {
      if (isNativeReflectConstruct2()) {
        module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
      } else {
        module.exports = _construct = function _construct2(Parent2, args3, Class2) {
          var a = [null];
          a.push.apply(a, args3);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            setPrototypeOf2(instance, Class2.prototype);
          return instance;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      }
      return _construct.apply(null, arguments);
    }
    module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(construct);
  return construct.exports;
}
var hasRequiredWrapNativeSuper;
function requireWrapNativeSuper() {
  if (hasRequiredWrapNativeSuper)
    return wrapNativeSuper.exports;
  hasRequiredWrapNativeSuper = 1;
  (function(module) {
    var getPrototypeOf2 = requireGetPrototypeOf();
    var setPrototypeOf2 = requireSetPrototypeOf();
    var isNativeFunction2 = requireIsNativeFunction();
    var construct2 = requireConstruct();
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      module.exports = _wrapNativeSuper = function _wrapNativeSuper3(Class2) {
        if (Class2 === null || !isNativeFunction2(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return construct2(Class2, arguments, getPrototypeOf2(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return setPrototypeOf2(Wrapper, Class2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _wrapNativeSuper(Class);
    }
    module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(wrapNativeSuper);
  return wrapNativeSuper.exports;
}
var _interopRequireDefault$6 = interopRequireDefaultExports$1;
Object.defineProperty(rxError, "__esModule", {
  value: true
});
rxError.RxTypeError = rxError.RxError = void 0;
rxError.isBulkWriteConflictError = isBulkWriteConflictError;
rxError.newRxError = newRxError;
rxError.newRxTypeError = newRxTypeError;
rxError.rxStorageWriteErrorToRxError = rxStorageWriteErrorToRxError;
var _createClass2$4 = _interopRequireDefault$6(requireCreateClass());
var _inheritsLoose2 = _interopRequireDefault$6(requireInheritsLoose());
var _wrapNativeSuper2 = _interopRequireDefault$6(requireWrapNativeSuper());
var _overwritable$9 = overwritable$1;
function parametersToString(parameters) {
  var ret = "";
  if (Object.keys(parameters).length === 0)
    return ret;
  ret += "Given parameters: {\n";
  ret += Object.keys(parameters).map((k) => {
    var paramStr = "[object Object]";
    try {
      if (k === "errors") {
        paramStr = parameters[k].map((err) => JSON.stringify(err, Object.getOwnPropertyNames(err)));
      } else {
        paramStr = JSON.stringify(parameters[k], function(_k, v) {
          return v === void 0 ? null : v;
        }, 2);
      }
    } catch (e) {
    }
    return k + ":" + paramStr;
  }).join("\n");
  ret += "}";
  return ret;
}
function messageForError(message, code, parameters) {
  return "RxError (" + code + "):\n" + message + "\n" + parametersToString(parameters);
}
var RxError = /* @__PURE__ */ function(_Error) {
  (0, _inheritsLoose2.default)(RxError2, _Error);
  function RxError2(code, message, parameters = {}) {
    var _this;
    var mes = messageForError(message, code, parameters);
    _this = _Error.call(this, mes) || this;
    _this.code = code;
    _this.message = mes;
    _this.parameters = parameters;
    _this.rxdb = true;
    return _this;
  }
  var _proto = RxError2.prototype;
  _proto.toString = function toString2() {
    return this.message;
  };
  (0, _createClass2$4.default)(RxError2, [{
    key: "name",
    get: function() {
      return "RxError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return false;
    }
  }]);
  return RxError2;
}(/* @__PURE__ */ (0, _wrapNativeSuper2.default)(Error));
rxError.RxError = RxError;
var RxTypeError = /* @__PURE__ */ function(_TypeError) {
  (0, _inheritsLoose2.default)(RxTypeError2, _TypeError);
  function RxTypeError2(code, message, parameters = {}) {
    var _this2;
    var mes = messageForError(message, code, parameters);
    _this2 = _TypeError.call(this, mes) || this;
    _this2.code = code;
    _this2.message = mes;
    _this2.parameters = parameters;
    _this2.rxdb = true;
    return _this2;
  }
  var _proto2 = RxTypeError2.prototype;
  _proto2.toString = function toString2() {
    return this.message;
  };
  (0, _createClass2$4.default)(RxTypeError2, [{
    key: "name",
    get: function() {
      return "RxTypeError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return true;
    }
  }]);
  return RxTypeError2;
}(/* @__PURE__ */ (0, _wrapNativeSuper2.default)(TypeError));
rxError.RxTypeError = RxTypeError;
function newRxError(code, parameters) {
  return new RxError(code, _overwritable$9.overwritable.tunnelErrorMessage(code), parameters);
}
function newRxTypeError(code, parameters) {
  return new RxTypeError(code, _overwritable$9.overwritable.tunnelErrorMessage(code), parameters);
}
function isBulkWriteConflictError(err) {
  if (err && err.status === 409) {
    return err;
  } else {
    return false;
  }
}
var STORAGE_WRITE_ERROR_CODE_TO_MESSAGE = {
  409: "document write conflict",
  422: "schema validation error",
  510: "attachment data missing"
};
function rxStorageWriteErrorToRxError(err) {
  return newRxError("COL20", {
    name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],
    document: err.documentId,
    writeError: err
  });
}
var rxSchemaHelper = {};
Object.defineProperty(rxSchemaHelper, "__esModule", {
  value: true
});
rxSchemaHelper.RX_META_SCHEMA = rxSchemaHelper.DEFAULT_CHECKPOINT_SCHEMA = void 0;
rxSchemaHelper.fillObjectWithDefaults = fillObjectWithDefaults;
rxSchemaHelper.fillPrimaryKey = fillPrimaryKey;
rxSchemaHelper.fillWithDefaultSettings = fillWithDefaultSettings;
rxSchemaHelper.getComposedPrimaryKeyOfDocumentData = getComposedPrimaryKeyOfDocumentData;
rxSchemaHelper.getFinalFields = getFinalFields;
rxSchemaHelper.getLengthOfPrimaryKey = getLengthOfPrimaryKey;
rxSchemaHelper.getPrimaryFieldOfPrimaryKey = getPrimaryFieldOfPrimaryKey;
rxSchemaHelper.getPseudoSchemaForVersion = getPseudoSchemaForVersion;
rxSchemaHelper.getSchemaByObjectPath = getSchemaByObjectPath;
rxSchemaHelper.normalizeRxJsonSchema = normalizeRxJsonSchema;
var _rxError$l = rxError;
var _utils$v = utils;
function getPseudoSchemaForVersion(version, primaryKey) {
  var pseudoSchema = fillWithDefaultSettings({
    version,
    type: "object",
    primaryKey,
    properties: {
      [primaryKey]: {
        type: "string",
        maxLength: 100
      }
    },
    required: [primaryKey]
  });
  return pseudoSchema;
}
function getSchemaByObjectPath(rxJsonSchema, path2) {
  var usePath = path2;
  usePath = usePath.replace(_utils$v.REGEX_ALL_DOTS, ".properties.");
  usePath = "properties." + usePath;
  usePath = (0, _utils$v.trimDots)(usePath);
  var ret = (0, _utils$v.getProperty)(rxJsonSchema, usePath);
  return ret;
}
function fillPrimaryKey(primaryPath, jsonSchema2, documentData) {
  if (typeof jsonSchema2.primaryKey === "string") {
    return documentData;
  }
  var newPrimary = getComposedPrimaryKeyOfDocumentData(jsonSchema2, documentData);
  var existingPrimary = documentData[primaryPath];
  if (existingPrimary && existingPrimary !== newPrimary) {
    throw (0, _rxError$l.newRxError)("DOC19", {
      args: {
        documentData,
        existingPrimary,
        newPrimary
      },
      schema: jsonSchema2
    });
  }
  documentData[primaryPath] = newPrimary;
  return documentData;
}
function getPrimaryFieldOfPrimaryKey(primaryKey) {
  if (typeof primaryKey === "string") {
    return primaryKey;
  } else {
    return primaryKey.key;
  }
}
function getLengthOfPrimaryKey(schema) {
  var primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);
  var schemaPart = getSchemaByObjectPath(schema, primaryPath);
  return (0, _utils$v.ensureNotFalsy)(schemaPart.maxLength);
}
function getComposedPrimaryKeyOfDocumentData(jsonSchema2, documentData) {
  if (typeof jsonSchema2.primaryKey === "string") {
    return documentData[jsonSchema2.primaryKey];
  }
  var compositePrimary = jsonSchema2.primaryKey;
  return compositePrimary.fields.map((field) => {
    var value = (0, _utils$v.getProperty)(documentData, field);
    if (typeof value === "undefined") {
      throw (0, _rxError$l.newRxError)("DOC18", {
        args: {
          field,
          documentData
        }
      });
    }
    return value;
  }).join(compositePrimary.separator);
}
function normalizeRxJsonSchema(jsonSchema2) {
  var normalizedSchema = (0, _utils$v.sortObject)(jsonSchema2, true);
  return normalizedSchema;
}
function fillWithDefaultSettings(schemaObj) {
  schemaObj = (0, _utils$v.flatClone)(schemaObj);
  var primaryPath = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);
  schemaObj.properties = (0, _utils$v.flatClone)(schemaObj.properties);
  schemaObj.additionalProperties = false;
  if (!schemaObj.hasOwnProperty("keyCompression")) {
    schemaObj.keyCompression = false;
  }
  schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];
  schemaObj.properties._rev = {
    type: "string",
    minLength: 1
  };
  schemaObj.properties._attachments = {
    type: "object"
  };
  schemaObj.properties._deleted = {
    type: "boolean"
  };
  schemaObj.properties._meta = RX_META_SCHEMA;
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.required.push("_deleted");
  schemaObj.required.push("_rev");
  schemaObj.required.push("_meta");
  schemaObj.required.push("_attachments");
  var finalFields = getFinalFields(schemaObj);
  (0, _utils$v.appendToArray)(schemaObj.required, finalFields);
  schemaObj.required = schemaObj.required.filter((field) => !field.includes(".")).filter((elem, pos, arr2) => arr2.indexOf(elem) === pos);
  schemaObj.version = schemaObj.version || 0;
  if (schemaObj.indexes) {
    schemaObj.indexes = schemaObj.indexes.map((index) => {
      var arIndex = (0, _utils$v.isMaybeReadonlyArray)(index) ? index.slice(0) : [index];
      if (!arIndex.includes(primaryPath)) {
        var modifiedIndex = arIndex.slice(0);
        modifiedIndex.push(primaryPath);
        return modifiedIndex;
      }
      return arIndex;
    });
  }
  return schemaObj;
}
var RX_META_SCHEMA = {
  type: "object",
  properties: {
    /**
     * The last-write time.
     * Unix time in milliseconds.
     */
    lwt: {
      type: "number",
      /**
       * We use 1 as minimum so that the value is never falsy.
       */
      minimum: _utils$v.RX_META_LWT_MINIMUM,
      maximum: 1e15,
      multipleOf: 0.01
    }
  },
  /**
   * Additional properties are allowed
   * and can be used by plugins to set various flags.
   */
  additionalProperties: true,
  required: ["lwt"]
};
rxSchemaHelper.RX_META_SCHEMA = RX_META_SCHEMA;
function getFinalFields(jsonSchema2) {
  var ret = Object.keys(jsonSchema2.properties).filter((key) => jsonSchema2.properties[key].final);
  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema2.primaryKey);
  ret.push(primaryPath);
  if (typeof jsonSchema2.primaryKey !== "string") {
    jsonSchema2.primaryKey.fields.forEach((field) => ret.push(field));
  }
  return ret;
}
function fillObjectWithDefaults(rxSchema2, obj) {
  var defaultKeys = Object.keys(rxSchema2.defaultValues);
  for (var i = 0; i < defaultKeys.length; ++i) {
    var key = defaultKeys[i];
    if (!obj.hasOwnProperty(key) || typeof obj[key] === "undefined") {
      obj[key] = rxSchema2.defaultValues[key];
    }
  }
  return obj;
}
var DEFAULT_CHECKPOINT_SCHEMA = {
  type: "object",
  properties: {
    id: {
      type: "string"
    },
    lwt: {
      type: "number"
    }
  },
  required: ["id", "lwt"],
  additionalProperties: false
};
rxSchemaHelper.DEFAULT_CHECKPOINT_SCHEMA = DEFAULT_CHECKPOINT_SCHEMA;
Object.defineProperty(rxStorageHelper, "__esModule", {
  value: true
});
rxStorageHelper.RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = rxStorageHelper.INTERNAL_STORAGE_NAME = void 0;
rxStorageHelper.attachmentWriteDataToNormalData = attachmentWriteDataToNormalData;
rxStorageHelper.categorizeBulkWriteRows = categorizeBulkWriteRows;
rxStorageHelper.ensureRxStorageInstanceParamsAreCorrect = ensureRxStorageInstanceParamsAreCorrect;
rxStorageHelper.flatCloneDocWithMeta = flatCloneDocWithMeta;
rxStorageHelper.getAttachmentSize = getAttachmentSize;
rxStorageHelper.getSingleDocument = getSingleDocument;
rxStorageHelper.getUniqueDeterministicEventKey = getUniqueDeterministicEventKey;
rxStorageHelper.getWrappedStorageInstance = getWrappedStorageInstance;
rxStorageHelper.hasEncryption = hasEncryption;
rxStorageHelper.stackCheckpoints = stackCheckpoints;
rxStorageHelper.storageChangeEventToRxChangeEvent = storageChangeEventToRxChangeEvent;
rxStorageHelper.stripAttachmentsDataFromDocument = stripAttachmentsDataFromDocument;
rxStorageHelper.stripAttachmentsDataFromRow = stripAttachmentsDataFromRow;
rxStorageHelper.throwIfIsStorageWriteError = throwIfIsStorageWriteError;
rxStorageHelper.writeSingle = writeSingle;
var _overwritable$8 = overwritable$1;
var _rxError$k = rxError;
var _rxSchemaHelper$e = rxSchemaHelper;
var _utils$u = utils;
var INTERNAL_STORAGE_NAME = "_rxdb_internal";
rxStorageHelper.INTERNAL_STORAGE_NAME = INTERNAL_STORAGE_NAME;
var RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = "rxdatabase_storage_local";
rxStorageHelper.RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = RX_DATABASE_LOCAL_DOCS_STORAGE_NAME;
async function getSingleDocument(storageInstance, documentId) {
  var results = await storageInstance.findDocumentsById([documentId], false);
  var doc = results[documentId];
  if (doc) {
    return doc;
  } else {
    return null;
  }
}
async function writeSingle(instance, writeRow, context2) {
  var writeResult = await instance.bulkWrite([writeRow], context2);
  if (Object.keys(writeResult.error).length > 0) {
    var error = (0, _utils$u.firstPropertyValueOfObject)(writeResult.error);
    throw error;
  } else {
    var ret = (0, _utils$u.firstPropertyValueOfObject)(writeResult.success);
    return ret;
  }
}
function stackCheckpoints(checkpoints) {
  return Object.assign({}, ...checkpoints);
}
function storageChangeEventToRxChangeEvent(isLocal, rxStorageChangeEvent, rxCollection2) {
  var documentData = rxStorageChangeEvent.documentData;
  var previousDocumentData = rxStorageChangeEvent.previousDocumentData;
  var ret = {
    eventId: rxStorageChangeEvent.eventId,
    documentId: rxStorageChangeEvent.documentId,
    collectionName: rxCollection2 ? rxCollection2.name : void 0,
    startTime: rxStorageChangeEvent.startTime,
    endTime: rxStorageChangeEvent.endTime,
    isLocal,
    operation: rxStorageChangeEvent.operation,
    documentData: _overwritable$8.overwritable.deepFreezeWhenDevMode(documentData),
    previousDocumentData: _overwritable$8.overwritable.deepFreezeWhenDevMode(previousDocumentData)
  };
  return ret;
}
function throwIfIsStorageWriteError(collection, documentId, writeData, error) {
  if (error) {
    if (error.status === 409) {
      throw (0, _rxError$k.newRxError)("CONFLICT", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else if (error.status === 422) {
      throw (0, _rxError$k.newRxError)("VD2", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else {
      throw error;
    }
  }
}
function categorizeBulkWriteRows(storageInstance, primaryPath, docsInDb, bulkWriteRows, context2) {
  var hasAttachments = !!storageInstance.schema.attachments;
  var bulkInsertDocs = [];
  var bulkUpdateDocs = [];
  var errors = {};
  var changeByDocId = /* @__PURE__ */ new Map();
  var eventBulkId = (0, _utils$u.randomCouchString)(10);
  var eventBulk = {
    id: eventBulkId,
    events: [],
    checkpoint: null,
    context: context2
  };
  var eventBulkEvents = eventBulk.events;
  var attachmentsAdd = [];
  var attachmentsRemove = [];
  var attachmentsUpdate = [];
  var startTime = (0, _utils$u.now)();
  var docsByIdIsMap = typeof docsInDb.get === "function";
  var hasDocsInDb = docsByIdIsMap ? docsInDb.size > 0 : Object.keys(docsInDb).length > 0;
  var newestRow;
  var rowAmount = bulkWriteRows.length;
  var _loop = function() {
    var writeRow = bulkWriteRows[rowId];
    var docId = writeRow.document[primaryPath];
    var documentInDb = false;
    if (hasDocsInDb) {
      documentInDb = docsByIdIsMap ? docsInDb.get(docId) : docsInDb[docId];
    }
    var attachmentError;
    if (!documentInDb) {
      var insertedIsDeleted = writeRow.document._deleted ? true : false;
      if (hasAttachments) {
        Object.entries(writeRow.document._attachments).forEach(([attachmentId, attachmentData]) => {
          if (!attachmentData.data) {
            attachmentError = {
              documentId: docId,
              isError: true,
              status: 510,
              writeRow,
              attachmentId
            };
            errors[docId] = attachmentError;
          } else {
            attachmentsAdd.push({
              documentId: docId,
              attachmentId,
              attachmentData,
              digest: (0, _utils$u.defaultHashSha256)(attachmentData.data)
            });
          }
        });
      }
      if (!attachmentError) {
        if (hasAttachments) {
          bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));
        } else {
          bulkInsertDocs.push(writeRow);
        }
        if (!newestRow || newestRow.document._meta.lwt < writeRow.document._meta.lwt) {
          newestRow = writeRow;
        }
      }
      if (!insertedIsDeleted) {
        var event = {
          eventId: getUniqueDeterministicEventKey(eventBulkId, rowId, docId, writeRow),
          documentId: docId,
          operation: "INSERT",
          documentData: hasAttachments ? stripAttachmentsDataFromDocument(writeRow.document) : writeRow.document,
          previousDocumentData: hasAttachments && writeRow.previous ? stripAttachmentsDataFromDocument(writeRow.previous) : writeRow.previous,
          startTime,
          endTime: (0, _utils$u.now)()
        };
        changeByDocId.set(docId, event);
        eventBulkEvents.push(event);
      }
    } else {
      var revInDb = documentInDb._rev;
      if (!writeRow.previous || !!writeRow.previous && revInDb !== writeRow.previous._rev) {
        var err = {
          isError: true,
          status: 409,
          documentId: docId,
          writeRow,
          documentInDb
        };
        errors[docId] = err;
        return 1;
      }
      var updatedRow = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow;
      if (hasAttachments) {
        if (writeRow.document._deleted) {
          if (writeRow.previous) {
            Object.keys(writeRow.previous._attachments).forEach((attachmentId) => {
              attachmentsRemove.push({
                documentId: docId,
                attachmentId,
                digest: (0, _utils$u.ensureNotFalsy)(writeRow.previous)._attachments[attachmentId].digest
              });
            });
          }
        } else {
          Object.entries(writeRow.document._attachments).find(([attachmentId, attachmentData]) => {
            var previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : void 0;
            if (!previousAttachmentData && !attachmentData.data) {
              attachmentError = {
                documentId: docId,
                documentInDb,
                isError: true,
                status: 510,
                writeRow,
                attachmentId
              };
            }
            return true;
          });
          if (!attachmentError) {
            Object.entries(writeRow.document._attachments).forEach(([attachmentId, attachmentData]) => {
              var previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : void 0;
              if (!previousAttachmentData) {
                attachmentsAdd.push({
                  documentId: docId,
                  attachmentId,
                  attachmentData,
                  digest: (0, _utils$u.defaultHashSha256)(attachmentData.data)
                });
              } else {
                var newDigest = updatedRow.document._attachments[attachmentId].digest;
                if (attachmentData.data && /**
                 * Performance shortcut,
                 * do not update the attachment data if it did not change.
                 */
                previousAttachmentData.digest !== newDigest) {
                  attachmentsUpdate.push({
                    documentId: docId,
                    attachmentId,
                    attachmentData,
                    digest: (0, _utils$u.defaultHashSha256)(attachmentData.data)
                  });
                }
              }
            });
          }
        }
      }
      if (attachmentError) {
        errors[docId] = attachmentError;
      } else {
        bulkUpdateDocs.push(updatedRow);
        if (!newestRow || newestRow.document._meta.lwt < updatedRow.document._meta.lwt) {
          newestRow = updatedRow;
        }
      }
      var writeDoc = writeRow.document;
      var eventDocumentData = null;
      var previousEventDocumentData = null;
      var operation = null;
      if (writeRow.previous && writeRow.previous._deleted && !writeDoc._deleted) {
        operation = "INSERT";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc;
      } else if (writeRow.previous && !writeRow.previous._deleted && !writeDoc._deleted) {
        operation = "UPDATE";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc;
        previousEventDocumentData = writeRow.previous;
      } else if (writeDoc._deleted) {
        operation = "DELETE";
        eventDocumentData = (0, _utils$u.ensureNotFalsy)(writeRow.document);
        previousEventDocumentData = writeRow.previous;
      } else {
        throw (0, _rxError$k.newRxError)("SNH", {
          args: {
            writeRow
          }
        });
      }
      var _event = {
        eventId: getUniqueDeterministicEventKey(eventBulkId, rowId, docId, writeRow),
        documentId: docId,
        documentData: eventDocumentData,
        previousDocumentData: previousEventDocumentData,
        operation,
        startTime,
        endTime: (0, _utils$u.now)()
      };
      changeByDocId.set(docId, _event);
      eventBulkEvents.push(_event);
    }
  };
  for (var rowId = 0; rowId < rowAmount; rowId++) {
    if (_loop())
      continue;
  }
  return {
    bulkInsertDocs,
    bulkUpdateDocs,
    newestRow,
    errors,
    changeByDocId,
    eventBulk,
    attachmentsAdd,
    attachmentsRemove,
    attachmentsUpdate
  };
}
function stripAttachmentsDataFromRow(writeRow) {
  return {
    previous: writeRow.previous,
    document: stripAttachmentsDataFromDocument(writeRow.document)
  };
}
function getAttachmentSize(attachmentBase64String) {
  return atob(attachmentBase64String).length;
}
function attachmentWriteDataToNormalData(writeData) {
  var data = writeData.data;
  if (!data) {
    return writeData;
  }
  var ret = {
    digest: (0, _utils$u.defaultHashSha256)(data),
    length: getAttachmentSize(data),
    type: writeData.type
  };
  return ret;
}
function stripAttachmentsDataFromDocument(doc) {
  var useDoc = (0, _utils$u.flatClone)(doc);
  useDoc._attachments = {};
  Object.entries(doc._attachments).forEach(([attachmentId, attachmentData]) => {
    useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);
  });
  return useDoc;
}
function flatCloneDocWithMeta(doc) {
  var ret = (0, _utils$u.flatClone)(doc);
  ret._meta = (0, _utils$u.flatClone)(doc._meta);
  return ret;
}
function getUniqueDeterministicEventKey(eventBulkId, rowId, docId, writeRow) {
  return eventBulkId + "|" + rowId + "|" + docId + "|" + writeRow.document._rev;
}
function getWrappedStorageInstance(database, storageInstance, rxJsonSchema) {
  _overwritable$8.overwritable.deepFreezeWhenDevMode(rxJsonSchema);
  var primaryPath = (0, _rxSchemaHelper$e.getPrimaryFieldOfPrimaryKey)(rxJsonSchema.primaryKey);
  function transformDocumentDataFromRxDBToRxStorage(writeRow) {
    var data = (0, _utils$u.flatClone)(writeRow.document);
    data._meta = (0, _utils$u.flatClone)(data._meta);
    if (_overwritable$8.overwritable.isDevMode()) {
      data = (0, _rxSchemaHelper$e.fillPrimaryKey)(primaryPath, rxJsonSchema, data);
      if (writeRow.previous)
        ;
      if (writeRow.previous) {
        Object.keys(writeRow.previous._meta).forEach((metaFieldName) => {
          if (!writeRow.document._meta.hasOwnProperty(metaFieldName)) {
            throw (0, _rxError$k.newRxError)("SNH", {
              dataBefore: writeRow.previous,
              dataAfter: writeRow.document
            });
          }
        });
      }
    }
    data._meta.lwt = (0, _utils$u.now)();
    data._rev = (0, _utils$u.createRevision)(database.token, writeRow.previous);
    return {
      document: data,
      previous: writeRow.previous
    };
  }
  var ret = {
    originalStorageInstance: storageInstance,
    schema: storageInstance.schema,
    internals: storageInstance.internals,
    collectionName: storageInstance.collectionName,
    databaseName: storageInstance.databaseName,
    options: storageInstance.options,
    bulkWrite(rows, context2) {
      var toStorageWriteRows = rows.map((row) => transformDocumentDataFromRxDBToRxStorage(row));
      return database.lockedRun(() => storageInstance.bulkWrite(toStorageWriteRows, context2)).then((writeResult) => {
        var reInsertErrors = Object.values(writeResult.error).filter((error) => {
          if (error.status === 409 && !error.writeRow.previous && !error.writeRow.document._deleted && (0, _utils$u.ensureNotFalsy)(error.documentInDb)._deleted) {
            return true;
          }
          return false;
        });
        if (reInsertErrors.length > 0) {
          var useWriteResult = {
            error: (0, _utils$u.flatClone)(writeResult.error),
            success: (0, _utils$u.flatClone)(writeResult.success)
          };
          var reInserts = reInsertErrors.map((error) => {
            delete useWriteResult.error[error.documentId];
            return {
              previous: error.documentInDb,
              document: Object.assign({}, error.writeRow.document, {
                _rev: (0, _utils$u.createRevision)(database.token, error.documentInDb)
              })
            };
          });
          return database.lockedRun(() => storageInstance.bulkWrite(reInserts, context2)).then((subResult) => {
            useWriteResult.error = Object.assign(useWriteResult.error, subResult.error);
            useWriteResult.success = Object.assign(useWriteResult.success, subResult.success);
            return useWriteResult;
          });
        }
        return writeResult;
      });
    },
    query(preparedQuery) {
      return database.lockedRun(() => storageInstance.query(preparedQuery));
    },
    count(preparedQuery) {
      return database.lockedRun(() => storageInstance.count(preparedQuery));
    },
    findDocumentsById(ids, deleted) {
      return database.lockedRun(() => storageInstance.findDocumentsById(ids, deleted));
    },
    getAttachmentData(documentId, attachmentId, digest) {
      return database.lockedRun(() => storageInstance.getAttachmentData(documentId, attachmentId, digest));
    },
    getChangedDocumentsSince(limit2, checkpoint2) {
      return database.lockedRun(() => storageInstance.getChangedDocumentsSince((0, _utils$u.ensureNotFalsy)(limit2), checkpoint2));
    },
    cleanup(minDeletedTime) {
      return database.lockedRun(() => storageInstance.cleanup(minDeletedTime));
    },
    remove() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.remove());
    },
    close() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.close());
    },
    changeStream() {
      return storageInstance.changeStream();
    },
    conflictResultionTasks() {
      return storageInstance.conflictResultionTasks();
    },
    resolveConflictResultionTask(taskSolution) {
      if (taskSolution.output.isEqual) {
        return storageInstance.resolveConflictResultionTask(taskSolution);
      }
      var doc = Object.assign({}, taskSolution.output.documentData, {
        _meta: (0, _utils$u.getDefaultRxDocumentMeta)(),
        _rev: (0, _utils$u.getDefaultRevision)(),
        _attachments: {}
      });
      var documentData = (0, _utils$u.flatClone)(doc);
      delete documentData._meta;
      delete documentData._rev;
      delete documentData._attachments;
      return storageInstance.resolveConflictResultionTask({
        id: taskSolution.id,
        output: {
          isEqual: false,
          documentData
        }
      });
    }
  };
  database.storageInstances.add(ret);
  return ret;
}
function ensureRxStorageInstanceParamsAreCorrect(params) {
  if (params.schema.keyCompression) {
    throw (0, _rxError$k.newRxError)("UT5", {
      args: {
        params
      }
    });
  }
  if (hasEncryption(params.schema)) {
    throw (0, _rxError$k.newRxError)("UT6", {
      args: {
        params
      }
    });
  }
  if (params.schema.attachments && params.schema.attachments.compression) {
    throw (0, _rxError$k.newRxError)("UT7", {
      args: {
        params
      }
    });
  }
}
function hasEncryption(jsonSchema2) {
  if (!!jsonSchema2.encrypted && jsonSchema2.encrypted.length > 0 || jsonSchema2.attachments && jsonSchema2.attachments.encrypted) {
    return true;
  } else {
    return false;
  }
}
Object.defineProperty(rxStorageRemote, "__esModule", {
  value: true
});
rxStorageRemote.RxStorageRemote = rxStorageRemote.RxStorageInstanceRemote = void 0;
rxStorageRemote.getRxStorageRemote = getRxStorageRemote;
var _rxjs$a = cjs;
var _utils$t = utils;
var _messageChannelCache = messageChannelCache;
var _rxStorageHelper$b = rxStorageHelper;
var RxStorageRemote = /* @__PURE__ */ function() {
  function RxStorageRemote2(settings) {
    this.name = "remote";
    this.seed = (0, _utils$t.randomCouchString)(10);
    this.lastRequestId = 0;
    this.settings = settings;
    this.statics = settings.statics;
    if (settings.mode === "one") {
      this.messageChannelIfOneMode = (0, _messageChannelCache.getMessageChannel)(settings, [], true);
    }
  }
  var _proto = RxStorageRemote2.prototype;
  _proto.getRequestId = function getRequestId() {
    var newId = this.lastRequestId++;
    return this.seed + "|" + newId;
  };
  _proto.createStorageInstance = async function createStorageInstance(params) {
    (0, _rxStorageHelper$b.ensureRxStorageInstanceParamsAreCorrect)(params);
    var connectionId = "c|" + this.getRequestId();
    var cacheKeys = ["mode-" + this.settings.mode];
    switch (this.settings.mode) {
      case "collection":
        cacheKeys.push("collection-" + params.collectionName);
      case "database":
        cacheKeys.push("database-" + params.databaseName);
      case "storage":
        cacheKeys.push("seed-" + this.seed);
    }
    var messageChannel = await (this.messageChannelIfOneMode ? this.messageChannelIfOneMode : (0, _messageChannelCache.getMessageChannel)(this.settings, cacheKeys));
    var requestId = this.getRequestId();
    var waitForOkPromise = (0, _rxjs$a.firstValueFrom)(messageChannel.messages$.pipe((0, _rxjs$a.filter)((msg) => msg.answerTo === requestId)));
    messageChannel.send({
      connectionId,
      method: "create",
      requestId,
      params
    });
    var waitForOkResult = await waitForOkPromise;
    if (waitForOkResult.error) {
      throw new Error("could not create instance " + JSON.stringify(waitForOkResult.error));
    }
    return new RxStorageInstanceRemote(this, params.databaseName, params.collectionName, params.schema, {
      params,
      connectionId,
      messageChannel
    }, params.options);
  };
  _proto.customRequest = async function customRequest(data) {
    var messageChannel = await this.settings.messageChannelCreator();
    var requestId = this.getRequestId();
    var connectionId = "custom|request|" + requestId;
    var waitForAnswerPromise = (0, _rxjs$a.firstValueFrom)(messageChannel.messages$.pipe((0, _rxjs$a.filter)((msg) => msg.answerTo === requestId)));
    messageChannel.send({
      connectionId,
      method: "custom",
      requestId,
      params: data
    });
    var response = await waitForAnswerPromise;
    if (response.error) {
      await messageChannel.close();
      throw new Error("could not run customRequest(): " + JSON.stringify({
        data,
        error: response.error
      }));
    } else {
      await messageChannel.close();
      return response.return;
    }
  };
  return RxStorageRemote2;
}();
rxStorageRemote.RxStorageRemote = RxStorageRemote;
function getMessageReturn(msg) {
  if (msg.method === "getAttachmentData") {
    return msg.return;
  } else {
    if (typeof msg.return === "string") {
      return JSON.parse(msg.return);
    } else {
      return msg.return;
    }
  }
}
var RxStorageInstanceRemote = /* @__PURE__ */ function() {
  function RxStorageInstanceRemote2(storage, databaseName, collectionName, schema, internals, options2) {
    this.changes$ = new _rxjs$a.Subject();
    this.conflicts$ = new _rxjs$a.Subject();
    this.subs = [];
    this.closed = false;
    this.storage = storage;
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.schema = schema;
    this.internals = internals;
    this.options = options2;
    this.messages$ = this.internals.messageChannel.messages$.pipe((0, _rxjs$a.filter)((msg) => msg.connectionId === this.internals.connectionId));
    this.subs.push(this.messages$.subscribe((msg) => {
      if (msg.method === "changeStream") {
        this.changes$.next(getMessageReturn(msg));
      }
      if (msg.method === "conflictResultionTasks") {
        this.conflicts$.next(msg.return);
      }
    }));
  }
  var _proto2 = RxStorageInstanceRemote2.prototype;
  _proto2.requestRemote = async function requestRemote(methodName, params) {
    var requestId = this.storage.getRequestId();
    var responsePromise = (0, _rxjs$a.firstValueFrom)(this.messages$.pipe((0, _rxjs$a.filter)((msg) => msg.answerTo === requestId)));
    var message = {
      connectionId: this.internals.connectionId,
      requestId,
      method: methodName,
      params
    };
    this.internals.messageChannel.send(message);
    var response = await responsePromise;
    if (response.error) {
      throw new Error("could not requestRemote: " + JSON.stringify({
        methodName,
        params,
        error: response.error
      }, null, 4));
    } else {
      return getMessageReturn(response);
    }
  };
  _proto2.bulkWrite = function bulkWrite(documentWrites, context2) {
    return this.requestRemote("bulkWrite", [documentWrites, context2]);
  };
  _proto2.findDocumentsById = function findDocumentsById(ids, deleted) {
    return this.requestRemote("findDocumentsById", [ids, deleted]);
  };
  _proto2.query = function query2(preparedQuery) {
    return this.requestRemote("query", [preparedQuery]);
  };
  _proto2.count = function count2(preparedQuery) {
    return this.requestRemote("count", [preparedQuery]);
  };
  _proto2.getAttachmentData = function getAttachmentData(documentId, attachmentId, digest) {
    return this.requestRemote("getAttachmentData", [documentId, attachmentId, digest]);
  };
  _proto2.getChangedDocumentsSince = function getChangedDocumentsSince(limit2, checkpoint2) {
    return this.requestRemote("getChangedDocumentsSince", [limit2, checkpoint2]);
  };
  _proto2.changeStream = function changeStream() {
    return this.changes$.asObservable();
  };
  _proto2.cleanup = function cleanup(minDeletedTime) {
    return this.requestRemote("cleanup", [minDeletedTime]);
  };
  _proto2.close = async function close3() {
    if (this.closed) {
      return Promise.reject(new Error("already closed"));
    }
    this.closed = true;
    this.subs.forEach((sub) => sub.unsubscribe());
    this.changes$.complete();
    await this.requestRemote("close", []);
    await (0, _messageChannelCache.closeMessageChannel)(this.internals.messageChannel);
  };
  _proto2.remove = async function remove() {
    this.closed = true;
    await this.requestRemote("remove", []);
    await (0, _messageChannelCache.closeMessageChannel)(this.internals.messageChannel);
  };
  _proto2.conflictResultionTasks = function conflictResultionTasks() {
    return this.conflicts$;
  };
  _proto2.resolveConflictResultionTask = async function resolveConflictResultionTask(taskSolution) {
    await this.requestRemote("resolveConflictResultionTask", [taskSolution]);
  };
  return RxStorageInstanceRemote2;
}();
rxStorageRemote.RxStorageInstanceRemote = RxStorageInstanceRemote;
function getRxStorageRemote(settings) {
  var withDefaults = Object.assign({
    mode: "storage"
  }, settings);
  return new RxStorageRemote(withDefaults);
}
var storageRemoteTypes = {};
var storageRemoteHelpers = {};
Object.defineProperty(storageRemoteHelpers, "__esModule", {
  value: true
});
storageRemoteHelpers.createAnswer = createAnswer;
storageRemoteHelpers.createErrorAnswer = createErrorAnswer;
var _utils$s = utils;
function createErrorAnswer(msg, error) {
  return {
    connectionId: msg.connectionId,
    answerTo: msg.requestId,
    method: msg.method,
    error: (0, _utils$s.errorToPlainJson)(error)
  };
}
function createAnswer(msg, ret) {
  return {
    connectionId: msg.connectionId,
    answerTo: msg.requestId,
    method: msg.method,
    return: ret
  };
}
var remote = {};
Object.defineProperty(remote, "__esModule", {
  value: true
});
remote.exposeRxStorageRemote = exposeRxStorageRemote;
var _rxjs$9 = cjs;
var _utils$r = utils;
var _storageRemoteHelpers = storageRemoteHelpers;
function exposeRxStorageRemote(settings) {
  var instanceByFullName = /* @__PURE__ */ new Map();
  settings.messages$.pipe((0, _rxjs$9.filter)((msg) => msg.method === "custom")).subscribe(async (msg) => {
    if (!settings.customRequestHandler) {
      settings.send((0, _storageRemoteHelpers.createErrorAnswer)(msg, new Error("Remote storage: cannot resolve custom request because settings.customRequestHandler is not set")));
    } else {
      try {
        var result = await settings.customRequestHandler(msg.params);
        settings.send((0, _storageRemoteHelpers.createAnswer)(msg, result));
      } catch (err) {
        settings.send((0, _storageRemoteHelpers.createErrorAnswer)(msg, err));
      }
    }
  });
  function getRxStorageInstance(params) {
    if (settings.storage) {
      return settings.storage.createStorageInstance(params);
    } else if (settings.database) {
      var storageInstances = Array.from(settings.database.storageInstances);
      var collectionName = params.collectionName;
      var storageInstance = storageInstances.find((instance) => instance.collectionName === collectionName);
      if (!storageInstance) {
        console.dir(storageInstances);
        throw new Error("storageInstance does not exist " + JSON.stringify({
          collectionName
        }));
      }
      var schema = params.schema;
      if (!(0, _utils$r.deepEqual)(schema, storageInstance.schema)) {
        throw new Error("Wrong schema " + JSON.stringify({
          schema,
          existingSchema: storageInstance.schema
        }));
      }
      return Promise.resolve(storageInstance);
    } else {
      throw new Error("no base given");
    }
  }
  settings.messages$.pipe((0, _rxjs$9.filter)((msg) => msg.method === "create")).subscribe(async (msg) => {
    var connectionId = msg.connectionId;
    if (Array.isArray(msg.params)) {
      return;
    }
    var params = msg.params;
    var collectionName = params.collectionName;
    var fullName = [params.databaseName, params.collectionName, params.schema.version].join("|");
    var state = instanceByFullName.get(fullName);
    if (!state) {
      try {
        state = {
          /**
           * We work with a promise here to ensure
           * that parallel create-calls will still end up
           * with exactly one instance and not more.
           */
          storageInstancePromise: getRxStorageInstance(params),
          connectionIds: /* @__PURE__ */ new Set(),
          params
        };
        instanceByFullName.set(fullName, state);
      } catch (err) {
        settings.send((0, _storageRemoteHelpers.createErrorAnswer)(msg, err));
        return;
      }
    } else {
      if (!(0, _utils$r.deepEqual)(params.schema, state.params.schema)) {
        settings.send((0, _storageRemoteHelpers.createErrorAnswer)(msg, new Error("Remote storage: schema not equal to existing storage")));
        return;
      }
    }
    state.connectionIds.add(msg.connectionId);
    var subs = [];
    var storageInstance = await state.storageInstancePromise;
    subs.push(storageInstance.changeStream().subscribe((changes) => {
      var message = {
        connectionId,
        answerTo: "changestream",
        method: "changeStream",
        return: changes
      };
      settings.send(message);
    }));
    subs.push(storageInstance.conflictResultionTasks().subscribe((conflicts2) => {
      var message = {
        connectionId,
        answerTo: "conflictResultionTasks",
        method: "conflictResultionTasks",
        return: conflicts2
      };
      settings.send(message);
    }));
    var connectionClosed = false;
    function closeThisConnection() {
      if (connectionClosed) {
        return;
      }
      connectionClosed = true;
      subs.forEach((sub) => sub.unsubscribe());
      (0, _utils$r.ensureNotFalsy)(state).connectionIds.delete(connectionId);
      instanceByFullName.delete(fullName);
    }
    if (settings.database) {
      var database = settings.database;
      var collection = database.collections[collectionName];
      if (collection) {
        collection.onDestroy.push(() => closeThisConnection());
      } else {
        database.onDestroy.push(() => closeThisConnection());
      }
    }
    subs.push(settings.messages$.pipe((0, _rxjs$9.filter)((subMsg) => subMsg.connectionId === connectionId)).subscribe(async (plainMessage) => {
      var message = plainMessage;
      if (message.method === "create" || message.method === "custom") {
        return;
      }
      if (!Array.isArray(message.params)) {
        return;
      }
      var result;
      try {
        if (message.method === "close" && settings.database) {
          settings.send((0, _storageRemoteHelpers.createAnswer)(message, null));
          return;
        }
        if (message.method === "close" && (0, _utils$r.ensureNotFalsy)(state).connectionIds.size > 1) {
          settings.send((0, _storageRemoteHelpers.createAnswer)(message, null));
          (0, _utils$r.ensureNotFalsy)(state).connectionIds.delete(connectionId);
          subs.forEach((sub) => sub.unsubscribe());
          return;
        }
        result = await storageInstance[message.method](message.params[0], message.params[1], message.params[2], message.params[3]);
        if (message.method === "close" || message.method === "remove") {
          closeThisConnection();
        }
        settings.send((0, _storageRemoteHelpers.createAnswer)(message, result));
      } catch (err) {
        settings.send((0, _storageRemoteHelpers.createErrorAnswer)(message, err));
      }
    }));
    settings.send((0, _storageRemoteHelpers.createAnswer)(msg, "ok"));
  });
  return {
    instanceByFullName
  };
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _rxStorageRemote = rxStorageRemote;
  Object.keys(_rxStorageRemote).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageRemote[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageRemote[key];
      }
    });
  });
  var _storageRemoteTypes = storageRemoteTypes;
  Object.keys(_storageRemoteTypes).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _storageRemoteTypes[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _storageRemoteTypes[key];
      }
    });
  });
  var _storageRemoteHelpers2 = storageRemoteHelpers;
  Object.keys(_storageRemoteHelpers2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _storageRemoteHelpers2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _storageRemoteHelpers2[key];
      }
    });
  });
  var _messageChannelCache2 = messageChannelCache;
  Object.keys(_messageChannelCache2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _messageChannelCache2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _messageChannelCache2[key];
      }
    });
  });
  var _remote = remote;
  Object.keys(_remote).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _remote[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _remote[key];
      }
    });
  });
})(storageRemote);
var electronHelper = {};
Object.defineProperty(electronHelper, "__esModule", {
  value: true
});
electronHelper.IPC_RENDERER_TO_MAIN = electronHelper.IPC_RENDERER_KEY_PREFIX = void 0;
var IPC_RENDERER_KEY_PREFIX = "rxdb-ipc-renderer-storage";
electronHelper.IPC_RENDERER_KEY_PREFIX = IPC_RENDERER_KEY_PREFIX;
var IPC_RENDERER_TO_MAIN = "rxdb-renderer-to-main";
electronHelper.IPC_RENDERER_TO_MAIN = IPC_RENDERER_TO_MAIN;
Object.defineProperty(rxStorageIpcRenderer, "__esModule", {
  value: true
});
rxStorageIpcRenderer.getRxStorageIpcRenderer = getRxStorageIpcRenderer;
var _rxjs$8 = cjs;
var _storageRemote$1 = storageRemote;
var _electronHelper$1 = electronHelper;
var _utils$q = utils;
function getRxStorageIpcRenderer(settings) {
  var channelId = [_electronHelper$1.IPC_RENDERER_KEY_PREFIX, settings.key].join("|");
  var storage = (0, _storageRemote$1.getRxStorageRemote)({
    identifier: "electron-ipc-renderer",
    statics: settings.statics,
    mode: settings.mode,
    messageChannelCreator() {
      var messages$ = new _rxjs$8.Subject();
      var listener = (_event, message) => {
        messages$.next(message);
      };
      settings.ipcRenderer.on(channelId, listener);
      settings.ipcRenderer.postMessage(channelId, false);
      return Promise.resolve({
        messages$,
        send(msg) {
          settings.ipcRenderer.postMessage(channelId, msg);
        },
        close() {
          settings.ipcRenderer.removeListener(channelId, listener);
          return _utils$q.PROMISE_RESOLVE_VOID;
        }
      });
    }
  });
  return storage;
}
var rxStorageIpcMain = {};
Object.defineProperty(rxStorageIpcMain, "__esModule", {
  value: true
});
rxStorageIpcMain.exposeIpcMainRxStorage = exposeIpcMainRxStorage;
var _rxjs$7 = cjs;
var _electronHelper = electronHelper;
var _storageRemote = storageRemote;
function exposeIpcMainRxStorage(args2) {
  var channelId = [_electronHelper.IPC_RENDERER_KEY_PREFIX, args2.key].join("|");
  var messages$ = new _rxjs$7.Subject();
  var openRenderers = /* @__PURE__ */ new Set();
  args2.ipcMain.on(channelId, (event, message) => {
    openRenderers.add(event.sender);
    if (message) {
      messages$.next(message);
    }
  });
  var send = (msg) => {
    openRenderers.forEach((sender) => {
      sender.send(channelId, msg);
    });
  };
  (0, _storageRemote.exposeRxStorageRemote)({
    storage: args2.storage,
    messages$,
    send
  });
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _rxStorageIpcRenderer = rxStorageIpcRenderer;
  Object.keys(_rxStorageIpcRenderer).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageIpcRenderer[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageIpcRenderer[key];
      }
    });
  });
  var _rxStorageIpcMain = rxStorageIpcMain;
  Object.keys(_rxStorageIpcMain).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageIpcMain[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageIpcMain[key];
      }
    });
  });
})(electron);
var storageDexie = {};
var rxStorageDexie = {};
var dexieHelper = {};
const _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
const keys = Object.keys;
const isArray$1 = Array.isArray;
if (typeof Promise !== "undefined" && !_global.Promise) {
  _global.Promise = Promise;
}
function extend(obj, extension) {
  if (typeof extension !== "object")
    return obj;
  keys(extension).forEach(function(key) {
    obj[key] = extension[key];
  });
  return obj;
}
const getProto = Object.getPrototypeOf;
const _hasOwn = {}.hasOwnProperty;
function hasOwn(obj, prop) {
  return _hasOwn.call(obj, prop);
}
function props(proto, extension) {
  if (typeof extension === "function")
    extension = extension(getProto(proto));
  (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach((key) => {
    setProp(proto, key, extension[key]);
  });
}
const defineProperty = Object.defineProperty;
function setProp(obj, prop, functionOrGetSet, options2) {
  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options2));
}
function derive(Child) {
  return {
    from: function(Parent) {
      Child.prototype = Object.create(Parent.prototype);
      setProp(Child.prototype, "constructor", Child);
      return {
        extend: props.bind(null, Child.prototype)
      };
    }
  };
}
const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function getPropertyDescriptor(obj, prop) {
  const pd = getOwnPropertyDescriptor(obj, prop);
  let proto;
  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}
const _slice = [].slice;
function slice$1(args2, start, end) {
  return _slice.call(args2, start, end);
}
function override(origFunc, overridedFactory) {
  return overridedFactory(origFunc);
}
function assert(b) {
  if (!b)
    throw new Error("Assertion Failed");
}
function asap$1(fn) {
  if (_global.setImmediate)
    setImmediate(fn);
  else
    setTimeout(fn, 0);
}
function arrayToObject$1(array2, extractor) {
  return array2.reduce((result, item, i) => {
    var nameAndValue = extractor(item, i);
    if (nameAndValue)
      result[nameAndValue[0]] = nameAndValue[1];
    return result;
  }, {});
}
function tryCatch(fn, onerror, args2) {
  try {
    fn.apply(null, args2);
  } catch (ex) {
    onerror && onerror(ex);
  }
}
function getByKeyPath(obj, keyPath) {
  if (hasOwn(obj, keyPath))
    return obj[keyPath];
  if (!keyPath)
    return obj;
  if (typeof keyPath !== "string") {
    var rv = [];
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      var val = getByKeyPath(obj, keyPath[i]);
      rv.push(val);
    }
    return rv;
  }
  var period = keyPath.indexOf(".");
  if (period !== -1) {
    var innerObj = obj[keyPath.substr(0, period)];
    return innerObj === void 0 ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
  }
  return void 0;
}
function setByKeyPath(obj, keyPath, value) {
  if (!obj || keyPath === void 0)
    return;
  if ("isFrozen" in Object && Object.isFrozen(obj))
    return;
  if (typeof keyPath !== "string" && "length" in keyPath) {
    assert(typeof value !== "string" && "length" in value);
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      setByKeyPath(obj, keyPath[i], value[i]);
    }
  } else {
    var period = keyPath.indexOf(".");
    if (period !== -1) {
      var currentKeyPath = keyPath.substr(0, period);
      var remainingKeyPath = keyPath.substr(period + 1);
      if (remainingKeyPath === "")
        if (value === void 0) {
          if (isArray$1(obj) && !isNaN(parseInt(currentKeyPath)))
            obj.splice(currentKeyPath, 1);
          else
            delete obj[currentKeyPath];
        } else
          obj[currentKeyPath] = value;
      else {
        var innerObj = obj[currentKeyPath];
        if (!innerObj || !hasOwn(obj, currentKeyPath))
          innerObj = obj[currentKeyPath] = {};
        setByKeyPath(innerObj, remainingKeyPath, value);
      }
    } else {
      if (value === void 0) {
        if (isArray$1(obj) && !isNaN(parseInt(keyPath)))
          obj.splice(keyPath, 1);
        else
          delete obj[keyPath];
      } else
        obj[keyPath] = value;
    }
  }
}
function delByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string")
    setByKeyPath(obj, keyPath, void 0);
  else if ("length" in keyPath)
    [].map.call(keyPath, function(kp) {
      setByKeyPath(obj, kp, void 0);
    });
}
function shallowClone(obj) {
  var rv = {};
  for (var m in obj) {
    if (hasOwn(obj, m))
      rv[m] = obj[m];
  }
  return rv;
}
const concat$1 = [].concat;
function flatten(a) {
  return concat$1.apply([], a);
}
const intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map((num) => ["Int", "Uint", "Float"].map((t) => t + num + "Array")))).filter((t) => _global[t]);
const intrinsicTypes = intrinsicTypeNames.map((t) => _global[t]);
arrayToObject$1(intrinsicTypeNames, (x) => [x, true]);
let circularRefs = null;
function deepClone(any) {
  circularRefs = typeof WeakMap !== "undefined" && /* @__PURE__ */ new WeakMap();
  const rv = innerDeepClone(any);
  circularRefs = null;
  return rv;
}
function innerDeepClone(any) {
  if (!any || typeof any !== "object")
    return any;
  let rv = circularRefs && circularRefs.get(any);
  if (rv)
    return rv;
  if (isArray$1(any)) {
    rv = [];
    circularRefs && circularRefs.set(any, rv);
    for (var i = 0, l = any.length; i < l; ++i) {
      rv.push(innerDeepClone(any[i]));
    }
  } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
    rv = any;
  } else {
    const proto = getProto(any);
    rv = proto === Object.prototype ? {} : Object.create(proto);
    circularRefs && circularRefs.set(any, rv);
    for (var prop in any) {
      if (hasOwn(any, prop)) {
        rv[prop] = innerDeepClone(any[prop]);
      }
    }
  }
  return rv;
}
const { toString: toString$1 } = {};
function toStringTag(o) {
  return toString$1.call(o).slice(8, -1);
}
const iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
const getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
  var i;
  return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function() {
  return null;
};
const NO_CHAR_ARRAY = {};
function getArrayOf(arrayLike) {
  var i, a, x, it;
  if (arguments.length === 1) {
    if (isArray$1(arrayLike))
      return arrayLike.slice();
    if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
      return [arrayLike];
    if (it = getIteratorOf(arrayLike)) {
      a = [];
      while (x = it.next(), !x.done)
        a.push(x.value);
      return a;
    }
    if (arrayLike == null)
      return [arrayLike];
    i = arrayLike.length;
    if (typeof i === "number") {
      a = new Array(i);
      while (i--)
        a[i] = arrayLike[i];
      return a;
    }
    return [arrayLike];
  }
  i = arguments.length;
  a = new Array(i);
  while (i--)
    a[i] = arguments[i];
  return a;
}
const isAsyncFunction = typeof Symbol !== "undefined" ? (fn) => fn[Symbol.toStringTag] === "AsyncFunction" : () => false;
var debug$1 = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function setDebug(value, filter2) {
  debug$1 = value;
  libraryFilter = filter2;
}
var libraryFilter = () => true;
const NEEDS_THROW_FOR_STACK = !new Error("").stack;
function getErrorWithStack() {
  if (NEEDS_THROW_FOR_STACK)
    try {
      getErrorWithStack.arguments;
      throw new Error();
    } catch (e) {
      return e;
    }
  return new Error();
}
function prettyStack(exception, numIgnoredFrames) {
  var stack = exception.stack;
  if (!stack)
    return "";
  numIgnoredFrames = numIgnoredFrames || 0;
  if (stack.indexOf(exception.name) === 0)
    numIgnoredFrames += (exception.name + exception.message).split("\n").length;
  return stack.split("\n").slice(numIgnoredFrames).filter(libraryFilter).map((frame) => "\n" + frame).join("");
}
var dexieErrorNames = [
  "Modify",
  "Bulk",
  "OpenFailed",
  "VersionChange",
  "Schema",
  "Upgrade",
  "InvalidTable",
  "MissingAPI",
  "NoSuchDatabase",
  "InvalidArgument",
  "SubTransaction",
  "Unsupported",
  "Internal",
  "DatabaseClosed",
  "PrematureCommit",
  "ForeignAwait"
];
var idbDomErrorNames = [
  "Unknown",
  "Constraint",
  "Data",
  "TransactionInactive",
  "ReadOnly",
  "Version",
  "NotFound",
  "InvalidState",
  "InvalidAccess",
  "Abort",
  "Timeout",
  "QuotaExceeded",
  "Syntax",
  "DataClone"
];
var errorList = dexieErrorNames.concat(idbDomErrorNames);
var defaultTexts = {
  VersionChanged: "Database version changed by other database connection",
  DatabaseClosed: "Database has been closed",
  Abort: "Transaction aborted",
  TransactionInactive: "Transaction has already completed or failed",
  MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
};
function DexieError(name, msg) {
  this._e = getErrorWithStack();
  this.name = name;
  this.message = msg;
}
derive(DexieError).from(Error).extend({
  stack: {
    get: function() {
      return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
    }
  },
  toString: function() {
    return this.name + ": " + this.message;
  }
});
function getMultiErrorMessage(msg, failures) {
  return msg + ". Errors: " + Object.keys(failures).map((key) => failures[key].toString()).filter((v, i, s) => s.indexOf(v) === i).join("\n");
}
function ModifyError(msg, failures, successCount, failedKeys) {
  this._e = getErrorWithStack();
  this.failures = failures;
  this.failedKeys = failedKeys;
  this.successCount = successCount;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(ModifyError).from(DexieError);
function BulkError(msg, failures) {
  this._e = getErrorWithStack();
  this.name = "BulkError";
  this.failures = Object.keys(failures).map((pos) => failures[pos]);
  this.failuresByPos = failures;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(BulkError).from(DexieError);
var errnames = errorList.reduce((obj, name) => (obj[name] = name + "Error", obj), {});
const BaseException = DexieError;
var exceptions = errorList.reduce((obj, name) => {
  var fullName = name + "Error";
  function DexieError2(msgOrInner, inner) {
    this._e = getErrorWithStack();
    this.name = fullName;
    if (!msgOrInner) {
      this.message = defaultTexts[name] || fullName;
      this.inner = null;
    } else if (typeof msgOrInner === "string") {
      this.message = `${msgOrInner}${!inner ? "" : "\n " + inner}`;
      this.inner = inner || null;
    } else if (typeof msgOrInner === "object") {
      this.message = `${msgOrInner.name} ${msgOrInner.message}`;
      this.inner = msgOrInner;
    }
  }
  derive(DexieError2).from(BaseException);
  obj[name] = DexieError2;
  return obj;
}, {});
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;
var exceptionMap = idbDomErrorNames.reduce((obj, name) => {
  obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
function mapError(domError, message) {
  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
    return domError;
  var rv = new exceptionMap[domError.name](message || domError.message, domError);
  if ("stack" in domError) {
    setProp(rv, "stack", { get: function() {
      return this.inner.stack;
    } });
  }
  return rv;
}
var fullNameExceptions = errorList.reduce((obj, name) => {
  if (["Syntax", "Type", "Range"].indexOf(name) === -1)
    obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;
function nop() {
}
function mirror(val) {
  return val;
}
function pureFunctionChain(f1, f2) {
  if (f1 == null || f1 === mirror)
    return f2;
  return function(val) {
    return f2(f1(val));
  };
}
function callBoth(on1, on2) {
  return function() {
    on1.apply(this, arguments);
    on2.apply(this, arguments);
  };
}
function hookCreatingChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res !== void 0)
      arguments[0] = res;
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res2 !== void 0 ? res2 : res;
  };
}
function hookDeletingChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    f1.apply(this, arguments);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = this.onerror = null;
    f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
  };
}
function hookUpdatingChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function(modifications) {
    var res = f1.apply(this, arguments);
    extend(modifications, res);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
  };
}
function reverseStoppableEventChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    if (f2.apply(this, arguments) === false)
      return false;
    return f1.apply(this, arguments);
  };
}
function promisableChain(f1, f2) {
  if (f1 === nop)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res && typeof res.then === "function") {
      var thiz = this, i = arguments.length, args2 = new Array(i);
      while (i--)
        args2[i] = arguments[i];
      return res.then(function() {
        return f2.apply(thiz, args2);
      });
    }
    return f2.apply(this, arguments);
  };
}
var INTERNAL = {};
const LONG_STACKS_CLIP_LIMIT = 100, MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === "undefined" ? [] : (() => {
  let globalP = Promise.resolve();
  if (typeof crypto === "undefined" || !crypto.subtle)
    return [globalP, getProto(globalP), globalP];
  const nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [
    nativeP,
    getProto(nativeP),
    globalP
  ];
})(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
const NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
const patchGlobalPromise = !!resolvedGlobalPromise;
var stack_being_generated = false;
var schedulePhysicalTick = resolvedGlobalPromise ? () => {
  resolvedGlobalPromise.then(physicalTick);
} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {
  var hiddenDiv = document.createElement("div");
  new MutationObserver(() => {
    physicalTick();
    hiddenDiv = null;
  }).observe(hiddenDiv, { attributes: true });
  hiddenDiv.setAttribute("i", "1");
} : () => {
  setTimeout(physicalTick, 0);
};
var asap = function(callback, args2) {
  microtickQueue.push([callback, args2]);
  if (needsNewPhysicalTick) {
    schedulePhysicalTick();
    needsNewPhysicalTick = false;
  }
};
var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], currentFulfiller = null, rejectionMapper = mirror;
var globalPSD = {
  id: "global",
  global: true,
  ref: 0,
  unhandleds: [],
  onunhandled: globalError,
  pgp: false,
  env: {},
  finalize: function() {
    this.unhandleds.forEach((uh) => {
      try {
        globalError(uh[0], uh[1]);
      } catch (e) {
      }
    });
  }
};
var PSD = globalPSD;
var microtickQueue = [];
var numScheduledCalls = 0;
var tickFinalizers = [];
function DexiePromise(fn) {
  if (typeof this !== "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [];
  this.onuncatched = nop;
  this._lib = false;
  var psd = this._PSD = PSD;
  if (debug$1) {
    this._stackHolder = getErrorWithStack();
    this._prev = null;
    this._numPrev = 0;
  }
  if (typeof fn !== "function") {
    if (fn !== INTERNAL)
      throw new TypeError("Not a function");
    this._state = arguments[1];
    this._value = arguments[2];
    if (this._state === false)
      handleRejection(this, this._value);
    return;
  }
  this._state = null;
  this._value = null;
  ++psd.ref;
  executePromiseTask(this, fn);
}
const thenProp = {
  get: function() {
    var psd = PSD, microTaskId = totalEchoes;
    function then(onFulfilled, onRejected) {
      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
      const cleanup = possibleAwait && !decrementExpectedAwaits();
      var rv = new DexiePromise((resolve, reject) => {
        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
      });
      debug$1 && linkToPreviousPromise(rv, this);
      return rv;
    }
    then.prototype = INTERNAL;
    return then;
  },
  set: function(value) {
    setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
      get: function() {
        return value;
      },
      set: thenProp.set
    });
  }
};
props(DexiePromise.prototype, {
  then: thenProp,
  _then: function(onFulfilled, onRejected) {
    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
  },
  catch: function(onRejected) {
    if (arguments.length === 1)
      return this.then(null, onRejected);
    var type2 = arguments[0], handler = arguments[1];
    return typeof type2 === "function" ? this.then(null, (err) => err instanceof type2 ? handler(err) : PromiseReject(err)) : this.then(null, (err) => err && err.name === type2 ? handler(err) : PromiseReject(err));
  },
  finally: function(onFinally) {
    return this.then((value) => {
      onFinally();
      return value;
    }, (err) => {
      onFinally();
      return PromiseReject(err);
    });
  },
  stack: {
    get: function() {
      if (this._stack)
        return this._stack;
      try {
        stack_being_generated = true;
        var stacks = getStack(this, [], MAX_LONG_STACKS);
        var stack = stacks.join("\nFrom previous: ");
        if (this._state !== null)
          this._stack = stack;
        return stack;
      } finally {
        stack_being_generated = false;
      }
    }
  },
  timeout: function(ms, msg) {
    return ms < Infinity ? new DexiePromise((resolve, reject) => {
      var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);
      this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
    }) : this;
  }
});
if (typeof Symbol !== "undefined" && Symbol.toStringTag)
  setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
globalPSD.env = snapShot();
function Listener(onFulfilled, onRejected, resolve, reject, zone) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.resolve = resolve;
  this.reject = reject;
  this.psd = zone;
}
props(DexiePromise, {
  all: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise(function(resolve, reject) {
      if (values.length === 0)
        resolve([]);
      var remaining = values.length;
      values.forEach((a, i) => DexiePromise.resolve(a).then((x) => {
        values[i] = x;
        if (!--remaining)
          resolve(values);
      }, reject));
    });
  },
  resolve: (value) => {
    if (value instanceof DexiePromise)
      return value;
    if (value && typeof value.then === "function")
      return new DexiePromise((resolve, reject) => {
        value.then(resolve, reject);
      });
    var rv = new DexiePromise(INTERNAL, true, value);
    linkToPreviousPromise(rv, currentFulfiller);
    return rv;
  },
  reject: PromiseReject,
  race: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise((resolve, reject) => {
      values.map((value) => DexiePromise.resolve(value).then(resolve, reject));
    });
  },
  PSD: {
    get: () => PSD,
    set: (value) => PSD = value
  },
  totalEchoes: { get: () => totalEchoes },
  newPSD: newScope,
  usePSD,
  scheduler: {
    get: () => asap,
    set: (value) => {
      asap = value;
    }
  },
  rejectionMapper: {
    get: () => rejectionMapper,
    set: (value) => {
      rejectionMapper = value;
    }
  },
  follow: (fn, zoneProps) => {
    return new DexiePromise((resolve, reject) => {
      return newScope((resolve2, reject2) => {
        var psd = PSD;
        psd.unhandleds = [];
        psd.onunhandled = reject2;
        psd.finalize = callBoth(function() {
          run_at_end_of_this_or_next_physical_tick(() => {
            this.unhandleds.length === 0 ? resolve2() : reject2(this.unhandleds[0]);
          });
        }, psd.finalize);
        fn();
      }, zoneProps, resolve, reject);
    });
  }
});
if (NativePromise) {
  if (NativePromise.allSettled)
    setProp(DexiePromise, "allSettled", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve) => {
        if (possiblePromises.length === 0)
          resolve([]);
        let remaining = possiblePromises.length;
        const results = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => results[i] = { status: "fulfilled", value }, (reason) => results[i] = { status: "rejected", reason }).then(() => --remaining || resolve(results)));
      });
    });
  if (NativePromise.any && typeof AggregateError !== "undefined")
    setProp(DexiePromise, "any", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve, reject) => {
        if (possiblePromises.length === 0)
          reject(new AggregateError([]));
        let remaining = possiblePromises.length;
        const failures = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => resolve(value), (failure) => {
          failures[i] = failure;
          if (!--remaining)
            reject(new AggregateError(failures));
        }));
      });
    });
}
function executePromiseTask(promise, fn) {
  try {
    fn((value) => {
      if (promise._state !== null)
        return;
      if (value === promise)
        throw new TypeError("A promise cannot be resolved with itself.");
      var shouldExecuteTick = promise._lib && beginMicroTickScope();
      if (value && typeof value.then === "function") {
        executePromiseTask(promise, (resolve, reject) => {
          value instanceof DexiePromise ? value._then(resolve, reject) : value.then(resolve, reject);
        });
      } else {
        promise._state = true;
        promise._value = value;
        propagateAllListeners(promise);
      }
      if (shouldExecuteTick)
        endMicroTickScope();
    }, handleRejection.bind(null, promise));
  } catch (ex) {
    handleRejection(promise, ex);
  }
}
function handleRejection(promise, reason) {
  rejectingErrors.push(reason);
  if (promise._state !== null)
    return;
  var shouldExecuteTick = promise._lib && beginMicroTickScope();
  reason = rejectionMapper(reason);
  promise._state = false;
  promise._value = reason;
  debug$1 && reason !== null && typeof reason === "object" && !reason._promise && tryCatch(() => {
    var origProp = getPropertyDescriptor(reason, "stack");
    reason._promise = promise;
    setProp(reason, "stack", {
      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack
    });
  });
  addPossiblyUnhandledError(promise);
  propagateAllListeners(promise);
  if (shouldExecuteTick)
    endMicroTickScope();
}
function propagateAllListeners(promise) {
  var listeners = promise._listeners;
  promise._listeners = [];
  for (var i = 0, len = listeners.length; i < len; ++i) {
    propagateToListener(promise, listeners[i]);
  }
  var psd = promise._PSD;
  --psd.ref || psd.finalize();
  if (numScheduledCalls === 0) {
    ++numScheduledCalls;
    asap(() => {
      if (--numScheduledCalls === 0)
        finalizePhysicalTick();
    }, []);
  }
}
function propagateToListener(promise, listener) {
  if (promise._state === null) {
    promise._listeners.push(listener);
    return;
  }
  var cb = promise._state ? listener.onFulfilled : listener.onRejected;
  if (cb === null) {
    return (promise._state ? listener.resolve : listener.reject)(promise._value);
  }
  ++listener.psd.ref;
  ++numScheduledCalls;
  asap(callListener, [cb, promise, listener]);
}
function callListener(cb, promise, listener) {
  try {
    currentFulfiller = promise;
    var ret, value = promise._value;
    if (promise._state) {
      ret = cb(value);
    } else {
      if (rejectingErrors.length)
        rejectingErrors = [];
      ret = cb(value);
      if (rejectingErrors.indexOf(value) === -1)
        markErrorAsHandled(promise);
    }
    listener.resolve(ret);
  } catch (e) {
    listener.reject(e);
  } finally {
    currentFulfiller = null;
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
    --listener.psd.ref || listener.psd.finalize();
  }
}
function getStack(promise, stacks, limit2) {
  if (stacks.length === limit2)
    return stacks;
  var stack = "";
  if (promise._state === false) {
    var failure = promise._value, errorName, message;
    if (failure != null) {
      errorName = failure.name || "Error";
      message = failure.message || failure;
      stack = prettyStack(failure, 0);
    } else {
      errorName = failure;
      message = "";
    }
    stacks.push(errorName + (message ? ": " + message : "") + stack);
  }
  if (debug$1) {
    stack = prettyStack(promise._stackHolder, 2);
    if (stack && stacks.indexOf(stack) === -1)
      stacks.push(stack);
    if (promise._prev)
      getStack(promise._prev, stacks, limit2);
  }
  return stacks;
}
function linkToPreviousPromise(promise, prev) {
  var numPrev = prev ? prev._numPrev + 1 : 0;
  if (numPrev < LONG_STACKS_CLIP_LIMIT) {
    promise._prev = prev;
    promise._numPrev = numPrev;
  }
}
function physicalTick() {
  beginMicroTickScope() && endMicroTickScope();
}
function beginMicroTickScope() {
  var wasRootExec = isOutsideMicroTick;
  isOutsideMicroTick = false;
  needsNewPhysicalTick = false;
  return wasRootExec;
}
function endMicroTickScope() {
  var callbacks, i, l;
  do {
    while (microtickQueue.length > 0) {
      callbacks = microtickQueue;
      microtickQueue = [];
      l = callbacks.length;
      for (i = 0; i < l; ++i) {
        var item = callbacks[i];
        item[0].apply(null, item[1]);
      }
    }
  } while (microtickQueue.length > 0);
  isOutsideMicroTick = true;
  needsNewPhysicalTick = true;
}
function finalizePhysicalTick() {
  var unhandledErrs = unhandledErrors;
  unhandledErrors = [];
  unhandledErrs.forEach((p) => {
    p._PSD.onunhandled.call(null, p._value, p);
  });
  var finalizers = tickFinalizers.slice(0);
  var i = finalizers.length;
  while (i)
    finalizers[--i]();
}
function run_at_end_of_this_or_next_physical_tick(fn) {
  function finalizer() {
    fn();
    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
  }
  tickFinalizers.push(finalizer);
  ++numScheduledCalls;
  asap(() => {
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
  }, []);
}
function addPossiblyUnhandledError(promise) {
  if (!unhandledErrors.some((p) => p._value === promise._value))
    unhandledErrors.push(promise);
}
function markErrorAsHandled(promise) {
  var i = unhandledErrors.length;
  while (i)
    if (unhandledErrors[--i]._value === promise._value) {
      unhandledErrors.splice(i, 1);
      return;
    }
}
function PromiseReject(reason) {
  return new DexiePromise(INTERNAL, false, reason);
}
function wrap(fn, errorCatcher) {
  var psd = PSD;
  return function() {
    var wasRootExec = beginMicroTickScope(), outerScope = PSD;
    try {
      switchToZone(psd, true);
      return fn.apply(this, arguments);
    } catch (e) {
      errorCatcher && errorCatcher(e);
    } finally {
      switchToZone(outerScope, false);
      if (wasRootExec)
        endMicroTickScope();
    }
  };
}
const task = { awaits: 0, echoes: 0, id: 0 };
var taskCounter = 0;
var zoneStack = [];
var zoneEchoes = 0;
var totalEchoes = 0;
var zone_id_counter = 0;
function newScope(fn, props2, a1, a2) {
  var parent = PSD, psd = Object.create(parent);
  psd.parent = parent;
  psd.ref = 0;
  psd.global = false;
  psd.id = ++zone_id_counter;
  var globalEnv = globalPSD.env;
  psd.env = patchGlobalPromise ? {
    Promise: DexiePromise,
    PromiseProp: { value: DexiePromise, configurable: true, writable: true },
    all: DexiePromise.all,
    race: DexiePromise.race,
    allSettled: DexiePromise.allSettled,
    any: DexiePromise.any,
    resolve: DexiePromise.resolve,
    reject: DexiePromise.reject,
    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
  } : {};
  if (props2)
    extend(psd, props2);
  ++parent.ref;
  psd.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var rv = usePSD(psd, fn, a1, a2);
  if (psd.ref === 0)
    psd.finalize();
  return rv;
}
function incrementExpectedAwaits() {
  if (!task.id)
    task.id = ++taskCounter;
  ++task.awaits;
  task.echoes += ZONE_ECHO_LIMIT;
  return task.id;
}
function decrementExpectedAwaits() {
  if (!task.awaits)
    return false;
  if (--task.awaits === 0)
    task.id = 0;
  task.echoes = task.awaits * ZONE_ECHO_LIMIT;
  return true;
}
if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
  incrementExpectedAwaits = decrementExpectedAwaits = nop;
}
function onPossibleParallellAsync(possiblePromise) {
  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
    incrementExpectedAwaits();
    return possiblePromise.then((x) => {
      decrementExpectedAwaits();
      return x;
    }, (e) => {
      decrementExpectedAwaits();
      return rejection(e);
    });
  }
  return possiblePromise;
}
function zoneEnterEcho(targetZone) {
  ++totalEchoes;
  if (!task.echoes || --task.echoes === 0) {
    task.echoes = task.id = 0;
  }
  zoneStack.push(PSD);
  switchToZone(targetZone, true);
}
function zoneLeaveEcho() {
  var zone = zoneStack[zoneStack.length - 1];
  zoneStack.pop();
  switchToZone(zone, false);
}
function switchToZone(targetZone, bEnteringZone) {
  var currentZone = PSD;
  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
  }
  if (targetZone === PSD)
    return;
  PSD = targetZone;
  if (currentZone === globalPSD)
    globalPSD.env = snapShot();
  if (patchGlobalPromise) {
    var GlobalPromise = globalPSD.env.Promise;
    var targetEnv = targetZone.env;
    nativePromiseProto.then = targetEnv.nthen;
    GlobalPromise.prototype.then = targetEnv.gthen;
    if (currentZone.global || targetZone.global) {
      Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
      GlobalPromise.all = targetEnv.all;
      GlobalPromise.race = targetEnv.race;
      GlobalPromise.resolve = targetEnv.resolve;
      GlobalPromise.reject = targetEnv.reject;
      if (targetEnv.allSettled)
        GlobalPromise.allSettled = targetEnv.allSettled;
      if (targetEnv.any)
        GlobalPromise.any = targetEnv.any;
    }
  }
}
function snapShot() {
  var GlobalPromise = _global.Promise;
  return patchGlobalPromise ? {
    Promise: GlobalPromise,
    PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
    all: GlobalPromise.all,
    race: GlobalPromise.race,
    allSettled: GlobalPromise.allSettled,
    any: GlobalPromise.any,
    resolve: GlobalPromise.resolve,
    reject: GlobalPromise.reject,
    nthen: nativePromiseProto.then,
    gthen: GlobalPromise.prototype.then
  } : {};
}
function usePSD(psd, fn, a1, a2, a3) {
  var outerScope = PSD;
  try {
    switchToZone(psd, true);
    return fn(a1, a2, a3);
  } finally {
    switchToZone(outerScope, false);
  }
}
function enqueueNativeMicroTask(job) {
  nativePromiseThen.call(resolvedNativePromise, job);
}
function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
  return typeof fn !== "function" ? fn : function() {
    var outerZone = PSD;
    if (possibleAwait)
      incrementExpectedAwaits();
    switchToZone(zone, true);
    try {
      return fn.apply(this, arguments);
    } finally {
      switchToZone(outerZone, false);
      if (cleanup)
        enqueueNativeMicroTask(decrementExpectedAwaits);
    }
  };
}
function getPatchedPromiseThen(origThen, zone) {
  return function(onResolved, onRejected) {
    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
  };
}
const UNHANDLEDREJECTION = "unhandledrejection";
function globalError(err, promise) {
  var rv;
  try {
    rv = promise.onuncatched(err);
  } catch (e) {
  }
  if (rv !== false)
    try {
      var event, eventData = { promise, reason: err };
      if (_global.document && document.createEvent) {
        event = document.createEvent("Event");
        event.initEvent(UNHANDLEDREJECTION, true, true);
        extend(event, eventData);
      } else if (_global.CustomEvent) {
        event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
        extend(event, eventData);
      }
      if (event && _global.dispatchEvent) {
        dispatchEvent(event);
        if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
          try {
            _global.onunhandledrejection(event);
          } catch (_) {
          }
      }
      if (debug$1 && event && !event.defaultPrevented) {
        console.warn(`Unhandled rejection: ${err.stack || err}`);
      }
    } catch (e) {
    }
}
var rejection = DexiePromise.reject;
function tempTransaction(db2, mode, storeNames, fn) {
  if (!db2.idbdb || !db2._state.openComplete && (!PSD.letThrough && !db2._vip)) {
    if (db2._state.openComplete) {
      return rejection(new exceptions.DatabaseClosed(db2._state.dbOpenError));
    }
    if (!db2._state.isBeingOpened) {
      if (!db2._options.autoOpen)
        return rejection(new exceptions.DatabaseClosed());
      db2.open().catch(nop);
    }
    return db2._state.dbReadyPromise.then(() => tempTransaction(db2, mode, storeNames, fn));
  } else {
    var trans = db2._createTransaction(mode, storeNames, db2._dbSchema);
    try {
      trans.create();
      db2._state.PR1398_maxLoop = 3;
    } catch (ex) {
      if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
        console.warn("Dexie: Need to reopen db");
        db2._close();
        return db2.open().then(() => tempTransaction(db2, mode, storeNames, fn));
      }
      return rejection(ex);
    }
    return trans._promise(mode, (resolve, reject) => {
      return newScope(() => {
        PSD.trans = trans;
        return fn(resolve, reject, trans);
      });
    }).then((result) => {
      return trans._completion.then(() => result);
    });
  }
}
const DEXIE_VERSION = "4.0.0-alpha.4";
const maxString = String.fromCharCode(65535);
const minKey = -Infinity;
const INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
const STRING_EXPECTED = "String expected.";
const connections = [];
const isIEOrEdge = typeof navigator !== "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
const hasIEDeleteObjectStoreBug = isIEOrEdge;
const hangsOnDeleteLargeKeyRange = isIEOrEdge;
const dexieStackFrameFilter = (frame) => !/(dexie\.js|dexie\.min\.js)/.test(frame);
const DBNAMES_DB = "__dbnames";
const READONLY = "readonly";
const READWRITE = "readwrite";
function combine(filter1, filter2) {
  return filter1 ? filter2 ? function() {
    return filter1.apply(this, arguments) && filter2.apply(this, arguments);
  } : filter1 : filter2;
}
const AnyRange = {
  type: 3,
  lower: -Infinity,
  lowerOpen: false,
  upper: [[]],
  upperOpen: false
};
function workaroundForUndefinedPrimKey(keyPath) {
  return typeof keyPath === "string" && !/\./.test(keyPath) ? (obj) => {
    if (obj[keyPath] === void 0 && keyPath in obj) {
      obj = deepClone(obj);
      delete obj[keyPath];
    }
    return obj;
  } : (obj) => obj;
}
function Entity() {
  throw exceptions.Type();
}
class Table {
  _trans(mode, fn, writeLocked) {
    const trans = this._tx || PSD.trans;
    const tableName = this.name;
    function checkTableInTransaction(resolve, reject, trans2) {
      if (!trans2.schema[tableName])
        throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
      return fn(trans2.idbtrans, trans2);
    }
    const wasRootExec = beginMicroTickScope();
    try {
      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
    } finally {
      if (wasRootExec)
        endMicroTickScope();
    }
  }
  get(keyOrCrit, cb) {
    if (keyOrCrit && keyOrCrit.constructor === Object)
      return this.where(keyOrCrit).first(cb);
    return this._trans("readonly", (trans) => {
      return this.core.get({ trans, key: keyOrCrit }).then((res) => this.hook.reading.fire(res));
    }).then(cb);
  }
  where(indexOrCrit) {
    if (typeof indexOrCrit === "string")
      return new this.db.WhereClause(this, indexOrCrit);
    if (isArray$1(indexOrCrit))
      return new this.db.WhereClause(this, `[${indexOrCrit.join("+")}]`);
    const keyPaths = keys(indexOrCrit);
    if (keyPaths.length === 1)
      return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix) => ix.compound && keyPaths.every((keyPath) => ix.keyPath.indexOf(keyPath) >= 0) && ix.keyPath.every((keyPath) => keyPaths.indexOf(keyPath) >= 0))[0];
    if (compoundIndex && this.db._maxKey !== maxString)
      return this.where(compoundIndex.name).equals(compoundIndex.keyPath.map((kp) => indexOrCrit[kp]));
    if (!compoundIndex && debug$1)
      console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a compound index [${keyPaths.join("+")}]`);
    const { idxByName } = this.schema;
    const idb = this.db._deps.indexedDB;
    function equals(a, b) {
      try {
        return idb.cmp(a, b) === 0;
      } catch (e) {
        return false;
      }
    }
    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {
      const index = idxByName[keyPath];
      const value = indexOrCrit[keyPath];
      return [
        prevIndex || index,
        prevIndex || !index ? combine(prevFilterFn, index && index.multi ? (x) => {
          const prop = getByKeyPath(x, keyPath);
          return isArray$1(prop) && prop.some((item) => equals(value, item));
        } : (x) => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn
      ];
    }, [null, null]);
    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
  }
  filter(filterFunction) {
    return this.toCollection().and(filterFunction);
  }
  count(thenShortcut) {
    return this.toCollection().count(thenShortcut);
  }
  offset(offset) {
    return this.toCollection().offset(offset);
  }
  limit(numRows) {
    return this.toCollection().limit(numRows);
  }
  each(callback) {
    return this.toCollection().each(callback);
  }
  toArray(thenShortcut) {
    return this.toCollection().toArray(thenShortcut);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(index) {
    return new this.db.Collection(new this.db.WhereClause(this, isArray$1(index) ? `[${index.join("+")}]` : index));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(constructor) {
    const { db: db2, name: tableName } = this;
    this.schema.mappedClass = constructor;
    if (constructor.prototype instanceof Entity) {
      constructor = class extends constructor {
        get db() {
          return db2;
        }
        table() {
          return tableName;
        }
      };
    }
    const inheritedProps = /* @__PURE__ */ new Set();
    for (let proto = constructor.prototype; proto; proto = getProto(proto)) {
      Object.getOwnPropertyNames(proto).forEach((propName) => inheritedProps.add(propName));
    }
    const readHook = (obj) => {
      if (!obj)
        return obj;
      const res = Object.create(constructor.prototype);
      for (let m in obj)
        if (!inheritedProps.has(m))
          try {
            res[m] = obj[m];
          } catch (_) {
          }
      return res;
    };
    if (this.schema.readHook) {
      this.hook.reading.unsubscribe(this.schema.readHook);
    }
    this.schema.readHook = readHook;
    this.hook("reading", readHook);
    return constructor;
  }
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return this.mapToClass(Class);
  }
  add(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
    }).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  update(keyOrObject, modifications) {
    if (typeof keyOrObject === "object" && !isArray$1(keyOrObject)) {
      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
      if (key === void 0)
        return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
      try {
        if (typeof modifications !== "function") {
          keys(modifications).forEach((keyPath) => {
            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
          });
        } else {
          modifications(keyOrObject, { value: keyOrObject, primKey: key });
        }
      } catch (_a) {
      }
      return this.where(":id").equals(key).modify(modifications);
    } else {
      return this.where(":id").equals(keyOrObject).modify(modifications);
    }
  }
  put(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  delete(key) {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "delete", keys: [key] })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "deleteRange", range: AnyRange })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  bulkGet(keys2) {
    return this._trans("readonly", (trans) => {
      return this.core.getMany({
        keys: keys2,
        trans
      }).then((result) => result.map((res) => this.hook.reading.fire(res)));
    });
  }
  bulkAdd(objects, keysOrOptions, options2) {
    const keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options2 = options2 || (keys2 ? void 0 : keysOrOptions);
    const wantResults = options2 ? options2.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys2)
        throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (keys2 && keys2.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "add", keys: keys2, values: objectsToAdd, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkPut(objects, keysOrOptions, options2) {
    const keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options2 = options2 || (keys2 ? void 0 : keysOrOptions);
    const wantResults = options2 ? options2.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys2)
        throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (keys2 && keys2.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "put", keys: keys2, values: objectsToPut, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkDelete(keys2) {
    const numKeys = keys2.length;
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "delete", keys: keys2 });
    }).then(({ numFailures, lastResult, failures }) => {
      if (numFailures === 0)
        return lastResult;
      throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);
    });
  }
}
function Events(ctx) {
  var evs = {};
  var rv = function(eventName, subscriber) {
    if (subscriber) {
      var i2 = arguments.length, args2 = new Array(i2 - 1);
      while (--i2)
        args2[i2 - 1] = arguments[i2];
      evs[eventName].subscribe.apply(null, args2);
      return ctx;
    } else if (typeof eventName === "string") {
      return evs[eventName];
    }
  };
  rv.addEventType = add2;
  for (var i = 1, l = arguments.length; i < l; ++i) {
    add2(arguments[i]);
  }
  return rv;
  function add2(eventName, chainFunction, defaultFunction) {
    if (typeof eventName === "object")
      return addConfiguredEvents(eventName);
    if (!chainFunction)
      chainFunction = reverseStoppableEventChain;
    if (!defaultFunction)
      defaultFunction = nop;
    var context2 = {
      subscribers: [],
      fire: defaultFunction,
      subscribe: function(cb) {
        if (context2.subscribers.indexOf(cb) === -1) {
          context2.subscribers.push(cb);
          context2.fire = chainFunction(context2.fire, cb);
        }
      },
      unsubscribe: function(cb) {
        context2.subscribers = context2.subscribers.filter(function(fn) {
          return fn !== cb;
        });
        context2.fire = context2.subscribers.reduce(chainFunction, defaultFunction);
      }
    };
    evs[eventName] = rv[eventName] = context2;
    return context2;
  }
  function addConfiguredEvents(cfg) {
    keys(cfg).forEach(function(eventName) {
      var args2 = cfg[eventName];
      if (isArray$1(args2)) {
        add2(eventName, cfg[eventName][0], cfg[eventName][1]);
      } else if (args2 === "asap") {
        var context2 = add2(eventName, mirror, function fire() {
          var i2 = arguments.length, args3 = new Array(i2);
          while (i2--)
            args3[i2] = arguments[i2];
          context2.subscribers.forEach(function(fn) {
            asap$1(function fireEvent() {
              fn.apply(null, args3);
            });
          });
        });
      } else
        throw new exceptions.InvalidArgument("Invalid event config");
    });
  }
}
function makeClassConstructor(prototype, constructor) {
  derive(constructor).from({ prototype });
  return constructor;
}
function createTableConstructor(db2) {
  return makeClassConstructor(Table.prototype, function Table2(name, tableSchema, trans) {
    this.db = db2;
    this._tx = trans;
    this.name = name;
    this.schema = tableSchema;
    this.hook = db2._allTables[name] ? db2._allTables[name].hook : Events(null, {
      "creating": [hookCreatingChain, nop],
      "reading": [pureFunctionChain, mirror],
      "updating": [hookUpdatingChain, nop],
      "deleting": [hookDeletingChain, nop]
    });
  });
}
function isPlainKeyRange(ctx, ignoreLimitFilter) {
  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
}
function addFilter(ctx, fn) {
  ctx.filter = combine(ctx.filter, fn);
}
function addReplayFilter(ctx, factory, isLimitFilter) {
  var curr = ctx.replayFilter;
  ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;
  ctx.justLimit = isLimitFilter && !curr;
}
function addMatchFilter(ctx, fn) {
  ctx.isMatch = combine(ctx.isMatch, fn);
}
function getIndexOrStore(ctx, coreSchema) {
  if (ctx.isPrimKey)
    return coreSchema.primaryKey;
  const index = coreSchema.getIndexByKeyPath(ctx.index);
  if (!index)
    throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
  return index;
}
function openCursor(ctx, coreTable, trans) {
  const index = getIndexOrStore(ctx, coreTable.schema);
  return coreTable.openCursor({
    trans,
    values: !ctx.keysOnly,
    reverse: ctx.dir === "prev",
    unique: !!ctx.unique,
    query: {
      index,
      range: ctx.range
    }
  });
}
function iter(ctx, fn, coreTrans, coreTable) {
  const filter2 = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
  if (!ctx.or) {
    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter2), fn, !ctx.keysOnly && ctx.valueMapper);
  } else {
    const set2 = {};
    const union = (item, cursor2, advance) => {
      if (!filter2 || filter2(cursor2, advance, (result) => cursor2.stop(result), (err) => cursor2.fail(err))) {
        var primaryKey = cursor2.primaryKey;
        var key = "" + primaryKey;
        if (key === "[object ArrayBuffer]")
          key = "" + new Uint8Array(primaryKey);
        if (!hasOwn(set2, key)) {
          set2[key] = true;
          fn(item, cursor2, advance);
        }
      }
    };
    return Promise.all([
      ctx.or._iterate(union, coreTrans),
      iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
    ]);
  }
}
function iterate(cursorPromise, filter2, fn, valueMapper) {
  var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;
  var wrappedFn = wrap(mappedFn);
  return cursorPromise.then((cursor2) => {
    if (cursor2) {
      return cursor2.start(() => {
        var c = () => cursor2.continue();
        if (!filter2 || filter2(cursor2, (advancer) => c = advancer, (val) => {
          cursor2.stop(val);
          c = nop;
        }, (e) => {
          cursor2.fail(e);
          c = nop;
        }))
          wrappedFn(cursor2.value, cursor2, (advancer) => c = advancer);
        c();
      });
    }
  });
}
function cmp$2(a, b) {
  try {
    const ta = type$8(a);
    const tb = type$8(b);
    if (ta !== tb) {
      if (ta === "Array")
        return 1;
      if (tb === "Array")
        return -1;
      if (ta === "binary")
        return 1;
      if (tb === "binary")
        return -1;
      if (ta === "string")
        return 1;
      if (tb === "string")
        return -1;
      if (ta === "Date")
        return 1;
      if (tb !== "Date")
        return NaN;
      return -1;
    }
    switch (ta) {
      case "number":
      case "Date":
      case "string":
        return a > b ? 1 : a < b ? -1 : 0;
      case "binary": {
        return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
      }
      case "Array":
        return compareArrays(a, b);
    }
  } catch (_a) {
  }
  return NaN;
}
function compareArrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    const res = cmp$2(a[i], b[i]);
    if (res !== 0)
      return res;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function compareUint8Arrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    if (a[i] !== b[i])
      return a[i] < b[i] ? -1 : 1;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function type$8(x) {
  const t = typeof x;
  if (t !== "object")
    return t;
  if (ArrayBuffer.isView(x))
    return "binary";
  const tsTag = toStringTag(x);
  return tsTag === "ArrayBuffer" ? "binary" : tsTag;
}
function getUint8Array(a) {
  if (a instanceof Uint8Array)
    return a;
  if (ArrayBuffer.isView(a))
    return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  return new Uint8Array(a);
}
class Collection {
  _read(fn, cb) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
  }
  _write(fn) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
  }
  _addAlgorithm(fn) {
    var ctx = this._ctx;
    ctx.algorithm = combine(ctx.algorithm, fn);
  }
  _iterate(fn, coreTrans) {
    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
  }
  clone(props2) {
    var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
    if (props2)
      extend(ctx, props2);
    rv._ctx = ctx;
    return rv;
  }
  raw() {
    this._ctx.valueMapper = null;
    return this;
  }
  each(fn) {
    var ctx = this._ctx;
    return this._read((trans) => iter(ctx, fn, trans, ctx.table.core));
  }
  count(cb) {
    return this._read((trans) => {
      const ctx = this._ctx;
      const coreTable = ctx.table.core;
      if (isPlainKeyRange(ctx, true)) {
        return coreTable.count({
          trans,
          query: {
            index: getIndexOrStore(ctx, coreTable.schema),
            range: ctx.range
          }
        }).then((count3) => Math.min(count3, ctx.limit));
      } else {
        var count2 = 0;
        return iter(ctx, () => {
          ++count2;
          return false;
        }, trans, coreTable).then(() => count2);
      }
    }).then(cb);
  }
  sortBy(keyPath, cb) {
    const parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
    function getval(obj, i) {
      if (i)
        return getval(obj[parts[i]], i - 1);
      return obj[lastPart];
    }
    var order = this._ctx.dir === "next" ? 1 : -1;
    function sorter(a, b) {
      var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
      return aVal < bVal ? -order : aVal > bVal ? order : 0;
    }
    return this.toArray(function(a) {
      return a.sort(sorter);
    }).then(cb);
  }
  toArray(cb) {
    return this._read((trans) => {
      var ctx = this._ctx;
      if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
        const { valueMapper } = ctx;
        const index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          limit: ctx.limit,
          values: true,
          query: {
            index,
            range: ctx.range
          }
        }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);
      } else {
        const a = [];
        return iter(ctx, (item) => a.push(item), trans, ctx.table.core).then(() => a);
      }
    }, cb);
  }
  offset(offset) {
    var ctx = this._ctx;
    if (offset <= 0)
      return this;
    ctx.offset += offset;
    if (isPlainKeyRange(ctx)) {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return (cursor2, advance) => {
          if (offsetLeft === 0)
            return true;
          if (offsetLeft === 1) {
            --offsetLeft;
            return false;
          }
          advance(() => {
            cursor2.advance(offsetLeft);
            offsetLeft = 0;
          });
          return false;
        };
      });
    } else {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return () => --offsetLeft < 0;
      });
    }
    return this;
  }
  limit(numRows) {
    this._ctx.limit = Math.min(this._ctx.limit, numRows);
    addReplayFilter(this._ctx, () => {
      var rowsLeft = numRows;
      return function(cursor2, advance, resolve) {
        if (--rowsLeft <= 0)
          advance(resolve);
        return rowsLeft >= 0;
      };
    }, true);
    return this;
  }
  until(filterFunction, bIncludeStopEntry) {
    addFilter(this._ctx, function(cursor2, advance, resolve) {
      if (filterFunction(cursor2.value)) {
        advance(resolve);
        return bIncludeStopEntry;
      } else {
        return true;
      }
    });
    return this;
  }
  first(cb) {
    return this.limit(1).toArray(function(a) {
      return a[0];
    }).then(cb);
  }
  last(cb) {
    return this.reverse().first(cb);
  }
  filter(filterFunction) {
    addFilter(this._ctx, function(cursor2) {
      return filterFunction(cursor2.value);
    });
    addMatchFilter(this._ctx, filterFunction);
    return this;
  }
  and(filter2) {
    return this.filter(filter2);
  }
  or(indexName) {
    return new this.db.WhereClause(this._ctx.table, indexName, this);
  }
  reverse() {
    this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
    if (this._ondirectionchange)
      this._ondirectionchange(this._ctx.dir);
    return this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor2) {
      cb(cursor2.key, cursor2);
    });
  }
  eachUniqueKey(cb) {
    this._ctx.unique = "unique";
    return this.eachKey(cb);
  }
  eachPrimaryKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor2) {
      cb(cursor2.primaryKey, cursor2);
    });
  }
  keys(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor2) {
      a.push(cursor2.key);
    }).then(function() {
      return a;
    }).then(cb);
  }
  primaryKeys(cb) {
    var ctx = this._ctx;
    if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
      return this._read((trans) => {
        var index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          values: false,
          limit: ctx.limit,
          query: {
            index,
            range: ctx.range
          }
        });
      }).then(({ result }) => result).then(cb);
    }
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor2) {
      a.push(cursor2.primaryKey);
    }).then(function() {
      return a;
    }).then(cb);
  }
  uniqueKeys(cb) {
    this._ctx.unique = "unique";
    return this.keys(cb);
  }
  firstKey(cb) {
    return this.limit(1).keys(function(a) {
      return a[0];
    }).then(cb);
  }
  lastKey(cb) {
    return this.reverse().firstKey(cb);
  }
  distinct() {
    var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
    if (!idx || !idx.multi)
      return this;
    var set2 = {};
    addFilter(this._ctx, function(cursor2) {
      var strKey = cursor2.primaryKey.toString();
      var found = hasOwn(set2, strKey);
      set2[strKey] = true;
      return !found;
    });
    return this;
  }
  modify(changes) {
    var ctx = this._ctx;
    return this._write((trans) => {
      var modifyer;
      if (typeof changes === "function") {
        modifyer = changes;
      } else {
        var keyPaths = keys(changes);
        var numKeys = keyPaths.length;
        modifyer = function(item) {
          var anythingModified = false;
          for (var i = 0; i < numKeys; ++i) {
            var keyPath = keyPaths[i], val = changes[keyPath];
            if (getByKeyPath(item, keyPath) !== val) {
              setByKeyPath(item, keyPath, val);
              anythingModified = true;
            }
          }
          return anythingModified;
        };
      }
      const coreTable = ctx.table.core;
      const { outbound, extractKey: extractKey2 } = coreTable.schema.primaryKey;
      const limit2 = this.db._options.modifyChunkSize || 200;
      const totalFailures = [];
      let successCount = 0;
      const failedKeys = [];
      const applyMutateResult = (expectedCount, res) => {
        const { failures, numFailures } = res;
        successCount += expectedCount - numFailures;
        for (let pos of keys(failures)) {
          totalFailures.push(failures[pos]);
        }
      };
      return this.clone().primaryKeys().then((keys2) => {
        const nextChunk = (offset) => {
          const count2 = Math.min(limit2, keys2.length - offset);
          return coreTable.getMany({
            trans,
            keys: keys2.slice(offset, offset + count2),
            cache: "immutable"
          }).then((values) => {
            const addValues = [];
            const putValues = [];
            const putKeys = outbound ? [] : null;
            const deleteKeys = [];
            for (let i = 0; i < count2; ++i) {
              const origValue = values[i];
              const ctx2 = {
                value: deepClone(origValue),
                primKey: keys2[offset + i]
              };
              if (modifyer.call(ctx2, ctx2.value, ctx2) !== false) {
                if (ctx2.value == null) {
                  deleteKeys.push(keys2[offset + i]);
                } else if (!outbound && cmp$2(extractKey2(origValue), extractKey2(ctx2.value)) !== 0) {
                  deleteKeys.push(keys2[offset + i]);
                  addValues.push(ctx2.value);
                } else {
                  putValues.push(ctx2.value);
                  if (outbound)
                    putKeys.push(keys2[offset + i]);
                }
              }
            }
            const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
              index: ctx.index,
              range: ctx.range
            };
            return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then((res) => {
              for (let pos in res.failures) {
                deleteKeys.splice(parseInt(pos), 1);
              }
              applyMutateResult(addValues.length, res);
            })).then(() => (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
              trans,
              type: "put",
              keys: putKeys,
              values: putValues,
              criteria,
              changeSpec: typeof changes !== "function" && changes
            }).then((res) => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
              trans,
              type: "delete",
              keys: deleteKeys,
              criteria
            }).then((res) => applyMutateResult(deleteKeys.length, res))).then(() => {
              return keys2.length > offset + count2 && nextChunk(offset + limit2);
            });
          });
        };
        return nextChunk(0).then(() => {
          if (totalFailures.length > 0)
            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
          return keys2.length;
        });
      });
    });
  }
  delete() {
    var ctx = this._ctx, range2 = ctx.range;
    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range2.type === 3)) {
      return this._write((trans) => {
        const { primaryKey } = ctx.table.core.schema;
        const coreRange = range2;
        return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then((count2) => {
          return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(({ failures, lastResult, results, numFailures }) => {
            if (numFailures)
              throw new ModifyError("Could not delete some values", Object.keys(failures).map((pos) => failures[pos]), count2 - numFailures);
            return count2 - numFailures;
          });
        });
      });
    }
    return this.modify(deleteCallback);
  }
}
const deleteCallback = (value, ctx) => ctx.value = null;
function createCollectionConstructor(db2) {
  return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
    this.db = db2;
    let keyRange = AnyRange, error = null;
    if (keyRangeGenerator)
      try {
        keyRange = keyRangeGenerator();
      } catch (ex) {
        error = ex;
      }
    const whereCtx = whereClause._ctx;
    const table = whereCtx.table;
    const readingHook = table.hook.reading.fire;
    this._ctx = {
      table,
      index: whereCtx.index,
      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
      range: keyRange,
      keysOnly: false,
      dir: "next",
      unique: "",
      algorithm: null,
      filter: null,
      replayFilter: null,
      justLimit: true,
      isMatch: null,
      offset: 0,
      limit: Infinity,
      error,
      or: whereCtx.or,
      valueMapper: readingHook !== mirror ? readingHook : null
    };
  });
}
function simpleCompare(a, b) {
  return a < b ? -1 : a === b ? 0 : 1;
}
function simpleCompareReverse(a, b) {
  return a > b ? -1 : a === b ? 0 : 1;
}
function fail(collectionOrWhereClause, err, T) {
  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
  collection._ctx.error = T ? new T(err) : new TypeError(err);
  return collection;
}
function emptyCollection(whereClause) {
  return new whereClause.Collection(whereClause, () => rangeEqual("")).limit(0);
}
function upperFactory(dir) {
  return dir === "next" ? (s) => s.toUpperCase() : (s) => s.toLowerCase();
}
function lowerFactory(dir) {
  return dir === "next" ? (s) => s.toLowerCase() : (s) => s.toUpperCase();
}
function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp2, dir) {
  var length = Math.min(key.length, lowerNeedle.length);
  var llp = -1;
  for (var i = 0; i < length; ++i) {
    var lwrKeyChar = lowerKey[i];
    if (lwrKeyChar !== lowerNeedle[i]) {
      if (cmp2(key[i], upperNeedle[i]) < 0)
        return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
      if (cmp2(key[i], lowerNeedle[i]) < 0)
        return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
      if (llp >= 0)
        return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
      return null;
    }
    if (cmp2(key[i], lwrKeyChar) < 0)
      llp = i;
  }
  if (length < lowerNeedle.length && dir === "next")
    return key + upperNeedle.substr(key.length);
  if (length < key.length && dir === "prev")
    return key.substr(0, upperNeedle.length);
  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
}
function addIgnoreCaseAlgorithm(whereClause, match2, needles, suffix) {
  var upper, lower, compare2, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
  if (!needles.every((s) => typeof s === "string")) {
    return fail(whereClause, STRING_EXPECTED);
  }
  function initDirection(dir) {
    upper = upperFactory(dir);
    lower = lowerFactory(dir);
    compare2 = dir === "next" ? simpleCompare : simpleCompareReverse;
    var needleBounds = needles.map(function(needle) {
      return { lower: lower(needle), upper: upper(needle) };
    }).sort(function(a, b) {
      return compare2(a.lower, b.lower);
    });
    upperNeedles = needleBounds.map(function(nb) {
      return nb.upper;
    });
    lowerNeedles = needleBounds.map(function(nb) {
      return nb.lower;
    });
    direction = dir;
    nextKeySuffix = dir === "next" ? "" : suffix;
  }
  initDirection("next");
  var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));
  c._ondirectionchange = function(direction2) {
    initDirection(direction2);
  };
  var firstPossibleNeedle = 0;
  c._addAlgorithm(function(cursor2, advance, resolve) {
    var key = cursor2.key;
    if (typeof key !== "string")
      return false;
    var lowerKey = lower(key);
    if (match2(lowerKey, lowerNeedles, firstPossibleNeedle)) {
      return true;
    } else {
      var lowestPossibleCasing = null;
      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare2, direction);
        if (casing === null && lowestPossibleCasing === null)
          firstPossibleNeedle = i + 1;
        else if (lowestPossibleCasing === null || compare2(lowestPossibleCasing, casing) > 0) {
          lowestPossibleCasing = casing;
        }
      }
      if (lowestPossibleCasing !== null) {
        advance(function() {
          cursor2.continue(lowestPossibleCasing + nextKeySuffix);
        });
      } else {
        advance(resolve);
      }
      return false;
    }
  });
  return c;
}
function createRange(lower, upper, lowerOpen, upperOpen) {
  return {
    type: 2,
    lower,
    upper,
    lowerOpen,
    upperOpen
  };
}
function rangeEqual(value) {
  return {
    type: 1,
    lower: value,
    upper: value
  };
}
class WhereClause {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(lower, upper, includeLower, includeUpper) {
    includeLower = includeLower !== false;
    includeUpper = includeUpper === true;
    try {
      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
        return emptyCollection(this);
      return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
  }
  equals(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => rangeEqual(value));
  }
  above(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, true));
  }
  aboveOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, false));
  }
  below(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value, false, true));
  }
  belowOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value));
  }
  startsWith(str) {
    if (typeof str !== "string")
      return fail(this, STRING_EXPECTED);
    return this.between(str, str + maxString, true, true);
  }
  startsWithIgnoreCase(str) {
    if (str === "")
      return this.startsWith(str);
    return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);
  }
  equalsIgnoreCase(str) {
    return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], "");
  }
  anyOfIgnoreCase() {
    var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set2.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set2, "");
  }
  startsWithAnyOfIgnoreCase() {
    var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set2.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.some((n) => x.indexOf(n) === 0), set2, maxString);
  }
  anyOf() {
    const set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    let compare2 = this._cmp;
    try {
      set2.sort(compare2);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    if (set2.length === 0)
      return emptyCollection(this);
    const c = new this.Collection(this, () => createRange(set2[0], set2[set2.length - 1]));
    c._ondirectionchange = (direction) => {
      compare2 = direction === "next" ? this._ascending : this._descending;
      set2.sort(compare2);
    };
    let i = 0;
    c._addAlgorithm((cursor2, advance, resolve) => {
      const key = cursor2.key;
      while (compare2(key, set2[i]) > 0) {
        ++i;
        if (i === set2.length) {
          advance(resolve);
          return false;
        }
      }
      if (compare2(key, set2[i]) === 0) {
        return true;
      } else {
        advance(() => {
          cursor2.continue(set2[i]);
        });
        return false;
      }
    });
    return c;
  }
  notEqual(value) {
    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
  }
  noneOf() {
    const set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set2.length === 0)
      return new this.Collection(this);
    try {
      set2.sort(this._ascending);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    const ranges = set2.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);
    ranges.push([set2[set2.length - 1], this.db._maxKey]);
    return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
  }
  inAnyRange(ranges, options2) {
    const cmp2 = this._cmp, ascending = this._ascending, descending = this._descending, min2 = this._min, max2 = this._max;
    if (ranges.length === 0)
      return emptyCollection(this);
    if (!ranges.every((range2) => range2[0] !== void 0 && range2[1] !== void 0 && ascending(range2[0], range2[1]) <= 0)) {
      return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
    }
    const includeLowers = !options2 || options2.includeLowers !== false;
    const includeUppers = options2 && options2.includeUppers === true;
    function addRange2(ranges2, newRange) {
      let i = 0, l = ranges2.length;
      for (; i < l; ++i) {
        const range2 = ranges2[i];
        if (cmp2(newRange[0], range2[1]) < 0 && cmp2(newRange[1], range2[0]) > 0) {
          range2[0] = min2(range2[0], newRange[0]);
          range2[1] = max2(range2[1], newRange[1]);
          break;
        }
      }
      if (i === l)
        ranges2.push(newRange);
      return ranges2;
    }
    let sortDirection = ascending;
    function rangeSorter(a, b) {
      return sortDirection(a[0], b[0]);
    }
    let set2;
    try {
      set2 = ranges.reduce(addRange2, []);
      set2.sort(rangeSorter);
    } catch (ex) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    let rangePos = 0;
    const keyIsBeyondCurrentEntry = includeUppers ? (key) => ascending(key, set2[rangePos][1]) > 0 : (key) => ascending(key, set2[rangePos][1]) >= 0;
    const keyIsBeforeCurrentEntry = includeLowers ? (key) => descending(key, set2[rangePos][0]) > 0 : (key) => descending(key, set2[rangePos][0]) >= 0;
    function keyWithinCurrentRange(key) {
      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
    }
    let checkKey = keyIsBeyondCurrentEntry;
    const c = new this.Collection(this, () => createRange(set2[0][0], set2[set2.length - 1][1], !includeLowers, !includeUppers));
    c._ondirectionchange = (direction) => {
      if (direction === "next") {
        checkKey = keyIsBeyondCurrentEntry;
        sortDirection = ascending;
      } else {
        checkKey = keyIsBeforeCurrentEntry;
        sortDirection = descending;
      }
      set2.sort(rangeSorter);
    };
    c._addAlgorithm((cursor2, advance, resolve) => {
      var key = cursor2.key;
      while (checkKey(key)) {
        ++rangePos;
        if (rangePos === set2.length) {
          advance(resolve);
          return false;
        }
      }
      if (keyWithinCurrentRange(key)) {
        return true;
      } else if (this._cmp(key, set2[rangePos][1]) === 0 || this._cmp(key, set2[rangePos][0]) === 0) {
        return false;
      } else {
        advance(() => {
          if (sortDirection === ascending)
            cursor2.continue(set2[rangePos][0]);
          else
            cursor2.continue(set2[rangePos][1]);
        });
        return false;
      }
    });
    return c;
  }
  startsWithAnyOf() {
    const set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (!set2.every((s) => typeof s === "string")) {
      return fail(this, "startsWithAnyOf() only works with strings");
    }
    if (set2.length === 0)
      return emptyCollection(this);
    return this.inAnyRange(set2.map((str) => [str, str + maxString]));
  }
}
function createWhereClauseConstructor(db2) {
  return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {
    this.db = db2;
    this._ctx = {
      table,
      index: index === ":id" ? null : index,
      or: orCollection
    };
    const indexedDB2 = db2._deps.indexedDB;
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    this._cmp = this._ascending = indexedDB2.cmp.bind(indexedDB2);
    this._descending = (a, b) => indexedDB2.cmp(b, a);
    this._max = (a, b) => indexedDB2.cmp(a, b) > 0 ? a : b;
    this._min = (a, b) => indexedDB2.cmp(a, b) < 0 ? a : b;
    this._IDBKeyRange = db2._deps.IDBKeyRange;
  });
}
function eventRejectHandler(reject) {
  return wrap(function(event) {
    preventDefault(event);
    reject(event.target.error);
    return false;
  });
}
function preventDefault(event) {
  if (event.stopPropagation)
    event.stopPropagation();
  if (event.preventDefault)
    event.preventDefault();
}
const DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
const STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
const globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
class Transaction {
  _lock() {
    assert(!PSD.global);
    ++this._reculock;
    if (this._reculock === 1 && !PSD.global)
      PSD.lockOwnerFor = this;
    return this;
  }
  _unlock() {
    assert(!PSD.global);
    if (--this._reculock === 0) {
      if (!PSD.global)
        PSD.lockOwnerFor = null;
      while (this._blockedFuncs.length > 0 && !this._locked()) {
        var fnAndPSD = this._blockedFuncs.shift();
        try {
          usePSD(fnAndPSD[1], fnAndPSD[0]);
        } catch (e) {
        }
      }
    }
    return this;
  }
  _locked() {
    return this._reculock && PSD.lockOwnerFor !== this;
  }
  create(idbtrans) {
    if (!this.mode)
      return this;
    const idbdb = this.db.idbdb;
    const dbOpenError = this.db._state.dbOpenError;
    assert(!this.idbtrans);
    if (!idbtrans && !idbdb) {
      switch (dbOpenError && dbOpenError.name) {
        case "DatabaseClosedError":
          throw new exceptions.DatabaseClosed(dbOpenError);
        case "MissingAPIError":
          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
        default:
          throw new exceptions.OpenFailed(dbOpenError);
      }
    }
    if (!this.active)
      throw new exceptions.TransactionInactive();
    assert(this._completion._state === null);
    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
    idbtrans.onerror = wrap((ev) => {
      preventDefault(ev);
      this._reject(idbtrans.error);
    });
    idbtrans.onabort = wrap((ev) => {
      preventDefault(ev);
      this.active && this._reject(new exceptions.Abort(idbtrans.error));
      this.active = false;
      this.on("abort").fire(ev);
    });
    idbtrans.oncomplete = wrap(() => {
      this.active = false;
      this._resolve();
      if ("mutatedParts" in idbtrans) {
        globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
      }
    });
    return this;
  }
  _promise(mode, fn, bWriteLock) {
    if (mode === "readwrite" && this.mode !== "readwrite")
      return rejection(new exceptions.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return rejection(new exceptions.TransactionInactive());
    if (this._locked()) {
      return new DexiePromise((resolve, reject) => {
        this._blockedFuncs.push([() => {
          this._promise(mode, fn, bWriteLock).then(resolve, reject);
        }, PSD]);
      });
    } else if (bWriteLock) {
      return newScope(() => {
        var p2 = new DexiePromise((resolve, reject) => {
          this._lock();
          const rv = fn(resolve, reject, this);
          if (rv && rv.then)
            rv.then(resolve, reject);
        });
        p2.finally(() => this._unlock());
        p2._lib = true;
        return p2;
      });
    } else {
      var p = new DexiePromise((resolve, reject) => {
        var rv = fn(resolve, reject, this);
        if (rv && rv.then)
          rv.then(resolve, reject);
      });
      p._lib = true;
      return p;
    }
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(promiseLike) {
    var root = this._root();
    const promise = DexiePromise.resolve(promiseLike);
    if (root._waitingFor) {
      root._waitingFor = root._waitingFor.then(() => promise);
    } else {
      root._waitingFor = promise;
      root._waitingQueue = [];
      var store = root.idbtrans.objectStore(root.storeNames[0]);
      (function spin() {
        ++root._spinCount;
        while (root._waitingQueue.length)
          root._waitingQueue.shift()();
        if (root._waitingFor)
          store.get(-Infinity).onsuccess = spin;
      })();
    }
    var currentWaitPromise = root._waitingFor;
    return new DexiePromise((resolve, reject) => {
      promise.then((res) => root._waitingQueue.push(wrap(resolve.bind(null, res))), (err) => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {
        if (root._waitingFor === currentWaitPromise) {
          root._waitingFor = null;
        }
      });
    });
  }
  abort() {
    if (this.active) {
      this.active = false;
      if (this.idbtrans)
        this.idbtrans.abort();
      this._reject(new exceptions.Abort());
    }
  }
  table(tableName) {
    const memoizedTables = this._memoizedTables || (this._memoizedTables = {});
    if (hasOwn(memoizedTables, tableName))
      return memoizedTables[tableName];
    const tableSchema = this.schema[tableName];
    if (!tableSchema) {
      throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
    }
    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
    transactionBoundTable.core = this.db.core.table(tableName);
    memoizedTables[tableName] = transactionBoundTable;
    return transactionBoundTable;
  }
}
function createTransactionConstructor(db2) {
  return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
    this.db = db2;
    this.mode = mode;
    this.storeNames = storeNames;
    this.schema = dbschema;
    this.chromeTransactionDurability = chromeTransactionDurability;
    this.idbtrans = null;
    this.on = Events(this, "complete", "error", "abort");
    this.parent = parent || null;
    this.active = true;
    this._reculock = 0;
    this._blockedFuncs = [];
    this._resolve = null;
    this._reject = null;
    this._waitingFor = null;
    this._waitingQueue = null;
    this._spinCount = 0;
    this._completion = new DexiePromise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._completion.then(() => {
      this.active = false;
      this.on.complete.fire();
    }, (e) => {
      var wasActive = this.active;
      this.active = false;
      this.on.error.fire(e);
      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();
      return rejection(e);
    });
  });
}
function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
  return {
    name,
    keyPath,
    unique,
    multi,
    auto,
    compound,
    src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
  };
}
function nameFromKeyPath(keyPath) {
  return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
}
function createTableSchema(name, primKey, indexes) {
  return {
    name,
    primKey,
    indexes,
    mappedClass: null,
    idxByName: arrayToObject$1(indexes, (index) => [index.name, index])
  };
}
function safariMultiStoreFix(storeNames) {
  return storeNames.length === 1 ? storeNames[0] : storeNames;
}
let getMaxKey = (IdbKeyRange) => {
  try {
    IdbKeyRange.only([[]]);
    getMaxKey = () => [[]];
    return [[]];
  } catch (e) {
    getMaxKey = () => maxString;
    return maxString;
  }
};
function getKeyExtractor(keyPath) {
  if (keyPath == null) {
    return () => void 0;
  } else if (typeof keyPath === "string") {
    return getSinglePathKeyExtractor(keyPath);
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function getSinglePathKeyExtractor(keyPath) {
  const split2 = keyPath.split(".");
  if (split2.length === 1) {
    return (obj) => obj[keyPath];
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function arrayify(arrayLike) {
  return [].slice.call(arrayLike);
}
let _id_counter = 0;
function getKeyPathAlias(keyPath) {
  return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : `[${keyPath.join("+")}]`;
}
function createDBCore(db2, IdbKeyRange, tmpTrans) {
  function extractSchema(db3, trans) {
    const tables2 = arrayify(db3.objectStoreNames);
    return {
      schema: {
        name: db3.name,
        tables: tables2.map((table) => trans.objectStore(table)).map((store) => {
          const { keyPath, autoIncrement } = store;
          const compound = isArray$1(keyPath);
          const outbound = keyPath == null;
          const indexByKeyPath = {};
          const result = {
            name: store.name,
            primaryKey: {
              name: null,
              isPrimaryKey: true,
              outbound,
              compound,
              keyPath,
              autoIncrement,
              unique: true,
              extractKey: getKeyExtractor(keyPath)
            },
            indexes: arrayify(store.indexNames).map((indexName) => store.index(indexName)).map((index) => {
              const { name, unique, multiEntry, keyPath: keyPath2 } = index;
              const compound2 = isArray$1(keyPath2);
              const result2 = {
                name,
                compound: compound2,
                keyPath: keyPath2,
                unique,
                multiEntry,
                extractKey: getKeyExtractor(keyPath2)
              };
              indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
              return result2;
            }),
            getIndexByKeyPath: (keyPath2) => indexByKeyPath[getKeyPathAlias(keyPath2)]
          };
          indexByKeyPath[":id"] = result.primaryKey;
          if (keyPath != null) {
            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
          }
          return result;
        })
      },
      hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
    };
  }
  function makeIDBKeyRange(range2) {
    if (range2.type === 3)
      return null;
    if (range2.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower, upper, lowerOpen, upperOpen } = range2;
    const idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
    return idbRange;
  }
  function createDbCoreTable(tableSchema) {
    const tableName = tableSchema.name;
    function mutate({ trans, type: type2, keys: keys2, values, range: range2 }) {
      return new Promise((resolve, reject) => {
        resolve = wrap(resolve);
        const store = trans.objectStore(tableName);
        const outbound = store.keyPath == null;
        const isAddOrPut = type2 === "put" || type2 === "add";
        if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
          throw new Error("Invalid operation type: " + type2);
        const { length } = keys2 || values || { length: 1 };
        if (keys2 && values && keys2.length !== values.length) {
          throw new Error("Given keys array must have same length as given values array.");
        }
        if (length === 0)
          return resolve({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let req;
        const reqs = [];
        const failures = [];
        let numFailures = 0;
        const errorHandler = (event) => {
          ++numFailures;
          preventDefault(event);
        };
        if (type2 === "deleteRange") {
          if (range2.type === 4)
            return resolve({ numFailures, failures, results: [], lastResult: void 0 });
          if (range2.type === 3)
            reqs.push(req = store.clear());
          else
            reqs.push(req = store.delete(makeIDBKeyRange(range2)));
        } else {
          const [args1, args2] = isAddOrPut ? outbound ? [values, keys2] : [values, null] : [keys2, null];
          if (isAddOrPut) {
            for (let i = 0; i < length; ++i) {
              reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          } else {
            for (let i = 0; i < length; ++i) {
              reqs.push(req = store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          }
        }
        const done = (event) => {
          const lastResult = event.target.result;
          reqs.forEach((req2, i) => req2.error != null && (failures[i] = req2.error));
          resolve({
            numFailures,
            failures,
            results: type2 === "delete" ? keys2 : reqs.map((req2) => req2.result),
            lastResult
          });
        };
        req.onerror = (event) => {
          errorHandler(event);
          done(event);
        };
        req.onsuccess = done;
      });
    }
    function openCursor2({ trans, values, query: query3, reverse, unique }) {
      return new Promise((resolve, reject) => {
        resolve = wrap(resolve);
        const { index, range: range2 } = query3;
        const store = trans.objectStore(tableName);
        const source = index.isPrimaryKey ? store : store.index(index.name);
        const direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
        const req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range2), direction) : source.openKeyCursor(makeIDBKeyRange(range2), direction);
        req.onerror = eventRejectHandler(reject);
        req.onsuccess = wrap((ev) => {
          const cursor2 = req.result;
          if (!cursor2) {
            resolve(null);
            return;
          }
          cursor2.___id = ++_id_counter;
          cursor2.done = false;
          const _cursorContinue = cursor2.continue.bind(cursor2);
          let _cursorContinuePrimaryKey = cursor2.continuePrimaryKey;
          if (_cursorContinuePrimaryKey)
            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor2);
          const _cursorAdvance = cursor2.advance.bind(cursor2);
          const doThrowCursorIsNotStarted = () => {
            throw new Error("Cursor not started");
          };
          const doThrowCursorIsStopped = () => {
            throw new Error("Cursor not stopped");
          };
          cursor2.trans = trans;
          cursor2.stop = cursor2.continue = cursor2.continuePrimaryKey = cursor2.advance = doThrowCursorIsNotStarted;
          cursor2.fail = wrap(reject);
          cursor2.next = function() {
            let gotOne = 1;
            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);
          };
          cursor2.start = (callback) => {
            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {
              resolveIteration = wrap(resolveIteration);
              req.onerror = eventRejectHandler(rejectIteration);
              cursor2.fail = rejectIteration;
              cursor2.stop = (value) => {
                cursor2.stop = cursor2.continue = cursor2.continuePrimaryKey = cursor2.advance = doThrowCursorIsStopped;
                resolveIteration(value);
              };
            });
            const guardedCallback = () => {
              if (req.result) {
                try {
                  callback();
                } catch (err) {
                  cursor2.fail(err);
                }
              } else {
                cursor2.done = true;
                cursor2.start = () => {
                  throw new Error("Cursor behind last entry");
                };
                cursor2.stop();
              }
            };
            req.onsuccess = wrap((ev2) => {
              req.onsuccess = guardedCallback;
              guardedCallback();
            });
            cursor2.continue = _cursorContinue;
            cursor2.continuePrimaryKey = _cursorContinuePrimaryKey;
            cursor2.advance = _cursorAdvance;
            guardedCallback();
            return iterationPromise;
          };
          resolve(cursor2);
        }, reject);
      });
    }
    function query2(hasGetAll2) {
      return (request) => {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const { trans, values, limit: limit2, query: query3 } = request;
          const nonInfinitLimit = limit2 === Infinity ? void 0 : limit2;
          const { index, range: range2 } = query3;
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range2);
          if (limit2 === 0)
            return resolve({ result: [] });
          if (hasGetAll2) {
            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
            req.onsuccess = (event) => resolve({ result: event.target.result });
            req.onerror = eventRejectHandler(reject);
          } else {
            let count2 = 0;
            const req = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
            const result = [];
            req.onsuccess = (event) => {
              const cursor2 = req.result;
              if (!cursor2)
                return resolve({ result });
              result.push(values ? cursor2.value : cursor2.primaryKey);
              if (++count2 === limit2)
                return resolve({ result });
              cursor2.continue();
            };
            req.onerror = eventRejectHandler(reject);
          }
        });
      };
    }
    return {
      name: tableName,
      schema: tableSchema,
      mutate,
      getMany({ trans, keys: keys2 }) {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const store = trans.objectStore(tableName);
          const length = keys2.length;
          const result = new Array(length);
          let keyCount = 0;
          let callbackCount = 0;
          let req;
          const successHandler = (event) => {
            const req2 = event.target;
            if ((result[req2._pos] = req2.result) != null)
              ;
            if (++callbackCount === keyCount)
              resolve(result);
          };
          const errorHandler = eventRejectHandler(reject);
          for (let i = 0; i < length; ++i) {
            const key = keys2[i];
            if (key != null) {
              req = store.get(keys2[i]);
              req._pos = i;
              req.onsuccess = successHandler;
              req.onerror = errorHandler;
              ++keyCount;
            }
          }
          if (keyCount === 0)
            resolve(result);
        });
      },
      get({ trans, key }) {
        return new Promise((resolve, reject) => {
          resolve = wrap(resolve);
          const store = trans.objectStore(tableName);
          const req = store.get(key);
          req.onsuccess = (event) => resolve(event.target.result);
          req.onerror = eventRejectHandler(reject);
        });
      },
      query: query2(hasGetAll),
      openCursor: openCursor2,
      count({ query: query3, trans }) {
        const { index, range: range2 } = query3;
        return new Promise((resolve, reject) => {
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range2);
          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();
          req.onsuccess = wrap((ev) => resolve(ev.target.result));
          req.onerror = eventRejectHandler(reject);
        });
      }
    };
  }
  const { schema, hasGetAll } = extractSchema(db2, tmpTrans);
  const tables = schema.tables.map((tableSchema) => createDbCoreTable(tableSchema));
  const tableMap = {};
  tables.forEach((table) => tableMap[table.name] = table);
  return {
    stack: "dbcore",
    transaction: db2.transaction.bind(db2),
    table(name) {
      const result = tableMap[name];
      if (!result)
        throw new Error(`Table '${name}' not found`);
      return tableMap[name];
    },
    MIN_KEY: -Infinity,
    MAX_KEY: getMaxKey(IdbKeyRange),
    schema
  };
}
function createMiddlewareStack(stackImpl, middlewares) {
  return middlewares.reduce((down, { create: create2 }) => ({ ...down, ...create2(down) }), stackImpl);
}
function createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange: IDBKeyRange2, indexedDB: indexedDB2 }, tmpTrans) {
  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange2, tmpTrans), middlewares.dbcore);
  return {
    dbcore
  };
}
function generateMiddlewareStacks({ _novip: db2 }, tmpTrans) {
  const idbdb = tmpTrans.db;
  const stacks = createMiddlewareStacks(db2._middlewares, idbdb, db2._deps, tmpTrans);
  db2.core = stacks.dbcore;
  db2.tables.forEach((table) => {
    const tableName = table.name;
    if (db2.core.schema.tables.some((tbl) => tbl.name === tableName)) {
      table.core = db2.core.table(tableName);
      if (db2[tableName] instanceof db2.Table) {
        db2[tableName].core = table.core;
      }
    }
  });
}
function setApiOnPlace({ _novip: db2 }, objs, tableNames, dbschema) {
  tableNames.forEach((tableName) => {
    const schema = dbschema[tableName];
    objs.forEach((obj) => {
      const propDesc = getPropertyDescriptor(obj, tableName);
      if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
        if (obj === db2.Transaction.prototype || obj instanceof db2.Transaction) {
          setProp(obj, tableName, {
            get() {
              return this.table(tableName);
            },
            set(value) {
              defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
            }
          });
        } else {
          obj[tableName] = new db2.Table(tableName, schema);
        }
      }
    });
  });
}
function removeTablesApi({ _novip: db2 }, objs) {
  objs.forEach((obj) => {
    for (let key in obj) {
      if (obj[key] instanceof db2.Table)
        delete obj[key];
    }
  });
}
function lowerVersionFirst(a, b) {
  return a._cfg.version - b._cfg.version;
}
function runUpgraders(db2, oldVersion, idbUpgradeTrans, reject) {
  const globalSchema = db2._dbSchema;
  const trans = db2._createTransaction("readwrite", db2._storeNames, globalSchema);
  trans.create(idbUpgradeTrans);
  trans._completion.catch(reject);
  const rejectTransaction = trans._reject.bind(trans);
  const transless = PSD.transless || PSD;
  newScope(() => {
    PSD.trans = trans;
    PSD.transless = transless;
    if (oldVersion === 0) {
      keys(globalSchema).forEach((tableName) => {
        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
      });
      generateMiddlewareStacks(db2, idbUpgradeTrans);
      DexiePromise.follow(() => db2.on.populate.fire(trans)).catch(rejectTransaction);
    } else
      updateTablesAndIndexes(db2, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
  });
}
function updateTablesAndIndexes({ _novip: db2 }, oldVersion, trans, idbUpgradeTrans) {
  const queue = [];
  const versions = db2._versions;
  let globalSchema = db2._dbSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
  let anyContentUpgraderHasRun = false;
  const versToRun = versions.filter((v) => v._cfg.version >= oldVersion);
  versToRun.forEach((version) => {
    queue.push(() => {
      const oldSchema = globalSchema;
      const newSchema = version._cfg.dbschema;
      adjustToExistingIndexNames(db2, oldSchema, idbUpgradeTrans);
      adjustToExistingIndexNames(db2, newSchema, idbUpgradeTrans);
      globalSchema = db2._dbSchema = newSchema;
      const diff2 = getSchemaDiff(oldSchema, newSchema);
      diff2.add.forEach((tuple) => {
        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
      });
      diff2.change.forEach((change) => {
        if (change.recreate) {
          throw new exceptions.Upgrade("Not yet support for changing primary key");
        } else {
          const store = idbUpgradeTrans.objectStore(change.name);
          change.add.forEach((idx) => addIndex(store, idx));
          change.change.forEach((idx) => {
            store.deleteIndex(idx.name);
            addIndex(store, idx);
          });
          change.del.forEach((idxName) => store.deleteIndex(idxName));
        }
      });
      const contentUpgrade = version._cfg.contentUpgrade;
      if (contentUpgrade && version._cfg.version > oldVersion) {
        generateMiddlewareStacks(db2, idbUpgradeTrans);
        trans._memoizedTables = {};
        anyContentUpgraderHasRun = true;
        let upgradeSchema = shallowClone(newSchema);
        diff2.del.forEach((table) => {
          upgradeSchema[table] = oldSchema[table];
        });
        removeTablesApi(db2, [db2.Transaction.prototype]);
        setApiOnPlace(db2, [db2.Transaction.prototype], keys(upgradeSchema), upgradeSchema);
        trans.schema = upgradeSchema;
        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);
        if (contentUpgradeIsAsync) {
          incrementExpectedAwaits();
        }
        let returnValue;
        const promiseFollowed = DexiePromise.follow(() => {
          returnValue = contentUpgrade(trans);
          if (returnValue) {
            if (contentUpgradeIsAsync) {
              var decrementor = decrementExpectedAwaits.bind(null, null);
              returnValue.then(decrementor, decrementor);
            }
          }
        });
        return returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);
      }
    });
    queue.push((idbtrans) => {
      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
        const newSchema = version._cfg.dbschema;
        deleteRemovedTables(newSchema, idbtrans);
      }
      removeTablesApi(db2, [db2.Transaction.prototype]);
      setApiOnPlace(db2, [db2.Transaction.prototype], db2._storeNames, db2._dbSchema);
      trans.schema = db2._dbSchema;
    });
  });
  function runQueue() {
    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
  }
  return runQueue().then(() => {
    createMissingTables(globalSchema, idbUpgradeTrans);
  });
}
function getSchemaDiff(oldSchema, newSchema) {
  const diff2 = {
    del: [],
    add: [],
    change: []
  };
  let table;
  for (table in oldSchema) {
    if (!newSchema[table])
      diff2.del.push(table);
  }
  for (table in newSchema) {
    const oldDef = oldSchema[table], newDef = newSchema[table];
    if (!oldDef) {
      diff2.add.push([table, newDef]);
    } else {
      const change = {
        name: table,
        def: newDef,
        recreate: false,
        del: [],
        add: [],
        change: []
      };
      if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
        change.recreate = true;
        diff2.change.push(change);
      } else {
        const oldIndexes = oldDef.idxByName;
        const newIndexes = newDef.idxByName;
        let idxName;
        for (idxName in oldIndexes) {
          if (!newIndexes[idxName])
            change.del.push(idxName);
        }
        for (idxName in newIndexes) {
          const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
          if (!oldIdx)
            change.add.push(newIdx);
          else if (oldIdx.src !== newIdx.src)
            change.change.push(newIdx);
        }
        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
          diff2.change.push(change);
        }
      }
    }
  }
  return diff2;
}
function createTable(idbtrans, tableName, primKey, indexes) {
  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
  indexes.forEach((idx) => addIndex(store, idx));
  return store;
}
function createMissingTables(newSchema, idbtrans) {
  keys(newSchema).forEach((tableName) => {
    if (!idbtrans.db.objectStoreNames.contains(tableName)) {
      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
    }
  });
}
function deleteRemovedTables(newSchema, idbtrans) {
  [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName) => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));
}
function addIndex(store, idx) {
  store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
}
function buildGlobalSchema(db2, idbdb, tmpTrans) {
  const globalSchema = {};
  const dbStoreNames = slice$1(idbdb.objectStoreNames, 0);
  dbStoreNames.forEach((storeName) => {
    const store = tmpTrans.objectStore(storeName);
    let keyPath = store.keyPath;
    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
    const indexes = [];
    for (let j = 0; j < store.indexNames.length; ++j) {
      const idbindex = store.index(store.indexNames[j]);
      keyPath = idbindex.keyPath;
      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
      indexes.push(index);
    }
    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
  });
  return globalSchema;
}
function readGlobalSchema({ _novip: db2 }, idbdb, tmpTrans) {
  db2.verno = idbdb.version / 10;
  const globalSchema = db2._dbSchema = buildGlobalSchema(db2, idbdb, tmpTrans);
  db2._storeNames = slice$1(idbdb.objectStoreNames, 0);
  setApiOnPlace(db2, [db2._allTables], keys(globalSchema), globalSchema);
}
function verifyInstalledSchema(db2, tmpTrans) {
  const installedSchema = buildGlobalSchema(db2, db2.idbdb, tmpTrans);
  const diff2 = getSchemaDiff(installedSchema, db2._dbSchema);
  return !(diff2.add.length || diff2.change.some((ch) => ch.add.length || ch.change.length));
}
function adjustToExistingIndexNames({ _novip: db2 }, schema, idbtrans) {
  const storeNames = idbtrans.db.objectStoreNames;
  for (let i = 0; i < storeNames.length; ++i) {
    const storeName = storeNames[i];
    const store = idbtrans.objectStore(storeName);
    db2._hasGetAll = "getAll" in store;
    for (let j = 0; j < store.indexNames.length; ++j) {
      const indexName = store.indexNames[j];
      const keyPath = store.index(indexName).keyPath;
      const dexieName = typeof keyPath === "string" ? keyPath : "[" + slice$1(keyPath).join("+") + "]";
      if (schema[storeName]) {
        const indexSpec = schema[storeName].idxByName[dexieName];
        if (indexSpec) {
          indexSpec.name = indexName;
          delete schema[storeName].idxByName[dexieName];
          schema[storeName].idxByName[indexName] = indexSpec;
        }
      }
    }
  }
  if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
    db2._hasGetAll = false;
  }
}
function parseIndexSyntax(primKeyAndIndexes) {
  return primKeyAndIndexes.split(",").map((index, indexNum) => {
    index = index.trim();
    const name = index.replace(/([&*]|\+\+)/g, "");
    const keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
    return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray$1(keyPath), indexNum === 0);
  });
}
class Version {
  _parseStoresSpec(stores, outSchema) {
    keys(stores).forEach((tableName) => {
      if (stores[tableName] !== null) {
        var indexes = parseIndexSyntax(stores[tableName]);
        var primKey = indexes.shift();
        if (primKey.multi)
          throw new exceptions.Schema("Primary key cannot be multi-valued");
        indexes.forEach((idx) => {
          if (idx.auto)
            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!idx.keyPath)
            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
        });
        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
      }
    });
  }
  stores(stores) {
    const db2 = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
    const versions = db2._versions;
    const storesSpec = {};
    let dbschema = {};
    versions.forEach((version) => {
      extend(storesSpec, version._cfg.storesSource);
      dbschema = version._cfg.dbschema = {};
      version._parseStoresSpec(storesSpec, dbschema);
    });
    db2._dbSchema = dbschema;
    removeTablesApi(db2, [db2._allTables, db2, db2.Transaction.prototype]);
    setApiOnPlace(db2, [db2._allTables, db2, db2.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
    db2._storeNames = keys(dbschema);
    return this;
  }
  upgrade(upgradeFunction) {
    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
    return this;
  }
}
function createVersionConstructor(db2) {
  return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
    this.db = db2;
    this._cfg = {
      version: versionNumber,
      storesSource: null,
      dbschema: {},
      tables: {},
      contentUpgrade: null
    };
  });
}
function getDbNamesTable(indexedDB2, IDBKeyRange2) {
  let dbNamesDB = indexedDB2["_dbNamesDB"];
  if (!dbNamesDB) {
    dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
      addons: [],
      indexedDB: indexedDB2,
      IDBKeyRange: IDBKeyRange2
    });
    dbNamesDB.version(1).stores({ dbnames: "name" });
  }
  return dbNamesDB.table("dbnames");
}
function hasDatabasesNative(indexedDB2) {
  return indexedDB2 && typeof indexedDB2.databases === "function";
}
function getDatabaseNames({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }) {
  return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then((infos) => infos.map((info) => info.name).filter((name) => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB2, IDBKeyRange2).toCollection().primaryKeys();
}
function _onDatabaseCreated({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).put({ name }).catch(nop);
}
function _onDatabaseDeleted({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).delete(name).catch(nop);
}
function vip(fn) {
  return newScope(function() {
    PSD.letThrough = true;
    return fn();
  });
}
function idbReady() {
  var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari || !indexedDB.databases)
    return Promise.resolve();
  var intervalId;
  return new Promise(function(resolve) {
    var tryIdb = function() {
      return indexedDB.databases().finally(resolve);
    };
    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function() {
    return clearInterval(intervalId);
  });
}
function dexieOpen(db2) {
  const state = db2._state;
  const { indexedDB: indexedDB2 } = db2._deps;
  if (state.isBeingOpened || db2.idbdb)
    return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db2);
  debug$1 && (state.openCanceller._stackHolder = getErrorWithStack());
  state.isBeingOpened = true;
  state.dbOpenError = null;
  state.openComplete = false;
  const openCanceller = state.openCanceller;
  function throwIfCancelled() {
    if (state.openCanceller !== openCanceller)
      throw new exceptions.DatabaseClosed("db.open() was cancelled");
  }
  let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
  return DexiePromise.race([openCanceller, (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {
    throwIfCancelled();
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    const dbName = db2.name;
    const req = state.autoSchema ? indexedDB2.open(dbName) : indexedDB2.open(dbName, Math.round(db2.verno * 10));
    if (!req)
      throw new exceptions.MissingAPI();
    req.onerror = eventRejectHandler(reject);
    req.onblocked = wrap(db2._fireOnBlocked);
    req.onupgradeneeded = wrap((e) => {
      upgradeTransaction = req.transaction;
      if (state.autoSchema && !db2._options.allowEmptyDB) {
        req.onerror = preventDefault;
        upgradeTransaction.abort();
        req.result.close();
        const delreq = indexedDB2.deleteDatabase(dbName);
        delreq.onsuccess = delreq.onerror = wrap(() => {
          reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));
        });
      } else {
        upgradeTransaction.onerror = eventRejectHandler(reject);
        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
        wasCreated = oldVer < 1;
        db2._novip.idbdb = req.result;
        runUpgraders(db2, oldVer / 10, upgradeTransaction, reject);
      }
    }, reject);
    req.onsuccess = wrap(() => {
      upgradeTransaction = null;
      const idbdb = db2._novip.idbdb = req.result;
      const objectStoreNames = slice$1(idbdb.objectStoreNames);
      if (objectStoreNames.length > 0)
        try {
          const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
          if (state.autoSchema)
            readGlobalSchema(db2, idbdb, tmpTrans);
          else {
            adjustToExistingIndexNames(db2, db2._dbSchema, tmpTrans);
            if (!verifyInstalledSchema(db2, tmpTrans)) {
              console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);
            }
          }
          generateMiddlewareStacks(db2, tmpTrans);
        } catch (e) {
        }
      connections.push(db2);
      idbdb.onversionchange = wrap((ev) => {
        state.vcFired = true;
        db2.on("versionchange").fire(ev);
      });
      idbdb.onclose = wrap((ev) => {
        db2.on("close").fire(ev);
      });
      if (wasCreated)
        _onDatabaseCreated(db2._deps, dbName);
      resolve();
    }, reject);
  }))]).then(() => {
    throwIfCancelled();
    state.onReadyBeingFired = [];
    return DexiePromise.resolve(vip(() => db2.on.ready.fire(db2.vip))).then(function fireRemainders() {
      if (state.onReadyBeingFired.length > 0) {
        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(() => remainders(db2.vip))).then(fireRemainders);
      }
    });
  }).finally(() => {
    state.onReadyBeingFired = null;
    state.isBeingOpened = false;
  }).then(() => {
    return db2;
  }).catch((err) => {
    state.dbOpenError = err;
    try {
      upgradeTransaction && upgradeTransaction.abort();
    } catch (_a) {
    }
    if (openCanceller === state.openCanceller) {
      db2._close();
    }
    return rejection(err);
  }).finally(() => {
    state.openComplete = true;
    resolveDbReady();
  });
}
function awaitIterator(iterator2) {
  var callNext = (result) => iterator2.next(result), doThrow = (error) => iterator2.throw(error), onSuccess = step(callNext), onError = step(doThrow);
  function step(getNext) {
    return (val) => {
      var next = getNext(val), value = next.value;
      return next.done ? value : !value || typeof value.then !== "function" ? isArray$1(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
    };
  }
  return step(callNext)();
}
function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
  var i = arguments.length;
  if (i < 2)
    throw new exceptions.InvalidArgument("Too few arguments");
  var args2 = new Array(i - 1);
  while (--i)
    args2[i - 1] = arguments[i];
  scopeFunc = args2.pop();
  var tables = flatten(args2);
  return [mode, tables, scopeFunc];
}
function enterTransactionScope(db2, mode, storeNames, parentTransaction, scopeFunc) {
  return DexiePromise.resolve().then(() => {
    const transless = PSD.transless || PSD;
    const trans = db2._createTransaction(mode, storeNames, db2._dbSchema, parentTransaction);
    const zoneProps = {
      trans,
      transless
    };
    if (parentTransaction) {
      trans.idbtrans = parentTransaction.idbtrans;
    } else {
      try {
        trans.create();
        db2._state.PR1398_maxLoop = 3;
      } catch (ex) {
        if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
          console.warn("Dexie: Need to reopen db");
          db2._close();
          return db2.open().then(() => enterTransactionScope(db2, mode, storeNames, null, scopeFunc));
        }
        return rejection(ex);
      }
    }
    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);
    if (scopeFuncIsAsync) {
      incrementExpectedAwaits();
    }
    let returnValue;
    const promiseFollowed = DexiePromise.follow(() => {
      returnValue = scopeFunc.call(trans, trans);
      if (returnValue) {
        if (scopeFuncIsAsync) {
          var decrementor = decrementExpectedAwaits.bind(null, null);
          returnValue.then(decrementor, decrementor);
        } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
          returnValue = awaitIterator(returnValue);
        }
      }
    }, zoneProps);
    return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then((x) => trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : promiseFollowed.then(() => returnValue)).then((x) => {
      if (parentTransaction)
        trans._resolve();
      return trans._completion.then(() => x);
    }).catch((e) => {
      trans._reject(e);
      return rejection(e);
    });
  });
}
function pad(a, value, count2) {
  const result = isArray$1(a) ? a.slice() : [a];
  for (let i = 0; i < count2; ++i)
    result.push(value);
  return result;
}
function createVirtualIndexMiddleware(down) {
  return {
    ...down,
    table(tableName) {
      const table = down.table(tableName);
      const { schema } = table;
      const indexLookup = {};
      const allVirtualIndexes = [];
      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
        const keyPathAlias = getKeyPathAlias(keyPath);
        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
        const keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
        const isVirtual = keyTail > 0;
        const virtualIndex = {
          ...lowLevelIndex,
          isVirtual,
          keyTail,
          keyLength,
          extractKey: getKeyExtractor(keyPath),
          unique: !isVirtual && lowLevelIndex.unique
        };
        indexList.push(virtualIndex);
        if (!virtualIndex.isPrimaryKey) {
          allVirtualIndexes.push(virtualIndex);
        }
        if (keyLength > 1) {
          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
        }
        indexList.sort((a, b) => a.keyTail - b.keyTail);
        return virtualIndex;
      }
      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
      indexLookup[":id"] = [primaryKey];
      for (const index of schema.indexes) {
        addVirtualIndexes(index.keyPath, 0, index);
      }
      function findBestIndex(keyPath) {
        const result2 = indexLookup[getKeyPathAlias(keyPath)];
        return result2 && result2[0];
      }
      function translateRange(range2, keyTail) {
        return {
          type: range2.type === 1 ? 2 : range2.type,
          lower: pad(range2.lower, range2.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
          lowerOpen: true,
          upper: pad(range2.upper, range2.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
          upperOpen: true
        };
      }
      function translateRequest(req) {
        const index = req.query.index;
        return index.isVirtual ? {
          ...req,
          query: {
            index,
            range: translateRange(req.query.range, index.keyTail)
          }
        } : req;
      }
      const result = {
        ...table,
        schema: {
          ...schema,
          primaryKey,
          indexes: allVirtualIndexes,
          getIndexByKeyPath: findBestIndex
        },
        count(req) {
          return table.count(translateRequest(req));
        },
        query(req) {
          return table.query(translateRequest(req));
        },
        openCursor(req) {
          const { keyTail, isVirtual, keyLength } = req.query.index;
          if (!isVirtual)
            return table.openCursor(req);
          function createVirtualCursor(cursor2) {
            function _continue(key) {
              key != null ? cursor2.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor2.continue(cursor2.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor2.continue();
            }
            const virtualCursor = Object.create(cursor2, {
              continue: { value: _continue },
              continuePrimaryKey: {
                value(key, primaryKey2) {
                  cursor2.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                }
              },
              primaryKey: {
                get() {
                  return cursor2.primaryKey;
                }
              },
              key: {
                get() {
                  const key = cursor2.key;
                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                }
              },
              value: {
                get() {
                  return cursor2.value;
                }
              }
            });
            return virtualCursor;
          }
          return table.openCursor(translateRequest(req)).then((cursor2) => cursor2 && createVirtualCursor(cursor2));
        }
      };
      return result;
    }
  };
}
const virtualIndexMiddleware = {
  stack: "dbcore",
  name: "VirtualIndexMiddleware",
  level: 1,
  create: createVirtualIndexMiddleware
};
function getObjectDiff(a, b, rv, prfx) {
  rv = rv || {};
  prfx = prfx || "";
  keys(a).forEach((prop) => {
    if (!hasOwn(b, prop)) {
      rv[prfx + prop] = void 0;
    } else {
      var ap = a[prop], bp = b[prop];
      if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
        const apTypeName = toStringTag(ap);
        const bpTypeName = toStringTag(bp);
        if (apTypeName !== bpTypeName) {
          rv[prfx + prop] = b[prop];
        } else if (apTypeName === "Object") {
          getObjectDiff(ap, bp, rv, prfx + prop + ".");
        } else if (ap !== bp) {
          rv[prfx + prop] = b[prop];
        }
      } else if (ap !== bp)
        rv[prfx + prop] = b[prop];
    }
  });
  keys(b).forEach((prop) => {
    if (!hasOwn(a, prop)) {
      rv[prfx + prop] = b[prop];
    }
  });
  return rv;
}
function getEffectiveKeys(primaryKey, req) {
  if (req.type === "delete")
    return req.keys;
  return req.keys || req.values.map(primaryKey.extractKey);
}
const hooksMiddleware = {
  stack: "dbcore",
  name: "HooksMiddleware",
  level: 2,
  create: (downCore) => ({
    ...downCore,
    table(tableName) {
      const downTable = downCore.table(tableName);
      const { primaryKey } = downTable.schema;
      const tableMiddleware = {
        ...downTable,
        mutate(req) {
          const dxTrans = PSD.trans;
          const { deleting, creating, updating } = dxTrans.table(tableName).hook;
          switch (req.type) {
            case "add":
              if (creating.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "put":
              if (creating.fire === nop && updating.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "delete":
              if (deleting.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "deleteRange":
              if (deleting.fire === nop)
                break;
              return dxTrans._promise("readwrite", () => deleteRange(req), true);
          }
          return downTable.mutate(req);
          function addPutOrDelete(req2) {
            const dxTrans2 = PSD.trans;
            const keys2 = req2.keys || getEffectiveKeys(primaryKey, req2);
            if (!keys2)
              throw new Error("Keys missing");
            req2 = req2.type === "add" || req2.type === "put" ? { ...req2, keys: keys2 } : { ...req2 };
            if (req2.type !== "delete")
              req2.values = [...req2.values];
            if (req2.keys)
              req2.keys = [...req2.keys];
            return getExistingValues(downTable, req2, keys2).then((existingValues) => {
              const contexts = keys2.map((key, i) => {
                const existingValue = existingValues[i];
                const ctx = { onerror: null, onsuccess: null };
                if (req2.type === "delete") {
                  deleting.fire.call(ctx, key, existingValue, dxTrans2);
                } else if (req2.type === "add" || existingValue === void 0) {
                  const generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                  if (key == null && generatedPrimaryKey != null) {
                    key = generatedPrimaryKey;
                    req2.keys[i] = key;
                    if (!primaryKey.outbound) {
                      setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                    }
                  }
                } else {
                  const objectDiff = getObjectDiff(existingValue, req2.values[i]);
                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                  if (additionalChanges) {
                    const requestedValue = req2.values[i];
                    Object.keys(additionalChanges).forEach((keyPath) => {
                      if (hasOwn(requestedValue, keyPath)) {
                        requestedValue[keyPath] = additionalChanges[keyPath];
                      } else {
                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);
                      }
                    });
                  }
                }
                return ctx;
              });
              return downTable.mutate(req2).then(({ failures, results, numFailures, lastResult }) => {
                for (let i = 0; i < keys2.length; ++i) {
                  const primKey = results ? results[i] : keys2[i];
                  const ctx = contexts[i];
                  if (primKey == null) {
                    ctx.onerror && ctx.onerror(failures[i]);
                  } else {
                    ctx.onsuccess && ctx.onsuccess(
                      req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                    );
                  }
                }
                return { failures, results, numFailures, lastResult };
              }).catch((error) => {
                contexts.forEach((ctx) => ctx.onerror && ctx.onerror(error));
                return Promise.reject(error);
              });
            });
          }
          function deleteRange(req2) {
            return deleteNextChunk(req2.trans, req2.range, 1e4);
          }
          function deleteNextChunk(trans, range2, limit2) {
            return downTable.query({ trans, values: false, query: { index: primaryKey, range: range2 }, limit: limit2 }).then(({ result }) => {
              return addPutOrDelete({ type: "delete", keys: result, trans }).then((res) => {
                if (res.numFailures > 0)
                  return Promise.reject(res.failures[0]);
                if (result.length < limit2) {
                  return { failures: [], numFailures: 0, lastResult: void 0 };
                } else {
                  return deleteNextChunk(trans, { ...range2, lower: result[result.length - 1], lowerOpen: true }, limit2);
                }
              });
            });
          }
        }
      };
      return tableMiddleware;
    }
  })
};
function getExistingValues(table, req, effectiveKeys) {
  return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
}
function getFromTransactionCache(keys2, cache, clone2) {
  try {
    if (!cache)
      return null;
    if (cache.keys.length < keys2.length)
      return null;
    const result = [];
    for (let i = 0, j = 0; i < cache.keys.length && j < keys2.length; ++i) {
      if (cmp$2(cache.keys[i], keys2[j]) !== 0)
        continue;
      result.push(clone2 ? deepClone(cache.values[i]) : cache.values[i]);
      ++j;
    }
    return result.length === keys2.length ? result : null;
  } catch (_a) {
    return null;
  }
}
const cacheExistingValuesMiddleware = {
  stack: "dbcore",
  level: -1,
  create: (core2) => {
    return {
      table: (tableName) => {
        const table = core2.table(tableName);
        return {
          ...table,
          getMany: (req) => {
            if (!req.cache) {
              return table.getMany(req);
            }
            const cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
            if (cachedResult) {
              return DexiePromise.resolve(cachedResult);
            }
            return table.getMany(req).then((res) => {
              req.trans["_cache"] = {
                keys: req.keys,
                values: req.cache === "clone" ? deepClone(res) : res
              };
              return res;
            });
          },
          mutate: (req) => {
            if (req.type !== "add")
              req.trans["_cache"] = null;
            return table.mutate(req);
          }
        };
      }
    };
  }
};
function isEmptyRange(node2) {
  return !("from" in node2);
}
const RangeSet = function(fromOrTree, to) {
  if (this) {
    extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
  } else {
    const rv = new RangeSet();
    if (fromOrTree && "d" in fromOrTree) {
      extend(rv, fromOrTree);
    }
    return rv;
  }
};
props(RangeSet.prototype, {
  add(rangeSet) {
    mergeRanges(this, rangeSet);
    return this;
  },
  addKey(key) {
    addRange(this, key, key);
    return this;
  },
  addKeys(keys2) {
    keys2.forEach((key) => addRange(this, key, key));
    return this;
  },
  [iteratorSymbol]() {
    return getRangeSetIterator(this);
  }
});
function addRange(target, from2, to) {
  const diff2 = cmp$2(from2, to);
  if (isNaN(diff2))
    return;
  if (diff2 > 0)
    throw RangeError();
  if (isEmptyRange(target))
    return extend(target, { from: from2, to, d: 1 });
  const left = target.l;
  const right = target.r;
  if (cmp$2(to, target.from) < 0) {
    left ? addRange(left, from2, to) : target.l = { from: from2, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp$2(from2, target.to) > 0) {
    right ? addRange(right, from2, to) : target.r = { from: from2, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp$2(from2, target.from) < 0) {
    target.from = from2;
    target.l = null;
    target.d = right ? right.d + 1 : 1;
  }
  if (cmp$2(to, target.to) > 0) {
    target.to = to;
    target.r = null;
    target.d = target.l ? target.l.d + 1 : 1;
  }
  const rightWasCutOff = !target.r;
  if (left && !target.l) {
    mergeRanges(target, left);
  }
  if (right && rightWasCutOff) {
    mergeRanges(target, right);
  }
}
function mergeRanges(target, newSet) {
  function _addRangeSet(target2, { from: from2, to, l, r }) {
    addRange(target2, from2, to);
    if (l)
      _addRangeSet(target2, l);
    if (r)
      _addRangeSet(target2, r);
  }
  if (!isEmptyRange(newSet))
    _addRangeSet(target, newSet);
}
function rangesOverlap(rangeSet1, rangeSet2) {
  const i1 = getRangeSetIterator(rangeSet2);
  let nextResult1 = i1.next();
  if (nextResult1.done)
    return false;
  let a = nextResult1.value;
  const i2 = getRangeSetIterator(rangeSet1);
  let nextResult2 = i2.next(a.from);
  let b = nextResult2.value;
  while (!nextResult1.done && !nextResult2.done) {
    if (cmp$2(b.from, a.to) <= 0 && cmp$2(b.to, a.from) >= 0)
      return true;
    cmp$2(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
  }
  return false;
}
function getRangeSetIterator(node2) {
  let state = isEmptyRange(node2) ? null : { s: 0, n: node2 };
  return {
    next(key) {
      const keyProvided = arguments.length > 0;
      while (state) {
        switch (state.s) {
          case 0:
            state.s = 1;
            if (keyProvided) {
              while (state.n.l && cmp$2(key, state.n.from) < 0)
                state = { up: state, n: state.n.l, s: 1 };
            } else {
              while (state.n.l)
                state = { up: state, n: state.n.l, s: 1 };
            }
          case 1:
            state.s = 2;
            if (!keyProvided || cmp$2(key, state.n.to) <= 0)
              return { value: state.n, done: false };
          case 2:
            if (state.n.r) {
              state.s = 3;
              state = { up: state, n: state.n.r, s: 0 };
              continue;
            }
          case 3:
            state = state.up;
        }
      }
      return { done: true };
    }
  };
}
function rebalance(target) {
  var _a, _b;
  const diff2 = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
  const r = diff2 > 1 ? "r" : diff2 < -1 ? "l" : "";
  if (r) {
    const l = r === "r" ? "l" : "r";
    const rootClone = { ...target };
    const oldRootRight = target[r];
    target.from = oldRootRight.from;
    target.to = oldRootRight.to;
    target[r] = oldRootRight[r];
    rootClone[r] = oldRootRight[l];
    target[l] = rootClone;
    rootClone.d = computeDepth(rootClone);
  }
  target.d = computeDepth(target);
}
function computeDepth({ r, l }) {
  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
}
const observabilityMiddleware = {
  stack: "dbcore",
  level: 0,
  create: (core2) => {
    const dbName = core2.schema.name;
    const FULL_RANGE = new RangeSet(core2.MIN_KEY, core2.MAX_KEY);
    return {
      ...core2,
      table: (tableName) => {
        const table = core2.table(tableName);
        const { schema } = table;
        const { primaryKey } = schema;
        const { extractKey: extractKey2, outbound } = primaryKey;
        const tableClone = {
          ...table,
          mutate: (req) => {
            const trans = req.trans;
            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
            const getRangeSet = (indexName) => {
              const part = `idb://${dbName}/${tableName}/${indexName}`;
              return mutatedParts[part] || (mutatedParts[part] = new RangeSet());
            };
            const pkRangeSet = getRangeSet("");
            const delsRangeSet = getRangeSet(":dels");
            const { type: type2 } = req;
            let [keys2, newObjs] = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];
            const oldCache = req.trans["_cache"];
            return table.mutate(req).then((res) => {
              if (isArray$1(keys2)) {
                if (type2 !== "delete")
                  keys2 = res.results;
                pkRangeSet.addKeys(keys2);
                const oldObjs = getFromTransactionCache(keys2, oldCache);
                if (!oldObjs && type2 !== "add") {
                  delsRangeSet.addKeys(keys2);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys2) {
                const range2 = { from: keys2.lower, to: keys2.upper };
                delsRangeSet.add(range2);
                pkRangeSet.add(range2);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach((idx) => getRangeSet(idx.name).add(FULL_RANGE));
              }
              return res;
            });
          }
        };
        const getRange = ({ query: { index, range: range2 } }) => {
          var _a, _b;
          return [
            index,
            new RangeSet((_a = range2.lower) !== null && _a !== void 0 ? _a : core2.MIN_KEY, (_b = range2.upper) !== null && _b !== void 0 ? _b : core2.MAX_KEY)
          ];
        };
        const readSubscribers = {
          get: (req) => [primaryKey, new RangeSet(req.key)],
          getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],
          count: getRange,
          query: getRange,
          openCursor: getRange
        };
        keys(readSubscribers).forEach((method) => {
          tableClone[method] = function(req) {
            const { subscr } = PSD;
            if (subscr) {
              const getRangeSet = (indexName) => {
                const part = `idb://${dbName}/${tableName}/${indexName}`;
                return subscr[part] || (subscr[part] = new RangeSet());
              };
              const pkRangeSet = getRangeSet("");
              const delsRangeSet = getRangeSet(":dels");
              const [queriedIndex, queriedRanges] = readSubscribers[method](req);
              getRangeSet(queriedIndex.name || "").add(queriedRanges);
              if (!queriedIndex.isPrimaryKey) {
                if (method === "count") {
                  delsRangeSet.add(FULL_RANGE);
                } else {
                  const keysPromise = method === "query" && outbound && req.values && table.query({
                    ...req,
                    values: false
                  });
                  return table[method].apply(this, arguments).then((res) => {
                    if (method === "query") {
                      if (outbound && req.values) {
                        return keysPromise.then(({ result: resultingKeys }) => {
                          pkRangeSet.addKeys(resultingKeys);
                          return res;
                        });
                      }
                      const pKeys = req.values ? res.result.map(extractKey2) : res.result;
                      if (req.values) {
                        pkRangeSet.addKeys(pKeys);
                      } else {
                        delsRangeSet.addKeys(pKeys);
                      }
                    } else if (method === "openCursor") {
                      const cursor2 = res;
                      const wantValues = req.values;
                      return cursor2 && Object.create(cursor2, {
                        key: {
                          get() {
                            delsRangeSet.addKey(cursor2.primaryKey);
                            return cursor2.key;
                          }
                        },
                        primaryKey: {
                          get() {
                            const pkey = cursor2.primaryKey;
                            delsRangeSet.addKey(pkey);
                            return pkey;
                          }
                        },
                        value: {
                          get() {
                            wantValues && pkRangeSet.addKey(cursor2.primaryKey);
                            return cursor2.value;
                          }
                        }
                      });
                    }
                    return res;
                  });
                }
              }
            }
            return table[method].apply(this, arguments);
          };
        });
        return tableClone;
      }
    };
  }
};
function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
  function addAffectedIndex(ix) {
    const rangeSet = getRangeSet(ix.name || "");
    function extractKey2(obj) {
      return obj != null ? ix.extractKey(obj) : null;
    }
    const addKeyOrKeys = (key) => ix.multiEntry && isArray$1(key) ? key.forEach((key2) => rangeSet.addKey(key2)) : rangeSet.addKey(key);
    (oldObjs || newObjs).forEach((_, i) => {
      const oldKey = oldObjs && extractKey2(oldObjs[i]);
      const newKey = newObjs && extractKey2(newObjs[i]);
      if (cmp$2(oldKey, newKey) !== 0) {
        if (oldKey != null)
          addKeyOrKeys(oldKey);
        if (newKey != null)
          addKeyOrKeys(newKey);
      }
    });
  }
  schema.indexes.forEach(addAffectedIndex);
}
class Dexie$1 {
  constructor(name, options2) {
    this._middlewares = {};
    this.verno = 0;
    const deps = Dexie$1.dependencies;
    this._options = options2 = {
      addons: Dexie$1.addons,
      autoOpen: true,
      indexedDB: deps.indexedDB,
      IDBKeyRange: deps.IDBKeyRange,
      ...options2
    };
    this._deps = {
      indexedDB: options2.indexedDB,
      IDBKeyRange: options2.IDBKeyRange
    };
    const { addons } = options2;
    this._dbSchema = {};
    this._versions = [];
    this._storeNames = [];
    this._allTables = {};
    this.idbdb = null;
    this._novip = this;
    const state = {
      dbOpenError: null,
      isBeingOpened: false,
      onReadyBeingFired: null,
      openComplete: false,
      dbReadyResolve: nop,
      dbReadyPromise: null,
      cancelOpen: nop,
      openCanceller: null,
      autoSchema: true,
      PR1398_maxLoop: 3
    };
    state.dbReadyPromise = new DexiePromise((resolve) => {
      state.dbReadyResolve = resolve;
    });
    state.openCanceller = new DexiePromise((_, reject) => {
      state.cancelOpen = reject;
    });
    this._state = state;
    this.name = name;
    this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
    this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe) => {
      return (subscriber, bSticky) => {
        Dexie$1.vip(() => {
          const state2 = this._state;
          if (state2.openComplete) {
            if (!state2.dbOpenError)
              DexiePromise.resolve().then(subscriber);
            if (bSticky)
              subscribe(subscriber);
          } else if (state2.onReadyBeingFired) {
            state2.onReadyBeingFired.push(subscriber);
            if (bSticky)
              subscribe(subscriber);
          } else {
            subscribe(subscriber);
            const db2 = this;
            if (!bSticky)
              subscribe(function unsubscribe() {
                db2.on.ready.unsubscribe(subscriber);
                db2.on.ready.unsubscribe(unsubscribe);
              });
          }
        });
      };
    });
    this.Collection = createCollectionConstructor(this);
    this.Table = createTableConstructor(this);
    this.Transaction = createTransactionConstructor(this);
    this.Version = createVersionConstructor(this);
    this.WhereClause = createWhereClauseConstructor(this);
    this.on("versionchange", (ev) => {
      if (ev.newVersion > 0)
        console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);
      else
        console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);
      this.close();
    });
    this.on("blocked", (ev) => {
      if (!ev.newVersion || ev.newVersion < ev.oldVersion)
        console.warn(`Dexie.delete('${this.name}') was blocked`);
      else
        console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);
    });
    this._maxKey = getMaxKey(options2.IDBKeyRange);
    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);
    this._fireOnBlocked = (ev) => {
      this.on("blocked").fire(ev);
      connections.filter((c) => c.name === this.name && c !== this && !c._state.vcFired).map((c) => c.on("versionchange").fire(ev));
    };
    this.use(virtualIndexMiddleware);
    this.use(hooksMiddleware);
    this.use(observabilityMiddleware);
    this.use(cacheExistingValuesMiddleware);
    this.vip = Object.create(this, { _vip: { value: true } });
    addons.forEach((addon) => addon(this));
  }
  version(versionNumber) {
    if (isNaN(versionNumber) || versionNumber < 0.1)
      throw new exceptions.Type(`Given version is not a positive number`);
    versionNumber = Math.round(versionNumber * 10) / 10;
    if (this.idbdb || this._state.isBeingOpened)
      throw new exceptions.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, versionNumber);
    const versions = this._versions;
    var versionInstance = versions.filter((v) => v._cfg.version === versionNumber)[0];
    if (versionInstance)
      return versionInstance;
    versionInstance = new this.Version(versionNumber);
    versions.push(versionInstance);
    versions.sort(lowerVersionFirst);
    versionInstance.stores({});
    this._state.autoSchema = false;
    return versionInstance;
  }
  _whenReady(fn) {
    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve, reject) => {
      if (this._state.openComplete) {
        return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));
      }
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen) {
          reject(new exceptions.DatabaseClosed());
          return;
        }
        this.open().catch(nop);
      }
      this._state.dbReadyPromise.then(resolve, reject);
    }).then(fn);
  }
  use({ stack, create: create2, level, name }) {
    if (name)
      this.unuse({ stack, name });
    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
    middlewares.push({ stack, create: create2, level: level == null ? 10 : level, name });
    middlewares.sort((a, b) => a.level - b.level);
    return this;
  }
  unuse({ stack, name, create: create2 }) {
    if (stack && this._middlewares[stack]) {
      this._middlewares[stack] = this._middlewares[stack].filter((mw) => create2 ? mw.create !== create2 : name ? mw.name !== name : false);
    }
    return this;
  }
  open() {
    return dexieOpen(this);
  }
  _close() {
    const state = this._state;
    const idx = connections.indexOf(this);
    if (idx >= 0)
      connections.splice(idx, 1);
    if (this.idbdb) {
      try {
        this.idbdb.close();
      } catch (e) {
      }
      this._novip.idbdb = null;
    }
    state.dbReadyPromise = new DexiePromise((resolve) => {
      state.dbReadyResolve = resolve;
    });
    state.openCanceller = new DexiePromise((_, reject) => {
      state.cancelOpen = reject;
    });
  }
  close() {
    this._close();
    const state = this._state;
    this._options.autoOpen = false;
    state.dbOpenError = new exceptions.DatabaseClosed();
    if (state.isBeingOpened)
      state.cancelOpen(state.dbOpenError);
  }
  delete() {
    const hasArguments = arguments.length > 0;
    const state = this._state;
    return new DexiePromise((resolve, reject) => {
      const doDelete = () => {
        this.close();
        var req = this._deps.indexedDB.deleteDatabase(this.name);
        req.onsuccess = wrap(() => {
          _onDatabaseDeleted(this._deps, this.name);
          resolve();
        });
        req.onerror = eventRejectHandler(reject);
        req.onblocked = this._fireOnBlocked;
      };
      if (hasArguments)
        throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
      if (state.isBeingOpened) {
        state.dbReadyPromise.then(doDelete);
      } else {
        doDelete();
      }
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const dbOpenError = this._state.dbOpenError;
    return dbOpenError && dbOpenError.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return keys(this._allTables).map((name) => this._allTables[name]);
  }
  transaction() {
    const args2 = extractTransactionArgs.apply(this, arguments);
    return this._transaction.apply(this, args2);
  }
  _transaction(mode, tables, scopeFunc) {
    let parentTransaction = PSD.trans;
    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
      parentTransaction = null;
    const onlyIfCompatible = mode.indexOf("?") !== -1;
    mode = mode.replace("!", "").replace("?", "");
    let idbMode, storeNames;
    try {
      storeNames = tables.map((table) => {
        var storeName = table instanceof this.Table ? table.name : table;
        if (typeof storeName !== "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return storeName;
      });
      if (mode == "r" || mode === READONLY)
        idbMode = READONLY;
      else if (mode == "rw" || mode == READWRITE)
        idbMode = READWRITE;
      else
        throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
      if (parentTransaction) {
        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
          if (onlyIfCompatible) {
            parentTransaction = null;
          } else
            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
        }
        if (parentTransaction) {
          storeNames.forEach((storeName) => {
            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
              if (onlyIfCompatible) {
                parentTransaction = null;
              } else
                throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
            }
          });
        }
        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
          parentTransaction = null;
        }
      }
    } catch (e) {
      return parentTransaction ? parentTransaction._promise(null, (_, reject) => {
        reject(e);
      }) : rejection(e);
    }
    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);
  }
  table(tableName) {
    if (!hasOwn(this._allTables, tableName)) {
      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);
    }
    return this._allTables[tableName];
  }
}
const symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
class Observable {
  constructor(subscribe) {
    this._subscribe = subscribe;
  }
  subscribe(x, error, complete) {
    return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
  }
  [symbolObservable]() {
    return this;
  }
}
function extendObservabilitySet(target, newSet) {
  keys(newSet).forEach((part) => {
    const rangeSet = target[part] || (target[part] = new RangeSet());
    mergeRanges(rangeSet, newSet[part]);
  });
  return target;
}
function liveQuery(querier) {
  return new Observable((observer) => {
    const scopeFuncIsAsync = isAsyncFunction(querier);
    function execute(subscr) {
      if (scopeFuncIsAsync) {
        incrementExpectedAwaits();
      }
      const exec = () => newScope(querier, { subscr, trans: null });
      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();
      if (scopeFuncIsAsync) {
        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
      }
      return rv;
    }
    let closed = false;
    let accumMuts = {};
    let currentObs = {};
    const subscription = {
      get closed() {
        return closed;
      },
      unsubscribe: () => {
        closed = true;
        globalEvents.storagemutated.unsubscribe(mutationListener);
      }
    };
    observer.start && observer.start(subscription);
    let querying = false, startedListening2 = false;
    function shouldNotify() {
      return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));
    }
    const mutationListener = (parts) => {
      extendObservabilitySet(accumMuts, parts);
      if (shouldNotify()) {
        doQuery();
      }
    };
    const doQuery = () => {
      if (querying || closed) {
        return;
      }
      accumMuts = {};
      const subscr = {};
      const ret = execute(subscr);
      if (!startedListening2) {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
        startedListening2 = true;
      }
      querying = true;
      Promise.resolve(ret).then((result) => {
        querying = false;
        if (closed) {
          return;
        }
        if (shouldNotify()) {
          doQuery();
        } else {
          accumMuts = {};
          currentObs = subscr;
          observer.next && observer.next(result);
        }
      }, (err) => {
        if (!["DatabaseClosedError", "AbortError"].includes(err === null || err === void 0 ? void 0 : err.name)) {
          querying = false;
          observer.error && observer.error(err);
          subscription.unsubscribe();
        }
      });
    };
    doQuery();
    return subscription;
  });
}
let domDeps;
try {
  domDeps = {
    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
  };
} catch (e) {
  domDeps = { indexedDB: null, IDBKeyRange: null };
}
const Dexie = Dexie$1;
props(Dexie, {
  ...fullNameExceptions,
  delete(databaseName) {
    const db2 = new Dexie(databaseName, { addons: [] });
    return db2.delete();
  },
  exists(name) {
    return new Dexie(name, { addons: [] }).open().then((db2) => {
      db2.close();
      return true;
    }).catch("NoSuchDatabaseError", () => false);
  },
  getDatabaseNames(cb) {
    try {
      return getDatabaseNames(Dexie.dependencies).then(cb);
    } catch (_a) {
      return rejection(new exceptions.MissingAPI());
    }
  },
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return Class;
  },
  ignoreTransaction(scopeFunc) {
    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
  },
  vip,
  async: function(generatorFn) {
    return function() {
      try {
        var rv = awaitIterator(generatorFn.apply(this, arguments));
        if (!rv || typeof rv.then !== "function")
          return DexiePromise.resolve(rv);
        return rv;
      } catch (e) {
        return rejection(e);
      }
    };
  },
  spawn: function(generatorFn, args2, thiz) {
    try {
      var rv = awaitIterator(generatorFn.apply(thiz, args2 || []));
      if (!rv || typeof rv.then !== "function")
        return DexiePromise.resolve(rv);
      return rv;
    } catch (e) {
      return rejection(e);
    }
  },
  currentTransaction: {
    get: () => PSD.trans || null
  },
  waitFor: function(promiseOrFunction, optionalTimeout) {
    const promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
    return PSD.trans ? PSD.trans.waitFor(promise) : promise;
  },
  Promise: DexiePromise,
  debug: {
    get: () => debug$1,
    set: (value) => {
      setDebug(value, value === "dexie" ? () => true : dexieStackFrameFilter);
    }
  },
  derive,
  extend,
  props,
  override,
  Events,
  on: globalEvents,
  liveQuery,
  extendObservabilitySet,
  getByKeyPath,
  setByKeyPath,
  delByKeyPath,
  shallowClone,
  deepClone,
  getObjectDiff,
  cmp: cmp$2,
  asap: asap$1,
  minKey,
  addons: [],
  connections,
  errnames,
  dependencies: domDeps,
  semVer: DEXIE_VERSION,
  version: DEXIE_VERSION.split(".").map((n) => parseInt(n)).reduce((p, c, i) => p + c / Math.pow(10, i * 2))
});
Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);
if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts) => {
    if (!propagatingLocally) {
      let event;
      if (isIEOrEdge) {
        event = document.createEvent("CustomEvent");
        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
      } else {
        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
          detail: updatedParts
        });
      }
      propagatingLocally = true;
      dispatchEvent(event);
      propagatingLocally = false;
    }
  });
  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {
    if (!propagatingLocally) {
      propagateLocally(detail);
    }
  });
}
function propagateLocally(updateParts) {
  let wasMe = propagatingLocally;
  try {
    propagatingLocally = true;
    globalEvents.storagemutated.fire(updateParts);
  } finally {
    propagatingLocally = wasMe;
  }
}
let propagatingLocally = false;
if (typeof BroadcastChannel !== "undefined") {
  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
  if (typeof bc.unref === "function") {
    bc.unref();
  }
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    if (!propagatingLocally) {
      bc.postMessage(changedParts);
    }
  });
  bc.onmessage = (ev) => {
    if (ev.data)
      propagateLocally(ev.data);
  };
} else if (typeof self !== "undefined" && typeof navigator !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    try {
      if (!propagatingLocally) {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
            trig: Math.random(),
            changedParts
          }));
        }
        if (typeof self["clients"] === "object") {
          [...self["clients"].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({
            type: STORAGE_MUTATED_DOM_EVENT_NAME,
            changedParts
          }));
        }
      }
    } catch (_a) {
    }
  });
  if (typeof addEventListener !== "undefined") {
    addEventListener("storage", (ev) => {
      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
        const data = JSON.parse(ev.newValue);
        if (data)
          propagateLocally(data.changedParts);
      }
    });
  }
  const swContainer = self.document && navigator.serviceWorker;
  if (swContainer) {
    swContainer.addEventListener("message", propagateMessageLocally);
  }
}
function propagateMessageLocally({ data }) {
  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
    propagateLocally(data.changedParts);
  }
}
DexiePromise.rejectionMapper = mapError;
setDebug(debug$1, dexieStackFrameFilter);
const dexie = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Dexie: Dexie$1,
  Entity,
  RangeSet,
  cmp: cmp$2,
  default: Dexie$1,
  liveQuery,
  mergeRanges,
  rangesOverlap
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(dexie);
var rxStorageStatics = {};
var queryPlanner = {};
Object.defineProperty(queryPlanner, "__esModule", {
  value: true
});
queryPlanner.UPPER_BOUND_LOGICAL_OPERATORS = queryPlanner.LOWER_BOUND_LOGICAL_OPERATORS = queryPlanner.LOGICAL_OPERATORS = queryPlanner.INDEX_MIN = queryPlanner.INDEX_MAX = void 0;
queryPlanner.getMatcherQueryOpts = getMatcherQueryOpts;
queryPlanner.getQueryPlan = getQueryPlan;
queryPlanner.isSelectorSatisfiedByIndex = isSelectorSatisfiedByIndex;
queryPlanner.rateQueryPlan = rateQueryPlan;
var _utils$p = utils;
var _rxSchemaHelper$d = rxSchemaHelper;
var INDEX_MAX = String.fromCharCode(65535);
queryPlanner.INDEX_MAX = INDEX_MAX;
var INDEX_MIN = Number.MIN_VALUE;
queryPlanner.INDEX_MIN = INDEX_MIN;
function getQueryPlan(schema, query2) {
  var primaryPath = (0, _rxSchemaHelper$d.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);
  var selector = query2.selector;
  var indexes = schema.indexes ? schema.indexes.slice(0) : [];
  if (query2.index) {
    indexes = [query2.index];
  } else {
    indexes.push([primaryPath]);
  }
  var optimalSortIndex = query2.sort.map((sortField) => Object.keys(sortField)[0]);
  var optimalSortIndexCompareString = optimalSortIndex.join(",");
  var hasDescSorting = !!query2.sort.find((sortField) => Object.values(sortField)[0] === "desc");
  var currentBestQuality = -1;
  var currentBestQueryPlan;
  indexes.forEach((index) => {
    var inclusiveEnd = true;
    var inclusiveStart = true;
    var opts = index.map((indexField) => {
      var matcher = selector[indexField];
      var operators2 = matcher ? Object.keys(matcher) : [];
      var matcherOpts = {};
      if (!matcher || !operators2.length) {
        var startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;
        matcherOpts = {
          startKey,
          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,
          inclusiveStart: true,
          inclusiveEnd: true
        };
      } else {
        operators2.forEach((operator) => {
          if (LOGICAL_OPERATORS.has(operator)) {
            var operatorValue = matcher[operator];
            var partialOpts = getMatcherQueryOpts(operator, operatorValue);
            matcherOpts = Object.assign(matcherOpts, partialOpts);
          }
        });
      }
      if (typeof matcherOpts.startKey === "undefined") {
        matcherOpts.startKey = INDEX_MIN;
      }
      if (typeof matcherOpts.endKey === "undefined") {
        matcherOpts.endKey = INDEX_MAX;
      }
      if (typeof matcherOpts.inclusiveStart === "undefined") {
        matcherOpts.inclusiveStart = true;
      }
      if (typeof matcherOpts.inclusiveEnd === "undefined") {
        matcherOpts.inclusiveEnd = true;
      }
      if (inclusiveStart && !matcherOpts.inclusiveStart) {
        inclusiveStart = false;
      }
      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {
        inclusiveEnd = false;
      }
      return matcherOpts;
    });
    var queryPlan = {
      index,
      startKeys: opts.map((opt) => opt.startKey),
      endKeys: opts.map((opt) => opt.endKey),
      inclusiveEnd,
      inclusiveStart,
      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index.join(","),
      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query2.selector)
    };
    var quality = rateQueryPlan(schema, query2, queryPlan);
    if (quality > 0 && quality > currentBestQuality || query2.index) {
      currentBestQuality = quality;
      currentBestQueryPlan = queryPlan;
    }
  });
  if (!currentBestQueryPlan) {
    currentBestQueryPlan = {
      index: [primaryPath],
      startKeys: [INDEX_MIN],
      endKeys: [INDEX_MAX],
      inclusiveEnd: true,
      inclusiveStart: true,
      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath,
      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex([primaryPath], query2.selector)
    };
  }
  return currentBestQueryPlan;
}
var LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte", "$lt", "$lte"]);
queryPlanner.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
var LOWER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte"]);
queryPlanner.LOWER_BOUND_LOGICAL_OPERATORS = LOWER_BOUND_LOGICAL_OPERATORS;
var UPPER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$lt", "$lte"]);
queryPlanner.UPPER_BOUND_LOGICAL_OPERATORS = UPPER_BOUND_LOGICAL_OPERATORS;
function isSelectorSatisfiedByIndex(index, selector) {
  var selectorEntries = Object.entries(selector);
  var hasNonMatchingOperator = selectorEntries.find(([fieldName, operation]) => {
    if (!index.includes(fieldName)) {
      return true;
    }
    var hasNonLogicOperator = Object.entries(operation).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));
    return hasNonLogicOperator;
  });
  if (hasNonMatchingOperator) {
    return false;
  }
  var prevLowerBoundaryField;
  var hasMoreThenOneLowerBoundaryField = index.find((fieldName) => {
    var operation = selector[fieldName];
    if (!operation) {
      return false;
    }
    var hasLowerLogicOp = Object.keys(operation).find((key) => LOWER_BOUND_LOGICAL_OPERATORS.has(key));
    if (prevLowerBoundaryField && hasLowerLogicOp) {
      return true;
    } else if (hasLowerLogicOp !== "$eq") {
      prevLowerBoundaryField = hasLowerLogicOp;
    }
    return false;
  });
  if (hasMoreThenOneLowerBoundaryField) {
    return false;
  }
  var prevUpperBoundaryField;
  var hasMoreThenOneUpperBoundaryField = index.find((fieldName) => {
    var operation = selector[fieldName];
    if (!operation) {
      return false;
    }
    var hasUpperLogicOp = Object.keys(operation).find((key) => UPPER_BOUND_LOGICAL_OPERATORS.has(key));
    if (prevUpperBoundaryField && hasUpperLogicOp) {
      return true;
    } else if (hasUpperLogicOp !== "$eq") {
      prevUpperBoundaryField = hasUpperLogicOp;
    }
    return false;
  });
  if (hasMoreThenOneUpperBoundaryField) {
    return false;
  }
  return true;
}
function getMatcherQueryOpts(operator, operatorValue) {
  switch (operator) {
    case "$eq":
      return {
        startKey: operatorValue,
        endKey: operatorValue
      };
    case "$lte":
      return {
        endKey: operatorValue
      };
    case "$gte":
      return {
        startKey: operatorValue
      };
    case "$lt":
      return {
        endKey: operatorValue,
        inclusiveEnd: false
      };
    case "$gt":
      return {
        startKey: operatorValue,
        inclusiveStart: false
      };
    default:
      throw new Error("SNH");
  }
}
function rateQueryPlan(schema, query2, queryPlan) {
  var quality = 0;
  var addQuality = (value) => {
    if (value > 0) {
      quality = quality + value;
    }
  };
  var pointsPerMatchingKey = 10;
  var nonMinKeyCount = (0, _utils$p.countUntilNotMatching)(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);
  addQuality(nonMinKeyCount * pointsPerMatchingKey);
  var nonMaxKeyCount = (0, _utils$p.countUntilNotMatching)(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);
  addQuality(nonMaxKeyCount * pointsPerMatchingKey);
  var equalKeyCount = (0, _utils$p.countUntilNotMatching)(queryPlan.startKeys, (keyValue, idx) => {
    if (keyValue === queryPlan.endKeys[idx]) {
      return true;
    } else {
      return false;
    }
  });
  addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);
  var pointsIfNoReSortMustBeDone = queryPlan.sortFieldsSameAsIndexFields ? 5 : 0;
  addQuality(pointsIfNoReSortMustBeDone);
  return quality;
}
Object.defineProperty(rxStorageStatics, "__esModule", {
  value: true
});
rxStorageStatics.RxStorageDefaultStatics = void 0;
var _rxError$j = rxError;
var _queryPlanner$3 = queryPlanner;
var _rxSchemaHelper$c = rxSchemaHelper;
var RxStorageDefaultStatics = {
  prepareQuery(schema, mutateableQuery) {
    if (!mutateableQuery.sort) {
      throw (0, _rxError$j.newRxError)("SNH", {
        query: mutateableQuery
      });
    }
    var queryPlan = (0, _queryPlanner$3.getQueryPlan)(schema, mutateableQuery);
    return {
      query: mutateableQuery,
      queryPlan
    };
  },
  checkpointSchema: _rxSchemaHelper$c.DEFAULT_CHECKPOINT_SCHEMA
};
rxStorageStatics.RxStorageDefaultStatics = RxStorageDefaultStatics;
Object.defineProperty(dexieHelper, "__esModule", {
  value: true
});
dexieHelper.RxStorageDexieStatics = dexieHelper.RX_STORAGE_NAME_DEXIE = dexieHelper.DEXIE_PIPE_SUBSTITUTE = dexieHelper.DEXIE_DOCS_TABLE_NAME = dexieHelper.DEXIE_DELETED_DOCS_TABLE_NAME = dexieHelper.DEXIE_CHANGES_TABLE_NAME = void 0;
dexieHelper.closeDexieDb = closeDexieDb;
dexieHelper.dexieReplaceIfStartsWithPipe = dexieReplaceIfStartsWithPipe;
dexieHelper.dexieReplaceIfStartsWithPipeRevert = dexieReplaceIfStartsWithPipeRevert;
dexieHelper.ensureNoBooleanIndex = ensureNoBooleanIndex;
dexieHelper.fromDexieToStorage = fromDexieToStorage;
dexieHelper.fromStorageToDexie = fromStorageToDexie;
dexieHelper.getDexieDbWithTables = getDexieDbWithTables;
dexieHelper.getDexieStoreSchema = getDexieStoreSchema;
dexieHelper.getDocsInDb = getDocsInDb;
var _dexie = require$$0$2;
var _utils$o = utils;
var _rxError$i = rxError;
var _rxSchemaHelper$b = rxSchemaHelper;
var _rxStorageStatics = rxStorageStatics;
var DEXIE_DOCS_TABLE_NAME = "docs";
dexieHelper.DEXIE_DOCS_TABLE_NAME = DEXIE_DOCS_TABLE_NAME;
var DEXIE_DELETED_DOCS_TABLE_NAME = "deleted-docs";
dexieHelper.DEXIE_DELETED_DOCS_TABLE_NAME = DEXIE_DELETED_DOCS_TABLE_NAME;
var DEXIE_CHANGES_TABLE_NAME = "changes";
dexieHelper.DEXIE_CHANGES_TABLE_NAME = DEXIE_CHANGES_TABLE_NAME;
var RX_STORAGE_NAME_DEXIE = "dexie";
dexieHelper.RX_STORAGE_NAME_DEXIE = RX_STORAGE_NAME_DEXIE;
var RxStorageDexieStatics = _rxStorageStatics.RxStorageDefaultStatics;
dexieHelper.RxStorageDexieStatics = RxStorageDexieStatics;
var DEXIE_STATE_DB_BY_NAME = /* @__PURE__ */ new Map();
var REF_COUNT_PER_DEXIE_DB = /* @__PURE__ */ new Map();
function getDexieDbWithTables(databaseName, collectionName, settings, schema) {
  var primaryPath = (0, _rxSchemaHelper$b.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);
  var dexieDbName = "rxdb-dexie-" + databaseName + "--" + schema.version + "--" + collectionName;
  var state = (0, _utils$o.getFromMapOrCreate)(DEXIE_STATE_DB_BY_NAME, dexieDbName, () => {
    var value = (async () => {
      var useSettings = (0, _utils$o.flatClone)(settings);
      useSettings.autoOpen = false;
      var dexieDb = new _dexie.Dexie(dexieDbName, useSettings);
      var dexieStoresSettings = {
        [DEXIE_DOCS_TABLE_NAME]: getDexieStoreSchema(schema),
        [DEXIE_CHANGES_TABLE_NAME]: "++sequence, id",
        /**
         * Instead of adding {deleted: false} to every query we run over the document store,
         * we move deleted documents into a separate store where they can only be queried
         * by primary key.
         * This increases performance because it is way easier for the query planner to select
         * a good index and we also do not have to add the _deleted field to every index.
         *
         * We also need the [_meta.lwt+' + primaryPath + '] index for getChangedDocumentsSince()
         */
        [DEXIE_DELETED_DOCS_TABLE_NAME]: primaryPath + ",_meta.lwt,[_meta.lwt+" + primaryPath + "]"
      };
      dexieDb.version(1).stores(dexieStoresSettings);
      await dexieDb.open();
      return {
        dexieDb,
        dexieTable: dexieDb[DEXIE_DOCS_TABLE_NAME],
        dexieDeletedTable: dexieDb[DEXIE_DELETED_DOCS_TABLE_NAME]
      };
    })();
    DEXIE_STATE_DB_BY_NAME.set(dexieDbName, state);
    REF_COUNT_PER_DEXIE_DB.set(state, 0);
    return value;
  });
  return state;
}
async function closeDexieDb(statePromise) {
  var state = await statePromise;
  var prevCount = REF_COUNT_PER_DEXIE_DB.get(statePromise);
  var newCount = prevCount - 1;
  if (newCount === 0) {
    state.dexieDb.close();
    REF_COUNT_PER_DEXIE_DB.delete(statePromise);
  } else {
    REF_COUNT_PER_DEXIE_DB.set(statePromise, newCount);
  }
}
function ensureNoBooleanIndex(schema) {
  if (!schema.indexes) {
    return;
  }
  var checkedFields = /* @__PURE__ */ new Set();
  schema.indexes.forEach((index) => {
    var fields = (0, _utils$o.toArray)(index);
    fields.forEach((field) => {
      if (checkedFields.has(field)) {
        return;
      }
      checkedFields.add(field);
      var schemaObj = (0, _rxSchemaHelper$b.getSchemaByObjectPath)(schema, field);
      if (schemaObj.type === "boolean") {
        throw (0, _rxError$i.newRxError)("DXE1", {
          schema,
          index,
          field
        });
      }
    });
  });
}
var DEXIE_PIPE_SUBSTITUTE = "__";
dexieHelper.DEXIE_PIPE_SUBSTITUTE = DEXIE_PIPE_SUBSTITUTE;
function dexieReplaceIfStartsWithPipe(str) {
  var split2 = str.split(".");
  if (split2.length > 1) {
    return split2.map((part) => dexieReplaceIfStartsWithPipe(part)).join(".");
  }
  if (str.startsWith("|")) {
    var withoutFirst = str.substring(1);
    return DEXIE_PIPE_SUBSTITUTE + withoutFirst;
  } else {
    return str;
  }
}
function dexieReplaceIfStartsWithPipeRevert(str) {
  var split2 = str.split(".");
  if (split2.length > 1) {
    return split2.map((part) => dexieReplaceIfStartsWithPipeRevert(part)).join(".");
  }
  if (str.startsWith(DEXIE_PIPE_SUBSTITUTE)) {
    var withoutFirst = str.substring(DEXIE_PIPE_SUBSTITUTE.length);
    return "|" + withoutFirst;
  } else {
    return str;
  }
}
function fromStorageToDexie(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromStorageToDexie(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object") {
        value = fromStorageToDexie(value);
      }
      ret[dexieReplaceIfStartsWithPipe(key)] = value;
    });
    return ret;
  }
}
function fromDexieToStorage(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromDexieToStorage(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object" || Array.isArray(documentData)) {
        value = fromDexieToStorage(value);
      }
      ret[dexieReplaceIfStartsWithPipeRevert(key)] = value;
    });
    return ret;
  }
}
function getDexieStoreSchema(rxJsonSchema) {
  var parts = [];
  var primaryKey = (0, _rxSchemaHelper$b.getPrimaryFieldOfPrimaryKey)(rxJsonSchema.primaryKey);
  parts.push([primaryKey]);
  if (rxJsonSchema.indexes) {
    rxJsonSchema.indexes.forEach((index) => {
      var arIndex = (0, _utils$o.toArray)(index);
      parts.push(arIndex);
    });
  }
  parts.push(["_meta.lwt", primaryKey]);
  parts = parts.map((part) => {
    return part.map((str) => dexieReplaceIfStartsWithPipe(str));
  });
  return parts.map((part) => {
    if (part.length === 1) {
      return part[0];
    } else {
      return "[" + part.join("+") + "]";
    }
  }).join(", ");
}
async function getDocsInDb(internals, docIds) {
  var state = await internals;
  var [nonDeletedDocsInDb, deletedDocsInDb] = await Promise.all([state.dexieTable.bulkGet(docIds), state.dexieDeletedTable.bulkGet(docIds)]);
  var docsInDb = deletedDocsInDb.slice(0);
  nonDeletedDocsInDb.forEach((doc, idx) => {
    if (doc) {
      docsInDb[idx] = doc;
    }
  });
  return docsInDb;
}
var rxStorageInstanceDexie = {};
var dexieQuery$1 = {};
var rxQueryHelper = {};
var util$5 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.isOperator = exports.removeValue = exports.setValue = exports.walk = exports.filterMissing = exports.resolveGraph = exports.resolve = exports.memoize = exports.into = exports.groupBy = exports.sortBy = exports.hashCode = exports.stringify = exports.unique = exports.isEqual = exports.flatten = exports.intersection = exports.merge = exports.has = exports.ensureArray = exports.isMissing = exports.isEmpty = exports.truthy = exports.notInArray = exports.inArray = exports.isNil = exports.isFunction = exports.isRegExp = exports.isDate = exports.isObjectLike = exports.isObject = exports.isArray = exports.isNotNaN = exports.isNumber = exports.isString = exports.isBoolean = exports.getType = exports.cloneDeep = exports.assert = exports.compare = exports.MIN_LONG = exports.MAX_LONG = exports.MIN_INT = exports.MAX_INT = void 0;
  exports.MAX_INT = 2147483647;
  exports.MIN_INT = -2147483648;
  exports.MAX_LONG = Number.MAX_SAFE_INTEGER;
  exports.MIN_LONG = Number.MIN_SAFE_INTEGER;
  const MISSING = Symbol("missing");
  const OBJECT_PROTOTYPE = Object.getPrototypeOf({});
  const OBJECT_TAG = "[object Object]";
  const OBJECT_TYPE_RE = /^\[object ([a-zA-Z0-9]+)\]$/;
  const DEFAULT_HASH_FUNCTION = (value) => {
    const s = stringify2(value);
    let hash2 = 0;
    let i = s.length;
    while (i)
      hash2 = (hash2 << 5) - hash2 ^ s.charCodeAt(--i);
    return hash2 >>> 0;
  };
  const JS_SIMPLE_TYPES = /* @__PURE__ */ new Set([
    "null",
    "undefined",
    "boolean",
    "number",
    "string",
    "date",
    "regexp"
  ]);
  const SORT_ORDER_BY_TYPE = {
    null: 0,
    undefined: 0,
    number: 1,
    string: 2,
    object: 3,
    array: 4,
    boolean: 5,
    date: 6,
    regexp: 7,
    function: 8
  };
  const compare2 = (a, b) => {
    if (a === MISSING)
      a = void 0;
    if (b === MISSING)
      b = void 0;
    const [u, v] = [a, b].map((n) => SORT_ORDER_BY_TYPE[(0, exports.getType)(n).toLowerCase()]);
    if (u !== v)
      return u - v;
    if (u === 1 || u === 2 || u === 6) {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
    if (isEqual2(a, b))
      return 0;
    if (a < b)
      return -1;
    if (a > b)
      return 1;
    return 0;
  };
  exports.compare = compare2;
  function assert2(condition, message) {
    if (!condition)
      throw new Error(message);
  }
  exports.assert = assert2;
  const cloneDeep = (obj) => {
    const m = /* @__PURE__ */ new Map();
    const add2 = (v) => {
      if (m.has(v))
        throw new Error("cycle detected during clone operation.");
      m.set(v, true);
    };
    const clone2 = (val) => {
      if (val instanceof Date)
        return new Date(val);
      if ((0, exports.isArray)(val)) {
        add2(val);
        const res = new Array(val.length);
        const len = val.length;
        for (let i = 0; i < len; i++)
          res[i] = clone2(val[i]);
        return res;
      }
      if ((0, exports.isObject)(val)) {
        add2(val);
        const res = {};
        for (const k in val)
          res[k] = clone2(val[k]);
        return res;
      }
      return val;
    };
    return clone2(obj);
  };
  exports.cloneDeep = cloneDeep;
  const getType2 = (v) => OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v))[1];
  exports.getType = getType2;
  const isBoolean = (v) => typeof v === "boolean";
  exports.isBoolean = isBoolean;
  const isString = (v) => typeof v === "string";
  exports.isString = isString;
  const isNumber2 = (v) => !isNaN(v) && typeof v === "number";
  exports.isNumber = isNumber2;
  const isNotNaN = (v) => !(isNaN(v) && typeof v === "number");
  exports.isNotNaN = isNotNaN;
  exports.isArray = Array.isArray;
  const isObject2 = (v) => {
    if (!v)
      return false;
    const proto = Object.getPrototypeOf(v);
    return (proto === OBJECT_PROTOTYPE || proto === null) && OBJECT_TAG === Object.prototype.toString.call(v);
  };
  exports.isObject = isObject2;
  const isObjectLike = (v) => v === Object(v);
  exports.isObjectLike = isObjectLike;
  const isDate2 = (v) => v instanceof Date;
  exports.isDate = isDate2;
  const isRegExp = (v) => v instanceof RegExp;
  exports.isRegExp = isRegExp;
  const isFunction2 = (v) => typeof v === "function";
  exports.isFunction = isFunction2;
  const isNil = (v) => v === null || v === void 0;
  exports.isNil = isNil;
  const inArray = (arr2, item) => arr2.includes(item);
  exports.inArray = inArray;
  const notInArray = (arr2, item) => !(0, exports.inArray)(arr2, item);
  exports.notInArray = notInArray;
  const truthy = (arg, strict = true) => !!arg || strict && arg === "";
  exports.truthy = truthy;
  const isEmpty2 = (x) => (0, exports.isNil)(x) || (0, exports.isString)(x) && !x || x instanceof Array && x.length === 0 || (0, exports.isObject)(x) && Object.keys(x).length === 0;
  exports.isEmpty = isEmpty2;
  const isMissing = (v) => v === MISSING;
  exports.isMissing = isMissing;
  const ensureArray = (x) => x instanceof Array ? x : [x];
  exports.ensureArray = ensureArray;
  const has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);
  exports.has = has;
  const mergeable = (left, right) => (0, exports.isObject)(left) && (0, exports.isObject)(right) || (0, exports.isArray)(left) && (0, exports.isArray)(right);
  function merge2(target, obj, options2) {
    options2 = options2 || { flatten: false };
    if ((0, exports.isMissing)(target) || (0, exports.isNil)(target))
      return obj;
    if ((0, exports.isMissing)(obj) || (0, exports.isNil)(obj))
      return target;
    if (!mergeable(target, obj)) {
      if (options2.skipValidation)
        return obj || target;
      throw Error("mismatched types. must both be array or object");
    }
    options2.skipValidation = true;
    if ((0, exports.isArray)(target)) {
      const result = target;
      const input = obj;
      if (options2.flatten) {
        let i = 0;
        let j = 0;
        while (i < result.length && j < input.length) {
          result[i] = merge2(result[i++], input[j++], options2);
        }
        while (j < input.length) {
          result.push(obj[j++]);
        }
      } else {
        into(result, input);
      }
    } else {
      for (const k in obj) {
        target[k] = merge2(target[k], obj[k], options2);
      }
    }
    return target;
  }
  exports.merge = merge2;
  function buildHashIndex(arr2, hashFunction = DEFAULT_HASH_FUNCTION) {
    const map2 = /* @__PURE__ */ new Map();
    arr2.forEach((o, i) => {
      const h = hashCode(o, hashFunction);
      if (map2.has(h)) {
        if (!map2.get(h).some((j) => isEqual2(arr2[j], o))) {
          map2.get(h).push(i);
        }
      } else {
        map2.set(h, [i]);
      }
    });
    return map2;
  }
  function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {
    if (input.some((arr2) => arr2.length == 0))
      return [];
    if (input.length === 1)
      return Array.from(input);
    const sortedIndex = sortBy(input.map((a, i) => [i, a.length]), (a) => a[1]);
    const smallest = input[sortedIndex[0][0]];
    const map2 = buildHashIndex(smallest, hashFunction);
    const rmap = /* @__PURE__ */ new Map();
    const results = new Array();
    map2.forEach((v, k) => {
      const lhs = v.map((j) => smallest[j]);
      const res = lhs.map((_) => 0);
      const stable = lhs.map((_) => [sortedIndex[0][0], 0]);
      let found = false;
      for (let i = 1; i < input.length; i++) {
        const [currIndex, _] = sortedIndex[i];
        const arr2 = input[currIndex];
        if (!rmap.has(i))
          rmap.set(i, buildHashIndex(arr2));
        if (rmap.get(i).has(k)) {
          const rhs = rmap.get(i).get(k).map((j) => arr2[j]);
          found = lhs.map((s, n) => rhs.some((t, m) => {
            const p = res[n];
            if (isEqual2(s, t)) {
              res[n]++;
              if (currIndex < stable[n][0]) {
                stable[n] = [currIndex, rmap.get(i).get(k)[m]];
              }
            }
            return p < res[n];
          })).some(Boolean);
        }
        if (!found)
          return;
      }
      if (found) {
        into(results, res.map((n, i) => {
          return n === input.length - 1 ? [lhs[i], stable[i]] : MISSING;
        }).filter((n) => n !== MISSING));
      }
    });
    return results.sort((a, b) => {
      const [_i, [u, m]] = a;
      const [_j, [v, n]] = b;
      const r = (0, exports.compare)(u, v);
      if (r !== 0)
        return r;
      return (0, exports.compare)(m, n);
    }).map((v) => v[0]);
  }
  exports.intersection = intersection;
  function flatten2(xs, depth = 0) {
    const arr2 = new Array();
    function flatten22(ys, n) {
      for (let i = 0, len = ys.length; i < len; i++) {
        if ((0, exports.isArray)(ys[i]) && (n > 0 || n < 0)) {
          flatten22(ys[i], Math.max(-1, n - 1));
        } else {
          arr2.push(ys[i]);
        }
      }
    }
    flatten22(xs, depth);
    return arr2;
  }
  exports.flatten = flatten2;
  function isEqual2(a, b) {
    const lhs = [a];
    const rhs = [b];
    while (lhs.length > 0) {
      a = lhs.pop();
      b = rhs.pop();
      if (a === b)
        continue;
      const nativeType = (0, exports.getType)(a).toLowerCase();
      if (nativeType !== (0, exports.getType)(b).toLowerCase() || nativeType === "function") {
        return false;
      }
      if (nativeType === "array") {
        const xs = a;
        const ys = b;
        if (xs.length !== ys.length)
          return false;
        if (xs.length === ys.length && xs.length === 0)
          continue;
        into(lhs, xs);
        into(rhs, ys);
      } else if (nativeType === "object") {
        const aKeys = Object.keys(a);
        const bKeys = Object.keys(b);
        if (aKeys.length !== bKeys.length)
          return false;
        for (let i = 0, len = aKeys.length; i < len; i++) {
          const k = aKeys[i];
          if (!(0, exports.has)(b, k))
            return false;
          lhs.push(a[k]);
          rhs.push(b[k]);
        }
      } else {
        if (stringify2(a) !== stringify2(b))
          return false;
      }
    }
    return lhs.length === 0;
  }
  exports.isEqual = isEqual2;
  function unique(input, hashFunction = DEFAULT_HASH_FUNCTION) {
    const result = input.map((_) => MISSING);
    buildHashIndex(input, hashFunction).forEach((v, _) => {
      v.forEach((i) => result[i] = input[i]);
    });
    return result.filter((v) => v !== MISSING);
  }
  exports.unique = unique;
  function stringify2(value) {
    const type2 = (0, exports.getType)(value).toLowerCase();
    switch (type2) {
      case "boolean":
      case "number":
      case "regexp":
        return value.toString();
      case "string":
        return JSON.stringify(value);
      case "date":
        return value.toISOString();
      case "null":
      case "undefined":
        return type2;
      case "array":
        return "[" + value.map(stringify2).join(",") + "]";
    }
    const prefix = type2 === "object" ? "" : `${(0, exports.getType)(value)}`;
    const objKeys = Object.keys(value);
    objKeys.sort();
    return `${prefix}{` + objKeys.map((k) => `${stringify2(k)}:${stringify2(value[k])}`).join(",") + "}";
  }
  exports.stringify = stringify2;
  function hashCode(value, hashFunction) {
    hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;
    if ((0, exports.isNil)(value))
      return null;
    return hashFunction(value).toString();
  }
  exports.hashCode = hashCode;
  function sortBy(collection, keyFn, comparator = exports.compare) {
    if ((0, exports.isEmpty)(collection))
      return collection;
    const sorted = new Array();
    const result = new Array();
    for (let i = 0; i < collection.length; i++) {
      const obj = collection[i];
      const key = keyFn(obj, i);
      if ((0, exports.isNil)(key)) {
        result.push(obj);
      } else {
        sorted.push([key, obj]);
      }
    }
    sorted.sort((a, b) => comparator(a[0], b[0]));
    return into(result, sorted.map((o) => o[1]));
  }
  exports.sortBy = sortBy;
  function groupBy2(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {
    if (collection.length < 1)
      return /* @__PURE__ */ new Map();
    const lookup2 = /* @__PURE__ */ new Map();
    const result = /* @__PURE__ */ new Map();
    for (let i = 0; i < collection.length; i++) {
      const obj = collection[i];
      const key = keyFn(obj, i);
      const hash2 = hashCode(key, hashFunction);
      if (hash2 === null) {
        if (result.has(null)) {
          result.get(null).push(obj);
        } else {
          result.set(null, [obj]);
        }
      } else {
        const existingKey = lookup2.has(hash2) ? lookup2.get(hash2).find((k) => isEqual2(k, key)) : null;
        if ((0, exports.isNil)(existingKey)) {
          result.set(key, [obj]);
          if (lookup2.has(hash2)) {
            lookup2.get(hash2).push(key);
          } else {
            lookup2.set(hash2, [key]);
          }
        } else {
          result.get(existingKey).push(obj);
        }
      }
    }
    return result;
  }
  exports.groupBy = groupBy2;
  const MAX_ARRAY_PUSH = 5e4;
  function into(target, ...rest) {
    if (target instanceof Array) {
      return rest.reduce((acc, arr2) => {
        let i = Math.ceil(arr2.length / MAX_ARRAY_PUSH);
        let begin = 0;
        while (i-- > 0) {
          Array.prototype.push.apply(acc, arr2.slice(begin, begin + MAX_ARRAY_PUSH));
          begin += MAX_ARRAY_PUSH;
        }
        return acc;
      }, target);
    } else {
      return rest.filter(exports.isObjectLike).reduce((acc, item) => {
        Object.assign(acc, item);
        return acc;
      }, target);
    }
  }
  exports.into = into;
  function memoize(fn, hashFunction = DEFAULT_HASH_FUNCTION) {
    return ((memo2) => {
      return (...args2) => {
        const key = hashCode(args2, hashFunction) || "";
        if (!(0, exports.has)(memo2, key)) {
          memo2[key] = fn.apply(this, args2);
        }
        return memo2[key];
      };
    })({
      /* storage */
    });
  }
  exports.memoize = memoize;
  function getValue(obj, key) {
    return (0, exports.isObjectLike)(obj) ? obj[key] : void 0;
  }
  function unwrap(arr2, depth) {
    if (depth < 1)
      return arr2;
    while (depth-- && arr2.length === 1)
      arr2 = arr2[0];
    return arr2;
  }
  function resolve(obj, selector, options2) {
    let depth = 0;
    function resolve2(o, path2) {
      let value = o;
      for (let i = 0; i < path2.length; i++) {
        const field = path2[i];
        const isText = /^\d+$/.exec(field) === null;
        if (isText && value instanceof Array) {
          if (i === 0 && depth > 0)
            break;
          depth += 1;
          const subpath = path2.slice(i);
          value = value.reduce((acc, item) => {
            const v = resolve2(item, subpath);
            if (v !== void 0)
              acc.push(v);
            return acc;
          }, []);
          break;
        } else {
          value = getValue(value, field);
        }
        if (value === void 0)
          break;
      }
      return value;
    }
    const result = JS_SIMPLE_TYPES.has((0, exports.getType)(obj).toLowerCase()) ? obj : resolve2(obj, selector.split("."));
    return result instanceof Array && (options2 === null || options2 === void 0 ? void 0 : options2.unwrapArray) ? unwrap(result, depth) : result;
  }
  exports.resolve = resolve;
  function resolveGraph(obj, selector, options2) {
    const names = selector.split(".");
    const key = names[0];
    const next = names.slice(1).join(".");
    const isIndex = /^\d+$/.exec(key) !== null;
    const hasNext = names.length > 1;
    let result;
    let value;
    if (obj instanceof Array) {
      if (isIndex) {
        result = getValue(obj, Number(key));
        if (hasNext) {
          result = resolveGraph(result, next, options2);
        }
        result = [result];
      } else {
        result = [];
        for (const item of obj) {
          value = resolveGraph(item, selector, options2);
          if (options2 === null || options2 === void 0 ? void 0 : options2.preserveMissing) {
            if (value === void 0) {
              value = MISSING;
            }
            result.push(value);
          } else if (value !== void 0) {
            result.push(value);
          }
        }
      }
    } else {
      value = getValue(obj, key);
      if (hasNext) {
        value = resolveGraph(value, next, options2);
      }
      if (value === void 0)
        return void 0;
      result = (options2 === null || options2 === void 0 ? void 0 : options2.preserveKeys) ? Object.assign({}, obj) : {};
      result[key] = value;
    }
    return result;
  }
  exports.resolveGraph = resolveGraph;
  function filterMissing(obj) {
    if (obj instanceof Array) {
      for (let i = obj.length - 1; i >= 0; i--) {
        if (obj[i] === MISSING) {
          obj.splice(i, 1);
        } else {
          filterMissing(obj[i]);
        }
      }
    } else if ((0, exports.isObject)(obj)) {
      for (const k in obj) {
        if ((0, exports.has)(obj, k)) {
          filterMissing(obj[k]);
        }
      }
    }
  }
  exports.filterMissing = filterMissing;
  const NUMBER_RE = /^\d+$/;
  function walk(obj, selector, fn, options2) {
    const names = selector.split(".");
    const key = names[0];
    const next = names.slice(1).join(".");
    if (names.length === 1) {
      if ((0, exports.isObject)(obj) || (0, exports.isArray)(obj) && NUMBER_RE.test(key)) {
        fn(obj, key);
      }
    } else {
      if ((options2 === null || options2 === void 0 ? void 0 : options2.buildGraph) && (0, exports.isNil)(obj[key])) {
        obj[key] = {};
      }
      const item = obj[key];
      if (!item)
        return;
      const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));
      if (item instanceof Array && (options2 === null || options2 === void 0 ? void 0 : options2.descendArray) && !isNextArrayIndex) {
        item.forEach((e) => walk(e, next, fn, options2));
      } else {
        walk(item, next, fn, options2);
      }
    }
  }
  exports.walk = walk;
  function setValue(obj, selector, value) {
    walk(obj, selector, (item, key) => {
      item[key] = value;
    }, { buildGraph: true });
  }
  exports.setValue = setValue;
  function removeValue(obj, selector, options2) {
    walk(obj, selector, (item, key) => {
      if (item instanceof Array) {
        if (/^\d+$/.test(key)) {
          item.splice(parseInt(key), 1);
        } else if (options2 && options2.descendArray) {
          for (const elem of item) {
            if ((0, exports.isObject)(elem)) {
              delete elem[key];
            }
          }
        }
      } else if ((0, exports.isObject)(item)) {
        delete item[key];
      }
    }, options2);
  }
  exports.removeValue = removeValue;
  const OPERATOR_NAME_PATTERN = /^\$[a-zA-Z0-9_]+$/;
  function isOperator(name) {
    return OPERATOR_NAME_PATTERN.test(name);
  }
  exports.isOperator = isOperator;
  function normalize(expr2) {
    if (JS_SIMPLE_TYPES.has((0, exports.getType)(expr2).toLowerCase())) {
      return (0, exports.isRegExp)(expr2) ? { $regex: expr2 } : { $eq: expr2 };
    }
    if ((0, exports.isObjectLike)(expr2)) {
      const exprObj = expr2;
      if (!Object.keys(exprObj).some(isOperator)) {
        return { $eq: expr2 };
      }
      if ((0, exports.has)(expr2, "$regex")) {
        const newExpr = Object.assign({}, expr2);
        newExpr["$regex"] = new RegExp(expr2["$regex"], expr2["$options"]);
        delete newExpr["$options"];
        return newExpr;
      }
    }
    return expr2;
  }
  exports.normalize = normalize;
})(util$5);
var rxQueryMingo = {};
var core = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redact = exports.computeValue = exports.getOperator = exports.useOperators = exports.Context = exports.OperatorType = exports.initOptions = exports.ComputeOptions = exports.ProcessingMode = void 0;
  const util_12 = util$5;
  var ProcessingMode;
  (function(ProcessingMode2) {
    ProcessingMode2["CLONE_ALL"] = "CLONE_ALL";
    ProcessingMode2["CLONE_INPUT"] = "CLONE_INPUT";
    ProcessingMode2["CLONE_OUTPUT"] = "CLONE_OUTPUT";
    ProcessingMode2["CLONE_OFF"] = "CLONE_OFF";
  })(ProcessingMode = exports.ProcessingMode || (exports.ProcessingMode = {}));
  class ComputeOptions {
    constructor(_opts, _root, _local, timestamp2 = Date.now()) {
      this._opts = _opts;
      this._root = _root;
      this._local = _local;
      this.timestamp = timestamp2;
      this.update(_root, _local);
    }
    /**
     * Initialize new ComputeOptions.
     *
     * @param options
     * @param root
     * @param local
     * @returns {ComputeOptions}
     */
    static init(options2, root, local) {
      return options2 instanceof ComputeOptions ? new ComputeOptions(options2._opts, (0, util_12.isNil)(options2.root) ? root : options2.root, Object.assign({}, options2.local, local)) : new ComputeOptions(options2, root, local);
    }
    /** Updates the internal mutable state. */
    update(root, local) {
      var _a;
      this._root = root;
      this._local = local ? Object.assign({}, local, {
        variables: Object.assign({}, (_a = this._local) === null || _a === void 0 ? void 0 : _a.variables, local === null || local === void 0 ? void 0 : local.variables)
      }) : local;
      return this;
    }
    getOptions() {
      return Object.freeze(Object.assign(Object.assign({}, this._opts), { context: Context.from(this._opts.context) }));
    }
    get root() {
      return this._root;
    }
    get local() {
      return this._local;
    }
    get idKey() {
      return this._opts.idKey;
    }
    get collation() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collation;
    }
    get processingMode() {
      var _a;
      return ((_a = this._opts) === null || _a === void 0 ? void 0 : _a.processingMode) || ProcessingMode.CLONE_OFF;
    }
    get useStrictMode() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useStrictMode;
    }
    get scriptEnabled() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.scriptEnabled;
    }
    get useGlobalContext() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useGlobalContext;
    }
    get hashFunction() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.hashFunction;
    }
    get collectionResolver() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collectionResolver;
    }
    get jsonSchemaValidator() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.jsonSchemaValidator;
    }
    get variables() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.variables;
    }
    get context() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.context;
    }
  }
  exports.ComputeOptions = ComputeOptions;
  function initOptions(options2) {
    return options2 instanceof ComputeOptions ? options2.getOptions() : Object.freeze(Object.assign(Object.assign({ idKey: "_id", scriptEnabled: true, useStrictMode: true, useGlobalContext: true, processingMode: ProcessingMode.CLONE_OFF }, options2), { context: (options2 === null || options2 === void 0 ? void 0 : options2.context) ? Context.from(options2 === null || options2 === void 0 ? void 0 : options2.context) : Context.init({}) }));
  }
  exports.initOptions = initOptions;
  var OperatorType;
  (function(OperatorType2) {
    OperatorType2["ACCUMULATOR"] = "accumulator";
    OperatorType2["EXPRESSION"] = "expression";
    OperatorType2["PIPELINE"] = "pipeline";
    OperatorType2["PROJECTION"] = "projection";
    OperatorType2["QUERY"] = "query";
    OperatorType2["WINDOW"] = "window";
  })(OperatorType = exports.OperatorType || (exports.OperatorType = {}));
  class Context {
    constructor(ops) {
      this.operators = (0, util_12.cloneDeep)(ops);
    }
    static init(ops) {
      return new Context((0, util_12.merge)({
        [OperatorType.ACCUMULATOR]: {},
        [OperatorType.EXPRESSION]: {},
        [OperatorType.PIPELINE]: {},
        [OperatorType.PROJECTION]: {},
        [OperatorType.QUERY]: {},
        [OperatorType.WINDOW]: {}
      }, ops, { skipValidation: true }));
    }
    static from(ctx) {
      return new Context(ctx.operators);
    }
    addOperators(type2, ops) {
      for (const [name, fn] of Object.entries(ops)) {
        if (!this.getOperator(type2, name)) {
          this.operators[type2][name] = fn;
        }
      }
      return this;
    }
    // register
    addAccumulatorOps(ops) {
      return this.addOperators(OperatorType.ACCUMULATOR, ops);
    }
    addExpressionOps(ops) {
      return this.addOperators(OperatorType.EXPRESSION, ops);
    }
    addQueryOps(ops) {
      return this.addOperators(OperatorType.QUERY, ops);
    }
    addPipelineOps(ops) {
      return this.addOperators(OperatorType.PIPELINE, ops);
    }
    addProjectionOps(ops) {
      return this.addOperators(OperatorType.PROJECTION, ops);
    }
    addWindowOps(ops) {
      return this.addOperators(OperatorType.WINDOW, ops);
    }
    // getters
    getOperator(type2, name) {
      return type2 in this.operators ? this.operators[type2][name] || null : null;
    }
  }
  exports.Context = Context;
  const CONTEXT = Context.init({});
  function useOperators(type2, operators2) {
    for (const [name, fn] of Object.entries(operators2)) {
      (0, util_12.assert)((0, util_12.isFunction)(fn) && (0, util_12.isOperator)(name), `'${name}' is not a valid operator`);
      const currentFn = getOperator(type2, name, null);
      (0, util_12.assert)(!currentFn || fn === currentFn, `${name} already exists for '${type2}' operators. Cannot change operator function once registered.`);
    }
    CONTEXT.addOperators(type2, operators2);
  }
  exports.useOperators = useOperators;
  function getOperator(type2, operator, options2) {
    const { context: ctx, useGlobalContext: fallback2 } = options2 || {};
    const fn = ctx ? ctx.getOperator(type2, operator) : null;
    return !fn && fallback2 ? CONTEXT.getOperator(type2, operator) : fn;
  }
  exports.getOperator = getOperator;
  const systemVariables = {
    $$ROOT(obj, expr2, options2) {
      return options2.root;
    },
    $$CURRENT(obj, expr2, options2) {
      return obj;
    },
    $$REMOVE(obj, expr2, options2) {
      return void 0;
    },
    $$NOW(obj, expr2, options2) {
      return new Date(options2.timestamp);
    }
  };
  const redactVariables = {
    $$KEEP(obj, expr2, options2) {
      return obj;
    },
    $$PRUNE(obj, expr2, options2) {
      return void 0;
    },
    $$DESCEND(obj, expr2, options2) {
      if (!(0, util_12.has)(expr2, "$cond"))
        return obj;
      let result;
      for (const [key, current] of Object.entries(obj)) {
        if ((0, util_12.isObjectLike)(current)) {
          if (current instanceof Array) {
            const array2 = [];
            for (let elem of current) {
              if ((0, util_12.isObject)(elem)) {
                elem = redact2(elem, expr2, options2.update(elem));
              }
              if (!(0, util_12.isNil)(elem)) {
                array2.push(elem);
              }
            }
            result = array2;
          } else {
            result = redact2(current, expr2, options2.update(current));
          }
          if ((0, util_12.isNil)(result)) {
            delete obj[key];
          } else {
            obj[key] = result;
          }
        }
      }
      return obj;
    }
  };
  function computeValue(obj, expr2, operator, options2) {
    var _a;
    const copts = ComputeOptions.init(options2, obj);
    operator = operator || "";
    if ((0, util_12.isOperator)(operator)) {
      const callExpression = getOperator(OperatorType.EXPRESSION, operator, options2);
      if (callExpression)
        return callExpression(obj, expr2, copts);
      const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator, options2);
      if (callAccumulator) {
        if (!(obj instanceof Array)) {
          obj = computeValue(obj, expr2, null, copts);
          expr2 = null;
        }
        (0, util_12.assert)(obj instanceof Array, `'${operator}' target must be an array.`);
        return callAccumulator(
          obj,
          expr2,
          // reset the root object for accumulators.
          copts.update(null, copts.local)
        );
      }
      throw new Error(`operator '${operator}' is not registered`);
    }
    if ((0, util_12.isString)(expr2) && expr2.length > 0 && expr2[0] === "$") {
      if ((0, util_12.has)(redactVariables, expr2)) {
        return expr2;
      }
      let context2 = copts.root;
      const arr2 = expr2.split(".");
      if ((0, util_12.has)(systemVariables, arr2[0])) {
        context2 = systemVariables[arr2[0]](obj, null, copts);
        expr2 = expr2.slice(arr2[0].length + 1);
      } else if (arr2[0].slice(0, 2) === "$$") {
        context2 = Object.assign(
          {},
          copts.variables,
          // global vars
          // current item is added before local variables because the binding may be changed.
          { this: obj },
          (_a = copts.local) === null || _a === void 0 ? void 0 : _a.variables
          // local vars
        );
        const prefix = arr2[0].slice(2);
        (0, util_12.assert)((0, util_12.has)(context2, prefix), `Use of undefined variable: ${prefix}`);
        expr2 = expr2.slice(2);
      } else {
        expr2 = expr2.slice(1);
      }
      if (expr2 === "")
        return context2;
      return (0, util_12.resolve)(context2, expr2);
    }
    if ((0, util_12.isArray)(expr2)) {
      return expr2.map((item) => computeValue(obj, item, null, copts));
    } else if ((0, util_12.isObject)(expr2)) {
      const result = {};
      for (const [key, val] of Object.entries(expr2)) {
        result[key] = computeValue(obj, val, key, copts);
        if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some((t) => !!getOperator(t, key, options2))) {
          (0, util_12.assert)(Object.keys(expr2).length === 1, "Invalid aggregation expression '" + JSON.stringify(expr2) + "'");
          return result[key];
        }
      }
      return result;
    }
    return expr2;
  }
  exports.computeValue = computeValue;
  function redact2(obj, expr2, options2) {
    const result = computeValue(obj, expr2, null, options2);
    return (0, util_12.has)(redactVariables, result) ? redactVariables[result](obj, expr2, options2) : result;
  }
  exports.redact = redact2;
})(core);
var query = {};
var cursor = {};
var aggregator = {};
var lazy = {};
Object.defineProperty(lazy, "__esModule", { value: true });
lazy.Iterator = lazy.compose = lazy.Lazy = void 0;
function Lazy(source) {
  return source instanceof Iterator ? source : new Iterator(source);
}
lazy.Lazy = Lazy;
function compose(...iterators) {
  let index = 0;
  return Lazy(() => {
    while (index < iterators.length) {
      const o = iterators[index].next();
      if (!o.done)
        return o;
      index++;
    }
    return { done: true };
  });
}
lazy.compose = compose;
function isGenerator(o) {
  return !!o && typeof o === "object" && (o === null || o === void 0 ? void 0 : o.next) instanceof Function;
}
function dropItem(array2, i) {
  const rest = array2.slice(i + 1);
  array2.splice(i);
  Array.prototype.push.apply(array2, rest);
}
const DONE = new Error();
var Action;
(function(Action2) {
  Action2[Action2["MAP"] = 0] = "MAP";
  Action2[Action2["FILTER"] = 1] = "FILTER";
  Action2[Action2["TAKE"] = 2] = "TAKE";
  Action2[Action2["DROP"] = 3] = "DROP";
})(Action || (Action = {}));
function createCallback(nextFn, iteratees, buffer2) {
  let done = false;
  let index = -1;
  let bufferIndex = 0;
  return function(storeResult) {
    try {
      outer:
        while (!done) {
          let o = nextFn();
          index++;
          let i = -1;
          const size2 = iteratees.length;
          let innerDone = false;
          while (++i < size2) {
            const r = iteratees[i];
            switch (r.action) {
              case Action.MAP:
                o = r.func(o, index);
                break;
              case Action.FILTER:
                if (!r.func(o, index))
                  continue outer;
                break;
              case Action.TAKE:
                --r.count;
                if (!r.count)
                  innerDone = true;
                break;
              case Action.DROP:
                --r.count;
                if (!r.count)
                  dropItem(iteratees, i);
                continue outer;
              default:
                break outer;
            }
          }
          done = innerDone;
          if (storeResult) {
            buffer2[bufferIndex++] = o;
          } else {
            return { value: o, done: false };
          }
        }
    } catch (e) {
      if (e !== DONE)
        throw e;
    }
    done = true;
    return { done };
  };
}
class Iterator {
  /**
   * @param {*} source An iterable object or function.
   *    Array - return one element per cycle
   *    Object{next:Function} - call next() for the next value (this also handles generator functions)
   *    Function - call to return the next value
   * @param {Function} fn An optional transformation function
   */
  constructor(source) {
    this.iteratees = [];
    this.yieldedValues = [];
    this.isDone = false;
    let nextVal;
    if (source instanceof Function) {
      source = { next: source };
    }
    if (isGenerator(source)) {
      const src2 = source;
      nextVal = () => {
        const o = src2.next();
        if (o.done)
          throw DONE;
        return o.value;
      };
    } else if (source instanceof Array) {
      const data = source;
      const size2 = data.length;
      let index = 0;
      nextVal = () => {
        if (index < size2)
          return data[index++];
        throw DONE;
      };
    } else if (!(source instanceof Function)) {
      throw new Error(`Source is of type '${typeof source}'. Must be Array, Function, or Generator`);
    }
    this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);
  }
  /**
   * Add an iteratee to this lazy sequence
   */
  push(action, value) {
    if (typeof value === "function") {
      this.iteratees.push({ action, func: value });
    } else if (typeof value === "number") {
      this.iteratees.push({ action, count: value });
    }
    return this;
  }
  next() {
    return this.getNext();
  }
  // Iteratees methods
  /**
   * Transform each item in the sequence to a new value
   * @param {Function} f
   */
  map(f) {
    return this.push(Action.MAP, f);
  }
  /**
   * Select only items matching the given predicate
   * @param {Function} pred
   */
  filter(predicate) {
    return this.push(Action.FILTER, predicate);
  }
  /**
   * Take given numbe for values from sequence
   * @param {Number} n A number greater than 0
   */
  take(n) {
    return n > 0 ? this.push(Action.TAKE, n) : this;
  }
  /**
   * Drop a number of values from the sequence
   * @param {Number} n Number of items to drop greater than 0
   */
  drop(n) {
    return n > 0 ? this.push(Action.DROP, n) : this;
  }
  // Transformations
  /**
   * Returns a new lazy object with results of the transformation
   * The entire sequence is realized.
   *
   * @param {Function} fn Tranform function of type (Array) => (Any)
   */
  transform(fn) {
    const self2 = this;
    let iter2;
    return Lazy(() => {
      if (!iter2) {
        iter2 = Lazy(fn(self2.value()));
      }
      return iter2.next();
    });
  }
  // Terminal methods
  /**
   * Returns the fully realized values of the iterators.
   * The return value will be an array unless `lazy.first()` was used.
   * The realized values are cached for subsequent calls.
   */
  value() {
    if (!this.isDone) {
      this.isDone = this.getNext(true).done;
    }
    return this.yieldedValues;
  }
  /**
   * Execute the funcion for each value. Will stop when an execution returns false.
   * @param {Function} f
   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true
   */
  each(f) {
    for (; ; ) {
      const o = this.next();
      if (o.done)
        break;
      if (f(o.value) === false)
        return false;
    }
    return true;
  }
  /**
   * Returns the reduction of sequence according the reducing function
   *
   * @param {*} f a reducing function
   * @param {*} initialValue
   */
  reduce(f, initialValue) {
    let o = this.next();
    if (initialValue === void 0 && !o.done) {
      initialValue = o.value;
      o = this.next();
    }
    while (!o.done) {
      initialValue = f(initialValue, o.value);
      o = this.next();
    }
    return initialValue;
  }
  /**
   * Returns the number of matched items in the sequence
   */
  size() {
    return this.reduce((acc, _) => ++acc, 0);
  }
  [Symbol.iterator]() {
    return this;
  }
}
lazy.Iterator = Iterator;
Object.defineProperty(aggregator, "__esModule", { value: true });
aggregator.Aggregator = void 0;
const core_1$1M = core;
const lazy_1$6 = lazy;
const util_1$1L = util$5;
class Aggregator {
  constructor(pipeline2, options2) {
    this.pipeline = pipeline2;
    this.options = (0, core_1$1M.initOptions)(options2);
  }
  /**
   * Returns an `Lazy` iterator for processing results of pipeline
   *
   * @param {*} collection An array or iterator object
   * @returns {Iterator} an iterator object
   */
  stream(collection) {
    let iterator2 = (0, lazy_1$6.Lazy)(collection);
    const mode = this.options.processingMode;
    if (mode == core_1$1M.ProcessingMode.CLONE_ALL || mode == core_1$1M.ProcessingMode.CLONE_INPUT) {
      iterator2.map(util_1$1L.cloneDeep);
    }
    const pipelineOperators = new Array();
    if (!(0, util_1$1L.isEmpty)(this.pipeline)) {
      for (const operator of this.pipeline) {
        const operatorKeys = Object.keys(operator);
        const opName = operatorKeys[0];
        const call = (0, core_1$1M.getOperator)(core_1$1M.OperatorType.PIPELINE, opName, this.options);
        (0, util_1$1L.assert)(operatorKeys.length === 1 && !!call, `invalid pipeline operator ${opName}`);
        pipelineOperators.push(opName);
        iterator2 = call(iterator2, operator[opName], this.options);
      }
    }
    if (mode == core_1$1M.ProcessingMode.CLONE_OUTPUT || mode == core_1$1M.ProcessingMode.CLONE_ALL && !!(0, util_1$1L.intersection)([["$group", "$unwind"], pipelineOperators]).length) {
      iterator2.map(util_1$1L.cloneDeep);
    }
    return iterator2;
  }
  /**
   * Return the results of the aggregation as an array.
   *
   * @param {*} collection
   * @param {*} query
   */
  run(collection) {
    return this.stream(collection).value();
  }
}
aggregator.Aggregator = Aggregator;
Object.defineProperty(cursor, "__esModule", { value: true });
cursor.Cursor = void 0;
const aggregator_1$6 = aggregator;
const lazy_1$5 = lazy;
const util_1$1K = util$5;
class Cursor {
  constructor(source, predicate, projection, options2) {
    this.source = source;
    this.predicate = predicate;
    this.projection = projection;
    this.options = options2;
    this.operators = [];
    this.result = null;
    this.buffer = [];
  }
  /** Returns the iterator from running the query */
  fetch() {
    if (this.result)
      return this.result;
    if ((0, util_1$1K.isObject)(this.projection)) {
      this.operators.push({ $project: this.projection });
    }
    this.result = (0, lazy_1$5.Lazy)(this.source).filter(this.predicate);
    if (this.operators.length > 0) {
      this.result = new aggregator_1$6.Aggregator(this.operators, this.options).stream(this.result);
    }
    return this.result;
  }
  /** Returns an iterator with the buffered data included */
  fetchAll() {
    const buffered = (0, lazy_1$5.Lazy)([...this.buffer]);
    this.buffer = [];
    return (0, lazy_1$5.compose)(buffered, this.fetch());
  }
  /**
   * Return remaining objects in the cursor as an array. This method exhausts the cursor
   * @returns {Array}
   */
  all() {
    return this.fetchAll().value();
  }
  /**
   * Returns the number of objects return in the cursor. This method exhausts the cursor
   * @returns {Number}
   */
  count() {
    return this.all().length;
  }
  /**
   * Returns a cursor that begins returning results only after passing or skipping a number of documents.
   * @param {Number} n the number of results to skip.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  skip(n) {
    this.operators.push({ $skip: n });
    return this;
  }
  /**
   * Constrains the size of a cursor's result set.
   * @param {Number} n the number of results to limit to.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  limit(n) {
    this.operators.push({ $limit: n });
    return this;
  }
  /**
   * Returns results ordered according to a sort specification.
   * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  sort(modifier) {
    this.operators.push({ $sort: modifier });
    return this;
  }
  /**
   * Specifies the collation for the cursor returned by the `mingo.Query.find`
   * @param {*} spec
   */
  collation(spec) {
    this.options = Object.assign(Object.assign({}, this.options), { collation: spec });
    return this;
  }
  /**
   * Returns the next document in a cursor.
   * @returns {Object | Boolean}
   */
  next() {
    if (this.buffer.length > 0) {
      return this.buffer.pop();
    }
    const o = this.fetch().next();
    if (o.done)
      return;
    return o.value;
  }
  /**
   * Returns true if the cursor has documents and can be iterated.
   * @returns {boolean}
   */
  hasNext() {
    if (this.buffer.length > 0)
      return true;
    const o = this.fetch().next();
    if (o.done)
      return false;
    this.buffer.push(o.value);
    return true;
  }
  /**
   * Applies a function to each document in a cursor and collects the return values in an array.
   * @param fn
   * @returns {Array}
   */
  map(fn) {
    return this.all().map(fn);
  }
  /**
   * Applies a JavaScript function for every document in a cursor.
   * @param fn
   */
  forEach(fn) {
    this.all().forEach(fn);
  }
  [Symbol.iterator]() {
    return this.fetchAll();
  }
}
cursor.Cursor = Cursor;
Object.defineProperty(query, "__esModule", { value: true });
query.Query = void 0;
const core_1$1L = core;
const cursor_1 = cursor;
const util_1$1J = util$5;
class Query {
  constructor(condition, options2) {
    this.condition = condition;
    this.options = (0, core_1$1L.initOptions)(options2);
    this.compiled = [];
    this.compile();
  }
  compile() {
    (0, util_1$1J.assert)((0, util_1$1J.isObject)(this.condition), "query criteria must be an object");
    const whereOperator = {};
    for (const [field, expr2] of Object.entries(this.condition)) {
      if ("$where" === field) {
        Object.assign(whereOperator, { field, expr: expr2 });
      } else if ((0, util_1$1J.inArray)(["$and", "$or", "$nor", "$expr", "$jsonSchema"], field)) {
        this.processOperator(field, field, expr2);
      } else {
        (0, util_1$1J.assert)(!(0, util_1$1J.isOperator)(field), `unknown top level operator: ${field}`);
        for (const [operator, val] of Object.entries((0, util_1$1J.normalize)(expr2))) {
          this.processOperator(field, operator, val);
        }
      }
      if (whereOperator.field) {
        this.processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);
      }
    }
  }
  processOperator(field, operator, value) {
    const call = (0, core_1$1L.getOperator)(core_1$1L.OperatorType.QUERY, operator, this.options);
    if (!call) {
      throw new Error(`unknown operator ${operator}`);
    }
    const fn = call(field, value, this.options);
    this.compiled.push(fn);
  }
  /**
   * Checks if the object passes the query criteria. Returns true if so, false otherwise.
   *
   * @param obj The object to test
   * @returns {boolean} True or false
   */
  test(obj) {
    for (let i = 0, len = this.compiled.length; i < len; i++) {
      if (!this.compiled[i](obj)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns a cursor to select matching documents from the input source.
   *
   * @param source A source providing a sequence of documents
   * @param projection An optional projection criteria
   * @returns {Cursor} A Cursor for iterating over the results
   */
  find(collection, projection) {
    return new cursor_1.Cursor(collection, (x) => this.test(x), projection || {}, this.options);
  }
  /**
   * Remove matched documents from the collection returning the remainder
   *
   * @param collection An array of documents
   * @returns {Array} A new array with matching elements removed
   */
  remove(collection) {
    return collection.reduce((acc, obj) => {
      if (!this.test(obj))
        acc.push(obj);
      return acc;
    }, []);
  }
}
query.Query = Query;
var pipeline = {};
var addFields = {};
Object.defineProperty(addFields, "__esModule", { value: true });
addFields.$addFields = void 0;
const core_1$1K = core;
const util_1$1I = util$5;
const $addFields = (collection, expr2, options2) => {
  const newFields = Object.keys(expr2);
  if (newFields.length === 0)
    return collection;
  return collection.map((obj) => {
    const newObj = Object.assign({}, obj);
    for (const field of newFields) {
      const newValue = (0, core_1$1K.computeValue)(obj, expr2[field], null, options2);
      if (newValue !== void 0) {
        (0, util_1$1I.setValue)(newObj, field, newValue);
      } else {
        (0, util_1$1I.removeValue)(newObj, field);
      }
    }
    return newObj;
  });
};
addFields.$addFields = $addFields;
var bucket = {};
Object.defineProperty(bucket, "__esModule", { value: true });
bucket.$bucket = void 0;
const core_1$1J = core;
const lazy_1$4 = lazy;
const util_1$1H = util$5;
const $bucket = (collection, expr2, options2) => {
  const boundaries = [...expr2.boundaries];
  const defaultKey = expr2.default;
  const lower = boundaries[0];
  const upper = boundaries[boundaries.length - 1];
  const outputExpr = expr2.output || { count: { $sum: 1 } };
  (0, util_1$1H.assert)(expr2.boundaries.length > 2, "$bucket 'boundaries' expression must have at least 3 elements");
  const boundType = (0, util_1$1H.getType)(lower);
  for (let i = 0, len = boundaries.length - 1; i < len; i++) {
    (0, util_1$1H.assert)(boundType === (0, util_1$1H.getType)(boundaries[i + 1]), "$bucket 'boundaries' must all be of the same type");
    (0, util_1$1H.assert)((0, util_1$1H.compare)(boundaries[i], boundaries[i + 1]) < 0, "$bucket 'boundaries' must be sorted in ascending order");
  }
  !(0, util_1$1H.isNil)(defaultKey) && (0, util_1$1H.getType)(expr2.default) === (0, util_1$1H.getType)(lower) && (0, util_1$1H.assert)((0, util_1$1H.compare)(expr2.default, upper) >= 0 || (0, util_1$1H.compare)(expr2.default, lower) < 0, "$bucket 'default' expression must be out of boundaries range");
  const grouped = {};
  for (const k of boundaries) {
    grouped[k] = [];
  }
  if (!(0, util_1$1H.isNil)(defaultKey))
    grouped[defaultKey] = [];
  let iterator2;
  return (0, lazy_1$4.Lazy)(() => {
    if (!iterator2) {
      collection.each((obj) => {
        const key = (0, core_1$1J.computeValue)(obj, expr2.groupBy, null, options2);
        if ((0, util_1$1H.isNil)(key) || (0, util_1$1H.compare)(key, lower) < 0 || (0, util_1$1H.compare)(key, upper) >= 0) {
          (0, util_1$1H.assert)(!(0, util_1$1H.isNil)(defaultKey), "$bucket require a default for out of range values");
          grouped[defaultKey].push(obj);
        } else {
          (0, util_1$1H.assert)((0, util_1$1H.compare)(key, lower) >= 0 && (0, util_1$1H.compare)(key, upper) < 0, "$bucket 'groupBy' expression must resolve to a value in range of boundaries");
          const index = findInsertIndex(boundaries, key);
          const boundKey = boundaries[Math.max(0, index - 1)];
          grouped[boundKey].push(obj);
        }
      });
      boundaries.pop();
      if (!(0, util_1$1H.isNil)(defaultKey))
        boundaries.push(defaultKey);
      iterator2 = (0, lazy_1$4.Lazy)(boundaries).map((key) => {
        const acc = (0, core_1$1J.computeValue)(grouped[key], outputExpr, null, options2);
        return (0, util_1$1H.into)(acc, { _id: key });
      });
    }
    return iterator2.next();
  });
};
bucket.$bucket = $bucket;
function findInsertIndex(sorted, item) {
  let lo = 0;
  let hi = sorted.length - 1;
  while (lo <= hi) {
    const mid = Math.round(lo + (hi - lo) / 2);
    if ((0, util_1$1H.compare)(item, sorted[mid]) < 0) {
      hi = mid - 1;
    } else if ((0, util_1$1H.compare)(item, sorted[mid]) > 0) {
      lo = mid + 1;
    } else {
      return mid;
    }
  }
  return lo;
}
var bucketAuto = {};
Object.defineProperty(bucketAuto, "__esModule", { value: true });
bucketAuto.$bucketAuto = void 0;
const core_1$1I = core;
const util_1$1G = util$5;
const $bucketAuto = (collection, expr2, options2) => {
  const outputExpr = expr2.output || { count: { $sum: 1 } };
  const groupByExpr = expr2.groupBy;
  const bucketCount = expr2.buckets;
  (0, util_1$1G.assert)(bucketCount > 0, `The $bucketAuto 'buckets' field must be greater than 0, but found: ${bucketCount}`);
  const ID_KEY2 = "_id";
  return collection.transform((coll) => {
    const approxBucketSize = Math.max(1, Math.round(coll.length / bucketCount));
    const computeValueOptimized = (0, util_1$1G.memoize)(core_1$1I.computeValue, options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
    const grouped = /* @__PURE__ */ new Map();
    const remaining = [];
    const sorted = (0, util_1$1G.sortBy)(coll, (o) => {
      const key = computeValueOptimized(o, groupByExpr, null, options2);
      if ((0, util_1$1G.isNil)(key)) {
        remaining.push(o);
      } else {
        if (!grouped.has(key))
          grouped.set(key, []);
        grouped.get(key).push(o);
      }
      return key;
    });
    const result = [];
    let index = 0;
    for (let i = 0, len = sorted.length; i < bucketCount && index < len; i++) {
      const boundaries = {};
      const bucketItems = [];
      for (let j = 0; j < approxBucketSize && index < len; j++) {
        let key = computeValueOptimized(sorted[index], groupByExpr, null, options2);
        if ((0, util_1$1G.isNil)(key))
          key = null;
        (0, util_1$1G.into)(bucketItems, (0, util_1$1G.isNil)(key) ? remaining : grouped.get(key));
        index += (0, util_1$1G.isNil)(key) ? remaining.length : grouped.get(key).length;
        if (!(0, util_1$1G.has)(boundaries, "min"))
          boundaries.min = key;
        if (result.length > 0) {
          const lastBucket = result[result.length - 1];
          lastBucket[ID_KEY2].max = boundaries.min;
        }
      }
      if (i == bucketCount - 1) {
        (0, util_1$1G.into)(bucketItems, sorted.slice(index));
      }
      const values = (0, core_1$1I.computeValue)(bucketItems, outputExpr, null, options2);
      result.push((0, util_1$1G.into)(values, {
        _id: boundaries
      }));
    }
    if (result.length > 0) {
      result[result.length - 1][ID_KEY2].max = computeValueOptimized(sorted[sorted.length - 1], groupByExpr, null, options2);
    }
    return result;
  });
};
bucketAuto.$bucketAuto = $bucketAuto;
var count$1 = {};
Object.defineProperty(count$1, "__esModule", { value: true });
count$1.$count = void 0;
const lazy_1$3 = lazy;
const util_1$1F = util$5;
const $count$1 = (collection, expr2, _) => {
  (0, util_1$1F.assert)((0, util_1$1F.isString)(expr2) && expr2.trim() !== "" && expr2.indexOf(".") === -1 && expr2.trim()[0] !== "$", "Invalid expression value for $count");
  return (0, lazy_1$3.Lazy)([
    {
      [expr2]: collection.size()
    }
  ]);
};
count$1.$count = $count$1;
var facet = {};
Object.defineProperty(facet, "__esModule", { value: true });
facet.$facet = void 0;
const aggregator_1$5 = aggregator;
const core_1$1H = core;
const $facet = (collection, expr2, options2) => {
  return collection.transform((array2) => {
    const o = {};
    for (const [k, pipeline2] of Object.entries(expr2)) {
      o[k] = new aggregator_1$5.Aggregator(pipeline2, Object.assign(Object.assign({}, options2), { processingMode: core_1$1H.ProcessingMode.CLONE_INPUT })).run(array2);
    }
    return [o];
  });
};
facet.$facet = $facet;
var fill = {};
var ifNull = {};
Object.defineProperty(ifNull, "__esModule", { value: true });
ifNull.$ifNull = void 0;
const core_1$1G = core;
const util_1$1E = util$5;
const $ifNull = (obj, expr2, options2) => {
  const args2 = (0, core_1$1G.computeValue)(obj, expr2, null, options2);
  return args2.find((arg) => !(0, util_1$1E.isNil)(arg));
};
ifNull.$ifNull = $ifNull;
var linearFill = {};
var accumulator$1 = {};
var accumulator = {};
Object.defineProperty(accumulator, "__esModule", { value: true });
accumulator.$accumulator = void 0;
const core_1$1F = core;
const util_1$1D = util$5;
const $accumulator = (collection, expr2, options2) => {
  var _a;
  (0, util_1$1D.assert)(!!options2 && options2.scriptEnabled, "$accumulator operator requires 'scriptEnabled' option to be true");
  if (collection.length == 0)
    return expr2.initArgs;
  const copts = core_1$1F.ComputeOptions.init(options2);
  const initArgs = (0, core_1$1F.computeValue)({}, expr2.initArgs || [], null, copts.update(((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId) || {}));
  let state = expr2.init.call(null, ...initArgs);
  for (const doc of collection) {
    const args2 = (0, core_1$1F.computeValue)(doc, expr2.accumulateArgs, null, copts.update(doc));
    state = expr2.accumulate.call(null, ...[state, ...args2]);
  }
  return expr2.finalize ? expr2.finalize.call(null, state) : state;
};
accumulator.$accumulator = $accumulator;
var addToSet = {};
var push$1 = {};
Object.defineProperty(push$1, "__esModule", { value: true });
push$1.$push = void 0;
const core_1$1E = core;
const util_1$1C = util$5;
const $push = (collection, expr2, options2) => {
  if ((0, util_1$1C.isNil)(expr2))
    return collection;
  const copts = core_1$1E.ComputeOptions.init(options2);
  return collection.map((obj) => (0, core_1$1E.computeValue)(obj, expr2, null, copts.update(obj)));
};
push$1.$push = $push;
Object.defineProperty(addToSet, "__esModule", { value: true });
addToSet.$addToSet = void 0;
const util_1$1B = util$5;
const push_1$f = push$1;
const $addToSet = (collection, expr2, options2) => {
  return (0, util_1$1B.unique)((0, push_1$f.$push)(collection, expr2, options2), options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
};
addToSet.$addToSet = $addToSet;
var avg = {};
Object.defineProperty(avg, "__esModule", { value: true });
avg.$avg = void 0;
const util_1$1A = util$5;
const push_1$e = push$1;
const $avg = (collection, expr2, options2) => {
  const data = (0, push_1$e.$push)(collection, expr2, options2).filter(util_1$1A.isNumber);
  const sum2 = data.reduce((acc, n) => acc + n, 0);
  return sum2 / (data.length || 1);
};
avg.$avg = $avg;
var bottom = {};
var bottomN = {};
Object.defineProperty(bottomN, "__esModule", { value: true });
bottomN.$bottomN = void 0;
const aggregator_1$4 = aggregator;
const core_1$1D = core;
const push_1$d = push$1;
const $bottomN = (collection, expr2, options2) => {
  const copts = core_1$1D.ComputeOptions.init(options2);
  const { n, sortBy } = (0, core_1$1D.computeValue)(copts.local.groupId, expr2, null, copts);
  const result = new aggregator_1$4.Aggregator([{ $sort: sortBy }], copts).run(collection);
  const m = result.length;
  const p = n;
  return (0, push_1$d.$push)(m <= p ? result : result.slice(m - p), expr2.output, copts);
};
bottomN.$bottomN = $bottomN;
Object.defineProperty(bottom, "__esModule", { value: true });
bottom.$bottom = void 0;
const bottomN_1 = bottomN;
const $bottom = (collection, expr2, options2) => (0, bottomN_1.$bottomN)(collection, Object.assign(Object.assign({}, expr2), { n: 1 }), options2);
bottom.$bottom = $bottom;
var count = {};
Object.defineProperty(count, "__esModule", { value: true });
count.$count = void 0;
const $count = (collection, _expr, _options2) => collection.length;
count.$count = $count;
var covariancePop = {};
var _internal$7 = {};
Object.defineProperty(_internal$7, "__esModule", { value: true });
_internal$7.covariance = _internal$7.stddev = void 0;
function stddev(data, sampled = true) {
  const sum2 = data.reduce((acc, n) => acc + n, 0);
  const N = data.length || 1;
  const avg2 = sum2 / N;
  return Math.sqrt(data.reduce((acc, n) => acc + Math.pow(n - avg2, 2), 0) / (N - Number(sampled)));
}
_internal$7.stddev = stddev;
function covariance(dataset, sampled = true) {
  if (!dataset)
    return null;
  if (dataset.length < 2)
    return sampled ? null : 0;
  let meanX = 0;
  let meanY = 0;
  for (const [x, y] of dataset) {
    meanX += x;
    meanY += y;
  }
  meanX /= dataset.length;
  meanY /= dataset.length;
  let result = 0;
  for (const [x, y] of dataset) {
    result += (x - meanX) * (y - meanY);
  }
  return result / (dataset.length - Number(sampled));
}
_internal$7.covariance = covariance;
Object.defineProperty(covariancePop, "__esModule", { value: true });
covariancePop.$covariancePop = void 0;
const _internal_1$Q = _internal$7;
const push_1$c = push$1;
const $covariancePop = (collection, expr2, options2) => (0, _internal_1$Q.covariance)((0, push_1$c.$push)(collection, expr2, options2), false);
covariancePop.$covariancePop = $covariancePop;
var covarianceSamp = {};
Object.defineProperty(covarianceSamp, "__esModule", { value: true });
covarianceSamp.$covarianceSamp = void 0;
const _internal_1$P = _internal$7;
const push_1$b = push$1;
const $covarianceSamp = (collection, expr2, options2) => (0, _internal_1$P.covariance)((0, push_1$b.$push)(collection, expr2, options2), true);
covarianceSamp.$covarianceSamp = $covarianceSamp;
var first$1 = {};
Object.defineProperty(first$1, "__esModule", { value: true });
first$1.$first = void 0;
const core_1$1C = core;
const $first$1 = (collection, expr2, options2) => {
  return collection.length > 0 ? (0, core_1$1C.computeValue)(collection[0], expr2, null, options2) : void 0;
};
first$1.$first = $first$1;
var firstN$1 = {};
Object.defineProperty(firstN$1, "__esModule", { value: true });
firstN$1.$firstN = void 0;
const core_1$1B = core;
const push_1$a = push$1;
const $firstN$1 = (collection, expr2, options2) => {
  var _a;
  const copts = core_1$1B.ComputeOptions.init(options2);
  const m = collection.length;
  const n = (0, core_1$1B.computeValue)((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId, expr2.n, null, copts);
  return (0, push_1$a.$push)(m <= n ? collection : collection.slice(0, n), expr2.input, options2);
};
firstN$1.$firstN = $firstN$1;
var last$1 = {};
Object.defineProperty(last$1, "__esModule", { value: true });
last$1.$last = void 0;
const core_1$1A = core;
const $last$1 = (collection, expr2, options2) => {
  return collection.length > 0 ? (0, core_1$1A.computeValue)(collection[collection.length - 1], expr2, null, options2) : void 0;
};
last$1.$last = $last$1;
var lastN$1 = {};
Object.defineProperty(lastN$1, "__esModule", { value: true });
lastN$1.$lastN = void 0;
const core_1$1z = core;
const push_1$9 = push$1;
const $lastN$1 = (collection, expr2, options2) => {
  var _a;
  const copts = core_1$1z.ComputeOptions.init(options2);
  const m = collection.length;
  const n = (0, core_1$1z.computeValue)((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId, expr2.n, null, copts);
  return (0, push_1$9.$push)(m <= n ? collection : collection.slice(m - n), expr2.input, options2);
};
lastN$1.$lastN = $lastN$1;
var max = {};
Object.defineProperty(max, "__esModule", { value: true });
max.$max = void 0;
const util_1$1z = util$5;
const push_1$8 = push$1;
const $max = (collection, expr2, options2) => {
  const nums = (0, push_1$8.$push)(collection, expr2, options2).filter(util_1$1z.isNotNaN);
  const n = nums.reduce((acc, n2) => (0, util_1$1z.compare)(n2, acc) >= 0 ? n2 : acc, -Infinity);
  return n === -Infinity ? void 0 : n;
};
max.$max = $max;
var maxN$1 = {};
Object.defineProperty(maxN$1, "__esModule", { value: true });
maxN$1.$maxN = void 0;
const core_1$1y = core;
const util_1$1y = util$5;
const push_1$7 = push$1;
const $maxN$1 = (collection, expr2, options2) => {
  var _a;
  const copts = core_1$1y.ComputeOptions.init(options2);
  const m = collection.length;
  const n = (0, core_1$1y.computeValue)((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId, expr2.n, null, copts);
  const arr2 = (0, push_1$7.$push)(collection, expr2.input, options2).filter((o) => !(0, util_1$1y.isNil)(o));
  arr2.sort((a, b) => -1 * (0, util_1$1y.compare)(a, b));
  return m <= n ? arr2 : arr2.slice(0, n);
};
maxN$1.$maxN = $maxN$1;
var mergeObjects$1 = {};
var mergeObjects = {};
Object.defineProperty(mergeObjects, "__esModule", { value: true });
mergeObjects.$mergeObjects = void 0;
const core_1$1x = core;
const util_1$1x = util$5;
const $mergeObjects$1 = (obj, expr2, options2) => {
  const docs = (0, core_1$1x.computeValue)(obj, expr2, null, options2);
  return docs instanceof Array ? docs.reduce((memo2, o) => (0, util_1$1x.into)(memo2, o), {}) : {};
};
mergeObjects.$mergeObjects = $mergeObjects$1;
Object.defineProperty(mergeObjects$1, "__esModule", { value: true });
mergeObjects$1.$mergeObjects = void 0;
const mergeObjects_1 = mergeObjects;
const $mergeObjects = (collection, _, options2) => (0, mergeObjects_1.$mergeObjects)({ docs: collection }, "$docs", options2);
mergeObjects$1.$mergeObjects = $mergeObjects;
var min = {};
Object.defineProperty(min, "__esModule", { value: true });
min.$min = void 0;
const util_1$1w = util$5;
const push_1$6 = push$1;
const $min = (collection, expr2, options2) => {
  const nums = (0, push_1$6.$push)(collection, expr2, options2).filter(util_1$1w.isNotNaN);
  const n = nums.reduce((acc, n2) => (0, util_1$1w.compare)(n2, acc) <= 0 ? n2 : acc, Infinity);
  return n === Infinity ? void 0 : n;
};
min.$min = $min;
var minN$1 = {};
Object.defineProperty(minN$1, "__esModule", { value: true });
minN$1.$minN = void 0;
const core_1$1w = core;
const util_1$1v = util$5;
const push_1$5 = push$1;
const $minN$1 = (collection, expr2, options2) => {
  var _a;
  const copts = core_1$1w.ComputeOptions.init(options2);
  const m = collection.length;
  const n = (0, core_1$1w.computeValue)((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId, expr2.n, null, copts);
  const arr2 = (0, push_1$5.$push)(collection, expr2.input, options2).filter((o) => !(0, util_1$1v.isNil)(o));
  arr2.sort(util_1$1v.compare);
  return m <= n ? arr2 : arr2.slice(0, n);
};
minN$1.$minN = $minN$1;
var stdDevPop = {};
Object.defineProperty(stdDevPop, "__esModule", { value: true });
stdDevPop.$stdDevPop = void 0;
const util_1$1u = util$5;
const _internal_1$O = _internal$7;
const push_1$4 = push$1;
const $stdDevPop = (collection, expr2, options2) => (0, _internal_1$O.stddev)((0, push_1$4.$push)(collection, expr2, options2).filter(util_1$1u.isNumber), false);
stdDevPop.$stdDevPop = $stdDevPop;
var stdDevSamp = {};
Object.defineProperty(stdDevSamp, "__esModule", { value: true });
stdDevSamp.$stdDevSamp = void 0;
const util_1$1t = util$5;
const _internal_1$N = _internal$7;
const push_1$3 = push$1;
const $stdDevSamp = (collection, expr2, options2) => (0, _internal_1$N.stddev)((0, push_1$3.$push)(collection, expr2, options2).filter(util_1$1t.isNumber), true);
stdDevSamp.$stdDevSamp = $stdDevSamp;
var sum = {};
Object.defineProperty(sum, "__esModule", { value: true });
sum.$sum = void 0;
const util_1$1s = util$5;
const push_1$2 = push$1;
const $sum = (collection, expr2, options2) => {
  if (!(0, util_1$1s.isArray)(collection))
    return 0;
  if ((0, util_1$1s.isNumber)(expr2))
    return collection.length * expr2;
  const nums = (0, push_1$2.$push)(collection, expr2, options2).filter(util_1$1s.isNumber);
  return nums.reduce((acc, n) => acc + n, 0);
};
sum.$sum = $sum;
var top = {};
var topN = {};
Object.defineProperty(topN, "__esModule", { value: true });
topN.$topN = void 0;
const aggregator_1$3 = aggregator;
const core_1$1v = core;
const push_1$1 = push$1;
const $topN = (collection, expr2, options2) => {
  const copts = core_1$1v.ComputeOptions.init(options2);
  const { n, sortBy } = (0, core_1$1v.computeValue)(copts.local.groupId, expr2, null, copts);
  const result = new aggregator_1$3.Aggregator([{ $sort: sortBy }, { $limit: n }], copts).run(collection);
  return (0, push_1$1.$push)(result, expr2.output, copts);
};
topN.$topN = $topN;
Object.defineProperty(top, "__esModule", { value: true });
top.$top = void 0;
const topN_1 = topN;
const $top = (collection, expr2, options2) => (0, topN_1.$topN)(collection, Object.assign(Object.assign({}, expr2), { n: 1 }), options2);
top.$top = $top;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(accumulator, exports);
  __exportStar(addToSet, exports);
  __exportStar(avg, exports);
  __exportStar(bottom, exports);
  __exportStar(bottomN, exports);
  __exportStar(count, exports);
  __exportStar(covariancePop, exports);
  __exportStar(covarianceSamp, exports);
  __exportStar(first$1, exports);
  __exportStar(firstN$1, exports);
  __exportStar(last$1, exports);
  __exportStar(lastN$1, exports);
  __exportStar(max, exports);
  __exportStar(maxN$1, exports);
  __exportStar(mergeObjects$1, exports);
  __exportStar(min, exports);
  __exportStar(minN$1, exports);
  __exportStar(push$1, exports);
  __exportStar(stdDevPop, exports);
  __exportStar(stdDevSamp, exports);
  __exportStar(sum, exports);
  __exportStar(top, exports);
  __exportStar(topN, exports);
})(accumulator$1);
var _internal$6 = {};
var _internal$5 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexStrip = exports.regexQuote = exports.padDigits = exports.computeDate = exports.adjustDate = exports.formatTimezone = exports.parseTimezone = exports.DATE_SYM_TABLE = exports.DATE_PART_INTERVAL = exports.DATE_FORMAT = exports.DURATION_IN_MILLIS = exports.MILLIS_PER_DAY = exports.MINUTES_PER_HOUR = exports.isoWeekYear = exports.isoWeek = exports.getDayOfYear = exports.isLeapYear = void 0;
  const core_12 = core;
  const util_12 = util$5;
  const COMMON_YEAR_DAYS_OFFSET = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  const LEAP_YEAR_DAYS_OFFSET = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  const p = (y) => (y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400)) % 7;
  const weeks = (y) => 52 + Number(p(y) == 4 || p(y - 1) == 3);
  const isLeapYear = (year2) => (year2 & 3) == 0 && (year2 % 100 != 0 || year2 % 400 == 0);
  exports.isLeapYear = isLeapYear;
  const getDayOfYear = (d) => ((0, exports.isLeapYear)(d.getUTCFullYear()) ? LEAP_YEAR_DAYS_OFFSET : COMMON_YEAR_DAYS_OFFSET)[d.getUTCMonth()] + d.getUTCDate();
  exports.getDayOfYear = getDayOfYear;
  function isoWeek2(d) {
    const w = Math.floor((10 + (0, exports.getDayOfYear)(d) - (d.getUTCDay() || 7)) / 7);
    if (w < 1)
      return weeks(d.getUTCFullYear() - 1);
    if (w > weeks(d.getUTCFullYear()))
      return 1;
    return w;
  }
  exports.isoWeek = isoWeek2;
  function isoWeekYear2(d) {
    return d.getUTCFullYear() - Number(d.getUTCMonth() == 0 && d.getUTCDate() == 1 && d.getUTCDay() < 1);
  }
  exports.isoWeekYear = isoWeekYear2;
  exports.MINUTES_PER_HOUR = 60;
  exports.MILLIS_PER_DAY = 1e3 * 60 * 60 * 24;
  exports.DURATION_IN_MILLIS = {
    week: exports.MILLIS_PER_DAY * 7,
    day: exports.MILLIS_PER_DAY,
    hour: 1e3 * 60 * 60,
    minute: 1e3 * 60,
    second: 1e3,
    millisecond: 1
  };
  exports.DATE_FORMAT = "%Y-%m-%dT%H:%M:%S.%LZ";
  exports.DATE_PART_INTERVAL = [
    ["year", 0, 9999],
    ["month", 1, 12],
    ["day", 1, 31],
    ["hour", 0, 23],
    ["minute", 0, 59],
    ["second", 0, 59],
    ["millisecond", 0, 999]
  ];
  exports.DATE_SYM_TABLE = {
    "%Y": { name: "year", padding: 4, re: /([0-9]{4})/ },
    "%G": { name: "year", padding: 4, re: /([0-9]{4})/ },
    "%m": { name: "month", padding: 2, re: /(0[1-9]|1[012])/ },
    "%d": { name: "day", padding: 2, re: /(0[1-9]|[12][0-9]|3[01])/ },
    "%H": { name: "hour", padding: 2, re: /([01][0-9]|2[0-3])/ },
    "%M": { name: "minute", padding: 2, re: /([0-5][0-9])/ },
    "%S": { name: "second", padding: 2, re: /([0-5][0-9]|60)/ },
    "%L": { name: "millisecond", padding: 3, re: /([0-9]{3})/ },
    "%u": { name: "weekday", padding: 1, re: /([1-7])/ },
    "%U": { name: "week", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },
    "%V": { name: "isoWeek", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },
    "%z": {
      name: "timezone",
      padding: 2,
      re: /(([+-][01][0-9]|2[0-3]):?([0-5][0-9])?)/
    },
    "%Z": { name: "minuteOffset", padding: 3, re: /([+-][0-9]{3})/ }
    // "%%": "%",
  };
  function parseTimezone(tzstr) {
    if ((0, util_12.isNil)(tzstr))
      return 0;
    const m = exports.DATE_SYM_TABLE["%z"].re.exec(tzstr);
    if (!m)
      throw Error(`invalid or location-based timezone '${tzstr}' not supported`);
    const hr = parseInt(m[2]) || 0;
    const min2 = parseInt(m[3]) || 0;
    return (Math.abs(hr * exports.MINUTES_PER_HOUR) + min2) * (hr < 0 ? -1 : 1);
  }
  exports.parseTimezone = parseTimezone;
  function formatTimezone(minuteOffset) {
    return (minuteOffset < 0 ? "-" : "+") + padDigits(Math.abs(Math.floor(minuteOffset / exports.MINUTES_PER_HOUR)), 2) + padDigits(Math.abs(minuteOffset) % exports.MINUTES_PER_HOUR, 2);
  }
  exports.formatTimezone = formatTimezone;
  function adjustDate(d, minuteOffset) {
    d.setUTCMinutes(d.getUTCMinutes() + minuteOffset);
  }
  exports.adjustDate = adjustDate;
  function computeDate(obj, expr2, options2) {
    const d = (0, core_12.computeValue)(obj, expr2, null, options2);
    if ((0, util_12.isDate)(d))
      return new Date(d);
    if ((0, util_12.isNumber)(d))
      return new Date(d * 1e3);
    if (d.date) {
      const date2 = (0, util_12.isDate)(d.date) ? new Date(d.date) : new Date(d.date * 1e3);
      if (d.timezone) {
        adjustDate(date2, parseTimezone(d.timezone));
      }
      return date2;
    }
    throw Error(`cannot convert ${expr2 === null || expr2 === void 0 ? void 0 : expr2.toString()} to date`);
  }
  exports.computeDate = computeDate;
  function padDigits(n, digits2) {
    return new Array(Math.max(digits2 - String(n).length + 1, 0)).join("0") + n.toString();
  }
  exports.padDigits = padDigits;
  function regexQuote(s) {
    "^.-*?$".split("").forEach((c) => {
      s = s.replace(c, `\\${c}`);
    });
    return s;
  }
  exports.regexQuote = regexQuote;
  function regexStrip(s) {
    return s.replace(/^\//, "").replace(/\/$/, "");
  }
  exports.regexStrip = regexStrip;
})(_internal$5);
var _internal$4 = {};
Object.defineProperty(_internal$4, "__esModule", { value: true });
_internal$4.isUnbounded = void 0;
const isUnbounded = (window2) => {
  const boundary = (window2 === null || window2 === void 0 ? void 0 : window2.documents) || (window2 === null || window2 === void 0 ? void 0 : window2.range);
  return !boundary || boundary[0] === "unbounded" && boundary[1] === "unbounded";
};
_internal$4.isUnbounded = isUnbounded;
Object.defineProperty(_internal$6, "__esModule", { value: true });
_internal$6.rank = _internal$6.withMemo = _internal$6.MILLIS_PER_UNIT = void 0;
const util_1$1r = util$5;
const accumulator_1$3 = accumulator$1;
const _internal_1$M = _internal$5;
const _internal_2 = _internal$4;
_internal$6.MILLIS_PER_UNIT = {
  week: _internal_1$M.MILLIS_PER_DAY * 7,
  day: _internal_1$M.MILLIS_PER_DAY,
  hour: _internal_1$M.MILLIS_PER_DAY / 24,
  minute: 6e4,
  second: 1e3,
  millisecond: 1
};
const memo = /* @__PURE__ */ new WeakMap();
function withMemo(collection, expr2, cacheFn, fn) {
  if (!(0, _internal_2.isUnbounded)(expr2.parentExpr.output[expr2.field].window)) {
    return fn(cacheFn());
  }
  if (!memo.has(collection)) {
    memo.set(collection, { [expr2.field]: cacheFn() });
  }
  const data = memo.get(collection);
  if (data[expr2.field] === void 0) {
    data[expr2.field] = cacheFn();
  }
  let failed = false;
  try {
    return fn(data[expr2.field]);
  } catch (e) {
    failed = true;
  } finally {
    if (failed || expr2.documentNumber === collection.length) {
      delete data[expr2.field];
      if (Object.keys(data).length === 0)
        memo.delete(collection);
    }
  }
}
_internal$6.withMemo = withMemo;
function rank(_, collection, expr2, options2, dense) {
  return withMemo(collection, expr2, () => {
    const sortKey = "$" + Object.keys(expr2.parentExpr.sortBy)[0];
    const values = (0, accumulator_1$3.$push)(collection, sortKey, options2);
    const groups = (0, util_1$1r.groupBy)(values, (_2, n) => values[n], options2.hashFunction);
    return { values, groups };
  }, (input) => {
    const { values, groups: partitions } = input;
    if (partitions.size == collection.length) {
      return expr2.documentNumber;
    }
    const current = values[expr2.documentNumber - 1];
    let i = 0;
    let offset = 0;
    for (const key of partitions.keys()) {
      if ((0, util_1$1r.isEqual)(current, key)) {
        return dense ? i + 1 : offset + 1;
      }
      i++;
      offset += partitions.get(key).length;
    }
    throw new Error("rank: invalid return value. please submit a bug report.");
  });
}
_internal$6.rank = rank;
Object.defineProperty(linearFill, "__esModule", { value: true });
linearFill.$linearFill = void 0;
const util_1$1q = util$5;
const accumulator_1$2 = accumulator$1;
const _internal_1$L = _internal$6;
const interpolate = (x1, y1, x2, y2, x) => y1 + (x - x1) * ((y2 - y1) / (x2 - x1));
function $linearFill(_, collection, expr2, options2) {
  return (0, _internal_1$L.withMemo)(collection, expr2, () => {
    const sortKey = "$" + Object.keys(expr2.parentExpr.sortBy)[0];
    const points = (0, accumulator_1$2.$push)(collection, [sortKey, expr2.inputExpr], options2).filter(([x, _2]) => (0, util_1$1q.isNumber)(+x));
    if (points.length !== collection.length)
      return null;
    let lindex = -1;
    let rindex = 0;
    while (rindex < points.length) {
      while (lindex + 1 < points.length && (0, util_1$1q.isNumber)(points[lindex + 1][1])) {
        lindex++;
        rindex = lindex;
      }
      while (rindex + 1 < points.length && !(0, util_1$1q.isNumber)(points[rindex + 1][1])) {
        rindex++;
      }
      if (rindex + 1 >= points.length)
        break;
      rindex++;
      while (lindex + 1 < rindex) {
        points[lindex + 1][1] = interpolate(points[lindex][0], points[lindex][1], points[rindex][0], points[rindex][1], points[lindex + 1][0]);
        lindex++;
      }
      lindex = rindex;
    }
    return points.map(([_2, y]) => y);
  }, (values) => values[expr2.documentNumber - 1]);
}
linearFill.$linearFill = $linearFill;
var locf = {};
Object.defineProperty(locf, "__esModule", { value: true });
locf.$locf = void 0;
const util_1$1p = util$5;
const push_1 = push$1;
const _internal_1$K = _internal$6;
function $locf(_, collection, expr2, options2) {
  return (0, _internal_1$K.withMemo)(collection, expr2, () => {
    const values = (0, push_1.$push)(collection, expr2.inputExpr, options2);
    for (let i = 1; i < values.length; i++) {
      if ((0, util_1$1p.isNil)(values[i]))
        values[i] = values[i - 1];
    }
    return values;
  }, (series) => series[expr2.documentNumber - 1]);
}
locf.$locf = $locf;
var setWindowFields = {};
var expression = {};
var arithmetic = {};
var abs = {};
Object.defineProperty(abs, "__esModule", { value: true });
abs.$abs = void 0;
const core_1$1u = core;
const util_1$1o = util$5;
const $abs = (obj, expr2, options2) => {
  const n = (0, core_1$1u.computeValue)(obj, expr2, null, options2);
  return (0, util_1$1o.isNil)(n) ? null : Math.abs(n);
};
abs.$abs = $abs;
var add$1 = {};
Object.defineProperty(add$1, "__esModule", { value: true });
add$1.$add = void 0;
const core_1$1t = core;
const util_1$1n = util$5;
const $add = (obj, expr2, options2) => {
  const args2 = (0, core_1$1t.computeValue)(obj, expr2, null, options2);
  let foundDate = false;
  const result = args2.reduce((acc, val) => {
    if ((0, util_1$1n.isDate)(val)) {
      (0, util_1$1n.assert)(!foundDate, "'$add' can only have one date value");
      foundDate = true;
      val = val.getTime();
    }
    acc += val;
    return acc;
  }, 0);
  return foundDate ? new Date(result) : result;
};
add$1.$add = $add;
var ceil = {};
Object.defineProperty(ceil, "__esModule", { value: true });
ceil.$ceil = void 0;
const core_1$1s = core;
const util_1$1m = util$5;
const $ceil = (obj, expr2, options2) => {
  const n = (0, core_1$1s.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1m.isNil)(n))
    return null;
  (0, util_1$1m.assert)((0, util_1$1m.isNumber)(n) || isNaN(n), "$ceil expression must resolve to a number.");
  return Math.ceil(n);
};
ceil.$ceil = $ceil;
var divide = {};
Object.defineProperty(divide, "__esModule", { value: true });
divide.$divide = void 0;
const core_1$1r = core;
const $divide = (obj, expr2, options2) => {
  const args2 = (0, core_1$1r.computeValue)(obj, expr2, null, options2);
  return args2[0] / args2[1];
};
divide.$divide = $divide;
var exp = {};
Object.defineProperty(exp, "__esModule", { value: true });
exp.$exp = void 0;
const core_1$1q = core;
const util_1$1l = util$5;
const $exp = (obj, expr2, options2) => {
  const n = (0, core_1$1q.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1l.isNil)(n))
    return null;
  (0, util_1$1l.assert)((0, util_1$1l.isNumber)(n) || isNaN(n), "$exp expression must resolve to a number.");
  return Math.exp(n);
};
exp.$exp = $exp;
var floor = {};
Object.defineProperty(floor, "__esModule", { value: true });
floor.$floor = void 0;
const core_1$1p = core;
const util_1$1k = util$5;
const $floor = (obj, expr2, options2) => {
  const n = (0, core_1$1p.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1k.isNil)(n))
    return null;
  (0, util_1$1k.assert)((0, util_1$1k.isNumber)(n) || isNaN(n), "$floor expression must resolve to a number.");
  return Math.floor(n);
};
floor.$floor = $floor;
var ln = {};
Object.defineProperty(ln, "__esModule", { value: true });
ln.$ln = void 0;
const core_1$1o = core;
const util_1$1j = util$5;
const $ln = (obj, expr2, options2) => {
  const n = (0, core_1$1o.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1j.isNil)(n))
    return null;
  (0, util_1$1j.assert)((0, util_1$1j.isNumber)(n) || isNaN(n), "$ln expression must resolve to a number.");
  return Math.log(n);
};
ln.$ln = $ln;
var log = {};
Object.defineProperty(log, "__esModule", { value: true });
log.$log = void 0;
const core_1$1n = core;
const util_1$1i = util$5;
const $log = (obj, expr2, options2) => {
  const args2 = (0, core_1$1n.computeValue)(obj, expr2, null, options2);
  const msg = "$log expression must resolve to array(2) of numbers";
  (0, util_1$1i.assert)((0, util_1$1i.isArray)(args2) && args2.length === 2, msg);
  if (args2.some(util_1$1i.isNil))
    return null;
  (0, util_1$1i.assert)(args2.some(isNaN) || args2.every(util_1$1i.isNumber), msg);
  return Math.log10(args2[0]) / Math.log10(args2[1]);
};
log.$log = $log;
var log10 = {};
Object.defineProperty(log10, "__esModule", { value: true });
log10.$log10 = void 0;
const core_1$1m = core;
const util_1$1h = util$5;
const $log10 = (obj, expr2, options2) => {
  const n = (0, core_1$1m.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1h.isNil)(n))
    return null;
  (0, util_1$1h.assert)((0, util_1$1h.isNumber)(n) || isNaN(n), "$log10 expression must resolve to a number.");
  return Math.log10(n);
};
log10.$log10 = $log10;
var mod$1 = {};
Object.defineProperty(mod$1, "__esModule", { value: true });
mod$1.$mod = void 0;
const core_1$1l = core;
const $mod$1 = (obj, expr2, options2) => {
  const args2 = (0, core_1$1l.computeValue)(obj, expr2, null, options2);
  return args2[0] % args2[1];
};
mod$1.$mod = $mod$1;
var multiply = {};
Object.defineProperty(multiply, "__esModule", { value: true });
multiply.$multiply = void 0;
const core_1$1k = core;
const $multiply = (obj, expr2, options2) => {
  const args2 = (0, core_1$1k.computeValue)(obj, expr2, null, options2);
  return args2.reduce((acc, num) => acc * num, 1);
};
multiply.$multiply = $multiply;
var pow = {};
Object.defineProperty(pow, "__esModule", { value: true });
pow.$pow = void 0;
const core_1$1j = core;
const util_1$1g = util$5;
const $pow = (obj, expr2, options2) => {
  const args2 = (0, core_1$1j.computeValue)(obj, expr2, null, options2);
  (0, util_1$1g.assert)((0, util_1$1g.isArray)(args2) && args2.length === 2 && args2.every(util_1$1g.isNumber), "$pow expression must resolve to array(2) of numbers");
  (0, util_1$1g.assert)(!(args2[0] === 0 && args2[1] < 0), "$pow cannot raise 0 to a negative exponent");
  return Math.pow(args2[0], args2[1]);
};
pow.$pow = $pow;
var round = {};
var _internal$3 = {};
Object.defineProperty(_internal$3, "__esModule", { value: true });
_internal$3.truncate = void 0;
function truncate(num, places, roundOff) {
  const sign = Math.abs(num) === num ? 1 : -1;
  num = Math.abs(num);
  let result = Math.trunc(num);
  const decimals = parseFloat((num - result).toFixed(places + 1));
  if (places === 0) {
    const firstDigit = Math.trunc(10 * decimals);
    if (roundOff && ((result & 1) === 1 && firstDigit >= 5 || firstDigit > 5)) {
      result++;
    }
  } else if (places > 0) {
    const offset = Math.pow(10, places);
    let remainder = Math.trunc(decimals * offset);
    const lastDigit = Math.trunc(decimals * offset * 10) % 10;
    if (roundOff && lastDigit > 5) {
      remainder += 1;
    }
    result = (result * offset + remainder) / offset;
  } else if (places < 0) {
    const offset = Math.pow(10, -1 * places);
    let excess = result % offset;
    result = Math.max(0, result - excess);
    if (roundOff && sign === -1) {
      while (excess > 10) {
        excess -= excess % 10;
      }
      if (result > 0 && excess >= 5) {
        result += offset;
      }
    }
  }
  return result * sign;
}
_internal$3.truncate = truncate;
Object.defineProperty(round, "__esModule", { value: true });
round.$round = void 0;
const core_1$1i = core;
const util_1$1f = util$5;
const _internal_1$J = _internal$3;
const $round = (obj, expr2, options2) => {
  const args2 = (0, core_1$1i.computeValue)(obj, expr2, null, options2);
  const num = args2[0];
  const place = args2[1];
  if ((0, util_1$1f.isNil)(num) || isNaN(num) || Math.abs(num) === Infinity)
    return num;
  (0, util_1$1f.assert)((0, util_1$1f.isNumber)(num), "$round expression must resolve to a number.");
  return (0, _internal_1$J.truncate)(num, place, true);
};
round.$round = $round;
var sqrt = {};
Object.defineProperty(sqrt, "__esModule", { value: true });
sqrt.$sqrt = void 0;
const core_1$1h = core;
const util_1$1e = util$5;
const $sqrt = (obj, expr2, options2) => {
  const n = (0, core_1$1h.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1e.isNil)(n))
    return null;
  (0, util_1$1e.assert)((0, util_1$1e.isNumber)(n) && n > 0 || isNaN(n), "$sqrt expression must resolve to non-negative number.");
  return Math.sqrt(n);
};
sqrt.$sqrt = $sqrt;
var subtract = {};
Object.defineProperty(subtract, "__esModule", { value: true });
subtract.$subtract = void 0;
const core_1$1g = core;
const $subtract = (obj, expr2, options2) => {
  const args2 = (0, core_1$1g.computeValue)(obj, expr2, null, options2);
  return args2[0] - args2[1];
};
subtract.$subtract = $subtract;
var trunc = {};
Object.defineProperty(trunc, "__esModule", { value: true });
trunc.$trunc = void 0;
const core_1$1f = core;
const util_1$1d = util$5;
const _internal_1$I = _internal$3;
const $trunc = (obj, expr2, options2) => {
  const arr2 = (0, core_1$1f.computeValue)(obj, expr2, null, options2);
  const num = arr2[0];
  const places = arr2[1];
  if ((0, util_1$1d.isNil)(num) || isNaN(num) || Math.abs(num) === Infinity)
    return num;
  (0, util_1$1d.assert)((0, util_1$1d.isNumber)(num), "$trunc expression must resolve to a number.");
  (0, util_1$1d.assert)((0, util_1$1d.isNil)(places) || (0, util_1$1d.isNumber)(places) && places > -20 && places < 100, "$trunc expression has invalid place");
  return (0, _internal_1$I.truncate)(num, places, false);
};
trunc.$trunc = $trunc;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(abs, exports);
  __exportStar(add$1, exports);
  __exportStar(ceil, exports);
  __exportStar(divide, exports);
  __exportStar(exp, exports);
  __exportStar(floor, exports);
  __exportStar(ln, exports);
  __exportStar(log, exports);
  __exportStar(log10, exports);
  __exportStar(mod$1, exports);
  __exportStar(multiply, exports);
  __exportStar(pow, exports);
  __exportStar(round, exports);
  __exportStar(sqrt, exports);
  __exportStar(subtract, exports);
  __exportStar(trunc, exports);
})(arithmetic);
var array$1 = {};
var arrayElemAt = {};
Object.defineProperty(arrayElemAt, "__esModule", { value: true });
arrayElemAt.$arrayElemAt = void 0;
const core_1$1e = core;
const util_1$1c = util$5;
const $arrayElemAt = (obj, expr2, options2) => {
  const args2 = (0, core_1$1e.computeValue)(obj, expr2, null, options2);
  (0, util_1$1c.assert)(args2 instanceof Array && args2.length === 2, "$arrayElemAt expression must resolve to array(2)");
  if (args2.some(util_1$1c.isNil))
    return null;
  const index = args2[1];
  const arr2 = args2[0];
  if (index < 0 && Math.abs(index) <= arr2.length) {
    return arr2[(index + arr2.length) % arr2.length];
  } else if (index >= 0 && index < arr2.length) {
    return arr2[index];
  }
  return void 0;
};
arrayElemAt.$arrayElemAt = $arrayElemAt;
var arrayToObject = {};
Object.defineProperty(arrayToObject, "__esModule", { value: true });
arrayToObject.$arrayToObject = void 0;
const core_1$1d = core;
const util_1$1b = util$5;
const $arrayToObject = (obj, expr2, options2) => {
  const arr2 = (0, core_1$1d.computeValue)(obj, expr2, null, options2);
  (0, util_1$1b.assert)((0, util_1$1b.isArray)(arr2), "$arrayToObject expression must resolve to an array");
  return arr2.reduce((newObj, val) => {
    while ((0, util_1$1b.isArray)(val) && val.length === 1)
      val = val[0];
    if (val instanceof Array && val.length == 2) {
      newObj[val[0]] = val[1];
    } else {
      const valObj = val;
      (0, util_1$1b.assert)((0, util_1$1b.isObject)(valObj) && (0, util_1$1b.has)(valObj, "k") && (0, util_1$1b.has)(valObj, "v"), "$arrayToObject expression is invalid.");
      newObj[valObj.k] = valObj.v;
    }
    return newObj;
  }, {});
};
arrayToObject.$arrayToObject = $arrayToObject;
var concatArrays = {};
Object.defineProperty(concatArrays, "__esModule", { value: true });
concatArrays.$concatArrays = void 0;
const core_1$1c = core;
const util_1$1a = util$5;
const $concatArrays = (obj, expr2, options2) => {
  const arr2 = (0, core_1$1c.computeValue)(obj, expr2, null, options2);
  (0, util_1$1a.assert)((0, util_1$1a.isArray)(arr2), "$concatArrays must resolve to an array");
  if (arr2.some(util_1$1a.isNil))
    return null;
  return arr2.reduce((acc, item) => (0, util_1$1a.into)(acc, item), []);
};
concatArrays.$concatArrays = $concatArrays;
var filter = {};
Object.defineProperty(filter, "__esModule", { value: true });
filter.$filter = void 0;
const core_1$1b = core;
const util_1$19 = util$5;
const $filter = (obj, expr2, options2) => {
  const input = (0, core_1$1b.computeValue)(obj, expr2.input, null, options2);
  (0, util_1$19.assert)((0, util_1$19.isArray)(input), "$filter 'input' expression must resolve to an array");
  const copts = core_1$1b.ComputeOptions.init(options2, obj);
  const k = expr2.as || "this";
  const local = {
    variables: { [k]: null }
  };
  return input.filter((o) => {
    local.variables[k] = o;
    const b = (0, core_1$1b.computeValue)(obj, expr2.cond, null, copts.update(copts.root, local));
    return (0, util_1$19.truthy)(b, options2.useStrictMode);
  });
};
filter.$filter = $filter;
var first = {};
Object.defineProperty(first, "__esModule", { value: true });
first.$first = void 0;
const core_1$1a = core;
const util_1$18 = util$5;
const accumulator_1$1 = accumulator$1;
const $first = (obj, expr2, options2) => {
  const copts = core_1$1a.ComputeOptions.init(options2);
  if (obj instanceof Array)
    return (0, accumulator_1$1.$first)(obj, expr2, copts.update());
  const arr2 = (0, core_1$1a.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$18.isNil)(arr2))
    return null;
  (0, util_1$18.assert)((0, util_1$18.isArray)(arr2), "Must resolve to an array/null or missing");
  return (0, accumulator_1$1.$first)(arr2, "$$this", options2);
};
first.$first = $first;
var firstN = {};
Object.defineProperty(firstN, "__esModule", { value: true });
firstN.$firstN = void 0;
const core_1$19 = core;
const util_1$17 = util$5;
const firstN_1 = firstN$1;
const $firstN = (obj, expr2, options2) => {
  if (obj instanceof Array)
    return (0, firstN_1.$firstN)(obj, expr2, options2);
  const { input, n } = (0, core_1$19.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$17.isNil)(input))
    return null;
  (0, util_1$17.assert)((0, util_1$17.isArray)(input), "Must resolve to an array/null or missing");
  return (0, firstN_1.$firstN)(input, { n, input: "$$this" }, options2);
};
firstN.$firstN = $firstN;
var _in$1 = {};
Object.defineProperty(_in$1, "__esModule", { value: true });
_in$1.$in = void 0;
const core_1$18 = core;
const util_1$16 = util$5;
const $in$1 = (obj, expr2, options2) => {
  const [item, arr2] = (0, core_1$18.computeValue)(obj, expr2, null, options2);
  (0, util_1$16.assert)((0, util_1$16.isArray)(arr2), "$in second argument must be an array");
  return arr2.some(util_1$16.isEqual.bind(null, item));
};
_in$1.$in = $in$1;
var indexOfArray = {};
Object.defineProperty(indexOfArray, "__esModule", { value: true });
indexOfArray.$indexOfArray = void 0;
const core_1$17 = core;
const util_1$15 = util$5;
const $indexOfArray = (obj, expr2, options2) => {
  const args2 = (0, core_1$17.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$15.isNil)(args2))
    return null;
  let arr2 = args2[0];
  const searchValue = args2[1];
  if ((0, util_1$15.isNil)(arr2))
    return null;
  (0, util_1$15.assert)((0, util_1$15.isArray)(arr2), "$indexOfArray expression must resolve to an array.");
  const start = args2[2] || 0;
  let end = args2[3];
  if ((0, util_1$15.isNil)(end))
    end = arr2.length;
  if (start > end)
    return -1;
  (0, util_1$15.assert)(start >= 0 && end >= 0, "$indexOfArray expression is invalid");
  if (start > 0 || end < arr2.length) {
    arr2 = arr2.slice(start, end);
  }
  let index = -1;
  arr2.some((v, i) => {
    const b = (0, util_1$15.isEqual)(v, searchValue);
    if (b)
      index = i;
    return b;
  });
  return index + start;
};
indexOfArray.$indexOfArray = $indexOfArray;
var isArray = {};
Object.defineProperty(isArray, "__esModule", { value: true });
isArray.$isArray = void 0;
const core_1$16 = core;
const $isArray = (obj, expr2, options2) => {
  return (0, core_1$16.computeValue)(obj, expr2[0], null, options2) instanceof Array;
};
isArray.$isArray = $isArray;
var last = {};
Object.defineProperty(last, "__esModule", { value: true });
last.$last = void 0;
const core_1$15 = core;
const util_1$14 = util$5;
const accumulator_1 = accumulator$1;
const $last = (obj, expr2, options2) => {
  const copts = core_1$15.ComputeOptions.init(options2);
  if (obj instanceof Array)
    return (0, accumulator_1.$last)(obj, expr2, copts.update());
  const arr2 = (0, core_1$15.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$14.isNil)(arr2))
    return null;
  (0, util_1$14.assert)((0, util_1$14.isArray)(arr2), "Must resolve to an array/null or missing");
  return (0, accumulator_1.$last)(arr2, "$$this", options2);
};
last.$last = $last;
var lastN = {};
Object.defineProperty(lastN, "__esModule", { value: true });
lastN.$lastN = void 0;
const core_1$14 = core;
const util_1$13 = util$5;
const lastN_1 = lastN$1;
const $lastN = (obj, expr2, options2) => {
  if (obj instanceof Array)
    return (0, lastN_1.$lastN)(obj, expr2, options2);
  const { input, n } = (0, core_1$14.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$13.isNil)(input))
    return null;
  (0, util_1$13.assert)((0, util_1$13.isArray)(input), "Must resolve to an array/null or missing");
  return (0, lastN_1.$lastN)(input, { n, input: "$$this" }, options2);
};
lastN.$lastN = $lastN;
var map = {};
Object.defineProperty(map, "__esModule", { value: true });
map.$map = void 0;
const core_1$13 = core;
const util_1$12 = util$5;
const $map = (obj, expr2, options2) => {
  const input = (0, core_1$13.computeValue)(obj, expr2.input, null, options2);
  (0, util_1$12.assert)((0, util_1$12.isArray)(input), `$map 'input' expression must resolve to an array`);
  const copts = core_1$13.ComputeOptions.init(options2);
  const k = expr2.as || "this";
  return input.map((o) => {
    return (0, core_1$13.computeValue)(obj, expr2.in, null, copts.update(copts.root, {
      variables: { [k]: o }
    }));
  });
};
map.$map = $map;
var maxN = {};
Object.defineProperty(maxN, "__esModule", { value: true });
maxN.$maxN = void 0;
const core_1$12 = core;
const util_1$11 = util$5;
const maxN_1 = maxN$1;
const $maxN = (obj, expr2, options2) => {
  if (obj instanceof Array)
    return (0, maxN_1.$maxN)(obj, expr2, options2);
  const { input, n } = (0, core_1$12.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$11.isNil)(input))
    return null;
  (0, util_1$11.assert)((0, util_1$11.isArray)(input), "Must resolve to an array/null or missing");
  return (0, maxN_1.$maxN)(input, { n, input: "$$this" }, options2);
};
maxN.$maxN = $maxN;
var minN = {};
Object.defineProperty(minN, "__esModule", { value: true });
minN.$minN = void 0;
const core_1$11 = core;
const util_1$10 = util$5;
const minN_1 = minN$1;
const $minN = (obj, expr2, options2) => {
  if (obj instanceof Array)
    return (0, minN_1.$minN)(obj, expr2, options2);
  const { input, n } = (0, core_1$11.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$10.isNil)(input))
    return null;
  (0, util_1$10.assert)((0, util_1$10.isArray)(input), "Must resolve to an array/null or missing");
  return (0, minN_1.$minN)(input, { n, input: "$$this" }, options2);
};
minN.$minN = $minN;
var nin$1 = {};
var _predicates = {};
Object.defineProperty(_predicates, "__esModule", { value: true });
_predicates.$type = _predicates.$elemMatch = _predicates.$size = _predicates.$all = _predicates.$exists = _predicates.$regex = _predicates.$mod = _predicates.$gte = _predicates.$gt = _predicates.$lte = _predicates.$lt = _predicates.$nin = _predicates.$in = _predicates.$ne = _predicates.$eq = _predicates.createExpressionOperator = _predicates.createQueryOperator = void 0;
const core_1$10 = core;
const query_1$4 = query;
const util_1$$ = util$5;
function createQueryOperator(predicate) {
  const f = (selector, value, options2) => {
    const opts = { unwrapArray: true };
    const depth = Math.max(1, selector.split(".").length - 1);
    return (obj) => {
      const lhs = (0, util_1$$.resolve)(obj, selector, opts);
      return predicate(lhs, value, Object.assign(Object.assign({}, options2), { depth }));
    };
  };
  f.op = "query";
  return f;
}
_predicates.createQueryOperator = createQueryOperator;
function createExpressionOperator(predicate) {
  return (obj, expr2, options2) => {
    const args2 = (0, core_1$10.computeValue)(obj, expr2, null, options2);
    return predicate(...args2);
  };
}
_predicates.createExpressionOperator = createExpressionOperator;
function $eq(a, b, options2) {
  if ((0, util_1$$.isEqual)(a, b))
    return true;
  if ((0, util_1$$.isNil)(a) && (0, util_1$$.isNil)(b))
    return true;
  if (a instanceof Array) {
    const eq2 = util_1$$.isEqual.bind(null, b);
    return a.some(eq2) || (0, util_1$$.flatten)(a, options2 === null || options2 === void 0 ? void 0 : options2.depth).some(eq2);
  }
  return false;
}
_predicates.$eq = $eq;
function $ne(a, b, options2) {
  return !$eq(a, b, options2);
}
_predicates.$ne = $ne;
function $in(a, b, options2) {
  if ((0, util_1$$.isNil)(a))
    return b.some((v) => v === null);
  return (0, util_1$$.intersection)([(0, util_1$$.ensureArray)(a), b], options2 === null || options2 === void 0 ? void 0 : options2.hashFunction).length > 0;
}
_predicates.$in = $in;
function $nin(a, b, options2) {
  return !$in(a, b, options2);
}
_predicates.$nin = $nin;
function $lt(a, b, options2) {
  return compare(a, b, (x, y) => (0, util_1$$.compare)(x, y) < 0);
}
_predicates.$lt = $lt;
function $lte(a, b, options2) {
  return compare(a, b, (x, y) => (0, util_1$$.compare)(x, y) <= 0);
}
_predicates.$lte = $lte;
function $gt(a, b, options2) {
  return compare(a, b, (x, y) => (0, util_1$$.compare)(x, y) > 0);
}
_predicates.$gt = $gt;
function $gte(a, b, options2) {
  return compare(a, b, (x, y) => (0, util_1$$.compare)(x, y) >= 0);
}
_predicates.$gte = $gte;
function $mod(a, b, options2) {
  return (0, util_1$$.ensureArray)(a).some((x) => b.length === 2 && x % b[0] === b[1]);
}
_predicates.$mod = $mod;
function $regex(a, b, options2) {
  const lhs = (0, util_1$$.ensureArray)(a);
  const match2 = (x) => (0, util_1$$.isString)(x) && (0, util_1$$.truthy)(b.exec(x), options2 === null || options2 === void 0 ? void 0 : options2.useStrictMode);
  return lhs.some(match2) || (0, util_1$$.flatten)(lhs, 1).some(match2);
}
_predicates.$regex = $regex;
function $exists(a, b, options2) {
  return (b === false || b === 0) && a === void 0 || (b === true || b === 1) && a !== void 0;
}
_predicates.$exists = $exists;
function $all(values, queries, options2) {
  if (!(0, util_1$$.isArray)(values) || !(0, util_1$$.isArray)(queries) || !values.length || !queries.length) {
    return false;
  }
  let matched = true;
  for (const query2 of queries) {
    if (!matched)
      break;
    if ((0, util_1$$.isObject)(query2) && (0, util_1$$.inArray)(Object.keys(query2), "$elemMatch")) {
      matched = $elemMatch(values, query2["$elemMatch"], options2);
    } else if (query2 instanceof RegExp) {
      matched = values.some((s) => typeof s === "string" && query2.test(s));
    } else {
      matched = values.some((v) => (0, util_1$$.isEqual)(query2, v));
    }
  }
  return matched;
}
_predicates.$all = $all;
function $size$1(a, b, options2) {
  return Array.isArray(a) && a.length === b;
}
_predicates.$size = $size$1;
function isNonBooleanOperator(name) {
  return (0, util_1$$.isOperator)(name) && ["$and", "$or", "$nor"].indexOf(name) === -1;
}
function $elemMatch(a, b, options2) {
  if ((0, util_1$$.isArray)(a) && !(0, util_1$$.isEmpty)(a)) {
    let format = (x) => x;
    let criteria = b;
    if (Object.keys(b).every(isNonBooleanOperator)) {
      criteria = { temp: b };
      format = (x) => ({ temp: x });
    }
    const query2 = new query_1$4.Query(criteria, options2);
    for (let i = 0, len = a.length; i < len; i++) {
      if (query2.test(format(a[i]))) {
        return true;
      }
    }
  }
  return false;
}
_predicates.$elemMatch = $elemMatch;
const isNull = (a) => a === null;
const isInt = (a) => (0, util_1$$.isNumber)(a) && a >= util_1$$.MIN_INT && a <= util_1$$.MAX_INT && a.toString().indexOf(".") === -1;
const isLong = (a) => (0, util_1$$.isNumber)(a) && a >= util_1$$.MIN_LONG && a <= util_1$$.MAX_LONG && a.toString().indexOf(".") === -1;
const compareFuncs = {
  array: util_1$$.isArray,
  bool: util_1$$.isBoolean,
  boolean: util_1$$.isBoolean,
  date: util_1$$.isDate,
  decimal: util_1$$.isNumber,
  double: util_1$$.isNumber,
  int: isInt,
  long: isLong,
  number: util_1$$.isNumber,
  null: isNull,
  object: util_1$$.isObject,
  regex: util_1$$.isRegExp,
  regexp: util_1$$.isRegExp,
  string: util_1$$.isString,
  // added for completeness
  undefined: util_1$$.isNil,
  function: (_) => {
    throw new Error("unsupported type key `function`.");
  },
  // Mongo identifiers
  1: util_1$$.isNumber,
  2: util_1$$.isString,
  3: util_1$$.isObject,
  4: util_1$$.isArray,
  6: util_1$$.isNil,
  8: util_1$$.isBoolean,
  9: util_1$$.isDate,
  10: isNull,
  11: util_1$$.isRegExp,
  16: isInt,
  18: isLong,
  19: util_1$$.isNumber
  //decimal
};
function compareType(a, b, _) {
  const f = compareFuncs[b];
  return f ? f(a) : false;
}
function $type$1(a, b, options2) {
  return Array.isArray(b) ? b.findIndex((t) => compareType(a, t)) >= 0 : compareType(a, b);
}
_predicates.$type = $type$1;
function compare(a, b, f) {
  return (0, util_1$$.ensureArray)(a).some((x) => (0, util_1$$.getType)(x) === (0, util_1$$.getType)(b) && f(x, b));
}
Object.defineProperty(nin$1, "__esModule", { value: true });
nin$1.$nin = void 0;
const _predicates_1$l = _predicates;
nin$1.$nin = (0, _predicates_1$l.createExpressionOperator)(_predicates_1$l.$nin);
var range = {};
Object.defineProperty(range, "__esModule", { value: true });
range.$range = void 0;
const core_1$$ = core;
const $range = (obj, expr2, options2) => {
  const arr2 = (0, core_1$$.computeValue)(obj, expr2, null, options2);
  const start = arr2[0];
  const end = arr2[1];
  const step = arr2[2] || 1;
  const result = new Array();
  let counter = start;
  while (counter < end && step > 0 || counter > end && step < 0) {
    result.push(counter);
    counter += step;
  }
  return result;
};
range.$range = $range;
var reduce = {};
Object.defineProperty(reduce, "__esModule", { value: true });
reduce.$reduce = void 0;
const core_1$_ = core;
const util_1$_ = util$5;
const $reduce = (obj, expr2, options2) => {
  const copts = core_1$_.ComputeOptions.init(options2);
  const input = (0, core_1$_.computeValue)(obj, expr2.input, null, copts);
  const initialValue = (0, core_1$_.computeValue)(obj, expr2.initialValue, null, copts);
  const inExpr = expr2["in"];
  if ((0, util_1$_.isNil)(input))
    return null;
  (0, util_1$_.assert)((0, util_1$_.isArray)(input), "$reduce 'input' expression must resolve to an array");
  return input.reduce((acc, n) => {
    return (0, core_1$_.computeValue)(n, inExpr, null, copts.update(copts.root, {
      variables: { value: acc }
    }));
  }, initialValue);
};
reduce.$reduce = $reduce;
var reverseArray = {};
Object.defineProperty(reverseArray, "__esModule", { value: true });
reverseArray.$reverseArray = void 0;
const core_1$Z = core;
const util_1$Z = util$5;
const $reverseArray = (obj, expr2, options2) => {
  const arr2 = (0, core_1$Z.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$Z.isNil)(arr2))
    return null;
  (0, util_1$Z.assert)((0, util_1$Z.isArray)(arr2), "$reverseArray expression must resolve to an array");
  const result = arr2.slice(0);
  result.reverse();
  return result;
};
reverseArray.$reverseArray = $reverseArray;
var size$1 = {};
Object.defineProperty(size$1, "__esModule", { value: true });
size$1.$size = void 0;
const core_1$Y = core;
const util_1$Y = util$5;
const $size = (obj, expr2, options2) => {
  const value = (0, core_1$Y.computeValue)(obj, expr2, null, options2);
  return (0, util_1$Y.isArray)(value) ? value.length : void 0;
};
size$1.$size = $size;
var slice = {};
Object.defineProperty(slice, "__esModule", { value: true });
slice.$slice = void 0;
const core_1$X = core;
const util_1$X = util$5;
const $slice = (obj, expr2, options2) => {
  const args2 = (0, core_1$X.computeValue)(obj, expr2, null, options2);
  const arr2 = args2[0];
  let skip2 = args2[1];
  let limit2 = args2[2];
  if ((0, util_1$X.isNil)(limit2)) {
    if (skip2 < 0) {
      skip2 = Math.max(0, arr2.length + skip2);
      limit2 = arr2.length - skip2 + 1;
    } else {
      limit2 = skip2;
      skip2 = 0;
    }
  } else {
    if (skip2 < 0) {
      skip2 = Math.max(0, arr2.length + skip2);
    }
    (0, util_1$X.assert)(limit2 > 0, `Invalid argument for $slice operator. Limit must be a positive number`);
    limit2 += skip2;
  }
  return arr2.slice(skip2, limit2);
};
slice.$slice = $slice;
var sortArray = {};
Object.defineProperty(sortArray, "__esModule", { value: true });
sortArray.$sortArray = void 0;
const aggregator_1$2 = aggregator;
const core_1$W = core;
const util_1$W = util$5;
const $sortArray = (obj, expr2, options2) => {
  const { input, sortBy } = (0, core_1$W.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$W.isNil)(input))
    return null;
  (0, util_1$W.assert)((0, util_1$W.isArray)(input), "$sortArray expression must resolve to an array");
  if ((0, util_1$W.isObject)(sortBy)) {
    return new aggregator_1$2.Aggregator([{ $sort: sortBy }]).run(input);
  }
  const result = [...input];
  result.sort(util_1$W.compare);
  if (sortBy === -1)
    result.reverse();
  return result;
};
sortArray.$sortArray = $sortArray;
var zip = {};
Object.defineProperty(zip, "__esModule", { value: true });
zip.$zip = void 0;
const core_1$V = core;
const util_1$V = util$5;
const $zip = (obj, expr2, options2) => {
  const inputs = (0, core_1$V.computeValue)(obj, expr2.inputs, null, options2);
  const useLongestLength = expr2.useLongestLength || false;
  (0, util_1$V.assert)((0, util_1$V.isArray)(inputs), "'inputs' expression must resolve to an array");
  (0, util_1$V.assert)((0, util_1$V.isBoolean)(useLongestLength), "'useLongestLength' must be a boolean");
  if ((0, util_1$V.isArray)(expr2.defaults)) {
    (0, util_1$V.assert)(useLongestLength, "'useLongestLength' must be set to true to use 'defaults'");
  }
  let zipCount = 0;
  for (let i = 0, len = inputs.length; i < len; i++) {
    const arr2 = inputs[i];
    if ((0, util_1$V.isNil)(arr2))
      return null;
    (0, util_1$V.assert)((0, util_1$V.isArray)(arr2), "'inputs' expression values must resolve to an array or null");
    zipCount = useLongestLength ? Math.max(zipCount, arr2.length) : Math.min(zipCount || arr2.length, arr2.length);
  }
  const result = [];
  const defaults2 = expr2.defaults || [];
  for (let i = 0; i < zipCount; i++) {
    const temp = inputs.map((val, index) => {
      return (0, util_1$V.isNil)(val[i]) ? defaults2[index] || null : val[i];
    });
    result.push(temp);
  }
  return result;
};
zip.$zip = $zip;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(arrayElemAt, exports);
  __exportStar(arrayToObject, exports);
  __exportStar(concatArrays, exports);
  __exportStar(filter, exports);
  __exportStar(first, exports);
  __exportStar(firstN, exports);
  __exportStar(_in$1, exports);
  __exportStar(indexOfArray, exports);
  __exportStar(isArray, exports);
  __exportStar(last, exports);
  __exportStar(lastN, exports);
  __exportStar(map, exports);
  __exportStar(maxN, exports);
  __exportStar(minN, exports);
  __exportStar(nin$1, exports);
  __exportStar(range, exports);
  __exportStar(reduce, exports);
  __exportStar(reverseArray, exports);
  __exportStar(size$1, exports);
  __exportStar(slice, exports);
  __exportStar(sortArray, exports);
  __exportStar(zip, exports);
})(array$1);
var boolean = {};
var and$1 = {};
Object.defineProperty(and$1, "__esModule", { value: true });
and$1.$and = void 0;
const core_1$U = core;
const util_1$U = util$5;
const $and$1 = (obj, expr2, options2) => {
  const value = (0, core_1$U.computeValue)(obj, expr2, null, options2);
  return (0, util_1$U.truthy)(value, options2.useStrictMode) && value.every((v) => (0, util_1$U.truthy)(v, options2.useStrictMode));
};
and$1.$and = $and$1;
var not$1 = {};
Object.defineProperty(not$1, "__esModule", { value: true });
not$1.$not = void 0;
const core_1$T = core;
const util_1$T = util$5;
const $not$1 = (obj, expr2, options2) => {
  const booleanExpr = (0, util_1$T.ensureArray)(expr2);
  if (booleanExpr.length == 0)
    return false;
  if (booleanExpr.length == 1)
    return !(0, core_1$T.computeValue)(obj, booleanExpr[0], null, options2);
  throw "Expression $not takes exactly 1 argument";
};
not$1.$not = $not$1;
var or$1 = {};
Object.defineProperty(or$1, "__esModule", { value: true });
or$1.$or = void 0;
const core_1$S = core;
const util_1$S = util$5;
const $or$1 = (obj, expr2, options2) => {
  const value = (0, core_1$S.computeValue)(obj, expr2, null, options2);
  const strict = options2.useStrictMode;
  return (0, util_1$S.truthy)(value, strict) && value.some((v) => (0, util_1$S.truthy)(v, strict));
};
or$1.$or = $or$1;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(and$1, exports);
  __exportStar(not$1, exports);
  __exportStar(or$1, exports);
})(boolean);
var comparison$1 = {};
var cmp$1 = {};
Object.defineProperty(cmp$1, "__esModule", { value: true });
cmp$1.$cmp = void 0;
const core_1$R = core;
const $cmp = (obj, expr2, options2) => {
  const args2 = (0, core_1$R.computeValue)(obj, expr2, null, options2);
  if (args2[0] > args2[1])
    return 1;
  if (args2[0] < args2[1])
    return -1;
  return 0;
};
cmp$1.$cmp = $cmp;
var eq$1 = {};
Object.defineProperty(eq$1, "__esModule", { value: true });
eq$1.$eq = void 0;
const _predicates_1$k = _predicates;
eq$1.$eq = (0, _predicates_1$k.createExpressionOperator)(_predicates_1$k.$eq);
var gt$1 = {};
Object.defineProperty(gt$1, "__esModule", { value: true });
gt$1.$gt = void 0;
const _predicates_1$j = _predicates;
gt$1.$gt = (0, _predicates_1$j.createExpressionOperator)(_predicates_1$j.$gt);
var gte$1 = {};
Object.defineProperty(gte$1, "__esModule", { value: true });
gte$1.$gte = void 0;
const _predicates_1$i = _predicates;
gte$1.$gte = (0, _predicates_1$i.createExpressionOperator)(_predicates_1$i.$gte);
var lt$1 = {};
Object.defineProperty(lt$1, "__esModule", { value: true });
lt$1.$lt = void 0;
const _predicates_1$h = _predicates;
lt$1.$lt = (0, _predicates_1$h.createExpressionOperator)(_predicates_1$h.$lt);
var lte$1 = {};
Object.defineProperty(lte$1, "__esModule", { value: true });
lte$1.$lte = void 0;
const _predicates_1$g = _predicates;
lte$1.$lte = (0, _predicates_1$g.createExpressionOperator)(_predicates_1$g.$lte);
var ne$1 = {};
Object.defineProperty(ne$1, "__esModule", { value: true });
ne$1.$ne = void 0;
const _predicates_1$f = _predicates;
ne$1.$ne = (0, _predicates_1$f.createExpressionOperator)(_predicates_1$f.$ne);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(cmp$1, exports);
  __exportStar(eq$1, exports);
  __exportStar(gt$1, exports);
  __exportStar(gte$1, exports);
  __exportStar(lt$1, exports);
  __exportStar(lte$1, exports);
  __exportStar(ne$1, exports);
})(comparison$1);
var conditional = {};
var cond = {};
Object.defineProperty(cond, "__esModule", { value: true });
cond.$cond = void 0;
const core_1$Q = core;
const util_1$R = util$5;
const $cond = (obj, expr2, options2) => {
  let ifExpr;
  let thenExpr;
  let elseExpr;
  const errorMsg = "$cond: invalid arguments";
  if (expr2 instanceof Array) {
    (0, util_1$R.assert)(expr2.length === 3, errorMsg);
    ifExpr = expr2[0];
    thenExpr = expr2[1];
    elseExpr = expr2[2];
  } else {
    (0, util_1$R.assert)((0, util_1$R.isObject)(expr2), errorMsg);
    ifExpr = expr2.if;
    thenExpr = expr2.then;
    elseExpr = expr2.else;
  }
  const condition = (0, util_1$R.truthy)((0, core_1$Q.computeValue)(obj, ifExpr, null, options2), options2.useStrictMode);
  return (0, core_1$Q.computeValue)(obj, condition ? thenExpr : elseExpr, null, options2);
};
cond.$cond = $cond;
var _switch = {};
Object.defineProperty(_switch, "__esModule", { value: true });
_switch.$switch = void 0;
const core_1$P = core;
const util_1$Q = util$5;
const $switch = (obj, expr2, options2) => {
  let thenExpr = null;
  expr2.branches.some((b) => {
    const condition = (0, util_1$Q.truthy)((0, core_1$P.computeValue)(obj, b.case, null, options2), options2.useStrictMode);
    if (condition)
      thenExpr = b.then;
    return condition;
  });
  return (0, core_1$P.computeValue)(obj, thenExpr !== null ? thenExpr : expr2.default, null, options2);
};
_switch.$switch = $switch;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(cond, exports);
  __exportStar(ifNull, exports);
  __exportStar(_switch, exports);
})(conditional);
var custom = {};
var _function = {};
Object.defineProperty(_function, "__esModule", { value: true });
_function.$function = void 0;
const core_1$O = core;
const util_1$P = util$5;
const $function = (obj, expr2, options2) => {
  (0, util_1$P.assert)(options2.scriptEnabled, "$function operator requires 'scriptEnabled' option to be true");
  const fn = (0, core_1$O.computeValue)(obj, expr2, null, options2);
  return fn.body.apply(null, fn.args);
};
_function.$function = $function;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(_function, exports);
})(custom);
var date = {};
var dateAdd = {};
Object.defineProperty(dateAdd, "__esModule", { value: true });
dateAdd.$dateAdd = void 0;
const core_1$N = core;
const _internal_1$H = _internal$5;
const $dateAdd = (obj, expr2, options2) => {
  const args2 = (0, core_1$N.computeValue)(obj, expr2, null, options2);
  const d = (0, _internal_1$H.computeDate)(obj, expr2.startDate, options2);
  switch (args2.unit) {
    case "year":
      d.setUTCFullYear(d.getUTCFullYear() + args2.amount);
      break;
    case "quarter":
      addMonth(d, 3 * args2.amount);
      break;
    case "month":
      addMonth(d, args2.amount);
      break;
    default:
      d.setTime(d.getTime() + _internal_1$H.DURATION_IN_MILLIS[args2.unit] * args2.amount);
  }
  if (args2.timezone) {
    const tz = (0, _internal_1$H.parseTimezone)(args2.timezone);
    (0, _internal_1$H.adjustDate)(d, tz);
  }
  return d;
};
dateAdd.$dateAdd = $dateAdd;
function addMonth(d, amount) {
  const m = d.getUTCMonth() + amount;
  const yearOffset = Math.floor(m / 12);
  if (m < 0) {
    const month2 = m % 12 + 12;
    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, month2, d.getUTCDate());
  } else {
    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, m % 12, d.getUTCDate());
  }
}
var dateDiff = {};
Object.defineProperty(dateDiff, "__esModule", { value: true });
dateDiff.$dateDiff = void 0;
const core_1$M = core;
const _internal_1$G = _internal$5;
const $dateDiff = (obj, expr2, options2) => {
  const args2 = (0, core_1$M.computeValue)(obj, expr2, null, options2);
  const d1 = (0, _internal_1$G.computeDate)(obj, expr2.startDate, options2);
  const d2 = (0, _internal_1$G.computeDate)(obj, expr2.endDate, options2);
  let diff2;
  switch (args2.unit) {
    case "year":
    case "quarter":
    case "month":
      diff2 = diffYQM(d1, d2, args2.unit);
      break;
    default:
      diff2 = (d2.getTime() - d1.getTime()) / _internal_1$G.DURATION_IN_MILLIS[args2.unit];
  }
  return diff2;
};
dateDiff.$dateDiff = $dateDiff;
const unitMonths = {
  year: 12,
  quarter: 3,
  month: 1
};
function diffYQM(d1, d2, unit) {
  let months = (d2.getUTCFullYear() - d1.getUTCFullYear()) * 12;
  months -= d1.getUTCMonth();
  months += d2.getUTCMonth();
  return Math.trunc(months / unitMonths[unit]);
}
var dateFromParts = {};
Object.defineProperty(dateFromParts, "__esModule", { value: true });
dateFromParts.$dateFromParts = void 0;
const core_1$L = core;
const _internal_1$F = _internal$5;
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const getDaysInMonth = (date2) => {
  return date2.month == 2 && (0, _internal_1$F.isLeapYear)(date2.year) ? 29 : DAYS_IN_MONTH[date2.month - 1];
};
const $dateFromParts = (obj, expr2, options2) => {
  const args2 = (0, core_1$L.computeValue)(obj, expr2, null, options2);
  const minuteOffset = (0, _internal_1$F.parseTimezone)(args2.timezone);
  for (let i = _internal_1$F.DATE_PART_INTERVAL.length - 1, remainder = 0; i >= 0; i--) {
    const datePartInterval = _internal_1$F.DATE_PART_INTERVAL[i];
    const k = datePartInterval[0];
    const min2 = datePartInterval[1];
    const max2 = datePartInterval[2];
    let part = (args2[k] || 0) + remainder;
    remainder = 0;
    const limit2 = max2 + 1;
    if (k == "hour")
      part += Math.floor(minuteOffset / _internal_1$F.MINUTES_PER_HOUR) * -1;
    if (k == "minute")
      part += minuteOffset % _internal_1$F.MINUTES_PER_HOUR * -1;
    if (part < min2) {
      const delta = min2 - part;
      remainder = -1 * Math.ceil(delta / limit2);
      part = limit2 - delta % limit2;
    } else if (part > max2) {
      part += min2;
      remainder = Math.trunc(part / limit2);
      part %= limit2;
    }
    args2[k] = part;
  }
  args2.day = Math.min(args2.day, getDaysInMonth(args2));
  return new Date(Date.UTC(args2.year, args2.month - 1, args2.day, args2.hour, args2.minute, args2.second, args2.millisecond));
};
dateFromParts.$dateFromParts = $dateFromParts;
var dateFromString = {};
Object.defineProperty(dateFromString, "__esModule", { value: true });
dateFromString.$dateFromString = void 0;
const core_1$K = core;
const util_1$O = util$5;
const _internal_1$E = _internal$5;
const buildMap = (letters, sign) => {
  const h = {};
  letters.split("").forEach((v, i) => h[v] = sign * (i + 1));
  return h;
};
const TZ_LETTER_OFFSETS = Object.assign(Object.assign(Object.assign({}, buildMap("ABCDEFGHIKLM", 1)), buildMap("NOPQRSTUVWXY", -1)), { Z: 0 });
const $dateFromString = (obj, expr2, options2) => {
  const args2 = (0, core_1$K.computeValue)(obj, expr2, null, options2);
  args2.format = args2.format || _internal_1$E.DATE_FORMAT;
  args2.onNull = args2.onNull || null;
  let dateString = args2.dateString;
  if ((0, util_1$O.isNil)(dateString))
    return args2.onNull;
  const separators = args2.format.split(/%[YGmdHMSLuVzZ]/);
  separators.reverse();
  const matches = args2.format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%V|%z|%Z)/g);
  const dateParts = {};
  let expectedPattern = "";
  for (let i = 0, len = matches.length; i < len; i++) {
    const formatSpecifier = matches[i];
    const props2 = _internal_1$E.DATE_SYM_TABLE[formatSpecifier];
    if ((0, util_1$O.isObject)(props2)) {
      const m2 = props2.re.exec(dateString);
      const delimiter = separators.pop() || "";
      if (m2 !== null) {
        dateParts[props2.name] = /^\d+$/.exec(m2[0]) ? parseInt(m2[0]) : m2[0];
        dateString = dateString.substr(0, m2.index) + dateString.substr(m2.index + m2[0].length);
        expectedPattern += (0, _internal_1$E.regexQuote)(delimiter) + (0, _internal_1$E.regexStrip)(props2.re.toString());
      } else {
        dateParts[props2.name] = null;
      }
    }
  }
  if ((0, util_1$O.isNil)(dateParts.year) || (0, util_1$O.isNil)(dateParts.month) || (0, util_1$O.isNil)(dateParts.day) || !new RegExp("^" + expectedPattern + "[A-Z]?$").exec(args2.dateString)) {
    return args2.onError;
  }
  const m = args2.dateString.match(/([A-Z])$/);
  (0, util_1$O.assert)(
    // only one of in-date timeone or timezone argument but not both.
    !(m && args2.timezone),
    `$dateFromString: you cannot pass in a date/time string with time zone information ('${m && m[0]}') together with a timezone argument`
  );
  const minuteOffset = m ? TZ_LETTER_OFFSETS[m[0]] * _internal_1$E.MINUTES_PER_HOUR : (0, _internal_1$E.parseTimezone)(args2.timezone);
  const d = new Date(Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day, 0, 0, 0));
  if (!(0, util_1$O.isNil)(dateParts.hour))
    d.setUTCHours(dateParts.hour);
  if (!(0, util_1$O.isNil)(dateParts.minute))
    d.setUTCMinutes(dateParts.minute);
  if (!(0, util_1$O.isNil)(dateParts.second))
    d.setUTCSeconds(dateParts.second);
  if (!(0, util_1$O.isNil)(dateParts.millisecond))
    d.setUTCMilliseconds(dateParts.millisecond);
  (0, _internal_1$E.adjustDate)(d, -minuteOffset);
  return d;
};
dateFromString.$dateFromString = $dateFromString;
var dateSubtract = {};
Object.defineProperty(dateSubtract, "__esModule", { value: true });
dateSubtract.$dateSubtract = void 0;
const core_1$J = core;
const dateAdd_1$1 = dateAdd;
const $dateSubtract = (obj, expr2, options2) => {
  const amount = (0, core_1$J.computeValue)(obj, expr2 === null || expr2 === void 0 ? void 0 : expr2.amount, null, options2);
  return (0, dateAdd_1$1.$dateAdd)(obj, Object.assign(Object.assign({}, expr2), { amount: -1 * amount }), options2);
};
dateSubtract.$dateSubtract = $dateSubtract;
var dateToParts = {};
Object.defineProperty(dateToParts, "__esModule", { value: true });
dateToParts.$dateToParts = void 0;
const core_1$I = core;
const _internal_1$D = _internal$5;
const $dateToParts = (obj, expr2, options2) => {
  const args2 = (0, core_1$I.computeValue)(obj, expr2, null, options2);
  const d = new Date(args2.date);
  const tz = (0, _internal_1$D.parseTimezone)(args2.timezone);
  (0, _internal_1$D.adjustDate)(d, tz);
  const timePart = {
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
  if (args2.iso8601 == true) {
    return Object.assign(timePart, {
      isoWeekYear: (0, _internal_1$D.isoWeekYear)(d),
      isoWeek: (0, _internal_1$D.isoWeek)(d),
      isoDayOfWeek: d.getUTCDay() || 7
    });
  }
  return Object.assign(timePart, {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate()
  });
};
dateToParts.$dateToParts = $dateToParts;
var dateToString = {};
var dayOfMonth = {};
Object.defineProperty(dayOfMonth, "__esModule", { value: true });
dayOfMonth.$dayOfMonth = void 0;
const _internal_1$C = _internal$5;
const $dayOfMonth = (obj, expr2, options2) => {
  return (0, _internal_1$C.computeDate)(obj, expr2, options2).getUTCDate();
};
dayOfMonth.$dayOfMonth = $dayOfMonth;
var hour = {};
Object.defineProperty(hour, "__esModule", { value: true });
hour.$hour = void 0;
const _internal_1$B = _internal$5;
const $hour = (obj, expr2, options2) => {
  return (0, _internal_1$B.computeDate)(obj, expr2, options2).getUTCHours();
};
hour.$hour = $hour;
var isoDayOfWeek = {};
Object.defineProperty(isoDayOfWeek, "__esModule", { value: true });
isoDayOfWeek.$isoDayOfWeek = void 0;
const _internal_1$A = _internal$5;
const $isoDayOfWeek = (obj, expr2, options2) => {
  return (0, _internal_1$A.computeDate)(obj, expr2, options2).getUTCDay() || 7;
};
isoDayOfWeek.$isoDayOfWeek = $isoDayOfWeek;
var isoWeek = {};
Object.defineProperty(isoWeek, "__esModule", { value: true });
isoWeek.$isoWeek = void 0;
const _internal_1$z = _internal$5;
const $isoWeek = (obj, expr2, options2) => {
  return (0, _internal_1$z.isoWeek)((0, _internal_1$z.computeDate)(obj, expr2, options2));
};
isoWeek.$isoWeek = $isoWeek;
var millisecond = {};
Object.defineProperty(millisecond, "__esModule", { value: true });
millisecond.$millisecond = void 0;
const _internal_1$y = _internal$5;
const $millisecond = (obj, expr2, options2) => {
  return (0, _internal_1$y.computeDate)(obj, expr2, options2).getUTCMilliseconds();
};
millisecond.$millisecond = $millisecond;
var minute = {};
Object.defineProperty(minute, "__esModule", { value: true });
minute.$minute = void 0;
const _internal_1$x = _internal$5;
const $minute = (obj, expr2, options2) => {
  return (0, _internal_1$x.computeDate)(obj, expr2, options2).getUTCMinutes();
};
minute.$minute = $minute;
var month = {};
Object.defineProperty(month, "__esModule", { value: true });
month.$month = void 0;
const _internal_1$w = _internal$5;
const $month = (obj, expr2, options2) => {
  return (0, _internal_1$w.computeDate)(obj, expr2, options2).getUTCMonth() + 1;
};
month.$month = $month;
var second = {};
Object.defineProperty(second, "__esModule", { value: true });
second.$second = void 0;
const _internal_1$v = _internal$5;
const $second = (obj, expr2, options2) => {
  return (0, _internal_1$v.computeDate)(obj, expr2, options2).getUTCSeconds();
};
second.$second = $second;
var week = {};
Object.defineProperty(week, "__esModule", { value: true });
week.$week = void 0;
const _internal_1$u = _internal$5;
const $week = (obj, expr2, options2) => {
  const d = (0, _internal_1$u.computeDate)(obj, expr2, options2);
  const result = (0, _internal_1$u.isoWeek)(d);
  if (d.getUTCDay() > 0 && d.getUTCDate() == 1 && d.getUTCMonth() == 0)
    return 0;
  if (d.getUTCDay() == 0)
    return result + 1;
  return result;
};
week.$week = $week;
var year = {};
Object.defineProperty(year, "__esModule", { value: true });
year.$year = void 0;
const _internal_1$t = _internal$5;
const $year = (obj, expr2, options2) => {
  return (0, _internal_1$t.computeDate)(obj, expr2, options2).getUTCFullYear();
};
year.$year = $year;
Object.defineProperty(dateToString, "__esModule", { value: true });
dateToString.$dateToString = void 0;
const core_1$H = core;
const util_1$N = util$5;
const _internal_1$s = _internal$5;
const dayOfMonth_1 = dayOfMonth;
const hour_1 = hour;
const isoDayOfWeek_1 = isoDayOfWeek;
const isoWeek_1 = isoWeek;
const millisecond_1 = millisecond;
const minute_1 = minute;
const month_1 = month;
const second_1 = second;
const week_1 = week;
const year_1 = year;
const DATE_FUNCTIONS = {
  "%Y": year_1.$year,
  "%G": year_1.$year,
  "%m": month_1.$month,
  "%d": dayOfMonth_1.$dayOfMonth,
  "%H": hour_1.$hour,
  "%M": minute_1.$minute,
  "%S": second_1.$second,
  "%L": millisecond_1.$millisecond,
  "%u": isoDayOfWeek_1.$isoDayOfWeek,
  "%U": week_1.$week,
  "%V": isoWeek_1.$isoWeek
};
const $dateToString = (obj, expr2, options2) => {
  const args2 = (0, core_1$H.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$N.isNil)(args2.onNull))
    args2.onNull = null;
  if ((0, util_1$N.isNil)(args2.date))
    return args2.onNull;
  const date2 = (0, _internal_1$s.computeDate)(obj, args2.date, options2);
  let format = args2.format || _internal_1$s.DATE_FORMAT;
  const minuteOffset = (0, _internal_1$s.parseTimezone)(args2.timezone);
  const matches = format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%U|%V|%z|%Z)/g);
  (0, _internal_1$s.adjustDate)(date2, minuteOffset);
  for (let i = 0, len = matches.length; i < len; i++) {
    const formatSpecifier = matches[i];
    const props2 = _internal_1$s.DATE_SYM_TABLE[formatSpecifier];
    const operatorFn = DATE_FUNCTIONS[formatSpecifier];
    let value;
    if ((0, util_1$N.isObject)(props2)) {
      if (props2.name === "timezone") {
        value = (0, _internal_1$s.formatTimezone)(minuteOffset);
      } else if (props2.name === "minuteOffset") {
        value = minuteOffset.toString();
      } else {
        (0, util_1$N.assert)(!!operatorFn, `unsupported date format specifier '${formatSpecifier}'`);
        value = (0, _internal_1$s.padDigits)(operatorFn(obj, date2, options2), props2.padding);
      }
    }
    format = format.replace(formatSpecifier, value);
  }
  return format;
};
dateToString.$dateToString = $dateToString;
var dayOfWeek = {};
Object.defineProperty(dayOfWeek, "__esModule", { value: true });
dayOfWeek.$dayOfWeek = void 0;
const _internal_1$r = _internal$5;
const $dayOfWeek = (obj, expr2, options2) => {
  return (0, _internal_1$r.computeDate)(obj, expr2, options2).getUTCDay() + 1;
};
dayOfWeek.$dayOfWeek = $dayOfWeek;
var dayOfYear = {};
Object.defineProperty(dayOfYear, "__esModule", { value: true });
dayOfYear.$dayOfYear = void 0;
const _internal_1$q = _internal$5;
const $dayOfYear = (obj, expr2, options2) => {
  return (0, _internal_1$q.getDayOfYear)((0, _internal_1$q.computeDate)(obj, expr2, options2));
};
dayOfYear.$dayOfYear = $dayOfYear;
var isoWeekYear = {};
Object.defineProperty(isoWeekYear, "__esModule", { value: true });
isoWeekYear.$isoWeekYear = void 0;
const _internal_1$p = _internal$5;
const $isoWeekYear = (obj, expr2, options2) => {
  const d = (0, _internal_1$p.computeDate)(obj, expr2, options2);
  return d.getUTCFullYear() - Number(d.getUTCMonth() == 0 && d.getUTCDate() == 1 && d.getUTCDay() < 1);
};
isoWeekYear.$isoWeekYear = $isoWeekYear;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(dateAdd, exports);
  __exportStar(dateDiff, exports);
  __exportStar(dateFromParts, exports);
  __exportStar(dateFromString, exports);
  __exportStar(dateSubtract, exports);
  __exportStar(dateToParts, exports);
  __exportStar(dateToString, exports);
  __exportStar(dayOfMonth, exports);
  __exportStar(dayOfWeek, exports);
  __exportStar(dayOfYear, exports);
  __exportStar(hour, exports);
  __exportStar(isoDayOfWeek, exports);
  __exportStar(isoWeek, exports);
  __exportStar(isoWeekYear, exports);
  __exportStar(millisecond, exports);
  __exportStar(minute, exports);
  __exportStar(month, exports);
  __exportStar(second, exports);
  __exportStar(week, exports);
  __exportStar(year, exports);
})(date);
var literal = {};
Object.defineProperty(literal, "__esModule", { value: true });
literal.$literal = void 0;
const $literal = (_obj, expr2, _options2) => expr2;
literal.$literal = $literal;
var misc = {};
var getField = {};
Object.defineProperty(getField, "__esModule", { value: true });
getField.$getField = void 0;
const core_1$G = core;
const util_1$M = util$5;
const $getField = (obj, expr2, options2) => {
  const args2 = (0, core_1$G.computeValue)(obj, expr2, null, options2);
  let input = obj;
  let field = args2;
  if ((0, util_1$M.isObject)(args2) && args2.input && args2.field) {
    input = args2.input;
    field = args2.field;
  }
  if ((0, util_1$M.isNil)(input))
    return null;
  (0, util_1$M.assert)((0, util_1$M.isObject)(input), "$getField expression 'input' must evaluate to an object");
  (0, util_1$M.assert)((0, util_1$M.isString)(field), "$getField expression 'field' must evaluate to a string");
  return input[field];
};
getField.$getField = $getField;
var rand = {};
Object.defineProperty(rand, "__esModule", { value: true });
rand.$rand = void 0;
const $rand = (_obj, _expr, _options2) => Math.random();
rand.$rand = $rand;
var sampleRate = {};
Object.defineProperty(sampleRate, "__esModule", { value: true });
sampleRate.$sampleRate = void 0;
const core_1$F = core;
const $sampleRate = (obj, expr2, options2) => Math.random() <= (0, core_1$F.computeValue)(obj, expr2, null, options2);
sampleRate.$sampleRate = $sampleRate;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(getField, exports);
  __exportStar(rand, exports);
  __exportStar(sampleRate, exports);
})(misc);
var object = {};
var objectToArray = {};
Object.defineProperty(objectToArray, "__esModule", { value: true });
objectToArray.$objectToArray = void 0;
const core_1$E = core;
const util_1$L = util$5;
const $objectToArray = (obj, expr2, options2) => {
  const val = (0, core_1$E.computeValue)(obj, expr2, null, options2);
  (0, util_1$L.assert)((0, util_1$L.isObject)(val), "$objectToArray expression must resolve to an object");
  const entries2 = Object.entries(val);
  const result = new Array(entries2.length);
  let i = 0;
  for (const [k, v] of entries2) {
    result[i++] = { k, v };
  }
  return result;
};
objectToArray.$objectToArray = $objectToArray;
var setField = {};
Object.defineProperty(setField, "__esModule", { value: true });
setField.$setField = void 0;
const core_1$D = core;
const util_1$K = util$5;
const $setField = (obj, expr2, options2) => {
  const args2 = (0, core_1$D.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$K.isNil)(args2.input))
    return null;
  (0, util_1$K.assert)((0, util_1$K.isObject)(args2.input), "$setField expression 'input' must evaluate to an object");
  (0, util_1$K.assert)((0, util_1$K.isString)(args2.field), "$setField expression 'field' must evaluate to a string");
  if (expr2.value == "$$REMOVE") {
    delete obj[args2.field];
  } else {
    obj[args2.field] = args2.value;
  }
  return obj;
};
setField.$setField = $setField;
var unsetField = {};
Object.defineProperty(unsetField, "__esModule", { value: true });
unsetField.$unsetField = void 0;
const setField_1 = setField;
const $unsetField = (obj, expr2, options2) => {
  return (0, setField_1.$setField)(obj, Object.assign(Object.assign({}, expr2), { value: "$$REMOVE" }), options2);
};
unsetField.$unsetField = $unsetField;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(mergeObjects, exports);
  __exportStar(objectToArray, exports);
  __exportStar(setField, exports);
  __exportStar(unsetField, exports);
})(object);
var set$1 = {};
var allElementsTrue = {};
Object.defineProperty(allElementsTrue, "__esModule", { value: true });
allElementsTrue.$allElementsTrue = void 0;
const core_1$C = core;
const util_1$J = util$5;
const $allElementsTrue = (obj, expr2, options2) => {
  const args2 = (0, core_1$C.computeValue)(obj, expr2, null, options2)[0];
  return args2.every((v) => (0, util_1$J.truthy)(v, options2.useStrictMode));
};
allElementsTrue.$allElementsTrue = $allElementsTrue;
var anyElementTrue = {};
Object.defineProperty(anyElementTrue, "__esModule", { value: true });
anyElementTrue.$anyElementTrue = void 0;
const core_1$B = core;
const util_1$I = util$5;
const $anyElementTrue = (obj, expr2, options2) => {
  const args2 = (0, core_1$B.computeValue)(obj, expr2, null, options2)[0];
  return args2.some((v) => (0, util_1$I.truthy)(v, options2.useStrictMode));
};
anyElementTrue.$anyElementTrue = $anyElementTrue;
var setDifference = {};
Object.defineProperty(setDifference, "__esModule", { value: true });
setDifference.$setDifference = void 0;
const core_1$A = core;
const util_1$H = util$5;
const $setDifference = (obj, expr2, options2) => {
  const args2 = (0, core_1$A.computeValue)(obj, expr2, null, options2);
  return args2[0].filter(util_1$H.notInArray.bind(null, args2[1]));
};
setDifference.$setDifference = $setDifference;
var setEquals = {};
Object.defineProperty(setEquals, "__esModule", { value: true });
setEquals.$setEquals = void 0;
const core_1$z = core;
const util_1$G = util$5;
const $setEquals = (obj, expr2, options2) => {
  const args2 = (0, core_1$z.computeValue)(obj, expr2, null, options2);
  const xs = (0, util_1$G.unique)(args2[0], options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
  const ys = (0, util_1$G.unique)(args2[1], options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
  return xs.length === ys.length && xs.length === (0, util_1$G.intersection)([xs, ys], options2 === null || options2 === void 0 ? void 0 : options2.hashFunction).length;
};
setEquals.$setEquals = $setEquals;
var setIntersection = {};
Object.defineProperty(setIntersection, "__esModule", { value: true });
setIntersection.$setIntersection = void 0;
const core_1$y = core;
const util_1$F = util$5;
const $setIntersection = (obj, expr2, options2) => {
  const args2 = (0, core_1$y.computeValue)(obj, expr2, null, options2);
  (0, util_1$F.assert)((0, util_1$F.isArray)(args2) && args2.every(util_1$F.isArray), "$setIntersection: expresssion must resolve to array of arrays");
  return (0, util_1$F.intersection)(args2, options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
};
setIntersection.$setIntersection = $setIntersection;
var setIsSubset = {};
Object.defineProperty(setIsSubset, "__esModule", { value: true });
setIsSubset.$setIsSubset = void 0;
const core_1$x = core;
const util_1$E = util$5;
const $setIsSubset = (obj, expr2, options2) => {
  const args2 = (0, core_1$x.computeValue)(obj, expr2, null, options2);
  return (0, util_1$E.intersection)(args2, options2 === null || options2 === void 0 ? void 0 : options2.hashFunction).length === args2[0].length;
};
setIsSubset.$setIsSubset = $setIsSubset;
var setUnion = {};
Object.defineProperty(setUnion, "__esModule", { value: true });
setUnion.$setUnion = void 0;
const core_1$w = core;
const util_1$D = util$5;
const $setUnion = (obj, expr2, options2) => {
  const args2 = (0, core_1$w.computeValue)(obj, expr2, null, options2);
  (0, util_1$D.assert)((0, util_1$D.isArray)(args2) && args2.length == 2 && args2.every(util_1$D.isArray), "$setUnion: arguments must be arrays");
  return (0, util_1$D.unique)(args2[0].concat(args2[1]), options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
};
setUnion.$setUnion = $setUnion;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(allElementsTrue, exports);
  __exportStar(anyElementTrue, exports);
  __exportStar(setDifference, exports);
  __exportStar(setEquals, exports);
  __exportStar(setIntersection, exports);
  __exportStar(setIsSubset, exports);
  __exportStar(setUnion, exports);
})(set$1);
var string = {};
var concat = {};
Object.defineProperty(concat, "__esModule", { value: true });
concat.$concat = void 0;
const core_1$v = core;
const util_1$C = util$5;
const $concat = (obj, expr2, options2) => {
  const args2 = (0, core_1$v.computeValue)(obj, expr2, null, options2);
  if ([null, void 0].some(util_1$C.inArray.bind(null, args2)))
    return null;
  return args2.join("");
};
concat.$concat = $concat;
var indexOfBytes = {};
Object.defineProperty(indexOfBytes, "__esModule", { value: true });
indexOfBytes.$indexOfBytes = void 0;
const core_1$u = core;
const util_1$B = util$5;
const $indexOfBytes = (obj, expr2, options2) => {
  const arr2 = (0, core_1$u.computeValue)(obj, expr2, null, options2);
  const errorMsg = "$indexOfBytes expression resolves to invalid an argument";
  if ((0, util_1$B.isNil)(arr2[0]))
    return null;
  (0, util_1$B.assert)((0, util_1$B.isString)(arr2[0]) && (0, util_1$B.isString)(arr2[1]), errorMsg);
  const str = arr2[0];
  const searchStr = arr2[1];
  let start = arr2[2];
  let end = arr2[3];
  let valid = (0, util_1$B.isNil)(start) || (0, util_1$B.isNumber)(start) && start >= 0 && Math.round(start) === start;
  valid = valid && ((0, util_1$B.isNil)(end) || (0, util_1$B.isNumber)(end) && end >= 0 && Math.round(end) === end);
  (0, util_1$B.assert)(valid, errorMsg);
  start = start || 0;
  end = end || str.length;
  if (start > end)
    return -1;
  const index = str.substring(start, end).indexOf(searchStr);
  return index > -1 ? index + start : index;
};
indexOfBytes.$indexOfBytes = $indexOfBytes;
var ltrim = {};
var _internal$2 = {};
Object.defineProperty(_internal$2, "__esModule", { value: true });
_internal$2.regexSearch = _internal$2.trimString = void 0;
const core_1$t = core;
const util_1$A = util$5;
const WHITESPACE_CHARS = [
  0,
  32,
  9,
  10,
  11,
  12,
  13,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202
  // Hair space
];
function trimString(obj, expr2, options2, trimOpts) {
  const val = (0, core_1$t.computeValue)(obj, expr2, null, options2);
  const s = val.input;
  if ((0, util_1$A.isNil)(s))
    return null;
  const codepoints = (0, util_1$A.isNil)(val.chars) ? WHITESPACE_CHARS : val.chars.split("").map((c) => c.codePointAt(0));
  let i = 0;
  let j = s.length - 1;
  while (trimOpts.left && i <= j && codepoints.indexOf(s[i].codePointAt(0)) !== -1)
    i++;
  while (trimOpts.right && i <= j && codepoints.indexOf(s[j].codePointAt(0)) !== -1)
    j--;
  return s.substring(i, j + 1);
}
_internal$2.trimString = trimString;
function regexSearch(obj, expr2, options2, reOpts) {
  const val = (0, core_1$t.computeValue)(obj, expr2, null, options2);
  if (!(0, util_1$A.isString)(val.input))
    return [];
  const regexOptions = val.options;
  if (regexOptions) {
    (0, util_1$A.assert)(regexOptions.indexOf("x") === -1, "extended capability option 'x' not supported");
    (0, util_1$A.assert)(regexOptions.indexOf("g") === -1, "global option 'g' not supported");
  }
  let input = val.input;
  const re = new RegExp(val.regex, regexOptions);
  let m;
  const matches = new Array();
  let offset = 0;
  while (m = re.exec(input)) {
    const result = {
      match: m[0],
      idx: m.index + offset,
      captures: []
    };
    for (let i = 1; i < m.length; i++)
      result.captures.push(m[i] || null);
    matches.push(result);
    if (!reOpts.global)
      break;
    offset = m.index + m[0].length;
    input = input.substring(offset);
  }
  return matches;
}
_internal$2.regexSearch = regexSearch;
Object.defineProperty(ltrim, "__esModule", { value: true });
ltrim.$ltrim = void 0;
const _internal_1$o = _internal$2;
const $ltrim = (obj, expr2, options2) => {
  return (0, _internal_1$o.trimString)(obj, expr2, options2, { left: true, right: false });
};
ltrim.$ltrim = $ltrim;
var regexFind = {};
Object.defineProperty(regexFind, "__esModule", { value: true });
regexFind.$regexFind = void 0;
const _internal_1$n = _internal$2;
const $regexFind = (obj, expr2, options2) => {
  const result = (0, _internal_1$n.regexSearch)(obj, expr2, options2, { global: false });
  return result && result.length > 0 ? result[0] : null;
};
regexFind.$regexFind = $regexFind;
var regexFindAll = {};
Object.defineProperty(regexFindAll, "__esModule", { value: true });
regexFindAll.$regexFindAll = void 0;
const _internal_1$m = _internal$2;
const $regexFindAll = (obj, expr2, options2) => {
  return (0, _internal_1$m.regexSearch)(obj, expr2, options2, { global: true });
};
regexFindAll.$regexFindAll = $regexFindAll;
var regexMatch = {};
Object.defineProperty(regexMatch, "__esModule", { value: true });
regexMatch.$regexMatch = void 0;
const _internal_1$l = _internal$2;
const $regexMatch = (obj, expr2, options2) => {
  return (0, _internal_1$l.regexSearch)(obj, expr2, options2, { global: false }).length != 0;
};
regexMatch.$regexMatch = $regexMatch;
var replaceAll = {};
Object.defineProperty(replaceAll, "__esModule", { value: true });
replaceAll.$replaceAll = void 0;
const core_1$s = core;
const util_1$z = util$5;
const $replaceAll = (obj, expr2, options2) => {
  const args2 = (0, core_1$s.computeValue)(obj, expr2, null, options2);
  const arr2 = [args2.input, args2.find, args2.replacement];
  if (arr2.some(util_1$z.isNil))
    return null;
  (0, util_1$z.assert)(arr2.every(util_1$z.isString), "$replaceAll expression fields must evaluate to string");
  return args2.input.replace(new RegExp(args2.find, "g"), args2.replacement);
};
replaceAll.$replaceAll = $replaceAll;
var replaceOne = {};
Object.defineProperty(replaceOne, "__esModule", { value: true });
replaceOne.$replaceOne = void 0;
const core_1$r = core;
const util_1$y = util$5;
const $replaceOne = (obj, expr2, options2) => {
  const args2 = (0, core_1$r.computeValue)(obj, expr2, null, options2);
  const arr2 = [args2.input, args2.find, args2.replacement];
  if (arr2.some(util_1$y.isNil))
    return null;
  (0, util_1$y.assert)(arr2.every(util_1$y.isString), "$replaceOne expression fields must evaluate to string");
  return args2.input.replace(args2.find, args2.replacement);
};
replaceOne.$replaceOne = $replaceOne;
var rtrim = {};
Object.defineProperty(rtrim, "__esModule", { value: true });
rtrim.$rtrim = void 0;
const _internal_1$k = _internal$2;
const $rtrim = (obj, expr2, options2) => {
  return (0, _internal_1$k.trimString)(obj, expr2, options2, { left: false, right: true });
};
rtrim.$rtrim = $rtrim;
var split = {};
Object.defineProperty(split, "__esModule", { value: true });
split.$split = void 0;
const core_1$q = core;
const util_1$x = util$5;
const $split = (obj, expr2, options2) => {
  const args2 = (0, core_1$q.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$x.isNil)(args2[0]))
    return null;
  (0, util_1$x.assert)(args2.every(util_1$x.isString), "$split expression must result to array(2) of strings");
  return args2[0].split(args2[1]);
};
split.$split = $split;
var strcasecmp = {};
Object.defineProperty(strcasecmp, "__esModule", { value: true });
strcasecmp.$strcasecmp = void 0;
const core_1$p = core;
const util_1$w = util$5;
const $strcasecmp = (obj, expr2, options2) => {
  const args2 = (0, core_1$p.computeValue)(obj, expr2, null, options2);
  let a = args2[0];
  let b = args2[1];
  if ((0, util_1$w.isEqual)(a, b) || args2.every(util_1$w.isNil))
    return 0;
  (0, util_1$w.assert)(args2.every(util_1$w.isString), "$strcasecmp must resolve to array(2) of strings");
  a = a.toUpperCase();
  b = b.toUpperCase();
  return a > b && 1 || a < b && -1 || 0;
};
strcasecmp.$strcasecmp = $strcasecmp;
var strLenBytes = {};
Object.defineProperty(strLenBytes, "__esModule", { value: true });
strLenBytes.$strLenBytes = void 0;
const core_1$o = core;
const $strLenBytes = (obj, expr2, options2) => {
  return ~-encodeURI((0, core_1$o.computeValue)(obj, expr2, null, options2)).split(/%..|./).length;
};
strLenBytes.$strLenBytes = $strLenBytes;
var strLenCP = {};
Object.defineProperty(strLenCP, "__esModule", { value: true });
strLenCP.$strLenCP = void 0;
const core_1$n = core;
const $strLenCP = (obj, expr2, options2) => {
  return (0, core_1$n.computeValue)(obj, expr2, null, options2).length;
};
strLenCP.$strLenCP = $strLenCP;
var substr = {};
Object.defineProperty(substr, "__esModule", { value: true });
substr.$substr = void 0;
const core_1$m = core;
const util_1$v = util$5;
const $substr = (obj, expr2, options2) => {
  const args2 = (0, core_1$m.computeValue)(obj, expr2, null, options2);
  const s = args2[0];
  const index = args2[1];
  const count2 = args2[2];
  if ((0, util_1$v.isString)(s)) {
    if (index < 0) {
      return "";
    } else if (count2 < 0) {
      return s.substr(index);
    } else {
      return s.substr(index, count2);
    }
  }
  return "";
};
substr.$substr = $substr;
var substrBytes = {};
Object.defineProperty(substrBytes, "__esModule", { value: true });
substrBytes.$substrBytes = void 0;
const core_1$l = core;
const util_1$u = util$5;
const UTF8_MASK = [192, 224, 240];
function toUtf8(n) {
  if (n < 128)
    return [n];
  let count2 = n < 2048 && 1 || n < 65536 && 2 || 3;
  const offset = UTF8_MASK[count2 - 1];
  const utf8 = [(n >> 6 * count2) + offset];
  while (count2 > 0)
    utf8.push(128 | n >> 6 * --count2 & 63);
  return utf8;
}
function utf8Encode(s) {
  const buf = [];
  for (let i = 0, len = s.length; i < len; i++) {
    buf.push(toUtf8(s.codePointAt(i)));
  }
  return buf;
}
const $substrBytes = (obj, expr2, options2) => {
  const args2 = (0, core_1$l.computeValue)(obj, expr2, null, options2);
  const s = args2[0];
  const index = args2[1];
  const count2 = args2[2];
  (0, util_1$u.assert)((0, util_1$u.isString)(s) && (0, util_1$u.isNumber)(index) && index >= 0 && (0, util_1$u.isNumber)(count2) && count2 >= 0, "$substrBytes: invalid arguments");
  const buf = utf8Encode(s);
  const validIndex = [];
  let acc = 0;
  for (let i = 0; i < buf.length; i++) {
    validIndex.push(acc);
    acc += buf[i].length;
  }
  const begin = validIndex.indexOf(index);
  const end = validIndex.indexOf(index + count2);
  (0, util_1$u.assert)(begin > -1 && end > -1, "$substrBytes: invalid range, start or end index is a UTF-8 continuation byte.");
  return s.substring(begin, end);
};
substrBytes.$substrBytes = $substrBytes;
var substrCP = {};
Object.defineProperty(substrCP, "__esModule", { value: true });
substrCP.$substrCP = void 0;
const substr_1 = substr;
const $substrCP = (obj, expr2, options2) => {
  return (0, substr_1.$substr)(obj, expr2, options2);
};
substrCP.$substrCP = $substrCP;
var toLower = {};
Object.defineProperty(toLower, "__esModule", { value: true });
toLower.$toLower = void 0;
const core_1$k = core;
const util_1$t = util$5;
const $toLower = (obj, expr2, options2) => {
  const value = (0, core_1$k.computeValue)(obj, expr2, null, options2);
  return (0, util_1$t.isEmpty)(value) ? "" : value.toLowerCase();
};
toLower.$toLower = $toLower;
var toUpper = {};
Object.defineProperty(toUpper, "__esModule", { value: true });
toUpper.$toUpper = void 0;
const core_1$j = core;
const util_1$s = util$5;
const $toUpper = (obj, expr2, options2) => {
  const value = (0, core_1$j.computeValue)(obj, expr2, null, options2);
  return (0, util_1$s.isEmpty)(value) ? "" : value.toUpperCase();
};
toUpper.$toUpper = $toUpper;
var trim = {};
Object.defineProperty(trim, "__esModule", { value: true });
trim.$trim = void 0;
const _internal_1$j = _internal$2;
const $trim = (obj, expr2, options2) => {
  return (0, _internal_1$j.trimString)(obj, expr2, options2, { left: true, right: true });
};
trim.$trim = $trim;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(concat, exports);
  __exportStar(indexOfBytes, exports);
  __exportStar(ltrim, exports);
  __exportStar(regexFind, exports);
  __exportStar(regexFindAll, exports);
  __exportStar(regexMatch, exports);
  __exportStar(replaceAll, exports);
  __exportStar(replaceOne, exports);
  __exportStar(rtrim, exports);
  __exportStar(split, exports);
  __exportStar(strcasecmp, exports);
  __exportStar(strLenBytes, exports);
  __exportStar(strLenCP, exports);
  __exportStar(substr, exports);
  __exportStar(substrBytes, exports);
  __exportStar(substrCP, exports);
  __exportStar(toLower, exports);
  __exportStar(toUpper, exports);
  __exportStar(trim, exports);
})(string);
var trignometry = {};
var acos = {};
var _internal$1 = {};
Object.defineProperty(_internal$1, "__esModule", { value: true });
_internal$1.createTrignometryOperator = void 0;
const core_1$i = core;
const FIXED_POINTS = {
  undefined: null,
  null: null,
  NaN: NaN,
  Infinity: new Error(),
  "-Infinity": new Error()
};
function createTrignometryOperator(f, fixedPoints = FIXED_POINTS) {
  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);
  const keySet = new Set(Object.keys(fp));
  return (obj, expr2, options2) => {
    const n = (0, core_1$i.computeValue)(obj, expr2, null, options2);
    if (keySet.has(`${n}`)) {
      const res = fp[`${n}`];
      if (res instanceof Error) {
        throw new Error(`cannot apply $${f.name} to -inf, value must in (-inf,inf)`);
      }
      return res;
    }
    return f(n);
  };
}
_internal$1.createTrignometryOperator = createTrignometryOperator;
Object.defineProperty(acos, "__esModule", { value: true });
acos.$acos = void 0;
const _internal_1$i = _internal$1;
acos.$acos = (0, _internal_1$i.createTrignometryOperator)(Math.acos, {
  Infinity: Infinity,
  0: new Error()
});
var acosh = {};
Object.defineProperty(acosh, "__esModule", { value: true });
acosh.$acosh = void 0;
const _internal_1$h = _internal$1;
acosh.$acosh = (0, _internal_1$h.createTrignometryOperator)(Math.acosh, {
  Infinity: Infinity,
  0: new Error()
});
var asin = {};
Object.defineProperty(asin, "__esModule", { value: true });
asin.$asin = void 0;
const _internal_1$g = _internal$1;
asin.$asin = (0, _internal_1$g.createTrignometryOperator)(Math.asin);
var asinh = {};
Object.defineProperty(asinh, "__esModule", { value: true });
asinh.$asinh = void 0;
const _internal_1$f = _internal$1;
asinh.$asinh = (0, _internal_1$f.createTrignometryOperator)(Math.asinh, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});
var atan = {};
Object.defineProperty(atan, "__esModule", { value: true });
atan.$atan = void 0;
const _internal_1$e = _internal$1;
atan.$atan = (0, _internal_1$e.createTrignometryOperator)(Math.atan);
var atan2 = {};
Object.defineProperty(atan2, "__esModule", { value: true });
atan2.$atan2 = void 0;
const core_1$h = core;
const util_1$r = util$5;
const $atan2 = (obj, expr2, options2) => {
  const [y, x] = (0, core_1$h.computeValue)(obj, expr2, null, options2);
  if (isNaN(y) || (0, util_1$r.isNil)(y))
    return y;
  if (isNaN(x) || (0, util_1$r.isNil)(x))
    return x;
  return Math.atan2(y, x);
};
atan2.$atan2 = $atan2;
var atanh = {};
Object.defineProperty(atanh, "__esModule", { value: true });
atanh.$atanh = void 0;
const _internal_1$d = _internal$1;
atanh.$atanh = (0, _internal_1$d.createTrignometryOperator)(Math.atanh, {
  1: Infinity,
  "-1": -Infinity
});
var cos = {};
Object.defineProperty(cos, "__esModule", { value: true });
cos.$cos = void 0;
const _internal_1$c = _internal$1;
cos.$cos = (0, _internal_1$c.createTrignometryOperator)(Math.cos);
var cosh = {};
Object.defineProperty(cosh, "__esModule", { value: true });
cosh.$cosh = void 0;
const _internal_1$b = _internal$1;
cosh.$cosh = (0, _internal_1$b.createTrignometryOperator)(Math.cosh, {
  "-Infinity": Infinity,
  Infinity: Infinity
  // [Math.PI]: -1,
});
var degreesToRadians = {};
Object.defineProperty(degreesToRadians, "__esModule", { value: true });
degreesToRadians.$degreesToRadians = void 0;
const _internal_1$a = _internal$1;
const RADIANS_FACTOR = Math.PI / 180;
degreesToRadians.$degreesToRadians = (0, _internal_1$a.createTrignometryOperator)((n) => n * RADIANS_FACTOR, {
  Infinity: Infinity,
  "-Infinity": Infinity
});
var radiansToDegrees = {};
Object.defineProperty(radiansToDegrees, "__esModule", { value: true });
radiansToDegrees.$radiansToDegrees = void 0;
const _internal_1$9 = _internal$1;
const DEGREES_FACTOR = 180 / Math.PI;
radiansToDegrees.$radiansToDegrees = (0, _internal_1$9.createTrignometryOperator)((n) => n * DEGREES_FACTOR, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});
var sin = {};
Object.defineProperty(sin, "__esModule", { value: true });
sin.$sin = void 0;
const _internal_1$8 = _internal$1;
sin.$sin = (0, _internal_1$8.createTrignometryOperator)(Math.sin);
var sinh = {};
Object.defineProperty(sinh, "__esModule", { value: true });
sinh.$sinh = void 0;
const _internal_1$7 = _internal$1;
sinh.$sinh = (0, _internal_1$7.createTrignometryOperator)(Math.sinh, {
  "-Infinity": -Infinity,
  Infinity: Infinity
});
var tan = {};
Object.defineProperty(tan, "__esModule", { value: true });
tan.$tan = void 0;
const _internal_1$6 = _internal$1;
tan.$tan = (0, _internal_1$6.createTrignometryOperator)(Math.tan);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(acos, exports);
  __exportStar(acosh, exports);
  __exportStar(asin, exports);
  __exportStar(asinh, exports);
  __exportStar(atan, exports);
  __exportStar(atan2, exports);
  __exportStar(atanh, exports);
  __exportStar(cos, exports);
  __exportStar(cosh, exports);
  __exportStar(degreesToRadians, exports);
  __exportStar(radiansToDegrees, exports);
  __exportStar(sin, exports);
  __exportStar(sinh, exports);
  __exportStar(tan, exports);
})(trignometry);
var type$7 = {};
var convert = {};
var _internal = {};
Object.defineProperty(_internal, "__esModule", { value: true });
_internal.toInteger = _internal.TypeConvertError = void 0;
const core_1$g = core;
const util_1$q = util$5;
class TypeConvertError extends Error {
  constructor(message) {
    super(message);
  }
}
_internal.TypeConvertError = TypeConvertError;
function toInteger(obj, expr2, options2, max2, min2, typename) {
  const val = (0, core_1$g.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$q.isNil)(val))
    return null;
  if (val instanceof Date)
    return val.getTime();
  if (val === true)
    return 1;
  if (val === false)
    return 0;
  const n = Number(val);
  if ((0, util_1$q.isNumber)(n) && n >= min2 && n <= max2) {
    if (!(0, util_1$q.isString)(val) || n.toString().indexOf(".") === -1) {
      return Math.trunc(n);
    }
  }
  throw new TypeConvertError(`cannot convert '${val}' to ${typename}`);
}
_internal.toInteger = toInteger;
var toBool = {};
Object.defineProperty(toBool, "__esModule", { value: true });
toBool.$toBool = void 0;
const core_1$f = core;
const util_1$p = util$5;
const $toBool = (obj, expr2, options2) => {
  const val = (0, core_1$f.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$p.isNil)(val))
    return null;
  if ((0, util_1$p.isString)(val))
    return true;
  return Boolean(val);
};
toBool.$toBool = $toBool;
var toDate = {};
Object.defineProperty(toDate, "__esModule", { value: true });
toDate.$toDate = void 0;
const core_1$e = core;
const util_1$o = util$5;
const _internal_1$5 = _internal;
const $toDate = (obj, expr2, options2) => {
  const val = (0, core_1$e.computeValue)(obj, expr2, null, options2);
  if (val instanceof Date)
    return val;
  if ((0, util_1$o.isNil)(val))
    return null;
  const d = new Date(val);
  const n = d.getTime();
  if (!isNaN(n))
    return d;
  throw new _internal_1$5.TypeConvertError(`cannot convert '${val}' to date`);
};
toDate.$toDate = $toDate;
var toDouble = {};
Object.defineProperty(toDouble, "__esModule", { value: true });
toDouble.$toDouble = void 0;
const core_1$d = core;
const util_1$n = util$5;
const _internal_1$4 = _internal;
const $toDouble = (obj, expr2, options2) => {
  const val = (0, core_1$d.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$n.isNil)(val))
    return null;
  if (val instanceof Date)
    return val.getTime();
  if (val === true)
    return 1;
  if (val === false)
    return 0;
  const n = Number(val);
  if ((0, util_1$n.isNumber)(n))
    return n;
  throw new _internal_1$4.TypeConvertError(`cannot convert '${val}' to double/decimal`);
};
toDouble.$toDouble = $toDouble;
var toInt = {};
Object.defineProperty(toInt, "__esModule", { value: true });
toInt.$toInt = void 0;
const util_1$m = util$5;
const _internal_1$3 = _internal;
const $toInt = (obj, expr2, options2) => {
  return (0, _internal_1$3.toInteger)(obj, expr2, options2, util_1$m.MAX_INT, util_1$m.MIN_INT, "int");
};
toInt.$toInt = $toInt;
var toLong = {};
Object.defineProperty(toLong, "__esModule", { value: true });
toLong.$toLong = void 0;
const util_1$l = util$5;
const _internal_1$2 = _internal;
const $toLong = (obj, expr2, options2) => {
  return (0, _internal_1$2.toInteger)(obj, expr2, options2, util_1$l.MAX_LONG, util_1$l.MIN_LONG, "long");
};
toLong.$toLong = $toLong;
var toString = {};
Object.defineProperty(toString, "__esModule", { value: true });
toString.$toString = void 0;
const core_1$c = core;
const util_1$k = util$5;
const dateToString_1 = dateToString;
const $toString = (obj, expr2, options2) => {
  const val = (0, core_1$c.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$k.isNil)(val))
    return null;
  if (val instanceof Date) {
    const dateExpr = {
      date: expr2,
      format: "%Y-%m-%dT%H:%M:%S.%LZ"
    };
    return (0, dateToString_1.$dateToString)(obj, dateExpr, options2);
  } else {
    return val.toString();
  }
};
toString.$toString = $toString;
Object.defineProperty(convert, "__esModule", { value: true });
convert.$convert = void 0;
const core_1$b = core;
const util_1$j = util$5;
const _internal_1$1 = _internal;
const toBool_1 = toBool;
const toDate_1 = toDate;
const toDouble_1$1 = toDouble;
const toInt_1 = toInt;
const toLong_1 = toLong;
const toString_1 = toString;
const $convert = (obj, expr2, options2) => {
  const args2 = (0, core_1$b.computeValue)(obj, expr2, null, options2);
  args2.onNull = args2.onNull === void 0 ? null : args2.onNull;
  if ((0, util_1$j.isNil)(args2.input))
    return args2.onNull;
  try {
    switch (args2.to) {
      case 2:
      case "string":
        return (0, toString_1.$toString)(obj, args2.input, options2);
      case 8:
      case "boolean":
      case "bool":
        return (0, toBool_1.$toBool)(obj, args2.input, options2);
      case 9:
      case "date":
        return (0, toDate_1.$toDate)(obj, args2.input, options2);
      case 1:
      case 19:
      case "double":
      case "decimal":
      case "number":
        return (0, toDouble_1$1.$toDouble)(obj, args2.input, options2);
      case 16:
      case "int":
        return (0, toInt_1.$toInt)(obj, args2.input, options2);
      case 18:
      case "long":
        return (0, toLong_1.$toLong)(obj, args2.input, options2);
    }
  } catch (e) {
  }
  if (args2.onError !== void 0)
    return args2.onError;
  throw new _internal_1$1.TypeConvertError(`could not convert to type ${args2.to}.`);
};
convert.$convert = $convert;
var isNumber = {};
Object.defineProperty(isNumber, "__esModule", { value: true });
isNumber.$isNumber = void 0;
const core_1$a = core;
const util_1$i = util$5;
const $isNumber = (obj, expr2, options2) => {
  const n = (0, core_1$a.computeValue)(obj, expr2, null, options2);
  return (0, util_1$i.isNumber)(n);
};
isNumber.$isNumber = $isNumber;
var toDecimal = {};
Object.defineProperty(toDecimal, "__esModule", { value: true });
toDecimal.$toDecimal = void 0;
const toDouble_1 = toDouble;
toDecimal.$toDecimal = toDouble_1.$toDouble;
var type$6 = {};
Object.defineProperty(type$6, "__esModule", { value: true });
type$6.$type = void 0;
const core_1$9 = core;
const util_1$h = util$5;
const $type = (obj, expr2, options2) => {
  const val = (0, core_1$9.computeValue)(obj, expr2, null, options2);
  const typename = (0, util_1$h.getType)(val);
  const nativeType = typename.toLowerCase();
  switch (nativeType) {
    case "boolean":
      return "bool";
    case "number":
      if (val.toString().indexOf(".") >= 0)
        return "double";
      return val >= util_1$h.MIN_INT && val <= util_1$h.MAX_INT ? "int" : "long";
    case "regexp":
      return "regex";
    default:
      return nativeType;
  }
};
type$6.$type = $type;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(convert, exports);
  __exportStar(isNumber, exports);
  __exportStar(toBool, exports);
  __exportStar(toDate, exports);
  __exportStar(toDecimal, exports);
  __exportStar(toDouble, exports);
  __exportStar(toInt, exports);
  __exportStar(toLong, exports);
  __exportStar(toString, exports);
  __exportStar(type$6, exports);
})(type$7);
var variable = {};
var _let = {};
Object.defineProperty(_let, "__esModule", { value: true });
_let.$let = void 0;
const core_1$8 = core;
const $let = (obj, expr2, options2) => {
  const variables = {};
  for (const [key, val] of Object.entries(expr2.vars)) {
    variables[key] = (0, core_1$8.computeValue)(obj, val, null, options2);
  }
  return (0, core_1$8.computeValue)(obj, expr2.in, null, core_1$8.ComputeOptions.init(options2, obj, { variables }));
};
_let.$let = $let;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(_let, exports);
})(variable);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(arithmetic, exports);
  __exportStar(array$1, exports);
  __exportStar(boolean, exports);
  __exportStar(comparison$1, exports);
  __exportStar(conditional, exports);
  __exportStar(custom, exports);
  __exportStar(date, exports);
  __exportStar(literal, exports);
  __exportStar(misc, exports);
  __exportStar(object, exports);
  __exportStar(set$1, exports);
  __exportStar(string, exports);
  __exportStar(trignometry, exports);
  __exportStar(type$7, exports);
  __exportStar(variable, exports);
})(expression);
var group = {};
Object.defineProperty(group, "__esModule", { value: true });
group.$group = void 0;
const core_1$7 = core;
const util_1$g = util$5;
const ID_KEY = "_id";
const $group = (collection, expr2, options2) => {
  (0, util_1$g.assert)((0, util_1$g.has)(expr2, ID_KEY), "a group specification must include an _id");
  const idExpr = expr2[ID_KEY];
  const copts = core_1$7.ComputeOptions.init(options2);
  return collection.transform((coll) => {
    const partitions = (0, util_1$g.groupBy)(coll, (obj) => (0, core_1$7.computeValue)(obj, idExpr, null, options2), options2.hashFunction);
    expr2 = Object.assign({}, expr2);
    delete expr2[ID_KEY];
    let i = -1;
    const partitionKeys = Array.from(partitions.keys());
    const size2 = partitions.size;
    return () => {
      if (++i === size2)
        return { done: true };
      const groupId = partitionKeys[i];
      const obj = {};
      if (groupId !== void 0) {
        obj[ID_KEY] = groupId;
      }
      for (const [key, val] of Object.entries(expr2)) {
        obj[key] = (0, core_1$7.computeValue)(partitions.get(groupId), val, key, copts.update(null, { groupId }));
      }
      return { value: obj, done: false };
    };
  });
};
group.$group = $group;
var sort = {};
Object.defineProperty(sort, "__esModule", { value: true });
sort.$sort = void 0;
const util_1$f = util$5;
const $sort = (collection, sortKeys, options2) => {
  if ((0, util_1$f.isEmpty)(sortKeys) || !(0, util_1$f.isObject)(sortKeys))
    return collection;
  let cmp2 = util_1$f.compare;
  const collationSpec = options2.collation;
  if ((0, util_1$f.isObject)(collationSpec) && (0, util_1$f.isString)(collationSpec.locale)) {
    cmp2 = collationComparator(collationSpec);
  }
  return collection.transform((coll) => {
    const modifiers = Object.keys(sortKeys);
    for (const key of modifiers.reverse()) {
      const groups = (0, util_1$f.groupBy)(coll, (obj) => (0, util_1$f.resolve)(obj, key), options2.hashFunction);
      const sortedKeys = Array.from(groups.keys()).sort(cmp2);
      if (sortKeys[key] === -1)
        sortedKeys.reverse();
      coll = [];
      sortedKeys.reduce((acc, key2) => (0, util_1$f.into)(acc, groups.get(key2)), coll);
    }
    return coll;
  });
};
sort.$sort = $sort;
const COLLATION_STRENGTH = {
  // Only strings that differ in base letters compare as unequal. Examples: a ≠ b, a = á, a = A.
  1: "base",
  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.
  // Examples: a ≠ b, a ≠ á, a = A.
  2: "accent",
  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.
  // Other differences may also be taken into consideration. Examples: a ≠ b, a ≠ á, a ≠ A
  3: "variant"
  // case - Only strings that differ in base letters or case compare as unequal. Examples: a ≠ b, a = á, a ≠ A.
};
function collationComparator(spec) {
  const localeOpt = {
    sensitivity: COLLATION_STRENGTH[spec.strength || 3],
    caseFirst: spec.caseFirst === "off" ? "false" : spec.caseFirst || "false",
    numeric: spec.numericOrdering || false,
    ignorePunctuation: spec.alternate === "shifted"
  };
  if ((spec.caseLevel || false) === true) {
    if (localeOpt.sensitivity === "base")
      localeOpt.sensitivity = "case";
    if (localeOpt.sensitivity === "accent")
      localeOpt.sensitivity = "variant";
  }
  const collator = new Intl.Collator(spec.locale, localeOpt);
  return (a, b) => {
    if (!(0, util_1$f.isString)(a) || !(0, util_1$f.isString)(b))
      return (0, util_1$f.compare)(a, b);
    const i = collator.compare(a, b);
    if (i < 0)
      return -1;
    if (i > 0)
      return 1;
    return 0;
  };
}
Object.defineProperty(setWindowFields, "__esModule", { value: true });
setWindowFields.$setWindowFields = void 0;
const core_1$6 = core;
const lazy_1$2 = lazy;
const util_1$e = util$5;
const expression_1$1 = expression;
const dateAdd_1 = dateAdd;
const _internal_1 = _internal$4;
const addFields_1$2 = addFields;
const group_1$1 = group;
const sort_1$1 = sort;
const SORT_REQUIRED_OPS = /* @__PURE__ */ new Set([
  "$denseRank",
  "$documentNumber",
  "$first",
  "$last",
  "$linearFill",
  "$rank",
  "$shift"
]);
const WINDOW_UNBOUNDED_OPS = /* @__PURE__ */ new Set([
  "$denseRank",
  "$expMovingAvg",
  "$linearFill",
  "$locf",
  "$rank",
  "$shift"
]);
const $setWindowFields = (collection, expr2, options2) => {
  options2 = (0, core_1$6.initOptions)(options2);
  options2.context.addExpressionOps({ $function: expression_1$1.$function });
  for (const outputExpr of Object.values(expr2.output)) {
    const keys2 = Object.keys(outputExpr);
    const op = keys2.find(util_1$e.isOperator);
    (0, util_1$e.assert)(!!(0, core_1$6.getOperator)(core_1$6.OperatorType.WINDOW, op, options2) || !!(0, core_1$6.getOperator)(core_1$6.OperatorType.ACCUMULATOR, op, options2), `'${op}' is not a valid window operator`);
    (0, util_1$e.assert)(keys2.length > 0 && keys2.length <= 2 && (keys2.length == 1 || keys2.includes("window")), "'output' option should have a single window operator.");
    if (outputExpr === null || outputExpr === void 0 ? void 0 : outputExpr.window) {
      const { documents, range: range2 } = outputExpr.window;
      (0, util_1$e.assert)(!!documents && !range2 || !documents && !!range2 || !documents && !range2, "'window' option supports only one of 'documents' or 'range'.");
    }
  }
  if (expr2.sortBy) {
    collection = (0, sort_1$1.$sort)(collection, expr2.sortBy, options2);
  }
  collection = (0, group_1$1.$group)(collection, {
    _id: expr2.partitionBy,
    items: { $push: "$$CURRENT" }
  }, options2);
  return collection.transform((partitions) => {
    const iterators = [];
    const outputConfig = [];
    for (const [field, outputExpr] of Object.entries(expr2.output)) {
      const op = Object.keys(outputExpr).find(util_1$e.isOperator);
      const config2 = {
        operatorName: op,
        func: {
          left: (0, core_1$6.getOperator)(core_1$6.OperatorType.ACCUMULATOR, op, options2),
          right: (0, core_1$6.getOperator)(core_1$6.OperatorType.WINDOW, op, options2)
        },
        args: outputExpr[op],
        field,
        window: outputExpr.window
      };
      (0, util_1$e.assert)(!!expr2.sortBy || !(SORT_REQUIRED_OPS.has(op) || !config2.window), `${SORT_REQUIRED_OPS.has(op) ? `'${op}'` : "bounded window operation"} requires a sortBy.`);
      (0, util_1$e.assert)(!config2.window || !WINDOW_UNBOUNDED_OPS.has(op), `${op} does not accept a 'window' field.`);
      outputConfig.push(config2);
    }
    partitions.forEach((group2) => {
      const items = group2.items;
      let iterator2 = (0, lazy_1$2.Lazy)(items);
      const windowResultMap = {};
      for (const config2 of outputConfig) {
        const { func, args: args2, field, window: window2 } = config2;
        const makeResultFunc = (getItemsFn) => {
          let index = -1;
          return (obj) => {
            ++index;
            if (func.left) {
              return func.left(getItemsFn(obj, index), args2, options2);
            } else if (func.right) {
              return func.right(
                obj,
                getItemsFn(obj, index),
                {
                  parentExpr: expr2,
                  inputExpr: args2,
                  documentNumber: index + 1,
                  field
                },
                // must use raw options only since it operates over a collection.
                options2
              );
            }
          };
        };
        if (window2) {
          const { documents, range: range2, unit } = window2;
          const boundary = documents || range2;
          if (!(0, _internal_1.isUnbounded)(window2)) {
            const [begin, end] = boundary;
            const toBeginIndex = (currentIndex) => {
              if (begin == "current")
                return currentIndex;
              if (begin == "unbounded")
                return 0;
              return Math.max(begin + currentIndex, 0);
            };
            const toEndIndex = (currentIndex) => {
              if (end == "current")
                return currentIndex + 1;
              if (end == "unbounded")
                return items.length;
              return end + currentIndex + 1;
            };
            const getItems = (current, index) => {
              if (!!documents || boundary.every(util_1$e.isString)) {
                return items.slice(toBeginIndex(index), toEndIndex(index));
              }
              const sortKey = Object.keys(expr2.sortBy)[0];
              let lower;
              let upper;
              if (unit) {
                const getTime = (amount) => {
                  return (0, dateAdd_1.$dateAdd)(current, {
                    startDate: new Date(current[sortKey]),
                    unit,
                    amount
                  }, options2).getTime();
                };
                lower = (0, util_1$e.isNumber)(begin) ? getTime(begin) : -Infinity;
                upper = (0, util_1$e.isNumber)(end) ? getTime(end) : Infinity;
              } else {
                const currentValue = current[sortKey];
                lower = (0, util_1$e.isNumber)(begin) ? currentValue + begin : -Infinity;
                upper = (0, util_1$e.isNumber)(end) ? currentValue + end : Infinity;
              }
              let array2 = items;
              if (begin == "current")
                array2 = items.slice(index);
              if (end == "current")
                array2 = items.slice(0, index + 1);
              return array2.filter((o) => {
                const value = o[sortKey];
                const n = +value;
                return n >= lower && n <= upper;
              });
            };
            windowResultMap[field] = makeResultFunc(getItems);
          }
        }
        if (!windowResultMap[field]) {
          windowResultMap[field] = makeResultFunc((_) => items);
        }
        iterator2 = (0, addFields_1$2.$addFields)(iterator2, {
          [field]: {
            $function: {
              body: (obj) => windowResultMap[field](obj),
              args: ["$$CURRENT"]
            }
          }
        }, options2);
      }
      iterators.push(iterator2);
    });
    return (0, lazy_1$2.compose)(...iterators);
  });
};
setWindowFields.$setWindowFields = $setWindowFields;
Object.defineProperty(fill, "__esModule", { value: true });
fill.$fill = void 0;
const core_1$5 = core;
const util_1$d = util$5;
const ifNull_1 = ifNull;
const linearFill_1 = linearFill;
const locf_1 = locf;
const addFields_1$1 = addFields;
const setWindowFields_1 = setWindowFields;
const FILL_METHODS = {
  locf: "$locf",
  linear: "$linearFill"
};
const $fill = (collection, expr2, options2) => {
  var _a, _b;
  (0, util_1$d.assert)(!expr2.sortBy || (0, util_1$d.isObject)(expr2.sortBy), "sortBy must be an object.");
  (0, util_1$d.assert)(!!expr2.sortBy || Object.values(expr2.output).every((m) => (0, util_1$d.has)(m, "value")), "sortBy required if any output field specifies a 'method'.");
  (0, util_1$d.assert)(!(expr2.partitionBy && expr2.partitionByFields), "specify either partitionBy or partitionByFields.");
  (0, util_1$d.assert)(!expr2.partitionByFields || ((_a = expr2 === null || expr2 === void 0 ? void 0 : expr2.partitionByFields) === null || _a === void 0 ? void 0 : _a.every((s) => s[0] !== "$")), "fields in partitionByFields cannot begin with '$'.");
  options2 = (0, core_1$5.initOptions)(options2);
  options2.context.addExpressionOps({ $ifNull: ifNull_1.$ifNull });
  options2.context.addWindowOps({ $locf: locf_1.$locf, $linearFill: linearFill_1.$linearFill });
  const partitionExpr = expr2.partitionBy || ((_b = expr2 === null || expr2 === void 0 ? void 0 : expr2.partitionByFields) === null || _b === void 0 ? void 0 : _b.map((s) => `$${s}`));
  const valueExpr = {};
  const methodExpr = {};
  for (const [k, m] of Object.entries(expr2.output)) {
    if ((0, util_1$d.has)(m, "value")) {
      valueExpr[k] = { $ifNull: [`$$CURRENT.${k}`, m["value"]] };
    } else {
      const fillOp = FILL_METHODS[m["method"]];
      (0, util_1$d.assert)(!!fillOp, `invalid fill method '${m["method"]}'.`);
      methodExpr[k] = { [fillOp]: "$" + k };
    }
  }
  if (Object.keys(methodExpr).length > 0) {
    collection = (0, setWindowFields_1.$setWindowFields)(collection, {
      sortBy: expr2.sortBy || {},
      partitionBy: partitionExpr,
      output: methodExpr
    }, options2);
  }
  if (Object.keys(valueExpr).length > 0) {
    collection = (0, addFields_1$1.$addFields)(collection, valueExpr, options2);
  }
  return collection;
};
fill.$fill = $fill;
var limit = {};
Object.defineProperty(limit, "__esModule", { value: true });
limit.$limit = void 0;
const $limit = (collection, expr2, options2) => {
  return collection.take(expr2);
};
limit.$limit = $limit;
var lookup = {};
Object.defineProperty(lookup, "__esModule", { value: true });
lookup.$lookup = void 0;
const util_1$c = util$5;
const $lookup = (collection, expr2, options2) => {
  const joinColl = (0, util_1$c.isString)(expr2.from) ? options2 === null || options2 === void 0 ? void 0 : options2.collectionResolver(expr2.from) : expr2.from;
  (0, util_1$c.assert)(joinColl instanceof Array, `'from' field must resolve to an array`);
  const hash2 = {};
  for (const obj of joinColl) {
    const k = (0, util_1$c.hashCode)((0, util_1$c.resolve)(obj, expr2.foreignField), options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
    hash2[k] = hash2[k] || [];
    hash2[k].push(obj);
  }
  return collection.map((obj) => {
    const k = (0, util_1$c.hashCode)((0, util_1$c.resolve)(obj, expr2.localField), options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
    const newObj = (0, util_1$c.into)({}, obj);
    newObj[expr2.as] = hash2[k] || [];
    return newObj;
  });
};
lookup.$lookup = $lookup;
var match = {};
Object.defineProperty(match, "__esModule", { value: true });
match.$match = void 0;
const query_1$3 = query;
const $match = (collection, expr2, options2) => {
  const q = new query_1$3.Query(expr2, options2);
  return collection.filter((o) => q.test(o));
};
match.$match = $match;
var merge$1 = {};
Object.defineProperty(merge$1, "__esModule", { value: true });
merge$1.$merge = void 0;
const aggregator_1$1 = aggregator;
const core_1$4 = core;
const util_1$b = util$5;
const expression_1 = expression;
const $merge = (collection, expr2, options2) => {
  const output = (0, util_1$b.isString)(expr2.into) ? options2 === null || options2 === void 0 ? void 0 : options2.collectionResolver(expr2.into) : expr2.into;
  (0, util_1$b.assert)(output instanceof Array, `$merge: option 'into' must resolve to an array`);
  const onField = expr2.on || options2.idKey;
  const getHash = (o) => {
    const val = (0, util_1$b.isString)(onField) ? (0, util_1$b.resolve)(o, onField) : onField.map((s) => (0, util_1$b.resolve)(o, s));
    return (0, util_1$b.hashCode)(val, options2.hashFunction);
  };
  const hash2 = {};
  for (let i = 0; i < output.length; i++) {
    const obj = output[i];
    const k = getHash(obj);
    (0, util_1$b.assert)(!hash2[k], "$merge: 'into' collection must have unique entries for the 'on' field.");
    hash2[k] = [obj, i];
  }
  const copts = core_1$4.ComputeOptions.init(options2);
  return collection.map((o) => {
    const k = getHash(o);
    if (hash2[k]) {
      const [target, i] = hash2[k];
      const variables = (0, core_1$4.computeValue)(
        target,
        expr2.let || { new: "$$ROOT" },
        null,
        // 'root' is the item from the iteration.
        copts.update(o)
      );
      if ((0, util_1$b.isArray)(expr2.whenMatched)) {
        const aggregator2 = new aggregator_1$1.Aggregator(expr2.whenMatched, Object.assign(Object.assign({}, options2), { variables }));
        output[i] = aggregator2.run([target])[0];
      } else {
        switch (expr2.whenMatched) {
          case "replace":
            output[i] = o;
            break;
          case "fail":
            throw new Error("$merge: failed due to matching as specified by 'whenMatched' option.");
          case "keepExisting":
            break;
          case "merge":
          default:
            output[i] = (0, expression_1.$mergeObjects)(
              target,
              [target, o],
              // 'root' is the item from the iteration.
              copts.update(o, { variables })
            );
            break;
        }
      }
    } else {
      switch (expr2.whenNotMatched) {
        case "discard":
          break;
        case "fail":
          throw new Error("$merge: failed due to matching as specified by 'whenMatched' option.");
        case "insert":
        default:
          output.push(o);
          break;
      }
    }
    return o;
  });
};
merge$1.$merge = $merge;
var out = {};
Object.defineProperty(out, "__esModule", { value: true });
out.$out = void 0;
const util_1$a = util$5;
const $out = (collection, expr2, options2) => {
  const outputColl = (0, util_1$a.isString)(expr2) ? options2 === null || options2 === void 0 ? void 0 : options2.collectionResolver(expr2) : expr2;
  (0, util_1$a.assert)(outputColl instanceof Array, `expression must resolve to an array`);
  return collection.map((o) => {
    outputColl.push((0, util_1$a.cloneDeep)(o));
    return o;
  });
};
out.$out = $out;
var project = {};
Object.defineProperty(project, "__esModule", { value: true });
project.$project = void 0;
const core_1$3 = core;
const util_1$9 = util$5;
const $project = (collection, expr2, options2) => {
  if ((0, util_1$9.isEmpty)(expr2))
    return collection;
  let expressionKeys = Object.keys(expr2);
  let idOnlyExcluded = false;
  validateExpression(expr2, options2);
  const ID_KEY2 = options2.idKey;
  if ((0, util_1$9.inArray)(expressionKeys, ID_KEY2)) {
    const id = expr2[ID_KEY2];
    if (id === 0 || id === false) {
      expressionKeys = expressionKeys.filter(util_1$9.notInArray.bind(null, [ID_KEY2]));
      idOnlyExcluded = expressionKeys.length == 0;
    }
  } else {
    expressionKeys.push(ID_KEY2);
  }
  const copts = core_1$3.ComputeOptions.init(options2);
  return collection.map((obj) => processObject(obj, expr2, copts.update(obj), expressionKeys, idOnlyExcluded));
};
project.$project = $project;
function processObject(obj, expr2, options2, expressionKeys, idOnlyExcluded) {
  let newObj = {};
  let foundSlice = false;
  let foundExclusion = false;
  const dropKeys = [];
  if (idOnlyExcluded) {
    dropKeys.push(options2.idKey);
  }
  for (const key of expressionKeys) {
    let value = void 0;
    const subExpr = expr2[key];
    if (key !== options2.idKey && (0, util_1$9.inArray)([0, false], subExpr)) {
      foundExclusion = true;
    }
    if (key === options2.idKey && (0, util_1$9.isEmpty)(subExpr)) {
      value = obj[key];
    } else if ((0, util_1$9.isString)(subExpr)) {
      value = (0, core_1$3.computeValue)(obj, subExpr, key, options2);
    } else if ((0, util_1$9.inArray)([1, true], subExpr))
      ;
    else if (subExpr instanceof Array) {
      value = subExpr.map((v) => {
        const r = (0, core_1$3.computeValue)(obj, v, null, options2);
        if ((0, util_1$9.isNil)(r))
          return null;
        return r;
      });
    } else if ((0, util_1$9.isObject)(subExpr)) {
      const subExprObj = subExpr;
      const subExprKeys = Object.keys(subExpr);
      const operator = subExprKeys.length == 1 ? subExprKeys[0] : "";
      const call = (0, core_1$3.getOperator)(core_1$3.OperatorType.PROJECTION, operator, options2);
      if (call) {
        if (operator === "$slice") {
          if ((0, util_1$9.ensureArray)(subExprObj[operator]).every(util_1$9.isNumber)) {
            value = call(obj, subExprObj[operator], key, options2);
            foundSlice = true;
          } else {
            value = (0, core_1$3.computeValue)(obj, subExprObj, key, options2);
          }
        } else {
          value = call(obj, subExprObj[operator], key, options2);
        }
      } else if ((0, util_1$9.isOperator)(operator)) {
        value = (0, core_1$3.computeValue)(obj, subExprObj[operator], operator, options2);
      } else if ((0, util_1$9.has)(obj, key)) {
        validateExpression(subExprObj, options2);
        let target = obj[key];
        if (target instanceof Array) {
          value = target.map((o) => processObject(o, subExprObj, options2, subExprKeys, false));
        } else {
          target = (0, util_1$9.isObject)(target) ? target : obj;
          value = processObject(target, subExprObj, options2, subExprKeys, false);
        }
      } else {
        value = (0, core_1$3.computeValue)(obj, subExpr, null, options2);
      }
    } else {
      dropKeys.push(key);
      continue;
    }
    const objPathGraph = (0, util_1$9.resolveGraph)(obj, key, {
      preserveMissing: true
    });
    if (objPathGraph !== void 0) {
      (0, util_1$9.merge)(newObj, objPathGraph, {
        flatten: true
      });
    }
    if ((0, util_1$9.notInArray)([0, 1, false, true], subExpr)) {
      if (value === void 0) {
        (0, util_1$9.removeValue)(newObj, key, { descendArray: true });
      } else {
        (0, util_1$9.setValue)(newObj, key, value);
      }
    }
  }
  (0, util_1$9.filterMissing)(newObj);
  if (foundSlice || foundExclusion || idOnlyExcluded) {
    newObj = (0, util_1$9.into)({}, obj, newObj);
    if (dropKeys.length > 0) {
      for (const k of dropKeys) {
        (0, util_1$9.removeValue)(newObj, k, { descendArray: true });
      }
    }
  }
  return newObj;
}
function validateExpression(expr2, options2) {
  const check = [false, false];
  for (const [k, v] of Object.entries(expr2)) {
    if (k === (options2 === null || options2 === void 0 ? void 0 : options2.idKey))
      return;
    if (v === 0 || v === false) {
      check[0] = true;
    } else if (v === 1 || v === true) {
      check[1] = true;
    }
    (0, util_1$9.assert)(!(check[0] && check[1]), "Projection cannot have a mix of inclusion and exclusion.");
  }
}
var redact = {};
Object.defineProperty(redact, "__esModule", { value: true });
redact.$redact = void 0;
const core_1$2 = core;
const $redact = (collection, expr2, options2) => {
  const copts = core_1$2.ComputeOptions.init(options2);
  return collection.map((obj) => (0, core_1$2.redact)(obj, expr2, copts.update(obj)));
};
redact.$redact = $redact;
var replaceRoot = {};
Object.defineProperty(replaceRoot, "__esModule", { value: true });
replaceRoot.$replaceRoot = void 0;
const core_1$1 = core;
const util_1$8 = util$5;
const $replaceRoot = (collection, expr2, options2) => {
  return collection.map((obj) => {
    obj = (0, core_1$1.computeValue)(obj, expr2.newRoot, null, options2);
    (0, util_1$8.assert)((0, util_1$8.isObject)(obj), "$replaceRoot expression must return an object");
    return obj;
  });
};
replaceRoot.$replaceRoot = $replaceRoot;
var replaceWith = {};
Object.defineProperty(replaceWith, "__esModule", { value: true });
replaceWith.$replaceWith = void 0;
const replaceRoot_1 = replaceRoot;
replaceWith.$replaceWith = replaceRoot_1.$replaceRoot;
var sample = {};
Object.defineProperty(sample, "__esModule", { value: true });
sample.$sample = void 0;
const $sample = (collection, expr2, _options2) => {
  return collection.transform((xs) => {
    const len = xs.length;
    let i = -1;
    return () => {
      if (++i === expr2.size)
        return { done: true };
      const n = Math.floor(Math.random() * len);
      return { value: xs[n], done: false };
    };
  });
};
sample.$sample = $sample;
var set = {};
Object.defineProperty(set, "__esModule", { value: true });
set.$set = void 0;
const addFields_1 = addFields;
set.$set = addFields_1.$addFields;
var skip = {};
Object.defineProperty(skip, "__esModule", { value: true });
skip.$skip = void 0;
const $skip = (collection, expr2, options2) => {
  return collection.drop(expr2);
};
skip.$skip = $skip;
var sortByCount = {};
Object.defineProperty(sortByCount, "__esModule", { value: true });
sortByCount.$sortByCount = void 0;
const group_1 = group;
const sort_1 = sort;
const $sortByCount = (collection, expr2, options2) => {
  const newExpr = { count: { $sum: 1 } };
  newExpr["_id"] = expr2;
  return (0, sort_1.$sort)((0, group_1.$group)(collection, newExpr, options2), { count: -1 }, options2);
};
sortByCount.$sortByCount = $sortByCount;
var unionWith = {};
Object.defineProperty(unionWith, "__esModule", { value: true });
unionWith.$unionWith = void 0;
const aggregator_1 = aggregator;
const lazy_1$1 = lazy;
const util_1$7 = util$5;
const $unionWith = (collection, expr2, options2) => {
  const array2 = (0, util_1$7.isString)(expr2.coll) ? options2.collectionResolver(expr2.coll) : expr2.coll;
  const iterators = [collection];
  iterators.push(expr2.pipeline ? new aggregator_1.Aggregator(expr2.pipeline, options2).stream(array2) : (0, lazy_1$1.Lazy)(array2));
  return (0, lazy_1$1.compose)(...iterators);
};
unionWith.$unionWith = $unionWith;
var unset = {};
Object.defineProperty(unset, "__esModule", { value: true });
unset.$unset = void 0;
const util_1$6 = util$5;
const project_1 = project;
const $unset = (collection, expr2, options2) => {
  expr2 = (0, util_1$6.ensureArray)(expr2);
  const doc = {};
  for (const k of expr2)
    doc[k] = 0;
  return (0, project_1.$project)(collection, doc, options2);
};
unset.$unset = $unset;
var unwind = {};
Object.defineProperty(unwind, "__esModule", { value: true });
unwind.$unwind = void 0;
const lazy_1 = lazy;
const util_1$5 = util$5;
const $unwind = (collection, expr2, _options2) => {
  if ((0, util_1$5.isString)(expr2))
    expr2 = { path: expr2 };
  const path2 = expr2.path;
  const field = path2.substring(1);
  const includeArrayIndex = (expr2 === null || expr2 === void 0 ? void 0 : expr2.includeArrayIndex) || false;
  const preserveNullAndEmptyArrays = expr2.preserveNullAndEmptyArrays || false;
  const format = (o, i) => {
    if (includeArrayIndex !== false)
      o[includeArrayIndex] = i;
    return o;
  };
  let value;
  return (0, lazy_1.Lazy)(() => {
    for (; ; ) {
      if (value instanceof lazy_1.Iterator) {
        const tmp = value.next();
        if (!tmp.done)
          return tmp;
      }
      const wrapper = collection.next();
      if (wrapper.done)
        return wrapper;
      const obj = wrapper.value;
      value = (0, util_1$5.resolve)(obj, field);
      if (value instanceof Array) {
        if (value.length === 0 && preserveNullAndEmptyArrays === true) {
          value = null;
          (0, util_1$5.removeValue)(obj, field);
          return { value: format(obj, null), done: false };
        } else {
          value = (0, lazy_1.Lazy)(value).map((item, i) => {
            const newObj = (0, util_1$5.resolveGraph)(obj, field, {
              preserveKeys: true
            });
            (0, util_1$5.setValue)(newObj, field, item);
            return format(newObj, i);
          });
        }
      } else if (!(0, util_1$5.isEmpty)(value) || preserveNullAndEmptyArrays === true) {
        return { value: format(obj, null), done: false };
      }
    }
  });
};
unwind.$unwind = $unwind;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(addFields, exports);
  __exportStar(bucket, exports);
  __exportStar(bucketAuto, exports);
  __exportStar(count$1, exports);
  __exportStar(facet, exports);
  __exportStar(fill, exports);
  __exportStar(group, exports);
  __exportStar(limit, exports);
  __exportStar(lookup, exports);
  __exportStar(match, exports);
  __exportStar(merge$1, exports);
  __exportStar(out, exports);
  __exportStar(project, exports);
  __exportStar(redact, exports);
  __exportStar(replaceRoot, exports);
  __exportStar(replaceWith, exports);
  __exportStar(sample, exports);
  __exportStar(set, exports);
  __exportStar(setWindowFields, exports);
  __exportStar(skip, exports);
  __exportStar(sort, exports);
  __exportStar(sortByCount, exports);
  __exportStar(unionWith, exports);
  __exportStar(unset, exports);
  __exportStar(unwind, exports);
})(pipeline);
var logical = {};
var and = {};
Object.defineProperty(and, "__esModule", { value: true });
and.$and = void 0;
const query_1$2 = query;
const util_1$4 = util$5;
const $and = (_, rhs, options2) => {
  (0, util_1$4.assert)((0, util_1$4.isArray)(rhs), "Invalid expression: $and expects value to be an Array.");
  const queries = rhs.map((expr2) => new query_1$2.Query(expr2, options2));
  return (obj) => queries.every((q) => q.test(obj));
};
and.$and = $and;
var nor = {};
var or = {};
Object.defineProperty(or, "__esModule", { value: true });
or.$or = void 0;
const query_1$1 = query;
const util_1$3 = util$5;
const $or = (_, rhs, options2) => {
  (0, util_1$3.assert)((0, util_1$3.isArray)(rhs), "Invalid expression. $or expects value to be an Array");
  const queries = rhs.map((expr2) => new query_1$1.Query(expr2, options2));
  return (obj) => queries.some((q) => q.test(obj));
};
or.$or = $or;
Object.defineProperty(nor, "__esModule", { value: true });
nor.$nor = void 0;
const util_1$2 = util$5;
const or_1 = or;
const $nor = (_, rhs, options2) => {
  (0, util_1$2.assert)((0, util_1$2.isArray)(rhs), "Invalid expression. $nor expects value to be an array.");
  const f = (0, or_1.$or)("$or", rhs, options2);
  return (obj) => !f(obj);
};
nor.$nor = $nor;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
not.$not = void 0;
const query_1 = query;
const util_1$1 = util$5;
const $not = (selector, rhs, options2) => {
  const criteria = {};
  criteria[selector] = (0, util_1$1.normalize)(rhs);
  const query2 = new query_1.Query(criteria, options2);
  return (obj) => !query2.test(obj);
};
not.$not = $not;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(and, exports);
  __exportStar(nor, exports);
  __exportStar(not, exports);
  __exportStar(or, exports);
})(logical);
var comparison = {};
var eq = {};
Object.defineProperty(eq, "__esModule", { value: true });
eq.$eq = void 0;
const _predicates_1$e = _predicates;
eq.$eq = (0, _predicates_1$e.createQueryOperator)(_predicates_1$e.$eq);
var gt = {};
Object.defineProperty(gt, "__esModule", { value: true });
gt.$gt = void 0;
const _predicates_1$d = _predicates;
gt.$gt = (0, _predicates_1$d.createQueryOperator)(_predicates_1$d.$gt);
var gte = {};
Object.defineProperty(gte, "__esModule", { value: true });
gte.$gte = void 0;
const _predicates_1$c = _predicates;
gte.$gte = (0, _predicates_1$c.createQueryOperator)(_predicates_1$c.$gte);
var _in = {};
Object.defineProperty(_in, "__esModule", { value: true });
_in.$in = void 0;
const _predicates_1$b = _predicates;
_in.$in = (0, _predicates_1$b.createQueryOperator)(_predicates_1$b.$in);
var lt = {};
Object.defineProperty(lt, "__esModule", { value: true });
lt.$lt = void 0;
const _predicates_1$a = _predicates;
lt.$lt = (0, _predicates_1$a.createQueryOperator)(_predicates_1$a.$lt);
var lte = {};
Object.defineProperty(lte, "__esModule", { value: true });
lte.$lte = void 0;
const _predicates_1$9 = _predicates;
lte.$lte = (0, _predicates_1$9.createQueryOperator)(_predicates_1$9.$lte);
var ne = {};
Object.defineProperty(ne, "__esModule", { value: true });
ne.$ne = void 0;
const _predicates_1$8 = _predicates;
ne.$ne = (0, _predicates_1$8.createQueryOperator)(_predicates_1$8.$ne);
var nin = {};
Object.defineProperty(nin, "__esModule", { value: true });
nin.$nin = void 0;
const _predicates_1$7 = _predicates;
nin.$nin = (0, _predicates_1$7.createQueryOperator)(_predicates_1$7.$nin);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.$nin = exports.$ne = exports.$lte = exports.$lt = exports.$in = exports.$gte = exports.$gt = exports.$eq = void 0;
  var eq_1 = eq;
  Object.defineProperty(exports, "$eq", { enumerable: true, get: function() {
    return eq_1.$eq;
  } });
  var gt_1 = gt;
  Object.defineProperty(exports, "$gt", { enumerable: true, get: function() {
    return gt_1.$gt;
  } });
  var gte_1 = gte;
  Object.defineProperty(exports, "$gte", { enumerable: true, get: function() {
    return gte_1.$gte;
  } });
  var in_1 = _in;
  Object.defineProperty(exports, "$in", { enumerable: true, get: function() {
    return in_1.$in;
  } });
  var lt_1 = lt;
  Object.defineProperty(exports, "$lt", { enumerable: true, get: function() {
    return lt_1.$lt;
  } });
  var lte_1 = lte;
  Object.defineProperty(exports, "$lte", { enumerable: true, get: function() {
    return lte_1.$lte;
  } });
  var ne_1 = ne;
  Object.defineProperty(exports, "$ne", { enumerable: true, get: function() {
    return ne_1.$ne;
  } });
  var nin_1 = nin;
  Object.defineProperty(exports, "$nin", { enumerable: true, get: function() {
    return nin_1.$nin;
  } });
})(comparison);
var evaluation = {};
var expr = {};
Object.defineProperty(expr, "__esModule", { value: true });
expr.$expr = void 0;
const core_1 = core;
function $expr(_, rhs, options2) {
  return (obj) => (0, core_1.computeValue)(obj, rhs, null, options2);
}
expr.$expr = $expr;
var jsonSchema = {};
Object.defineProperty(jsonSchema, "__esModule", { value: true });
jsonSchema.$jsonSchema = void 0;
function $jsonSchema(_, schema, options2) {
  if (!(options2 === null || options2 === void 0 ? void 0 : options2.jsonSchemaValidator)) {
    throw new Error("Missing option 'jsonSchemaValidator'. Configure to use '$jsonSchema' operator.");
  }
  const validate = options2 === null || options2 === void 0 ? void 0 : options2.jsonSchemaValidator(schema);
  return (obj) => validate(obj);
}
jsonSchema.$jsonSchema = $jsonSchema;
var mod = {};
Object.defineProperty(mod, "__esModule", { value: true });
mod.$mod = void 0;
const _predicates_1$6 = _predicates;
mod.$mod = (0, _predicates_1$6.createQueryOperator)(_predicates_1$6.$mod);
var regex = {};
Object.defineProperty(regex, "__esModule", { value: true });
regex.$regex = void 0;
const _predicates_1$5 = _predicates;
regex.$regex = (0, _predicates_1$5.createQueryOperator)(_predicates_1$5.$regex);
var where = {};
Object.defineProperty(where, "__esModule", { value: true });
where.$where = void 0;
const util_1 = util$5;
function $where(_, rhs, options2) {
  (0, util_1.assert)(options2.scriptEnabled, "$where operator requires 'scriptEnabled' option to be true");
  const f = rhs;
  (0, util_1.assert)((0, util_1.isFunction)(f), "$where only accepts a Function object");
  return (obj) => (0, util_1.truthy)(f.call(obj), options2 === null || options2 === void 0 ? void 0 : options2.useStrictMode);
}
where.$where = $where;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(expr, exports);
  __exportStar(jsonSchema, exports);
  __exportStar(mod, exports);
  __exportStar(regex, exports);
  __exportStar(where, exports);
})(evaluation);
var array = {};
var all = {};
Object.defineProperty(all, "__esModule", { value: true });
all.$all = void 0;
const _predicates_1$4 = _predicates;
all.$all = (0, _predicates_1$4.createQueryOperator)(_predicates_1$4.$all);
var elemMatch = {};
Object.defineProperty(elemMatch, "__esModule", { value: true });
elemMatch.$elemMatch = void 0;
const _predicates_1$3 = _predicates;
elemMatch.$elemMatch = (0, _predicates_1$3.createQueryOperator)(_predicates_1$3.$elemMatch);
var size = {};
Object.defineProperty(size, "__esModule", { value: true });
size.$size = void 0;
const _predicates_1$2 = _predicates;
size.$size = (0, _predicates_1$2.createQueryOperator)(_predicates_1$2.$size);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(all, exports);
  __exportStar(elemMatch, exports);
  __exportStar(size, exports);
})(array);
var element = {};
var exists = {};
Object.defineProperty(exists, "__esModule", { value: true });
exists.$exists = void 0;
const _predicates_1$1 = _predicates;
exists.$exists = (0, _predicates_1$1.createQueryOperator)(_predicates_1$1.$exists);
var type$5 = {};
Object.defineProperty(type$5, "__esModule", { value: true });
type$5.$type = void 0;
const _predicates_1 = _predicates;
type$5.$type = (0, _predicates_1.createQueryOperator)(_predicates_1.$type);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(exists, exports);
  __exportStar(type$5, exports);
})(element);
Object.defineProperty(rxQueryMingo, "__esModule", {
  value: true
});
rxQueryMingo.getMingoQuery = getMingoQuery;
var _core = core;
var _query = query;
var _pipeline = pipeline;
var _logical = logical;
var _comparison = comparison;
var _evaluation = evaluation;
var _array = array;
var _element = element;
var mingoInitDone = false;
function getMingoQuery(selector) {
  if (!mingoInitDone) {
    (0, _core.useOperators)(_core.OperatorType.PIPELINE, {
      $sort: _pipeline.$sort,
      $project: _pipeline.$project
    });
    (0, _core.useOperators)(_core.OperatorType.QUERY, {
      $and: _logical.$and,
      $eq: _comparison.$eq,
      $elemMatch: _array.$elemMatch,
      $exists: _element.$exists,
      $gt: _comparison.$gt,
      $gte: _comparison.$gte,
      $in: _comparison.$in,
      $lt: _comparison.$lt,
      $lte: _comparison.$lte,
      $ne: _comparison.$ne,
      $nin: _comparison.$nin,
      $mod: _evaluation.$mod,
      $nor: _logical.$nor,
      $not: _logical.$not,
      $or: _logical.$or,
      $regex: _evaluation.$regex,
      $size: _array.$size,
      $type: _element.$type
    });
    mingoInitDone = true;
  }
  return new _query.Query(selector);
}
Object.defineProperty(rxQueryHelper, "__esModule", {
  value: true
});
rxQueryHelper.getQueryMatcher = getQueryMatcher;
rxQueryHelper.getSortComparator = getSortComparator;
rxQueryHelper.normalizeMangoQuery = normalizeMangoQuery;
rxQueryHelper.normalizeQueryRegex = normalizeQueryRegex;
var _queryPlanner$2 = queryPlanner;
var _rxSchemaHelper$a = rxSchemaHelper;
var _utils$n = utils;
var _util$8 = util$5;
var _rxError$h = rxError;
var _rxQueryMingo = rxQueryMingo;
function normalizeMangoQuery(schema, mangoQuery) {
  var primaryKey = (0, _rxSchemaHelper$a.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);
  mangoQuery = (0, _utils$n.flatClone)(mangoQuery);
  if (mangoQuery.selector) {
    mangoQuery.selector = normalizeQueryRegex(mangoQuery.selector);
  }
  var normalizedMangoQuery = (0, _utils$n.clone)(mangoQuery);
  if (typeof normalizedMangoQuery.skip !== "number") {
    normalizedMangoQuery.skip = 0;
  }
  if (!normalizedMangoQuery.selector) {
    normalizedMangoQuery.selector = {};
  } else {
    normalizedMangoQuery.selector = normalizedMangoQuery.selector;
    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
      if (typeof matcher !== "object" || matcher === null) {
        normalizedMangoQuery.selector[field] = {
          $eq: matcher
        };
      }
    });
  }
  if (normalizedMangoQuery.index) {
    var indexAr = (0, _utils$n.toArray)(normalizedMangoQuery.index);
    if (!indexAr.includes(primaryKey)) {
      indexAr.push(primaryKey);
    }
    normalizedMangoQuery.index = indexAr;
  }
  if (!normalizedMangoQuery.sort) {
    if (normalizedMangoQuery.index) {
      normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field) => {
        return {
          [field]: "asc"
        };
      });
    } else {
      if (schema.indexes) {
        var fieldsWithLogicalOperator = /* @__PURE__ */ new Set();
        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
          var hasLogical = false;
          if (typeof matcher === "object" && matcher !== null) {
            hasLogical = !!Object.keys(matcher).find((operator) => _queryPlanner$2.LOGICAL_OPERATORS.has(operator));
          } else {
            hasLogical = true;
          }
          if (hasLogical) {
            fieldsWithLogicalOperator.add(field);
          }
        });
        var currentFieldsAmount = -1;
        var currentBestIndexForSort;
        schema.indexes.forEach((index) => {
          var useIndex = (0, _utils$n.isMaybeReadonlyArray)(index) ? index : [index];
          var firstWrongIndex = useIndex.findIndex((indexField) => !fieldsWithLogicalOperator.has(indexField));
          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {
            currentFieldsAmount = firstWrongIndex;
            currentBestIndexForSort = useIndex;
          }
        });
        if (currentBestIndexForSort) {
          normalizedMangoQuery.sort = currentBestIndexForSort.map((field) => {
            return {
              [field]: "asc"
            };
          });
        }
      }
      if (!normalizedMangoQuery.sort) {
        normalizedMangoQuery.sort = [{
          [primaryKey]: "asc"
        }];
      }
    }
  } else {
    var isPrimaryInSort = normalizedMangoQuery.sort.find((p) => (0, _utils$n.firstPropertyNameOfObject)(p) === primaryKey);
    if (!isPrimaryInSort) {
      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);
      normalizedMangoQuery.sort.push({
        [primaryKey]: "asc"
      });
    }
  }
  return normalizedMangoQuery;
}
function normalizeQueryRegex(selector) {
  if (typeof selector !== "object" || selector === null) {
    return selector;
  }
  var keys2 = Object.keys(selector);
  var ret = {};
  keys2.forEach((key) => {
    var value = selector[key];
    if (key === "$regex" && value instanceof RegExp) {
      var parsed = (0, _utils$n.parseRegex)(value);
      ret.$regex = parsed.pattern;
      ret.$options = parsed.flags;
    } else if (Array.isArray(value)) {
      ret[key] = value.map((item) => normalizeQueryRegex(item));
    } else {
      ret[key] = normalizeQueryRegex(value);
    }
  });
  return ret;
}
function getSortComparator(schema, query2) {
  if (!query2.sort) {
    throw (0, _rxError$h.newRxError)("SNH", {
      query: query2
    });
  }
  var sortParts = [];
  query2.sort.forEach((sortBlock) => {
    var key = Object.keys(sortBlock)[0];
    var direction = Object.values(sortBlock)[0];
    sortParts.push({
      key,
      direction,
      getValueFn: (0, _utils$n.objectPathMonad)(key)
    });
  });
  var fun = (a, b) => {
    for (var i = 0; i < sortParts.length; ++i) {
      var sortPart = sortParts[i];
      var valueA = sortPart.getValueFn(a);
      var valueB = sortPart.getValueFn(b);
      if (valueA !== valueB) {
        var ret = sortPart.direction === "asc" ? (0, _util$8.compare)(valueA, valueB) : (0, _util$8.compare)(valueB, valueA);
        return ret;
      }
    }
  };
  return fun;
}
function getQueryMatcher(_schema, query2) {
  if (!query2.sort) {
    throw (0, _rxError$h.newRxError)("SNH", {
      query: query2
    });
  }
  var mingoQuery = (0, _rxQueryMingo.getMingoQuery)(query2.selector);
  var fun = (doc) => {
    if (doc._deleted) {
      return false;
    }
    var cursor2 = mingoQuery.find([doc]);
    var next = cursor2.next();
    if (next) {
      return true;
    } else {
      return false;
    }
  };
  return fun;
}
Object.defineProperty(dexieQuery$1, "__esModule", {
  value: true
});
dexieQuery$1.dexieCount = dexieCount;
dexieQuery$1.dexieQuery = dexieQuery;
dexieQuery$1.getKeyRangeByQueryPlan = getKeyRangeByQueryPlan;
dexieQuery$1.mapKeyForKeyRange = mapKeyForKeyRange;
var _queryPlanner$1 = queryPlanner;
var _rxQueryHelper$1 = rxQueryHelper;
var _dexieHelper$2 = dexieHelper;
function mapKeyForKeyRange(k) {
  if (k === _queryPlanner$1.INDEX_MIN) {
    return -Infinity;
  } else {
    return k;
  }
}
function getKeyRangeByQueryPlan(queryPlan, IDBKeyRange2) {
  if (!IDBKeyRange2) {
    if (typeof window === "undefined") {
      throw new Error("IDBKeyRange missing");
    } else {
      IDBKeyRange2 = window.IDBKeyRange;
    }
  }
  var startKeys = queryPlan.startKeys.map(mapKeyForKeyRange);
  var endKeys = queryPlan.endKeys.map(mapKeyForKeyRange);
  var ret;
  if (queryPlan.index.length === 1) {
    var equalKeys = startKeys[0] === endKeys[0];
    ret = IDBKeyRange2.bound(startKeys[0], endKeys[0], equalKeys ? false : !queryPlan.inclusiveStart, equalKeys ? false : !queryPlan.inclusiveEnd);
  } else {
    ret = IDBKeyRange2.bound(startKeys, endKeys, !queryPlan.inclusiveStart, !queryPlan.inclusiveEnd);
  }
  return ret;
}
async function dexieQuery(instance, preparedQuery) {
  var state = await instance.internals;
  var query2 = preparedQuery.query;
  var skip2 = query2.skip ? query2.skip : 0;
  var limit2 = query2.limit ? query2.limit : Infinity;
  var skipPlusLimit = skip2 + limit2;
  var queryPlan = preparedQuery.queryPlan;
  var queryMatcher = false;
  if (!queryPlan.selectorSatisfiedByIndex) {
    queryMatcher = (0, _rxQueryHelper$1.getQueryMatcher)(instance.schema, preparedQuery.query);
  }
  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);
  var queryPlanFields = queryPlan.index;
  var rows = [];
  await state.dexieDb.transaction("r", state.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store = tx.objectStore(_dexieHelper$2.DEXIE_DOCS_TABLE_NAME);
    var index;
    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {
      index = store;
    } else {
      var indexName;
      if (queryPlanFields.length === 1) {
        indexName = (0, _dexieHelper$2.dexieReplaceIfStartsWithPipe)(queryPlanFields[0]);
      } else {
        indexName = "[" + queryPlanFields.map((field) => (0, _dexieHelper$2.dexieReplaceIfStartsWithPipe)(field)).join("+") + "]";
      }
      index = store.index(indexName);
    }
    var cursorReq = index.openCursor(keyRange);
    await new Promise((res) => {
      cursorReq.onsuccess = function(e) {
        var cursor2 = e.target.result;
        if (cursor2) {
          var docData = (0, _dexieHelper$2.fromDexieToStorage)(cursor2.value);
          if (!docData._deleted && (!queryMatcher || queryMatcher(docData))) {
            rows.push(docData);
          }
          if (queryPlan.sortFieldsSameAsIndexFields && rows.length === skipPlusLimit) {
            res();
          } else {
            cursor2.continue();
          }
        } else {
          res();
        }
      };
    });
  });
  if (!queryPlan.sortFieldsSameAsIndexFields) {
    var sortComparator = (0, _rxQueryHelper$1.getSortComparator)(instance.schema, preparedQuery.query);
    rows = rows.sort(sortComparator);
  }
  rows = rows.slice(skip2, skipPlusLimit);
  return {
    documents: rows
  };
}
async function dexieCount(instance, preparedQuery) {
  var state = await instance.internals;
  var queryPlan = preparedQuery.queryPlan;
  var queryPlanFields = queryPlan.index;
  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);
  var count2 = -1;
  await state.dexieDb.transaction("r", state.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store = tx.objectStore(_dexieHelper$2.DEXIE_DOCS_TABLE_NAME);
    var index;
    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {
      index = store;
    } else {
      var indexName;
      if (queryPlanFields.length === 1) {
        indexName = (0, _dexieHelper$2.dexieReplaceIfStartsWithPipe)(queryPlanFields[0]);
      } else {
        indexName = "[" + queryPlanFields.map((field) => (0, _dexieHelper$2.dexieReplaceIfStartsWithPipe)(field)).join("+") + "]";
      }
      index = store.index(indexName);
    }
    var request = index.count(keyRange);
    count2 = await new Promise((res, rej) => {
      request.onsuccess = function() {
        res(request.result);
      };
      request.onerror = (err) => rej(err);
    });
  });
  return count2;
}
var rxStorageMultiinstance = {};
var operators = {};
var partition$1 = {};
Object.defineProperty(partition$1, "__esModule", { value: true });
partition$1.partition = void 0;
var not_1 = not$3;
var filter_1 = filter$2;
function partition(predicate, thisArg) {
  return function(source) {
    return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];
  };
}
partition$1.partition = partition;
var race$1 = {};
var __read = commonjsGlobal && commonjsGlobal.__read || function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
    to[j] = from2[i];
  return to;
};
Object.defineProperty(race$1, "__esModule", { value: true });
race$1.race = void 0;
var argsOrArgArray_1 = argsOrArgArray$1;
var raceWith_1 = raceWith$1;
function race() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  return raceWith_1.raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray_1.argsOrArgArray(args2))));
}
race$1.race = race;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeAll = exports.merge = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.concat = exports.combineLatestWith = exports.combineLatest = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = void 0;
  exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.race = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.partition = exports.pairwise = exports.onErrorResumeNext = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = void 0;
  exports.zipWith = exports.zipAll = exports.zip = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = void 0;
  var audit_12 = audit$1;
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_12.audit;
  } });
  var auditTime_1 = auditTime$1;
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = buffer$1;
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = bufferCount$1;
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = bufferTime$1;
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = bufferToggle$1;
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = bufferWhen$1;
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = catchError$1;
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = combineAll;
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_12 = combineLatestAll$1;
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_12.combineLatestAll;
  } });
  var combineLatest_12 = combineLatest$1;
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_12.combineLatest;
  } });
  var combineLatestWith_1 = combineLatestWith$1;
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concat_12 = concat$3;
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_12.concat;
  } });
  var concatAll_12 = concatAll$1;
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_12.concatAll;
  } });
  var concatMap_12 = concatMap$1;
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_12.concatMap;
  } });
  var concatMapTo_1 = concatMapTo$1;
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = concatWith$1;
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_12 = connect$1;
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_12.connect;
  } });
  var count_1 = count$3;
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = debounce$1;
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = debounceTime$1;
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_12 = defaultIfEmpty$1;
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_12.defaultIfEmpty;
  } });
  var delay_1 = delay$1;
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_12 = delayWhen$1;
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_12.delayWhen;
  } });
  var dematerialize_1 = dematerialize$1;
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = distinct$1;
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_12 = distinctUntilChanged$1;
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_12.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = distinctUntilKeyChanged$1;
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = elementAt$1;
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = endWith$1;
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = every$1;
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = exhaust;
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_12 = exhaustAll$1;
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_12.exhaustAll;
  } });
  var exhaustMap_12 = exhaustMap$1;
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_12.exhaustMap;
  } });
  var expand_1 = expand$1;
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_12 = filter$2;
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_12.filter;
  } });
  var finalize_1 = finalize$1;
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_12 = find$1;
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_12.find;
  } });
  var findIndex_1 = findIndex$1;
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = first$3;
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = groupBy$1;
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_12 = ignoreElements$1;
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_12.ignoreElements;
  } });
  var isEmpty_1 = isEmpty$1;
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = last$3;
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_12 = map$2;
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_12.map;
  } });
  var mapTo_12 = mapTo$1;
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_12.mapTo;
  } });
  var materialize_1 = materialize$1;
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = max$2;
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var merge_12 = merge$3;
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_12.merge;
  } });
  var mergeAll_12 = mergeAll$1;
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_12.mergeAll;
  } });
  var flatMap_1 = flatMap;
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_12 = mergeMap$1;
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_12.mergeMap;
  } });
  var mergeMapTo_1 = mergeMapTo$1;
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = mergeScan$1;
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = mergeWith$1;
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = min$2;
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_12 = multicast$1;
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_12.multicast;
  } });
  var observeOn_12 = observeOn$1;
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_12.observeOn;
  } });
  var onErrorResumeNextWith_1 = onErrorResumeNextWith$1;
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNext;
  } });
  var pairwise_1 = pairwise$1;
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var partition_1 = partition$1;
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var pluck_1 = pluck$1;
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = publish$1;
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = publishBehavior$1;
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = publishLast$1;
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = publishReplay$1;
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var race_12 = race$1;
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_12.race;
  } });
  var raceWith_12 = raceWith$1;
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_12.raceWith;
  } });
  var reduce_12 = reduce$2;
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_12.reduce;
  } });
  var repeat_1 = repeat$1;
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = repeatWhen$1;
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = retry$2;
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = retryWhen$1;
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_12 = refCount$1;
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_12.refCount;
  } });
  var sample_12 = sample$2;
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_12.sample;
  } });
  var sampleTime_1 = sampleTime$1;
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = scan$1;
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = sequenceEqual$1;
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_12 = share$1;
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_12.share;
  } });
  var shareReplay_1 = shareReplay$1;
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = single$1;
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = skip$2;
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = skipLast$1;
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = skipUntil$1;
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = skipWhile$1;
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = startWith$1;
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_12 = subscribeOn$1;
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_12.subscribeOn;
  } });
  var switchAll_1 = switchAll$1;
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_12 = switchMap$1;
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_12.switchMap;
  } });
  var switchMapTo_1 = switchMapTo$1;
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = switchScan$1;
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_12 = take$1;
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_12.take;
  } });
  var takeLast_12 = takeLast$1;
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_12.takeLast;
  } });
  var takeUntil_1 = takeUntil$1;
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = takeWhile$1;
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = tap$1;
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_12 = throttle$1;
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_12.throttle;
  } });
  var throttleTime_1 = throttleTime$1;
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_12 = throwIfEmpty$1;
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_12.throwIfEmpty;
  } });
  var timeInterval_1 = timeInterval$1;
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_12 = timeout;
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_12.timeout;
  } });
  var timeoutWith_1 = timeoutWith$1;
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = timestamp$1;
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_12 = toArray$2;
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_12.toArray;
  } });
  var window_1 = window$2;
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = windowCount$1;
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = windowTime$1;
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = windowToggle$1;
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = windowWhen$1;
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = withLatestFrom$1;
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zip_12 = zip$2;
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_12.zip;
  } });
  var zipAll_1 = zipAll$1;
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = zipWith$1;
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
})(operators);
var es5node = {};
var broadcastChannel = {};
var util$4 = {};
Object.defineProperty(util$4, "__esModule", {
  value: true
});
util$4.PROMISE_RESOLVED_VOID = util$4.PROMISE_RESOLVED_TRUE = util$4.PROMISE_RESOLVED_FALSE = void 0;
util$4.isPromise = isPromise;
util$4.microSeconds = microSeconds$5;
util$4.randomInt = randomInt;
util$4.randomToken = randomToken;
util$4.sleep = sleep;
util$4.supportsWebLockAPI = supportsWebLockAPI;
function isPromise(obj) {
  return obj && typeof obj.then === "function";
}
var PROMISE_RESOLVED_FALSE = Promise.resolve(false);
util$4.PROMISE_RESOLVED_FALSE = PROMISE_RESOLVED_FALSE;
var PROMISE_RESOLVED_TRUE = Promise.resolve(true);
util$4.PROMISE_RESOLVED_TRUE = PROMISE_RESOLVED_TRUE;
var PROMISE_RESOLVED_VOID = Promise.resolve();
util$4.PROMISE_RESOLVED_VOID = PROMISE_RESOLVED_VOID;
function sleep(time, resolveWith) {
  if (!time)
    time = 0;
  return new Promise(function(res) {
    return setTimeout(function() {
      return res(resolveWith);
    }, time);
  });
}
function randomInt(min2, max2) {
  return Math.floor(Math.random() * (max2 - min2 + 1) + min2);
}
function randomToken() {
  return Math.random().toString(36).substring(2);
}
var lastMs = 0;
var additional = 0;
function microSeconds$5() {
  var ms = (/* @__PURE__ */ new Date()).getTime();
  if (ms === lastMs) {
    additional++;
    return ms * 1e3 + additional;
  } else {
    lastMs = ms;
    additional = 0;
    return ms * 1e3;
  }
}
function supportsWebLockAPI() {
  if (typeof navigator !== "undefined" && typeof navigator.locks !== "undefined" && typeof navigator.locks.request === "function") {
    return true;
  } else {
    return false;
  }
}
var methodChooser = {};
var _typeof$1 = { exports: {} };
(function(module) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(obj);
  }
  module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof$1);
var _typeofExports = _typeof$1.exports;
var native = {};
Object.defineProperty(native, "__esModule", {
  value: true
});
native.NativeMethod = void 0;
native.averageResponseTime = averageResponseTime$4;
native.canBeUsed = canBeUsed$4;
native.close = close$4;
native.create = create$4;
native.microSeconds = void 0;
native.onMessage = onMessage$4;
native.postMessage = postMessage$4;
native.type = void 0;
var _util$7 = util$4;
var microSeconds$4 = _util$7.microSeconds;
native.microSeconds = microSeconds$4;
var type$4 = "native";
native.type = type$4;
function create$4(channelName) {
  var state = {
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: []
    // subscriberFunctions
  };
  state.bc.onmessage = function(msg) {
    if (state.messagesCallback) {
      state.messagesCallback(msg.data);
    }
  };
  return state;
}
function close$4(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}
function postMessage$4(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return _util$7.PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}
function onMessage$4(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed$4() {
  if ((typeof window !== "undefined" || typeof self !== "undefined") && typeof BroadcastChannel === "function") {
    if (BroadcastChannel._pubkey) {
      throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
    }
    return true;
  } else {
    return false;
  }
}
function averageResponseTime$4() {
  return 150;
}
var NativeMethod = {
  create: create$4,
  close: close$4,
  onMessage: onMessage$4,
  postMessage: postMessage$4,
  canBeUsed: canBeUsed$4,
  type: type$4,
  averageResponseTime: averageResponseTime$4,
  microSeconds: microSeconds$4
};
native.NativeMethod = NativeMethod;
var indexedDb = {};
var ObliviousSet = (
  /** @class */
  function() {
    function ObliviousSet2(ttl) {
      this.ttl = ttl;
      this.map = /* @__PURE__ */ new Map();
      this._to = false;
    }
    ObliviousSet2.prototype.has = function(value) {
      return this.map.has(value);
    };
    ObliviousSet2.prototype.add = function(value) {
      var _this = this;
      this.map.set(value, now$1());
      if (!this._to) {
        this._to = true;
        setTimeout(function() {
          _this._to = false;
          removeTooOldValues(_this);
        }, 0);
      }
    };
    ObliviousSet2.prototype.clear = function() {
      this.map.clear();
    };
    return ObliviousSet2;
  }()
);
function removeTooOldValues(obliviousSet) {
  var olderThen = now$1() - obliviousSet.ttl;
  var iterator2 = obliviousSet.map[Symbol.iterator]();
  while (true) {
    var next = iterator2.next().value;
    if (!next) {
      return;
    }
    var value = next[0];
    var time = next[1];
    if (time < olderThen) {
      obliviousSet.map.delete(value);
    } else {
      return;
    }
  }
}
function now$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const es$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ObliviousSet,
  now: now$1,
  removeTooOldValues
}, Symbol.toStringTag, { value: "Module" }));
const require$$11 = /* @__PURE__ */ getAugmentedNamespace(es$3);
var options = {};
Object.defineProperty(options, "__esModule", {
  value: true
});
options.fillOptionsWithDefaults = fillOptionsWithDefaults$1;
function fillOptionsWithDefaults$1() {
  var originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var options2 = JSON.parse(JSON.stringify(originalOptions));
  if (typeof options2.webWorkerSupport === "undefined")
    options2.webWorkerSupport = true;
  if (!options2.idb)
    options2.idb = {};
  if (!options2.idb.ttl)
    options2.idb.ttl = 1e3 * 45;
  if (!options2.idb.fallbackInterval)
    options2.idb.fallbackInterval = 150;
  if (originalOptions.idb && typeof originalOptions.idb.onclose === "function")
    options2.idb.onclose = originalOptions.idb.onclose;
  if (!options2.localstorage)
    options2.localstorage = {};
  if (!options2.localstorage.removeTimeout)
    options2.localstorage.removeTimeout = 1e3 * 60;
  if (originalOptions.methods)
    options2.methods = originalOptions.methods;
  if (!options2.node)
    options2.node = {};
  if (!options2.node.ttl)
    options2.node.ttl = 1e3 * 60 * 2;
  if (!options2.node.maxParallelWrites)
    options2.node.maxParallelWrites = 2048;
  if (typeof options2.node.useFastPath === "undefined")
    options2.node.useFastPath = true;
  return options2;
}
Object.defineProperty(indexedDb, "__esModule", {
  value: true
});
indexedDb.TRANSACTION_SETTINGS = indexedDb.IndexedDBMethod = void 0;
indexedDb.averageResponseTime = averageResponseTime$3;
indexedDb.canBeUsed = canBeUsed$3;
indexedDb.cleanOldMessages = cleanOldMessages$1;
indexedDb.close = close$3;
indexedDb.commitIndexedDBTransaction = commitIndexedDBTransaction;
indexedDb.create = create$3;
indexedDb.createDatabase = createDatabase;
indexedDb.getAllMessages = getAllMessages$1;
indexedDb.getIdb = getIdb;
indexedDb.getMessagesHigherThan = getMessagesHigherThan;
indexedDb.getOldMessages = getOldMessages;
indexedDb.microSeconds = void 0;
indexedDb.onMessage = onMessage$3;
indexedDb.postMessage = postMessage$3;
indexedDb.removeMessagesById = removeMessagesById;
indexedDb.type = void 0;
indexedDb.writeMessage = writeMessage$1;
var _util$6 = util$4;
var _obliviousSet$3 = require$$11;
var _options$3 = options;
var microSeconds$3 = _util$6.microSeconds;
indexedDb.microSeconds = microSeconds$3;
var DB_PREFIX = "pubkey.broadcast-channel-0-";
var OBJECT_STORE_ID = "messages";
var TRANSACTION_SETTINGS = {
  durability: "relaxed"
};
indexedDb.TRANSACTION_SETTINGS = TRANSACTION_SETTINGS;
var type$3 = "idb";
indexedDb.type = type$3;
function getIdb() {
  if (typeof indexedDB !== "undefined")
    return indexedDB;
  if (typeof window !== "undefined") {
    if (typeof window.mozIndexedDB !== "undefined")
      return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== "undefined")
      return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== "undefined")
      return window.msIndexedDB;
  }
  return false;
}
function commitIndexedDBTransaction(tx) {
  if (tx.commit) {
    tx.commit();
  }
}
function createDatabase(channelName) {
  var IndexedDB = getIdb();
  var dbName = DB_PREFIX + channelName;
  var openRequest = IndexedDB.open(dbName);
  openRequest.onupgradeneeded = function(ev) {
    var db2 = ev.target.result;
    db2.createObjectStore(OBJECT_STORE_ID, {
      keyPath: "id",
      autoIncrement: true
    });
  };
  return new Promise(function(res, rej) {
    openRequest.onerror = function(ev) {
      return rej(ev);
    };
    openRequest.onsuccess = function() {
      res(openRequest.result);
    };
  });
}
function writeMessage$1(db2, readerUuid, messageJson) {
  var time = (/* @__PURE__ */ new Date()).getTime();
  var writeObject = {
    uuid: readerUuid,
    time,
    data: messageJson
  };
  var tx = db2.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  return new Promise(function(res, rej) {
    tx.oncomplete = function() {
      return res();
    };
    tx.onerror = function(ev) {
      return rej(ev);
    };
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
    commitIndexedDBTransaction(tx);
  });
}
function getAllMessages$1(db2) {
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function(res) {
    objectStore.openCursor().onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        ret.push(cursor2.value);
        cursor2["continue"]();
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function getMessagesHigherThan(db2, lastCursorId) {
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
  if (objectStore.getAll) {
    var getAllRequest = objectStore.getAll(keyRangeValue);
    return new Promise(function(res, rej) {
      getAllRequest.onerror = function(err) {
        return rej(err);
      };
      getAllRequest.onsuccess = function(e) {
        res(e.target.result);
      };
    });
  }
  function openCursor2() {
    try {
      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e) {
      return objectStore.openCursor();
    }
  }
  return new Promise(function(res, rej) {
    var openCursorRequest = openCursor2();
    openCursorRequest.onerror = function(err) {
      return rej(err);
    };
    openCursorRequest.onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        if (cursor2.value.id < lastCursorId + 1) {
          cursor2["continue"](lastCursorId + 1);
        } else {
          ret.push(cursor2.value);
          cursor2["continue"]();
        }
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function removeMessagesById(channelState, ids) {
  if (channelState.closed) {
    return Promise.resolve([]);
  }
  var tx = channelState.db.transaction(OBJECT_STORE_ID, "readwrite", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  return Promise.all(ids.map(function(id) {
    var deleteRequest = objectStore["delete"](id);
    return new Promise(function(res) {
      deleteRequest.onsuccess = function() {
        return res();
      };
    });
  }));
}
function getOldMessages(db2, ttl) {
  var olderThen = (/* @__PURE__ */ new Date()).getTime() - ttl;
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function(res) {
    objectStore.openCursor().onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        var msgObk = cursor2.value;
        if (msgObk.time < olderThen) {
          ret.push(msgObk);
          cursor2["continue"]();
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
        }
      } else {
        res(ret);
      }
    };
  });
}
function cleanOldMessages$1(channelState) {
  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function(tooOld) {
    return removeMessagesById(channelState, tooOld.map(function(msg) {
      return msg.id;
    }));
  });
}
function create$3(channelName, options2) {
  options2 = (0, _options$3.fillOptionsWithDefaults)(options2);
  return createDatabase(channelName).then(function(db2) {
    var state = {
      closed: false,
      lastCursorId: 0,
      channelName,
      options: options2,
      uuid: (0, _util$6.randomToken)(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new _obliviousSet$3.ObliviousSet(options2.idb.ttl * 2),
      // ensures we do not read messages in parallel
      writeBlockPromise: _util$6.PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db: db2
    };
    db2.onclose = function() {
      state.closed = true;
      if (options2.idb.onclose)
        options2.idb.onclose();
    };
    _readLoop(state);
    return state;
  });
}
function _readLoop(state) {
  if (state.closed)
    return;
  readNewMessages(state).then(function() {
    return (0, _util$6.sleep)(state.options.idb.fallbackInterval);
  }).then(function() {
    return _readLoop(state);
  });
}
function _filterMessage$1(msgObj, state) {
  if (msgObj.uuid === state.uuid)
    return false;
  if (state.eMIs.has(msgObj.id))
    return false;
  if (msgObj.data.time < state.messagesCallbackTime)
    return false;
  return true;
}
function readNewMessages(state) {
  if (state.closed)
    return _util$6.PROMISE_RESOLVED_VOID;
  if (!state.messagesCallback)
    return _util$6.PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state.db, state.lastCursorId).then(function(newerMessages) {
    var useMessages = newerMessages.filter(function(msgObj) {
      return !!msgObj;
    }).map(function(msgObj) {
      if (msgObj.id > state.lastCursorId) {
        state.lastCursorId = msgObj.id;
      }
      return msgObj;
    }).filter(function(msgObj) {
      return _filterMessage$1(msgObj, state);
    }).sort(function(msgObjA, msgObjB) {
      return msgObjA.time - msgObjB.time;
    });
    useMessages.forEach(function(msgObj) {
      if (state.messagesCallback) {
        state.eMIs.add(msgObj.id);
        state.messagesCallback(msgObj.data);
      }
    });
    return _util$6.PROMISE_RESOLVED_VOID;
  });
}
function close$3(channelState) {
  channelState.closed = true;
  channelState.db.close();
}
function postMessage$3(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {
    return writeMessage$1(channelState.db, channelState.uuid, messageJson);
  }).then(function() {
    if ((0, _util$6.randomInt)(0, 10) === 0) {
      cleanOldMessages$1(channelState);
    }
  });
  return channelState.writeBlockPromise;
}
function onMessage$3(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
  readNewMessages(channelState);
}
function canBeUsed$3() {
  return !!getIdb();
}
function averageResponseTime$3(options2) {
  return options2.idb.fallbackInterval * 2;
}
var IndexedDBMethod = {
  create: create$3,
  close: close$3,
  onMessage: onMessage$3,
  postMessage: postMessage$3,
  canBeUsed: canBeUsed$3,
  type: type$3,
  averageResponseTime: averageResponseTime$3,
  microSeconds: microSeconds$3
};
indexedDb.IndexedDBMethod = IndexedDBMethod;
var localstorage = {};
Object.defineProperty(localstorage, "__esModule", {
  value: true
});
localstorage.LocalstorageMethod = void 0;
localstorage.addStorageEventListener = addStorageEventListener;
localstorage.averageResponseTime = averageResponseTime$2;
localstorage.canBeUsed = canBeUsed$2;
localstorage.close = close$2;
localstorage.create = create$2;
localstorage.getLocalStorage = getLocalStorage;
localstorage.microSeconds = void 0;
localstorage.onMessage = onMessage$2;
localstorage.postMessage = postMessage$2;
localstorage.removeStorageEventListener = removeStorageEventListener;
localstorage.storageKey = storageKey;
localstorage.type = void 0;
var _obliviousSet$2 = require$$11;
var _options$2 = options;
var _util$5 = util$4;
var microSeconds$2 = _util$5.microSeconds;
localstorage.microSeconds = microSeconds$2;
var KEY_PREFIX = "pubkey.broadcastChannel-";
var type$2 = "localstorage";
localstorage.type = type$2;
function getLocalStorage() {
  var localStorage2;
  if (typeof window === "undefined")
    return null;
  try {
    localStorage2 = window.localStorage;
    localStorage2 = window["ie8-eventlistener/storage"] || window.localStorage;
  } catch (e) {
  }
  return localStorage2;
}
function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}
function postMessage$2(channelState, messageJson) {
  return new Promise(function(res) {
    (0, _util$5.sleep)().then(function() {
      var key = storageKey(channelState.channelName);
      var writeObj = {
        token: (0, _util$5.randomToken)(),
        time: (/* @__PURE__ */ new Date()).getTime(),
        data: messageJson,
        uuid: channelState.uuid
      };
      var value = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value);
      var ev = document.createEvent("Event");
      ev.initEvent("storage", true, true);
      ev.key = key;
      ev.newValue = value;
      window.dispatchEvent(ev);
      res();
    });
  });
}
function addStorageEventListener(channelName, fn) {
  var key = storageKey(channelName);
  var listener = function listener2(ev) {
    if (ev.key === key) {
      fn(JSON.parse(ev.newValue));
    }
  };
  window.addEventListener("storage", listener);
  return listener;
}
function removeStorageEventListener(listener) {
  window.removeEventListener("storage", listener);
}
function create$2(channelName, options2) {
  options2 = (0, _options$2.fillOptionsWithDefaults)(options2);
  if (!canBeUsed$2()) {
    throw new Error("BroadcastChannel: localstorage cannot be used");
  }
  var uuid = (0, _util$5.randomToken)();
  var eMIs = new _obliviousSet$2.ObliviousSet(options2.localstorage.removeTimeout);
  var state = {
    channelName,
    uuid,
    eMIs
    // emittedMessagesIds
  };
  state.listener = addStorageEventListener(channelName, function(msgObj) {
    if (!state.messagesCallback)
      return;
    if (msgObj.uuid === uuid)
      return;
    if (!msgObj.token || eMIs.has(msgObj.token))
      return;
    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime)
      return;
    eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  return state;
}
function close$2(channelState) {
  removeStorageEventListener(channelState.listener);
}
function onMessage$2(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
}
function canBeUsed$2() {
  var ls = getLocalStorage();
  if (!ls)
    return false;
  try {
    var key = "__broadcastchannel_check";
    ls.setItem(key, "works");
    ls.removeItem(key);
  } catch (e) {
    return false;
  }
  return true;
}
function averageResponseTime$2() {
  var defaultTime = 120;
  var userAgent = navigator.userAgent.toLowerCase();
  if (userAgent.includes("safari") && !userAgent.includes("chrome")) {
    return defaultTime * 2;
  }
  return defaultTime;
}
var LocalstorageMethod = {
  create: create$2,
  close: close$2,
  onMessage: onMessage$2,
  postMessage: postMessage$2,
  canBeUsed: canBeUsed$2,
  type: type$2,
  averageResponseTime: averageResponseTime$2,
  microSeconds: microSeconds$2
};
localstorage.LocalstorageMethod = LocalstorageMethod;
var simulate = {};
Object.defineProperty(simulate, "__esModule", {
  value: true
});
simulate.SimulateMethod = void 0;
simulate.averageResponseTime = averageResponseTime$1;
simulate.canBeUsed = canBeUsed$1;
simulate.close = close$1;
simulate.create = create$1;
simulate.microSeconds = void 0;
simulate.onMessage = onMessage$1;
simulate.postMessage = postMessage$1;
simulate.type = void 0;
var _util$4 = util$4;
var microSeconds$1 = _util$4.microSeconds;
simulate.microSeconds = microSeconds$1;
var type$1 = "simulate";
simulate.type = type$1;
var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
function create$1(channelName) {
  var state = {
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state);
  return state;
}
function close$1(channelState) {
  SIMULATE_CHANNELS["delete"](channelState);
}
function postMessage$1(channelState, messageJson) {
  return new Promise(function(res) {
    return setTimeout(function() {
      var channelArray = Array.from(SIMULATE_CHANNELS);
      channelArray.filter(function(channel) {
        return channel.name === channelState.name;
      }).filter(function(channel) {
        return channel !== channelState;
      }).filter(function(channel) {
        return !!channel.messagesCallback;
      }).forEach(function(channel) {
        return channel.messagesCallback(messageJson);
      });
      res();
    }, 5);
  });
}
function onMessage$1(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed$1() {
  return true;
}
function averageResponseTime$1() {
  return 5;
}
var SimulateMethod = {
  create: create$1,
  close: close$1,
  onMessage: onMessage$1,
  postMessage: postMessage$1,
  canBeUsed: canBeUsed$1,
  type: type$1,
  averageResponseTime: averageResponseTime$1,
  microSeconds: microSeconds$1
};
simulate.SimulateMethod = SimulateMethod;
var node = {};
var interopRequireDefault = { exports: {} };
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
var regeneratorRuntime$1 = { exports: {} };
var hasRequiredRegeneratorRuntime;
function requireRegeneratorRuntime() {
  if (hasRequiredRegeneratorRuntime)
    return regeneratorRuntime$1.exports;
  hasRequiredRegeneratorRuntime = 1;
  (function(module) {
    var _typeof2 = _typeofExports["default"];
    function _regeneratorRuntime() {
      module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports = {}, Op = Object.prototype, hasOwn2 = Op.hasOwnProperty, defineProperty2 = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol2 = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define2(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap2(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context(tryLocsList || []);
        return defineProperty2(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context2)
        }), generator;
      }
      function tryCatch2(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports.wrap = wrap2;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol2, function() {
        return this;
      });
      var getProto2 = Object.getPrototypeOf, NativeIteratorPrototype = getProto2 && getProto2(getProto2(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol2) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch2(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof2(value) && hasOwn2.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty2(this, "_invoke", {
          value: function value(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context2) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return {
              value: void 0,
              done: true
            };
          }
          for (context2.method = method, context2.arg = arg; ; ) {
            var delegate = context2.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context2);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context2.method)
              context2.sent = context2._sent = context2.arg;
            else if ("throw" === context2.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context2.arg;
              context2.dispatchException(context2.arg);
            } else
              "return" === context2.method && context2.abrupt("return", context2.arg);
            state = "executing";
            var record = tryCatch2(innerFn, self2, context2);
            if ("normal" === record.type) {
              if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context2.done
              };
            }
            "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context2) {
        var methodName = context2.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context2.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method) || "return" !== methodName && (context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch2(method, delegate.iterator, context2.arg);
        if ("throw" === record.type)
          return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context2[delegate.resultName] = info.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable || "" === iterable) {
          var iteratorMethod = iterable[iteratorSymbol2];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; )
                if (hasOwn2.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        throw new TypeError(_typeof2(iterable) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty2(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter2 = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter2 : iter2.next().then(function(result) {
          return result.done ? result.value : iter2.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol2, function() {
        return this;
      }), define(Gp, "toString", function() {
        return "[object Generator]";
      }), exports.keys = function(val) {
        var object2 = Object(val), keys2 = [];
        for (var key in object2)
          keys2.push(key);
        return keys2.reverse(), function next() {
          for (; keys2.length; ) {
            var key2 = keys2.pop();
            if (key2 in object2)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn2.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context2 = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn2.call(entry, "catchLoc"), hasFinally = hasOwn2.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type2, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type2 || "continue" === type2) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type2, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports;
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);
  return regeneratorRuntime$1.exports;
}
var regenerator;
var hasRequiredRegenerator;
function requireRegenerator() {
  if (hasRequiredRegenerator)
    return regenerator;
  hasRequiredRegenerator = 1;
  var runtime = requireRegeneratorRuntime()();
  regenerator = runtime;
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
  return regenerator;
}
var asyncToGenerator = { exports: {} };
var hasRequiredAsyncToGenerator;
function requireAsyncToGenerator() {
  if (hasRequiredAsyncToGenerator)
    return asyncToGenerator.exports;
  hasRequiredAsyncToGenerator = 1;
  (function(module) {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args2 = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args2);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(asyncToGenerator);
  return asyncToGenerator.exports;
}
var dist$1 = {};
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3)
    return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events2() {
    }
    if (Object.create) {
      Events2.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events2().__proto__)
        prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events2();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events2();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args2, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args2 = new Array(len - 1); i < len; i++) {
          args2[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args2);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args2)
                for (j = 1, args2 = new Array(len - 1); j < len; j++) {
                  args2[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args2);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context2 && listeners[i].context !== context2) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    {
      module.exports = EventEmitter;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var pTimeout = { exports: {} };
var pFinally;
var hasRequiredPFinally;
function requirePFinally() {
  if (hasRequiredPFinally)
    return pFinally;
  hasRequiredPFinally = 1;
  pFinally = (promise, onFinally) => {
    onFinally = onFinally || (() => {
    });
    return promise.then(
      (val) => new Promise((resolve) => {
        resolve(onFinally());
      }).then(() => val),
      (err) => new Promise((resolve) => {
        resolve(onFinally());
      }).then(() => {
        throw err;
      })
    );
  };
  return pFinally;
}
var hasRequiredPTimeout;
function requirePTimeout() {
  if (hasRequiredPTimeout)
    return pTimeout.exports;
  hasRequiredPTimeout = 1;
  const pFinally2 = requirePFinally();
  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  const pTimeout$1 = (promise, milliseconds, fallback2) => new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || milliseconds < 0) {
      throw new TypeError("Expected `milliseconds` to be a positive number");
    }
    if (milliseconds === Infinity) {
      resolve(promise);
      return;
    }
    const timer2 = setTimeout(() => {
      if (typeof fallback2 === "function") {
        try {
          resolve(fallback2());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message = typeof fallback2 === "string" ? fallback2 : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback2 instanceof Error ? fallback2 : new TimeoutError(message);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    pFinally2(
      // eslint-disable-next-line promise/prefer-await-to-then
      promise.then(resolve, reject),
      () => {
        clearTimeout(timer2);
      }
    );
  });
  pTimeout.exports = pTimeout$1;
  pTimeout.exports.default = pTimeout$1;
  pTimeout.exports.TimeoutError = TimeoutError;
  return pTimeout.exports;
}
var priorityQueue = {};
var lowerBound = {};
var hasRequiredLowerBound;
function requireLowerBound() {
  if (hasRequiredLowerBound)
    return lowerBound;
  hasRequiredLowerBound = 1;
  Object.defineProperty(lowerBound, "__esModule", { value: true });
  function lowerBound$1(array2, value, comparator) {
    let first2 = 0;
    let count2 = array2.length;
    while (count2 > 0) {
      const step = count2 / 2 | 0;
      let it = first2 + step;
      if (comparator(array2[it], value) <= 0) {
        first2 = ++it;
        count2 -= step + 1;
      } else {
        count2 = step;
      }
    }
    return first2;
  }
  lowerBound.default = lowerBound$1;
  return lowerBound;
}
var hasRequiredPriorityQueue;
function requirePriorityQueue() {
  if (hasRequiredPriorityQueue)
    return priorityQueue;
  hasRequiredPriorityQueue = 1;
  Object.defineProperty(priorityQueue, "__esModule", { value: true });
  const lower_bound_1 = requireLowerBound();
  class PriorityQueue {
    constructor() {
      this._queue = [];
    }
    enqueue(run, options2) {
      options2 = Object.assign({ priority: 0 }, options2);
      const element2 = {
        priority: options2.priority,
        run
      };
      if (this.size && this._queue[this.size - 1].priority >= options2.priority) {
        this._queue.push(element2);
        return;
      }
      const index = lower_bound_1.default(this._queue, element2, (a, b) => b.priority - a.priority);
      this._queue.splice(index, 0, element2);
    }
    dequeue() {
      const item = this._queue.shift();
      return item === null || item === void 0 ? void 0 : item.run;
    }
    filter(options2) {
      return this._queue.filter((element2) => element2.priority === options2.priority).map((element2) => element2.run);
    }
    get size() {
      return this._queue.length;
    }
  }
  priorityQueue.default = PriorityQueue;
  return priorityQueue;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist)
    return dist$1;
  hasRequiredDist = 1;
  Object.defineProperty(dist$1, "__esModule", { value: true });
  const EventEmitter = requireEventemitter3();
  const p_timeout_1 = requirePTimeout();
  const priority_queue_1 = requirePriorityQueue();
  const empty2 = () => {
  };
  const timeoutError = new p_timeout_1.TimeoutError();
  class PQueue extends EventEmitter {
    constructor(options2) {
      var _a, _b, _c, _d;
      super();
      this._intervalCount = 0;
      this._intervalEnd = 0;
      this._pendingCount = 0;
      this._resolveEmpty = empty2;
      this._resolveIdle = empty2;
      options2 = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options2);
      if (!(typeof options2.intervalCap === "number" && options2.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options2.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options2.intervalCap})`);
      }
      if (options2.interval === void 0 || !(Number.isFinite(options2.interval) && options2.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options2.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options2.interval})`);
      }
      this._carryoverConcurrencyCount = options2.carryoverConcurrencyCount;
      this._isIntervalIgnored = options2.intervalCap === Infinity || options2.interval === 0;
      this._intervalCap = options2.intervalCap;
      this._interval = options2.interval;
      this._queue = new options2.queueClass();
      this._queueClass = options2.queueClass;
      this.concurrency = options2.concurrency;
      this._timeout = options2.timeout;
      this._throwOnTimeout = options2.throwOnTimeout === true;
      this._isPaused = options2.autoStart === false;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--;
      this._tryToStartAnother();
      this.emit("next");
    }
    _resolvePromises() {
      this._resolveEmpty();
      this._resolveEmpty = empty2;
      if (this._pendingCount === 0) {
        this._resolveIdle();
        this._resolveIdle = empty2;
        this.emit("idle");
      }
    }
    _onResumeInterval() {
      this._onInterval();
      this._initializeIntervalIfNeeded();
      this._timeoutId = void 0;
    }
    _isIntervalPaused() {
      const now2 = Date.now();
      if (this._intervalId === void 0) {
        const delay2 = this._intervalEnd - now2;
        if (delay2 < 0) {
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        } else {
          if (this._timeoutId === void 0) {
            this._timeoutId = setTimeout(() => {
              this._onResumeInterval();
            }, delay2);
          }
          return true;
        }
      }
      return false;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0) {
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }
        this._intervalId = void 0;
        this._resolvePromises();
        return false;
      }
      if (!this._isPaused) {
        const canInitializeInterval = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          const job = this._queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit("active");
          job();
          if (canInitializeInterval) {
            this._initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
    _initializeIntervalIfNeeded() {
      if (this._isIntervalIgnored || this._intervalId !== void 0) {
        return;
      }
      this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval);
      this._intervalEnd = Date.now() + this._interval;
    }
    _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = void 0;
      }
      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      this._processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    _processQueue() {
      while (this._tryToStartAnother()) {
      }
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      this._concurrency = newConcurrency;
      this._processQueue();
    }
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */
    async add(fn, options2 = {}) {
      return new Promise((resolve, reject) => {
        const run = async () => {
          this._pendingCount++;
          this._intervalCount++;
          try {
            const operation = this._timeout === void 0 && options2.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options2.timeout === void 0 ? this._timeout : options2.timeout, () => {
              if (options2.throwOnTimeout === void 0 ? this._throwOnTimeout : options2.throwOnTimeout) {
                reject(timeoutError);
              }
              return void 0;
            });
            resolve(await operation);
          } catch (error) {
            reject(error);
          }
          this._next();
        };
        this._queue.enqueue(run, options2);
        this._tryToStartAnother();
        this.emit("add");
      });
    }
    /**
    	    Same as `.add()`, but accepts an array of sync or async functions.
    
    	    @returns A promise that resolves when all functions are resolved.
    	    */
    async addAll(functions, options2) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options2)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this._processQueue();
      return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      this._isPaused = true;
    }
    /**
    Clear the queue.
    */
    clear() {
      this._queue = new this._queueClass();
    }
    /**
    	    Can be called multiple times. Useful if you for example add additional items at a later time.
    
    	    @returns A promise that settles when the queue becomes empty.
    	    */
    async onEmpty() {
      if (this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveEmpty;
        this._resolveEmpty = () => {
          existingResolve();
          resolve();
        };
      });
    }
    /**
    	    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
    	    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    	    */
    async onIdle() {
      if (this._pendingCount === 0 && this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveIdle;
        this._resolveIdle = () => {
          existingResolve();
          resolve();
        };
      });
    }
    /**
    Size of the queue.
    */
    get size() {
      return this._queue.size;
    }
    /**
    	    Size of the queue, filtered by the given options.
    
    	    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    	    */
    sizeBy(options2) {
      return this._queue.filter(options2).length;
    }
    /**
    Number of pending promises.
    */
    get pending() {
      return this._pendingCount;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    /**
    Set the timeout for future operations.
    */
    set timeout(milliseconds) {
      this._timeout = milliseconds;
    }
  }
  dist$1.default = PQueue;
  return dist$1;
}
function addBrowser(fn) {
  if (typeof WorkerGlobalScope === "function" && self instanceof WorkerGlobalScope) {
    var oldClose = self.close.bind(self);
    self.close = function() {
      fn();
      return oldClose();
    };
  } else {
    if (typeof window.addEventListener !== "function") {
      return;
    }
    window.addEventListener("beforeunload", function() {
      fn();
    }, true);
    window.addEventListener("unload", function() {
      fn();
    }, true);
  }
}
function addNode(fn) {
  process.on("exit", function() {
    return fn();
  });
  process.on("beforeExit", function() {
    return fn().then(function() {
      return process.exit();
    });
  });
  process.on("SIGINT", function() {
    return fn().then(function() {
      return process.exit();
    });
  });
  process.on("uncaughtException", function(err) {
    return fn().then(function() {
      console.trace(err);
      process.exit(101);
    });
  });
}
var isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var USE_METHOD = isNode ? addNode : addBrowser;
var LISTENERS = /* @__PURE__ */ new Set();
var startedListening = false;
function startListening() {
  if (startedListening) {
    return;
  }
  startedListening = true;
  USE_METHOD(runAll);
}
function add(fn) {
  startListening();
  if (typeof fn !== "function") {
    throw new Error("Listener is no function");
  }
  LISTENERS.add(fn);
  var addReturn = {
    remove: function remove() {
      return LISTENERS["delete"](fn);
    },
    run: function run() {
      LISTENERS["delete"](fn);
      return fn();
    }
  };
  return addReturn;
}
function runAll() {
  var promises = [];
  LISTENERS.forEach(function(fn) {
    promises.push(fn());
    LISTENERS["delete"](fn);
  });
  return Promise.all(promises);
}
function removeAll() {
  LISTENERS.clear();
}
function getSize() {
  return LISTENERS.size;
}
const es$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add,
  getSize,
  removeAll,
  runAll
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(es$2);
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(node, "__esModule", {
  value: true
});
node.TMP_FOLDER_BASE = void 0;
node._filterMessage = _filterMessage;
node.averageResponseTime = averageResponseTime;
node.canBeUsed = canBeUsed;
node.cleanOldMessages = cleanOldMessages;
node.cleanPipeName = cleanPipeName;
node.clearNodeFolder = clearNodeFolder$1;
node.close = close;
node.countChannelFolders = countChannelFolders;
node.create = create;
node.createSocketEventEmitter = createSocketEventEmitter;
node.createSocketInfoFile = createSocketInfoFile;
node.emitOverFastPath = emitOverFastPath;
node.ensureFoldersExist = ensureFoldersExist;
node.getAllMessages = getAllMessages;
node.getPaths = getPaths;
node.getReadersUuids = getReadersUuids;
node.getSingleMessage = getSingleMessage;
node.handleMessagePing = handleMessagePing;
node.messagePath = messagePath;
node.microSeconds = microSeconds;
node.onMessage = onMessage;
node.openClientConnection = openClientConnection;
node.postMessage = postMessage;
node.readMessage = readMessage;
node.refreshReaderClients = refreshReaderClients;
node.socketInfoPath = socketInfoPath;
node.socketPath = socketPath;
node.type = void 0;
node.writeMessage = writeMessage;
var _regenerator = _interopRequireDefault$5(requireRegenerator());
var _asyncToGenerator2 = _interopRequireDefault$5(requireAsyncToGenerator());
var _util$3 = _interopRequireDefault$5(require$$3);
var _fs = _interopRequireDefault$5(fs$3);
var _crypto = _interopRequireDefault$5(require$$5);
var _os = _interopRequireDefault$5(require$$6);
var _events = _interopRequireDefault$5(require$$7);
var _net = _interopRequireDefault$5(require$$8);
var _path = _interopRequireDefault$5(require$$0$3);
var _pQueue = _interopRequireDefault$5(requireDist());
var _unload$1 = require$$0$1;
var _options$1 = options;
var _util2 = util$4;
var _obliviousSet$1 = require$$11;
function cleanPipeName(str) {
  if (process.platform === "win32" && !str.startsWith("\\\\.\\pipe\\")) {
    str = str.replace(/^\//, "");
    str = str.replace(/\//g, "-");
    return "\\\\.\\pipe\\" + str;
  } else {
    return str;
  }
}
var mkdir = _util$3["default"].promisify(_fs["default"].mkdir);
var writeFile = _util$3["default"].promisify(_fs["default"].writeFile);
var readFile = _util$3["default"].promisify(_fs["default"].readFile);
var unlink = _util$3["default"].promisify(_fs["default"].unlink);
var readdir = _util$3["default"].promisify(_fs["default"].readdir);
var chmod = _util$3["default"].promisify(_fs["default"].chmod);
var rmDir = _util$3["default"].promisify(_fs["default"].rm);
var removeDir = /* @__PURE__ */ function() {
  var _ref = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee(p) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return rmDir(p, {
              recursive: true
            });
          case 3:
            return _context.abrupt("return", _context.sent);
          case 6:
            _context.prev = 6;
            _context.t0 = _context["catch"](0);
            if (!(_context.t0.code !== "ENOENT")) {
              _context.next = 10;
              break;
            }
            throw _context.t0;
          case 10:
          case "end":
            return _context.stop();
        }
    }, _callee, null, [[0, 6]]);
  }));
  return function removeDir2(_x) {
    return _ref.apply(this, arguments);
  };
}();
var OTHER_INSTANCES = {};
var TMP_FOLDER_NAME = "pubkey.bc";
var TMP_FOLDER_BASE = _path["default"].join(_os["default"].tmpdir(), TMP_FOLDER_NAME);
node.TMP_FOLDER_BASE = TMP_FOLDER_BASE;
var getPathsCache = /* @__PURE__ */ new Map();
function getPaths(channelName) {
  if (!getPathsCache.has(channelName)) {
    var channelHash = _crypto["default"].createHash("sha256").update(channelName).digest("hex");
    var channelFolder = "A" + channelHash.substring(0, 20);
    var channelPathBase = _path["default"].join(TMP_FOLDER_BASE, channelFolder);
    var folderPathReaders = _path["default"].join(channelPathBase, "rdrs");
    var folderPathMessages = _path["default"].join(channelPathBase, "msgs");
    var ret = {
      channelBase: channelPathBase,
      readers: folderPathReaders,
      messages: folderPathMessages
    };
    getPathsCache.set(channelName, ret);
    return ret;
  }
  return getPathsCache.get(channelName);
}
var ENSURE_BASE_FOLDER_EXISTS_PROMISE = null;
function ensureBaseFolderExists() {
  return _ensureBaseFolderExists.apply(this, arguments);
}
function _ensureBaseFolderExists() {
  _ensureBaseFolderExists = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee4() {
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1)
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!ENSURE_BASE_FOLDER_EXISTS_PROMISE) {
              ENSURE_BASE_FOLDER_EXISTS_PROMISE = mkdir(TMP_FOLDER_BASE)["catch"](function() {
                return null;
              });
            }
            return _context4.abrupt("return", ENSURE_BASE_FOLDER_EXISTS_PROMISE);
          case 2:
          case "end":
            return _context4.stop();
        }
    }, _callee4);
  }));
  return _ensureBaseFolderExists.apply(this, arguments);
}
function ensureFoldersExist(_x2, _x3) {
  return _ensureFoldersExist.apply(this, arguments);
}
function _ensureFoldersExist() {
  _ensureFoldersExist = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee5(channelName, paths) {
    var chmodValue;
    return _regenerator["default"].wrap(function _callee5$(_context5) {
      while (1)
        switch (_context5.prev = _context5.next) {
          case 0:
            paths = paths || getPaths(channelName);
            _context5.next = 3;
            return ensureBaseFolderExists();
          case 3:
            _context5.next = 5;
            return mkdir(paths.channelBase)["catch"](function() {
              return null;
            });
          case 5:
            _context5.next = 7;
            return Promise.all([mkdir(paths.readers)["catch"](function() {
              return null;
            }), mkdir(paths.messages)["catch"](function() {
              return null;
            })]);
          case 7:
            chmodValue = "777";
            _context5.next = 10;
            return Promise.all([chmod(paths.channelBase, chmodValue), chmod(paths.readers, chmodValue), chmod(paths.messages, chmodValue)])["catch"](function() {
              return null;
            });
          case 10:
          case "end":
            return _context5.stop();
        }
    }, _callee5);
  }));
  return _ensureFoldersExist.apply(this, arguments);
}
function clearNodeFolder$1() {
  return _clearNodeFolder.apply(this, arguments);
}
function _clearNodeFolder() {
  _clearNodeFolder = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee6() {
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1)
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(!TMP_FOLDER_BASE || TMP_FOLDER_BASE === "" || TMP_FOLDER_BASE === "/")) {
              _context6.next = 2;
              break;
            }
            throw new Error("BroadcastChannel.clearNodeFolder(): path is wrong");
          case 2:
            ENSURE_BASE_FOLDER_EXISTS_PROMISE = null;
            _context6.next = 5;
            return removeDir(TMP_FOLDER_BASE);
          case 5:
            ENSURE_BASE_FOLDER_EXISTS_PROMISE = null;
            return _context6.abrupt("return", true);
          case 7:
          case "end":
            return _context6.stop();
        }
    }, _callee6);
  }));
  return _clearNodeFolder.apply(this, arguments);
}
function socketPath(channelName, readerUuid, paths) {
  paths = paths || getPaths(channelName);
  var socketPath2 = _path["default"].join(paths.readers, readerUuid + ".s");
  return cleanPipeName(socketPath2);
}
function socketInfoPath(channelName, readerUuid, paths) {
  paths = paths || getPaths(channelName);
  return _path["default"].join(paths.readers, readerUuid + ".json");
}
function createSocketInfoFile(channelName, readerUuid, paths) {
  var pathToFile = socketInfoPath(channelName, readerUuid, paths);
  return writeFile(pathToFile, JSON.stringify({
    time: microSeconds()
  })).then(function() {
    return pathToFile;
  });
}
function countChannelFolders() {
  return _countChannelFolders.apply(this, arguments);
}
function _countChannelFolders() {
  _countChannelFolders = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee7() {
    var folders;
    return _regenerator["default"].wrap(function _callee7$(_context7) {
      while (1)
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return ensureBaseFolderExists();
          case 2:
            _context7.next = 4;
            return readdir(TMP_FOLDER_BASE);
          case 4:
            folders = _context7.sent;
            return _context7.abrupt("return", folders.length);
          case 6:
          case "end":
            return _context7.stop();
        }
    }, _callee7);
  }));
  return _countChannelFolders.apply(this, arguments);
}
function connectionError(_x4) {
  return _connectionError.apply(this, arguments);
}
function _connectionError() {
  _connectionError = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee8(originalError) {
    var count2, addObj, text;
    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1)
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return countChannelFolders();
          case 2:
            count2 = _context8.sent;
            if (!(count2 < 30)) {
              _context8.next = 5;
              break;
            }
            return _context8.abrupt("return", originalError);
          case 5:
            addObj = {};
            Object.entries(originalError).forEach(function(_ref4) {
              var k = _ref4[0], v = _ref4[1];
              return addObj[k] = v;
            });
            text = "BroadcastChannel.create(): error: This might happen if you have created to many channels, like when you use BroadcastChannel in unit-tests.Try using BroadcastChannel.clearNodeFolder() to clear the tmp-folder before each test.See https://github.com/pubkey/broadcast-channel#clear-tmp-folder";
            return _context8.abrupt("return", new Error(text + ": " + JSON.stringify(addObj, null, 2)));
          case 9:
          case "end":
            return _context8.stop();
        }
    }, _callee8);
  }));
  return _connectionError.apply(this, arguments);
}
function createSocketEventEmitter(_x5, _x6, _x7) {
  return _createSocketEventEmitter.apply(this, arguments);
}
function _createSocketEventEmitter() {
  _createSocketEventEmitter = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee11(channelName, readerUuid, paths) {
    var pathToSocket, emitter, server;
    return _regenerator["default"].wrap(function _callee11$(_context11) {
      while (1)
        switch (_context11.prev = _context11.next) {
          case 0:
            pathToSocket = socketPath(channelName, readerUuid, paths);
            emitter = new _events["default"].EventEmitter();
            server = _net["default"].createServer(function(stream) {
              stream.on("end", function() {
              });
              stream.on("data", function(msg) {
                emitter.emit("data", msg.toString());
              });
            });
            _context11.next = 5;
            return new Promise(function(resolve, reject) {
              server.on("error", /* @__PURE__ */ function() {
                var _ref5 = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee9(err) {
                  var useErr;
                  return _regenerator["default"].wrap(function _callee9$(_context9) {
                    while (1)
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          _context9.next = 2;
                          return connectionError(err);
                        case 2:
                          useErr = _context9.sent;
                          reject(useErr);
                        case 4:
                        case "end":
                          return _context9.stop();
                      }
                  }, _callee9);
                }));
                return function(_x27) {
                  return _ref5.apply(this, arguments);
                };
              }());
              server.listen(pathToSocket, /* @__PURE__ */ function() {
                var _ref6 = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee10(err, res) {
                  var useErr;
                  return _regenerator["default"].wrap(function _callee10$(_context10) {
                    while (1)
                      switch (_context10.prev = _context10.next) {
                        case 0:
                          if (!err) {
                            _context10.next = 7;
                            break;
                          }
                          _context10.next = 3;
                          return connectionError(err);
                        case 3:
                          useErr = _context10.sent;
                          reject(useErr);
                          _context10.next = 8;
                          break;
                        case 7:
                          resolve(res);
                        case 8:
                        case "end":
                          return _context10.stop();
                      }
                  }, _callee10);
                }));
                return function(_x28, _x29) {
                  return _ref6.apply(this, arguments);
                };
              }());
            });
          case 5:
            return _context11.abrupt("return", {
              path: pathToSocket,
              emitter,
              server
            });
          case 6:
          case "end":
            return _context11.stop();
        }
    }, _callee11);
  }));
  return _createSocketEventEmitter.apply(this, arguments);
}
function openClientConnection(_x8, _x9) {
  return _openClientConnection.apply(this, arguments);
}
function _openClientConnection() {
  _openClientConnection = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee12(channelName, readerUuid) {
    var pathToSocket, client;
    return _regenerator["default"].wrap(function _callee12$(_context12) {
      while (1)
        switch (_context12.prev = _context12.next) {
          case 0:
            pathToSocket = socketPath(channelName, readerUuid);
            client = new _net["default"].Socket();
            return _context12.abrupt("return", new Promise(function(res, rej) {
              client.connect(pathToSocket, function() {
                return res(client);
              });
              client.on("error", function(err) {
                return rej(err);
              });
            }));
          case 3:
          case "end":
            return _context12.stop();
        }
    }, _callee12);
  }));
  return _openClientConnection.apply(this, arguments);
}
function writeMessage(channelName, readerUuid, messageJson, paths) {
  paths = paths || getPaths(channelName);
  var time = microSeconds();
  var writeObject = {
    uuid: readerUuid,
    time,
    data: messageJson
  };
  var token = (0, _util2.randomToken)();
  var fileName = time + "_" + readerUuid + "_" + token + ".json";
  var msgPath = _path["default"].join(paths.messages, fileName);
  return writeFile(msgPath, JSON.stringify(writeObject)).then(function() {
    return {
      time,
      uuid: readerUuid,
      token,
      path: msgPath
    };
  });
}
function getReadersUuids(_x10, _x11) {
  return _getReadersUuids.apply(this, arguments);
}
function _getReadersUuids() {
  _getReadersUuids = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee13(channelName, paths) {
    var readersPath, files;
    return _regenerator["default"].wrap(function _callee13$(_context13) {
      while (1)
        switch (_context13.prev = _context13.next) {
          case 0:
            paths = paths || getPaths(channelName);
            readersPath = paths.readers;
            _context13.next = 4;
            return readdir(readersPath);
          case 4:
            files = _context13.sent;
            return _context13.abrupt("return", files.map(function(file) {
              return file.split(".");
            }).filter(function(split2) {
              return split2[1] === "json";
            }).map(function(split2) {
              return split2[0];
            }));
          case 6:
          case "end":
            return _context13.stop();
        }
    }, _callee13);
  }));
  return _getReadersUuids.apply(this, arguments);
}
function messagePath(_x12, _x13, _x14, _x15) {
  return _messagePath.apply(this, arguments);
}
function _messagePath() {
  _messagePath = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee14(channelName, time, token, writerUuid) {
    var fileName;
    return _regenerator["default"].wrap(function _callee14$(_context14) {
      while (1)
        switch (_context14.prev = _context14.next) {
          case 0:
            fileName = time + "_" + writerUuid + "_" + token + ".json";
            return _context14.abrupt("return", _path["default"].join(getPaths(channelName).messages, fileName));
          case 2:
          case "end":
            return _context14.stop();
        }
    }, _callee14);
  }));
  return _messagePath.apply(this, arguments);
}
function getAllMessages(_x16, _x17) {
  return _getAllMessages.apply(this, arguments);
}
function _getAllMessages() {
  _getAllMessages = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee15(channelName, paths) {
    var messagesPath, files;
    return _regenerator["default"].wrap(function _callee15$(_context15) {
      while (1)
        switch (_context15.prev = _context15.next) {
          case 0:
            paths = paths || getPaths(channelName);
            messagesPath = paths.messages;
            _context15.next = 4;
            return readdir(messagesPath);
          case 4:
            files = _context15.sent;
            return _context15.abrupt("return", files.map(function(file) {
              var fileName = file.split(".")[0];
              var split2 = fileName.split("_");
              return {
                path: _path["default"].join(messagesPath, file),
                time: parseInt(split2[0]),
                senderUuid: split2[1],
                token: split2[2]
              };
            }));
          case 6:
          case "end":
            return _context15.stop();
        }
    }, _callee15);
  }));
  return _getAllMessages.apply(this, arguments);
}
function getSingleMessage(channelName, msgObj, paths) {
  paths = paths || getPaths(channelName);
  return {
    path: _path["default"].join(paths.messages, msgObj.t + "_" + msgObj.u + "_" + msgObj.to + ".json"),
    time: msgObj.t,
    senderUuid: msgObj.u,
    token: msgObj.to
  };
}
function readMessage(messageObj) {
  return readFile(messageObj.path, "utf8").then(function(content) {
    return JSON.parse(content);
  });
}
function cleanOldMessages(_x18, _x19) {
  return _cleanOldMessages.apply(this, arguments);
}
function _cleanOldMessages() {
  _cleanOldMessages = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee16(messageObjects, ttl) {
    var olderThan;
    return _regenerator["default"].wrap(function _callee16$(_context16) {
      while (1)
        switch (_context16.prev = _context16.next) {
          case 0:
            olderThan = microSeconds() - ttl * 1e3;
            _context16.next = 3;
            return Promise.all(messageObjects.filter(function(obj) {
              return obj.time < olderThan;
            }).map(function(obj) {
              return unlink(obj.path)["catch"](function() {
                return null;
              });
            }));
          case 3:
          case "end":
            return _context16.stop();
        }
    }, _callee16);
  }));
  return _cleanOldMessages.apply(this, arguments);
}
var type = "node";
node.type = type;
function create(_x20) {
  return _create.apply(this, arguments);
}
function _create() {
  _create = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee17(channelName) {
    var options2, time, paths, ensureFolderExistsPromise, uuid, state, _yield$Promise$all, socketEE, infoFilePath, _args17 = arguments;
    return _regenerator["default"].wrap(function _callee17$(_context17) {
      while (1)
        switch (_context17.prev = _context17.next) {
          case 0:
            options2 = _args17.length > 1 && _args17[1] !== void 0 ? _args17[1] : {};
            options2 = (0, _options$1.fillOptionsWithDefaults)(options2);
            time = microSeconds();
            paths = getPaths(channelName);
            ensureFolderExistsPromise = ensureFoldersExist(channelName, paths);
            uuid = (0, _util2.randomToken)();
            state = {
              time,
              channelName,
              options: options2,
              uuid,
              paths,
              // contains all messages that have been emitted before
              emittedMessagesIds: new _obliviousSet$1.ObliviousSet(options2.node.ttl * 2),
              /**
               * Used to ensure we do not write too many files at once
               * which could throw an error.
               * Must always be smaller than options.node.maxParallelWrites
               */
              writeFileQueue: new _pQueue["default"]({
                concurrency: options2.node.maxParallelWrites
              }),
              messagesCallbackTime: null,
              messagesCallback: null,
              // ensures we do not read messages in parallel
              writeBlockPromise: _util2.PROMISE_RESOLVED_VOID,
              otherReaderClients: {},
              // ensure if process crashes, everything is cleaned up
              removeUnload: (0, _unload$1.add)(function() {
                return close(state);
              }),
              closed: false
            };
            if (!OTHER_INSTANCES[channelName])
              OTHER_INSTANCES[channelName] = [];
            OTHER_INSTANCES[channelName].push(state);
            _context17.next = 11;
            return ensureFolderExistsPromise;
          case 11:
            _context17.next = 13;
            return Promise.all([createSocketEventEmitter(channelName, uuid, paths), createSocketInfoFile(channelName, uuid, paths), refreshReaderClients(state)]);
          case 13:
            _yield$Promise$all = _context17.sent;
            socketEE = _yield$Promise$all[0];
            infoFilePath = _yield$Promise$all[1];
            state.socketEE = socketEE;
            state.infoFilePath = infoFilePath;
            socketEE.emitter.on("data", function(data) {
              var singleOnes = data.split("|");
              singleOnes.filter(function(single2) {
                return single2 !== "";
              }).forEach(function(single2) {
                try {
                  var obj = JSON.parse(single2);
                  handleMessagePing(state, obj);
                } catch (err) {
                  throw new Error("could not parse data: " + single2);
                }
              });
            });
            return _context17.abrupt("return", state);
          case 20:
          case "end":
            return _context17.stop();
        }
    }, _callee17);
  }));
  return _create.apply(this, arguments);
}
function _filterMessage(msgObj, state) {
  if (msgObj.senderUuid === state.uuid)
    return false;
  if (state.emittedMessagesIds.has(msgObj.token))
    return false;
  if (!state.messagesCallback)
    return false;
  if (msgObj.time < state.messagesCallbackTime)
    return false;
  if (msgObj.time < state.time)
    return false;
  state.emittedMessagesIds.add(msgObj.token);
  return true;
}
function handleMessagePing(_x21, _x22) {
  return _handleMessagePing.apply(this, arguments);
}
function _handleMessagePing() {
  _handleMessagePing = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee18(state, msgObj) {
    var messages2, useMessages;
    return _regenerator["default"].wrap(function _callee18$(_context18) {
      while (1)
        switch (_context18.prev = _context18.next) {
          case 0:
            if (state.messagesCallback) {
              _context18.next = 2;
              break;
            }
            return _context18.abrupt("return");
          case 2:
            if (msgObj) {
              _context18.next = 8;
              break;
            }
            _context18.next = 5;
            return getAllMessages(state.channelName, state.paths);
          case 5:
            messages2 = _context18.sent;
            _context18.next = 9;
            break;
          case 8:
            messages2 = [getSingleMessage(state.channelName, msgObj, state.paths)];
          case 9:
            useMessages = messages2.filter(function(msgObj2) {
              return _filterMessage(msgObj2, state);
            }).sort(function(msgObjA, msgObjB) {
              return msgObjA.time - msgObjB.time;
            });
            if (!(!useMessages.length || !state.messagesCallback)) {
              _context18.next = 12;
              break;
            }
            return _context18.abrupt("return");
          case 12:
            _context18.next = 14;
            return Promise.all(useMessages.map(function(msgObj2) {
              return readMessage(msgObj2).then(function(content) {
                return msgObj2.content = content;
              });
            }));
          case 14:
            useMessages.forEach(function(msgObj2) {
              state.emittedMessagesIds.add(msgObj2.token);
              if (state.messagesCallback) {
                state.messagesCallback(msgObj2.content.data);
              }
            });
          case 15:
          case "end":
            return _context18.stop();
        }
    }, _callee18);
  }));
  return _handleMessagePing.apply(this, arguments);
}
function refreshReaderClients(channelState) {
  return getReadersUuids(channelState.channelName, channelState.paths).then(function(otherReaders) {
    Object.keys(channelState.otherReaderClients).filter(function(readerUuid) {
      return !otherReaders.includes(readerUuid);
    }).forEach(/* @__PURE__ */ function() {
      var _ref2 = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee2(readerUuid) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return channelState.otherReaderClients[readerUuid].destroy();
              case 3:
                _context2.next = 7;
                break;
              case 5:
                _context2.prev = 5;
                _context2.t0 = _context2["catch"](0);
              case 7:
                delete channelState.otherReaderClients[readerUuid];
              case 8:
              case "end":
                return _context2.stop();
            }
        }, _callee2, null, [[0, 5]]);
      }));
      return function(_x23) {
        return _ref2.apply(this, arguments);
      };
    }());
    return Promise.all(otherReaders.filter(function(readerUuid) {
      return readerUuid !== channelState.uuid;
    }).filter(function(readerUuid) {
      return !channelState.otherReaderClients[readerUuid];
    }).map(/* @__PURE__ */ function() {
      var _ref3 = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee3(readerUuid) {
        var client;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                if (!channelState.closed) {
                  _context3.next = 3;
                  break;
                }
                return _context3.abrupt("return");
              case 3:
                _context3.prev = 3;
                _context3.next = 6;
                return openClientConnection(channelState.channelName, readerUuid);
              case 6:
                client = _context3.sent;
                channelState.otherReaderClients[readerUuid] = client;
                _context3.next = 12;
                break;
              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3["catch"](3);
              case 12:
                _context3.next = 16;
                break;
              case 14:
                _context3.prev = 14;
                _context3.t1 = _context3["catch"](0);
              case 16:
              case "end":
                return _context3.stop();
            }
        }, _callee3, null, [[0, 14], [3, 10]]);
      }));
      return function(_x24) {
        return _ref3.apply(this, arguments);
      };
    }()));
  });
}
function postMessage(_x25, _x26) {
  return _postMessage.apply(this, arguments);
}
function _postMessage() {
  _postMessage = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee20(channelState, messageJson) {
    var writePromise;
    return _regenerator["default"].wrap(function _callee20$(_context20) {
      while (1)
        switch (_context20.prev = _context20.next) {
          case 0:
            writePromise = channelState.writeFileQueue.add(function() {
              return writeMessage(channelState.channelName, channelState.uuid, messageJson, channelState.paths);
            });
            channelState.writeBlockPromise = channelState.writeBlockPromise.then(/* @__PURE__ */ (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee19() {
              var _yield$Promise$all2, msgObj, pingStr, writeToReadersPromise;
              return _regenerator["default"].wrap(function _callee19$(_context19) {
                while (1)
                  switch (_context19.prev = _context19.next) {
                    case 0:
                      _context19.next = 2;
                      return new Promise(function(res) {
                        return setTimeout(res, 0);
                      });
                    case 2:
                      _context19.next = 4;
                      return Promise.all([writePromise, refreshReaderClients(channelState)]);
                    case 4:
                      _yield$Promise$all2 = _context19.sent;
                      msgObj = _yield$Promise$all2[0];
                      emitOverFastPath(channelState, msgObj, messageJson);
                      pingStr = '{"t":' + msgObj.time + ',"u":"' + msgObj.uuid + '","to":"' + msgObj.token + '"}|';
                      writeToReadersPromise = Promise.all(Object.values(channelState.otherReaderClients).filter(function(client) {
                        return client.writable;
                      }).map(function(client) {
                        return new Promise(function(res) {
                          client.write(pingStr, res);
                        });
                      }));
                      if ((0, _util2.randomInt)(0, 20) === 0) {
                        getAllMessages(channelState.channelName, channelState.paths).then(function(allMessages) {
                          return cleanOldMessages(allMessages, channelState.options.node.ttl);
                        });
                      }
                      return _context19.abrupt("return", writeToReadersPromise);
                    case 11:
                    case "end":
                      return _context19.stop();
                  }
              }, _callee19);
            })));
            return _context20.abrupt("return", channelState.writeBlockPromise);
          case 3:
          case "end":
            return _context20.stop();
        }
    }, _callee20);
  }));
  return _postMessage.apply(this, arguments);
}
function emitOverFastPath(state, msgObj, messageJson) {
  if (!state.options.node.useFastPath) {
    return;
  }
  var others = OTHER_INSTANCES[state.channelName].filter(function(s) {
    return s !== state;
  });
  var checkObj = {
    time: msgObj.time,
    senderUuid: msgObj.uuid,
    token: msgObj.token
  };
  others.filter(function(otherState) {
    return _filterMessage(checkObj, otherState);
  }).forEach(function(otherState) {
    otherState.messagesCallback(messageJson);
  });
}
function onMessage(channelState, fn) {
  var time = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : microSeconds();
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
  handleMessagePing(channelState);
}
function close(channelState) {
  if (channelState.closed)
    return _util2.PROMISE_RESOLVED_VOID;
  channelState.closed = true;
  channelState.emittedMessagesIds.clear();
  OTHER_INSTANCES[channelState.channelName] = OTHER_INSTANCES[channelState.channelName].filter(function(o) {
    return o !== channelState;
  });
  if (channelState.removeUnload) {
    channelState.removeUnload.remove();
  }
  return new Promise(function(res) {
    if (channelState.socketEE)
      channelState.socketEE.emitter.removeAllListeners();
    Object.values(channelState.otherReaderClients).forEach(function(client) {
      return client.destroy();
    });
    if (channelState.infoFilePath) {
      try {
        _fs["default"].unlinkSync(channelState.infoFilePath);
      } catch (err) {
      }
    }
    setTimeout(function() {
      channelState.socketEE.server.close();
      res();
    }, 200);
  });
}
function canBeUsed() {
  return typeof _fs["default"].mkdir === "function";
}
function averageResponseTime() {
  return 200;
}
function microSeconds() {
  return parseInt(now() / 1e3);
}
function now() {
  return Number(process.hrtime.bigint());
}
var _typeof = _typeofExports;
Object.defineProperty(methodChooser, "__esModule", {
  value: true
});
methodChooser.chooseMethod = chooseMethod;
var _native = native;
var _indexedDb = indexedDb;
var _localstorage = localstorage;
var _simulate = simulate;
var NodeMethod = _interopRequireWildcard(node);
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return { "default": obj };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj["default"] = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
var METHODS = [
  _native.NativeMethod,
  // fastest
  _indexedDb.IndexedDBMethod,
  _localstorage.LocalstorageMethod
];
function chooseMethod(options2) {
  var chooseMethods = [].concat(options2.methods, METHODS).filter(Boolean);
  chooseMethods.push(NodeMethod);
  if (options2.type) {
    if (options2.type === "simulate") {
      return _simulate.SimulateMethod;
    }
    var ret = chooseMethods.find(function(m) {
      return m.type === options2.type;
    });
    if (!ret)
      throw new Error("method-type " + options2.type + " not found");
    else
      return ret;
  }
  if (!options2.webWorkerSupport) {
    chooseMethods = chooseMethods.filter(function(m) {
      return m.type !== "idb";
    });
  }
  var useMethod = chooseMethods.find(function(method) {
    return method.canBeUsed();
  });
  if (!useMethod) {
    throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function(m) {
      return m.type;
    })));
  } else {
    return useMethod;
  }
}
Object.defineProperty(broadcastChannel, "__esModule", {
  value: true
});
broadcastChannel.OPEN_BROADCAST_CHANNELS = broadcastChannel.BroadcastChannel = void 0;
broadcastChannel.clearNodeFolder = clearNodeFolder;
broadcastChannel.enforceOptions = enforceOptions;
var _util$2 = util$4;
var _methodChooser = methodChooser;
var _options = options;
var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
broadcastChannel.OPEN_BROADCAST_CHANNELS = OPEN_BROADCAST_CHANNELS;
var lastId = 0;
var BroadcastChannel$1 = function BroadcastChannel2(name, options2) {
  this.id = lastId++;
  OPEN_BROADCAST_CHANNELS.add(this);
  this.name = name;
  if (ENFORCED_OPTIONS) {
    options2 = ENFORCED_OPTIONS;
  }
  this.options = (0, _options.fillOptionsWithDefaults)(options2);
  this.method = (0, _methodChooser.chooseMethod)(this.options);
  this._iL = false;
  this._onML = null;
  this._addEL = {
    message: [],
    internal: []
  };
  this._uMP = /* @__PURE__ */ new Set();
  this._befC = [];
  this._prepP = null;
  _prepareChannel(this);
};
broadcastChannel.BroadcastChannel = BroadcastChannel$1;
BroadcastChannel$1._pubkey = true;
function clearNodeFolder(options2) {
  options2 = (0, _options.fillOptionsWithDefaults)(options2);
  var method = (0, _methodChooser.chooseMethod)(options2);
  if (method.type === "node") {
    return method.clearNodeFolder().then(function() {
      return true;
    });
  } else {
    return _util$2.PROMISE_RESOLVED_FALSE;
  }
}
var ENFORCED_OPTIONS;
function enforceOptions(options2) {
  ENFORCED_OPTIONS = options2;
}
BroadcastChannel$1.prototype = {
  postMessage: function postMessage2(msg) {
    if (this.closed) {
      throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
       * In the past when this error appeared, it was really hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(msg));
    }
    return _post(this, "message", msg);
  },
  postInternal: function postInternal(msg) {
    return _post(this, "internal", msg);
  },
  set onmessage(fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time,
      fn
    };
    _removeListenerObject(this, "message", this._onML);
    if (fn && typeof fn === "function") {
      this._onML = listenObj;
      _addListenerObject(this, "message", listenObj);
    } else {
      this._onML = null;
    }
  },
  addEventListener: function addEventListener2(type2, fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time,
      fn
    };
    _addListenerObject(this, type2, listenObj);
  },
  removeEventListener: function removeEventListener(type2, fn) {
    var obj = this._addEL[type2].find(function(obj2) {
      return obj2.fn === fn;
    });
    _removeListenerObject(this, type2, obj);
  },
  close: function close2() {
    var _this = this;
    if (this.closed) {
      return;
    }
    OPEN_BROADCAST_CHANNELS["delete"](this);
    this.closed = true;
    var awaitPrepare = this._prepP ? this._prepP : _util$2.PROMISE_RESOLVED_VOID;
    this._onML = null;
    this._addEL.message = [];
    return awaitPrepare.then(function() {
      return Promise.all(Array.from(_this._uMP));
    }).then(function() {
      return Promise.all(_this._befC.map(function(fn) {
        return fn();
      }));
    }).then(function() {
      return _this.method.close(_this._state);
    });
  },
  get type() {
    return this.method.type;
  },
  get isClosed() {
    return this.closed;
  }
};
function _post(broadcastChannel2, type2, msg) {
  var time = broadcastChannel2.method.microSeconds();
  var msgObj = {
    time,
    type: type2,
    data: msg
  };
  var awaitPrepare = broadcastChannel2._prepP ? broadcastChannel2._prepP : _util$2.PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(function() {
    var sendPromise = broadcastChannel2.method.postMessage(broadcastChannel2._state, msgObj);
    broadcastChannel2._uMP.add(sendPromise);
    sendPromise["catch"]().then(function() {
      return broadcastChannel2._uMP["delete"](sendPromise);
    });
    return sendPromise;
  });
}
function _prepareChannel(channel) {
  var maybePromise = channel.method.create(channel.name, channel.options);
  if ((0, _util$2.isPromise)(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then(function(s) {
      channel._state = s;
    });
  } else {
    channel._state = maybePromise;
  }
}
function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0)
    return true;
  if (channel._addEL.internal.length > 0)
    return true;
  return false;
}
function _addListenerObject(channel, type2, obj) {
  channel._addEL[type2].push(obj);
  _startListening(channel);
}
function _removeListenerObject(channel, type2, obj) {
  channel._addEL[type2] = channel._addEL[type2].filter(function(o) {
    return o !== obj;
  });
  _stopListening(channel);
}
function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    var listenerFn = function listenerFn2(msgObj) {
      channel._addEL[msgObj.type].forEach(function(listenerObject) {
        var hundredMsInMicro = 100 * 1e3;
        var minMessageTime = listenerObject.time - hundredMsInMicro;
        if (msgObj.time >= minMessageTime) {
          listenerObject.fn(msgObj.data);
        }
      });
    };
    var time = channel.method.microSeconds();
    if (channel._prepP) {
      channel._prepP.then(function() {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time);
    }
  }
}
function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    channel._iL = false;
    var time = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time);
  }
}
var leaderElection = {};
var leaderElectionUtil = {};
Object.defineProperty(leaderElectionUtil, "__esModule", {
  value: true
});
leaderElectionUtil.beLeader = beLeader;
leaderElectionUtil.sendLeaderMessage = sendLeaderMessage;
var _unload = require$$0$1;
function sendLeaderMessage(leaderElector, action) {
  var msgJson = {
    context: "leader",
    action,
    token: leaderElector.token
  };
  return leaderElector.broadcastChannel.postInternal(msgJson);
}
function beLeader(leaderElector) {
  leaderElector.isLeader = true;
  leaderElector._hasLeader = true;
  var unloadFn = (0, _unload.add)(function() {
    return leaderElector.die();
  });
  leaderElector._unl.push(unloadFn);
  var isLeaderListener = function isLeaderListener2(msg) {
    if (msg.context === "leader" && msg.action === "apply") {
      sendLeaderMessage(leaderElector, "tell");
    }
    if (msg.context === "leader" && msg.action === "tell" && !leaderElector._dpLC) {
      leaderElector._dpLC = true;
      leaderElector._dpL();
      sendLeaderMessage(leaderElector, "tell");
    }
  };
  leaderElector.broadcastChannel.addEventListener("internal", isLeaderListener);
  leaderElector._lstns.push(isLeaderListener);
  return sendLeaderMessage(leaderElector, "tell");
}
var leaderElectionWebLock = {};
Object.defineProperty(leaderElectionWebLock, "__esModule", {
  value: true
});
leaderElectionWebLock.LeaderElectionWebLock = void 0;
var _util$1 = util$4;
var _leaderElectionUtil$1 = leaderElectionUtil;
var LeaderElectionWebLock = function LeaderElectionWebLock2(broadcastChannel2, options2) {
  var _this = this;
  this.broadcastChannel = broadcastChannel2;
  broadcastChannel2._befC.push(function() {
    return _this.die();
  });
  this._options = options2;
  this.isLeader = false;
  this.isDead = false;
  this.token = (0, _util$1.randomToken)();
  this._lstns = [];
  this._unl = [];
  this._dpL = function() {
  };
  this._dpLC = false;
  this._wKMC = {};
  this.lN = "pubkey-bc||" + broadcastChannel2.method.type + "||" + broadcastChannel2.name;
};
leaderElectionWebLock.LeaderElectionWebLock = LeaderElectionWebLock;
LeaderElectionWebLock.prototype = {
  hasLeader: function hasLeader() {
    var _this2 = this;
    return navigator.locks.query().then(function(locks) {
      var relevantLocks = locks.held ? locks.held.filter(function(lock2) {
        return lock2.name === _this2.lN;
      }) : [];
      if (relevantLocks && relevantLocks.length > 0) {
        return true;
      } else {
        return false;
      }
    });
  },
  awaitLeadership: function awaitLeadership() {
    var _this3 = this;
    if (!this._wLMP) {
      this._wKMC.c = new AbortController();
      var returnPromise = new Promise(function(res, rej) {
        _this3._wKMC.res = res;
        _this3._wKMC.rej = rej;
      });
      this._wLMP = new Promise(function(res) {
        navigator.locks.request(_this3.lN, {
          signal: _this3._wKMC.c.signal
        }, function() {
          _this3._wKMC.c = void 0;
          (0, _leaderElectionUtil$1.beLeader)(_this3);
          res();
          return returnPromise;
        })["catch"](function() {
        });
      });
    }
    return this._wLMP;
  },
  set onduplicate(_fn) {
  },
  die: function die() {
    var _this4 = this;
    this._lstns.forEach(function(listener) {
      return _this4.broadcastChannel.removeEventListener("internal", listener);
    });
    this._lstns = [];
    this._unl.forEach(function(uFn) {
      return uFn.remove();
    });
    this._unl = [];
    if (this.isLeader) {
      this.isLeader = false;
    }
    this.isDead = true;
    if (this._wKMC.res) {
      this._wKMC.res();
    }
    if (this._wKMC.c) {
      this._wKMC.c.abort("LeaderElectionWebLock.die() called");
    }
    return (0, _leaderElectionUtil$1.sendLeaderMessage)(this, "death");
  }
};
Object.defineProperty(leaderElection, "__esModule", {
  value: true
});
leaderElection.createLeaderElection = createLeaderElection;
var _util = util$4;
var _leaderElectionUtil = leaderElectionUtil;
var _leaderElectionWebLock = leaderElectionWebLock;
var LeaderElection = function LeaderElection2(broadcastChannel2, options2) {
  var _this = this;
  this.broadcastChannel = broadcastChannel2;
  this._options = options2;
  this.isLeader = false;
  this._hasLeader = false;
  this.isDead = false;
  this.token = (0, _util.randomToken)();
  this._aplQ = _util.PROMISE_RESOLVED_VOID;
  this._aplQC = 0;
  this._unl = [];
  this._lstns = [];
  this._dpL = function() {
  };
  this._dpLC = false;
  var hasLeaderListener = function hasLeaderListener2(msg) {
    if (msg.context === "leader") {
      if (msg.action === "death") {
        _this._hasLeader = false;
      }
      if (msg.action === "tell") {
        _this._hasLeader = true;
      }
    }
  };
  this.broadcastChannel.addEventListener("internal", hasLeaderListener);
  this._lstns.push(hasLeaderListener);
};
LeaderElection.prototype = {
  hasLeader: function hasLeader2() {
    return Promise.resolve(this._hasLeader);
  },
  /**
   * Returns true if the instance is leader,
   * false if not.
   * @async
   */
  applyOnce: function applyOnce(isFromFallbackInterval) {
    var _this2 = this;
    if (this.isLeader) {
      return (0, _util.sleep)(0, true);
    }
    if (this.isDead) {
      return (0, _util.sleep)(0, false);
    }
    if (this._aplQC > 1) {
      return this._aplQ;
    }
    var applyRun = function applyRun2() {
      if (_this2.isLeader) {
        return _util.PROMISE_RESOLVED_TRUE;
      }
      var stopCriteria = false;
      var stopCriteriaPromiseResolve;
      var stopCriteriaPromise = new Promise(function(res) {
        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve2() {
          stopCriteria = true;
          res();
        };
      });
      var handleMessage = function handleMessage2(msg) {
        if (msg.context === "leader" && msg.token != _this2.token) {
          if (msg.action === "apply") {
            if (msg.token > _this2.token) {
              stopCriteriaPromiseResolve();
            }
          }
          if (msg.action === "tell") {
            stopCriteriaPromiseResolve();
            _this2._hasLeader = true;
          }
        }
      };
      _this2.broadcastChannel.addEventListener("internal", handleMessage);
      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;
      return (0, _leaderElectionUtil.sendLeaderMessage)(_this2, "apply").then(function() {
        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function() {
          return Promise.reject(new Error());
        })]);
      }).then(function() {
        return (0, _leaderElectionUtil.sendLeaderMessage)(_this2, "apply");
      }).then(function() {
        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function() {
          return Promise.reject(new Error());
        })]);
      })["catch"](function() {
      }).then(function() {
        _this2.broadcastChannel.removeEventListener("internal", handleMessage);
        if (!stopCriteria) {
          return (0, _leaderElectionUtil.beLeader)(_this2).then(function() {
            return true;
          });
        } else {
          return false;
        }
      });
    };
    this._aplQC = this._aplQC + 1;
    this._aplQ = this._aplQ.then(function() {
      return applyRun();
    }).then(function() {
      _this2._aplQC = _this2._aplQC - 1;
    });
    return this._aplQ.then(function() {
      return _this2.isLeader;
    });
  },
  awaitLeadership: function awaitLeadership2() {
    if (
      /* _awaitLeadershipPromise */
      !this._aLP
    ) {
      this._aLP = _awaitLeadershipOnce(this);
    }
    return this._aLP;
  },
  set onduplicate(fn) {
    this._dpL = fn;
  },
  die: function die2() {
    var _this3 = this;
    this._lstns.forEach(function(listener) {
      return _this3.broadcastChannel.removeEventListener("internal", listener);
    });
    this._lstns = [];
    this._unl.forEach(function(uFn) {
      return uFn.remove();
    });
    this._unl = [];
    if (this.isLeader) {
      this._hasLeader = false;
      this.isLeader = false;
    }
    this.isDead = true;
    return (0, _leaderElectionUtil.sendLeaderMessage)(this, "death");
  }
};
function _awaitLeadershipOnce(leaderElector) {
  if (leaderElector.isLeader) {
    return _util.PROMISE_RESOLVED_VOID;
  }
  return new Promise(function(res) {
    var resolved2 = false;
    function finish() {
      if (resolved2) {
        return;
      }
      resolved2 = true;
      leaderElector.broadcastChannel.removeEventListener("internal", whenDeathListener);
      res(true);
    }
    leaderElector.applyOnce().then(function() {
      if (leaderElector.isLeader) {
        finish();
      }
    });
    var tryOnFallBack = function tryOnFallBack2() {
      return (0, _util.sleep)(leaderElector._options.fallbackInterval).then(function() {
        if (leaderElector.isDead || resolved2) {
          return;
        }
        if (leaderElector.isLeader) {
          finish();
        } else {
          return leaderElector.applyOnce(true).then(function() {
            if (leaderElector.isLeader) {
              finish();
            } else {
              tryOnFallBack2();
            }
          });
        }
      });
    };
    tryOnFallBack();
    var whenDeathListener = function whenDeathListener2(msg) {
      if (msg.context === "leader" && msg.action === "death") {
        leaderElector._hasLeader = false;
        leaderElector.applyOnce().then(function() {
          if (leaderElector.isLeader) {
            finish();
          }
        });
      }
    };
    leaderElector.broadcastChannel.addEventListener("internal", whenDeathListener);
    leaderElector._lstns.push(whenDeathListener);
  });
}
function fillOptionsWithDefaults(options2, channel) {
  if (!options2)
    options2 = {};
  options2 = JSON.parse(JSON.stringify(options2));
  if (!options2.fallbackInterval) {
    options2.fallbackInterval = 3e3;
  }
  if (!options2.responseTime) {
    options2.responseTime = channel.method.averageResponseTime(channel.options);
  }
  return options2;
}
function createLeaderElection(channel, options2) {
  if (channel._leaderElector) {
    throw new Error("BroadcastChannel already has a leader-elector");
  }
  options2 = fillOptionsWithDefaults(options2, channel);
  var elector = (0, _util.supportsWebLockAPI)() ? new _leaderElectionWebLock.LeaderElectionWebLock(channel, options2) : new LeaderElection(channel, options2);
  channel._befC.push(function() {
    return elector.die();
  });
  channel._leaderElector = elector;
  return elector;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BroadcastChannel", {
    enumerable: true,
    get: function get() {
      return _broadcastChannel2.BroadcastChannel;
    }
  });
  Object.defineProperty(exports, "OPEN_BROADCAST_CHANNELS", {
    enumerable: true,
    get: function get() {
      return _broadcastChannel2.OPEN_BROADCAST_CHANNELS;
    }
  });
  Object.defineProperty(exports, "beLeader", {
    enumerable: true,
    get: function get() {
      return _leaderElectionUtil2.beLeader;
    }
  });
  Object.defineProperty(exports, "clearNodeFolder", {
    enumerable: true,
    get: function get() {
      return _broadcastChannel2.clearNodeFolder;
    }
  });
  Object.defineProperty(exports, "createLeaderElection", {
    enumerable: true,
    get: function get() {
      return _leaderElection.createLeaderElection;
    }
  });
  Object.defineProperty(exports, "enforceOptions", {
    enumerable: true,
    get: function get() {
      return _broadcastChannel2.enforceOptions;
    }
  });
  var _broadcastChannel2 = broadcastChannel;
  var _leaderElection = leaderElection;
  var _leaderElectionUtil2 = leaderElectionUtil;
})(es5node);
Object.defineProperty(rxStorageMultiinstance, "__esModule", {
  value: true
});
rxStorageMultiinstance.BROADCAST_CHANNEL_BY_TOKEN = void 0;
rxStorageMultiinstance.addRxStorageMultiInstanceSupport = addRxStorageMultiInstanceSupport;
rxStorageMultiinstance.getBroadcastChannelReference = getBroadcastChannelReference;
rxStorageMultiinstance.removeBroadcastChannelReference = removeBroadcastChannelReference;
var _rxjs$6 = cjs;
var _operators$5 = operators;
var _broadcastChannel = es5node;
var BROADCAST_CHANNEL_BY_TOKEN = /* @__PURE__ */ new Map();
rxStorageMultiinstance.BROADCAST_CHANNEL_BY_TOKEN = BROADCAST_CHANNEL_BY_TOKEN;
function getBroadcastChannelReference(databaseInstanceToken, databaseName, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    state = {
      /**
       * We have to use the databaseName instead of the databaseInstanceToken
       * in the BroadcastChannel name because different instances must end with the same
       * channel name to be able to broadcast messages between each other.
       */
      bc: new _broadcastChannel.BroadcastChannel("RxDB:" + databaseName),
      refs: /* @__PURE__ */ new Set()
    };
    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);
  }
  state.refs.add(refObject);
  return state.bc;
}
function removeBroadcastChannelReference(databaseInstanceToken, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    return;
  }
  state.refs.delete(refObject);
  if (state.refs.size === 0) {
    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);
    return state.bc.close();
  }
}
function addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance, providedBroadcastChannel) {
  if (!instanceCreationParams.multiInstance) {
    return;
  }
  var broadcastChannel2 = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);
  var changesFromOtherInstances$ = new _rxjs$6.Subject();
  var eventListener = (msg) => {
    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {
      changesFromOtherInstances$.next(msg.eventBulk);
    }
  };
  broadcastChannel2.addEventListener("message", eventListener);
  var oldChangestream$ = instance.changeStream();
  var closed = false;
  var sub = oldChangestream$.subscribe((eventBulk) => {
    if (closed) {
      return;
    }
    broadcastChannel2.postMessage({
      storageName,
      databaseName: instanceCreationParams.databaseName,
      collectionName: instanceCreationParams.collectionName,
      version: instanceCreationParams.schema.version,
      eventBulk
    });
  });
  instance.changeStream = function() {
    return changesFromOtherInstances$.asObservable().pipe((0, _operators$5.mergeWith)(oldChangestream$));
  };
  var oldClose = instance.close.bind(instance);
  instance.close = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel2.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldClose();
  };
  var oldRemove = instance.remove.bind(instance);
  instance.remove = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel2.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldRemove();
  };
}
Object.defineProperty(rxStorageInstanceDexie, "__esModule", {
  value: true
});
rxStorageInstanceDexie.RxStorageInstanceDexie = void 0;
rxStorageInstanceDexie.createDexieStorageInstance = createDexieStorageInstance;
var _rxjs$5 = cjs;
var _utils$m = utils;
var _dexieHelper$1 = dexieHelper;
var _dexieQuery = dexieQuery$1;
var _rxSchemaHelper$9 = rxSchemaHelper;
var _rxStorageHelper$a = rxStorageHelper;
var _rxStorageMultiinstance = rxStorageMultiinstance;
var _rxError$g = rxError;
var instanceId = (0, _utils$m.now)();
var RxStorageInstanceDexie = /* @__PURE__ */ function() {
  function RxStorageInstanceDexie2(storage, databaseName, collectionName, schema, internals, options2, settings) {
    this.changes$ = new _rxjs$5.Subject();
    this.instanceId = instanceId++;
    this.closed = false;
    this.storage = storage;
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.schema = schema;
    this.internals = internals;
    this.options = options2;
    this.settings = settings;
    this.primaryPath = (0, _rxSchemaHelper$9.getPrimaryFieldOfPrimaryKey)(this.schema.primaryKey);
  }
  var _proto = RxStorageInstanceDexie2.prototype;
  _proto.bulkWrite = async function bulkWrite(documentWrites, context2) {
    ensureNotClosed(this);
    documentWrites.forEach((row) => {
      if (!row.document._rev || row.previous && !row.previous._rev) {
        throw (0, _rxError$g.newRxError)("SNH", {
          args: {
            row
          }
        });
      }
    });
    var state = await this.internals;
    var ret = {
      success: {},
      error: {}
    };
    var documentKeys = documentWrites.map((writeRow) => writeRow.document[this.primaryPath]);
    var categorized;
    await state.dexieDb.transaction("rw", state.dexieTable, state.dexieDeletedTable, async () => {
      var docsInDbMap = /* @__PURE__ */ new Map();
      var docsInDbWithInternals = await (0, _dexieHelper$1.getDocsInDb)(this.internals, documentKeys);
      docsInDbWithInternals.forEach((docWithDexieInternals) => {
        var doc = docWithDexieInternals ? (0, _dexieHelper$1.fromDexieToStorage)(docWithDexieInternals) : docWithDexieInternals;
        if (doc) {
          docsInDbMap.set(doc[this.primaryPath], doc);
        }
        return doc;
      });
      categorized = (0, _rxStorageHelper$a.categorizeBulkWriteRows)(this, this.primaryPath, docsInDbMap, documentWrites, context2);
      ret.error = categorized.errors;
      var bulkPutDocs = [];
      var bulkRemoveDocs = [];
      var bulkPutDeletedDocs = [];
      var bulkRemoveDeletedDocs = [];
      categorized.bulkInsertDocs.forEach((row) => {
        var docId = row.document[this.primaryPath];
        ret.success[docId] = row.document;
        bulkPutDocs.push(row.document);
      });
      categorized.bulkUpdateDocs.forEach((row) => {
        var docId = row.document[this.primaryPath];
        ret.success[docId] = row.document;
        if (row.document._deleted && row.previous && !row.previous._deleted) {
          bulkRemoveDocs.push(docId);
          bulkPutDeletedDocs.push(row.document);
        } else if (row.document._deleted && row.previous && row.previous._deleted) {
          bulkPutDeletedDocs.push(row.document);
        } else if (!row.document._deleted) {
          bulkPutDocs.push(row.document);
        } else {
          throw (0, _rxError$g.newRxError)("SNH", {
            args: {
              row
            }
          });
        }
      });
      await Promise.all([bulkPutDocs.length > 0 ? state.dexieTable.bulkPut(bulkPutDocs.map((d) => (0, _dexieHelper$1.fromStorageToDexie)(d))) : _utils$m.PROMISE_RESOLVE_VOID, bulkRemoveDocs.length > 0 ? state.dexieTable.bulkDelete(bulkRemoveDocs) : _utils$m.PROMISE_RESOLVE_VOID, bulkPutDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkPut(bulkPutDeletedDocs.map((d) => (0, _dexieHelper$1.fromStorageToDexie)(d))) : _utils$m.PROMISE_RESOLVE_VOID, bulkRemoveDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkDelete(bulkRemoveDeletedDocs) : _utils$m.PROMISE_RESOLVE_VOID]);
    });
    categorized = (0, _utils$m.ensureNotFalsy)(categorized);
    if (categorized.eventBulk.events.length > 0) {
      var lastState = (0, _utils$m.ensureNotFalsy)(categorized.newestRow).document;
      categorized.eventBulk.checkpoint = {
        id: lastState[this.primaryPath],
        lwt: lastState._meta.lwt
      };
      var endTime = (0, _utils$m.now)();
      categorized.eventBulk.events.forEach((event) => event.endTime = endTime);
      this.changes$.next(categorized.eventBulk);
    }
    return ret;
  };
  _proto.findDocumentsById = async function findDocumentsById(ids, deleted) {
    ensureNotClosed(this);
    var state = await this.internals;
    var ret = {};
    await state.dexieDb.transaction("r", state.dexieTable, state.dexieDeletedTable, async () => {
      var docsInDb;
      if (deleted) {
        docsInDb = await (0, _dexieHelper$1.getDocsInDb)(this.internals, ids);
      } else {
        docsInDb = await state.dexieTable.bulkGet(ids);
      }
      ids.forEach((id, idx) => {
        var documentInDb = docsInDb[idx];
        if (documentInDb && (!documentInDb._deleted || deleted)) {
          ret[id] = (0, _dexieHelper$1.fromDexieToStorage)(documentInDb);
        }
      });
    });
    return ret;
  };
  _proto.query = function query2(preparedQuery) {
    ensureNotClosed(this);
    return (0, _dexieQuery.dexieQuery)(this, preparedQuery);
  };
  _proto.count = async function count2(preparedQuery) {
    if (preparedQuery.queryPlan.selectorSatisfiedByIndex) {
      var result = await (0, _dexieQuery.dexieCount)(this, preparedQuery);
      return {
        count: result,
        mode: "fast"
      };
    } else {
      var _result = await (0, _dexieQuery.dexieQuery)(this, preparedQuery);
      return {
        count: _result.documents.length,
        mode: "slow"
      };
    }
  };
  _proto.getChangedDocumentsSince = async function getChangedDocumentsSince(limit2, checkpoint2) {
    ensureNotClosed(this);
    var sinceLwt = checkpoint2 ? checkpoint2.lwt : _utils$m.RX_META_LWT_MINIMUM;
    var sinceId = checkpoint2 ? checkpoint2.id : "";
    var state = await this.internals;
    var [changedDocsNormal, changedDocsDeleted] = await Promise.all([state.dexieTable, state.dexieDeletedTable].map(async (table) => {
      var query2 = table.where("[_meta.lwt+" + this.primaryPath + "]").above([sinceLwt, sinceId]).limit(limit2);
      var changedDocuments = await query2.toArray();
      return changedDocuments.map((d) => (0, _dexieHelper$1.fromDexieToStorage)(d));
    }));
    var changedDocs = changedDocsNormal.slice(0);
    (0, _utils$m.appendToArray)(changedDocs, changedDocsDeleted);
    changedDocs = (0, _utils$m.sortDocumentsByLastWriteTime)(this.primaryPath, changedDocs);
    changedDocs = changedDocs.slice(0, limit2);
    var lastDoc = (0, _utils$m.lastOfArray)(changedDocs);
    return {
      documents: changedDocs,
      checkpoint: lastDoc ? {
        id: lastDoc[this.primaryPath],
        lwt: lastDoc._meta.lwt
      } : checkpoint2 ? checkpoint2 : {
        id: "",
        lwt: 0
      }
    };
  };
  _proto.remove = async function remove() {
    ensureNotClosed(this);
    var state = await this.internals;
    await Promise.all([state.dexieDeletedTable.clear(), state.dexieTable.clear()]);
    return this.close();
  };
  _proto.changeStream = function changeStream() {
    ensureNotClosed(this);
    return this.changes$.asObservable();
  };
  _proto.cleanup = async function cleanup(minimumDeletedTime) {
    ensureNotClosed(this);
    var state = await this.internals;
    await state.dexieDb.transaction("rw", state.dexieDeletedTable, async () => {
      var maxDeletionTime = (0, _utils$m.now)() - minimumDeletedTime;
      var toRemove = await state.dexieDeletedTable.where("_meta.lwt").below(maxDeletionTime).toArray();
      var removeIds = toRemove.map((doc) => doc[this.primaryPath]);
      await state.dexieDeletedTable.bulkDelete(removeIds);
    });
    return true;
  };
  _proto.getAttachmentData = function getAttachmentData(_documentId, _attachmentId, _digest) {
    ensureNotClosed(this);
    throw new Error("Attachments are not implemented in the dexie RxStorage. Make a pull request.");
  };
  _proto.close = function close3() {
    ensureNotClosed(this);
    this.closed = true;
    this.changes$.complete();
    (0, _dexieHelper$1.closeDexieDb)(this.internals);
    return _utils$m.PROMISE_RESOLVE_VOID;
  };
  _proto.conflictResultionTasks = function conflictResultionTasks() {
    return new _rxjs$5.Subject();
  };
  _proto.resolveConflictResultionTask = async function resolveConflictResultionTask(_taskSolution) {
  };
  return RxStorageInstanceDexie2;
}();
rxStorageInstanceDexie.RxStorageInstanceDexie = RxStorageInstanceDexie;
function createDexieStorageInstance(storage, params, settings) {
  var internals = (0, _dexieHelper$1.getDexieDbWithTables)(params.databaseName, params.collectionName, settings, params.schema);
  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings);
  (0, _rxStorageMultiinstance.addRxStorageMultiInstanceSupport)(_dexieHelper$1.RX_STORAGE_NAME_DEXIE, params, instance);
  return Promise.resolve(instance);
}
function ensureNotClosed(instance) {
  if (instance.closed) {
    throw new Error("RxStorageInstanceDexie is closed " + instance.databaseName + "-" + instance.collectionName);
  }
}
Object.defineProperty(rxStorageDexie, "__esModule", {
  value: true
});
rxStorageDexie.RxStorageDexie = void 0;
rxStorageDexie.getRxStorageDexie = getRxStorageDexie;
var _dexieHelper = dexieHelper;
var _rxStorageInstanceDexie = rxStorageInstanceDexie;
var _rxStorageHelper$9 = rxStorageHelper;
var RxStorageDexie = /* @__PURE__ */ function() {
  function RxStorageDexie2(settings) {
    this.name = _dexieHelper.RX_STORAGE_NAME_DEXIE;
    this.statics = _dexieHelper.RxStorageDexieStatics;
    this.settings = settings;
  }
  var _proto = RxStorageDexie2.prototype;
  _proto.createStorageInstance = function createStorageInstance(params) {
    (0, _rxStorageHelper$9.ensureRxStorageInstanceParamsAreCorrect)(params);
    (0, _dexieHelper.ensureNoBooleanIndex)(params.schema);
    return (0, _rxStorageInstanceDexie.createDexieStorageInstance)(this, params, this.settings);
  };
  return RxStorageDexie2;
}();
rxStorageDexie.RxStorageDexie = RxStorageDexie;
function getRxStorageDexie(settings = {}) {
  var storage = new RxStorageDexie(settings);
  return storage;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _rxStorageDexie = rxStorageDexie;
  Object.keys(_rxStorageDexie).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageDexie[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageDexie[key];
      }
    });
  });
  var _rxStorageInstanceDexie2 = rxStorageInstanceDexie;
  Object.keys(_rxStorageInstanceDexie2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageInstanceDexie2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageInstanceDexie2[key];
      }
    });
  });
  var _dexieHelper2 = dexieHelper;
  Object.keys(_dexieHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _dexieHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _dexieHelper2[key];
      }
    });
  });
  var _dexieQuery2 = dexieQuery$1;
  Object.keys(_dexieQuery2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _dexieQuery2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _dexieQuery2[key];
      }
    });
  });
})(storageDexie);
const messages = {
  AbortError: "A request was aborted, for example through a call to IDBTransaction.abort.",
  ConstraintError: "A mutation operation in the transaction failed because a constraint was not satisfied. For example, an object such as an object store or index already exists and a request attempted to create a new one.",
  DataCloneError: "The data being stored could not be cloned by the internal structured cloning algorithm.",
  DataError: "Data provided to an operation does not meet requirements.",
  InvalidAccessError: "An invalid operation was performed on an object. For example transaction creation attempt was made, but an empty scope was provided.",
  InvalidStateError: "An operation was called on an object on which it is not allowed or at a time when it is not allowed. Also occurs if a request is made on a source object that has been deleted or removed. Use TransactionInactiveError or ReadOnlyError when possible, as they are more specific variations of InvalidStateError.",
  NotFoundError: "The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.",
  ReadOnlyError: 'The mutating operation was attempted in a "readonly" transaction.',
  TransactionInactiveError: "A request was placed against a transaction which is currently not active, or which is finished.",
  VersionError: "An attempt was made to open a database using a lower version than the existing version."
};
class AbortError extends Error {
  constructor(message = messages.AbortError) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
}
class ConstraintError extends Error {
  constructor(message = messages.ConstraintError) {
    super();
    this.name = "ConstraintError";
    this.message = message;
  }
}
class DataCloneError extends Error {
  constructor(message = messages.DataCloneError) {
    super();
    this.name = "DataCloneError";
    this.message = message;
  }
}
class DataError extends Error {
  constructor(message = messages.DataError) {
    super();
    this.name = "DataError";
    this.message = message;
  }
}
class InvalidAccessError extends Error {
  constructor(message = messages.InvalidAccessError) {
    super();
    this.name = "InvalidAccessError";
    this.message = message;
  }
}
class InvalidStateError extends Error {
  constructor(message = messages.InvalidStateError) {
    super();
    this.name = "InvalidStateError";
    this.message = message;
  }
}
class NotFoundError extends Error {
  constructor(message = messages.NotFoundError) {
    super();
    this.name = "NotFoundError";
    this.message = message;
  }
}
class ReadOnlyError extends Error {
  constructor(message = messages.ReadOnlyError) {
    super();
    this.name = "ReadOnlyError";
    this.message = message;
  }
}
class TransactionInactiveError extends Error {
  constructor(message = messages.TransactionInactiveError) {
    super();
    this.name = "TransactionInactiveError";
    this.message = message;
  }
}
class VersionError extends Error {
  constructor(message = messages.VersionError) {
    super();
    this.name = "VersionError";
    this.message = message;
  }
}
const valueToKey = (input, seen) => {
  if (typeof input === "number") {
    if (isNaN(input)) {
      throw new DataError();
    }
    return input;
  } else if (input instanceof Date) {
    const ms = input.valueOf();
    if (isNaN(ms)) {
      throw new DataError();
    }
    return new Date(ms);
  } else if (typeof input === "string") {
    return input;
  } else if (input instanceof ArrayBuffer || typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView && ArrayBuffer.isView(input)) {
    if (input instanceof ArrayBuffer) {
      return new Uint8Array(input).buffer;
    }
    return new Uint8Array(input.buffer).buffer;
  } else if (Array.isArray(input)) {
    if (seen === void 0) {
      seen = /* @__PURE__ */ new Set();
    } else if (seen.has(input)) {
      throw new DataError();
    }
    seen.add(input);
    const keys2 = [];
    for (let i = 0; i < input.length; i++) {
      const hop = input.hasOwnProperty(i);
      if (!hop) {
        throw new DataError();
      }
      const entry = input[i];
      const key = valueToKey(entry, seen);
      keys2.push(key);
    }
    return keys2;
  } else {
    throw new DataError();
  }
};
const getType = (x) => {
  if (typeof x === "number") {
    return "Number";
  }
  if (x instanceof Date) {
    return "Date";
  }
  if (Array.isArray(x)) {
    return "Array";
  }
  if (typeof x === "string") {
    return "String";
  }
  if (x instanceof ArrayBuffer) {
    return "Binary";
  }
  throw new DataError();
};
const cmp = (first2, second2) => {
  if (second2 === void 0) {
    throw new TypeError();
  }
  first2 = valueToKey(first2);
  second2 = valueToKey(second2);
  const t1 = getType(first2);
  const t2 = getType(second2);
  if (t1 !== t2) {
    if (t1 === "Array") {
      return 1;
    }
    if (t1 === "Binary" && (t2 === "String" || t2 === "Date" || t2 === "Number")) {
      return 1;
    }
    if (t1 === "String" && (t2 === "Date" || t2 === "Number")) {
      return 1;
    }
    if (t1 === "Date" && t2 === "Number") {
      return 1;
    }
    return -1;
  }
  if (t1 === "Binary") {
    first2 = new Uint8Array(first2);
    second2 = new Uint8Array(second2);
  }
  if (t1 === "Array" || t1 === "Binary") {
    const length = Math.min(first2.length, second2.length);
    for (let i = 0; i < length; i++) {
      const result = cmp(first2[i], second2[i]);
      if (result !== 0) {
        return result;
      }
    }
    if (first2.length > second2.length) {
      return 1;
    }
    if (first2.length < second2.length) {
      return -1;
    }
    return 0;
  }
  if (t1 === "Date") {
    if (first2.getTime() === second2.getTime()) {
      return 0;
    }
  } else {
    if (first2 === second2) {
      return 0;
    }
  }
  return first2 > second2 ? 1 : -1;
};
class FDBKeyRange {
  static only(value) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    value = valueToKey(value);
    return new FDBKeyRange(value, value, false, false);
  }
  static lowerBound(lower, open = false) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    lower = valueToKey(lower);
    return new FDBKeyRange(lower, void 0, open, true);
  }
  static upperBound(upper, open = false) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    upper = valueToKey(upper);
    return new FDBKeyRange(void 0, upper, true, open);
  }
  static bound(lower, upper, lowerOpen = false, upperOpen = false) {
    if (arguments.length < 2) {
      throw new TypeError();
    }
    const cmpResult = cmp(lower, upper);
    if (cmpResult === 1 || cmpResult === 0 && (lowerOpen || upperOpen)) {
      throw new DataError();
    }
    lower = valueToKey(lower);
    upper = valueToKey(upper);
    return new FDBKeyRange(lower, upper, lowerOpen, upperOpen);
  }
  constructor(lower, upper, lowerOpen, upperOpen) {
    this.lower = lower;
    this.upper = upper;
    this.lowerOpen = lowerOpen;
    this.upperOpen = upperOpen;
  }
  // https://w3c.github.io/IndexedDB/#dom-idbkeyrange-includes
  includes(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    key = valueToKey(key);
    if (this.lower !== void 0) {
      const cmpResult = cmp(this.lower, key);
      if (cmpResult === 1 || cmpResult === 0 && this.lowerOpen) {
        return false;
      }
    }
    if (this.upper !== void 0) {
      const cmpResult = cmp(this.upper, key);
      if (cmpResult === -1 || cmpResult === 0 && this.upperOpen) {
        return false;
      }
    }
    return true;
  }
  toString() {
    return "[object IDBKeyRange]";
  }
}
const extractKey = (keyPath, value) => {
  if (Array.isArray(keyPath)) {
    const result = [];
    for (let item of keyPath) {
      if (item !== void 0 && item !== null && typeof item !== "string" && item.toString) {
        item = item.toString();
      }
      result.push(valueToKey(extractKey(item, value)));
    }
    return result;
  }
  if (keyPath === "") {
    return value;
  }
  let remainingKeyPath = keyPath;
  let object2 = value;
  while (remainingKeyPath !== null) {
    let identifier;
    const i = remainingKeyPath.indexOf(".");
    if (i >= 0) {
      identifier = remainingKeyPath.slice(0, i);
      remainingKeyPath = remainingKeyPath.slice(i + 1);
    } else {
      identifier = remainingKeyPath;
      remainingKeyPath = null;
    }
    if (object2 === void 0 || object2 === null || !object2.hasOwnProperty(identifier)) {
      return;
    }
    object2 = object2[identifier];
  }
  return object2;
};
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var dist = { exports: {} };
(function(module, exports) {
  (function(f) {
    {
      module.exports = f();
    }
  })(function() {
    return function() {
      function r(e, n, t) {
        function o(i2, f) {
          if (!n[i2]) {
            if (!e[i2]) {
              var c = "function" == typeof commonjsRequire && commonjsRequire;
              if (!f && c)
                return c(i2, true);
              if (u)
                return u(i2, true);
              var a = new Error("Cannot find module '" + i2 + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p = n[i2] = { exports: {} };
            e[i2][0].call(p.exports, function(r2) {
              var n2 = e[i2][1][r2];
              return o(n2 || r2);
            }, p, p.exports, r, e, n, t);
          }
          return n[i2].exports;
        }
        for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t.length; i++)
          o(t[i]);
        return o;
      }
      return r;
    }()({ 1: [function(_dereq_, module2, exports2) {
      var DOMException2 = _dereq_("domexception");
      var Typeson = _dereq_("typeson");
      var structuredCloningThrowing = _dereq_("typeson-registry/dist/presets/structured-cloning-throwing");
      var globalVar = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : Function("return this;")();
      if (!globalVar.DOMException) {
        globalVar.DOMException = DOMException2;
      }
      var TSON = new Typeson().register(structuredCloningThrowing);
      function realisticStructuredClone2(obj) {
        return TSON.revive(TSON.encapsulate(obj));
      }
      module2.exports = realisticStructuredClone2;
    }, { "domexception": 5, "typeson": 8, "typeson-registry/dist/presets/structured-cloning-throwing": 7 }], 2: [function(_dereq_, module2, exports2) {
      var _slicedToArray = function() {
        function sliceIterator(arr2, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr2[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr2, i) {
          if (Array.isArray(arr2)) {
            return arr2;
          } else if (Symbol.iterator in Object(arr2)) {
            return sliceIterator(arr2, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var _createClass = function() {
        function defineProperties(target, props2) {
          for (var i = 0; i < props2.length; i++) {
            var descriptor = props2[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var legacyErrorCodes = _dereq_("./legacy-error-codes.json");
      var idlUtils = _dereq_("./utils.js");
      exports2.implementation = function() {
        function DOMExceptionImpl(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), message = _ref2[0], name = _ref2[1];
          _classCallCheck(this, DOMExceptionImpl);
          this.name = name;
          this.message = message;
        }
        _createClass(DOMExceptionImpl, [{
          key: "code",
          get: function get() {
            return legacyErrorCodes[this.name] || 0;
          }
        }]);
        return DOMExceptionImpl;
      }();
      exports2.init = function(impl) {
        if (Error.captureStackTrace) {
          var wrapper = idlUtils.wrapperForImpl(impl);
          Error.captureStackTrace(wrapper, wrapper.constructor);
        }
      };
    }, { "./legacy-error-codes.json": 4, "./utils.js": 6 }], 3: [function(_dereq_, module2, exports2) {
      var conversions = _dereq_("webidl-conversions");
      var utils2 = _dereq_("./utils.js");
      var impl = utils2.implSymbol;
      function DOMException2() {
        var args2 = [];
        for (var i = 0; i < arguments.length && i < 2; ++i) {
          args2[i] = arguments[i];
        }
        if (args2[0] !== void 0) {
          args2[0] = conversions["DOMString"](args2[0], { context: "Failed to construct 'DOMException': parameter 1" });
        } else {
          args2[0] = "";
        }
        if (args2[1] !== void 0) {
          args2[1] = conversions["DOMString"](args2[1], { context: "Failed to construct 'DOMException': parameter 2" });
        } else {
          args2[1] = "Error";
        }
        iface.setup(this, args2);
      }
      Object.defineProperty(DOMException2, "prototype", {
        value: DOMException2.prototype,
        writable: false,
        enumerable: false,
        configurable: false
      });
      Object.defineProperty(DOMException2.prototype, "name", {
        get: function get() {
          return this[impl]["name"];
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(DOMException2.prototype, "message", {
        get: function get() {
          return this[impl]["message"];
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(DOMException2.prototype, "code", {
        get: function get() {
          return this[impl]["code"];
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(DOMException2, "INDEX_SIZE_ERR", {
        value: 1,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INDEX_SIZE_ERR", {
        value: 1,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "DOMSTRING_SIZE_ERR", {
        value: 2,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "DOMSTRING_SIZE_ERR", {
        value: 2,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "HIERARCHY_REQUEST_ERR", {
        value: 3,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "HIERARCHY_REQUEST_ERR", {
        value: 3,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "WRONG_DOCUMENT_ERR", {
        value: 4,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "WRONG_DOCUMENT_ERR", {
        value: 4,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_CHARACTER_ERR", {
        value: 5,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_CHARACTER_ERR", {
        value: 5,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NO_DATA_ALLOWED_ERR", {
        value: 6,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NO_DATA_ALLOWED_ERR", {
        value: 6,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NO_MODIFICATION_ALLOWED_ERR", {
        value: 7,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NO_MODIFICATION_ALLOWED_ERR", {
        value: 7,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NOT_FOUND_ERR", {
        value: 8,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NOT_FOUND_ERR", {
        value: 8,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NOT_SUPPORTED_ERR", {
        value: 9,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NOT_SUPPORTED_ERR", {
        value: 9,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INUSE_ATTRIBUTE_ERR", {
        value: 10,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INUSE_ATTRIBUTE_ERR", {
        value: 10,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_STATE_ERR", {
        value: 11,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_STATE_ERR", {
        value: 11,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "SYNTAX_ERR", {
        value: 12,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "SYNTAX_ERR", {
        value: 12,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_MODIFICATION_ERR", {
        value: 13,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_MODIFICATION_ERR", {
        value: 13,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NAMESPACE_ERR", {
        value: 14,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NAMESPACE_ERR", {
        value: 14,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_ACCESS_ERR", {
        value: 15,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_ACCESS_ERR", {
        value: 15,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "VALIDATION_ERR", {
        value: 16,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "VALIDATION_ERR", {
        value: 16,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "TYPE_MISMATCH_ERR", {
        value: 17,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "TYPE_MISMATCH_ERR", {
        value: 17,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "SECURITY_ERR", {
        value: 18,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "SECURITY_ERR", {
        value: 18,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NETWORK_ERR", {
        value: 19,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NETWORK_ERR", {
        value: 19,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "ABORT_ERR", {
        value: 20,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "ABORT_ERR", {
        value: 20,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "URL_MISMATCH_ERR", {
        value: 21,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "URL_MISMATCH_ERR", {
        value: 21,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "QUOTA_EXCEEDED_ERR", {
        value: 22,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "QUOTA_EXCEEDED_ERR", {
        value: 22,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "TIMEOUT_ERR", {
        value: 23,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "TIMEOUT_ERR", {
        value: 23,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_NODE_TYPE_ERR", {
        value: 24,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_NODE_TYPE_ERR", {
        value: 24,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "DATA_CLONE_ERR", {
        value: 25,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "DATA_CLONE_ERR", {
        value: 25,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, Symbol.toStringTag, {
        value: "DOMException",
        writable: false,
        enumerable: false,
        configurable: true
      });
      var iface = {
        mixedInto: [],
        is: function is(obj) {
          if (obj) {
            if (obj[impl] instanceof Impl.implementation) {
              return true;
            }
            for (var i = 0; i < module2.exports.mixedInto.length; ++i) {
              if (obj instanceof module2.exports.mixedInto[i]) {
                return true;
              }
            }
          }
          return false;
        },
        isImpl: function isImpl(obj) {
          if (obj) {
            if (obj instanceof Impl.implementation) {
              return true;
            }
            var wrapper = utils2.wrapperForImpl(obj);
            for (var i = 0; i < module2.exports.mixedInto.length; ++i) {
              if (wrapper instanceof module2.exports.mixedInto[i]) {
                return true;
              }
            }
          }
          return false;
        },
        convert: function convert2(obj) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$context = _ref.context, context2 = _ref$context === void 0 ? "The provided value" : _ref$context;
          if (module2.exports.is(obj)) {
            return utils2.implForWrapper(obj);
          }
          throw new TypeError(context2 + " is not of type 'DOMException'.");
        },
        create: function create2(constructorArgs, privateData) {
          var obj = Object.create(DOMException2.prototype);
          this.setup(obj, constructorArgs, privateData);
          return obj;
        },
        createImpl: function createImpl(constructorArgs, privateData) {
          var obj = Object.create(DOMException2.prototype);
          this.setup(obj, constructorArgs, privateData);
          return utils2.implForWrapper(obj);
        },
        _internalSetup: function _internalSetup(obj) {
        },
        setup: function setup(obj, constructorArgs, privateData) {
          if (!privateData)
            privateData = {};
          privateData.wrapper = obj;
          this._internalSetup(obj);
          Object.defineProperty(obj, impl, {
            value: new Impl.implementation(constructorArgs, privateData),
            writable: false,
            enumerable: false,
            configurable: true
          });
          obj[impl][utils2.wrapperSymbol] = obj;
          if (Impl.init) {
            Impl.init(obj[impl], privateData);
          }
        },
        interface: DOMException2,
        expose: {
          Window: { DOMException: DOMException2 },
          Worker: { DOMException: DOMException2 }
        }
      };
      module2.exports = iface;
      var Impl = _dereq_(".//DOMException-impl.js");
    }, { ".//DOMException-impl.js": 2, "./utils.js": 6, "webidl-conversions": 9 }], 4: [function(_dereq_, module2, exports2) {
      module2.exports = {
        "IndexSizeError": 1,
        "DOMStringSizeError": 2,
        "HierarchyRequestError": 3,
        "WrongDocumentError": 4,
        "InvalidCharacterError": 5,
        "NoDataAllowedError": 6,
        "NoModificationAllowedError": 7,
        "NotFoundError": 8,
        "NotSupportedError": 9,
        "InUseAttributeError": 10,
        "InvalidStateError": 11,
        "SyntaxError": 12,
        "InvalidModificationError": 13,
        "NamespaceError": 14,
        "InvalidAccessError": 15,
        "ValidationError": 16,
        "TypeMismatchError": 17,
        "SecurityError": 18,
        "NetworkError": 19,
        "AbortError": 20,
        "URLMismatchError": 21,
        "QuotaExceededError": 22,
        "TimeoutError": 23,
        "InvalidNodeTypeError": 24,
        "DataCloneError": 25
      };
    }, {}], 5: [function(_dereq_, module2, exports2) {
      module2.exports = _dereq_("./DOMException").interface;
      Object.setPrototypeOf(module2.exports.prototype, Error.prototype);
    }, { "./DOMException": 3 }], 6: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function isObject2(value) {
        return (typeof value === "undefined" ? "undefined" : _typeof2(value)) === "object" && value !== null || typeof value === "function";
      }
      function getReferenceToBytes(bufferSource) {
        if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {
          return bufferSource;
        }
        if (bufferSource instanceof ArrayBuffer) {
          return Buffer.from(bufferSource);
        }
        return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);
      }
      function getCopyToBytes(bufferSource) {
        return Buffer.from(getReferenceToBytes(bufferSource));
      }
      function mixin(target, source) {
        var keys2 = Object.getOwnPropertyNames(source);
        for (var i = 0; i < keys2.length; ++i) {
          if (keys2[i] in target) {
            continue;
          }
          Object.defineProperty(target, keys2[i], Object.getOwnPropertyDescriptor(source, keys2[i]));
        }
      }
      var wrapperSymbol = Symbol("wrapper");
      var implSymbol = Symbol("impl");
      var sameObjectCaches = Symbol("SameObject caches");
      function getSameObject(wrapper, prop, creator) {
        if (!wrapper[sameObjectCaches]) {
          wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
        }
        if (prop in wrapper[sameObjectCaches]) {
          return wrapper[sameObjectCaches][prop];
        }
        wrapper[sameObjectCaches][prop] = creator();
        return wrapper[sameObjectCaches][prop];
      }
      function wrapperForImpl(impl) {
        return impl ? impl[wrapperSymbol] : null;
      }
      function implForWrapper(wrapper) {
        return wrapper ? wrapper[implSymbol] : null;
      }
      function tryWrapperForImpl(impl) {
        var wrapper = wrapperForImpl(impl);
        return wrapper ? wrapper : impl;
      }
      function tryImplForWrapper(wrapper) {
        var impl = implForWrapper(wrapper);
        return impl ? impl : wrapper;
      }
      var iterInternalSymbol = Symbol("internal");
      var IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
      module2.exports = {
        isObject: isObject2,
        getReferenceToBytes,
        getCopyToBytes,
        mixin,
        wrapperSymbol,
        implSymbol,
        getSameObject,
        wrapperForImpl,
        implForWrapper,
        tryWrapperForImpl,
        tryImplForWrapper,
        iterInternalSymbol,
        IteratorPrototype
      };
    }, {}], 7: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      !function(e, t) {
        "object" == (typeof exports2 === "undefined" ? "undefined" : _typeof2(exports2)) && "undefined" != typeof module2 ? module2.exports = t() : ((e = "undefined" != typeof globalThis ? globalThis : e || self).Typeson = e.Typeson || {}, e.Typeson.presets = e.Typeson.presets || {}, e.Typeson.presets.structuredCloningThrowing = t());
      }(void 0, function() {
        function _typeof$12(e2) {
          return (_typeof$12 = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function(e3) {
            return typeof e3 === "undefined" ? "undefined" : _typeof2(e3);
          } : function(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3 === "undefined" ? "undefined" : _typeof2(e3);
          })(e2);
        }
        function _classCallCheck$1(e2, t2) {
          if (!(e2 instanceof t2))
            throw new TypeError("Cannot call a class as a function");
        }
        function _defineProperties$1(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
          }
        }
        function _defineProperty$1(e2, t2, r2) {
          return t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
        }
        function ownKeys$1(e2, t2) {
          var r2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), r2.push.apply(r2, n2);
          }
          return r2;
        }
        function _toConsumableArray$1(e2) {
          return function _arrayWithoutHoles$1(e3) {
            if (Array.isArray(e3))
              return _arrayLikeToArray$1(e3);
          }(e2) || function _iterableToArray$1(e3) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3))
              return Array.from(e3);
          }(e2) || function _unsupportedIterableToArray$1(e3, t2) {
            if (!e3)
              return;
            if ("string" == typeof e3)
              return _arrayLikeToArray$1(e3, t2);
            var r2 = Object.prototype.toString.call(e3).slice(8, -1);
            "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
            if ("Map" === r2 || "Set" === r2)
              return Array.from(e3);
            if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
              return _arrayLikeToArray$1(e3, t2);
          }(e2) || function _nonIterableSpread$1() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function _arrayLikeToArray$1(e2, t2) {
          (null == t2 || t2 > e2.length) && (t2 = e2.length);
          for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++) {
            n2[r2] = e2[r2];
          }
          return n2;
        }
        function _typeof3(e2) {
          return (_typeof3 = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function _typeof4(e3) {
            return typeof e3 === "undefined" ? "undefined" : _typeof2(e3);
          } : function _typeof4(e3) {
            return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3 === "undefined" ? "undefined" : _typeof2(e3);
          })(e2);
        }
        function _classCallCheck(e2, t2) {
          if (!(e2 instanceof t2))
            throw new TypeError("Cannot call a class as a function");
        }
        function _defineProperties(e2, t2) {
          for (var r2 = 0; r2 < t2.length; r2++) {
            var n2 = t2[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
          }
        }
        function _defineProperty(e2, t2, r2) {
          return t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
        }
        function ownKeys(e2, t2) {
          var r2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), r2.push.apply(r2, n2);
          }
          return r2;
        }
        function _objectSpread2(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var r2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? ownKeys(Object(r2), true).forEach(function(t3) {
              _defineProperty(e2, t3, r2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : ownKeys(Object(r2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
            });
          }
          return e2;
        }
        function _slicedToArray(e2, t2) {
          return function _arrayWithHoles(e3) {
            if (Array.isArray(e3))
              return e3;
          }(e2) || function _iterableToArrayLimit(e3, t3) {
            if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e3)))
              return;
            var r2 = [], n2 = true, i2 = false, o2 = void 0;
            try {
              for (var a2, c2 = e3[Symbol.iterator](); !(n2 = (a2 = c2.next()).done) && (r2.push(a2.value), !t3 || r2.length !== t3); n2 = true) {
              }
            } catch (e4) {
              i2 = true, o2 = e4;
            } finally {
              try {
                n2 || null == c2.return || c2.return();
              } finally {
                if (i2)
                  throw o2;
              }
            }
            return r2;
          }(e2, t2) || _unsupportedIterableToArray(e2, t2) || function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function _toConsumableArray(e2) {
          return function _arrayWithoutHoles(e3) {
            if (Array.isArray(e3))
              return _arrayLikeToArray(e3);
          }(e2) || function _iterableToArray(e3) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3))
              return Array.from(e3);
          }(e2) || _unsupportedIterableToArray(e2) || function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function _unsupportedIterableToArray(e2, t2) {
          if (e2) {
            if ("string" == typeof e2)
              return _arrayLikeToArray(e2, t2);
            var r2 = Object.prototype.toString.call(e2).slice(8, -1);
            return "Object" === r2 && e2.constructor && (r2 = e2.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(e2) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? _arrayLikeToArray(e2, t2) : void 0;
          }
        }
        function _arrayLikeToArray(e2, t2) {
          (null == t2 || t2 > e2.length) && (t2 = e2.length);
          for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++) {
            n2[r2] = e2[r2];
          }
          return n2;
        }
        var e = function TypesonPromise(e2) {
          _classCallCheck(this, TypesonPromise), this.p = new Promise(e2);
        };
        e.__typeson__type__ = "TypesonPromise", "undefined" != typeof Symbol && (e.prototype[Symbol.toStringTag] = "TypesonPromise"), e.prototype.then = function(t2, r2) {
          var n2 = this;
          return new e(function(e2, i2) {
            n2.p.then(function(r3) {
              e2(t2 ? t2(r3) : r3);
            }).catch(function(e3) {
              return r2 ? r2(e3) : Promise.reject(e3);
            }).then(e2, i2);
          });
        }, e.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, e.resolve = function(t2) {
          return new e(function(e2) {
            e2(t2);
          });
        }, e.reject = function(t2) {
          return new e(function(e2, r2) {
            r2(t2);
          });
        }, ["all", "race"].forEach(function(t2) {
          e[t2] = function(r2) {
            return new e(function(e2, n2) {
              Promise[t2](r2.map(function(e3) {
                return e3 && e3.constructor && "TypesonPromise" === e3.constructor.__typeson__type__ ? e3.p : e3;
              })).then(e2, n2);
            });
          };
        });
        var t = {}.toString, r = {}.hasOwnProperty, n = Object.getPrototypeOf, i = r.toString;
        function isThenable(e2, t2) {
          return isObject2(e2) && "function" == typeof e2.then && (!t2 || "function" == typeof e2.catch);
        }
        function toStringTag2(e2) {
          return t.call(e2).slice(8, -1);
        }
        function hasConstructorOf(e2, t2) {
          if (!e2 || "object" !== _typeof3(e2))
            return false;
          var o2 = n(e2);
          if (!o2)
            return null === t2;
          var a2 = r.call(o2, "constructor") && o2.constructor;
          return "function" != typeof a2 ? null === t2 : t2 === a2 || null !== t2 && i.call(a2) === i.call(t2) || "function" == typeof t2 && "string" == typeof a2.__typeson__type__ && a2.__typeson__type__ === t2.__typeson__type__;
        }
        function isPlainObject(e2) {
          return !(!e2 || "Object" !== toStringTag2(e2)) && (!n(e2) || hasConstructorOf(e2, Object));
        }
        function isObject2(e2) {
          return e2 && "object" === _typeof3(e2);
        }
        function escapeKeyPathComponent(e2) {
          return e2.replace(/~/g, "~0").replace(/\./g, "~1");
        }
        function unescapeKeyPathComponent(e2) {
          return e2.replace(/~1/g, ".").replace(/~0/g, "~");
        }
        function getByKeyPath2(e2, t2) {
          if ("" === t2)
            return e2;
          var r2 = t2.indexOf(".");
          if (r2 > -1) {
            var n2 = e2[unescapeKeyPathComponent(t2.slice(0, r2))];
            return void 0 === n2 ? void 0 : getByKeyPath2(n2, t2.slice(r2 + 1));
          }
          return e2[unescapeKeyPathComponent(t2)];
        }
        function setAtKeyPath(e2, t2, r2) {
          if ("" === t2)
            return r2;
          var n2 = t2.indexOf(".");
          return n2 > -1 ? setAtKeyPath(e2[unescapeKeyPathComponent(t2.slice(0, n2))], t2.slice(n2 + 1), r2) : (e2[unescapeKeyPathComponent(t2)] = r2, e2);
        }
        function _await(e2, t2, r2) {
          return r2 ? t2 ? t2(e2) : e2 : (e2 && e2.then || (e2 = Promise.resolve(e2)), t2 ? e2.then(t2) : e2);
        }
        var o = Object.keys, a = Array.isArray, c = {}.hasOwnProperty, u = ["type", "replaced", "iterateIn", "iterateUnsetNumeric"];
        function _async(e2) {
          return function() {
            for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) {
              t2[r2] = arguments[r2];
            }
            try {
              return Promise.resolve(e2.apply(this, t2));
            } catch (e3) {
              return Promise.reject(e3);
            }
          };
        }
        function nestedPathsFirst(e2, t2) {
          if ("" === e2.keypath)
            return -1;
          var r2 = e2.keypath.match(/\./g) || 0, n2 = t2.keypath.match(/\./g) || 0;
          return r2 && (r2 = r2.length), n2 && (n2 = n2.length), r2 > n2 ? -1 : r2 < n2 ? 1 : e2.keypath < t2.keypath ? -1 : e2.keypath > t2.keypath;
        }
        var s = function() {
          function Typeson(e2) {
            _classCallCheck(this, Typeson), this.options = e2, this.plainObjectReplacers = [], this.nonplainObjectReplacers = [], this.revivers = {}, this.types = {};
          }
          return function _createClass(e2, t2, r2) {
            return t2 && _defineProperties(e2.prototype, t2), r2 && _defineProperties(e2, r2), e2;
          }(Typeson, [{ key: "stringify", value: function stringify2(e2, t2, r2, n2) {
            n2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this.options), n2), {}, { stringification: true });
            var i2 = this.encapsulate(e2, null, n2);
            return a(i2) ? JSON.stringify(i2[0], t2, r2) : i2.then(function(e3) {
              return JSON.stringify(e3, t2, r2);
            });
          } }, { key: "stringifySync", value: function stringifySync(e2, t2, r2, n2) {
            return this.stringify(e2, t2, r2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, n2), {}, { sync: true }));
          } }, { key: "stringifyAsync", value: function stringifyAsync(e2, t2, r2, n2) {
            return this.stringify(e2, t2, r2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, n2), {}, { sync: false }));
          } }, { key: "parse", value: function parse(e2, t2, r2) {
            return r2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this.options), r2), {}, { parse: true }), this.revive(JSON.parse(e2, t2), r2);
          } }, { key: "parseSync", value: function parseSync(e2, t2, r2) {
            return this.parse(e2, t2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r2), {}, { sync: true }));
          } }, { key: "parseAsync", value: function parseAsync(e2, t2, r2) {
            return this.parse(e2, t2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r2), {}, { sync: false }));
          } }, { key: "specialTypeNames", value: function specialTypeNames(e2, t2) {
            var r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return r2.returnTypeNames = true, this.encapsulate(e2, t2, r2);
          } }, { key: "rootTypeName", value: function rootTypeName(e2, t2) {
            var r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return r2.iterateNone = true, this.encapsulate(e2, t2, r2);
          } }, { key: "encapsulate", value: function encapsulate(t2, r2, n2) {
            var i2 = _async(function(t3, r3) {
              return _await(Promise.all(r3.map(function(e2) {
                return e2[1].p;
              })), function(n3) {
                return _await(Promise.all(n3.map(_async(function(n4) {
                  var o2 = false, a2 = [], c2 = _slicedToArray(r3.splice(0, 1), 1), u2 = _slicedToArray(c2[0], 7), s3 = u2[0], f3 = u2[2], l3 = u2[3], p3 = u2[4], y3 = u2[5], v3 = u2[6], b3 = _encapsulate(s3, n4, f3, l3, a2, true, v3), d3 = hasConstructorOf(b3, e);
                  return function _invoke(e2, t4) {
                    var r4 = e2();
                    return r4 && r4.then ? r4.then(t4) : t4(r4);
                  }(function() {
                    if (s3 && d3)
                      return _await(b3.p, function(e2) {
                        return p3[y3] = e2, o2 = true, i2(t3, a2);
                      });
                  }, function(e2) {
                    return o2 ? e2 : (s3 ? p3[y3] = b3 : t3 = d3 ? b3.p : b3, i2(t3, a2));
                  });
                }))), function() {
                  return t3;
                });
              });
            }), s2 = (n2 = _objectSpread2(_objectSpread2({ sync: true }, this.options), n2)).sync, f2 = this, l2 = {}, p2 = [], y2 = [], v2 = [], b2 = !("cyclic" in n2) || n2.cyclic, d2 = n2.encapsulateObserver, h2 = _encapsulate("", t2, b2, r2 || {}, v2);
            function finish(e2) {
              var t3 = Object.values(l2);
              if (n2.iterateNone)
                return t3.length ? t3[0] : Typeson.getJSONType(e2);
              if (t3.length) {
                if (n2.returnTypeNames)
                  return _toConsumableArray(new Set(t3));
                e2 && isPlainObject(e2) && !c.call(e2, "$types") ? e2.$types = l2 : e2 = { $: e2, $types: { $: l2 } };
              } else
                isObject2(e2) && c.call(e2, "$types") && (e2 = { $: e2, $types: true });
              return !n2.returnTypeNames && e2;
            }
            function _adaptBuiltinStateObjectProperties(e2, t3, r3) {
              Object.assign(e2, t3);
              var n3 = u.map(function(t4) {
                var r4 = e2[t4];
                return delete e2[t4], r4;
              });
              r3(), u.forEach(function(t4, r4) {
                e2[t4] = n3[r4];
              });
            }
            function _encapsulate(t3, r3, i3, u2, s3, v3, b3) {
              var h3, g2 = {}, m2 = _typeof3(r3), O2 = d2 ? function(n3) {
                var o2 = b3 || u2.type || Typeson.getJSONType(r3);
                d2(Object.assign(n3 || g2, { keypath: t3, value: r3, cyclic: i3, stateObj: u2, promisesData: s3, resolvingTypesonPromise: v3, awaitingTypesonPromise: hasConstructorOf(r3, e) }, { type: o2 }));
              } : null;
              if (["string", "boolean", "number", "undefined"].includes(m2))
                return void 0 === r3 || Number.isNaN(r3) || r3 === Number.NEGATIVE_INFINITY || r3 === Number.POSITIVE_INFINITY ? (h3 = u2.replaced ? r3 : replace(t3, r3, u2, s3, false, v3, O2)) !== r3 && (g2 = { replaced: h3 }) : h3 = r3, O2 && O2(), h3;
              if (null === r3)
                return O2 && O2(), r3;
              if (i3 && !u2.iterateIn && !u2.iterateUnsetNumeric && r3 && "object" === _typeof3(r3)) {
                var _2 = p2.indexOf(r3);
                if (!(_2 < 0))
                  return l2[t3] = "#", O2 && O2({ cyclicKeypath: y2[_2] }), "#" + y2[_2];
                true === i3 && (p2.push(r3), y2.push(t3));
              }
              var j2, S2 = isPlainObject(r3), T2 = a(r3), w2 = (S2 || T2) && (!f2.plainObjectReplacers.length || u2.replaced) || u2.iterateIn ? r3 : replace(t3, r3, u2, s3, S2 || T2, null, O2);
              if (w2 !== r3 ? (h3 = w2, g2 = { replaced: w2 }) : "" === t3 && hasConstructorOf(r3, e) ? (s3.push([t3, r3, i3, u2, void 0, void 0, u2.type]), h3 = r3) : T2 && "object" !== u2.iterateIn || "array" === u2.iterateIn ? (j2 = new Array(r3.length), g2 = { clone: j2 }) : (["function", "symbol"].includes(_typeof3(r3)) || "toJSON" in r3 || hasConstructorOf(r3, e) || hasConstructorOf(r3, Promise) || hasConstructorOf(r3, ArrayBuffer)) && !S2 && "object" !== u2.iterateIn ? h3 = r3 : (j2 = {}, u2.addLength && (j2.length = r3.length), g2 = { clone: j2 }), O2 && O2(), n2.iterateNone)
                return j2 || h3;
              if (!j2)
                return h3;
              if (u2.iterateIn) {
                var A2 = function _loop(n3) {
                  var o2 = { ownKeys: c.call(r3, n3) };
                  _adaptBuiltinStateObjectProperties(u2, o2, function() {
                    var o3 = t3 + (t3 ? "." : "") + escapeKeyPathComponent(n3), a2 = _encapsulate(o3, r3[n3], Boolean(i3), u2, s3, v3);
                    hasConstructorOf(a2, e) ? s3.push([o3, a2, Boolean(i3), u2, j2, n3, u2.type]) : void 0 !== a2 && (j2[n3] = a2);
                  });
                };
                for (var P2 in r3) {
                  A2(P2);
                }
                O2 && O2({ endIterateIn: true, end: true });
              } else
                o(r3).forEach(function(n3) {
                  var o2 = t3 + (t3 ? "." : "") + escapeKeyPathComponent(n3);
                  _adaptBuiltinStateObjectProperties(u2, { ownKeys: true }, function() {
                    var t4 = _encapsulate(o2, r3[n3], Boolean(i3), u2, s3, v3);
                    hasConstructorOf(t4, e) ? s3.push([o2, t4, Boolean(i3), u2, j2, n3, u2.type]) : void 0 !== t4 && (j2[n3] = t4);
                  });
                }), O2 && O2({ endIterateOwn: true, end: true });
              if (u2.iterateUnsetNumeric) {
                for (var C2 = r3.length, I2 = function _loop2(n3) {
                  if (!(n3 in r3)) {
                    var o2 = t3 + (t3 ? "." : "") + n3;
                    _adaptBuiltinStateObjectProperties(u2, { ownKeys: false }, function() {
                      var t4 = _encapsulate(o2, void 0, Boolean(i3), u2, s3, v3);
                      hasConstructorOf(t4, e) ? s3.push([o2, t4, Boolean(i3), u2, j2, n3, u2.type]) : void 0 !== t4 && (j2[n3] = t4);
                    });
                  }
                }, N2 = 0; N2 < C2; N2++) {
                  I2(N2);
                }
                O2 && O2({ endIterateUnsetNumeric: true, end: true });
              }
              return j2;
            }
            function replace(e2, t3, r3, n3, i3, o2, a2) {
              for (var c2 = i3 ? f2.plainObjectReplacers : f2.nonplainObjectReplacers, u2 = c2.length; u2--; ) {
                var p3 = c2[u2];
                if (p3.test(t3, r3)) {
                  var y3 = p3.type;
                  if (f2.revivers[y3]) {
                    var v3 = l2[e2];
                    l2[e2] = v3 ? [y3].concat(v3) : y3;
                  }
                  return Object.assign(r3, { type: y3, replaced: true }), !s2 && p3.replaceAsync || p3.replace ? (a2 && a2({ replacing: true }), _encapsulate(e2, p3[s2 || !p3.replaceAsync ? "replace" : "replaceAsync"](t3, r3), b2 && "readonly", r3, n3, o2, y3)) : (a2 && a2({ typeDetected: true }), _encapsulate(e2, t3, b2 && "readonly", r3, n3, o2, y3));
                }
              }
              return t3;
            }
            return v2.length ? s2 && n2.throwOnBadSyncType ? function() {
              throw new TypeError("Sync method requested but async result obtained");
            }() : Promise.resolve(i2(h2, v2)).then(finish) : !s2 && n2.throwOnBadSyncType ? function() {
              throw new TypeError("Async method requested but sync result obtained");
            }() : n2.stringification && s2 ? [finish(h2)] : s2 ? finish(h2) : Promise.resolve(finish(h2));
          } }, { key: "encapsulateSync", value: function encapsulateSync(e2, t2, r2) {
            return this.encapsulate(e2, t2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r2), {}, { sync: true }));
          } }, { key: "encapsulateAsync", value: function encapsulateAsync(e2, t2, r2) {
            return this.encapsulate(e2, t2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r2), {}, { sync: false }));
          } }, { key: "revive", value: function revive(t2, r2) {
            var n2 = t2 && t2.$types;
            if (!n2)
              return t2;
            if (true === n2)
              return t2.$;
            var i2 = (r2 = _objectSpread2(_objectSpread2({ sync: true }, this.options), r2)).sync, c2 = [], u2 = {}, s2 = true;
            n2.$ && isPlainObject(n2.$) && (t2 = t2.$, n2 = n2.$, s2 = false);
            var l2 = this;
            function executeReviver(e2, t3) {
              var r3 = _slicedToArray(l2.revivers[e2] || [], 1)[0];
              if (!r3)
                throw new Error("Unregistered type: " + e2);
              return i2 && !("revive" in r3) ? t3 : r3[i2 && r3.revive ? "revive" : !i2 && r3.reviveAsync ? "reviveAsync" : "revive"](t3, u2);
            }
            var p2 = [];
            function checkUndefined(e2) {
              return hasConstructorOf(e2, f) ? void 0 : e2;
            }
            var y2, v2 = function revivePlainObjects() {
              var r3 = [];
              if (Object.entries(n2).forEach(function(e2) {
                var t3 = _slicedToArray(e2, 2), i3 = t3[0], o2 = t3[1];
                "#" !== o2 && [].concat(o2).forEach(function(e3) {
                  _slicedToArray(l2.revivers[e3] || [null, {}], 2)[1].plain && (r3.push({ keypath: i3, type: e3 }), delete n2[i3]);
                });
              }), r3.length)
                return r3.sort(nestedPathsFirst).reduce(function reducer(r4, n3) {
                  var i3 = n3.keypath, o2 = n3.type;
                  if (isThenable(r4))
                    return r4.then(function(e2) {
                      return reducer(e2, { keypath: i3, type: o2 });
                    });
                  var a2 = getByKeyPath2(t2, i3);
                  if (hasConstructorOf(a2 = executeReviver(o2, a2), e))
                    return a2.then(function(e2) {
                      var r5 = setAtKeyPath(t2, i3, e2);
                      r5 === e2 && (t2 = r5);
                    });
                  var c3 = setAtKeyPath(t2, i3, a2);
                  c3 === a2 && (t2 = c3);
                }, void 0);
            }();
            return hasConstructorOf(v2, e) ? y2 = v2.then(function() {
              return t2;
            }) : (y2 = function _revive(t3, r3, i3, u3, l3) {
              if (!s2 || "$types" !== t3) {
                var y3 = n2[t3], v3 = a(r3);
                if (v3 || isPlainObject(r3)) {
                  var b2 = v3 ? new Array(r3.length) : {};
                  for (o(r3).forEach(function(n3) {
                    var o2 = _revive(t3 + (t3 ? "." : "") + escapeKeyPathComponent(n3), r3[n3], i3 || b2, b2, n3), a2 = function set2(e2) {
                      return hasConstructorOf(e2, f) ? b2[n3] = void 0 : void 0 !== e2 && (b2[n3] = e2), e2;
                    };
                    hasConstructorOf(o2, e) ? p2.push(o2.then(function(e2) {
                      return a2(e2);
                    })) : a2(o2);
                  }), r3 = b2; c2.length; ) {
                    var d2 = _slicedToArray(c2[0], 4), h2 = d2[0], g2 = d2[1], m2 = d2[2], O2 = d2[3], _2 = getByKeyPath2(h2, g2);
                    if (void 0 === _2)
                      break;
                    m2[O2] = _2, c2.splice(0, 1);
                  }
                }
                if (!y3)
                  return r3;
                if ("#" === y3) {
                  var j2 = getByKeyPath2(i3, r3.slice(1));
                  return void 0 === j2 && c2.push([i3, r3.slice(1), u3, l3]), j2;
                }
                return [].concat(y3).reduce(function reducer(t4, r4) {
                  return hasConstructorOf(t4, e) ? t4.then(function(e2) {
                    return reducer(e2, r4);
                  }) : executeReviver(r4, t4);
                }, r3);
              }
            }("", t2, null), p2.length && (y2 = e.resolve(y2).then(function(t3) {
              return e.all([t3].concat(p2));
            }).then(function(e2) {
              return _slicedToArray(e2, 1)[0];
            }))), isThenable(y2) ? i2 && r2.throwOnBadSyncType ? function() {
              throw new TypeError("Sync method requested but async result obtained");
            }() : hasConstructorOf(y2, e) ? y2.p.then(checkUndefined) : y2 : !i2 && r2.throwOnBadSyncType ? function() {
              throw new TypeError("Async method requested but sync result obtained");
            }() : i2 ? checkUndefined(y2) : Promise.resolve(checkUndefined(y2));
          } }, { key: "reviveSync", value: function reviveSync(e2, t2) {
            return this.revive(e2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, t2), {}, { sync: true }));
          } }, { key: "reviveAsync", value: function reviveAsync(e2, t2) {
            return this.revive(e2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, t2), {}, { sync: false }));
          } }, { key: "register", value: function register(e2, t2) {
            return t2 = t2 || {}, [].concat(e2).forEach(function R(e3) {
              var r2 = this;
              if (a(e3))
                return e3.map(function(e4) {
                  return R.call(r2, e4);
                });
              e3 && o(e3).forEach(function(r3) {
                if ("#" === r3)
                  throw new TypeError("# cannot be used as a type name as it is reserved for cyclic objects");
                if (Typeson.JSON_TYPES.includes(r3))
                  throw new TypeError("Plain JSON object types are reserved as type names");
                var n2 = e3[r3], i2 = n2 && n2.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers, o2 = i2.filter(function(e4) {
                  return e4.type === r3;
                });
                if (o2.length && (i2.splice(i2.indexOf(o2[0]), 1), delete this.revivers[r3], delete this.types[r3]), "function" == typeof n2) {
                  var c2 = n2;
                  n2 = { test: function test(e4) {
                    return e4 && e4.constructor === c2;
                  }, replace: function replace(e4) {
                    return _objectSpread2({}, e4);
                  }, revive: function revive(e4) {
                    return Object.assign(Object.create(c2.prototype), e4);
                  } };
                } else if (a(n2)) {
                  var u2 = _slicedToArray(n2, 3);
                  n2 = { test: u2[0], replace: u2[1], revive: u2[2] };
                }
                if (n2 && n2.test) {
                  var s2 = { type: r3, test: n2.test.bind(n2) };
                  n2.replace && (s2.replace = n2.replace.bind(n2)), n2.replaceAsync && (s2.replaceAsync = n2.replaceAsync.bind(n2));
                  var f2 = "number" == typeof t2.fallback ? t2.fallback : t2.fallback ? 0 : Number.POSITIVE_INFINITY;
                  if (n2.testPlainObjects ? this.plainObjectReplacers.splice(f2, 0, s2) : this.nonplainObjectReplacers.splice(f2, 0, s2), n2.revive || n2.reviveAsync) {
                    var l2 = {};
                    n2.revive && (l2.revive = n2.revive.bind(n2)), n2.reviveAsync && (l2.reviveAsync = n2.reviveAsync.bind(n2)), this.revivers[r3] = [l2, { plain: n2.testPlainObjects }];
                  }
                  this.types[r3] = n2;
                }
              }, this);
            }, this), this;
          } }]), Typeson;
        }(), f = function Undefined() {
          _classCallCheck(this, Undefined);
        };
        f.__typeson__type__ = "TypesonUndefined", s.Undefined = f, s.Promise = e, s.isThenable = isThenable, s.toStringTag = toStringTag2, s.hasConstructorOf = hasConstructorOf, s.isObject = isObject2, s.isPlainObject = isPlainObject, s.isUserObject = function isUserObject(e2) {
          if (!e2 || "Object" !== toStringTag2(e2))
            return false;
          var t2 = n(e2);
          return !t2 || hasConstructorOf(e2, Object) || isUserObject(t2);
        }, s.escapeKeyPathComponent = escapeKeyPathComponent, s.unescapeKeyPathComponent = unescapeKeyPathComponent, s.getByKeyPath = getByKeyPath2, s.getJSONType = function getJSONType(e2) {
          return null === e2 ? "null" : Array.isArray(e2) ? "array" : _typeof3(e2);
        }, s.JSON_TYPES = ["null", "boolean", "number", "string", "array", "object"];
        for (var l = { userObject: { test: function test(e2, t2) {
          return s.isUserObject(e2);
        }, replace: function replace(e2) {
          return function _objectSpread2$1(e3) {
            for (var t2 = 1; t2 < arguments.length; t2++) {
              var r2 = null != arguments[t2] ? arguments[t2] : {};
              t2 % 2 ? ownKeys$1(Object(r2), true).forEach(function(t3) {
                _defineProperty$1(e3, t3, r2[t3]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r2)) : ownKeys$1(Object(r2)).forEach(function(t3) {
                Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(r2, t3));
              });
            }
            return e3;
          }({}, e2);
        }, revive: function revive(e2) {
          return e2;
        } } }, p = [{ arrayNonindexKeys: { testPlainObjects: true, test: function test(e2, t2) {
          return !!Array.isArray(e2) && (Object.keys(e2).some(function(e3) {
            return String(Number.parseInt(e3)) !== e3;
          }) && (t2.iterateIn = "object", t2.addLength = true), true);
        }, replace: function replace(e2, t2) {
          return t2.iterateUnsetNumeric = true, e2;
        }, revive: function revive(e2) {
          if (Array.isArray(e2))
            return e2;
          var t2 = [];
          return Object.keys(e2).forEach(function(r2) {
            var n2 = e2[r2];
            t2[r2] = n2;
          }), t2;
        } } }, { sparseUndefined: { test: function test(e2, t2) {
          return void 0 === e2 && false === t2.ownKeys;
        }, replace: function replace(e2) {
          return 0;
        }, revive: function revive(e2) {
        } } }], y = { undef: { test: function test(e2, t2) {
          return void 0 === e2 && (t2.ownKeys || !("ownKeys" in t2));
        }, replace: function replace(e2) {
          return 0;
        }, revive: function revive(e2) {
          return new s.Undefined();
        } } }, v = { StringObject: { test: function test(e2) {
          return "String" === s.toStringTag(e2) && "object" === _typeof$12(e2);
        }, replace: function replace(e2) {
          return String(e2);
        }, revive: function revive(e2) {
          return new String(e2);
        } }, BooleanObject: { test: function test(e2) {
          return "Boolean" === s.toStringTag(e2) && "object" === _typeof$12(e2);
        }, replace: function replace(e2) {
          return Boolean(e2);
        }, revive: function revive(e2) {
          return new Boolean(e2);
        } }, NumberObject: { test: function test(e2) {
          return "Number" === s.toStringTag(e2) && "object" === _typeof$12(e2);
        }, replace: function replace(e2) {
          return Number(e2);
        }, revive: function revive(e2) {
          return new Number(e2);
        } } }, b = [{ nan: { test: function test(e2) {
          return Number.isNaN(e2);
        }, replace: function replace(e2) {
          return "NaN";
        }, revive: function revive(e2) {
          return Number.NaN;
        } } }, { infinity: { test: function test(e2) {
          return e2 === Number.POSITIVE_INFINITY;
        }, replace: function replace(e2) {
          return "Infinity";
        }, revive: function revive(e2) {
          return Number.POSITIVE_INFINITY;
        } } }, { negativeInfinity: { test: function test(e2) {
          return e2 === Number.NEGATIVE_INFINITY;
        }, replace: function replace(e2) {
          return "-Infinity";
        }, revive: function revive(e2) {
          return Number.NEGATIVE_INFINITY;
        } } }], d = { date: { test: function test(e2) {
          return "Date" === s.toStringTag(e2);
        }, replace: function replace(e2) {
          var t2 = e2.getTime();
          return Number.isNaN(t2) ? "NaN" : t2;
        }, revive: function revive(e2) {
          return "NaN" === e2 ? new Date(Number.NaN) : new Date(e2);
        } } }, h = { regexp: { test: function test(e2) {
          return "RegExp" === s.toStringTag(e2);
        }, replace: function replace(e2) {
          return { source: e2.source, flags: (e2.global ? "g" : "") + (e2.ignoreCase ? "i" : "") + (e2.multiline ? "m" : "") + (e2.sticky ? "y" : "") + (e2.unicode ? "u" : "") };
        }, revive: function revive(e2) {
          var t2 = e2.source, r2 = e2.flags;
          return new RegExp(t2, r2);
        } } }, g = { map: { test: function test(e2) {
          return "Map" === s.toStringTag(e2);
        }, replace: function replace(e2) {
          return _toConsumableArray$1(e2.entries());
        }, revive: function revive(e2) {
          return new Map(e2);
        } } }, m = { set: { test: function test(e2) {
          return "Set" === s.toStringTag(e2);
        }, replace: function replace(e2) {
          return _toConsumableArray$1(e2.values());
        }, revive: function revive(e2) {
          return new Set(e2);
        } } }, O = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", _ = new Uint8Array(256), j = 0; j < O.length; j++) {
          _[O.charCodeAt(j)] = j;
        }
        var S = function encode(e2, t2, r2) {
          null == r2 && (r2 = e2.byteLength);
          for (var n2 = new Uint8Array(e2, t2 || 0, r2), i2 = n2.length, o2 = "", a2 = 0; a2 < i2; a2 += 3) {
            o2 += O[n2[a2] >> 2], o2 += O[(3 & n2[a2]) << 4 | n2[a2 + 1] >> 4], o2 += O[(15 & n2[a2 + 1]) << 2 | n2[a2 + 2] >> 6], o2 += O[63 & n2[a2 + 2]];
          }
          return i2 % 3 == 2 ? o2 = o2.slice(0, -1) + "=" : i2 % 3 == 1 && (o2 = o2.slice(0, -2) + "=="), o2;
        }, T = function decode(e2) {
          var t2, r2, n2, i2, o2 = e2.length, a2 = 0.75 * e2.length, c2 = 0;
          "=" === e2[e2.length - 1] && (a2--, "=" === e2[e2.length - 2] && a2--);
          for (var u2 = new ArrayBuffer(a2), s2 = new Uint8Array(u2), f2 = 0; f2 < o2; f2 += 4) {
            t2 = _[e2.charCodeAt(f2)], r2 = _[e2.charCodeAt(f2 + 1)], n2 = _[e2.charCodeAt(f2 + 2)], i2 = _[e2.charCodeAt(f2 + 3)], s2[c2++] = t2 << 2 | r2 >> 4, s2[c2++] = (15 & r2) << 4 | n2 >> 2, s2[c2++] = (3 & n2) << 6 | 63 & i2;
          }
          return u2;
        }, w = { arraybuffer: { test: function test(e2) {
          return "ArrayBuffer" === s.toStringTag(e2);
        }, replace: function replace(e2, t2) {
          t2.buffers || (t2.buffers = []);
          var r2 = t2.buffers.indexOf(e2);
          return r2 > -1 ? { index: r2 } : (t2.buffers.push(e2), S(e2));
        }, revive: function revive(e2, t2) {
          if (t2.buffers || (t2.buffers = []), "object" === _typeof$12(e2))
            return t2.buffers[e2.index];
          var r2 = T(e2);
          return t2.buffers.push(r2), r2;
        } } }, A = "undefined" == typeof self ? commonjsGlobal : self, P = {};
        ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"].forEach(function(e2) {
          var t2 = e2, r2 = A[t2];
          r2 && (P[e2.toLowerCase()] = { test: function test(e3) {
            return s.toStringTag(e3) === t2;
          }, replace: function replace(e3, t3) {
            var r3 = e3.buffer, n2 = e3.byteOffset, i2 = e3.length;
            t3.buffers || (t3.buffers = []);
            var o2 = t3.buffers.indexOf(r3);
            return o2 > -1 ? { index: o2, byteOffset: n2, length: i2 } : (t3.buffers.push(r3), { encoded: S(r3), byteOffset: n2, length: i2 });
          }, revive: function revive(e3, t3) {
            t3.buffers || (t3.buffers = []);
            var n2, i2 = e3.byteOffset, o2 = e3.length, a2 = e3.encoded, c2 = e3.index;
            return "index" in e3 ? n2 = t3.buffers[c2] : (n2 = T(a2), t3.buffers.push(n2)), new r2(n2, i2, o2);
          } });
        });
        var C = { dataview: { test: function test(e2) {
          return "DataView" === s.toStringTag(e2);
        }, replace: function replace(e2, t2) {
          var r2 = e2.buffer, n2 = e2.byteOffset, i2 = e2.byteLength;
          t2.buffers || (t2.buffers = []);
          var o2 = t2.buffers.indexOf(r2);
          return o2 > -1 ? { index: o2, byteOffset: n2, byteLength: i2 } : (t2.buffers.push(r2), { encoded: S(r2), byteOffset: n2, byteLength: i2 });
        }, revive: function revive(e2, t2) {
          t2.buffers || (t2.buffers = []);
          var r2, n2 = e2.byteOffset, i2 = e2.byteLength, o2 = e2.encoded, a2 = e2.index;
          return "index" in e2 ? r2 = t2.buffers[a2] : (r2 = T(o2), t2.buffers.push(r2)), new DataView(r2, n2, i2);
        } } }, I = { IntlCollator: { test: function test(e2) {
          return s.hasConstructorOf(e2, Intl.Collator);
        }, replace: function replace(e2) {
          return e2.resolvedOptions();
        }, revive: function revive(e2) {
          return new Intl.Collator(e2.locale, e2);
        } }, IntlDateTimeFormat: { test: function test(e2) {
          return s.hasConstructorOf(e2, Intl.DateTimeFormat);
        }, replace: function replace(e2) {
          return e2.resolvedOptions();
        }, revive: function revive(e2) {
          return new Intl.DateTimeFormat(e2.locale, e2);
        } }, IntlNumberFormat: { test: function test(e2) {
          return s.hasConstructorOf(e2, Intl.NumberFormat);
        }, replace: function replace(e2) {
          return e2.resolvedOptions();
        }, revive: function revive(e2) {
          return new Intl.NumberFormat(e2.locale, e2);
        } } };
        function string2arraybuffer(e2) {
          for (var t2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; r2++) {
            t2[r2] = e2.charCodeAt(r2);
          }
          return t2.buffer;
        }
        var N = { file: { test: function test(e2) {
          return "File" === s.toStringTag(e2);
        }, replace: function replace(e2) {
          var t2 = new XMLHttpRequest();
          if (t2.overrideMimeType("text/plain; charset=x-user-defined"), t2.open("GET", URL.createObjectURL(e2), false), t2.send(), 200 !== t2.status && 0 !== t2.status)
            throw new Error("Bad File access: " + t2.status);
          return { type: e2.type, stringContents: t2.responseText, name: e2.name, lastModified: e2.lastModified };
        }, revive: function revive(e2) {
          var t2 = e2.name, r2 = e2.type, n2 = e2.stringContents, i2 = e2.lastModified;
          return new File([string2arraybuffer(n2)], t2, { type: r2, lastModified: i2 });
        }, replaceAsync: function replaceAsync(e2) {
          return new s.Promise(function(t2, r2) {
            var n2 = new FileReader();
            n2.addEventListener("load", function() {
              t2({ type: e2.type, stringContents: n2.result, name: e2.name, lastModified: e2.lastModified });
            }), n2.addEventListener("error", function() {
              r2(n2.error);
            }), n2.readAsBinaryString(e2);
          });
        } } }, k = { bigint: { test: function test(e2) {
          return "bigint" == typeof e2;
        }, replace: function replace(e2) {
          return String(e2);
        }, revive: function revive(e2) {
          return BigInt(e2);
        } } }, E = { bigintObject: { test: function test(e2) {
          return "object" === _typeof$12(e2) && s.hasConstructorOf(e2, BigInt);
        }, replace: function replace(e2) {
          return String(e2);
        }, revive: function revive(e2) {
          return new Object(BigInt(e2));
        } } }, B = { cryptokey: { test: function test(e2) {
          return "CryptoKey" === s.toStringTag(e2) && e2.extractable;
        }, replaceAsync: function replaceAsync(e2) {
          return new s.Promise(function(t2, r2) {
            crypto.subtle.exportKey("jwk", e2).catch(function(e3) {
              r2(e3);
            }).then(function(r3) {
              t2({ jwk: r3, algorithm: e2.algorithm, usages: e2.usages });
            });
          });
        }, revive: function revive(e2) {
          var t2 = e2.jwk, r2 = e2.algorithm, n2 = e2.usages;
          return crypto.subtle.importKey("jwk", t2, r2, true, n2);
        } } };
        return [l, y, p, v, b, d, h, { imagedata: { test: function test(e2) {
          return "ImageData" === s.toStringTag(e2);
        }, replace: function replace(e2) {
          return { array: _toConsumableArray$1(e2.data), width: e2.width, height: e2.height };
        }, revive: function revive(e2) {
          return new ImageData(new Uint8ClampedArray(e2.array), e2.width, e2.height);
        } } }, { imagebitmap: { test: function test(e2) {
          return "ImageBitmap" === s.toStringTag(e2) || e2 && e2.dataset && "ImageBitmap" === e2.dataset.toStringTag;
        }, replace: function replace(e2) {
          var t2 = document.createElement("canvas");
          return t2.getContext("2d").drawImage(e2, 0, 0), t2.toDataURL();
        }, revive: function revive(e2) {
          var t2 = document.createElement("canvas"), r2 = t2.getContext("2d"), n2 = document.createElement("img");
          return n2.addEventListener("load", function() {
            r2.drawImage(n2, 0, 0);
          }), n2.src = e2, t2;
        }, reviveAsync: function reviveAsync(e2) {
          var t2 = document.createElement("canvas"), r2 = t2.getContext("2d"), n2 = document.createElement("img");
          return n2.addEventListener("load", function() {
            r2.drawImage(n2, 0, 0);
          }), n2.src = e2, createImageBitmap(t2);
        } } }, N, { file: N.file, filelist: { test: function test(e2) {
          return "FileList" === s.toStringTag(e2);
        }, replace: function replace(e2) {
          for (var t2 = [], r2 = 0; r2 < e2.length; r2++) {
            t2[r2] = e2.item(r2);
          }
          return t2;
        }, revive: function revive(e2) {
          return new (function() {
            function FileList() {
              _classCallCheck$1(this, FileList), this._files = arguments[0], this.length = this._files.length;
            }
            return function _createClass$1(e3, t2, r2) {
              return t2 && _defineProperties$1(e3.prototype, t2), r2 && _defineProperties$1(e3, r2), e3;
            }(FileList, [{ key: "item", value: function item(e3) {
              return this._files[e3];
            } }, { key: Symbol.toStringTag, get: function get() {
              return "FileList";
            } }]), FileList;
          }())(e2);
        } } }, { blob: { test: function test(e2) {
          return "Blob" === s.toStringTag(e2);
        }, replace: function replace(e2) {
          var t2 = new XMLHttpRequest();
          if (t2.overrideMimeType("text/plain; charset=x-user-defined"), t2.open("GET", URL.createObjectURL(e2), false), t2.send(), 200 !== t2.status && 0 !== t2.status)
            throw new Error("Bad Blob access: " + t2.status);
          return { type: e2.type, stringContents: t2.responseText };
        }, revive: function revive(e2) {
          var t2 = e2.type, r2 = e2.stringContents;
          return new Blob([string2arraybuffer(r2)], { type: t2 });
        }, replaceAsync: function replaceAsync(e2) {
          return new s.Promise(function(t2, r2) {
            var n2 = new FileReader();
            n2.addEventListener("load", function() {
              t2({ type: e2.type, stringContents: n2.result });
            }), n2.addEventListener("error", function() {
              r2(n2.error);
            }), n2.readAsBinaryString(e2);
          });
        } } }].concat("function" == typeof Map ? g : [], "function" == typeof Set ? m : [], "function" == typeof ArrayBuffer ? w : [], "function" == typeof Uint8Array ? P : [], "function" == typeof DataView ? C : [], "undefined" != typeof Intl ? I : [], "undefined" != typeof crypto ? B : [], "undefined" != typeof BigInt ? [k, E] : []).concat({ checkDataCloneException: { test: function test(e2) {
          var t2 = {}.toString.call(e2).slice(8, -1);
          if (["symbol", "function"].includes(_typeof$12(e2)) || ["Arguments", "Module", "Error", "Promise", "WeakMap", "WeakSet", "Event", "MessageChannel"].includes(t2) || e2 && "object" === _typeof$12(e2) && "number" == typeof e2.nodeType && "function" == typeof e2.insertBefore)
            throw new DOMException("The object cannot be cloned.", "DataCloneError");
          return false;
        } } });
      });
    }, {}], 8: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _typeof3(e2) {
        return (_typeof3 = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function(e3) {
          return typeof e3 === "undefined" ? "undefined" : _typeof2(e3);
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3 === "undefined" ? "undefined" : _typeof2(e3);
        })(e2);
      }
      function _classCallCheck(e2, t2) {
        if (!(e2 instanceof t2))
          throw new TypeError("Cannot call a class as a function");
      }
      function _defineProperties(e2, t2) {
        for (var r2 = 0; r2 < t2.length; r2++) {
          var n2 = t2[r2];
          n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
        }
      }
      function _defineProperty(e2, t2, r2) {
        return t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
      }
      function ownKeys(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n2 = Object.getOwnPropertySymbols(e2);
          t2 && (n2 = n2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, n2);
        }
        return r2;
      }
      function _objectSpread2(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? ownKeys(Object(r2), true).forEach(function(t3) {
            _defineProperty(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : ownKeys(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      function _slicedToArray(e2, t2) {
        return function _arrayWithHoles(e3) {
          if (Array.isArray(e3))
            return e3;
        }(e2) || function _iterableToArrayLimit(e3, t3) {
          if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e3)))
            return;
          var r2 = [], n2 = true, o2 = false, a2 = void 0;
          try {
            for (var i2, c2 = e3[Symbol.iterator](); !(n2 = (i2 = c2.next()).done) && (r2.push(i2.value), !t3 || r2.length !== t3); n2 = true) {
            }
          } catch (e4) {
            o2 = true, a2 = e4;
          } finally {
            try {
              n2 || null == c2.return || c2.return();
            } finally {
              if (o2)
                throw a2;
            }
          }
          return r2;
        }(e2, t2) || _unsupportedIterableToArray(e2, t2) || function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function _toConsumableArray(e2) {
        return function _arrayWithoutHoles(e3) {
          if (Array.isArray(e3))
            return _arrayLikeToArray(e3);
        }(e2) || function _iterableToArray(e3) {
          if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3))
            return Array.from(e3);
        }(e2) || _unsupportedIterableToArray(e2) || function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function _unsupportedIterableToArray(e2, t2) {
        if (e2) {
          if ("string" == typeof e2)
            return _arrayLikeToArray(e2, t2);
          var r2 = Object.prototype.toString.call(e2).slice(8, -1);
          return "Object" === r2 && e2.constructor && (r2 = e2.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(e2) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? _arrayLikeToArray(e2, t2) : void 0;
        }
      }
      function _arrayLikeToArray(e2, t2) {
        (null == t2 || t2 > e2.length) && (t2 = e2.length);
        for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++) {
          n2[r2] = e2[r2];
        }
        return n2;
      }
      var e = function TypesonPromise(e2) {
        _classCallCheck(this, TypesonPromise), this.p = new Promise(e2);
      };
      e.__typeson__type__ = "TypesonPromise", "undefined" != typeof Symbol && (e.prototype[Symbol.toStringTag] = "TypesonPromise"), e.prototype.then = function(t2, r2) {
        var n2 = this;
        return new e(function(e2, o2) {
          n2.p.then(function(r3) {
            e2(t2 ? t2(r3) : r3);
          }).catch(function(e3) {
            return r2 ? r2(e3) : Promise.reject(e3);
          }).then(e2, o2);
        });
      }, e.prototype.catch = function(e2) {
        return this.then(null, e2);
      }, e.resolve = function(t2) {
        return new e(function(e2) {
          e2(t2);
        });
      }, e.reject = function(t2) {
        return new e(function(e2, r2) {
          r2(t2);
        });
      }, ["all", "race", "allSettled"].forEach(function(t2) {
        e[t2] = function(r2) {
          return new e(function(e2, n2) {
            Promise[t2](r2.map(function(e3) {
              return e3 && e3.constructor && "TypesonPromise" === e3.constructor.__typeson__type__ ? e3.p : e3;
            })).then(e2, n2);
          });
        };
      });
      var t = {}.toString, r = {}.hasOwnProperty, n = Object.getPrototypeOf, o = r.toString;
      function isThenable(e2, t2) {
        return isObject2(e2) && "function" == typeof e2.then && (!t2 || "function" == typeof e2.catch);
      }
      function toStringTag2(e2) {
        return t.call(e2).slice(8, -1);
      }
      function hasConstructorOf(e2, t2) {
        if (!e2 || "object" !== _typeof3(e2))
          return false;
        var a2 = n(e2);
        if (!a2)
          return null === t2;
        var i2 = r.call(a2, "constructor") && a2.constructor;
        return "function" != typeof i2 ? null === t2 : t2 === i2 || null !== t2 && o.call(i2) === o.call(t2) || "function" == typeof t2 && "string" == typeof i2.__typeson__type__ && i2.__typeson__type__ === t2.__typeson__type__;
      }
      function isPlainObject(e2) {
        return !(!e2 || "Object" !== toStringTag2(e2)) && (!n(e2) || hasConstructorOf(e2, Object));
      }
      function isObject2(e2) {
        return e2 && "object" === _typeof3(e2);
      }
      function escapeKeyPathComponent(e2) {
        return e2.replace(/~/g, "~0").replace(/\./g, "~1");
      }
      function unescapeKeyPathComponent(e2) {
        return e2.replace(/~1/g, ".").replace(/~0/g, "~");
      }
      function getByKeyPath2(e2, t2) {
        if ("" === t2)
          return e2;
        var r2 = t2.indexOf(".");
        if (r2 > -1) {
          var n2 = e2[unescapeKeyPathComponent(t2.slice(0, r2))];
          return void 0 === n2 ? void 0 : getByKeyPath2(n2, t2.slice(r2 + 1));
        }
        return e2[unescapeKeyPathComponent(t2)];
      }
      function setAtKeyPath(e2, t2, r2) {
        if ("" === t2)
          return r2;
        var n2 = t2.indexOf(".");
        return n2 > -1 ? setAtKeyPath(e2[unescapeKeyPathComponent(t2.slice(0, n2))], t2.slice(n2 + 1), r2) : (e2[unescapeKeyPathComponent(t2)] = r2, e2);
      }
      function _await(e2, t2, r2) {
        return r2 ? t2 ? t2(e2) : e2 : (e2 && e2.then || (e2 = Promise.resolve(e2)), t2 ? e2.then(t2) : e2);
      }
      var a = Object.keys, i = Array.isArray, c = {}.hasOwnProperty, s = ["type", "replaced", "iterateIn", "iterateUnsetNumeric"];
      function _async(e2) {
        return function() {
          for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) {
            t2[r2] = arguments[r2];
          }
          try {
            return Promise.resolve(e2.apply(this, t2));
          } catch (e3) {
            return Promise.reject(e3);
          }
        };
      }
      function nestedPathsFirst(e2, t2) {
        if ("" === e2.keypath)
          return -1;
        var r2 = e2.keypath.match(/\./g) || 0, n2 = t2.keypath.match(/\./g) || 0;
        return r2 && (r2 = r2.length), n2 && (n2 = n2.length), r2 > n2 ? -1 : r2 < n2 ? 1 : e2.keypath < t2.keypath ? -1 : e2.keypath > t2.keypath;
      }
      var u = function() {
        function Typeson(e2) {
          _classCallCheck(this, Typeson), this.options = e2, this.plainObjectReplacers = [], this.nonplainObjectReplacers = [], this.revivers = {}, this.types = {};
        }
        return function _createClass(e2, t2, r2) {
          return t2 && _defineProperties(e2.prototype, t2), r2 && _defineProperties(e2, r2), e2;
        }(Typeson, [{ key: "stringify", value: function stringify2(e2, t2, r2, n2) {
          n2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this.options), n2), {}, { stringification: true });
          var o2 = this.encapsulate(e2, null, n2);
          return i(o2) ? JSON.stringify(o2[0], t2, r2) : o2.then(function(e3) {
            return JSON.stringify(e3, t2, r2);
          });
        } }, { key: "stringifySync", value: function stringifySync(e2, t2, r2, n2) {
          return this.stringify(e2, t2, r2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, n2), {}, { sync: true }));
        } }, { key: "stringifyAsync", value: function stringifyAsync(e2, t2, r2, n2) {
          return this.stringify(e2, t2, r2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, n2), {}, { sync: false }));
        } }, { key: "parse", value: function parse(e2, t2, r2) {
          return r2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this.options), r2), {}, { parse: true }), this.revive(JSON.parse(e2, t2), r2);
        } }, { key: "parseSync", value: function parseSync(e2, t2, r2) {
          return this.parse(e2, t2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r2), {}, { sync: true }));
        } }, { key: "parseAsync", value: function parseAsync(e2, t2, r2) {
          return this.parse(e2, t2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r2), {}, { sync: false }));
        } }, { key: "specialTypeNames", value: function specialTypeNames(e2, t2) {
          var r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return r2.returnTypeNames = true, this.encapsulate(e2, t2, r2);
        } }, { key: "rootTypeName", value: function rootTypeName(e2, t2) {
          var r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return r2.iterateNone = true, this.encapsulate(e2, t2, r2);
        } }, { key: "encapsulate", value: function encapsulate(t2, r2, n2) {
          var o2 = _async(function(t3, r3) {
            return _await(Promise.all(r3.map(function(e2) {
              return e2[1].p;
            })), function(n3) {
              return _await(Promise.all(n3.map(_async(function(n4) {
                var a2 = false, i2 = [], c2 = _slicedToArray(r3.splice(0, 1), 1), s2 = _slicedToArray(c2[0], 7), u3 = s2[0], p3 = s2[2], y2 = s2[3], l2 = s2[4], f2 = s2[5], h2 = s2[6], v2 = _encapsulate(u3, n4, p3, y2, i2, true, h2), d2 = hasConstructorOf(v2, e);
                return function _invoke(e2, t4) {
                  var r4 = e2();
                  return r4 && r4.then ? r4.then(t4) : t4(r4);
                }(function() {
                  if (u3 && d2)
                    return _await(v2.p, function(e2) {
                      return l2[f2] = e2, a2 = true, o2(t3, i2);
                    });
                }, function(e2) {
                  return a2 ? e2 : (u3 ? l2[f2] = v2 : t3 = d2 ? v2.p : v2, o2(t3, i2));
                });
              }))), function() {
                return t3;
              });
            });
          }), u2 = (n2 = _objectSpread2(_objectSpread2({ sync: true }, this.options), n2)).sync, p2 = this, y = {}, l = [], f = [], h = [], v = !("cyclic" in n2) || n2.cyclic, d = n2.encapsulateObserver, b = _encapsulate("", t2, v, r2 || {}, h);
          function finish(e2) {
            var t3 = Object.values(y);
            if (n2.iterateNone)
              return t3.length ? t3[0] : Typeson.getJSONType(e2);
            if (t3.length) {
              if (n2.returnTypeNames)
                return _toConsumableArray(new Set(t3));
              e2 && isPlainObject(e2) && !c.call(e2, "$types") ? e2.$types = y : e2 = { $: e2, $types: { $: y } };
            } else
              isObject2(e2) && c.call(e2, "$types") && (e2 = { $: e2, $types: true });
            return !n2.returnTypeNames && e2;
          }
          function _adaptBuiltinStateObjectProperties(e2, t3, r3) {
            Object.assign(e2, t3);
            var n3 = s.map(function(t4) {
              var r4 = e2[t4];
              return delete e2[t4], r4;
            });
            r3(), s.forEach(function(t4, r4) {
              e2[t4] = n3[r4];
            });
          }
          function _encapsulate(t3, r3, o3, s2, u3, h2, v2) {
            var b2, _ = {}, O = _typeof3(r3), j = d ? function(n3) {
              var a2 = v2 || s2.type || Typeson.getJSONType(r3);
              d(Object.assign(n3 || _, { keypath: t3, value: r3, cyclic: o3, stateObj: s2, promisesData: u3, resolvingTypesonPromise: h2, awaitingTypesonPromise: hasConstructorOf(r3, e) }, { type: a2 }));
            } : null;
            if (["string", "boolean", "number", "undefined"].includes(O))
              return void 0 === r3 || Number.isNaN(r3) || r3 === Number.NEGATIVE_INFINITY || r3 === Number.POSITIVE_INFINITY ? (b2 = s2.replaced ? r3 : replace(t3, r3, s2, u3, false, h2, j)) !== r3 && (_ = { replaced: b2 }) : b2 = r3, j && j(), b2;
            if (null === r3)
              return j && j(), r3;
            if (o3 && !s2.iterateIn && !s2.iterateUnsetNumeric && r3 && "object" === _typeof3(r3)) {
              var m = l.indexOf(r3);
              if (!(m < 0))
                return y[t3] = "#", j && j({ cyclicKeypath: f[m] }), "#" + f[m];
              true === o3 && (l.push(r3), f.push(t3));
            }
            var S, g = isPlainObject(r3), P = i(r3), T = (g || P) && (!p2.plainObjectReplacers.length || s2.replaced) || s2.iterateIn ? r3 : replace(t3, r3, s2, u3, g || P, null, j);
            if (T !== r3 ? (b2 = T, _ = { replaced: T }) : "" === t3 && hasConstructorOf(r3, e) ? (u3.push([t3, r3, o3, s2, void 0, void 0, s2.type]), b2 = r3) : P && "object" !== s2.iterateIn || "array" === s2.iterateIn ? (S = new Array(r3.length), _ = { clone: S }) : (["function", "symbol"].includes(_typeof3(r3)) || "toJSON" in r3 || hasConstructorOf(r3, e) || hasConstructorOf(r3, Promise) || hasConstructorOf(r3, ArrayBuffer)) && !g && "object" !== s2.iterateIn ? b2 = r3 : (S = {}, s2.addLength && (S.length = r3.length), _ = { clone: S }), j && j(), n2.iterateNone)
              return S || b2;
            if (!S)
              return b2;
            if (s2.iterateIn) {
              var w = function _loop(n3) {
                var a2 = { ownKeys: c.call(r3, n3) };
                _adaptBuiltinStateObjectProperties(s2, a2, function() {
                  var a3 = t3 + (t3 ? "." : "") + escapeKeyPathComponent(n3), i2 = _encapsulate(a3, r3[n3], Boolean(o3), s2, u3, h2);
                  hasConstructorOf(i2, e) ? u3.push([a3, i2, Boolean(o3), s2, S, n3, s2.type]) : void 0 !== i2 && (S[n3] = i2);
                });
              };
              for (var A in r3) {
                w(A);
              }
              j && j({ endIterateIn: true, end: true });
            } else
              a(r3).forEach(function(n3) {
                var a2 = t3 + (t3 ? "." : "") + escapeKeyPathComponent(n3);
                _adaptBuiltinStateObjectProperties(s2, { ownKeys: true }, function() {
                  var t4 = _encapsulate(a2, r3[n3], Boolean(o3), s2, u3, h2);
                  hasConstructorOf(t4, e) ? u3.push([a2, t4, Boolean(o3), s2, S, n3, s2.type]) : void 0 !== t4 && (S[n3] = t4);
                });
              }), j && j({ endIterateOwn: true, end: true });
            if (s2.iterateUnsetNumeric) {
              for (var C = r3.length, k = function _loop2(n3) {
                if (!(n3 in r3)) {
                  var a2 = t3 + (t3 ? "." : "") + n3;
                  _adaptBuiltinStateObjectProperties(s2, { ownKeys: false }, function() {
                    var t4 = _encapsulate(a2, void 0, Boolean(o3), s2, u3, h2);
                    hasConstructorOf(t4, e) ? u3.push([a2, t4, Boolean(o3), s2, S, n3, s2.type]) : void 0 !== t4 && (S[n3] = t4);
                  });
                }
              }, N = 0; N < C; N++) {
                k(N);
              }
              j && j({ endIterateUnsetNumeric: true, end: true });
            }
            return S;
          }
          function replace(e2, t3, r3, n3, o3, a2, i2) {
            for (var c2 = o3 ? p2.plainObjectReplacers : p2.nonplainObjectReplacers, s2 = c2.length; s2--; ) {
              var l2 = c2[s2];
              if (l2.test(t3, r3)) {
                var f2 = l2.type;
                if (p2.revivers[f2]) {
                  var h2 = y[e2];
                  y[e2] = h2 ? [f2].concat(h2) : f2;
                }
                return Object.assign(r3, { type: f2, replaced: true }), !u2 && l2.replaceAsync || l2.replace ? (i2 && i2({ replacing: true }), _encapsulate(e2, l2[u2 || !l2.replaceAsync ? "replace" : "replaceAsync"](t3, r3), v && "readonly", r3, n3, a2, f2)) : (i2 && i2({ typeDetected: true }), _encapsulate(e2, t3, v && "readonly", r3, n3, a2, f2));
              }
            }
            return t3;
          }
          return h.length ? u2 && n2.throwOnBadSyncType ? function() {
            throw new TypeError("Sync method requested but async result obtained");
          }() : Promise.resolve(o2(b, h)).then(finish) : !u2 && n2.throwOnBadSyncType ? function() {
            throw new TypeError("Async method requested but sync result obtained");
          }() : n2.stringification && u2 ? [finish(b)] : u2 ? finish(b) : Promise.resolve(finish(b));
        } }, { key: "encapsulateSync", value: function encapsulateSync(e2, t2, r2) {
          return this.encapsulate(e2, t2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r2), {}, { sync: true }));
        } }, { key: "encapsulateAsync", value: function encapsulateAsync(e2, t2, r2) {
          return this.encapsulate(e2, t2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r2), {}, { sync: false }));
        } }, { key: "revive", value: function revive(t2, r2) {
          var n2 = t2 && t2.$types;
          if (!n2)
            return t2;
          if (true === n2)
            return t2.$;
          var o2 = (r2 = _objectSpread2(_objectSpread2({ sync: true }, this.options), r2)).sync, c2 = [], s2 = {}, u2 = true;
          n2.$ && isPlainObject(n2.$) && (t2 = t2.$, n2 = n2.$, u2 = false);
          var y = this;
          function executeReviver(e2, t3) {
            var r3 = _slicedToArray(y.revivers[e2] || [], 1)[0];
            if (!r3)
              throw new Error("Unregistered type: " + e2);
            return o2 && !("revive" in r3) ? t3 : r3[o2 && r3.revive ? "revive" : !o2 && r3.reviveAsync ? "reviveAsync" : "revive"](t3, s2);
          }
          var l = [];
          function checkUndefined(e2) {
            return hasConstructorOf(e2, p) ? void 0 : e2;
          }
          var f, h = function revivePlainObjects() {
            var r3 = [];
            if (Object.entries(n2).forEach(function(e2) {
              var t3 = _slicedToArray(e2, 2), o3 = t3[0], a2 = t3[1];
              "#" !== a2 && [].concat(a2).forEach(function(e3) {
                _slicedToArray(y.revivers[e3] || [null, {}], 2)[1].plain && (r3.push({ keypath: o3, type: e3 }), delete n2[o3]);
              });
            }), r3.length)
              return r3.sort(nestedPathsFirst).reduce(function reducer(r4, n3) {
                var o3 = n3.keypath, a2 = n3.type;
                if (isThenable(r4))
                  return r4.then(function(e2) {
                    return reducer(e2, { keypath: o3, type: a2 });
                  });
                var i2 = getByKeyPath2(t2, o3);
                if (hasConstructorOf(i2 = executeReviver(a2, i2), e))
                  return i2.then(function(e2) {
                    var r5 = setAtKeyPath(t2, o3, e2);
                    r5 === e2 && (t2 = r5);
                  });
                var c3 = setAtKeyPath(t2, o3, i2);
                c3 === i2 && (t2 = c3);
              }, void 0);
          }();
          return hasConstructorOf(h, e) ? f = h.then(function() {
            return t2;
          }) : (f = function _revive(t3, r3, o3, s3, y2) {
            if (!u2 || "$types" !== t3) {
              var f2 = n2[t3], h2 = i(r3);
              if (h2 || isPlainObject(r3)) {
                var v = h2 ? new Array(r3.length) : {};
                for (a(r3).forEach(function(n3) {
                  var a2 = _revive(t3 + (t3 ? "." : "") + escapeKeyPathComponent(n3), r3[n3], o3 || v, v, n3), i2 = function set2(e2) {
                    return hasConstructorOf(e2, p) ? v[n3] = void 0 : void 0 !== e2 && (v[n3] = e2), e2;
                  };
                  hasConstructorOf(a2, e) ? l.push(a2.then(function(e2) {
                    return i2(e2);
                  })) : i2(a2);
                }), r3 = v; c2.length; ) {
                  var d = _slicedToArray(c2[0], 4), b = d[0], _ = d[1], O = d[2], j = d[3], m = getByKeyPath2(b, _);
                  if (void 0 === m)
                    break;
                  O[j] = m, c2.splice(0, 1);
                }
              }
              if (!f2)
                return r3;
              if ("#" === f2) {
                var S = getByKeyPath2(o3, r3.slice(1));
                return void 0 === S && c2.push([o3, r3.slice(1), s3, y2]), S;
              }
              return [].concat(f2).reduce(function reducer(t4, r4) {
                return hasConstructorOf(t4, e) ? t4.then(function(e2) {
                  return reducer(e2, r4);
                }) : executeReviver(r4, t4);
              }, r3);
            }
          }("", t2, null), l.length && (f = e.resolve(f).then(function(t3) {
            return e.all([t3].concat(l));
          }).then(function(e2) {
            return _slicedToArray(e2, 1)[0];
          }))), isThenable(f) ? o2 && r2.throwOnBadSyncType ? function() {
            throw new TypeError("Sync method requested but async result obtained");
          }() : hasConstructorOf(f, e) ? f.p.then(checkUndefined) : f : !o2 && r2.throwOnBadSyncType ? function() {
            throw new TypeError("Async method requested but sync result obtained");
          }() : o2 ? checkUndefined(f) : Promise.resolve(checkUndefined(f));
        } }, { key: "reviveSync", value: function reviveSync(e2, t2) {
          return this.revive(e2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, t2), {}, { sync: true }));
        } }, { key: "reviveAsync", value: function reviveAsync(e2, t2) {
          return this.revive(e2, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, t2), {}, { sync: false }));
        } }, { key: "register", value: function register(e2, t2) {
          return t2 = t2 || {}, [].concat(e2).forEach(function R(e3) {
            var r2 = this;
            if (i(e3))
              return e3.map(function(e4) {
                return R.call(r2, e4);
              });
            e3 && a(e3).forEach(function(r3) {
              if ("#" === r3)
                throw new TypeError("# cannot be used as a type name as it is reserved for cyclic objects");
              if (Typeson.JSON_TYPES.includes(r3))
                throw new TypeError("Plain JSON object types are reserved as type names");
              var n2 = e3[r3], o2 = n2 && n2.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers, a2 = o2.filter(function(e4) {
                return e4.type === r3;
              });
              if (a2.length && (o2.splice(o2.indexOf(a2[0]), 1), delete this.revivers[r3], delete this.types[r3]), "function" == typeof n2) {
                var c2 = n2;
                n2 = { test: function test(e4) {
                  return e4 && e4.constructor === c2;
                }, replace: function replace(e4) {
                  return _objectSpread2({}, e4);
                }, revive: function revive(e4) {
                  return Object.assign(Object.create(c2.prototype), e4);
                } };
              } else if (i(n2)) {
                var s2 = _slicedToArray(n2, 3);
                n2 = { test: s2[0], replace: s2[1], revive: s2[2] };
              }
              if (n2 && n2.test) {
                var u2 = { type: r3, test: n2.test.bind(n2) };
                n2.replace && (u2.replace = n2.replace.bind(n2)), n2.replaceAsync && (u2.replaceAsync = n2.replaceAsync.bind(n2));
                var p2 = "number" == typeof t2.fallback ? t2.fallback : t2.fallback ? 0 : Number.POSITIVE_INFINITY;
                if (n2.testPlainObjects ? this.plainObjectReplacers.splice(p2, 0, u2) : this.nonplainObjectReplacers.splice(p2, 0, u2), n2.revive || n2.reviveAsync) {
                  var y = {};
                  n2.revive && (y.revive = n2.revive.bind(n2)), n2.reviveAsync && (y.reviveAsync = n2.reviveAsync.bind(n2)), this.revivers[r3] = [y, { plain: n2.testPlainObjects }];
                }
                this.types[r3] = n2;
              }
            }, this);
          }, this), this;
        } }]), Typeson;
      }(), p = function Undefined() {
        _classCallCheck(this, Undefined);
      };
      p.__typeson__type__ = "TypesonUndefined", u.Undefined = p, u.Promise = e, u.isThenable = isThenable, u.toStringTag = toStringTag2, u.hasConstructorOf = hasConstructorOf, u.isObject = isObject2, u.isPlainObject = isPlainObject, u.isUserObject = function isUserObject(e2) {
        if (!e2 || "Object" !== toStringTag2(e2))
          return false;
        var t2 = n(e2);
        return !t2 || hasConstructorOf(e2, Object) || isUserObject(t2);
      }, u.escapeKeyPathComponent = escapeKeyPathComponent, u.unescapeKeyPathComponent = unescapeKeyPathComponent, u.getByKeyPath = getByKeyPath2, u.getJSONType = function getJSONType(e2) {
        return null === e2 ? "null" : Array.isArray(e2) ? "array" : _typeof3(e2);
      }, u.JSON_TYPES = ["null", "boolean", "number", "string", "array", "object"], module2.exports = u;
    }, {}], 9: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _(message, opts) {
        return (opts && opts.context ? opts.context : "Value") + " " + message + ".";
      }
      function type2(V) {
        if (V === null) {
          return "Null";
        }
        switch (typeof V === "undefined" ? "undefined" : _typeof2(V)) {
          case "undefined":
            return "Undefined";
          case "boolean":
            return "Boolean";
          case "number":
            return "Number";
          case "string":
            return "String";
          case "symbol":
            return "Symbol";
          case "object":
          case "function":
          default:
            return "Object";
        }
      }
      function evenRound(x) {
        if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
          return censorNegativeZero(Math.floor(x));
        }
        return censorNegativeZero(Math.round(x));
      }
      function integerPart(n) {
        return censorNegativeZero(Math.trunc(n));
      }
      function sign(x) {
        return x < 0 ? -1 : 1;
      }
      function modulo(x, y) {
        var signMightNotMatch = x % y;
        if (sign(y) !== sign(signMightNotMatch)) {
          return signMightNotMatch + y;
        }
        return signMightNotMatch;
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function createIntegerConversion(bitLength, typeOpts) {
        var isSigned = !typeOpts.unsigned;
        var lowerBound2 = void 0;
        var upperBound = void 0;
        if (bitLength === 64) {
          upperBound = Math.pow(2, 53) - 1;
          lowerBound2 = !isSigned ? 0 : -Math.pow(2, 53) + 1;
        } else if (!isSigned) {
          lowerBound2 = 0;
          upperBound = Math.pow(2, bitLength) - 1;
        } else {
          lowerBound2 = -Math.pow(2, bitLength - 1);
          upperBound = Math.pow(2, bitLength - 1) - 1;
        }
        var twoToTheBitLength = Math.pow(2, bitLength);
        var twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);
        return function(V, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var x = +V;
          x = censorNegativeZero(x);
          if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
              throw new TypeError(_("is not a finite number", opts));
            }
            x = integerPart(x);
            if (x < lowerBound2 || x > upperBound) {
              throw new TypeError(_("is outside the accepted range of " + lowerBound2 + " to " + upperBound + ", inclusive", opts));
            }
            return x;
          }
          if (!Number.isNaN(x) && opts.clamp) {
            x = Math.min(Math.max(x, lowerBound2), upperBound);
            x = evenRound(x);
            return x;
          }
          if (!Number.isFinite(x) || x === 0) {
            return 0;
          }
          x = integerPart(x);
          if (x >= lowerBound2 && x <= upperBound) {
            return x;
          }
          x = modulo(x, twoToTheBitLength);
          if (isSigned && x >= twoToOneLessThanTheBitLength) {
            return x - twoToTheBitLength;
          }
          return x;
        };
      }
      exports2.any = function(V) {
        return V;
      };
      exports2.void = function() {
        return void 0;
      };
      exports2.boolean = function(val) {
        return !!val;
      };
      exports2.byte = createIntegerConversion(8, { unsigned: false });
      exports2.octet = createIntegerConversion(8, { unsigned: true });
      exports2.short = createIntegerConversion(16, { unsigned: false });
      exports2["unsigned short"] = createIntegerConversion(16, { unsigned: true });
      exports2.long = createIntegerConversion(32, { unsigned: false });
      exports2["unsigned long"] = createIntegerConversion(32, { unsigned: true });
      exports2["long long"] = createIntegerConversion(64, { unsigned: false });
      exports2["unsigned long long"] = createIntegerConversion(64, { unsigned: true });
      exports2.double = function(V, opts) {
        var x = +V;
        if (!Number.isFinite(x)) {
          throw new TypeError(_("is not a finite floating-point value", opts));
        }
        return x;
      };
      exports2["unrestricted double"] = function(V) {
        var x = +V;
        return x;
      };
      exports2.float = function(V, opts) {
        var x = +V;
        if (!Number.isFinite(x)) {
          throw new TypeError(_("is not a finite floating-point value", opts));
        }
        if (Object.is(x, -0)) {
          return x;
        }
        var y = Math.fround(x);
        if (!Number.isFinite(y)) {
          throw new TypeError(_("is outside the range of a single-precision floating-point value", opts));
        }
        return y;
      };
      exports2["unrestricted float"] = function(V) {
        var x = +V;
        if (isNaN(x)) {
          return x;
        }
        if (Object.is(x, -0)) {
          return x;
        }
        return Math.fround(x);
      };
      exports2.DOMString = function(V, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (opts.treatNullAsEmptyString && V === null) {
          return "";
        }
        if ((typeof V === "undefined" ? "undefined" : _typeof2(V)) === "symbol") {
          throw new TypeError(_("is a symbol, which cannot be converted to a string", opts));
        }
        return String(V);
      };
      exports2.ByteString = function(V, opts) {
        var x = exports2.DOMString(V, opts);
        var c = void 0;
        for (var i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
          if (c > 255) {
            throw new TypeError(_("is not a valid ByteString", opts));
          }
        }
        return x;
      };
      exports2.USVString = function(V, opts) {
        var S = exports2.DOMString(V, opts);
        var n = S.length;
        var U = [];
        for (var i = 0; i < n; ++i) {
          var c = S.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            U.push(String.fromCodePoint(c));
          } else if (56320 <= c && c <= 57343) {
            U.push(String.fromCodePoint(65533));
          } else if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            var d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              var a = c & 1023;
              var b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
        return U.join("");
      };
      exports2.object = function(V, opts) {
        if (type2(V) !== "Object") {
          throw new TypeError(_("is not an object", opts));
        }
        return V;
      };
      function convertCallbackFunction(V, opts) {
        if (typeof V !== "function") {
          throw new TypeError(_("is not a function", opts));
        }
        return V;
      }
      [
        Error,
        ArrayBuffer,
        // The IsDetachedBuffer abstract operation is not exposed in JS
        DataView,
        Int8Array,
        Int16Array,
        Int32Array,
        Uint8Array,
        Uint16Array,
        Uint32Array,
        Uint8ClampedArray,
        Float32Array,
        Float64Array
      ].forEach(function(func) {
        var name = func.name;
        var article = /^[AEIOU]/.test(name) ? "an" : "a";
        exports2[name] = function(V, opts) {
          if (!(V instanceof func)) {
            throw new TypeError(_("is not " + article + " " + name + " object", opts));
          }
          return V;
        };
      });
      exports2.ArrayBufferView = function(V, opts) {
        if (!ArrayBuffer.isView(V)) {
          throw new TypeError(_("is not a view on an ArrayBuffer object", opts));
        }
        return V;
      };
      exports2.BufferSource = function(V, opts) {
        if (!(ArrayBuffer.isView(V) || V instanceof ArrayBuffer)) {
          throw new TypeError(_("is not an ArrayBuffer object or a view on one", opts));
        }
        return V;
      };
      exports2.DOMTimeStamp = exports2["unsigned long long"];
      exports2.Function = convertCallbackFunction;
      exports2.VoidFunction = convertCallbackFunction;
    }, {}] }, {}, [1])(1);
  });
})(dist);
var distExports = dist.exports;
const realisticStructuredClone = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
const structuredCloneWrapper = (input) => {
  if (typeof structuredClone !== "undefined") {
    return structuredClone(input);
  }
  try {
    return realisticStructuredClone(input);
  } catch (err) {
    throw new DataCloneError();
  }
};
const getEffectiveObjectStore = (cursor2) => {
  if (cursor2.source instanceof FDBObjectStore$1) {
    return cursor2.source;
  }
  return cursor2.source.objectStore;
};
const makeKeyRange = (range2, lowers, uppers) => {
  let lower = range2 !== void 0 ? range2.lower : void 0;
  let upper = range2 !== void 0 ? range2.upper : void 0;
  for (const lowerTemp of lowers) {
    if (lowerTemp === void 0) {
      continue;
    }
    if (lower === void 0 || cmp(lower, lowerTemp) === 1) {
      lower = lowerTemp;
    }
  }
  for (const upperTemp of uppers) {
    if (upperTemp === void 0) {
      continue;
    }
    if (upper === void 0 || cmp(upper, upperTemp) === -1) {
      upper = upperTemp;
    }
  }
  if (lower !== void 0 && upper !== void 0) {
    return FDBKeyRange.bound(lower, upper);
  }
  if (lower !== void 0) {
    return FDBKeyRange.lowerBound(lower);
  }
  if (upper !== void 0) {
    return FDBKeyRange.upperBound(upper);
  }
};
class FDBCursor {
  _gotValue = false;
  _position = void 0;
  // Key of previously returned record
  _objectStorePosition = void 0;
  _keyOnly = false;
  _key = void 0;
  _primaryKey = void 0;
  constructor(source, range2, direction = "next", request, keyOnly = false) {
    this._range = range2;
    this._source = source;
    this._direction = direction;
    this._request = request;
    this._keyOnly = keyOnly;
  }
  // Read only properties
  get source() {
    return this._source;
  }
  set source(val) {
  }
  get request() {
    return this._request;
  }
  set request(val) {
  }
  get direction() {
    return this._direction;
  }
  set direction(val) {
  }
  get key() {
    return this._key;
  }
  set key(val) {
  }
  get primaryKey() {
    return this._primaryKey;
  }
  set primaryKey(val) {
  }
  // https://w3c.github.io/IndexedDB/#iterate-a-cursor
  _iterate(key, primaryKey) {
    const sourceIsObjectStore = this.source instanceof FDBObjectStore$1;
    const records = this.source instanceof FDBObjectStore$1 ? this.source._rawObjectStore.records : this.source._rawIndex.records;
    let foundRecord;
    if (this.direction === "next") {
      const range2 = makeKeyRange(this._range, [key, this._position], []);
      for (const record of records.values(range2)) {
        const cmpResultKey = key !== void 0 ? cmp(record.key, key) : void 0;
        const cmpResultPosition = this._position !== void 0 ? cmp(record.key, this._position) : void 0;
        if (key !== void 0) {
          if (cmpResultKey === -1) {
            continue;
          }
        }
        if (primaryKey !== void 0) {
          if (cmpResultKey === -1) {
            continue;
          }
          const cmpResultPrimaryKey = cmp(record.value, primaryKey);
          if (cmpResultKey === 0 && cmpResultPrimaryKey === -1) {
            continue;
          }
        }
        if (this._position !== void 0 && sourceIsObjectStore) {
          if (cmpResultPosition !== 1) {
            continue;
          }
        }
        if (this._position !== void 0 && !sourceIsObjectStore) {
          if (cmpResultPosition === -1) {
            continue;
          }
          if (cmpResultPosition === 0 && cmp(record.value, this._objectStorePosition) !== 1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        foundRecord = record;
        break;
      }
    } else if (this.direction === "nextunique") {
      const range2 = makeKeyRange(this._range, [key, this._position], []);
      for (const record of records.values(range2)) {
        if (key !== void 0) {
          if (cmp(record.key, key) === -1) {
            continue;
          }
        }
        if (this._position !== void 0) {
          if (cmp(record.key, this._position) !== 1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        foundRecord = record;
        break;
      }
    } else if (this.direction === "prev") {
      const range2 = makeKeyRange(this._range, [], [key, this._position]);
      for (const record of records.values(range2, "prev")) {
        const cmpResultKey = key !== void 0 ? cmp(record.key, key) : void 0;
        const cmpResultPosition = this._position !== void 0 ? cmp(record.key, this._position) : void 0;
        if (key !== void 0) {
          if (cmpResultKey === 1) {
            continue;
          }
        }
        if (primaryKey !== void 0) {
          if (cmpResultKey === 1) {
            continue;
          }
          const cmpResultPrimaryKey = cmp(record.value, primaryKey);
          if (cmpResultKey === 0 && cmpResultPrimaryKey === 1) {
            continue;
          }
        }
        if (this._position !== void 0 && sourceIsObjectStore) {
          if (cmpResultPosition !== -1) {
            continue;
          }
        }
        if (this._position !== void 0 && !sourceIsObjectStore) {
          if (cmpResultPosition === 1) {
            continue;
          }
          if (cmpResultPosition === 0 && cmp(record.value, this._objectStorePosition) !== -1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        foundRecord = record;
        break;
      }
    } else if (this.direction === "prevunique") {
      let tempRecord;
      const range2 = makeKeyRange(this._range, [], [key, this._position]);
      for (const record of records.values(range2, "prev")) {
        if (key !== void 0) {
          if (cmp(record.key, key) === 1) {
            continue;
          }
        }
        if (this._position !== void 0) {
          if (cmp(record.key, this._position) !== -1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        tempRecord = record;
        break;
      }
      if (tempRecord) {
        foundRecord = records.get(tempRecord.key);
      }
    }
    let result;
    if (!foundRecord) {
      this._key = void 0;
      if (!sourceIsObjectStore) {
        this._objectStorePosition = void 0;
      }
      if (!this._keyOnly && this.toString() === "[object IDBCursorWithValue]") {
        this.value = void 0;
      }
      result = null;
    } else {
      this._position = foundRecord.key;
      if (!sourceIsObjectStore) {
        this._objectStorePosition = foundRecord.value;
      }
      this._key = foundRecord.key;
      if (sourceIsObjectStore) {
        this._primaryKey = structuredCloneWrapper(foundRecord.key);
        if (!this._keyOnly && this.toString() === "[object IDBCursorWithValue]") {
          this.value = structuredCloneWrapper(foundRecord.value);
        }
      } else {
        this._primaryKey = structuredCloneWrapper(foundRecord.value);
        if (!this._keyOnly && this.toString() === "[object IDBCursorWithValue]") {
          if (this.source instanceof FDBObjectStore$1) {
            throw new Error("This should never happen");
          }
          const value = this.source.objectStore._rawObjectStore.getValue(foundRecord.value);
          this.value = structuredCloneWrapper(value);
        }
      }
      this._gotValue = true;
      result = this;
    }
    return result;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-update-IDBRequest-any-value
  update(value) {
    if (value === void 0) {
      throw new TypeError();
    }
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const effectiveKey = this.source.hasOwnProperty("_rawIndex") ? this.primaryKey : this._position;
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue || !this.hasOwnProperty("value")) {
      throw new InvalidStateError();
    }
    const clone2 = structuredCloneWrapper(value);
    if (effectiveObjectStore.keyPath !== null) {
      let tempKey;
      try {
        tempKey = extractKey(effectiveObjectStore.keyPath, clone2);
      } catch (err) {
      }
      if (cmp(tempKey, effectiveKey) !== 0) {
        throw new DataError();
      }
    }
    const record = {
      key: effectiveKey,
      value: clone2
    };
    return transaction._execRequestAsync({
      operation: effectiveObjectStore._rawObjectStore.storeRecord.bind(effectiveObjectStore._rawObjectStore, record, false, transaction._rollbackLog),
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-advance-void-unsigned-long-count
  advance(count2) {
    if (!Number.isInteger(count2) || count2 <= 0) {
      throw new TypeError();
    }
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue) {
      throw new InvalidStateError();
    }
    if (this._request) {
      this._request.readyState = "pending";
    }
    transaction._execRequestAsync({
      operation: () => {
        let result;
        for (let i = 0; i < count2; i++) {
          result = this._iterate();
          if (!result) {
            break;
          }
        }
        return result;
      },
      request: this._request,
      source: this.source
    });
    this._gotValue = false;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-continue-void-any-key
  continue(key) {
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue) {
      throw new InvalidStateError();
    }
    if (key !== void 0) {
      key = valueToKey(key);
      const cmpResult = cmp(key, this._position);
      if (cmpResult <= 0 && (this.direction === "next" || this.direction === "nextunique") || cmpResult >= 0 && (this.direction === "prev" || this.direction === "prevunique")) {
        throw new DataError();
      }
    }
    if (this._request) {
      this._request.readyState = "pending";
    }
    transaction._execRequestAsync({
      operation: this._iterate.bind(this, key),
      request: this._request,
      source: this.source
    });
    this._gotValue = false;
  }
  // hthttps://w3c.github.io/IndexedDB/#dom-idbcursor-continueprimarykey
  continuePrimaryKey(key, primaryKey) {
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (this.source instanceof FDBObjectStore$1 || this.direction !== "next" && this.direction !== "prev") {
      throw new InvalidAccessError();
    }
    if (!this._gotValue) {
      throw new InvalidStateError();
    }
    if (key === void 0 || primaryKey === void 0) {
      throw new DataError();
    }
    key = valueToKey(key);
    const cmpResult = cmp(key, this._position);
    if (cmpResult === -1 && this.direction === "next" || cmpResult === 1 && this.direction === "prev") {
      throw new DataError();
    }
    const cmpResult2 = cmp(primaryKey, this._objectStorePosition);
    if (cmpResult === 0) {
      if (cmpResult2 <= 0 && this.direction === "next" || cmpResult2 >= 0 && this.direction === "prev") {
        throw new DataError();
      }
    }
    if (this._request) {
      this._request.readyState = "pending";
    }
    transaction._execRequestAsync({
      operation: this._iterate.bind(this, key, primaryKey),
      request: this._request,
      source: this.source
    });
    this._gotValue = false;
  }
  delete() {
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const effectiveKey = this.source.hasOwnProperty("_rawIndex") ? this.primaryKey : this._position;
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue || !this.hasOwnProperty("value")) {
      throw new InvalidStateError();
    }
    return transaction._execRequestAsync({
      operation: effectiveObjectStore._rawObjectStore.deleteRecord.bind(effectiveObjectStore._rawObjectStore, effectiveKey, transaction._rollbackLog),
      source: this
    });
  }
  toString() {
    return "[object IDBCursor]";
  }
}
class FDBCursorWithValue extends FDBCursor {
  value = void 0;
  constructor(source, range2, direction, request) {
    super(source, range2, direction, request);
  }
  toString() {
    return "[object IDBCursorWithValue]";
  }
}
const stopped = (event, listener) => {
  return event.immediatePropagationStopped || event.eventPhase === event.CAPTURING_PHASE && listener.capture === false || event.eventPhase === event.BUBBLING_PHASE && listener.capture === true;
};
const invokeEventListeners = (event, obj) => {
  event.currentTarget = obj;
  for (const listener of obj.listeners.slice()) {
    if (event.type !== listener.type || stopped(event, listener)) {
      continue;
    }
    listener.callback.call(event.currentTarget, event);
  }
  const typeToProp = {
    abort: "onabort",
    blocked: "onblocked",
    complete: "oncomplete",
    error: "onerror",
    success: "onsuccess",
    upgradeneeded: "onupgradeneeded",
    versionchange: "onversionchange"
  };
  const prop = typeToProp[event.type];
  if (prop === void 0) {
    throw new Error(`Unknown event type: "${event.type}"`);
  }
  const callback = event.currentTarget[prop];
  if (callback) {
    const listener = {
      callback,
      capture: false,
      type: event.type
    };
    if (!stopped(event, listener)) {
      listener.callback.call(event.currentTarget, event);
    }
  }
};
class FakeEventTarget {
  listeners = [];
  // These will be overridden in individual subclasses and made not readonly
  addEventListener(type2, callback, capture = false) {
    this.listeners.push({
      callback,
      capture,
      type: type2
    });
  }
  removeEventListener(type2, callback, capture = false) {
    const i = this.listeners.findIndex((listener) => {
      return listener.type === type2 && listener.callback === callback && listener.capture === capture;
    });
    this.listeners.splice(i, 1);
  }
  // http://www.w3.org/TR/dom/#dispatching-events
  dispatchEvent(event) {
    if (event.dispatched || !event.initialized) {
      throw new InvalidStateError("The object is in an invalid state.");
    }
    event.isTrusted = false;
    event.dispatched = true;
    event.target = this;
    event.eventPhase = event.CAPTURING_PHASE;
    for (const obj of event.eventPath) {
      if (!event.propagationStopped) {
        invokeEventListeners(event, obj);
      }
    }
    event.eventPhase = event.AT_TARGET;
    if (!event.propagationStopped) {
      invokeEventListeners(event, event.target);
    }
    if (event.bubbles) {
      event.eventPath.reverse();
      event.eventPhase = event.BUBBLING_PHASE;
      for (const obj of event.eventPath) {
        if (!event.propagationStopped) {
          invokeEventListeners(event, obj);
        }
      }
    }
    event.dispatched = false;
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    if (event.canceled) {
      return false;
    }
    return true;
  }
}
class FDBRequest extends FakeEventTarget {
  _result = null;
  _error = null;
  source = null;
  transaction = null;
  readyState = "pending";
  onsuccess = null;
  onerror = null;
  get error() {
    if (this.readyState === "pending") {
      throw new InvalidStateError();
    }
    return this._error;
  }
  set error(value) {
    this._error = value;
  }
  get result() {
    if (this.readyState === "pending") {
      throw new InvalidStateError();
    }
    return this._result;
  }
  set result(value) {
    this._result = value;
  }
  toString() {
    return "[object IDBRequest]";
  }
}
const enforceRange = (num, type2) => {
  const min2 = 0;
  const max2 = type2 === "unsigned long" ? 4294967295 : 9007199254740991;
  if (isNaN(num) || num < min2 || num > max2) {
    throw new TypeError();
  }
  if (num >= 0) {
    return Math.floor(num);
  }
};
class FakeDOMStringList extends Array {
  contains(value) {
    for (const value2 of this) {
      if (value === value2) {
        return true;
      }
    }
    return false;
  }
  item(i) {
    if (i < 0 || i >= this.length) {
      return null;
    }
    return this[i];
  }
  // Used internally, should not be used by others. I could maybe get rid of these and replace rather than mutate, but too lazy to check the spec.
  _push(...values) {
    return Array.prototype.push.call(this, ...values);
  }
  _sort(...values) {
    return Array.prototype.sort.call(this, ...values);
  }
}
const valueToKeyRange = (value, nullDisallowedFlag = false) => {
  if (value instanceof FDBKeyRange) {
    return value;
  }
  if (value === null || value === void 0) {
    if (nullDisallowedFlag) {
      throw new DataError();
    }
    return new FDBKeyRange(void 0, void 0, false, false);
  }
  const key = valueToKey(value);
  return FDBKeyRange.only(key);
};
const confirmActiveTransaction$1 = (index) => {
  if (index._rawIndex.deleted || index.objectStore._rawObjectStore.deleted) {
    throw new InvalidStateError();
  }
  if (index.objectStore.transaction._state !== "active") {
    throw new TransactionInactiveError();
  }
};
class FDBIndex {
  constructor(objectStore, rawIndex) {
    this._rawIndex = rawIndex;
    this._name = rawIndex.name;
    this.objectStore = objectStore;
    this.keyPath = rawIndex.keyPath;
    this.multiEntry = rawIndex.multiEntry;
    this.unique = rawIndex.unique;
  }
  get name() {
    return this._name;
  }
  // https://w3c.github.io/IndexedDB/#dom-idbindex-name
  set name(name) {
    const transaction = this.objectStore.transaction;
    if (!transaction.db._runningVersionchangeTransaction) {
      throw new InvalidStateError();
    }
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (this._rawIndex.deleted || this.objectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    name = String(name);
    if (name === this._name) {
      return;
    }
    if (this.objectStore.indexNames.contains(name)) {
      throw new ConstraintError();
    }
    const oldName = this._name;
    const oldIndexNames = [...this.objectStore.indexNames];
    this._name = name;
    this._rawIndex.name = name;
    this.objectStore._indexesCache.delete(oldName);
    this.objectStore._indexesCache.set(name, this);
    this.objectStore._rawObjectStore.rawIndexes.delete(oldName);
    this.objectStore._rawObjectStore.rawIndexes.set(name, this._rawIndex);
    this.objectStore.indexNames = new FakeDOMStringList(...Array.from(this.objectStore._rawObjectStore.rawIndexes.keys()).filter((indexName) => {
      const index = this.objectStore._rawObjectStore.rawIndexes.get(indexName);
      return index && !index.deleted;
    }).sort());
    transaction._rollbackLog.push(() => {
      this._name = oldName;
      this._rawIndex.name = oldName;
      this.objectStore._indexesCache.delete(name);
      this.objectStore._indexesCache.set(oldName, this);
      this.objectStore._rawObjectStore.rawIndexes.delete(name);
      this.objectStore._rawObjectStore.rawIndexes.set(oldName, this._rawIndex);
      this.objectStore.indexNames = new FakeDOMStringList(...oldIndexNames);
    });
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-openCursor-IDBRequest-any-range-IDBCursorDirection-direction
  openCursor(range2, direction) {
    confirmActiveTransaction$1(this);
    if (range2 === null) {
      range2 = void 0;
    }
    if (range2 !== void 0 && !(range2 instanceof FDBKeyRange)) {
      range2 = FDBKeyRange.only(valueToKey(range2));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.objectStore.transaction;
    const cursor2 = new FDBCursorWithValue(this, range2, direction, request);
    return this.objectStore.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-openKeyCursor-IDBRequest-any-range-IDBCursorDirection-direction
  openKeyCursor(range2, direction) {
    confirmActiveTransaction$1(this);
    if (range2 === null) {
      range2 = void 0;
    }
    if (range2 !== void 0 && !(range2 instanceof FDBKeyRange)) {
      range2 = FDBKeyRange.only(valueToKey(range2));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.objectStore.transaction;
    const cursor2 = new FDBCursor(this, range2, direction, request, true);
    return this.objectStore.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  get(key) {
    confirmActiveTransaction$1(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getValue.bind(this._rawIndex, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbindex-getall
  getAll(query2, count2) {
    if (arguments.length > 1 && count2 !== void 0) {
      count2 = enforceRange(count2, "unsigned long");
    }
    confirmActiveTransaction$1(this);
    const range2 = valueToKeyRange(query2);
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getAllValues.bind(this._rawIndex, range2, count2),
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-getKey-IDBRequest-any-key
  getKey(key) {
    confirmActiveTransaction$1(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getKey.bind(this._rawIndex, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbindex-getallkeys
  getAllKeys(query2, count2) {
    if (arguments.length > 1 && count2 !== void 0) {
      count2 = enforceRange(count2, "unsigned long");
    }
    confirmActiveTransaction$1(this);
    const range2 = valueToKeyRange(query2);
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getAllKeys.bind(this._rawIndex, range2, count2),
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-count-IDBRequest-any-key
  count(key) {
    confirmActiveTransaction$1(this);
    if (key === null) {
      key = void 0;
    }
    if (key !== void 0 && !(key instanceof FDBKeyRange)) {
      key = FDBKeyRange.only(valueToKey(key));
    }
    return this.objectStore.transaction._execRequestAsync({
      operation: () => {
        let count2 = 0;
        const cursor2 = new FDBCursor(this, key);
        while (cursor2._iterate() !== null) {
          count2 += 1;
        }
        return count2;
      },
      source: this
    });
  }
  toString() {
    return "[object IDBIndex]";
  }
}
const canInjectKey = (keyPath, value) => {
  if (Array.isArray(keyPath)) {
    throw new Error("The key paths used in this section are always strings and never sequences, since it is not possible to create a object store which has a key generator and also has a key path that is a sequence.");
  }
  const identifiers = keyPath.split(".");
  if (identifiers.length === 0) {
    throw new Error("Assert: identifiers is not empty");
  }
  identifiers.pop();
  for (const identifier of identifiers) {
    if (typeof value !== "object" && !Array.isArray(value)) {
      return false;
    }
    const hop = value.hasOwnProperty(identifier);
    if (!hop) {
      return true;
    }
    value = value[identifier];
  }
  return typeof value === "object" || Array.isArray(value);
};
function binarySearch(records, key) {
  let low = 0;
  let high = records.length;
  let mid;
  while (low < high) {
    mid = low + high >>> 1;
    if (cmp(records[mid].key, key) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function getIndexByKey(records, key) {
  const idx = binarySearch(records, key);
  const record = records[idx];
  if (record && cmp(record.key, key) === 0) {
    return idx;
  }
  return -1;
}
function getByKey(records, key) {
  const idx = getIndexByKey(records, key);
  return records[idx];
}
function getIndexByKeyRange(records, keyRange) {
  const lowerIdx = typeof keyRange.lower === "undefined" ? 0 : binarySearch(records, keyRange.lower);
  const upperIdx = typeof keyRange.upper === "undefined" ? records.length - 1 : binarySearch(records, keyRange.upper);
  for (let i = lowerIdx; i <= upperIdx; i++) {
    const record = records[i];
    if (record && keyRange.includes(record.key)) {
      return i;
    }
  }
  return -1;
}
function getByKeyRange(records, keyRange) {
  const idx = getIndexByKeyRange(records, keyRange);
  return records[idx];
}
function getIndexByKeyGTE(records, key) {
  const idx = binarySearch(records, key);
  const record = records[idx];
  if (record && cmp(record.key, key) >= 0) {
    return idx;
  }
  return -1;
}
class RecordStore {
  records = [];
  get(key) {
    if (key instanceof FDBKeyRange) {
      return getByKeyRange(this.records, key);
    }
    return getByKey(this.records, key);
  }
  add(newRecord) {
    let i;
    if (this.records.length === 0) {
      i = 0;
    } else {
      i = getIndexByKeyGTE(this.records, newRecord.key);
      if (i === -1) {
        i = this.records.length;
      } else {
        while (i < this.records.length && cmp(this.records[i].key, newRecord.key) === 0) {
          if (cmp(this.records[i].value, newRecord.value) !== -1) {
            break;
          }
          i += 1;
        }
      }
    }
    this.records.splice(i, 0, newRecord);
  }
  delete(key) {
    const deletedRecords = [];
    const isRange = key instanceof FDBKeyRange;
    while (true) {
      const idx = isRange ? getIndexByKeyRange(this.records, key) : getIndexByKey(this.records, key);
      if (idx === -1) {
        break;
      }
      deletedRecords.push(this.records[idx]);
      this.records.splice(idx, 1);
    }
    return deletedRecords;
  }
  deleteByValue(key) {
    const range2 = key instanceof FDBKeyRange ? key : FDBKeyRange.only(key);
    const deletedRecords = [];
    this.records = this.records.filter((record) => {
      const shouldDelete = range2.includes(record.value);
      if (shouldDelete) {
        deletedRecords.push(record);
      }
      return !shouldDelete;
    });
    return deletedRecords;
  }
  clear() {
    const deletedRecords = this.records.slice();
    this.records = [];
    return deletedRecords;
  }
  values(range2, direction = "next") {
    return {
      [Symbol.iterator]: () => {
        let i;
        if (direction === "next") {
          i = 0;
          if (range2 !== void 0 && range2.lower !== void 0) {
            while (this.records[i] !== void 0) {
              const cmpResult = cmp(this.records[i].key, range2.lower);
              if (cmpResult === 1 || cmpResult === 0 && !range2.lowerOpen) {
                break;
              }
              i += 1;
            }
          }
        } else {
          i = this.records.length - 1;
          if (range2 !== void 0 && range2.upper !== void 0) {
            while (this.records[i] !== void 0) {
              const cmpResult = cmp(this.records[i].key, range2.upper);
              if (cmpResult === -1 || cmpResult === 0 && !range2.upperOpen) {
                break;
              }
              i -= 1;
            }
          }
        }
        return {
          next: () => {
            let done;
            let value;
            if (direction === "next") {
              value = this.records[i];
              done = i >= this.records.length;
              i += 1;
              if (!done && range2 !== void 0 && range2.upper !== void 0) {
                const cmpResult = cmp(value.key, range2.upper);
                done = cmpResult === 1 || cmpResult === 0 && range2.upperOpen;
                if (done) {
                  value = void 0;
                }
              }
            } else {
              value = this.records[i];
              done = i < 0;
              i -= 1;
              if (!done && range2 !== void 0 && range2.lower !== void 0) {
                const cmpResult = cmp(value.key, range2.lower);
                done = cmpResult === -1 || cmpResult === 0 && range2.lowerOpen;
                if (done) {
                  value = void 0;
                }
              }
            }
            return {
              done,
              value
            };
          }
        };
      }
    };
  }
}
class Index {
  deleted = false;
  // Initialized should be used to decide whether to throw an error or abort the versionchange transaction when there is a
  // constraint
  initialized = false;
  records = new RecordStore();
  constructor(rawObjectStore, name, keyPath, multiEntry, unique) {
    this.rawObjectStore = rawObjectStore;
    this.name = name;
    this.keyPath = keyPath;
    this.multiEntry = multiEntry;
    this.unique = unique;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-index
  getKey(key) {
    const record = this.records.get(key);
    return record !== void 0 ? record.value : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-referenced-values-from-an-index
  getAllKeys(range2, count2) {
    if (count2 === void 0 || count2 === 0) {
      count2 = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range2)) {
      records.push(structuredCloneWrapper(record.value));
      if (records.length >= count2) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#index-referenced-value-retrieval-operation
  getValue(key) {
    const record = this.records.get(key);
    return record !== void 0 ? this.rawObjectStore.getValue(record.value) : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-referenced-values-from-an-index
  getAllValues(range2, count2) {
    if (count2 === void 0 || count2 === 0) {
      count2 = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range2)) {
      records.push(this.rawObjectStore.getValue(record.value));
      if (records.length >= count2) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-storing-a-record-into-an-object-store (step 7)
  storeRecord(newRecord) {
    let indexKey;
    try {
      indexKey = extractKey(this.keyPath, newRecord.value);
    } catch (err) {
      if (err.name === "DataError") {
        return;
      }
      throw err;
    }
    if (!this.multiEntry || !Array.isArray(indexKey)) {
      try {
        valueToKey(indexKey);
      } catch (e) {
        return;
      }
    } else {
      const keep = [];
      for (const part of indexKey) {
        if (keep.indexOf(part) < 0) {
          try {
            keep.push(valueToKey(part));
          } catch (err) {
          }
        }
      }
      indexKey = keep;
    }
    if (!this.multiEntry || !Array.isArray(indexKey)) {
      if (this.unique) {
        const existingRecord = this.records.get(indexKey);
        if (existingRecord) {
          throw new ConstraintError();
        }
      }
    } else {
      if (this.unique) {
        for (const individualIndexKey of indexKey) {
          const existingRecord = this.records.get(individualIndexKey);
          if (existingRecord) {
            throw new ConstraintError();
          }
        }
      }
    }
    if (!this.multiEntry || !Array.isArray(indexKey)) {
      this.records.add({
        key: indexKey,
        value: newRecord.key
      });
    } else {
      for (const individualIndexKey of indexKey) {
        this.records.add({
          key: individualIndexKey,
          value: newRecord.key
        });
      }
    }
  }
  initialize(transaction) {
    if (this.initialized) {
      throw new Error("Index already initialized");
    }
    transaction._execRequestAsync({
      operation: () => {
        try {
          for (const record of this.rawObjectStore.records.values()) {
            this.storeRecord(record);
          }
          this.initialized = true;
        } catch (err) {
          transaction._abort(err.name);
        }
      },
      source: null
    });
  }
}
const validateKeyPath = (keyPath, parent) => {
  if (keyPath !== void 0 && keyPath !== null && typeof keyPath !== "string" && keyPath.toString && (parent === "array" || !Array.isArray(keyPath))) {
    keyPath = keyPath.toString();
  }
  if (typeof keyPath === "string") {
    if (keyPath === "" && parent !== "string") {
      return;
    }
    try {
      const validIdentifierRegex = /^(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])(?:[\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])*$/;
      if (keyPath.length >= 1 && validIdentifierRegex.test(keyPath)) {
        return;
      }
    } catch (err) {
      throw new SyntaxError(err.message);
    }
    if (keyPath.indexOf(" ") >= 0) {
      throw new SyntaxError("The keypath argument contains an invalid key path (no spaces allowed).");
    }
  }
  if (Array.isArray(keyPath) && keyPath.length > 0) {
    if (parent) {
      throw new SyntaxError("The keypath argument contains an invalid key path (nested arrays).");
    }
    for (const part of keyPath) {
      validateKeyPath(part, "array");
    }
    return;
  } else if (typeof keyPath === "string" && keyPath.indexOf(".") >= 0) {
    keyPath = keyPath.split(".");
    for (const part of keyPath) {
      validateKeyPath(part, "string");
    }
    return;
  }
  throw new SyntaxError();
};
const confirmActiveTransaction = (objectStore) => {
  if (objectStore._rawObjectStore.deleted) {
    throw new InvalidStateError();
  }
  if (objectStore.transaction._state !== "active") {
    throw new TransactionInactiveError();
  }
};
const buildRecordAddPut = (objectStore, value, key) => {
  confirmActiveTransaction(objectStore);
  if (objectStore.transaction.mode === "readonly") {
    throw new ReadOnlyError();
  }
  if (objectStore.keyPath !== null) {
    if (key !== void 0) {
      throw new DataError();
    }
  }
  const clone2 = structuredCloneWrapper(value);
  if (objectStore.keyPath !== null) {
    const tempKey = extractKey(objectStore.keyPath, clone2);
    if (tempKey !== void 0) {
      valueToKey(tempKey);
    } else {
      if (!objectStore._rawObjectStore.keyGenerator) {
        throw new DataError();
      } else if (!canInjectKey(objectStore.keyPath, clone2)) {
        throw new DataError();
      }
    }
  }
  if (objectStore.keyPath === null && objectStore._rawObjectStore.keyGenerator === null && key === void 0) {
    throw new DataError();
  }
  if (key !== void 0) {
    key = valueToKey(key);
  }
  return {
    key,
    value: clone2
  };
};
class FDBObjectStore {
  _indexesCache = /* @__PURE__ */ new Map();
  constructor(transaction, rawObjectStore) {
    this._rawObjectStore = rawObjectStore;
    this._name = rawObjectStore.name;
    this.keyPath = rawObjectStore.keyPath;
    this.autoIncrement = rawObjectStore.autoIncrement;
    this.transaction = transaction;
    this.indexNames = new FakeDOMStringList(...Array.from(rawObjectStore.rawIndexes.keys()).sort());
  }
  get name() {
    return this._name;
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-name
  set name(name) {
    const transaction = this.transaction;
    if (!transaction.db._runningVersionchangeTransaction) {
      throw new InvalidStateError();
    }
    confirmActiveTransaction(this);
    name = String(name);
    if (name === this._name) {
      return;
    }
    if (this._rawObjectStore.rawDatabase.rawObjectStores.has(name)) {
      throw new ConstraintError();
    }
    const oldName = this._name;
    const oldObjectStoreNames = [...transaction.db.objectStoreNames];
    this._name = name;
    this._rawObjectStore.name = name;
    this.transaction._objectStoresCache.delete(oldName);
    this.transaction._objectStoresCache.set(name, this);
    this._rawObjectStore.rawDatabase.rawObjectStores.delete(oldName);
    this._rawObjectStore.rawDatabase.rawObjectStores.set(name, this._rawObjectStore);
    transaction.db.objectStoreNames = new FakeDOMStringList(...Array.from(this._rawObjectStore.rawDatabase.rawObjectStores.keys()).filter((objectStoreName) => {
      const objectStore = this._rawObjectStore.rawDatabase.rawObjectStores.get(objectStoreName);
      return objectStore && !objectStore.deleted;
    }).sort());
    const oldScope = new Set(transaction._scope);
    const oldTransactionObjectStoreNames = [...transaction.objectStoreNames];
    this.transaction._scope.delete(oldName);
    transaction._scope.add(name);
    transaction.objectStoreNames = new FakeDOMStringList(...Array.from(transaction._scope).sort());
    transaction._rollbackLog.push(() => {
      this._name = oldName;
      this._rawObjectStore.name = oldName;
      this.transaction._objectStoresCache.delete(name);
      this.transaction._objectStoresCache.set(oldName, this);
      this._rawObjectStore.rawDatabase.rawObjectStores.delete(name);
      this._rawObjectStore.rawDatabase.rawObjectStores.set(oldName, this._rawObjectStore);
      transaction.db.objectStoreNames = new FakeDOMStringList(...oldObjectStoreNames);
      transaction._scope = oldScope;
      transaction.objectStoreNames = new FakeDOMStringList(...oldTransactionObjectStoreNames);
    });
  }
  put(value, key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    const record = buildRecordAddPut(this, value, key);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, record, false, this.transaction._rollbackLog),
      source: this
    });
  }
  add(value, key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    const record = buildRecordAddPut(this, value, key);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, record, true, this.transaction._rollbackLog),
      source: this
    });
  }
  delete(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    confirmActiveTransaction(this);
    if (this.transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.deleteRecord.bind(this._rawObjectStore, key, this.transaction._rollbackLog),
      source: this
    });
  }
  get(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    confirmActiveTransaction(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getValue.bind(this._rawObjectStore, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getall
  getAll(query2, count2) {
    if (arguments.length > 1 && count2 !== void 0) {
      count2 = enforceRange(count2, "unsigned long");
    }
    confirmActiveTransaction(this);
    const range2 = valueToKeyRange(query2);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getAllValues.bind(this._rawObjectStore, range2, count2),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getkey
  getKey(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    confirmActiveTransaction(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getKey.bind(this._rawObjectStore, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getallkeys
  getAllKeys(query2, count2) {
    if (arguments.length > 1 && count2 !== void 0) {
      count2 = enforceRange(count2, "unsigned long");
    }
    confirmActiveTransaction(this);
    const range2 = valueToKeyRange(query2);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getAllKeys.bind(this._rawObjectStore, range2, count2),
      source: this
    });
  }
  clear() {
    confirmActiveTransaction(this);
    if (this.transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.clear.bind(this._rawObjectStore, this.transaction._rollbackLog),
      source: this
    });
  }
  openCursor(range2, direction) {
    confirmActiveTransaction(this);
    if (range2 === null) {
      range2 = void 0;
    }
    if (range2 !== void 0 && !(range2 instanceof FDBKeyRange)) {
      range2 = FDBKeyRange.only(valueToKey(range2));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.transaction;
    const cursor2 = new FDBCursorWithValue(this, range2, direction, request);
    return this.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  openKeyCursor(range2, direction) {
    confirmActiveTransaction(this);
    if (range2 === null) {
      range2 = void 0;
    }
    if (range2 !== void 0 && !(range2 instanceof FDBKeyRange)) {
      range2 = FDBKeyRange.only(valueToKey(range2));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.transaction;
    const cursor2 = new FDBCursor(this, range2, direction, request, true);
    return this.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBObjectStore-createIndex-IDBIndex-DOMString-name-DOMString-sequence-DOMString--keyPath-IDBIndexParameters-optionalParameters
  createIndex(name, keyPath, optionalParameters = {}) {
    if (arguments.length < 2) {
      throw new TypeError();
    }
    const multiEntry = optionalParameters.multiEntry !== void 0 ? optionalParameters.multiEntry : false;
    const unique = optionalParameters.unique !== void 0 ? optionalParameters.unique : false;
    if (this.transaction.mode !== "versionchange") {
      throw new InvalidStateError();
    }
    confirmActiveTransaction(this);
    if (this.indexNames.contains(name)) {
      throw new ConstraintError();
    }
    validateKeyPath(keyPath);
    if (Array.isArray(keyPath) && multiEntry) {
      throw new InvalidAccessError();
    }
    const indexNames = [...this.indexNames];
    this.transaction._rollbackLog.push(() => {
      const index2 = this._rawObjectStore.rawIndexes.get(name);
      if (index2) {
        index2.deleted = true;
      }
      this.indexNames = new FakeDOMStringList(...indexNames);
      this._rawObjectStore.rawIndexes.delete(name);
    });
    const index = new Index(this._rawObjectStore, name, keyPath, multiEntry, unique);
    this.indexNames._push(name);
    this.indexNames._sort();
    this._rawObjectStore.rawIndexes.set(name, index);
    index.initialize(this.transaction);
    return new FDBIndex(this, index);
  }
  // https://w3c.github.io/IndexedDB/#dom-idbobjectstore-index
  index(name) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    if (this._rawObjectStore.deleted || this.transaction._state === "finished") {
      throw new InvalidStateError();
    }
    const index = this._indexesCache.get(name);
    if (index !== void 0) {
      return index;
    }
    const rawIndex = this._rawObjectStore.rawIndexes.get(name);
    if (!this.indexNames.contains(name) || rawIndex === void 0) {
      throw new NotFoundError();
    }
    const index2 = new FDBIndex(this, rawIndex);
    this._indexesCache.set(name, index2);
    return index2;
  }
  deleteIndex(name) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    if (this.transaction.mode !== "versionchange") {
      throw new InvalidStateError();
    }
    confirmActiveTransaction(this);
    const rawIndex = this._rawObjectStore.rawIndexes.get(name);
    if (rawIndex === void 0) {
      throw new NotFoundError();
    }
    this.transaction._rollbackLog.push(() => {
      rawIndex.deleted = false;
      this._rawObjectStore.rawIndexes.set(name, rawIndex);
      this.indexNames._push(name);
      this.indexNames._sort();
    });
    this.indexNames = new FakeDOMStringList(...Array.from(this.indexNames).filter((indexName) => {
      return indexName !== name;
    }));
    rawIndex.deleted = true;
    this.transaction._execRequestAsync({
      operation: () => {
        const rawIndex2 = this._rawObjectStore.rawIndexes.get(name);
        if (rawIndex === rawIndex2) {
          this._rawObjectStore.rawIndexes.delete(name);
        }
      },
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBObjectStore-count-IDBRequest-any-key
  count(key) {
    confirmActiveTransaction(this);
    if (key === null) {
      key = void 0;
    }
    if (key !== void 0 && !(key instanceof FDBKeyRange)) {
      key = FDBKeyRange.only(valueToKey(key));
    }
    return this.transaction._execRequestAsync({
      operation: () => {
        let count2 = 0;
        const cursor2 = new FDBCursor(this, key);
        while (cursor2._iterate() !== null) {
          count2 += 1;
        }
        return count2;
      },
      source: this
    });
  }
  toString() {
    return "[object IDBObjectStore]";
  }
}
const FDBObjectStore$1 = FDBObjectStore;
class Event {
  eventPath = [];
  NONE = 0;
  CAPTURING_PHASE = 1;
  AT_TARGET = 2;
  BUBBLING_PHASE = 3;
  // Flags
  propagationStopped = false;
  immediatePropagationStopped = false;
  canceled = false;
  initialized = true;
  dispatched = false;
  target = null;
  currentTarget = null;
  eventPhase = 0;
  defaultPrevented = false;
  isTrusted = false;
  timeStamp = Date.now();
  constructor(type2, eventInitDict = {}) {
    this.type = type2;
    this.bubbles = eventInitDict.bubbles !== void 0 ? eventInitDict.bubbles : false;
    this.cancelable = eventInitDict.cancelable !== void 0 ? eventInitDict.cancelable : false;
  }
  preventDefault() {
    if (this.cancelable) {
      this.canceled = true;
    }
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
  stopImmediatePropagation() {
    this.propagationStopped = true;
    this.immediatePropagationStopped = true;
  }
}
function getSetImmediateFromJsdom() {
  if (typeof navigator !== "undefined" && /jsdom/.test(navigator.userAgent)) {
    const outerRealmFunctionConstructor = Node.constructor;
    return new outerRealmFunctionConstructor("return setImmediate")();
  } else {
    return void 0;
  }
}
const queueTask = globalThis.setImmediate || getSetImmediateFromJsdom() || ((fn) => setTimeout(fn, 0));
class FDBTransaction extends FakeEventTarget {
  _state = "active";
  _started = false;
  _rollbackLog = [];
  _objectStoresCache = /* @__PURE__ */ new Map();
  error = null;
  onabort = null;
  oncomplete = null;
  onerror = null;
  _requests = [];
  constructor(storeNames, mode, db2) {
    super();
    this._scope = new Set(storeNames);
    this.mode = mode;
    this.db = db2;
    this.objectStoreNames = new FakeDOMStringList(...Array.from(this._scope).sort());
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-aborting-a-transaction
  _abort(errName) {
    for (const f of this._rollbackLog.reverse()) {
      f();
    }
    if (errName !== null) {
      const e = new Error();
      e.name = errName;
      this.error = e;
    }
    for (const {
      request
    } of this._requests) {
      if (request.readyState !== "done") {
        request.readyState = "done";
        if (request.source) {
          request.result = void 0;
          request.error = new AbortError();
          const event = new Event("error", {
            bubbles: true,
            cancelable: true
          });
          event.eventPath = [this.db, this];
          request.dispatchEvent(event);
        }
      }
    }
    queueTask(() => {
      const event = new Event("abort", {
        bubbles: true,
        cancelable: false
      });
      event.eventPath = [this.db];
      this.dispatchEvent(event);
    });
    this._state = "finished";
  }
  abort() {
    if (this._state === "committing" || this._state === "finished") {
      throw new InvalidStateError();
    }
    this._state = "active";
    this._abort(null);
  }
  // http://w3c.github.io/IndexedDB/#dom-idbtransaction-objectstore
  objectStore(name) {
    if (this._state !== "active") {
      throw new InvalidStateError();
    }
    const objectStore = this._objectStoresCache.get(name);
    if (objectStore !== void 0) {
      return objectStore;
    }
    const rawObjectStore = this.db._rawDatabase.rawObjectStores.get(name);
    if (!this._scope.has(name) || rawObjectStore === void 0) {
      throw new NotFoundError();
    }
    const objectStore2 = new FDBObjectStore$1(this, rawObjectStore);
    this._objectStoresCache.set(name, objectStore2);
    return objectStore2;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-asynchronously-executing-a-request
  _execRequestAsync(obj) {
    const source = obj.source;
    const operation = obj.operation;
    let request = obj.hasOwnProperty("request") ? obj.request : null;
    if (this._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (!request) {
      if (!source) {
        request = new FDBRequest();
      } else {
        request = new FDBRequest();
        request.source = source;
        request.transaction = source.transaction;
      }
    }
    this._requests.push({
      operation,
      request
    });
    return request;
  }
  _start() {
    this._started = true;
    let operation;
    let request;
    while (this._requests.length > 0) {
      const r = this._requests.shift();
      if (r && r.request.readyState !== "done") {
        request = r.request;
        operation = r.operation;
        break;
      }
    }
    if (request && operation) {
      if (!request.source) {
        operation();
      } else {
        let defaultAction;
        let event;
        try {
          const result = operation();
          request.readyState = "done";
          request.result = result;
          request.error = void 0;
          if (this._state === "inactive") {
            this._state = "active";
          }
          event = new Event("success", {
            bubbles: false,
            cancelable: false
          });
        } catch (err) {
          request.readyState = "done";
          request.result = void 0;
          request.error = err;
          if (this._state === "inactive") {
            this._state = "active";
          }
          event = new Event("error", {
            bubbles: true,
            cancelable: true
          });
          defaultAction = this._abort.bind(this, err.name);
        }
        try {
          event.eventPath = [this.db, this];
          request.dispatchEvent(event);
        } catch (err) {
          if (this._state !== "committing") {
            this._abort("AbortError");
          }
          throw err;
        }
        if (!event.canceled) {
          if (defaultAction) {
            defaultAction();
          }
        }
      }
      queueTask(this._start.bind(this));
      return;
    }
    if (this._state !== "finished") {
      this._state = "finished";
      if (!this.error) {
        const event = new Event("complete");
        this.dispatchEvent(event);
      }
    }
  }
  commit() {
    if (this._state !== "active") {
      throw new InvalidStateError();
    }
    this._state = "committing";
  }
  toString() {
    return "[object IDBRequest]";
  }
}
const MAX_KEY = 9007199254740992;
class KeyGenerator {
  // This is kind of wrong. Should start at 1 and increment only after record is saved
  num = 0;
  next() {
    if (this.num >= MAX_KEY) {
      throw new ConstraintError();
    }
    this.num += 1;
    return this.num;
  }
  // https://w3c.github.io/IndexedDB/#possibly-update-the-key-generator
  setIfLarger(num) {
    const value = Math.floor(Math.min(num, MAX_KEY)) - 1;
    if (value >= this.num) {
      this.num = value + 1;
    }
  }
}
class ObjectStore {
  deleted = false;
  records = new RecordStore();
  rawIndexes = /* @__PURE__ */ new Map();
  constructor(rawDatabase, name, keyPath, autoIncrement) {
    this.rawDatabase = rawDatabase;
    this.keyGenerator = autoIncrement === true ? new KeyGenerator() : null;
    this.deleted = false;
    this.name = name;
    this.keyPath = keyPath;
    this.autoIncrement = autoIncrement;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-object-store
  getKey(key) {
    const record = this.records.get(key);
    return record !== void 0 ? structuredCloneWrapper(record.key) : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-keys-from-an-object-store
  getAllKeys(range2, count2) {
    if (count2 === void 0 || count2 === 0) {
      count2 = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range2)) {
      records.push(structuredCloneWrapper(record.key));
      if (records.length >= count2) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-object-store
  getValue(key) {
    const record = this.records.get(key);
    return record !== void 0 ? structuredCloneWrapper(record.value) : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-values-from-an-object-store
  getAllValues(range2, count2) {
    if (count2 === void 0 || count2 === 0) {
      count2 = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range2)) {
      records.push(structuredCloneWrapper(record.value));
      if (records.length >= count2) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-storing-a-record-into-an-object-store
  storeRecord(newRecord, noOverwrite, rollbackLog) {
    if (this.keyPath !== null) {
      const key = extractKey(this.keyPath, newRecord.value);
      if (key !== void 0) {
        newRecord.key = key;
      }
    }
    if (this.keyGenerator !== null && newRecord.key === void 0) {
      if (rollbackLog) {
        const keyGeneratorBefore = this.keyGenerator.num;
        rollbackLog.push(() => {
          if (this.keyGenerator) {
            this.keyGenerator.num = keyGeneratorBefore;
          }
        });
      }
      newRecord.key = this.keyGenerator.next();
      if (this.keyPath !== null) {
        if (Array.isArray(this.keyPath)) {
          throw new Error("Cannot have an array key path in an object store with a key generator");
        }
        let remainingKeyPath = this.keyPath;
        let object2 = newRecord.value;
        let identifier;
        let i = 0;
        while (i >= 0) {
          if (typeof object2 !== "object") {
            throw new DataError();
          }
          i = remainingKeyPath.indexOf(".");
          if (i >= 0) {
            identifier = remainingKeyPath.slice(0, i);
            remainingKeyPath = remainingKeyPath.slice(i + 1);
            if (!object2.hasOwnProperty(identifier)) {
              object2[identifier] = {};
            }
            object2 = object2[identifier];
          }
        }
        identifier = remainingKeyPath;
        object2[identifier] = newRecord.key;
      }
    } else if (this.keyGenerator !== null && typeof newRecord.key === "number") {
      this.keyGenerator.setIfLarger(newRecord.key);
    }
    const existingRecord = this.records.get(newRecord.key);
    if (existingRecord) {
      if (noOverwrite) {
        throw new ConstraintError();
      }
      this.deleteRecord(newRecord.key, rollbackLog);
    }
    this.records.add(newRecord);
    if (rollbackLog) {
      rollbackLog.push(() => {
        this.deleteRecord(newRecord.key);
      });
    }
    for (const rawIndex of this.rawIndexes.values()) {
      if (rawIndex.initialized) {
        rawIndex.storeRecord(newRecord);
      }
    }
    return newRecord.key;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-deleting-records-from-an-object-store
  deleteRecord(key, rollbackLog) {
    const deletedRecords = this.records.delete(key);
    if (rollbackLog) {
      for (const record of deletedRecords) {
        rollbackLog.push(() => {
          this.storeRecord(record, true);
        });
      }
    }
    for (const rawIndex of this.rawIndexes.values()) {
      rawIndex.records.deleteByValue(key);
    }
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-clearing-an-object-store
  clear(rollbackLog) {
    const deletedRecords = this.records.clear();
    if (rollbackLog) {
      for (const record of deletedRecords) {
        rollbackLog.push(() => {
          this.storeRecord(record, true);
        });
      }
    }
    for (const rawIndex of this.rawIndexes.values()) {
      rawIndex.records.clear();
    }
  }
}
const confirmActiveVersionchangeTransaction = (database) => {
  if (!database._runningVersionchangeTransaction) {
    throw new InvalidStateError();
  }
  const transactions = database._rawDatabase.transactions.filter((tx) => {
    return tx.mode === "versionchange";
  });
  const transaction = transactions[transactions.length - 1];
  if (!transaction || transaction._state === "finished") {
    throw new InvalidStateError();
  }
  if (transaction._state !== "active") {
    throw new TransactionInactiveError();
  }
  return transaction;
};
const closeConnection = (connection) => {
  connection._closePending = true;
  const transactionsComplete = connection._rawDatabase.transactions.every((transaction) => {
    return transaction._state === "finished";
  });
  if (transactionsComplete) {
    connection._closed = true;
    connection._rawDatabase.connections = connection._rawDatabase.connections.filter((otherConnection) => {
      return connection !== otherConnection;
    });
  } else {
    queueTask(() => {
      closeConnection(connection);
    });
  }
};
class FDBDatabase extends FakeEventTarget {
  _closePending = false;
  _closed = false;
  _runningVersionchangeTransaction = false;
  constructor(rawDatabase) {
    super();
    this._rawDatabase = rawDatabase;
    this._rawDatabase.connections.push(this);
    this.name = rawDatabase.name;
    this.version = rawDatabase.version;
    this.objectStoreNames = new FakeDOMStringList(...Array.from(rawDatabase.rawObjectStores.keys()).sort());
  }
  // http://w3c.github.io/IndexedDB/#dom-idbdatabase-createobjectstore
  createObjectStore(name, options2 = {}) {
    if (name === void 0) {
      throw new TypeError();
    }
    const transaction = confirmActiveVersionchangeTransaction(this);
    const keyPath = options2 !== null && options2.keyPath !== void 0 ? options2.keyPath : null;
    const autoIncrement = options2 !== null && options2.autoIncrement !== void 0 ? options2.autoIncrement : false;
    if (keyPath !== null) {
      validateKeyPath(keyPath);
    }
    if (this._rawDatabase.rawObjectStores.has(name)) {
      throw new ConstraintError();
    }
    if (autoIncrement && (keyPath === "" || Array.isArray(keyPath))) {
      throw new InvalidAccessError();
    }
    const objectStoreNames = [...this.objectStoreNames];
    transaction._rollbackLog.push(() => {
      const objectStore = this._rawDatabase.rawObjectStores.get(name);
      if (objectStore) {
        objectStore.deleted = true;
      }
      this.objectStoreNames = new FakeDOMStringList(...objectStoreNames);
      transaction._scope.delete(name);
      this._rawDatabase.rawObjectStores.delete(name);
    });
    const rawObjectStore = new ObjectStore(this._rawDatabase, name, keyPath, autoIncrement);
    this.objectStoreNames._push(name);
    this.objectStoreNames._sort();
    transaction._scope.add(name);
    this._rawDatabase.rawObjectStores.set(name, rawObjectStore);
    transaction.objectStoreNames = new FakeDOMStringList(...this.objectStoreNames);
    return transaction.objectStore(name);
  }
  deleteObjectStore(name) {
    if (name === void 0) {
      throw new TypeError();
    }
    const transaction = confirmActiveVersionchangeTransaction(this);
    const store = this._rawDatabase.rawObjectStores.get(name);
    if (store === void 0) {
      throw new NotFoundError();
    }
    this.objectStoreNames = new FakeDOMStringList(...Array.from(this.objectStoreNames).filter((objectStoreName) => {
      return objectStoreName !== name;
    }));
    transaction.objectStoreNames = new FakeDOMStringList(...this.objectStoreNames);
    transaction._rollbackLog.push(() => {
      store.deleted = false;
      this._rawDatabase.rawObjectStores.set(name, store);
      this.objectStoreNames._push(name);
      this.objectStoreNames._sort();
    });
    store.deleted = true;
    this._rawDatabase.rawObjectStores.delete(name);
    transaction._objectStoresCache.delete(name);
  }
  transaction(storeNames, mode) {
    mode = mode !== void 0 ? mode : "readonly";
    if (mode !== "readonly" && mode !== "readwrite" && mode !== "versionchange") {
      throw new TypeError("Invalid mode: " + mode);
    }
    const hasActiveVersionchange = this._rawDatabase.transactions.some((transaction) => {
      return transaction._state === "active" && transaction.mode === "versionchange" && transaction.db === this;
    });
    if (hasActiveVersionchange) {
      throw new InvalidStateError();
    }
    if (this._closePending) {
      throw new InvalidStateError();
    }
    if (!Array.isArray(storeNames)) {
      storeNames = [storeNames];
    }
    if (storeNames.length === 0 && mode !== "versionchange") {
      throw new InvalidAccessError();
    }
    for (const storeName of storeNames) {
      if (!this.objectStoreNames.contains(storeName)) {
        throw new NotFoundError("No objectStore named " + storeName + " in this database");
      }
    }
    const tx = new FDBTransaction(storeNames, mode, this);
    this._rawDatabase.transactions.push(tx);
    this._rawDatabase.processTransactions();
    return tx;
  }
  close() {
    closeConnection(this);
  }
  toString() {
    return "[object IDBDatabase]";
  }
}
class FDBOpenDBRequest extends FDBRequest {
  onupgradeneeded = null;
  onblocked = null;
  toString() {
    return "[object IDBOpenDBRequest]";
  }
}
class FDBVersionChangeEvent extends Event {
  constructor(type2, parameters = {}) {
    super(type2);
    this.newVersion = parameters.newVersion !== void 0 ? parameters.newVersion : null;
    this.oldVersion = parameters.oldVersion !== void 0 ? parameters.oldVersion : 0;
  }
  toString() {
    return "[object IDBVersionChangeEvent]";
  }
}
class Database {
  deletePending = false;
  transactions = [];
  rawObjectStores = /* @__PURE__ */ new Map();
  connections = [];
  constructor(name, version) {
    this.name = name;
    this.version = version;
    this.processTransactions = this.processTransactions.bind(this);
  }
  processTransactions() {
    queueTask(() => {
      const anyRunning = this.transactions.some((transaction) => {
        return transaction._started && transaction._state !== "finished";
      });
      if (!anyRunning) {
        const next = this.transactions.find((transaction) => {
          return !transaction._started && transaction._state !== "finished";
        });
        if (next) {
          next.addEventListener("complete", this.processTransactions);
          next.addEventListener("abort", this.processTransactions);
          next._start();
        }
      }
    });
  }
}
const waitForOthersClosedDelete = (databases, name, openDatabases, cb) => {
  const anyOpen = openDatabases.some((openDatabase2) => {
    return !openDatabase2._closed && !openDatabase2._closePending;
  });
  if (anyOpen) {
    queueTask(() => waitForOthersClosedDelete(databases, name, openDatabases, cb));
    return;
  }
  databases.delete(name);
  cb(null);
};
const deleteDatabase = (databases, name, request, cb) => {
  try {
    const db2 = databases.get(name);
    if (db2 === void 0) {
      cb(null);
      return;
    }
    db2.deletePending = true;
    const openDatabases = db2.connections.filter((connection) => {
      return !connection._closed && !connection._closePending;
    });
    for (const openDatabase2 of openDatabases) {
      if (!openDatabase2._closePending) {
        const event = new FDBVersionChangeEvent("versionchange", {
          newVersion: null,
          oldVersion: db2.version
        });
        openDatabase2.dispatchEvent(event);
      }
    }
    const anyOpen = openDatabases.some((openDatabase3) => {
      return !openDatabase3._closed && !openDatabase3._closePending;
    });
    if (request && anyOpen) {
      const event = new FDBVersionChangeEvent("blocked", {
        newVersion: null,
        oldVersion: db2.version
      });
      request.dispatchEvent(event);
    }
    waitForOthersClosedDelete(databases, name, openDatabases, cb);
  } catch (err) {
    cb(err);
  }
};
const runVersionchangeTransaction = (connection, version, request, cb) => {
  connection._runningVersionchangeTransaction = true;
  const oldVersion = connection.version;
  const openDatabases = connection._rawDatabase.connections.filter((otherDatabase) => {
    return connection !== otherDatabase;
  });
  for (const openDatabase2 of openDatabases) {
    if (!openDatabase2._closed && !openDatabase2._closePending) {
      const event = new FDBVersionChangeEvent("versionchange", {
        newVersion: version,
        oldVersion
      });
      openDatabase2.dispatchEvent(event);
    }
  }
  const anyOpen = openDatabases.some((openDatabase3) => {
    return !openDatabase3._closed && !openDatabase3._closePending;
  });
  if (anyOpen) {
    const event = new FDBVersionChangeEvent("blocked", {
      newVersion: version,
      oldVersion
    });
    request.dispatchEvent(event);
  }
  const waitForOthersClosed = () => {
    const anyOpen2 = openDatabases.some((openDatabase2) => {
      return !openDatabase2._closed && !openDatabase2._closePending;
    });
    if (anyOpen2) {
      queueTask(waitForOthersClosed);
      return;
    }
    connection._rawDatabase.version = version;
    connection.version = version;
    const transaction = connection.transaction(connection.objectStoreNames, "versionchange");
    request.result = connection;
    request.readyState = "done";
    request.transaction = transaction;
    transaction._rollbackLog.push(() => {
      connection._rawDatabase.version = oldVersion;
      connection.version = oldVersion;
    });
    const event = new FDBVersionChangeEvent("upgradeneeded", {
      newVersion: version,
      oldVersion
    });
    request.dispatchEvent(event);
    transaction.addEventListener("error", () => {
      connection._runningVersionchangeTransaction = false;
    });
    transaction.addEventListener("abort", () => {
      connection._runningVersionchangeTransaction = false;
      request.transaction = null;
      queueTask(() => {
        cb(new AbortError());
      });
    });
    transaction.addEventListener("complete", () => {
      connection._runningVersionchangeTransaction = false;
      request.transaction = null;
      queueTask(() => {
        if (connection._closePending) {
          cb(new AbortError());
        } else {
          cb(null);
        }
      });
    });
  };
  waitForOthersClosed();
};
const openDatabase = (databases, name, version, request, cb) => {
  let db2 = databases.get(name);
  if (db2 === void 0) {
    db2 = new Database(name, 0);
    databases.set(name, db2);
  }
  if (version === void 0) {
    version = db2.version !== 0 ? db2.version : 1;
  }
  if (db2.version > version) {
    return cb(new VersionError());
  }
  const connection = new FDBDatabase(db2);
  if (db2.version < version) {
    runVersionchangeTransaction(connection, version, request, (err) => {
      if (err) {
        return cb(err);
      }
      cb(null, connection);
    });
  } else {
    cb(null, connection);
  }
};
class FDBFactory {
  cmp = cmp;
  _databases = /* @__PURE__ */ new Map();
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBFactory-deleteDatabase-IDBOpenDBRequest-DOMString-name
  deleteDatabase(name) {
    const request = new FDBOpenDBRequest();
    request.source = null;
    queueTask(() => {
      const db2 = this._databases.get(name);
      const oldVersion = db2 !== void 0 ? db2.version : 0;
      deleteDatabase(this._databases, name, request, (err) => {
        if (err) {
          request.error = new Error();
          request.error.name = err.name;
          request.readyState = "done";
          const event = new Event("error", {
            bubbles: true,
            cancelable: true
          });
          event.eventPath = [];
          request.dispatchEvent(event);
          return;
        }
        request.result = void 0;
        request.readyState = "done";
        const event2 = new FDBVersionChangeEvent("success", {
          newVersion: null,
          oldVersion
        });
        request.dispatchEvent(event2);
      });
    });
    return request;
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBFactory-open-IDBOpenDBRequest-DOMString-name-unsigned-long-long-version
  open(name, version) {
    if (arguments.length > 1 && version !== void 0) {
      version = enforceRange(version, "MAX_SAFE_INTEGER");
    }
    if (version === 0) {
      throw new TypeError();
    }
    const request = new FDBOpenDBRequest();
    request.source = null;
    queueTask(() => {
      openDatabase(this._databases, name, version, request, (err, connection) => {
        if (err) {
          request.result = void 0;
          request.readyState = "done";
          request.error = new Error();
          request.error.name = err.name;
          const event = new Event("error", {
            bubbles: true,
            cancelable: true
          });
          event.eventPath = [];
          request.dispatchEvent(event);
          return;
        }
        request.result = connection;
        request.readyState = "done";
        const event2 = new Event("success");
        event2.eventPath = [];
        request.dispatchEvent(event2);
      });
    });
    return request;
  }
  // https://w3c.github.io/IndexedDB/#dom-idbfactory-databases
  databases() {
    return new Promise((resolve) => {
      const result = [];
      for (const [name, database] of this._databases) {
        result.push({
          name,
          version: database.version
        });
      }
      resolve(result);
    });
  }
  toString() {
    return "[object IDBFactory]";
  }
}
const fakeIndexedDB = new FDBFactory();
var lib$2 = {};
var plugin = {};
var rxSchema = {};
var hooks = {};
Object.defineProperty(hooks, "__esModule", {
  value: true
});
hooks.HOOKS = void 0;
hooks._clearHook = _clearHook;
hooks.runAsyncPluginHooks = runAsyncPluginHooks;
hooks.runPluginHooks = runPluginHooks;
var HOOKS = {
  /**
   * Runs before a plugin is added.
   * Use this to block the usage of non-compatible plugins.
   */
  preAddRxPlugin: [],
  /**
   * functions that run before the database is created
   */
  preCreateRxDatabase: [],
  /**
   * runs after the database is created and prepared
   * but before the instance is returned to the user
   * @async
   */
  createRxDatabase: [],
  preCreateRxCollection: [],
  createRxCollection: [],
  /**
  * runs at the end of the destroy-process of a collection
  * @async
  */
  postDestroyRxCollection: [],
  /**
   * Runs after a collection is removed.
   * @async
   */
  postRemoveRxCollection: [],
  /**
    * functions that get the json-schema as input
    * to do additionally checks/manipulation
    */
  preCreateRxSchema: [],
  /**
   * functions that run after the RxSchema is created
   * gets RxSchema as attribute
   */
  createRxSchema: [],
  preCreateRxQuery: [],
  /**
   * Runs before a query is send to the
   * prepareQuery function of the storage engine.
   */
  prePrepareQuery: [],
  createRxDocument: [],
  /**
   * runs after a RxDocument is created,
   * cannot be async
   */
  postCreateRxDocument: [],
  /**
   * Runs before a RxStorageInstance is created
   * gets the params of createStorageInstance()
   * as attribute so you can manipulate them.
   * Notice that you have to clone stuff before mutating the inputs.
   */
  preCreateRxStorageInstance: [],
  /**
   * runs on the document-data before the document is migrated
   * {
   *   doc: Object, // original doc-data
   *   migrated: // migrated doc-data after run through migration-strategies
   * }
   */
  preMigrateDocument: [],
  /**
   * runs after the migration of a document has been done
   */
  postMigrateDocument: [],
  /**
   * runs at the beginning of the destroy-process of a database
   */
  preDestroyRxDatabase: [],
  /**
   * runs after a database has been removed
   * @async
   */
  postRemoveRxDatabase: [],
  /**
   * runs before the replication writes the rows to master
   * but before the rows have been modified
   * @async
   */
  preReplicationMasterWrite: [],
  /**
   * runs after the replication has been sent to the server
   * but before the new documents have been handled
   * @async
   */
  preReplicationMasterWriteDocumentsHandle: []
};
hooks.HOOKS = HOOKS;
function runPluginHooks(hookKey, obj) {
  if (HOOKS[hookKey]) {
    HOOKS[hookKey].forEach((fun) => fun(obj));
  }
}
function runAsyncPluginHooks(hookKey, obj) {
  return Promise.all(HOOKS[hookKey].map((fun) => fun(obj)));
}
function _clearHook(type2, fun) {
  HOOKS[type2] = HOOKS[type2].filter((h) => h !== fun);
}
var rxDocument = {};
var rxChangeEvent = {};
Object.defineProperty(rxChangeEvent, "__esModule", {
  value: true
});
rxChangeEvent.flattenEvents = flattenEvents;
rxChangeEvent.getDocumentDataOfRxChangeEvent = getDocumentDataOfRxChangeEvent;
rxChangeEvent.rxChangeEventToEventReduceChangeEvent = rxChangeEventToEventReduceChangeEvent;
var _overwritable$7 = overwritable$1;
var _utils$l = utils;
function getDocumentDataOfRxChangeEvent(rxChangeEvent2) {
  if (rxChangeEvent2.documentData) {
    return rxChangeEvent2.documentData;
  } else {
    return rxChangeEvent2.previousDocumentData;
  }
}
function rxChangeEventToEventReduceChangeEvent(rxChangeEvent2) {
  switch (rxChangeEvent2.operation) {
    case "INSERT":
      return {
        operation: rxChangeEvent2.operation,
        id: rxChangeEvent2.documentId,
        doc: rxChangeEvent2.documentData,
        previous: null
      };
    case "UPDATE":
      return {
        operation: rxChangeEvent2.operation,
        id: rxChangeEvent2.documentId,
        doc: _overwritable$7.overwritable.deepFreezeWhenDevMode(rxChangeEvent2.documentData),
        previous: rxChangeEvent2.previousDocumentData ? rxChangeEvent2.previousDocumentData : "UNKNOWN"
      };
    case "DELETE":
      return {
        operation: rxChangeEvent2.operation,
        id: rxChangeEvent2.documentId,
        doc: null,
        previous: rxChangeEvent2.previousDocumentData
      };
  }
}
function flattenEvents(input) {
  var output = [];
  if (Array.isArray(input)) {
    input.forEach((inputItem) => {
      var add2 = flattenEvents(inputItem);
      (0, _utils$l.appendToArray)(output, add2);
    });
  } else {
    if (input.id && input.events) {
      input.events.forEach((ev) => output.push(ev));
    } else {
      output.push(input);
    }
  }
  var usedIds = /* @__PURE__ */ new Set();
  var nonDuplicate = [];
  output.forEach((ev) => {
    if (!usedIds.has(ev.eventId)) {
      usedIds.add(ev.eventId);
      nonDuplicate.push(ev);
    }
  });
  return nonDuplicate;
}
var incrementalWrite = {};
Object.defineProperty(incrementalWrite, "__esModule", {
  value: true
});
incrementalWrite.IncrementalWriteQueue = void 0;
incrementalWrite.findNewestOfDocumentStates = findNewestOfDocumentStates;
incrementalWrite.modifierFromPublicToInternal = modifierFromPublicToInternal;
var _rxError$f = rxError;
var _utils$k = utils;
var IncrementalWriteQueue = /* @__PURE__ */ function() {
  function IncrementalWriteQueue2(storageInstance, primaryPath, preWrite, postWrite) {
    this.queueByDocId = /* @__PURE__ */ new Map();
    this.isRunning = false;
    this.storageInstance = storageInstance;
    this.primaryPath = primaryPath;
    this.preWrite = preWrite;
    this.postWrite = postWrite;
  }
  var _proto = IncrementalWriteQueue2.prototype;
  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {
    var docId = lastKnownDocumentState[this.primaryPath];
    var ar = (0, _utils$k.getFromMapOrCreate)(this.queueByDocId, docId, () => []);
    var ret = new Promise((resolve, reject) => {
      var item = {
        lastKnownDocumentState,
        modifier,
        resolve,
        reject
      };
      (0, _utils$k.ensureNotFalsy)(ar).push(item);
      this.triggerRun();
    });
    return ret;
  };
  _proto.triggerRun = async function triggerRun() {
    if (this.isRunning === true || this.queueByDocId.size === 0) {
      return;
    }
    this.isRunning = true;
    var writeRows = [];
    var itemsById = this.queueByDocId;
    this.queueByDocId = /* @__PURE__ */ new Map();
    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {
      var oldData = findNewestOfDocumentStates(items.map((i) => i.lastKnownDocumentState));
      var newData = oldData;
      for (var item of items) {
        try {
          newData = await item.modifier(
            /**
             * We have to clone() each time because the modifier
             * might throw while it already changed some properties
             * of the document.
             */
            (0, _utils$k.clone)(newData)
          );
        } catch (err) {
          item.reject(err);
          item.reject = () => {
          };
          item.resolve = () => {
          };
        }
      }
      try {
        await this.preWrite(newData, oldData);
      } catch (err) {
        items.forEach((item2) => item2.reject(err));
        return;
      }
      writeRows.push({
        previous: oldData,
        document: newData
      });
    }));
    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, "incremental-write") : {
      error: {},
      success: {}
    };
    await Promise.all(Array.from(Object.entries(writeResult.success)).map(([docId, result]) => {
      this.postWrite(result);
      var items = (0, _utils$k.getFromMapOrThrow)(itemsById, docId);
      items.forEach((item) => item.resolve(result));
    }));
    Array.from(Object.entries(writeResult.error)).forEach(([docId, error]) => {
      var items = (0, _utils$k.getFromMapOrThrow)(itemsById, docId);
      var isConflict = (0, _rxError$f.isBulkWriteConflictError)(error);
      if (isConflict) {
        var ar = (0, _utils$k.getFromMapOrCreate)(this.queueByDocId, docId, () => []);
        items.reverse().forEach((item) => {
          item.lastKnownDocumentState = (0, _utils$k.ensureNotFalsy)(isConflict.documentInDb);
          (0, _utils$k.ensureNotFalsy)(ar).unshift(item);
        });
      } else {
        var rxError2 = (0, _rxError$f.rxStorageWriteErrorToRxError)(error);
        items.forEach((item) => item.reject(rxError2));
      }
    });
    this.isRunning = false;
    return this.triggerRun();
  };
  return IncrementalWriteQueue2;
}();
incrementalWrite.IncrementalWriteQueue = IncrementalWriteQueue;
function modifierFromPublicToInternal(publicModifier) {
  var ret = async (docData) => {
    var withoutMeta = (0, _utils$k.stripMetaDataFromDocument)(docData);
    withoutMeta._deleted = docData._deleted;
    var modified = await publicModifier(withoutMeta);
    var reattachedMeta = Object.assign({}, modified, {
      _meta: docData._meta,
      _attachments: docData._attachments,
      _rev: docData._rev,
      _deleted: typeof modified._deleted !== "undefined" ? modified._deleted : docData._deleted
    });
    if (typeof reattachedMeta._deleted === "undefined") {
      reattachedMeta._deleted = false;
    }
    return reattachedMeta;
  };
  return ret;
}
function findNewestOfDocumentStates(docs) {
  var newest = docs[0];
  var newestRevisionHeight = (0, _utils$k.parseRevision)(newest._rev).height;
  docs.forEach((doc) => {
    var height = (0, _utils$k.parseRevision)(doc._rev).height;
    if (height > newestRevisionHeight) {
      newest = doc;
      newestRevisionHeight = height;
    }
  });
  return newest;
}
Object.defineProperty(rxDocument, "__esModule", {
  value: true
});
rxDocument.basePrototype = void 0;
rxDocument.beforeDocumentUpdateWrite = beforeDocumentUpdateWrite;
rxDocument.createRxDocumentConstructor = createRxDocumentConstructor;
rxDocument.createWithConstructor = createWithConstructor;
rxDocument.defineGetterSetter = defineGetterSetter;
rxDocument.isRxDocument = isRxDocument;
var _operators$4 = operators;
var _utils$j = utils;
var _rxError$e = rxError;
var _hooks$7 = hooks;
var _rxChangeEvent = rxChangeEvent;
var _overwritable$6 = overwritable$1;
var _rxSchemaHelper$8 = rxSchemaHelper;
var _rxStorageHelper$8 = rxStorageHelper;
var _incrementalWrite$1 = incrementalWrite;
var basePrototype = {
  get primaryPath() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.collection.schema.primaryPath;
  },
  get primary() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data[_this.primaryPath];
  },
  get revision() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._rev;
  },
  get deleted$() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.$.pipe((0, _operators$4.map)((d) => d._deleted));
  },
  get deleted() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._deleted;
  },
  getLatest() {
    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);
    return this.collection._docCache.getCachedRxDocument(latestDocData);
  },
  /**
   * returns the observable which emits the plain-data of this document
   */
  get $() {
    var _this = this;
    return _this.collection.$.pipe((0, _operators$4.filter)((changeEvent) => !changeEvent.isLocal), (0, _operators$4.filter)((changeEvent) => changeEvent.documentId === this.primary), (0, _operators$4.map)((changeEvent) => (0, _rxChangeEvent.getDocumentDataOfRxChangeEvent)(changeEvent)), (0, _operators$4.startWith)(_this.collection._docCache.getLatestDocumentData(this.primary)), (0, _operators$4.distinctUntilChanged)((prev, curr) => prev._rev === curr._rev), (0, _operators$4.map)((docData) => this.collection._docCache.getCachedRxDocument(docData)), (0, _operators$4.shareReplay)(_utils$j.RXJS_SHARE_REPLAY_DEFAULTS));
  },
  /**
   * returns observable of the value of the given path
   */
  get$(path2) {
    if (_overwritable$6.overwritable.isDevMode()) {
      if (path2.includes(".item.")) {
        throw (0, _rxError$e.newRxError)("DOC1", {
          path: path2
        });
      }
      if (path2 === this.primaryPath) {
        throw (0, _rxError$e.newRxError)("DOC2");
      }
      if (this.collection.schema.finalFields.includes(path2)) {
        throw (0, _rxError$e.newRxError)("DOC3", {
          path: path2
        });
      }
      var schemaObj = (0, _rxSchemaHelper$8.getSchemaByObjectPath)(this.collection.schema.jsonSchema, path2);
      if (!schemaObj) {
        throw (0, _rxError$e.newRxError)("DOC4", {
          path: path2
        });
      }
    }
    return this.$.pipe((0, _operators$4.map)((data) => (0, _utils$j.getProperty)(data, path2)), (0, _operators$4.distinctUntilChanged)());
  },
  /**
   * populate the given path
   */
  populate(path2) {
    var schemaObj = (0, _rxSchemaHelper$8.getSchemaByObjectPath)(this.collection.schema.jsonSchema, path2);
    var value = this.get(path2);
    if (!value) {
      return _utils$j.PROMISE_RESOLVE_NULL;
    }
    if (!schemaObj) {
      throw (0, _rxError$e.newRxError)("DOC5", {
        path: path2
      });
    }
    if (!schemaObj.ref) {
      throw (0, _rxError$e.newRxError)("DOC6", {
        path: path2,
        schemaObj
      });
    }
    var refCollection = this.collection.database.collections[schemaObj.ref];
    if (!refCollection) {
      throw (0, _rxError$e.newRxError)("DOC7", {
        ref: schemaObj.ref,
        path: path2,
        schemaObj
      });
    }
    if (schemaObj.type === "array") {
      return refCollection.findByIds(value).exec().then((res) => {
        var valuesIterator = res.values();
        return Array.from(valuesIterator);
      });
    } else {
      return refCollection.findOne(value).exec();
    }
  },
  /**
   * get data by objectPath
   */
  get(objPath) {
    if (!this._data) {
      return void 0;
    }
    var fromCache = this._propertyCache.get(objPath);
    if (fromCache) {
      return fromCache;
    }
    var valueObj = (0, _utils$j.getProperty)(this._data, objPath);
    if (typeof valueObj !== "object" || Array.isArray(valueObj)) {
      return _overwritable$6.overwritable.deepFreezeWhenDevMode(valueObj);
    }
    valueObj = (0, _utils$j.clone)(valueObj);
    defineGetterSetter(this.collection.schema, valueObj, objPath, this);
    this._propertyCache.set(objPath, valueObj);
    return valueObj;
  },
  toJSON(withMetaFields = false) {
    if (!withMetaFields) {
      var data = (0, _utils$j.flatClone)(this._data);
      delete data._rev;
      delete data._attachments;
      delete data._deleted;
      delete data._meta;
      return _overwritable$6.overwritable.deepFreezeWhenDevMode(data);
    } else {
      return _overwritable$6.overwritable.deepFreezeWhenDevMode(this._data);
    }
  },
  toMutableJSON(withMetaFields = false) {
    return (0, _utils$j.clone)(this.toJSON(withMetaFields));
  },
  /**
   * updates document
   * @overwritten by plugin (optional)
   * @param updateObj mongodb-like syntax
   */
  update(_updateObj) {
    throw (0, _utils$j.pluginMissing)("update");
  },
  incrementalUpdate(_updateObj) {
    throw (0, _utils$j.pluginMissing)("update");
  },
  updateCRDT(_updateObj) {
    throw (0, _utils$j.pluginMissing)("crdt");
  },
  putAttachment() {
    throw (0, _utils$j.pluginMissing)("attachments");
  },
  getAttachment() {
    throw (0, _utils$j.pluginMissing)("attachments");
  },
  allAttachments() {
    throw (0, _utils$j.pluginMissing)("attachments");
  },
  get allAttachments$() {
    throw (0, _utils$j.pluginMissing)("attachments");
  },
  async modify(mutationFunction, _context) {
    var oldData = this._data;
    var newData = await (0, _incrementalWrite$1.modifierFromPublicToInternal)(mutationFunction)(oldData);
    return this._saveData(newData, oldData);
  },
  /**
   * runs an incremental update over the document
   * @param function that takes the document-data and returns a new data-object
   */
  incrementalModify(mutationFunction, _context) {
    return this.collection.incrementalWriteQueue.addWrite(this._data, (0, _incrementalWrite$1.modifierFromPublicToInternal)(mutationFunction)).then((result) => this.collection._docCache.getCachedRxDocument(result));
  },
  patch(patch2) {
    var oldData = this._data;
    var newData = (0, _utils$j.clone)(oldData);
    Object.entries(patch2).forEach(([k, v]) => {
      newData[k] = v;
    });
    return this._saveData(newData, oldData);
  },
  /**
   * patches the given properties
   */
  incrementalPatch(patch2) {
    return this.incrementalModify((docData) => {
      Object.entries(patch2).forEach(([k, v]) => {
        docData[k] = v;
      });
      return docData;
    });
  },
  /**
   * saves the new document-data
   * and handles the events
   */
  async _saveData(newData, oldData) {
    newData = (0, _utils$j.flatClone)(newData);
    if (this._data._deleted) {
      throw (0, _rxError$e.newRxError)("DOC11", {
        id: this.primary,
        document: this
      });
    }
    await beforeDocumentUpdateWrite(this.collection, newData, oldData);
    var writeResult = await this.collection.storageInstance.bulkWrite([{
      previous: oldData,
      document: newData
    }], "rx-document-save-data");
    var isError = writeResult.error[this.primary];
    (0, _rxStorageHelper$8.throwIfIsStorageWriteError)(this.collection, this.primary, newData, isError);
    await this.collection._runHooks("post", "save", newData, this);
    return this.collection._docCache.getCachedRxDocument((0, _utils$j.getFromObjectOrThrow)(writeResult.success, this.primary));
  },
  /**
   * Remove the document.
   * Notice that there is no hard delete,
   * instead deleted documents get flagged with _deleted=true.
   */
  remove() {
    var collection = this.collection;
    if (this.deleted) {
      return Promise.reject((0, _rxError$e.newRxError)("DOC13", {
        document: this,
        id: this.primary
      }));
    }
    var deletedData = (0, _utils$j.flatClone)(this._data);
    var removedDocData;
    return collection._runHooks("pre", "remove", deletedData, this).then(async () => {
      deletedData._deleted = true;
      var writeResult = await collection.storageInstance.bulkWrite([{
        previous: this._data,
        document: deletedData
      }], "rx-document-remove");
      var isError = writeResult.error[this.primary];
      (0, _rxStorageHelper$8.throwIfIsStorageWriteError)(collection, this.primary, deletedData, isError);
      return (0, _utils$j.getFromObjectOrThrow)(writeResult.success, this.primary);
    }).then((removed) => {
      removedDocData = removed;
      return this.collection._runHooks("post", "remove", deletedData, this);
    }).then(() => {
      return this.collection._docCache.getCachedRxDocument(removedDocData);
    });
  },
  incrementalRemove() {
    return this.incrementalModify(async (docData) => {
      await this.collection._runHooks("pre", "remove", docData, this);
      docData._deleted = true;
      return docData;
    }).then(async (newDoc) => {
      await this.collection._runHooks("post", "remove", newDoc._data, newDoc);
      return newDoc;
    });
  },
  destroy() {
    throw (0, _rxError$e.newRxError)("DOC14");
  }
};
rxDocument.basePrototype = basePrototype;
function createRxDocumentConstructor(proto = basePrototype) {
  var constructor = function RxDocumentConstructor(collection, docData) {
    this.collection = collection;
    this._data = docData;
    this._propertyCache = /* @__PURE__ */ new Map();
    this.isInstanceOfRxDocument = true;
  };
  constructor.prototype = proto;
  return constructor;
}
function defineGetterSetter(schema, valueObj, objPath = "", thisObj = false) {
  if (valueObj === null) {
    return;
  }
  var pathProperties = (0, _rxSchemaHelper$8.getSchemaByObjectPath)(schema.jsonSchema, objPath);
  if (typeof pathProperties === "undefined")
    return;
  if (pathProperties.properties)
    pathProperties = pathProperties.properties;
  Object.keys(pathProperties).forEach((key) => {
    var fullPath = (0, _utils$j.trimDots)(objPath + "." + key);
    valueObj.__defineGetter__(key, function() {
      var _this = thisObj ? thisObj : this;
      if (!_this.get || typeof _this.get !== "function") {
        return void 0;
      }
      var ret = _this.get(fullPath);
      return ret;
    });
    Object.defineProperty(valueObj, key + "$", {
      get: function() {
        var _this = thisObj ? thisObj : this;
        return _this.get$(fullPath);
      },
      enumerable: false,
      configurable: false
    });
    Object.defineProperty(valueObj, key + "_", {
      get: function() {
        var _this = thisObj ? thisObj : this;
        return _this.populate(fullPath);
      },
      enumerable: false,
      configurable: false
    });
    valueObj.__defineSetter__(key, function(val) {
      var _this = thisObj ? thisObj : this;
      return _this.set(fullPath, val);
    });
  });
}
function createWithConstructor(constructor, collection, jsonData) {
  var doc = new constructor(collection, jsonData);
  (0, _hooks$7.runPluginHooks)("createRxDocument", doc);
  return doc;
}
function isRxDocument(obj) {
  return typeof obj === "object" && obj !== null && "isInstanceOfRxDocument" in obj;
}
function beforeDocumentUpdateWrite(collection, newData, oldData) {
  newData._meta = Object.assign({}, oldData._meta, newData._meta);
  if (_overwritable$6.overwritable.isDevMode()) {
    collection.schema.validateChange(oldData, newData);
  }
  return collection._runHooks("pre", "save", newData, oldData);
}
var _interopRequireDefault$4 = interopRequireDefaultExports$1;
Object.defineProperty(rxSchema, "__esModule", {
  value: true
});
rxSchema.RxSchema = void 0;
rxSchema.createRxSchema = createRxSchema;
rxSchema.getIndexes = getIndexes;
rxSchema.getPreviousVersions = getPreviousVersions;
rxSchema.isRxSchema = isRxSchema;
rxSchema.toTypedRxJsonSchema = toTypedRxJsonSchema;
var _createClass2$3 = _interopRequireDefault$4(requireCreateClass());
var _utils$i = utils;
var _rxError$d = rxError;
var _hooks$6 = hooks;
var _rxDocument$4 = rxDocument;
var _rxSchemaHelper$7 = rxSchemaHelper;
var _overwritable$5 = overwritable$1;
var RxSchema = /* @__PURE__ */ function() {
  function RxSchema2(jsonSchema2, hashFunction) {
    this.jsonSchema = jsonSchema2;
    this.hashFunction = hashFunction;
    this.indexes = getIndexes(this.jsonSchema);
    this.primaryPath = (0, _rxSchemaHelper$7.getPrimaryFieldOfPrimaryKey)(this.jsonSchema.primaryKey);
    this.finalFields = (0, _rxSchemaHelper$7.getFinalFields)(this.jsonSchema);
  }
  var _proto = RxSchema2.prototype;
  _proto.validateChange = function validateChange(dataBefore, dataAfter) {
    this.finalFields.forEach((fieldName) => {
      if (!(0, _utils$i.deepEqual)(dataBefore[fieldName], dataAfter[fieldName])) {
        throw (0, _rxError$d.newRxError)("DOC9", {
          dataBefore,
          dataAfter,
          fieldName,
          schema: this.jsonSchema
        });
      }
    });
  };
  _proto.getDocumentPrototype = function getDocumentPrototype2() {
    var proto = {};
    (0, _rxDocument$4.defineGetterSetter)(this, proto, "");
    (0, _utils$i.overwriteGetterForCaching)(this, "getDocumentPrototype", () => proto);
    return proto;
  };
  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {
    return (0, _rxSchemaHelper$7.getComposedPrimaryKeyOfDocumentData)(this.jsonSchema, documentData);
  };
  (0, _createClass2$3.default)(RxSchema2, [{
    key: "version",
    get: function() {
      return this.jsonSchema.version;
    }
  }, {
    key: "defaultValues",
    get: function() {
      var values = {};
      Object.entries(this.jsonSchema.properties).filter(([, v]) => v.hasOwnProperty("default")).forEach(([k, v]) => values[k] = v.default);
      return (0, _utils$i.overwriteGetterForCaching)(this, "defaultValues", values);
    }
    /**
     * @overrides itself on the first call
     *
     * TODO this should be a pure function that
     * caches the hash in a WeakMap.
     */
  }, {
    key: "hash",
    get: function() {
      return (0, _utils$i.overwriteGetterForCaching)(this, "hash", this.hashFunction(JSON.stringify(this.jsonSchema)));
    }
  }]);
  return RxSchema2;
}();
rxSchema.RxSchema = RxSchema;
function getIndexes(jsonSchema2) {
  return (jsonSchema2.indexes || []).map((index) => (0, _utils$i.isMaybeReadonlyArray)(index) ? index : [index]);
}
function getPreviousVersions(schema) {
  var version = schema.version ? schema.version : 0;
  var c = 0;
  return new Array(version).fill(0).map(() => c++);
}
function createRxSchema(jsonSchema2, hashFunction, runPreCreateHooks = true) {
  if (runPreCreateHooks) {
    (0, _hooks$6.runPluginHooks)("preCreateRxSchema", jsonSchema2);
  }
  var useJsonSchema = (0, _rxSchemaHelper$7.fillWithDefaultSettings)(jsonSchema2);
  useJsonSchema = (0, _rxSchemaHelper$7.normalizeRxJsonSchema)(useJsonSchema);
  _overwritable$5.overwritable.deepFreezeWhenDevMode(useJsonSchema);
  var schema = new RxSchema(useJsonSchema, hashFunction);
  (0, _hooks$6.runPluginHooks)("createRxSchema", schema);
  return schema;
}
function isRxSchema(obj) {
  return obj instanceof RxSchema;
}
function toTypedRxJsonSchema(schema) {
  return schema;
}
var rxQuery = {};
var eventReduce = {};
var lib$1 = {};
var states = {};
var stateResolver = {};
var util$3 = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1)
    return util$3;
  hasRequiredUtil$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProperty = exports.isObject = exports.roundToTwoDecimals = exports.mergeSets = exports.ensureNotFalsy = exports.flatClone = exports.cloneMap = exports.objectToMap = exports.mapToObject = exports.replaceCharAt = exports.getSortFieldsOfQuery = exports.normalizeSortField = exports.tryToFillPreviousDoc = exports.shuffleArray = exports.randomOfArray = exports.lastOfArray = exports.UNKNOWN_VALUE = void 0;
    exports.UNKNOWN_VALUE = "UNKNOWN";
    function lastOfArray2(ar) {
      return ar[ar.length - 1];
    }
    exports.lastOfArray = lastOfArray2;
    function randomOfArray(items) {
      return items[Math.floor(Math.random() * items.length)];
    }
    exports.randomOfArray = randomOfArray;
    function shuffleArray2(arr2) {
      return arr2.slice().sort(() => Math.random() - 0.5);
    }
    exports.shuffleArray = shuffleArray2;
    function tryToFillPreviousDoc(input) {
      const prev = input.changeEvent.previous;
      if (prev === exports.UNKNOWN_VALUE) {
        const id = input.changeEvent.id;
        const primary = input.queryParams.primaryKey;
        if (input.keyDocumentMap) {
          const doc = input.keyDocumentMap.get(id);
          if (doc) {
            input.changeEvent.previous = doc;
          }
        } else {
          const found = input.previousResults.find((item) => item[primary] === id);
          if (found) {
            input.changeEvent.previous = found;
          }
        }
      }
    }
    exports.tryToFillPreviousDoc = tryToFillPreviousDoc;
    function normalizeSortField(field) {
      if (field.startsWith("-")) {
        return field.substr(1);
      } else {
        return field;
      }
    }
    exports.normalizeSortField = normalizeSortField;
    function getSortFieldsOfQuery(query2) {
      if (!query2.sort) {
        return ["_id"];
      }
      return query2.sort.map((maybeArray) => {
        if (Array.isArray(maybeArray)) {
          return maybeArray[0].map((field) => normalizeSortField(field));
        } else {
          return normalizeSortField(maybeArray);
        }
      });
    }
    exports.getSortFieldsOfQuery = getSortFieldsOfQuery;
    function replaceCharAt(str, index, replacement) {
      return str.substr(0, index) + replacement + str.substr(index + replacement.length);
    }
    exports.replaceCharAt = replaceCharAt;
    function mapToObject(map2) {
      const ret = {};
      map2.forEach((value, key) => {
        ret[key] = value;
      });
      return ret;
    }
    exports.mapToObject = mapToObject;
    function objectToMap(object2) {
      const ret = /* @__PURE__ */ new Map();
      Object.entries(object2).forEach(([k, v]) => {
        ret.set(k, v);
      });
      return ret;
    }
    exports.objectToMap = objectToMap;
    function cloneMap(map2) {
      const ret = /* @__PURE__ */ new Map();
      map2.forEach((value, key) => {
        ret[key] = value;
      });
      return ret;
    }
    exports.cloneMap = cloneMap;
    function flatClone2(obj) {
      return Object.assign({}, obj);
    }
    exports.flatClone = flatClone2;
    function ensureNotFalsy2(obj) {
      if (!obj) {
        throw new Error("ensureNotFalsy() is falsy");
      }
      return obj;
    }
    exports.ensureNotFalsy = ensureNotFalsy2;
    function mergeSets(sets) {
      let ret = /* @__PURE__ */ new Set();
      sets.forEach((set2) => {
        ret = /* @__PURE__ */ new Set([...ret, ...set2]);
      });
      return ret;
    }
    exports.mergeSets = mergeSets;
    function roundToTwoDecimals(num) {
      return parseFloat(num.toFixed(2));
    }
    exports.roundToTwoDecimals = roundToTwoDecimals;
    function isObject2(value) {
      const type2 = typeof value;
      return value !== null && (type2 === "object" || type2 === "function");
    }
    exports.isObject = isObject2;
    function getProperty2(object2, path2, value) {
      if (Array.isArray(path2)) {
        path2 = path2.join(".");
      }
      if (!isObject2(object2) || typeof path2 !== "string") {
        return value === void 0 ? object2 : value;
      }
      const pathArray = path2.split(".");
      if (pathArray.length === 0) {
        return value;
      }
      for (let index = 0; index < pathArray.length; index++) {
        const key = pathArray[index];
        if (isStringIndex2(object2, key)) {
          object2 = index === pathArray.length - 1 ? void 0 : null;
        } else {
          object2 = object2[key];
        }
        if (object2 === void 0 || object2 === null) {
          if (index !== pathArray.length - 1) {
            return value;
          }
          break;
        }
      }
      return object2 === void 0 ? value : object2;
    }
    exports.getProperty = getProperty2;
    function isStringIndex2(object2, key) {
      if (typeof key !== "number" && Array.isArray(object2)) {
        const index = Number.parseInt(key, 10);
        return Number.isInteger(index) && object2[index] === object2[key];
      }
      return false;
    }
  })(util$3);
  return util$3;
}
var hasRequiredStateResolver;
function requireStateResolver() {
  if (hasRequiredStateResolver)
    return stateResolver;
  hasRequiredStateResolver = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wasResultsEmpty = exports.doesMatchNow = exports.wasMatching = exports.isSortedAfterLast = exports.isSortedBeforeFirst = exports.wasSortedAfterLast = exports.wasSortedBeforeFirst = exports.wasLast = exports.wasFirst = exports.wasInResult = exports.sortParamsChanged = exports.wasLimitReached = exports.previousUnknown = exports.isUpdate = exports.isInsert = exports.isDelete = exports.hasSkip = exports.isFindOne = exports.hasLimit = void 0;
    const util_12 = requireUtil$1();
    const hasLimit = (input) => {
      return !!input.queryParams.limit;
    };
    exports.hasLimit = hasLimit;
    const isFindOne = (input) => {
      return input.queryParams.limit === 1;
    };
    exports.isFindOne = isFindOne;
    const hasSkip = (input) => {
      if (input.queryParams.skip && input.queryParams.skip > 0) {
        return true;
      } else {
        return false;
      }
    };
    exports.hasSkip = hasSkip;
    const isDelete = (input) => {
      return input.changeEvent.operation === "DELETE";
    };
    exports.isDelete = isDelete;
    const isInsert = (input) => {
      return input.changeEvent.operation === "INSERT";
    };
    exports.isInsert = isInsert;
    const isUpdate = (input) => {
      return input.changeEvent.operation === "UPDATE";
    };
    exports.isUpdate = isUpdate;
    const previousUnknown = (input) => {
      return input.changeEvent.previous === util_12.UNKNOWN_VALUE;
    };
    exports.previousUnknown = previousUnknown;
    const wasLimitReached = (input) => {
      return (0, exports.hasLimit)(input) && input.previousResults.length >= input.queryParams.limit;
    };
    exports.wasLimitReached = wasLimitReached;
    const sortParamsChanged = (input) => {
      const sortFields = input.queryParams.sortFields;
      const prev = input.changeEvent.previous;
      const doc = input.changeEvent.doc;
      if (!doc) {
        return false;
      }
      if (!prev || prev === util_12.UNKNOWN_VALUE) {
        return true;
      }
      for (let i = 0; i < sortFields.length; i++) {
        const field = sortFields[i];
        const beforeData = (0, util_12.getProperty)(prev, field);
        const afterData = (0, util_12.getProperty)(doc, field);
        if (beforeData !== afterData) {
          return true;
        }
      }
      return false;
    };
    exports.sortParamsChanged = sortParamsChanged;
    const wasInResult = (input) => {
      const id = input.changeEvent.id;
      if (input.keyDocumentMap) {
        const has = input.keyDocumentMap.has(id);
        return has;
      } else {
        const primary = input.queryParams.primaryKey;
        const results = input.previousResults;
        for (let i = 0; i < results.length; i++) {
          const item = results[i];
          if (item[primary] === id) {
            return true;
          }
        }
        return false;
      }
    };
    exports.wasInResult = wasInResult;
    const wasFirst = (input) => {
      const first2 = input.previousResults[0];
      if (first2 && first2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      } else {
        return false;
      }
    };
    exports.wasFirst = wasFirst;
    const wasLast = (input) => {
      const last2 = (0, util_12.lastOfArray)(input.previousResults);
      if (last2 && last2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      } else {
        return false;
      }
    };
    exports.wasLast = wasLast;
    const wasSortedBeforeFirst = (input) => {
      const prev = input.changeEvent.previous;
      if (!prev || prev === util_12.UNKNOWN_VALUE) {
        return false;
      }
      const first2 = input.previousResults[0];
      if (!first2) {
        return false;
      }
      if (first2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      }
      const comp = input.queryParams.sortComparator(prev, first2);
      return comp < 0;
    };
    exports.wasSortedBeforeFirst = wasSortedBeforeFirst;
    const wasSortedAfterLast = (input) => {
      const prev = input.changeEvent.previous;
      if (!prev || prev === util_12.UNKNOWN_VALUE) {
        return false;
      }
      const last2 = (0, util_12.lastOfArray)(input.previousResults);
      if (!last2) {
        return false;
      }
      if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      }
      const comp = input.queryParams.sortComparator(prev, last2);
      return comp > 0;
    };
    exports.wasSortedAfterLast = wasSortedAfterLast;
    const isSortedBeforeFirst = (input) => {
      const doc = input.changeEvent.doc;
      if (!doc) {
        return false;
      }
      const first2 = input.previousResults[0];
      if (!first2) {
        return false;
      }
      if (first2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      }
      const comp = input.queryParams.sortComparator(doc, first2);
      return comp < 0;
    };
    exports.isSortedBeforeFirst = isSortedBeforeFirst;
    const isSortedAfterLast = (input) => {
      const doc = input.changeEvent.doc;
      if (!doc) {
        return false;
      }
      const last2 = (0, util_12.lastOfArray)(input.previousResults);
      if (!last2) {
        return false;
      }
      if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      }
      const comp = input.queryParams.sortComparator(doc, last2);
      return comp > 0;
    };
    exports.isSortedAfterLast = isSortedAfterLast;
    const wasMatching = (input) => {
      const prev = input.changeEvent.previous;
      if (!prev || prev === util_12.UNKNOWN_VALUE) {
        return false;
      }
      return input.queryParams.queryMatcher(prev);
    };
    exports.wasMatching = wasMatching;
    const doesMatchNow = (input) => {
      const doc = input.changeEvent.doc;
      if (!doc) {
        return false;
      }
      const ret = input.queryParams.queryMatcher(doc);
      return ret;
    };
    exports.doesMatchNow = doesMatchNow;
    const wasResultsEmpty = (input) => {
      return input.previousResults.length === 0;
    };
    exports.wasResultsEmpty = wasResultsEmpty;
  })(stateResolver);
  return stateResolver;
}
var hasRequiredStates;
function requireStates() {
  if (hasRequiredStates)
    return states;
  hasRequiredStates = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logStateSet = exports.getStateSet = exports.resolveState = exports.stateResolveFunctionByIndex = exports.stateResolveFunctions = exports.orderedStateList = void 0;
    const state_resolver_1 = requireStateResolver();
    __exportStar(requireStateResolver(), exports);
    exports.orderedStateList = [
      "isInsert",
      "isUpdate",
      "isDelete",
      "hasLimit",
      "isFindOne",
      "hasSkip",
      "wasResultsEmpty",
      "previousUnknown",
      "wasLimitReached",
      "wasFirst",
      "wasLast",
      "sortParamsChanged",
      "wasInResult",
      "wasSortedBeforeFirst",
      "wasSortedAfterLast",
      "isSortedBeforeFirst",
      "isSortedAfterLast",
      "wasMatching",
      "doesMatchNow"
    ];
    exports.stateResolveFunctions = {
      isInsert: state_resolver_1.isInsert,
      isUpdate: state_resolver_1.isUpdate,
      isDelete: state_resolver_1.isDelete,
      hasLimit: state_resolver_1.hasLimit,
      isFindOne: state_resolver_1.isFindOne,
      hasSkip: state_resolver_1.hasSkip,
      wasResultsEmpty: state_resolver_1.wasResultsEmpty,
      previousUnknown: state_resolver_1.previousUnknown,
      wasLimitReached: state_resolver_1.wasLimitReached,
      wasFirst: state_resolver_1.wasFirst,
      wasLast: state_resolver_1.wasLast,
      sortParamsChanged: state_resolver_1.sortParamsChanged,
      wasInResult: state_resolver_1.wasInResult,
      wasSortedBeforeFirst: state_resolver_1.wasSortedBeforeFirst,
      wasSortedAfterLast: state_resolver_1.wasSortedAfterLast,
      isSortedBeforeFirst: state_resolver_1.isSortedBeforeFirst,
      isSortedAfterLast: state_resolver_1.isSortedAfterLast,
      wasMatching: state_resolver_1.wasMatching,
      doesMatchNow: state_resolver_1.doesMatchNow
    };
    exports.stateResolveFunctionByIndex = {
      0: state_resolver_1.isInsert,
      1: state_resolver_1.isUpdate,
      2: state_resolver_1.isDelete,
      3: state_resolver_1.hasLimit,
      4: state_resolver_1.isFindOne,
      5: state_resolver_1.hasSkip,
      6: state_resolver_1.wasResultsEmpty,
      7: state_resolver_1.previousUnknown,
      8: state_resolver_1.wasLimitReached,
      9: state_resolver_1.wasFirst,
      10: state_resolver_1.wasLast,
      11: state_resolver_1.sortParamsChanged,
      12: state_resolver_1.wasInResult,
      13: state_resolver_1.wasSortedBeforeFirst,
      14: state_resolver_1.wasSortedAfterLast,
      15: state_resolver_1.isSortedBeforeFirst,
      16: state_resolver_1.isSortedAfterLast,
      17: state_resolver_1.wasMatching,
      18: state_resolver_1.doesMatchNow
    };
    function resolveState(stateName, input) {
      const fn = exports.stateResolveFunctions[stateName];
      if (!fn) {
        throw new Error("resolveState() has no function for " + stateName);
      }
      return fn(input);
    }
    exports.resolveState = resolveState;
    function getStateSet(input) {
      let set2 = "";
      for (let i = 0; i < exports.orderedStateList.length; i++) {
        const name = exports.orderedStateList[i];
        const value = resolveState(name, input);
        const add2 = value ? "1" : "0";
        set2 += add2;
      }
      return set2;
    }
    exports.getStateSet = getStateSet;
    function logStateSet(stateSet) {
      exports.orderedStateList.forEach((state, index) => {
        console.log("state: " + state + " : " + stateSet[index]);
      });
    }
    exports.logStateSet = logStateSet;
  })(states);
  return states;
}
var actions = {};
var actionFunctions = {};
function pushAtSortPosition(array2, item, compareFunction2, low) {
  var length = array2.length;
  var high = length - 1;
  var mid = 0;
  if (length === 0) {
    array2.push(item);
    return 0;
  }
  var lastMidDoc;
  while (low <= high) {
    mid = low + (high - low >> 1);
    lastMidDoc = array2[mid];
    if (compareFunction2(lastMidDoc, item) <= 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  if (compareFunction2(lastMidDoc, item) <= 0) {
    mid++;
  }
  array2.splice(mid, 0, item);
  return mid;
}
const es$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  pushAtSortPosition
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(es$1);
var hasRequiredActionFunctions;
function requireActionFunctions() {
  if (hasRequiredActionFunctions)
    return actionFunctions;
  hasRequiredActionFunctions = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unknownAction = exports.runFullQueryAgain = exports.removeExistingAndInsertAtSortPosition = exports.insertAtSortPosition = exports.alwaysWrong = exports.replaceExisting = exports.removeExisting = exports.removeLastInsertLast = exports.removeFirstInsertFirst = exports.removeLastInsertFirst = exports.removeFirstInsertLast = exports.removeLastItem = exports.removeFirstItem = exports.insertLast = exports.insertFirst = exports.doNothing = void 0;
    const array_push_at_sort_position_1 = require$$0;
    const doNothing = (_input) => {
    };
    exports.doNothing = doNothing;
    const insertFirst = (input) => {
      input.previousResults.unshift(input.changeEvent.doc);
      if (input.keyDocumentMap) {
        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
      }
    };
    exports.insertFirst = insertFirst;
    const insertLast = (input) => {
      input.previousResults.push(input.changeEvent.doc);
      if (input.keyDocumentMap) {
        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
      }
    };
    exports.insertLast = insertLast;
    const removeFirstItem = (input) => {
      const first2 = input.previousResults.shift();
      if (input.keyDocumentMap && first2) {
        input.keyDocumentMap.delete(first2[input.queryParams.primaryKey]);
      }
    };
    exports.removeFirstItem = removeFirstItem;
    const removeLastItem = (input) => {
      const last2 = input.previousResults.pop();
      if (input.keyDocumentMap && last2) {
        input.keyDocumentMap.delete(last2[input.queryParams.primaryKey]);
      }
    };
    exports.removeLastItem = removeLastItem;
    const removeFirstInsertLast = (input) => {
      (0, exports.removeFirstItem)(input);
      (0, exports.insertLast)(input);
    };
    exports.removeFirstInsertLast = removeFirstInsertLast;
    const removeLastInsertFirst = (input) => {
      (0, exports.removeLastItem)(input);
      (0, exports.insertFirst)(input);
    };
    exports.removeLastInsertFirst = removeLastInsertFirst;
    const removeFirstInsertFirst = (input) => {
      (0, exports.removeFirstItem)(input);
      (0, exports.insertFirst)(input);
    };
    exports.removeFirstInsertFirst = removeFirstInsertFirst;
    const removeLastInsertLast = (input) => {
      (0, exports.removeLastItem)(input);
      (0, exports.insertLast)(input);
    };
    exports.removeLastInsertLast = removeLastInsertLast;
    const removeExisting = (input) => {
      if (input.keyDocumentMap) {
        input.keyDocumentMap.delete(input.changeEvent.id);
      }
      const primary = input.queryParams.primaryKey;
      const results = input.previousResults;
      for (let i = 0; i < results.length; i++) {
        const item = results[i];
        if (item[primary] === input.changeEvent.id) {
          results.splice(i, 1);
          break;
        }
      }
    };
    exports.removeExisting = removeExisting;
    const replaceExisting = (input) => {
      const doc = input.changeEvent.doc;
      const primary = input.queryParams.primaryKey;
      const results = input.previousResults;
      for (let i = 0; i < results.length; i++) {
        const item = results[i];
        if (item[primary] === input.changeEvent.id) {
          results[i] = doc;
          if (input.keyDocumentMap) {
            input.keyDocumentMap.set(input.changeEvent.id, doc);
          }
          break;
        }
      }
    };
    exports.replaceExisting = replaceExisting;
    const alwaysWrong = (input) => {
      const wrongHuman = {
        _id: "wrongHuman" + (/* @__PURE__ */ new Date()).getTime()
      };
      input.previousResults.length = 0;
      input.previousResults.push(wrongHuman);
      if (input.keyDocumentMap) {
        input.keyDocumentMap.clear();
        input.keyDocumentMap.set(wrongHuman._id, wrongHuman);
      }
    };
    exports.alwaysWrong = alwaysWrong;
    const insertAtSortPosition = (input) => {
      const docId = input.changeEvent.id;
      const doc = input.changeEvent.doc;
      if (input.keyDocumentMap) {
        if (input.keyDocumentMap.has(docId)) {
          return;
        }
        input.keyDocumentMap.set(docId, doc);
      } else {
        const isDocInResults = input.previousResults.find((d) => d[input.queryParams.primaryKey] === docId);
        if (isDocInResults) {
          return;
        }
      }
      (0, array_push_at_sort_position_1.pushAtSortPosition)(input.previousResults, doc, input.queryParams.sortComparator, 0);
    };
    exports.insertAtSortPosition = insertAtSortPosition;
    const removeExistingAndInsertAtSortPosition = (input) => {
      (0, exports.removeExisting)(input);
      (0, exports.insertAtSortPosition)(input);
    };
    exports.removeExistingAndInsertAtSortPosition = removeExistingAndInsertAtSortPosition;
    const runFullQueryAgain = (_input) => {
      throw new Error("Action runFullQueryAgain must be implemented by yourself");
    };
    exports.runFullQueryAgain = runFullQueryAgain;
    const unknownAction = (_input) => {
      throw new Error("Action unknownAction should never be called");
    };
    exports.unknownAction = unknownAction;
  })(actionFunctions);
  return actionFunctions;
}
var hasRequiredActions;
function requireActions() {
  if (hasRequiredActions)
    return actions;
  hasRequiredActions = 1;
  Object.defineProperty(actions, "__esModule", { value: true });
  actions.actionFunctions = actions.orderedActionList = void 0;
  const action_functions_1 = requireActionFunctions();
  actions.orderedActionList = [
    "doNothing",
    "insertFirst",
    "insertLast",
    "removeFirstItem",
    "removeLastItem",
    "removeFirstInsertLast",
    "removeLastInsertFirst",
    "removeFirstInsertFirst",
    "removeLastInsertLast",
    "removeExisting",
    "replaceExisting",
    "alwaysWrong",
    "insertAtSortPosition",
    "removeExistingAndInsertAtSortPosition",
    "runFullQueryAgain",
    "unknownAction"
  ];
  actions.actionFunctions = {
    doNothing: action_functions_1.doNothing,
    insertFirst: action_functions_1.insertFirst,
    insertLast: action_functions_1.insertLast,
    removeFirstItem: action_functions_1.removeFirstItem,
    removeLastItem: action_functions_1.removeLastItem,
    removeFirstInsertLast: action_functions_1.removeFirstInsertLast,
    removeLastInsertFirst: action_functions_1.removeLastInsertFirst,
    removeFirstInsertFirst: action_functions_1.removeFirstInsertFirst,
    removeLastInsertLast: action_functions_1.removeLastInsertLast,
    removeExisting: action_functions_1.removeExisting,
    replaceExisting: action_functions_1.replaceExisting,
    alwaysWrong: action_functions_1.alwaysWrong,
    insertAtSortPosition: action_functions_1.insertAtSortPosition,
    removeExistingAndInsertAtSortPosition: action_functions_1.removeExistingAndInsertAtSortPosition,
    runFullQueryAgain: action_functions_1.runFullQueryAgain,
    unknownAction: action_functions_1.unknownAction
  };
  return actions;
}
var bdd_generated = {};
var lib = {};
var minimalString = {};
var bddToMinimalString = {};
var stringFormat = {};
var hasRequiredStringFormat;
function requireStringFormat() {
  if (hasRequiredStringFormat)
    return stringFormat;
  hasRequiredStringFormat = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNextCharId = exports.FIRST_CHAR_CODE_FOR_ID = exports.getCharOfValue = exports.getNumberOfChar = exports.getCharOfLevel = exports.CHAR_CODE_OFFSET = void 0;
    exports.CHAR_CODE_OFFSET = 40;
    function getCharOfLevel(level) {
      const charCode = exports.CHAR_CODE_OFFSET + level;
      return String.fromCharCode(charCode);
    }
    exports.getCharOfLevel = getCharOfLevel;
    function getNumberOfChar(char) {
      const charCode = char.charCodeAt(0);
      return charCode - exports.CHAR_CODE_OFFSET;
    }
    exports.getNumberOfChar = getNumberOfChar;
    function getCharOfValue(value) {
      const charCode = exports.CHAR_CODE_OFFSET + value;
      return String.fromCharCode(charCode);
    }
    exports.getCharOfValue = getCharOfValue;
    exports.FIRST_CHAR_CODE_FOR_ID = 97;
    function getNextCharId(lastCode) {
      if (lastCode >= 128 && lastCode <= 160) {
        lastCode = 161;
      }
      const char = String.fromCharCode(lastCode);
      return {
        char,
        nextCode: lastCode + 1
      };
    }
    exports.getNextCharId = getNextCharId;
  })(stringFormat);
  return stringFormat;
}
var hasRequiredBddToMinimalString;
function requireBddToMinimalString() {
  if (hasRequiredBddToMinimalString)
    return bddToMinimalString;
  hasRequiredBddToMinimalString = 1;
  Object.defineProperty(bddToMinimalString, "__esModule", { value: true });
  bddToMinimalString.nodeToString = bddToMinimalString.bddToMinimalString = void 0;
  const string_format_1 = requireStringFormat();
  const string_format_2 = requireStringFormat();
  function bddToMinimalString$1(bdd) {
    let ret = "";
    let currentCharCode = string_format_2.FIRST_CHAR_CODE_FOR_ID;
    const leafNodeAmount = bdd.getLeafNodes().length;
    if (leafNodeAmount > 99) {
      throw new Error("cannot build string with too many leaf nodes");
    }
    ret += leafNodeAmount.toString().padStart(2, "0");
    const levelsHighestFirst = bdd.levels.slice().reverse();
    const idByNode = /* @__PURE__ */ new Map();
    levelsHighestFirst.forEach((level) => {
      const nodes = bdd.getNodesOfLevel(level);
      nodes.forEach((node2) => {
        const stringRep = nodeToString(node2, idByNode, currentCharCode);
        currentCharCode = stringRep.nextCode;
        idByNode.set(node2, stringRep.id);
        ret += stringRep.str;
      });
    });
    return ret;
  }
  bddToMinimalString.bddToMinimalString = bddToMinimalString$1;
  function nodeToString(node2, idByNode, lastCode) {
    const nextId = (0, string_format_1.getNextCharId)(lastCode);
    switch (node2.type) {
      case "LeafNode":
        const valueChar = (0, string_format_1.getCharOfValue)(node2.asLeafNode().value);
        return {
          id: nextId.char,
          nextCode: nextId.nextCode,
          str: nextId.char + valueChar
        };
      case "InternalNode":
        const branch0Id = idByNode.get(node2.asInternalNode().branches.getBranch("0"));
        const branch1Id = idByNode.get(node2.asInternalNode().branches.getBranch("1"));
        return {
          id: nextId.char,
          nextCode: nextId.nextCode,
          str: nextId.char + branch0Id + branch1Id + (0, string_format_1.getCharOfLevel)(node2.level)
        };
      case "RootNode":
        const branch0IdRoot = idByNode.get(node2.asRootNode().branches.getBranch("0"));
        const branch1IdRoot = idByNode.get(node2.asRootNode().branches.getBranch("1"));
        return {
          id: nextId.char,
          nextCode: nextId.nextCode,
          str: "" + branch0IdRoot + branch1IdRoot + (0, string_format_1.getCharOfLevel)(node2.level)
        };
      default:
        throw new Error("unknown node type");
    }
  }
  bddToMinimalString.nodeToString = nodeToString;
  return bddToMinimalString;
}
var minimalStringToSimpleBdd = {};
var util$2 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util$2;
  hasRequiredUtil = 1;
  Object.defineProperty(util$2, "__esModule", { value: true });
  util$2.splitStringToChunks = util$2.lastOfArray = util$2.shuffleArray = util$2.firstKeyOfMap = util$2.getNextStateSet = util$2.maxBinaryWithLength = util$2.minBinaryWithLength = util$2.binaryToDecimal = util$2.oppositeBinary = util$2.decimalToPaddedBinary = util$2.nextNodeId = util$2.lastChar = util$2.oppositeBoolean = util$2.booleanToBooleanString = util$2.booleanStringToBoolean = void 0;
  function booleanStringToBoolean(str) {
    if (str === "1") {
      return true;
    } else {
      return false;
    }
  }
  util$2.booleanStringToBoolean = booleanStringToBoolean;
  function booleanToBooleanString(b) {
    if (b) {
      return "1";
    } else {
      return "0";
    }
  }
  util$2.booleanToBooleanString = booleanToBooleanString;
  function oppositeBoolean(input) {
    if (input === "1") {
      return "0";
    } else {
      return "1";
    }
  }
  util$2.oppositeBoolean = oppositeBoolean;
  function lastChar(str) {
    return str.slice(-1);
  }
  util$2.lastChar = lastChar;
  function makeid(length = 6) {
    let result = "";
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  }
  const nodeIdPrefix = makeid(4);
  let lastIdGen = 0;
  function nextNodeId() {
    const ret = "node_" + nodeIdPrefix + "_" + lastIdGen;
    lastIdGen++;
    return ret;
  }
  util$2.nextNodeId = nextNodeId;
  function decimalToPaddedBinary(decimal, padding) {
    const binary = (decimal >>> 0).toString(2);
    const padded = binary.padStart(padding, "0");
    return padded;
  }
  util$2.decimalToPaddedBinary = decimalToPaddedBinary;
  function oppositeBinary(i) {
    if (i === "1") {
      return "0";
    } else if (i === "0") {
      return "1";
    } else {
      throw new Error("non-binary given");
    }
  }
  util$2.oppositeBinary = oppositeBinary;
  function binaryToDecimal(binary) {
    return parseInt(binary, 2);
  }
  util$2.binaryToDecimal = binaryToDecimal;
  function minBinaryWithLength(length) {
    return new Array(length).fill(0).map(() => "0").join("");
  }
  util$2.minBinaryWithLength = minBinaryWithLength;
  function maxBinaryWithLength(length) {
    return new Array(length).fill(0).map(() => "1").join("");
  }
  util$2.maxBinaryWithLength = maxBinaryWithLength;
  function getNextStateSet(stateSet) {
    const decimal = binaryToDecimal(stateSet);
    const increase = decimal + 1;
    const binary = decimalToPaddedBinary(increase, stateSet.length);
    return binary;
  }
  util$2.getNextStateSet = getNextStateSet;
  function firstKeyOfMap(map2) {
    const iterator1 = map2.keys();
    return iterator1.next().value;
  }
  util$2.firstKeyOfMap = firstKeyOfMap;
  function shuffleArray2(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }
  util$2.shuffleArray = shuffleArray2;
  function lastOfArray2(ar) {
    return ar[ar.length - 1];
  }
  util$2.lastOfArray = lastOfArray2;
  function splitStringToChunks(str, chunkSize) {
    const chunks = [];
    for (let i = 0, charsLength = str.length; i < charsLength; i += chunkSize) {
      chunks.push(str.substring(i, i + chunkSize));
    }
    return chunks;
  }
  util$2.splitStringToChunks = splitStringToChunks;
  return util$2;
}
var hasRequiredMinimalStringToSimpleBdd;
function requireMinimalStringToSimpleBdd() {
  if (hasRequiredMinimalStringToSimpleBdd)
    return minimalStringToSimpleBdd;
  hasRequiredMinimalStringToSimpleBdd = 1;
  Object.defineProperty(minimalStringToSimpleBdd, "__esModule", { value: true });
  minimalStringToSimpleBdd.minimalStringToSimpleBdd = void 0;
  const util_12 = requireUtil();
  const string_format_1 = requireStringFormat();
  function minimalStringToSimpleBdd$1(str) {
    const nodesById = /* @__PURE__ */ new Map();
    const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);
    const lastLeafNodeChar = 2 + leafNodeAmount * 2;
    const leafNodeChars = str.substring(2, lastLeafNodeChar);
    const leafNodeChunks = (0, util_12.splitStringToChunks)(leafNodeChars, 2);
    for (let i = 0; i < leafNodeChunks.length; i++) {
      const chunk = leafNodeChunks[i];
      const id = chunk.charAt(0);
      const value = (0, string_format_1.getNumberOfChar)(chunk.charAt(1));
      nodesById.set(id, value);
    }
    const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);
    const internalNodeChunks = (0, util_12.splitStringToChunks)(internalNodeChars, 4);
    for (let i = 0; i < internalNodeChunks.length; i++) {
      const chunk = internalNodeChunks[i];
      const id = chunk.charAt(0);
      const idOf0Branch = chunk.charAt(1);
      const idOf1Branch = chunk.charAt(2);
      const level = (0, string_format_1.getNumberOfChar)(chunk.charAt(3));
      if (!nodesById.has(idOf0Branch)) {
        throw new Error("missing node with id " + idOf0Branch);
      }
      if (!nodesById.has(idOf1Branch)) {
        throw new Error("missing node with id " + idOf1Branch);
      }
      const node0 = nodesById.get(idOf0Branch);
      const node1 = nodesById.get(idOf1Branch);
      const node2 = {
        l: level,
        0: node0,
        1: node1
      };
      nodesById.set(id, node2);
    }
    const last3 = str.slice(-3);
    const idOf0 = last3.charAt(0);
    const idOf1 = last3.charAt(1);
    const levelOfRoot = (0, string_format_1.getNumberOfChar)(last3.charAt(2));
    const nodeOf0 = nodesById.get(idOf0);
    const nodeOf1 = nodesById.get(idOf1);
    const rootNode2 = {
      l: levelOfRoot,
      0: nodeOf0,
      1: nodeOf1
    };
    return rootNode2;
  }
  minimalStringToSimpleBdd.minimalStringToSimpleBdd = minimalStringToSimpleBdd$1;
  return minimalStringToSimpleBdd;
}
var resolveWithSimpleBdd = {};
var hasRequiredResolveWithSimpleBdd;
function requireResolveWithSimpleBdd() {
  if (hasRequiredResolveWithSimpleBdd)
    return resolveWithSimpleBdd;
  hasRequiredResolveWithSimpleBdd = 1;
  Object.defineProperty(resolveWithSimpleBdd, "__esModule", { value: true });
  resolveWithSimpleBdd.resolveWithSimpleBdd = void 0;
  const util_12 = requireUtil();
  function resolveWithSimpleBdd$1(simpleBdd, fns, input) {
    let currentNode = simpleBdd;
    let currentLevel = simpleBdd.l;
    while (true) {
      const booleanResult = fns[currentLevel](input);
      const branchKey = (0, util_12.booleanToBooleanString)(booleanResult);
      currentNode = currentNode[branchKey];
      if (typeof currentNode === "number" || typeof currentNode === "string") {
        return currentNode;
      } else {
        currentLevel = currentNode.l;
      }
    }
  }
  resolveWithSimpleBdd.resolveWithSimpleBdd = resolveWithSimpleBdd$1;
  return resolveWithSimpleBdd;
}
var bddToSimpleBdd = {};
var hasRequiredBddToSimpleBdd;
function requireBddToSimpleBdd() {
  if (hasRequiredBddToSimpleBdd)
    return bddToSimpleBdd;
  hasRequiredBddToSimpleBdd = 1;
  Object.defineProperty(bddToSimpleBdd, "__esModule", { value: true });
  bddToSimpleBdd.nodeToSimpleBddNode = bddToSimpleBdd.bddToSimpleBdd = void 0;
  function bddToSimpleBdd$1(bdd) {
    return nodeToSimpleBddNode(bdd);
  }
  bddToSimpleBdd.bddToSimpleBdd = bddToSimpleBdd$1;
  function nodeToSimpleBddNode(node2) {
    const branch0 = node2.branches.getBranch("0");
    const branch1 = node2.branches.getBranch("1");
    return {
      l: node2.level,
      0: branch0.isLeafNode() ? branch0.asLeafNode().value : nodeToSimpleBddNode(branch0),
      1: branch1.isLeafNode() ? branch1.asLeafNode().value : nodeToSimpleBddNode(branch1)
    };
  }
  bddToSimpleBdd.nodeToSimpleBddNode = nodeToSimpleBddNode;
  return bddToSimpleBdd;
}
var hasRequiredMinimalString;
function requireMinimalString() {
  if (hasRequiredMinimalString)
    return minimalString;
  hasRequiredMinimalString = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireBddToMinimalString(), exports);
    __exportStar(requireMinimalStringToSimpleBdd(), exports);
    __exportStar(requireResolveWithSimpleBdd(), exports);
    __exportStar(requireStringFormat(), exports);
    __exportStar(requireBddToSimpleBdd(), exports);
  })(minimalString);
  return minimalString;
}
var abstractNode = {};
var findSimilarNode = {};
var hasRequiredFindSimilarNode;
function requireFindSimilarNode() {
  if (hasRequiredFindSimilarNode)
    return findSimilarNode;
  hasRequiredFindSimilarNode = 1;
  Object.defineProperty(findSimilarNode, "__esModule", { value: true });
  findSimilarNode.findSimilarNode = void 0;
  function findSimilarNode$1(own, others) {
    const ownString = own.toString();
    for (let i = 0; i < others.length; i++) {
      const other = others[i];
      if (own !== other && !other.deleted && own.isEqualToOtherNode(other, ownString)) {
        return other;
      }
    }
    return null;
  }
  findSimilarNode.findSimilarNode = findSimilarNode$1;
  return findSimilarNode;
}
var hasRequiredAbstractNode;
function requireAbstractNode() {
  if (hasRequiredAbstractNode)
    return abstractNode;
  hasRequiredAbstractNode = 1;
  Object.defineProperty(abstractNode, "__esModule", { value: true });
  abstractNode.AbstractNode = void 0;
  const util_12 = requireUtil();
  const find_similar_node_1 = requireFindSimilarNode();
  class AbstractNode {
    constructor(level, rootNode2, type2) {
      this.level = level;
      this.id = (0, util_12.nextNodeId)();
      this.deleted = false;
      this.type = type2;
      this.rootNode = rootNode2;
      if (rootNode2) {
        this.rootNode.addNode(this);
      }
    }
    isEqualToOtherNode(otherNode, ownString = this.toString()) {
      const ret = ownString === otherNode.toString();
      return ret;
    }
    // deletes the whole node
    remove() {
      this.ensureNotDeleted("remove");
      if (this.isInternalNode()) {
        const useNode = this;
        if (useNode.parents.size > 0) {
          throw new Error("cannot remove node with parents " + this.id);
        }
      }
      if (this.branches) {
        const useNode = this;
        if (useNode.branches.areBranchesStrictEqual()) {
          useNode.branches.getBranch("0").parents.remove(useNode);
        } else {
          useNode.branches.getBranch("0").parents.remove(useNode);
          useNode.branches.getBranch("1").parents.remove(useNode);
        }
      }
      this.deleted = true;
      this.rootNode.removeNode(this);
    }
    toJSON(withId = false) {
      const ret = {
        id: withId ? this.id : void 0,
        deleted: withId ? this.deleted : void 0,
        type: this.type,
        level: this.level
      };
      if (withId && this.parents) {
        ret.parents = this.parents.toString();
      }
      if (this.isLeafNode()) {
        ret.value = this.asLeafNode().value;
      }
      if (this.branches && !this.branches.deleted) {
        const branches2 = this.branches;
        ret.branches = {
          "0": branches2.getBranch("0").toJSON(withId),
          "1": branches2.getBranch("1").toJSON(withId)
        };
      }
      return ret;
    }
    // a strange string-representation
    // to make an equal check between nodes
    toString() {
      let ret = "<" + this.type + ":" + this.level;
      if (this.branches) {
        const branches2 = this.branches;
        ret += "|0:" + branches2.getBranch("0");
        ret += "|1:" + branches2.getBranch("1");
      }
      if (this.isLeafNode()) {
        ret += "|v:" + this.asLeafNode().value;
      }
      ret += ">";
      return ret;
    }
    isRootNode() {
      return this.type === "RootNode";
    }
    isInternalNode() {
      return this.type === "InternalNode";
    }
    isLeafNode() {
      return this.type === "LeafNode";
    }
    asRootNode() {
      if (!this.isRootNode()) {
        throw new Error("ouch");
      }
      return this;
    }
    asInternalNode() {
      if (!this.isInternalNode()) {
        throw new Error("ouch");
      }
      return this;
    }
    asLeafNode() {
      if (!this.isLeafNode()) {
        throw new Error("ouch");
      }
      return this;
    }
    ensureNotDeleted(op = "unknown") {
      if (this.deleted) {
        throw new Error("forbidden operation " + op + " on deleted node " + this.id);
      }
    }
    log() {
      console.log(JSON.stringify(this.toJSON(true), null, 2));
    }
    /**
    * by the elimination-rule of bdd,
    * if two branches of the same level are equal,
    * one can be removed
    *
    * See page 21 at:
    * @link https://people.eecs.berkeley.edu/~sseshia/219c/lectures/BinaryDecisionDiagrams.pdf
    */
    applyEliminationRule(nodesOfSameLevel) {
      this.ensureNotDeleted("applyEliminationRule");
      if (!nodesOfSameLevel) {
        nodesOfSameLevel = this.rootNode.getNodesOfLevel(this.level);
      }
      const other = (0, find_similar_node_1.findSimilarNode)(this, nodesOfSameLevel);
      if (other) {
        const ownParents = this.parents.getAll();
        const parentsWithStrictEqualBranches = [];
        ownParents.forEach((parent) => {
          const branchKey = parent.branches.getKeyOfNode(this);
          parent.branches.setBranch(branchKey, other);
          if (parent.branches.areBranchesStrictEqual()) {
            parentsWithStrictEqualBranches.push(parent);
          }
          this.parents.remove(parent);
        });
        parentsWithStrictEqualBranches.forEach((node2) => {
          if (node2.isInternalNode()) {
            node2.applyReductionRule();
          }
        });
        return true;
      } else {
        return false;
      }
    }
  }
  abstractNode.AbstractNode = AbstractNode;
  return abstractNode;
}
var branches = {};
var hasRequiredBranches;
function requireBranches() {
  if (hasRequiredBranches)
    return branches;
  hasRequiredBranches = 1;
  Object.defineProperty(branches, "__esModule", { value: true });
  branches.ensureNodesNotStrictEqual = branches.Branches = void 0;
  class Branches {
    constructor(node2) {
      this.node = node2;
      this.deleted = false;
      this.branches = {};
    }
    setBranch(which, branchNode) {
      const previous = this.branches[which];
      if (previous === branchNode) {
        return;
      }
      this.branches[which] = branchNode;
      branchNode.parents.add(this.node);
    }
    getKeyOfNode(node2) {
      if (this.getBranch("0") === node2) {
        return "0";
      } else if (this.getBranch("1") === node2) {
        return "1";
      } else {
        throw new Error("none matched");
      }
    }
    getBranch(which) {
      return this.branches[which];
    }
    getBothBranches() {
      return [
        this.getBranch("0"),
        this.getBranch("1")
      ];
    }
    hasBranchAsNode(node2) {
      if (this.getBranch("0") === node2 || this.getBranch("1") === node2) {
        return true;
      } else {
        return false;
      }
    }
    hasNodeIdAsBranch(id) {
      if (this.getBranch("0").id === id || this.getBranch("1").id === id) {
        return true;
      } else {
        return false;
      }
    }
    areBranchesStrictEqual() {
      return this.branches["0"] === this.branches["1"];
    }
    hasEqualBranches() {
      return JSON.stringify(this.branches["0"]) === JSON.stringify(this.branches["1"]);
    }
  }
  branches.Branches = Branches;
  function ensureNodesNotStrictEqual(node1, node2) {
    if (node1 === node2) {
      throw new Error("cannot have two strict equal branches");
    }
  }
  branches.ensureNodesNotStrictEqual = ensureNodesNotStrictEqual;
  return branches;
}
var createBddFromTruthTable = {};
var rootNode = {};
var hasRequiredRootNode;
function requireRootNode() {
  if (hasRequiredRootNode)
    return rootNode;
  hasRequiredRootNode = 1;
  Object.defineProperty(rootNode, "__esModule", { value: true });
  rootNode.RootNode = void 0;
  const abstract_node_1 = requireAbstractNode();
  const branches_1 = requireBranches();
  const util_12 = requireUtil();
  const minimal_string_1 = requireMinimalString();
  class RootNode extends abstract_node_1.AbstractNode {
    constructor() {
      super(0, null, "RootNode");
      this.branches = new branches_1.Branches(this);
      this.levels = [];
      this.nodesByLevel = /* @__PURE__ */ new Map();
      this.levels.push(0);
      const level0Set = /* @__PURE__ */ new Set();
      level0Set.add(this);
      this.nodesByLevel.set(0, level0Set);
    }
    addNode(node2) {
      const level = node2.level;
      if (!this.levels.includes(level)) {
        this.levels.push(level);
      }
      this.ensureLevelSetExists(level);
      const set2 = this.nodesByLevel.get(level);
      set2 === null || set2 === void 0 ? void 0 : set2.add(node2);
    }
    removeNode(node2) {
      const set2 = this.nodesByLevel.get(node2.level);
      if (!set2.has(node2)) {
        throw new Error("removed non-existing node " + node2.id);
      }
      set2.delete(node2);
    }
    ensureLevelSetExists(level) {
      if (!this.nodesByLevel.has(level)) {
        this.nodesByLevel.set(level, /* @__PURE__ */ new Set());
      }
    }
    getLevels() {
      return Array.from(this.levels).sort((a, b) => a - b);
    }
    getNodesOfLevel(level) {
      this.ensureLevelSetExists(level);
      const set2 = this.nodesByLevel.get(level);
      return Array.from(set2);
    }
    countNodes() {
      let ret = 0;
      this.getLevels().forEach((level) => {
        const nodesAmount = this.getNodesOfLevel(level).length;
        ret = ret + nodesAmount;
      });
      return ret;
    }
    /**
     * applies the reduction rules to the whole bdd
     */
    minimize(logState = false) {
      let done = false;
      while (!done) {
        if (logState) {
          console.log("minimize() itterate once");
        }
        let successCount = 0;
        let lastLevel = (0, util_12.lastOfArray)(this.getLevels());
        while (lastLevel > 0) {
          const nodes = this.getNodesOfLevel(lastLevel);
          if (logState) {
            console.log("minimize() run for level " + lastLevel + " with " + nodes.length + " nodes");
          }
          let nodeCount = 0;
          for (const node2 of nodes) {
            nodeCount++;
            if (logState && nodeCount % 4e3 === 0) {
              console.log("minimize() node #" + node2.id);
            }
            if (node2.isLeafNode()) {
              const reductionDone = node2.asLeafNode().applyEliminationRule();
              if (reductionDone) {
                successCount++;
              }
            }
            if (!node2.deleted && node2.isInternalNode()) {
              const useNode = node2;
              const reductionDone = useNode.applyReductionRule();
              let eliminationDone = false;
              if (!useNode.deleted) {
                eliminationDone = useNode.applyEliminationRule(nodes);
              }
              if (reductionDone || eliminationDone) {
                successCount++;
              }
            }
          }
          lastLevel--;
        }
        if (successCount === 0) {
          done = true;
        } else {
          if (logState) {
            console.log("minimize() itteration done with " + successCount + " minimisations");
          }
        }
      }
    }
    getLeafNodes() {
      const lastLevel = (0, util_12.lastOfArray)(this.getLevels());
      const leafNodes = this.getNodesOfLevel(lastLevel).reverse();
      return leafNodes;
    }
    /**
     * strips all leaf-nodes
     * with the given value
     */
    removeIrrelevantLeafNodes(leafNodeValue) {
      let done = false;
      while (!done) {
        let countRemoved = 0;
        const leafNodes = this.getLeafNodes();
        for (const leafNode2 of leafNodes) {
          const removed = leafNode2.removeIfValueEquals(leafNodeValue);
          if (removed) {
            countRemoved++;
          }
        }
        this.minimize();
        if (countRemoved === 0) {
          done = true;
        }
      }
    }
    resolve(fns, booleanFunctionInput) {
      let currentNode = this;
      while (true) {
        const booleanResult = fns[currentNode.level](booleanFunctionInput);
        const branchKey = (0, util_12.booleanToBooleanString)(booleanResult);
        currentNode = currentNode.branches.getBranch(branchKey);
        if (currentNode.isLeafNode()) {
          return currentNode.asLeafNode().value;
        }
      }
    }
    toSimpleBdd() {
      return (0, minimal_string_1.bddToSimpleBdd)(this);
    }
  }
  rootNode.RootNode = RootNode;
  return rootNode;
}
var internalNode = {};
var parents = {};
var hasRequiredParents;
function requireParents() {
  if (hasRequiredParents)
    return parents;
  hasRequiredParents = 1;
  Object.defineProperty(parents, "__esModule", { value: true });
  parents.Parents = void 0;
  class Parents {
    constructor(node2) {
      this.node = node2;
      this.parents = /* @__PURE__ */ new Set();
    }
    remove(node2) {
      this.parents.delete(node2);
      if (this.parents.size === 0) {
        this.node.remove();
      }
    }
    getAll() {
      return Array.from(this.parents);
    }
    add(node2) {
      if (this.node.level === node2.level) {
        throw new Error("a node cannot be parent of a node with the same level");
      }
      this.parents.add(node2);
    }
    has(node2) {
      return this.parents.has(node2);
    }
    toString() {
      const ret = [];
      for (const parent of this.parents) {
        ret.push(parent.id);
      }
      return ret.join(", ");
    }
    get size() {
      return this.parents.size;
    }
  }
  parents.Parents = Parents;
  return parents;
}
var hasRequiredInternalNode;
function requireInternalNode() {
  if (hasRequiredInternalNode)
    return internalNode;
  hasRequiredInternalNode = 1;
  Object.defineProperty(internalNode, "__esModule", { value: true });
  internalNode.InternalNode = void 0;
  const branches_1 = requireBranches();
  const parents_1 = requireParents();
  const abstract_node_1 = requireAbstractNode();
  class InternalNode extends abstract_node_1.AbstractNode {
    constructor(level, rootNode2, parent) {
      super(level, rootNode2, "InternalNode");
      this.branches = new branches_1.Branches(this);
      this.parents = new parents_1.Parents(this);
      this.parents.add(parent);
    }
    /**
     * by the reduction-rule of bdd,
     * if both branches are equal,
     * we can remove this node from the bdd
     */
    applyReductionRule() {
      if (this.branches.hasEqualBranches()) {
        this.ensureNotDeleted("applyReductionRule");
        const keepBranch = this.branches.getBranch("0");
        const ownParents = this.parents.getAll();
        ownParents.forEach((parent) => {
          const branchKey = parent.branches.getKeyOfNode(this);
          parent.branches.setBranch(branchKey, keepBranch);
          this.parents.remove(parent);
          if (parent.branches.areBranchesStrictEqual() && parent.isInternalNode()) {
            parent.applyReductionRule();
          }
        });
        return true;
      }
      return false;
    }
  }
  internalNode.InternalNode = InternalNode;
  return internalNode;
}
var leafNode = {};
var hasRequiredLeafNode;
function requireLeafNode() {
  if (hasRequiredLeafNode)
    return leafNode;
  hasRequiredLeafNode = 1;
  Object.defineProperty(leafNode, "__esModule", { value: true });
  leafNode.LeafNode = void 0;
  const parents_1 = requireParents();
  const abstract_node_1 = requireAbstractNode();
  const util_12 = requireUtil();
  class LeafNode extends abstract_node_1.AbstractNode {
    constructor(level, rootNode2, value, parent) {
      super(level, rootNode2, "LeafNode");
      this.value = value;
      this.parents = new parents_1.Parents(this);
      this.parents.add(parent);
    }
    removeIfValueEquals(value) {
      this.ensureNotDeleted();
      if (this.value !== value) {
        return false;
      }
      const parents2 = this.parents.getAll();
      parents2.forEach((parent) => {
        const branchKey = parent.branches.getKeyOfNode(this);
        const otherBranch = parent.branches.getBranch((0, util_12.oppositeBoolean)(branchKey));
        this.parents.remove(parent);
        parent.branches.setBranch(branchKey, otherBranch);
        if (parent.isInternalNode()) {
          parent.applyReductionRule();
        }
      });
      return true;
    }
  }
  leafNode.LeafNode = LeafNode;
  return leafNode;
}
var hasRequiredCreateBddFromTruthTable;
function requireCreateBddFromTruthTable() {
  if (hasRequiredCreateBddFromTruthTable)
    return createBddFromTruthTable;
  hasRequiredCreateBddFromTruthTable = 1;
  Object.defineProperty(createBddFromTruthTable, "__esModule", { value: true });
  createBddFromTruthTable.createBddFromTruthTable = void 0;
  const root_node_1 = requireRootNode();
  const util_12 = requireUtil();
  const internal_node_1 = requireInternalNode();
  const leaf_node_1 = requireLeafNode();
  function createBddFromTruthTable$1(truthTable) {
    const root = new root_node_1.RootNode();
    const firstKey = truthTable.keys().next().value;
    const keyLength = firstKey.length;
    const mustBeSize = Math.pow(2, keyLength);
    if (truthTable.size !== mustBeSize) {
      throw new Error("truth table has missing entries");
    }
    for (const [stateSet, value] of truthTable) {
      let lastNode = root;
      for (let i = 0; i < stateSet.length - 1; i++) {
        const level = i + 1;
        const state = stateSet.charAt(i);
        if (!lastNode.branches.getBranch(state)) {
          lastNode.branches.setBranch(state, new internal_node_1.InternalNode(level, root, lastNode));
        }
        lastNode = lastNode.branches.getBranch(state);
      }
      const lastState = (0, util_12.lastChar)(stateSet);
      if (lastNode.branches.getBranch(lastState)) {
        throw new Error("leafNode already exists, this should not happen");
      }
      lastNode.branches.setBranch(lastState, new leaf_node_1.LeafNode(stateSet.length, root, value, lastNode));
    }
    return root;
  }
  createBddFromTruthTable.createBddFromTruthTable = createBddFromTruthTable$1;
  return createBddFromTruthTable;
}
var ensureCorrectBdd = {};
var hasRequiredEnsureCorrectBdd;
function requireEnsureCorrectBdd() {
  if (hasRequiredEnsureCorrectBdd)
    return ensureCorrectBdd;
  hasRequiredEnsureCorrectBdd = 1;
  Object.defineProperty(ensureCorrectBdd, "__esModule", { value: true });
  ensureCorrectBdd.getNodesRecursive = ensureCorrectBdd.ensureCorrectBdd = void 0;
  function ensureCorrectBdd$1(bdd) {
    const jsonString = JSON.stringify(bdd.toJSON(true));
    let allNodes = [];
    const nodesById = /* @__PURE__ */ new Map();
    bdd.getLevels().forEach((level) => {
      const levelNodes = bdd.getNodesOfLevel(level);
      levelNodes.forEach((node2) => {
        nodesById.set(node2.id, node2);
      });
      allNodes = allNodes.concat(levelNodes);
    });
    const recursiveNodes = getNodesRecursive(bdd);
    if (allNodes.length !== recursiveNodes.size) {
      const allNodesIds = allNodes.map((n) => n.id).sort();
      const recursiveNodesIds = Array.from(recursiveNodes).map((n) => n.id).sort();
      const nodesOnlyInRecursive = recursiveNodesIds.filter((id) => !allNodesIds.includes(id));
      if (recursiveNodes.size > allNodes.length) {
        const firstId = nodesOnlyInRecursive[0];
        const referenceToFirst = allNodes.find((n) => {
          if (n.isInternalNode()) {
            return n.branches.hasNodeIdAsBranch(firstId);
          }
          return false;
        });
        console.log("referenceToFirst:");
        referenceToFirst === null || referenceToFirst === void 0 ? void 0 : referenceToFirst.log();
      }
      throw new Error("ensureCorrectBdd() nodes in list not equal size to recursive nodes allNodes: " + allNodes.length + " recursiveNodes: " + recursiveNodes.size + " nodesOnlyInRecursive: " + nodesOnlyInRecursive.join(", ") + " ");
    }
    allNodes.forEach((node2) => {
      if (node2.isRootNode()) {
        return;
      }
      const useNode = node2;
      if (node2.deleted) {
        throw new Error("ensureCorrectBdd() bdd includes a deleted node");
      }
      if (useNode.parents.size === 0) {
        throw new Error("ensureCorrectBdd() node has no parent " + useNode.id);
      }
      if (useNode.isInternalNode()) {
        const internalNode2 = useNode;
        const bothBranches = internalNode2.branches.getBothBranches();
        if (internalNode2.branches.areBranchesStrictEqual()) {
          throw new Error("ensureCorrectBdd() node has two equal branches: " + bothBranches.map((n) => n.id).join(", "));
        }
        bothBranches.forEach((branch) => {
          if (!branch.parents.has(internalNode2)) {
            throw new Error("ensureCorrectBdd() branch must have the node as parent");
          }
        });
      }
      useNode.parents.getAll().forEach((parent) => {
        if (!parent.branches.hasBranchAsNode(useNode)) {
          throw new Error("ensureCorrectBdd() parent node does not have child as branch");
        }
      });
    });
    if (jsonString.includes('"deleted":true')) {
      throw new Error("ensureCorrectBdd() bdd includes a deleted node");
    }
  }
  ensureCorrectBdd.ensureCorrectBdd = ensureCorrectBdd$1;
  function getNodesRecursive(node2, set2 = /* @__PURE__ */ new Set()) {
    set2.add(node2);
    if (!node2.isLeafNode()) {
      const useNode = node2;
      const branch1 = useNode.branches.getBranch("0");
      set2.add(branch1);
      getNodesRecursive(branch1, set2);
      const branch2 = useNode.branches.getBranch("1");
      set2.add(branch2);
      getNodesRecursive(branch2, set2);
    }
    return set2;
  }
  ensureCorrectBdd.getNodesRecursive = getNodesRecursive;
  return ensureCorrectBdd;
}
var fillTruthTable = {};
var hasRequiredFillTruthTable;
function requireFillTruthTable() {
  if (hasRequiredFillTruthTable)
    return fillTruthTable;
  hasRequiredFillTruthTable = 1;
  Object.defineProperty(fillTruthTable, "__esModule", { value: true });
  fillTruthTable.fillTruthTable = void 0;
  const util_12 = requireUtil();
  function fillTruthTable$1(truthTable, inputLength, value) {
    const endInput = (0, util_12.maxBinaryWithLength)(inputLength);
    let currentInput = (0, util_12.minBinaryWithLength)(inputLength);
    let done = false;
    while (!done) {
      if (!truthTable.has(currentInput)) {
        truthTable.set(currentInput, value);
      }
      if (currentInput === endInput) {
        done = true;
      } else {
        currentInput = (0, util_12.getNextStateSet)(currentInput);
      }
    }
  }
  fillTruthTable.fillTruthTable = fillTruthTable$1;
  return fillTruthTable;
}
var optimizeBruteForce = {};
var hasRequiredOptimizeBruteForce;
function requireOptimizeBruteForce() {
  if (hasRequiredOptimizeBruteForce)
    return optimizeBruteForce;
  hasRequiredOptimizeBruteForce = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getArrayWithIndexes = exports.changeKeyOrder = exports.shuffleBooleanOrdering = exports.optimizeBruteForce = exports.defaultCompareResults = void 0;
    const create_bdd_from_truth_table_1 = requireCreateBddFromTruthTable();
    const util_12 = requireUtil();
    const defaultCompareResults = function(a, b) {
      if (a.countNodes() <= b.countNodes()) {
        return a;
      } else {
        return b;
      }
    };
    exports.defaultCompareResults = defaultCompareResults;
    async function optimizeBruteForce2({ truthTable, iterations = Infinity, onBetterBdd = () => null, compareResults = exports.defaultCompareResults, afterBddCreation = () => null, log: log2 = false }) {
      const initialBdd = (0, create_bdd_from_truth_table_1.createBddFromTruthTable)(truthTable);
      afterBddCreation(initialBdd);
      initialBdd.minimize();
      let currentBestResult = {
        truthTable,
        bdd: initialBdd
      };
      if (log2) {
        initialBdd.log();
        console.log("initial nodes amount: " + initialBdd.countNodes());
      }
      let t = 0;
      while (t < iterations) {
        t++;
        if (log2) {
          console.log("-".repeat(50));
          console.log("optimizeBruteForce() itterate once");
        }
        const shuffledOrdering = shuffleBooleanOrdering(truthTable);
        const nextBdd = (0, create_bdd_from_truth_table_1.createBddFromTruthTable)(shuffledOrdering.newTable);
        const newNodesByLevel = /* @__PURE__ */ new Map();
        const lastLevel = (0, util_12.lastOfArray)(nextBdd.getLevels());
        const newSortedLevels = [];
        nextBdd.getLevels().filter((level) => level !== lastLevel).forEach((level) => {
          const newLevel = shuffledOrdering.mappingBeforeToAfter[level];
          newSortedLevels.push(newLevel);
          const levelSet = /* @__PURE__ */ new Set();
          newNodesByLevel.set(newLevel, levelSet);
          nextBdd.getNodesOfLevel(level).forEach((node2) => {
            node2.level = newLevel;
            levelSet.add(node2);
          });
        });
        const lastLevelSet = /* @__PURE__ */ new Set();
        nextBdd.getNodesOfLevel(lastLevel).forEach((node2) => lastLevelSet.add(node2));
        newNodesByLevel.set(lastLevel, lastLevelSet);
        newSortedLevels.push(lastLevel);
        nextBdd.nodesByLevel = newNodesByLevel;
        nextBdd.levels = newSortedLevels;
        afterBddCreation(nextBdd);
        nextBdd.minimize();
        if (log2) {
          console.log("got new bdd with nodes amount of " + nextBdd.countNodes());
          console.dir(shuffledOrdering.mappingBeforeToAfter);
        }
        const betterBdd = await compareResults(currentBestResult.bdd, nextBdd);
        if (betterBdd.type !== "RootNode") {
          throw new Error("compareResults did not return a bdd");
        }
        if (betterBdd === nextBdd) {
          if (log2) {
            console.log("#".repeat(50));
            console.log("found better bdd " + nextBdd.countNodes());
          }
          currentBestResult = {
            bdd: nextBdd,
            truthTable: shuffledOrdering.newTable
          };
          onBetterBdd(currentBestResult);
        }
      }
      return currentBestResult;
    }
    exports.optimizeBruteForce = optimizeBruteForce2;
    function shuffleBooleanOrdering(truthTable) {
      const firstKey = (0, util_12.firstKeyOfMap)(truthTable);
      const arrayWithIndexes = getArrayWithIndexes(firstKey.length);
      const shuffled = (0, util_12.shuffleArray)(arrayWithIndexes);
      const mapping = {};
      const mappingBeforeToAfter = {};
      shuffled.forEach((indexBefore, indexAfter) => {
        mapping[indexAfter] = indexBefore;
        mappingBeforeToAfter[indexBefore] = indexAfter;
      });
      const newTable = /* @__PURE__ */ new Map();
      for (const [key, value] of truthTable.entries()) {
        const newKey = changeKeyOrder(key, mapping);
        newTable.set(newKey, value);
      }
      return {
        newTable,
        mapping,
        mappingBeforeToAfter
      };
    }
    exports.shuffleBooleanOrdering = shuffleBooleanOrdering;
    function changeKeyOrder(oldKey, mappingBeforeToAfter) {
      const chars = oldKey.split("").map((char, indexBefore) => {
        return {
          char,
          indexBefore,
          indexAfter: mappingBeforeToAfter[indexBefore]
        };
      }).sort((a, b) => a.indexAfter - b.indexAfter).map((charObj) => charObj.char).join("");
      return chars;
    }
    exports.changeKeyOrder = changeKeyOrder;
    function getArrayWithIndexes(size2) {
      const ret = [];
      let last2 = 0;
      while (last2 < size2) {
        ret.push(last2);
        last2++;
      }
      return ret;
    }
    exports.getArrayWithIndexes = getArrayWithIndexes;
  })(optimizeBruteForce);
  return optimizeBruteForce;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1)
    return lib;
  hasRequiredLib$1 = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireMinimalString(), exports);
    __exportStar(requireAbstractNode(), exports);
    __exportStar(requireBranches(), exports);
    __exportStar(requireCreateBddFromTruthTable(), exports);
    __exportStar(requireEnsureCorrectBdd(), exports);
    __exportStar(requireFillTruthTable(), exports);
    __exportStar(requireFindSimilarNode(), exports);
    __exportStar(requireInternalNode(), exports);
    __exportStar(requireLeafNode(), exports);
    __exportStar(requireOptimizeBruteForce(), exports);
    __exportStar(requireParents(), exports);
    __exportStar(requireRootNode(), exports);
    __exportStar(requireUtil(), exports);
  })(lib);
  return lib;
}
var hasRequiredBdd_generated;
function requireBdd_generated() {
  if (hasRequiredBdd_generated)
    return bdd_generated;
  hasRequiredBdd_generated = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveInput = exports.getSimpleBdd = exports.minimalBddString = void 0;
    const binary_decision_diagram_1 = requireLib$1();
    const states_1 = requireStates();
    exports.minimalBddString = "14a2b0c/d1e,f+g5h.i4j*k-l)m(n6ohk1pdf1qef1rin-sjn-ton-ugn-vmn-whn-xkn-yln-zdf5{ef5|wx5}df7~dz7ef7¡bk7¢e{7£g|7¤ry7¥dp7¦gk7§eq7¨gt7©ac7ªmv7«gu7¬nm7­iy7®nw7¯¤s8°«¦8±¬k8²ªm8³®v8´«n8µ¬n8¶vm8·xv8¸mn8¹­j8º®m8»xm8¼­¹3½}~3¾©°3¿¢3À¡£3Ám±3Â®º3Ãmº3Ä©´3Åb®3Æmµ3Çm»3Èx»3Ékn3Êm¸3Ë¼j6ÌÂm6ÍÆÃ6ÎÈm6Ïnm6ÐÊÇ6ÑÌÎ,ÒÍÐ,ÓÅÉ,Ô²¶,Õ³·,Ö®n,×º»,Ømf9ÙËÁ9Úym9ÛmÏ9ÜÑÒ9Ýz{2Þpq2ß½¿2à¾À2á¥§2â°¨2ãÄÓ2ä´Ö2åÝn0æÞn0çØÛ0èÙÜ0éßn0êàã0ë²Ô0ì¯Õ0íán0îâä0ï¹×0ðçv/ñåæ/òçë/óèì/ôéí/õêî/öÚy/÷òm(øóï(ùöy(ú÷ø:ûôõ:ümù:ýðñ4þúû4ÿþý*Āüm*ÿĀ.";
    let simpleBdd;
    function getSimpleBdd() {
      if (!simpleBdd) {
        simpleBdd = (0, binary_decision_diagram_1.minimalStringToSimpleBdd)(exports.minimalBddString);
      }
      return simpleBdd;
    }
    exports.getSimpleBdd = getSimpleBdd;
    const resolveInput = (input) => {
      return (0, binary_decision_diagram_1.resolveWithSimpleBdd)(getSimpleBdd(), states_1.stateResolveFunctionByIndex, input);
    };
    exports.resolveInput = resolveInput;
  })(bdd_generated);
  return bdd_generated;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib$1;
  hasRequiredLib = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.runAction = exports.calculateActionFunction = exports.calculateActionName = exports.calculateActionFromMap = void 0;
    const states_1 = requireStates();
    const actions_1 = requireActions();
    const bdd_generated_1 = requireBdd_generated();
    __exportStar(requireStates(), exports);
    __exportStar(requireUtil$1(), exports);
    function calculateActionFromMap(stateSetToActionMap, input) {
      const stateSet = (0, states_1.getStateSet)(input);
      const actionName = stateSetToActionMap.get(stateSet);
      if (!actionName) {
        return {
          action: "runFullQueryAgain",
          stateSet
        };
      } else {
        return {
          action: actionName,
          stateSet
        };
      }
    }
    exports.calculateActionFromMap = calculateActionFromMap;
    function calculateActionName(input) {
      const resolvedActionId = (0, bdd_generated_1.resolveInput)(input);
      return actions_1.orderedActionList[resolvedActionId];
    }
    exports.calculateActionName = calculateActionName;
    function calculateActionFunction(input) {
      const actionName = calculateActionName(input);
      return actions_1.actionFunctions[actionName];
    }
    exports.calculateActionFunction = calculateActionFunction;
    function runAction(action, queryParams, changeEvent, previousResults, keyDocumentMap) {
      const fn = actions_1.actionFunctions[action];
      fn({
        queryParams,
        changeEvent,
        previousResults,
        keyDocumentMap
      });
      return previousResults;
    }
    exports.runAction = runAction;
  })(lib$1);
  return lib$1;
}
var hasRequiredEventReduce;
function requireEventReduce() {
  if (hasRequiredEventReduce)
    return eventReduce;
  hasRequiredEventReduce = 1;
  Object.defineProperty(eventReduce, "__esModule", {
    value: true
  });
  eventReduce.RXQUERY_QUERY_PARAMS_CACHE = void 0;
  eventReduce.calculateNewResults = calculateNewResults;
  eventReduce.getQueryParams = getQueryParams;
  eventReduce.getSortFieldsOfQuery = getSortFieldsOfQuery;
  var _eventReduceJs = requireLib();
  var _rxChangeEvent2 = rxChangeEvent;
  var _utils2 = utils;
  var _rxQueryHelper2 = rxQueryHelper;
  function getSortFieldsOfQuery(primaryKey, query2) {
    if (!query2.sort || query2.sort.length === 0) {
      return [primaryKey];
    } else {
      return query2.sort.map((part) => Object.keys(part)[0]);
    }
  }
  var RXQUERY_QUERY_PARAMS_CACHE = /* @__PURE__ */ new WeakMap();
  eventReduce.RXQUERY_QUERY_PARAMS_CACHE = RXQUERY_QUERY_PARAMS_CACHE;
  function getQueryParams(rxQuery2) {
    return (0, _utils2.getFromMapOrCreate)(RXQUERY_QUERY_PARAMS_CACHE, rxQuery2, () => {
      var collection = rxQuery2.collection;
      var normalizedMangoQuery = (0, _rxQueryHelper2.normalizeMangoQuery)(collection.storageInstance.schema, (0, _utils2.clone)(rxQuery2.mangoQuery));
      var primaryKey = collection.schema.primaryPath;
      var sortComparator = (0, _rxQueryHelper2.getSortComparator)(collection.schema.jsonSchema, normalizedMangoQuery);
      var useSortComparator = (docA, docB) => {
        var sortComparatorData = {
          docA,
          docB,
          rxQuery: rxQuery2
        };
        return sortComparator(sortComparatorData.docA, sortComparatorData.docB);
      };
      var queryMatcher = (0, _rxQueryHelper2.getQueryMatcher)(collection.schema.jsonSchema, normalizedMangoQuery);
      var useQueryMatcher = (doc) => {
        var queryMatcherData = {
          doc,
          rxQuery: rxQuery2
        };
        return queryMatcher(queryMatcherData.doc);
      };
      var ret = {
        primaryKey: rxQuery2.collection.schema.primaryPath,
        skip: normalizedMangoQuery.skip,
        limit: normalizedMangoQuery.limit,
        sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),
        sortComparator: useSortComparator,
        queryMatcher: useQueryMatcher
      };
      return ret;
    });
  }
  function calculateNewResults(rxQuery2, rxChangeEvents) {
    if (!rxQuery2.collection.database.eventReduce) {
      return {
        runFullQueryAgain: true
      };
    }
    var queryParams = getQueryParams(rxQuery2);
    var previousResults = (0, _utils2.ensureNotFalsy)(rxQuery2._result).docsData.slice(0);
    var previousResultsMap = (0, _utils2.ensureNotFalsy)(rxQuery2._result).docsDataMap;
    var changed = false;
    var eventReduceEvents = rxChangeEvents.map((cE) => (0, _rxChangeEvent2.rxChangeEventToEventReduceChangeEvent)(cE)).filter(_utils2.arrayFilterNotEmpty);
    var foundNonOptimizeable = eventReduceEvents.find((eventReduceEvent) => {
      var stateResolveFunctionInput = {
        queryParams,
        changeEvent: eventReduceEvent,
        previousResults,
        keyDocumentMap: previousResultsMap
      };
      var actionName = (0, _eventReduceJs.calculateActionName)(stateResolveFunctionInput);
      if (actionName === "runFullQueryAgain") {
        return true;
      } else if (actionName !== "doNothing") {
        changed = true;
        (0, _eventReduceJs.runAction)(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);
        return false;
      }
    });
    if (foundNonOptimizeable) {
      return {
        runFullQueryAgain: true
      };
    } else {
      return {
        runFullQueryAgain: false,
        changed,
        newResults: previousResults
      };
    }
  }
  return eventReduce;
}
var queryCache = {};
Object.defineProperty(queryCache, "__esModule", {
  value: true
});
queryCache.QueryCache = queryCache.DEFAULT_UNEXECUTED_LIFETIME = queryCache.DEFAULT_TRY_TO_KEEP_MAX = queryCache.COLLECTIONS_WITH_RUNNING_CLEANUP = void 0;
queryCache.countRxQuerySubscribers = countRxQuerySubscribers;
queryCache.createQueryCache = createQueryCache;
queryCache.defaultCacheReplacementPolicyMonad = queryCache.defaultCacheReplacementPolicy = void 0;
queryCache.triggerCacheReplacement = triggerCacheReplacement;
queryCache.uncacheRxQuery = uncacheRxQuery;
var _utils$h = utils;
var QueryCache = /* @__PURE__ */ function() {
  function QueryCache2() {
    this._map = /* @__PURE__ */ new Map();
  }
  var _proto = QueryCache2.prototype;
  _proto.getByQuery = function getByQuery(rxQuery2) {
    var stringRep = rxQuery2.toString();
    return (0, _utils$h.getFromMapOrCreate)(this._map, stringRep, () => rxQuery2);
  };
  return QueryCache2;
}();
queryCache.QueryCache = QueryCache;
function createQueryCache() {
  return new QueryCache();
}
function uncacheRxQuery(queryCache2, rxQuery2) {
  rxQuery2.uncached = true;
  var stringRep = rxQuery2.toString();
  queryCache2._map.delete(stringRep);
}
function countRxQuerySubscribers(rxQuery2) {
  return rxQuery2.refCount$.observers.length;
}
var DEFAULT_TRY_TO_KEEP_MAX = 100;
queryCache.DEFAULT_TRY_TO_KEEP_MAX = DEFAULT_TRY_TO_KEEP_MAX;
var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1e3;
queryCache.DEFAULT_UNEXECUTED_LIFETIME = DEFAULT_UNEXECUTED_LIFETIME;
var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache2) => {
  if (queryCache2._map.size < tryToKeepMax) {
    return;
  }
  var minUnExecutedLifetime = (0, _utils$h.now)() - unExecutedLifetime;
  var maybeUncache = [];
  var queriesInCache = Array.from(queryCache2._map.values());
  for (var rxQuery2 of queriesInCache) {
    if (countRxQuerySubscribers(rxQuery2) > 0) {
      continue;
    }
    if (rxQuery2._lastEnsureEqual === 0 && rxQuery2._creationTime < minUnExecutedLifetime) {
      uncacheRxQuery(queryCache2, rxQuery2);
      continue;
    }
    maybeUncache.push(rxQuery2);
  }
  var mustUncache = maybeUncache.length - tryToKeepMax;
  if (mustUncache <= 0) {
    return;
  }
  var sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);
  var toRemove = sortedByLastUsage.slice(0, mustUncache);
  toRemove.forEach((rxQuery3) => uncacheRxQuery(queryCache2, rxQuery3));
};
queryCache.defaultCacheReplacementPolicyMonad = defaultCacheReplacementPolicyMonad;
var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);
queryCache.defaultCacheReplacementPolicy = defaultCacheReplacementPolicy;
var COLLECTIONS_WITH_RUNNING_CLEANUP = /* @__PURE__ */ new WeakSet();
queryCache.COLLECTIONS_WITH_RUNNING_CLEANUP = COLLECTIONS_WITH_RUNNING_CLEANUP;
function triggerCacheReplacement(rxCollection2) {
  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection2)) {
    return;
  }
  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection2);
  (0, _utils$h.nextTick)().then(() => (0, _utils$h.requestIdlePromise)(200)).then(() => {
    if (!rxCollection2.destroyed) {
      rxCollection2.cacheReplacementPolicy(rxCollection2, rxCollection2._queryCache);
    }
    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection2);
  });
}
var _interopRequireDefault$3 = interopRequireDefaultExports$1;
Object.defineProperty(rxQuery, "__esModule", {
  value: true
});
rxQuery.RxQueryBase = void 0;
rxQuery._getDefaultQuery = _getDefaultQuery;
rxQuery.createRxQuery = createRxQuery;
rxQuery.isFindOneByIdQuery = isFindOneByIdQuery;
rxQuery.isRxQuery = isRxQuery;
rxQuery.queryCollection = queryCollection;
rxQuery.tunnelQueryCache = tunnelQueryCache;
var _createClass2$2 = _interopRequireDefault$3(requireCreateClass());
var _rxjs$4 = cjs;
var _operators$3 = operators;
var _utils$g = utils;
var _rxError$c = rxError;
var _hooks$5 = hooks;
var _eventReduce = requireEventReduce();
var _queryCache$1 = queryCache;
var _rxQueryHelper = rxQueryHelper;
var _queryCount = 0;
var newQueryID = function() {
  return ++_queryCount;
};
var RxQueryBase = /* @__PURE__ */ function() {
  function RxQueryBase2(op, mangoQuery, collection, other = {}) {
    this.id = newQueryID();
    this._execOverDatabaseCount = 0;
    this._creationTime = (0, _utils$g.now)();
    this._lastEnsureEqual = 0;
    this.uncached = false;
    this.refCount$ = new _rxjs$4.BehaviorSubject(null);
    this._result = null;
    this._latestChangeEvent = -1;
    this._lastExecStart = 0;
    this._lastExecEnd = 0;
    this._ensureEqualQueue = _utils$g.PROMISE_RESOLVE_FALSE;
    this.op = op;
    this.mangoQuery = mangoQuery;
    this.collection = collection;
    this.other = other;
    if (!mangoQuery) {
      this.mangoQuery = _getDefaultQuery();
    }
    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);
  }
  var _proto = RxQueryBase2.prototype;
  _proto._setResultData = function _setResultData(newResultData) {
    if (typeof newResultData === "number") {
      this._result = {
        docsData: [],
        docsMap: /* @__PURE__ */ new Map(),
        docsDataMap: /* @__PURE__ */ new Map(),
        count: newResultData,
        docs: [],
        time: (0, _utils$g.now)()
      };
      return;
    } else if (newResultData instanceof Map) {
      newResultData = Array.from(newResultData.values());
    }
    var docsDataMap = /* @__PURE__ */ new Map();
    var docsMap = /* @__PURE__ */ new Map();
    var docs = newResultData.map((docData) => this.collection._docCache.getCachedRxDocument(docData));
    var docsData = docs.map((doc) => {
      docsDataMap.set(doc.primary, doc._data);
      docsMap.set(doc.primary, doc);
      return doc._data;
    });
    this._result = {
      docsData,
      docsMap,
      docsDataMap,
      count: docsData.length,
      docs,
      time: (0, _utils$g.now)()
    };
  };
  _proto._execOverDatabase = async function _execOverDatabase() {
    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;
    this._lastExecStart = (0, _utils$g.now)();
    if (this.op === "count") {
      var preparedQuery = this.getPreparedQuery();
      var result = await this.collection.storageInstance.count(preparedQuery);
      if (result.mode === "slow" && !this.collection.database.allowSlowCount) {
        throw (0, _rxError$c.newRxError)("QU14", {
          collection: this.collection,
          queryObj: this.mangoQuery
        });
      } else {
        return result.count;
      }
    }
    if (this.op === "findByIds") {
      var ids = (0, _utils$g.ensureNotFalsy)(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;
      var ret = /* @__PURE__ */ new Map();
      var mustBeQueried = [];
      ids.forEach((id) => {
        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);
        if (docData) {
          if (!docData._deleted) {
            var doc = this.collection._docCache.getCachedRxDocument(docData);
            ret.set(id, doc);
          }
        } else {
          mustBeQueried.push(id);
        }
      });
      if (mustBeQueried.length > 0) {
        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);
        Object.values(docs).forEach((docData) => {
          var doc = this.collection._docCache.getCachedRxDocument(docData);
          ret.set(doc.primary, doc);
        });
      }
      return ret;
    }
    var docsPromise = queryCollection(this);
    return docsPromise.then((docs2) => {
      this._lastExecEnd = (0, _utils$g.now)();
      return docs2;
    });
  };
  _proto.exec = function exec(throwIfMissing) {
    if (throwIfMissing && this.op !== "findOne") {
      throw (0, _rxError$c.newRxError)("QU9", {
        collection: this.collection.name,
        query: this.mangoQuery,
        op: this.op
      });
    }
    return _ensureEqual(this).then(() => (0, _rxjs$4.firstValueFrom)(this.$)).then((result) => {
      if (!result && throwIfMissing) {
        throw (0, _rxError$c.newRxError)("QU10", {
          collection: this.collection.name,
          query: this.mangoQuery,
          op: this.op
        });
      } else {
        return result;
      }
    });
  };
  _proto.toString = function toString2() {
    var stringObj = (0, _utils$g.sortObject)({
      op: this.op,
      query: this.mangoQuery,
      other: this.other
    }, true);
    var value = JSON.stringify(stringObj, _utils$g.stringifyFilter);
    this.toString = () => value;
    return value;
  };
  _proto.getPreparedQuery = function getPreparedQuery() {
    var hookInput = {
      rxQuery: this,
      // can be mutated by the hooks so we have to deep clone first.
      mangoQuery: (0, _rxQueryHelper.normalizeMangoQuery)(this.collection.schema.jsonSchema, this.mangoQuery)
    };
    (0, _hooks$5.runPluginHooks)("prePrepareQuery", hookInput);
    var value = this.collection.database.storage.statics.prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);
    this.getPreparedQuery = () => value;
    return value;
  };
  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {
    if (docData._deleted) {
      return false;
    }
    return this.queryMatcher(docData);
  };
  _proto.remove = function remove() {
    return this.exec().then((docs) => {
      if (Array.isArray(docs)) {
        return Promise.all(docs.map((doc) => doc.remove()));
      } else {
        return docs.remove();
      }
    });
  };
  _proto.update = function update2(_updateObj) {
    throw (0, _utils$g.pluginMissing)("update");
  };
  _proto.where = function where2(_queryObj) {
    throw (0, _utils$g.pluginMissing)("query-builder");
  };
  _proto.sort = function sort2(_params) {
    throw (0, _utils$g.pluginMissing)("query-builder");
  };
  _proto.skip = function skip2(_amount) {
    throw (0, _utils$g.pluginMissing)("query-builder");
  };
  _proto.limit = function limit2(_amount) {
    throw (0, _utils$g.pluginMissing)("query-builder");
  };
  (0, _createClass2$2.default)(RxQueryBase2, [{
    key: "$",
    get: function() {
      if (!this._$) {
        var results$ = this.collection.$.pipe(
          /**
           * Performance shortcut.
           * Changes to local documents are not relevant for the query.
           */
          (0, _operators$3.filter)((changeEvent) => !changeEvent.isLocal),
          /**
           * Start once to ensure the querying also starts
           * when there where no changes.
           */
          (0, _operators$3.startWith)(null),
          // ensure query results are up to date.
          (0, _operators$3.mergeMap)(() => _ensureEqual(this)),
          // use the current result set, written by _ensureEqual().
          (0, _operators$3.map)(() => this._result),
          // do not run stuff above for each new subscriber, only once.
          (0, _operators$3.shareReplay)(_utils$g.RXJS_SHARE_REPLAY_DEFAULTS),
          // do not proceed if result set has not changed.
          (0, _operators$3.distinctUntilChanged)((prev, curr) => {
            if (prev && prev.time === (0, _utils$g.ensureNotFalsy)(curr).time) {
              return true;
            } else {
              return false;
            }
          }),
          (0, _operators$3.filter)((result) => !!result),
          /**
           * Map the result set to a single RxDocument or an array,
           * depending on query type
           */
          (0, _operators$3.map)((result) => {
            var useResult = (0, _utils$g.ensureNotFalsy)(result);
            if (this.op === "count") {
              return useResult.count;
            } else if (this.op === "findOne") {
              return useResult.docs.length === 0 ? null : useResult.docs[0];
            } else if (this.op === "findByIds") {
              return useResult.docsMap;
            } else {
              return useResult.docs.slice(0);
            }
          })
        );
        this._$ = (0, _rxjs$4.merge)(
          results$,
          /**
           * Also add the refCount$ to the query observable
           * to allow us to count the amount of subscribers.
           */
          this.refCount$.pipe((0, _operators$3.filter)(() => false))
        );
      }
      return this._$;
    }
    // stores the changeEvent-number of the last handled change-event
    // time stamps on when the last full exec over the database has run
    // used to properly handle events that happen while the find-query is running
    /**
     * ensures that the exec-runs
     * are not run in parallel
     */
  }, {
    key: "queryMatcher",
    get: function() {
      var schema = this.collection.schema.jsonSchema;
      var normalizedQuery = (0, _rxQueryHelper.normalizeMangoQuery)(this.collection.schema.jsonSchema, this.mangoQuery);
      return (0, _utils$g.overwriteGetterForCaching)(this, "queryMatcher", (0, _rxQueryHelper.getQueryMatcher)(schema, normalizedQuery));
    }
  }, {
    key: "asRxQuery",
    get: function() {
      return this;
    }
  }]);
  return RxQueryBase2;
}();
rxQuery.RxQueryBase = RxQueryBase;
function _getDefaultQuery() {
  return {
    selector: {}
  };
}
function tunnelQueryCache(rxQuery2) {
  return rxQuery2.collection._queryCache.getByQuery(rxQuery2);
}
function createRxQuery(op, queryObj, collection, other) {
  (0, _hooks$5.runPluginHooks)("preCreateRxQuery", {
    op,
    queryObj,
    collection,
    other
  });
  var ret = new RxQueryBase(op, queryObj, collection, other);
  ret = tunnelQueryCache(ret);
  (0, _queryCache$1.triggerCacheReplacement)(collection);
  return ret;
}
function _isResultsInSync(rxQuery2) {
  var currentLatestEventNumber = rxQuery2.asRxQuery.collection._changeEventBuffer.counter;
  if (rxQuery2._latestChangeEvent >= currentLatestEventNumber) {
    return true;
  } else {
    return false;
  }
}
function _ensureEqual(rxQuery2) {
  if (rxQuery2.collection.database.destroyed || _isResultsInSync(rxQuery2)) {
    return _utils$g.PROMISE_RESOLVE_FALSE;
  }
  rxQuery2._ensureEqualQueue = rxQuery2._ensureEqualQueue.then(() => __ensureEqual(rxQuery2));
  return rxQuery2._ensureEqualQueue;
}
function __ensureEqual(rxQuery2) {
  rxQuery2._lastEnsureEqual = (0, _utils$g.now)();
  if (
    // db is closed
    rxQuery2.collection.database.destroyed || // nothing happened since last run
    _isResultsInSync(rxQuery2)
  ) {
    return _utils$g.PROMISE_RESOLVE_FALSE;
  }
  var ret = false;
  var mustReExec = false;
  if (rxQuery2._latestChangeEvent === -1) {
    mustReExec = true;
  }
  if (!mustReExec) {
    var missedChangeEvents = rxQuery2.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery2._latestChangeEvent + 1);
    if (missedChangeEvents === null) {
      mustReExec = true;
    } else {
      rxQuery2._latestChangeEvent = rxQuery2.asRxQuery.collection._changeEventBuffer.counter;
      var runChangeEvents = rxQuery2.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);
      if (rxQuery2.op === "count") {
        var previousCount = (0, _utils$g.ensureNotFalsy)(rxQuery2._result).count;
        var newCount = previousCount;
        runChangeEvents.forEach((cE) => {
          var didMatchBefore = cE.previousDocumentData && rxQuery2.doesDocumentDataMatch(cE.previousDocumentData);
          var doesMatchNow = rxQuery2.doesDocumentDataMatch(cE.documentData);
          if (!didMatchBefore && doesMatchNow) {
            newCount++;
          }
          if (didMatchBefore && !doesMatchNow) {
            newCount--;
          }
        });
        if (newCount !== previousCount) {
          ret = true;
          rxQuery2._setResultData(newCount);
        }
      } else {
        var eventReduceResult = (0, _eventReduce.calculateNewResults)(rxQuery2, runChangeEvents);
        if (eventReduceResult.runFullQueryAgain) {
          mustReExec = true;
        } else if (eventReduceResult.changed) {
          ret = true;
          rxQuery2._setResultData(eventReduceResult.newResults);
        }
      }
    }
  }
  if (mustReExec) {
    var latestAfter = rxQuery2.collection._changeEventBuffer.counter;
    return rxQuery2._execOverDatabase().then((newResultData) => {
      rxQuery2._latestChangeEvent = latestAfter;
      if (typeof newResultData === "number") {
        if (!rxQuery2._result || newResultData !== rxQuery2._result.count) {
          ret = true;
          rxQuery2._setResultData(newResultData);
        }
        return ret;
      }
      if (!rxQuery2._result || !(0, _utils$g.areRxDocumentArraysEqual)(rxQuery2.collection.schema.primaryPath, newResultData, rxQuery2._result.docsData)) {
        ret = true;
        rxQuery2._setResultData(newResultData);
      }
      return ret;
    });
  }
  return Promise.resolve(ret);
}
async function queryCollection(rxQuery2) {
  var docs = [];
  var collection = rxQuery2.collection;
  if (rxQuery2.isFindOneByIdQuery) {
    if (Array.isArray(rxQuery2.isFindOneByIdQuery)) {
      var docIds = rxQuery2.isFindOneByIdQuery;
      docIds = docIds.filter((docId2) => {
        var docData2 = rxQuery2.collection._docCache.getLatestDocumentDataIfExists(docId2);
        if (docData2) {
          if (!docData2._deleted) {
            docs.push(docData2);
          }
          return false;
        } else {
          return true;
        }
      });
      if (docIds.length > 0) {
        var docsMap = await collection.storageInstance.findDocumentsById(docIds, false);
        Object.values(docsMap).forEach((docData2) => {
          docs.push(docData2);
        });
      }
    } else {
      var docId = rxQuery2.isFindOneByIdQuery;
      var docData = rxQuery2.collection._docCache.getLatestDocumentDataIfExists(docId);
      if (!docData) {
        var _docsMap = await collection.storageInstance.findDocumentsById([docId], false);
        if (_docsMap.hasOwnProperty(docId)) {
          docData = _docsMap[docId];
        }
      }
      if (docData && !docData._deleted) {
        docs.push(docData);
      }
    }
  } else {
    var preparedQuery = rxQuery2.getPreparedQuery();
    var queryResult = await collection.storageInstance.query(preparedQuery);
    docs = queryResult.documents;
  }
  return docs;
}
function isFindOneByIdQuery(primaryPath, query2) {
  if (!query2.skip && query2.selector && Object.keys(query2.selector).length === 1 && query2.selector[primaryPath]) {
    var value = query2.selector[primaryPath];
    if (typeof value === "string") {
      return value;
    } else if (Object.keys(value).length === 1 && typeof value.$eq === "string") {
      return value.$eq;
    }
    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) && // must only contain strings
    !value.$eq.find((r) => typeof r !== "string")) {
      return value.$eq;
    }
  }
  return false;
}
function isRxQuery(obj) {
  return obj instanceof RxQueryBase;
}
var rxCollection = {};
var rxCollectionHelper = {};
var rxDatabaseInternalStore = {};
Object.defineProperty(rxDatabaseInternalStore, "__esModule", {
  value: true
});
rxDatabaseInternalStore.STORAGE_TOKEN_DOCUMENT_KEY = rxDatabaseInternalStore.STORAGE_TOKEN_DOCUMENT_ID = rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA_TITLE = rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA = rxDatabaseInternalStore.INTERNAL_CONTEXT_STORAGE_TOKEN = rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION = void 0;
rxDatabaseInternalStore._collectionNamePrimary = _collectionNamePrimary;
rxDatabaseInternalStore.addConnectedStorageToCollection = addConnectedStorageToCollection;
rxDatabaseInternalStore.ensureStorageTokenDocumentExists = ensureStorageTokenDocumentExists;
rxDatabaseInternalStore.getAllCollectionDocuments = getAllCollectionDocuments;
rxDatabaseInternalStore.getPrimaryKeyOfInternalDocument = getPrimaryKeyOfInternalDocument;
var _rxError$b = rxError;
var _rxSchemaHelper$6 = rxSchemaHelper;
var _rxStorageHelper$7 = rxStorageHelper;
var _utils$f = utils;
var INTERNAL_CONTEXT_COLLECTION = "collection";
rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION = INTERNAL_CONTEXT_COLLECTION;
var INTERNAL_CONTEXT_STORAGE_TOKEN = "storage-token";
rxDatabaseInternalStore.INTERNAL_CONTEXT_STORAGE_TOKEN = INTERNAL_CONTEXT_STORAGE_TOKEN;
var INTERNAL_STORE_SCHEMA_TITLE = "RxInternalDocument";
rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA_TITLE = INTERNAL_STORE_SCHEMA_TITLE;
var INTERNAL_STORE_SCHEMA = (0, _rxSchemaHelper$6.fillWithDefaultSettings)({
  version: 0,
  title: INTERNAL_STORE_SCHEMA_TITLE,
  primaryKey: {
    key: "id",
    fields: ["context", "key"],
    separator: "|"
  },
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 200
    },
    key: {
      type: "string"
    },
    context: {
      type: "string",
      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, "OTHER"]
    },
    data: {
      type: "object",
      additionalProperties: true
    }
  },
  indexes: [],
  required: ["key", "context", "data"],
  additionalProperties: false,
  /**
   * If the sharding plugin is used,
   * it must not shard on the internal RxStorageInstance
   * because that one anyway has only a small amount of documents
   * and also its creation is in the hot path of the initial page load,
   * so we should spend less time creating multiple RxStorageInstances.
   */
  sharding: {
    shards: 1,
    mode: "collection"
  }
});
rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA = INTERNAL_STORE_SCHEMA;
function getPrimaryKeyOfInternalDocument(key, context2) {
  return (0, _rxSchemaHelper$6.getComposedPrimaryKeyOfDocumentData)(INTERNAL_STORE_SCHEMA, {
    key,
    context: context2
  });
}
async function getAllCollectionDocuments(storageStatics, storageInstance) {
  var getAllQueryPrepared = storageStatics.prepareQuery(storageInstance.schema, {
    selector: {
      context: INTERNAL_CONTEXT_COLLECTION
    },
    sort: [{
      id: "asc"
    }],
    skip: 0
  });
  var queryResult = await storageInstance.query(getAllQueryPrepared);
  var allDocs = queryResult.documents;
  return allDocs;
}
var STORAGE_TOKEN_DOCUMENT_KEY = "storageToken";
rxDatabaseInternalStore.STORAGE_TOKEN_DOCUMENT_KEY = STORAGE_TOKEN_DOCUMENT_KEY;
var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);
rxDatabaseInternalStore.STORAGE_TOKEN_DOCUMENT_ID = STORAGE_TOKEN_DOCUMENT_ID;
async function ensureStorageTokenDocumentExists(rxDatabase2) {
  var storageToken = (0, _utils$f.randomCouchString)(10);
  var passwordHash = rxDatabase2.password ? rxDatabase2.hashFunction(JSON.stringify(rxDatabase2.password)) : void 0;
  var docData = {
    id: STORAGE_TOKEN_DOCUMENT_ID,
    context: INTERNAL_CONTEXT_STORAGE_TOKEN,
    key: STORAGE_TOKEN_DOCUMENT_KEY,
    data: {
      token: storageToken,
      /**
       * We add the instance token here
       * to be able to detect if a given RxDatabase instance
       * is the first instance that was ever created
       * or if databases have existed earlier on that storage
       * with the same database name.
       */
      instanceToken: rxDatabase2.token,
      passwordHash
    },
    _deleted: false,
    _meta: (0, _utils$f.getDefaultRxDocumentMeta)(),
    _rev: (0, _utils$f.getDefaultRevision)(),
    _attachments: {}
  };
  var writeResult = await rxDatabase2.internalStore.bulkWrite([{
    document: docData
  }], "internal-add-storage-token");
  if (writeResult.success[STORAGE_TOKEN_DOCUMENT_ID]) {
    return writeResult.success[STORAGE_TOKEN_DOCUMENT_ID];
  }
  var error = (0, _utils$f.ensureNotFalsy)(writeResult.error[STORAGE_TOKEN_DOCUMENT_ID]);
  if (error.isError && error.status === 409) {
    var conflictError = error;
    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {
      throw (0, _rxError$b.newRxError)("DB1", {
        passwordHash,
        existingPasswordHash: conflictError.documentInDb.data.passwordHash
      });
    }
    var storageTokenDocInDb = conflictError.documentInDb;
    return (0, _utils$f.ensureNotFalsy)(storageTokenDocInDb);
  }
  throw error;
}
async function addConnectedStorageToCollection(collection, storageCollectionName, schema) {
  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);
  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);
  while (true) {
    var collectionDoc = await (0, _rxStorageHelper$7.getSingleDocument)(collection.database.internalStore, collectionDocId);
    var saveData = (0, _utils$f.clone)((0, _utils$f.ensureNotFalsy)(collectionDoc));
    if (!saveData.data.connectedStorages) {
      saveData.data.connectedStorages = [];
    }
    var alreadyThere = saveData.data.connectedStorages.find((row) => row.collectionName === storageCollectionName && row.schema.version === schema.version);
    if (alreadyThere) {
      return;
    }
    saveData.data.connectedStorages.push({
      collectionName: storageCollectionName,
      schema
    });
    try {
      await (0, _rxStorageHelper$7.writeSingle)(collection.database.internalStore, {
        previous: (0, _utils$f.ensureNotFalsy)(collectionDoc),
        document: saveData
      }, "add-connected-storage-to-collection");
    } catch (err) {
      if (!(0, _rxError$b.isBulkWriteConflictError)(err)) {
        throw err;
      }
    }
  }
}
function _collectionNamePrimary(name, schema) {
  return name + "-" + schema.version;
}
Object.defineProperty(rxCollectionHelper, "__esModule", {
  value: true
});
rxCollectionHelper.createRxCollectionStorageInstance = createRxCollectionStorageInstance;
rxCollectionHelper.fillObjectDataBeforeInsert = fillObjectDataBeforeInsert;
rxCollectionHelper.removeCollectionStorages = removeCollectionStorages;
var _utils$e = utils;
var _rxSchemaHelper$5 = rxSchemaHelper;
var _hooks$4 = hooks;
var _rxDatabaseInternalStore$1 = rxDatabaseInternalStore;
var _rxStorageHelper$6 = rxStorageHelper;
var _overwritable$4 = overwritable$1;
function fillObjectDataBeforeInsert(schema, data) {
  data = (0, _utils$e.flatClone)(data);
  data = (0, _rxSchemaHelper$5.fillObjectWithDefaults)(schema, data);
  data = (0, _rxSchemaHelper$5.fillPrimaryKey)(schema.primaryPath, schema.jsonSchema, data);
  data._meta = (0, _utils$e.getDefaultRxDocumentMeta)();
  if (!data.hasOwnProperty("_deleted")) {
    data._deleted = false;
  }
  if (!data.hasOwnProperty("_attachments")) {
    data._attachments = {};
  }
  if (!data.hasOwnProperty("_rev")) {
    data._rev = (0, _utils$e.getDefaultRevision)();
  }
  return data;
}
async function createRxCollectionStorageInstance(rxDatabase2, storageInstanceCreationParams) {
  storageInstanceCreationParams.multiInstance = rxDatabase2.multiInstance;
  var storageInstance = await rxDatabase2.storage.createStorageInstance(storageInstanceCreationParams);
  return storageInstance;
}
async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, hashFunction) {
  var allCollectionMetaDocs = await (0, _rxDatabaseInternalStore$1.getAllCollectionDocuments)(storage.statics, databaseInternalStorage);
  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter((metaDoc) => metaDoc.data.name === collectionName);
  var removeStorages = [];
  relevantCollectionMetaDocs.forEach((metaDoc) => {
    removeStorages.push({
      collectionName: metaDoc.data.name,
      schema: metaDoc.data.schema,
      isCollection: true
    });
    metaDoc.data.connectedStorages.forEach((row) => removeStorages.push({
      collectionName: row.collectionName,
      isCollection: false,
      schema: row.schema
    }));
  });
  var alreadyAdded = /* @__PURE__ */ new Set();
  removeStorages = removeStorages.filter((row) => {
    var key = row.collectionName + "||" + row.schema.version;
    if (alreadyAdded.has(key)) {
      return false;
    } else {
      alreadyAdded.add(key);
      return true;
    }
  });
  await Promise.all(removeStorages.map(async (row) => {
    var storageInstance = await storage.createStorageInstance({
      collectionName: row.collectionName,
      databaseInstanceToken,
      databaseName,
      multiInstance: false,
      options: {},
      schema: row.schema,
      devMode: _overwritable$4.overwritable.isDevMode()
    });
    await storageInstance.remove();
    if (row.isCollection) {
      await (0, _hooks$4.runAsyncPluginHooks)("postRemoveRxCollection", {
        storage,
        databaseName,
        collectionName
      });
    }
  }));
  if (hashFunction) {
    var writeRows = relevantCollectionMetaDocs.map((doc) => {
      var writeDoc = (0, _rxStorageHelper$6.flatCloneDocWithMeta)(doc);
      writeDoc._deleted = true;
      writeDoc._meta.lwt = (0, _utils$e.now)();
      writeDoc._rev = (0, _utils$e.createRevision)(databaseInstanceToken, doc);
      return {
        previous: doc,
        document: writeDoc
      };
    });
    await databaseInternalStorage.bulkWrite(writeRows, "rx-database-remove-collection-all");
  }
}
var docCache = {};
var hasRequiredDocCache;
function requireDocCache() {
  if (hasRequiredDocCache)
    return docCache;
  hasRequiredDocCache = 1;
  Object.defineProperty(docCache, "__esModule", {
    value: true
  });
  docCache.DocumentCache = void 0;
  var _utils2 = utils;
  var _overwritable2 = overwritable$1;
  var _rxChangeEvent2 = rxChangeEvent;
  var DocumentCache = /* @__PURE__ */ function() {
    function DocumentCache2(primaryPath, changes$, documentCreator) {
      this.cacheItemByDocId = /* @__PURE__ */ new Map();
      this.registry = typeof FinalizationRegistry === "function" ? new FinalizationRegistry((docMeta) => {
        var docId = docMeta.docId;
        var cacheItem = this.cacheItemByDocId.get(docId);
        if (cacheItem) {
          cacheItem.documentByRevisionHeight.delete(docMeta.revisionHeight);
          if (cacheItem.documentByRevisionHeight.size === 0) {
            this.cacheItemByDocId.delete(docId);
          }
        }
      }) : void 0;
      this.primaryPath = primaryPath;
      this.changes$ = changes$;
      this.documentCreator = documentCreator;
      changes$.subscribe((changeEvent) => {
        var docId = changeEvent.documentId;
        var cacheItem = this.cacheItemByDocId.get(docId);
        if (cacheItem) {
          var documentData = (0, _rxChangeEvent2.getDocumentDataOfRxChangeEvent)(changeEvent);
          cacheItem.latestDoc = documentData;
        }
      });
    }
    var _proto = DocumentCache2.prototype;
    _proto.getCachedRxDocument = function getCachedRxDocument(docData) {
      var docId = docData[this.primaryPath];
      var revisionHeight = (0, _utils2.getHeightOfRevision)(docData._rev);
      var cacheItem = (0, _utils2.getFromMapOrCreate)(this.cacheItemByDocId, docId, () => getNewCacheItem(docData));
      var cachedRxDocumentWeakRef = cacheItem.documentByRevisionHeight.get(revisionHeight);
      var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : void 0;
      if (!cachedRxDocument) {
        docData = _overwritable2.overwritable.deepFreezeWhenDevMode(docData);
        cachedRxDocument = this.documentCreator(docData);
        cacheItem.documentByRevisionHeight.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));
        if (this.registry) {
          this.registry.register(cachedRxDocument, {
            docId,
            revisionHeight
          });
        }
      }
      return cachedRxDocument;
    };
    _proto.getLatestDocumentData = function getLatestDocumentData(docId) {
      var cacheItem = (0, _utils2.getFromMapOrThrow)(this.cacheItemByDocId, docId);
      return cacheItem.latestDoc;
    };
    _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {
      var cacheItem = this.cacheItemByDocId.get(docId);
      if (cacheItem) {
        return cacheItem.latestDoc;
      }
    };
    return DocumentCache2;
  }();
  docCache.DocumentCache = DocumentCache;
  function getNewCacheItem(docData) {
    return {
      documentByRevisionHeight: /* @__PURE__ */ new Map(),
      latestDoc: docData
    };
  }
  var HAS_WEAK_REF = typeof WeakRef === "function";
  function createWeakRefWithFallback(obj) {
    if (HAS_WEAK_REF) {
      return new WeakRef(obj);
    } else {
      return {
        deref() {
          return obj;
        }
      };
    }
  }
  return docCache;
}
var changeEventBuffer = {};
var hasRequiredChangeEventBuffer;
function requireChangeEventBuffer() {
  if (hasRequiredChangeEventBuffer)
    return changeEventBuffer;
  hasRequiredChangeEventBuffer = 1;
  Object.defineProperty(changeEventBuffer, "__esModule", {
    value: true
  });
  changeEventBuffer.ChangeEventBuffer = void 0;
  changeEventBuffer.createChangeEventBuffer = createChangeEventBuffer;
  var _operators2 = operators;
  var ChangeEventBuffer = /* @__PURE__ */ function() {
    function ChangeEventBuffer2(collection) {
      this.subs = [];
      this.limit = 100;
      this.counter = 0;
      this.eventCounterMap = /* @__PURE__ */ new WeakMap();
      this.buffer = [];
      this.collection = collection;
      this.subs.push(this.collection.$.pipe((0, _operators2.filter)((cE) => !cE.isLocal)).subscribe((cE) => this._handleChangeEvent(cE)));
    }
    var _proto = ChangeEventBuffer2.prototype;
    _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {
      this.counter++;
      this.buffer.push(changeEvent);
      this.eventCounterMap.set(changeEvent, this.counter);
      while (this.buffer.length > this.limit) {
        this.buffer.shift();
      }
    };
    _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {
      var oldestEvent = this.buffer[0];
      var oldestCounter = this.eventCounterMap.get(oldestEvent);
      if (pointer < oldestCounter)
        return null;
      var rest = pointer - oldestCounter;
      return rest;
    };
    _proto.getFrom = function getFrom(pointer) {
      var ret = [];
      var currentIndex = this.getArrayIndexByPointer(pointer);
      if (currentIndex === null)
        return null;
      while (true) {
        var nextEvent = this.buffer[currentIndex];
        currentIndex++;
        if (!nextEvent) {
          return ret;
        } else {
          ret.push(nextEvent);
        }
      }
    };
    _proto.runFrom = function runFrom(pointer, fn) {
      var ret = this.getFrom(pointer);
      if (ret === null) {
        throw new Error("out of bounds");
      } else {
        ret.forEach((cE) => fn(cE));
      }
    };
    _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {
      return changeEvents.slice(0);
    };
    _proto.destroy = function destroy() {
      this.subs.forEach((sub) => sub.unsubscribe());
    };
    return ChangeEventBuffer2;
  }();
  changeEventBuffer.ChangeEventBuffer = ChangeEventBuffer;
  function createChangeEventBuffer(collection) {
    return new ChangeEventBuffer(collection);
  }
  return changeEventBuffer;
}
var rxDocumentPrototypeMerge = {};
Object.defineProperty(rxDocumentPrototypeMerge, "__esModule", {
  value: true
});
rxDocumentPrototypeMerge.createNewRxDocument = createNewRxDocument;
rxDocumentPrototypeMerge.getDocumentOrmPrototype = getDocumentOrmPrototype;
rxDocumentPrototypeMerge.getDocumentPrototype = getDocumentPrototype;
rxDocumentPrototypeMerge.getRxDocumentConstructor = getRxDocumentConstructor;
var _rxDocument$3 = rxDocument;
var _hooks$3 = hooks;
var _overwritable$3 = overwritable$1;
var _utils$d = utils;
var constructorForCollection = /* @__PURE__ */ new WeakMap();
function getDocumentPrototype(rxCollection2) {
  var schemaProto = rxCollection2.schema.getDocumentPrototype();
  var ormProto = getDocumentOrmPrototype(rxCollection2);
  var baseProto = _rxDocument$3.basePrototype;
  var proto = {};
  [schemaProto, ormProto, baseProto].forEach((obj) => {
    var props2 = Object.getOwnPropertyNames(obj);
    props2.forEach((key) => {
      var desc = Object.getOwnPropertyDescriptor(obj, key);
      var enumerable = true;
      if (key.startsWith("_") || key.endsWith("_") || key.startsWith("$") || key.endsWith("$"))
        enumerable = false;
      if (typeof desc.value === "function") {
        Object.defineProperty(proto, key, {
          get() {
            return desc.value.bind(this);
          },
          enumerable,
          configurable: false
        });
      } else {
        desc.enumerable = enumerable;
        desc.configurable = false;
        if (desc.writable)
          desc.writable = false;
        Object.defineProperty(proto, key, desc);
      }
    });
  });
  return proto;
}
function getRxDocumentConstructor(rxCollection2) {
  return (0, _utils$d.getFromMapOrCreate)(constructorForCollection, rxCollection2, () => (0, _rxDocument$3.createRxDocumentConstructor)(getDocumentPrototype(rxCollection2)));
}
function createNewRxDocument(rxCollection2, docData) {
  var doc = (0, _rxDocument$3.createWithConstructor)(getRxDocumentConstructor(rxCollection2), rxCollection2, _overwritable$3.overwritable.deepFreezeWhenDevMode(docData));
  rxCollection2._runHooksSync("post", "create", docData, doc);
  (0, _hooks$3.runPluginHooks)("postCreateRxDocument", doc);
  return doc;
}
function getDocumentOrmPrototype(rxCollection2) {
  var proto = {};
  Object.entries(rxCollection2.methods).forEach(([k, v]) => {
    proto[k] = v;
  });
  return proto;
}
var replicationProtocol = {};
var checkpoint = {};
Object.defineProperty(checkpoint, "__esModule", {
  value: true
});
checkpoint.getCheckpointKey = getCheckpointKey;
checkpoint.getLastCheckpointDoc = getLastCheckpointDoc;
checkpoint.setCheckpoint = setCheckpoint;
var _rxSchemaHelper$4 = rxSchemaHelper;
var _rxStorageHelper$5 = rxStorageHelper;
var _utils$c = utils;
async function getLastCheckpointDoc(state, direction) {
  var checkpointDocId = (0, _rxSchemaHelper$4.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, {
    isCheckpoint: "1",
    itemId: direction
  });
  var checkpointResult = await state.input.metaInstance.findDocumentsById([checkpointDocId], false);
  var checkpointDoc = checkpointResult[checkpointDocId];
  state.lastCheckpointDoc[direction] = checkpointDoc;
  if (checkpointDoc) {
    return checkpointDoc.data;
  } else {
    return void 0;
  }
}
async function setCheckpoint(state, direction, checkpoint2) {
  var previousCheckpointDoc = state.lastCheckpointDoc[direction];
  if (checkpoint2 && /**
   * If the replication is already canceled,
   * we do not write a checkpoint
   * because that could mean we write a checkpoint
   * for data that has been fetched from the master
   * but not been written to the child.
   */
  !state.events.canceled.getValue() && /**
   * Only write checkpoint if it is different from before
   * to have less writes to the storage.
   */
  (!previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.data) !== JSON.stringify(checkpoint2))) {
    var newDoc = {
      id: "",
      isCheckpoint: "1",
      itemId: direction,
      _deleted: false,
      _attachments: {},
      data: checkpoint2,
      _meta: (0, _utils$c.getDefaultRxDocumentMeta)(),
      _rev: (0, _utils$c.getDefaultRevision)()
    };
    newDoc.id = (0, _rxSchemaHelper$4.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, newDoc);
    while (!state.events.canceled.getValue()) {
      if (previousCheckpointDoc) {
        newDoc.data = (0, _rxStorageHelper$5.stackCheckpoints)([previousCheckpointDoc.data, newDoc.data]);
      }
      newDoc._meta.lwt = (0, _utils$c.now)();
      newDoc._rev = (0, _utils$c.createRevision)(state.input.identifier, previousCheckpointDoc);
      var result = await state.input.metaInstance.bulkWrite([{
        previous: previousCheckpointDoc,
        document: newDoc
      }], "replication-set-checkpoint");
      if (result.success[newDoc.id]) {
        state.lastCheckpointDoc[direction] = (0, _utils$c.getFromObjectOrThrow)(result.success, newDoc.id);
        return;
      } else {
        var error = (0, _utils$c.getFromObjectOrThrow)(result.error, newDoc.id);
        if (error.status !== 409) {
          throw error;
        } else {
          previousCheckpointDoc = (0, _utils$c.ensureNotFalsy)(error.documentInDb);
          newDoc._rev = (0, _utils$c.createRevision)(state.input.identifier, previousCheckpointDoc);
        }
      }
    }
  }
}
function getCheckpointKey(input) {
  var hash2 = input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join("||"));
  return "rx-storage-replication-" + hash2;
}
var downstream = {};
var helper$2 = {};
Object.defineProperty(helper$2, "__esModule", {
  value: true
});
helper$2.docStateToWriteDoc = docStateToWriteDoc;
helper$2.writeDocToDocState = writeDocToDocState;
var _utils$b = utils;
function docStateToWriteDoc(databaseInstanceToken, docState, previous) {
  var docData = Object.assign({}, docState, {
    _attachments: {},
    _meta: {
      lwt: (0, _utils$b.now)()
    },
    _rev: (0, _utils$b.getDefaultRevision)()
  });
  docData._rev = (0, _utils$b.createRevision)(databaseInstanceToken, previous);
  return docData;
}
function writeDocToDocState(writeDoc) {
  var ret = (0, _utils$b.flatClone)(writeDoc);
  delete ret._attachments;
  delete ret._meta;
  delete ret._rev;
  return ret;
}
var metaInstance = {};
Object.defineProperty(metaInstance, "__esModule", {
  value: true
});
metaInstance.getAssumedMasterState = getAssumedMasterState;
metaInstance.getMetaWriteRow = getMetaWriteRow;
metaInstance.getRxReplicationMetaInstanceSchema = getRxReplicationMetaInstanceSchema;
var _rxSchemaHelper$3 = rxSchemaHelper;
var _rxStorageHelper$4 = rxStorageHelper;
var _utils$a = utils;
function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {
  var parentPrimaryKeyLength = (0, _rxSchemaHelper$3.getLengthOfPrimaryKey)(replicatedDocumentsSchema);
  var baseSchema = {
    primaryKey: {
      key: "id",
      fields: ["itemId", "isCheckpoint"],
      separator: "|"
    },
    type: "object",
    version: 0,
    additionalProperties: false,
    properties: {
      id: {
        type: "string",
        minLength: 1,
        // add +1 for the '|' and +1 for the 'isCheckpoint' flag
        maxLength: parentPrimaryKeyLength + 2
      },
      isCheckpoint: {
        type: "string",
        enum: ["0", "1"],
        minLength: 1,
        maxLength: 1
      },
      itemId: {
        type: "string",
        maxLength: parentPrimaryKeyLength
      },
      data: {
        type: "object",
        additionalProperties: true
      },
      isResolvedConflict: {
        type: "string"
      }
    },
    required: ["id", "isCheckpoint", "itemId", "data"]
  };
  if (encrypted) {
    baseSchema.encrypted = ["data"];
  }
  var metaInstanceSchema = (0, _rxSchemaHelper$3.fillWithDefaultSettings)(baseSchema);
  return metaInstanceSchema;
}
function getAssumedMasterState(state, docIds) {
  return state.input.metaInstance.findDocumentsById(docIds.map((docId) => {
    var useId = (0, _rxSchemaHelper$3.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, {
      itemId: docId,
      isCheckpoint: "0"
    });
    return useId;
  }), true).then((metaDocs) => {
    var ret = {};
    Object.values(metaDocs).forEach((metaDoc) => {
      ret[metaDoc.itemId] = {
        docData: metaDoc.data,
        metaDocument: metaDoc
      };
    });
    return ret;
  });
}
function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {
  var docId = newMasterDocState[state.primaryPath];
  var newMeta = previous ? (0, _rxStorageHelper$4.flatCloneDocWithMeta)(previous) : {
    id: "",
    isCheckpoint: "0",
    itemId: docId,
    data: newMasterDocState,
    _attachments: {},
    _deleted: false,
    _rev: (0, _utils$a.getDefaultRevision)(),
    _meta: {
      lwt: 0
    }
  };
  newMeta.data = newMasterDocState;
  newMeta.isResolvedConflict = isResolvedConflict;
  newMeta._meta.lwt = (0, _utils$a.now)();
  newMeta.id = (0, _rxSchemaHelper$3.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, newMeta);
  newMeta._rev = (0, _utils$a.createRevision)(state.input.identifier, previous);
  return {
    previous,
    document: newMeta
  };
}
Object.defineProperty(downstream, "__esModule", {
  value: true
});
downstream.startReplicationDownstream = startReplicationDownstream;
var _rxjs$3 = cjs;
var _rxError$a = rxError;
var _rxStorageHelper$3 = rxStorageHelper;
var _utils$9 = utils;
var _checkpoint$1 = checkpoint;
var _helper$1 = helper$2;
var _metaInstance$1 = metaInstance;
async function startReplicationDownstream(state) {
  if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {
    var checkpointDoc = await (0, _checkpoint$1.getLastCheckpointDoc)(state, "down");
    if (!checkpointDoc) {
      await (0, _checkpoint$1.setCheckpoint)(state, "down", state.input.initialCheckpoint.downstream);
    }
  }
  var identifierHash = state.input.hashFunction(state.input.identifier);
  var replicationHandler = state.input.replicationHandler;
  var timer2 = 0;
  var openTasks = [];
  function addNewTask(task2) {
    state.stats.down.addNewTask = state.stats.down.addNewTask + 1;
    var taskWithTime = {
      time: timer2++,
      task: task2
    };
    openTasks.push(taskWithTime);
    state.streamQueue.down = state.streamQueue.down.then(() => {
      var useTasks = [];
      while (openTasks.length > 0) {
        state.events.active.down.next(true);
        var innerTaskWithTime = (0, _utils$9.ensureNotFalsy)(openTasks.shift());
        if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {
          continue;
        }
        if (innerTaskWithTime.task === "RESYNC") {
          if (useTasks.length === 0) {
            useTasks.push(innerTaskWithTime.task);
            break;
          } else {
            break;
          }
        }
        useTasks.push(innerTaskWithTime.task);
      }
      if (useTasks.length === 0)
        return;
      if (useTasks[0] === "RESYNC") {
        return downstreamResyncOnce();
      } else {
        return downstreamProcessChanges(useTasks);
      }
    }).then(() => {
      state.events.active.down.next(false);
      if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {
        state.firstSyncDone.down.next(true);
      }
    });
  }
  addNewTask("RESYNC");
  var sub = replicationHandler.masterChangeStream$.subscribe((task2) => {
    state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;
    addNewTask(task2);
  });
  (0, _rxjs$3.firstValueFrom)(state.events.canceled.pipe((0, _rxjs$3.filter)((canceled) => !!canceled))).then(() => sub.unsubscribe());
  var lastTimeMasterChangesRequested = -1;
  async function downstreamResyncOnce() {
    state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;
    if (state.events.canceled.getValue()) {
      return;
    }
    state.checkpointQueue = state.checkpointQueue.then(() => (0, _checkpoint$1.getLastCheckpointDoc)(state, "down"));
    var lastCheckpoint = await state.checkpointQueue;
    var promises = [];
    while (!state.events.canceled.getValue()) {
      lastTimeMasterChangesRequested = timer2++;
      var downResult = await replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);
      if (downResult.documents.length === 0) {
        break;
      }
      lastCheckpoint = (0, _rxStorageHelper$3.stackCheckpoints)([lastCheckpoint, downResult.checkpoint]);
      promises.push(persistFromMaster(downResult.documents, lastCheckpoint));
      if (downResult.documents.length < state.input.pullBatchSize) {
        break;
      }
    }
    await Promise.all(promises);
  }
  function downstreamProcessChanges(tasks) {
    state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;
    var docsOfAllTasks = [];
    var lastCheckpoint = null;
    tasks.forEach((task2) => {
      if (task2 === "RESYNC") {
        throw new Error("SNH");
      }
      (0, _utils$9.appendToArray)(docsOfAllTasks, task2.documents);
      lastCheckpoint = (0, _rxStorageHelper$3.stackCheckpoints)([lastCheckpoint, task2.checkpoint]);
    });
    return persistFromMaster(docsOfAllTasks, (0, _utils$9.ensureNotFalsy)(lastCheckpoint));
  }
  var persistenceQueue = _utils$9.PROMISE_RESOLVE_VOID;
  var nonPersistedFromMaster = {
    docs: {}
  };
  function persistFromMaster(docs, checkpoint2) {
    state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;
    docs.forEach((docData) => {
      var docId = docData[state.primaryPath];
      nonPersistedFromMaster.docs[docId] = docData;
    });
    nonPersistedFromMaster.checkpoint = checkpoint2;
    persistenceQueue = persistenceQueue.then(() => {
      var downDocsById = nonPersistedFromMaster.docs;
      nonPersistedFromMaster.docs = {};
      var useCheckpoint = nonPersistedFromMaster.checkpoint;
      var docIds = Object.keys(downDocsById);
      if (state.events.canceled.getValue() || docIds.length === 0) {
        return _utils$9.PROMISE_RESOLVE_VOID;
      }
      var writeRowsToFork = [];
      var writeRowsToForkById = {};
      var writeRowsToMeta = {};
      var useMetaWriteRows = [];
      return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), (0, _metaInstance$1.getAssumedMasterState)(state, docIds)]).then(([currentForkState, assumedMasterState]) => {
        return Promise.all(docIds.map(async (docId) => {
          var forkStateFullDoc = currentForkState[docId];
          var forkStateDocData = forkStateFullDoc ? (0, _helper$1.writeDocToDocState)(forkStateFullDoc) : void 0;
          var masterState = downDocsById[docId];
          var assumedMaster = assumedMasterState[docId];
          if (assumedMaster && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {
            return _utils$9.PROMISE_RESOLVE_VOID;
          }
          var isAssumedMasterEqualToForkStatePromise = !assumedMaster || !forkStateDocData ? _utils$9.PROMISE_RESOLVE_FALSE : state.input.conflictHandler({
            realMasterState: assumedMaster.docData,
            newDocumentState: forkStateDocData
          }, "downstream-check-if-equal-0").then((r) => r.isEqual);
          var isAssumedMasterEqualToForkState = await isAssumedMasterEqualToForkStatePromise;
          if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc._meta[state.input.identifier] && (0, _utils$9.parseRevision)(forkStateFullDoc._rev).height === forkStateFullDoc._meta[state.input.identifier]) {
            isAssumedMasterEqualToForkState = true;
          }
          if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {
            return _utils$9.PROMISE_RESOLVE_VOID;
          }
          var areStatesExactlyEqualPromise = !forkStateDocData ? _utils$9.PROMISE_RESOLVE_FALSE : state.input.conflictHandler({
            realMasterState: masterState,
            newDocumentState: forkStateDocData
          }, "downstream-check-if-equal-1").then((r) => r.isEqual);
          var areStatesExactlyEqual = await areStatesExactlyEqualPromise;
          if (forkStateDocData && areStatesExactlyEqual) {
            if (!assumedMaster || isAssumedMasterEqualToForkState === false) {
              useMetaWriteRows.push((0, _metaInstance$1.getMetaWriteRow)(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : void 0));
            }
            return _utils$9.PROMISE_RESOLVE_VOID;
          }
          var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {
            _meta: (0, _utils$9.flatClone)(forkStateFullDoc._meta),
            _attachments: {},
            _rev: (0, _utils$9.getDefaultRevision)()
          } : {
            _meta: (0, _utils$9.getDefaultRxDocumentMeta)(),
            _rev: (0, _utils$9.getDefaultRevision)(),
            _attachments: {}
          });
          if (masterState._rev) {
            var nextRevisionHeight = !forkStateFullDoc ? 1 : (0, _utils$9.parseRevision)(forkStateFullDoc._rev).height + 1;
            newForkState._meta[state.input.identifier] = nextRevisionHeight;
          }
          var forkWriteRow = {
            previous: forkStateFullDoc,
            document: newForkState
          };
          forkWriteRow.document._rev = (0, _utils$9.createRevision)(identifierHash, forkWriteRow.previous);
          writeRowsToFork.push(forkWriteRow);
          writeRowsToForkById[docId] = forkWriteRow;
          writeRowsToMeta[docId] = (0, _metaInstance$1.getMetaWriteRow)(state, masterState, assumedMaster ? assumedMaster.metaDocument : void 0);
        }));
      }).then(() => {
        if (writeRowsToFork.length > 0) {
          return state.input.forkInstance.bulkWrite(writeRowsToFork, state.downstreamBulkWriteFlag).then((forkWriteResult) => {
            Object.keys(forkWriteResult.success).forEach((docId) => {
              state.events.processed.down.next(writeRowsToForkById[docId]);
              useMetaWriteRows.push(writeRowsToMeta[docId]);
            });
            Object.values(forkWriteResult.error).forEach((error) => {
              if (error.status === 409) {
                return;
              }
              state.events.error.next((0, _rxError$a.newRxError)("RC_PULL", {
                writeError: error
              }));
            });
          });
        }
      }).then(() => {
        if (useMetaWriteRows.length > 0) {
          return state.input.metaInstance.bulkWrite(useMetaWriteRows, "replication-down-write-meta").then((metaWriteResult) => {
            Object.entries(metaWriteResult.error).forEach(([docId, writeError]) => {
              state.events.error.next((0, _rxError$a.newRxError)("RC_PULL", {
                id: docId,
                writeError
              }));
            });
          });
        }
      }).then(() => {
        state.checkpointQueue = state.checkpointQueue.then(() => (0, _checkpoint$1.setCheckpoint)(state, "down", useCheckpoint));
      });
    }).catch((unhandledError) => state.events.error.next(unhandledError));
    return persistenceQueue;
  }
}
var upstream = {};
var conflicts = {};
Object.defineProperty(conflicts, "__esModule", {
  value: true
});
conflicts.defaultConflictHandler = void 0;
conflicts.resolveConflictError = resolveConflictError;
var _utils$8 = utils;
var defaultConflictHandler = function(i, _context) {
  if ((0, _utils$8.deepEqual)(i.newDocumentState, i.realMasterState)) {
    return Promise.resolve({
      isEqual: true
    });
  }
  return Promise.resolve({
    isEqual: false,
    documentData: i.realMasterState
  });
};
conflicts.defaultConflictHandler = defaultConflictHandler;
async function resolveConflictError(state, input, forkState) {
  var conflictHandler = state.input.conflictHandler;
  var conflictHandlerOutput = await conflictHandler(input, "replication-resolve-conflict");
  if (conflictHandlerOutput.isEqual) {
    return void 0;
  } else {
    var resolvedDoc = Object.assign({}, conflictHandlerOutput.documentData, {
      /**
       * Because the resolved conflict is written to the fork,
       * we have to keep/update the forks _meta data, not the masters.
       */
      _meta: (0, _utils$8.flatClone)(forkState._meta),
      _rev: (0, _utils$8.getDefaultRevision)(),
      _attachments: (0, _utils$8.flatClone)(forkState._attachments)
    });
    resolvedDoc._meta.lwt = (0, _utils$8.now)();
    resolvedDoc._rev = (0, _utils$8.createRevision)(state.input.identifier, forkState);
    return {
      resolvedDoc,
      output: conflictHandlerOutput
    };
  }
}
Object.defineProperty(upstream, "__esModule", {
  value: true
});
upstream.startReplicationUpstream = startReplicationUpstream;
var _rxjs$2 = cjs;
var _rxStorageHelper$2 = rxStorageHelper;
var _utils$7 = utils;
var _checkpoint = checkpoint;
var _conflicts = conflicts;
var _helper = helper$2;
var _metaInstance = metaInstance;
async function startReplicationUpstream(state) {
  if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {
    var checkpointDoc = await (0, _checkpoint.getLastCheckpointDoc)(state, "up");
    if (!checkpointDoc) {
      await (0, _checkpoint.setCheckpoint)(state, "up", state.input.initialCheckpoint.upstream);
    }
  }
  var replicationHandler = state.input.replicationHandler;
  state.streamQueue.up = state.streamQueue.up.then(() => {
    return upstreamInitialSync().then(() => {
      processTasks();
    });
  });
  var timer2 = 0;
  var initialSyncStartTime = -1;
  var openTasks = [];
  var sub = state.input.forkInstance.changeStream().pipe((0, _rxjs$2.filter)((eventBulk) => eventBulk.context !== state.downstreamBulkWriteFlag)).subscribe((eventBulk) => {
    state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;
    openTasks.push({
      task: eventBulk,
      time: timer2++
    });
    if (state.input.waitBeforePersist) {
      return state.input.waitBeforePersist().then(() => processTasks());
    } else {
      return processTasks();
    }
  });
  (0, _rxjs$2.firstValueFrom)(state.events.canceled.pipe((0, _rxjs$2.filter)((canceled) => !!canceled))).then(() => sub.unsubscribe());
  async function upstreamInitialSync() {
    state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;
    if (state.events.canceled.getValue()) {
      return;
    }
    state.checkpointQueue = state.checkpointQueue.then(() => (0, _checkpoint.getLastCheckpointDoc)(state, "up"));
    var lastCheckpoint = await state.checkpointQueue;
    var promises = [];
    while (!state.events.canceled.getValue()) {
      initialSyncStartTime = timer2++;
      var upResult = await state.input.forkInstance.getChangedDocumentsSince(state.input.pushBatchSize, lastCheckpoint);
      if (upResult.documents.length === 0) {
        break;
      }
      lastCheckpoint = (0, _rxStorageHelper$2.stackCheckpoints)([lastCheckpoint, upResult.checkpoint]);
      promises.push(persistToMaster(upResult.documents, (0, _utils$7.ensureNotFalsy)(lastCheckpoint)));
    }
    var resolvedPromises = await Promise.all(promises);
    var hadConflicts = resolvedPromises.find((r) => !!r);
    if (hadConflicts) {
      await upstreamInitialSync();
    } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {
      state.firstSyncDone.up.next(true);
    }
  }
  function processTasks() {
    if (state.events.canceled.getValue() || openTasks.length === 0) {
      state.events.active.up.next(false);
      return;
    }
    state.stats.up.processTasks = state.stats.up.processTasks + 1;
    state.events.active.up.next(true);
    state.streamQueue.up = state.streamQueue.up.then(() => {
      var docs = [];
      var checkpoint2 = {};
      while (openTasks.length > 0) {
        var taskWithTime = (0, _utils$7.ensureNotFalsy)(openTasks.shift());
        if (taskWithTime.time < initialSyncStartTime) {
          continue;
        }
        (0, _utils$7.appendToArray)(docs, taskWithTime.task.events.map((r) => {
          return r.documentData;
        }));
        checkpoint2 = (0, _rxStorageHelper$2.stackCheckpoints)([checkpoint2, taskWithTime.task.checkpoint]);
      }
      var promise = docs.length === 0 ? _utils$7.PROMISE_RESOLVE_FALSE : persistToMaster(docs, checkpoint2);
      return promise.then(() => {
        if (openTasks.length === 0) {
          state.events.active.up.next(false);
        } else {
          processTasks();
        }
      });
    });
  }
  var persistenceQueue = _utils$7.PROMISE_RESOLVE_FALSE;
  var nonPersistedFromMaster = {
    docs: {}
  };
  function persistToMaster(docs, checkpoint2) {
    state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;
    docs.forEach((docData) => {
      var docId = docData[state.primaryPath];
      nonPersistedFromMaster.docs[docId] = docData;
    });
    nonPersistedFromMaster.checkpoint = checkpoint2;
    persistenceQueue = persistenceQueue.then(async () => {
      if (state.events.canceled.getValue()) {
        return false;
      }
      var upDocsById = nonPersistedFromMaster.docs;
      nonPersistedFromMaster.docs = {};
      var useCheckpoint = nonPersistedFromMaster.checkpoint;
      var docIds = Object.keys(upDocsById);
      if (docIds.length === 0) {
        return false;
      }
      var assumedMasterState = await (0, _metaInstance.getAssumedMasterState)(state, docIds);
      var writeRowsToMaster = {};
      var writeRowsToMasterIds = [];
      var writeRowsToMeta = {};
      var forkStateById = {};
      await Promise.all(docIds.map(async (docId) => {
        var fullDocData = upDocsById[docId];
        forkStateById[docId] = fullDocData;
        var docData = (0, _helper.writeDocToDocState)(fullDocData);
        var assumedMasterDoc = assumedMasterState[docId];
        if (assumedMasterDoc && // if the isResolvedConflict is correct, we do not have to compare the documents.
        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && (await state.input.conflictHandler({
          realMasterState: assumedMasterDoc.docData,
          newDocumentState: docData
        }, "upstream-check-if-equal")).isEqual || /**
         * If the master works with _rev fields,
         * we use that to check if our current doc state
         * is different from the assumedMasterDoc.
         */
        assumedMasterDoc && assumedMasterDoc.docData._rev && (0, _utils$7.parseRevision)(fullDocData._rev).height === fullDocData._meta[state.input.identifier]) {
          return;
        }
        writeRowsToMasterIds.push(docId);
        writeRowsToMaster[docId] = {
          assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : void 0,
          newDocumentState: docData
        };
        writeRowsToMeta[docId] = (0, _metaInstance.getMetaWriteRow)(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : void 0);
      }));
      if (writeRowsToMasterIds.length === 0) {
        return false;
      }
      var writeRowsArray = Object.values(writeRowsToMaster);
      var conflictIds = /* @__PURE__ */ new Set();
      var conflictsById = {};
      var writeBatches = (0, _utils$7.batchArray)(writeRowsArray, state.input.pushBatchSize);
      await Promise.all(writeBatches.map(async (writeBatch) => {
        var masterWriteResult = await replicationHandler.masterWrite(writeBatch);
        masterWriteResult.forEach((conflictDoc) => {
          var id = conflictDoc[state.primaryPath];
          conflictIds.add(id);
          conflictsById[id] = conflictDoc;
        });
      }));
      var useWriteRowsToMeta = [];
      writeRowsToMasterIds.forEach((docId) => {
        if (!conflictIds.has(docId)) {
          state.events.processed.up.next(writeRowsToMaster[docId]);
          useWriteRowsToMeta.push(writeRowsToMeta[docId]);
        }
      });
      if (useWriteRowsToMeta.length > 0) {
        await state.input.metaInstance.bulkWrite(useWriteRowsToMeta, "replication-up-write-meta");
      }
      var hadConflictWrites = false;
      if (conflictIds.size > 0) {
        state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;
        var conflictWriteFork = [];
        var conflictWriteMeta = {};
        await Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {
          var writeToMasterRow = writeRowsToMaster[docId];
          var input = {
            newDocumentState: writeToMasterRow.newDocumentState,
            assumedMasterState: writeToMasterRow.assumedMasterState,
            realMasterState
          };
          return (0, _conflicts.resolveConflictError)(state, input, forkStateById[docId]).then((resolved2) => {
            if (resolved2) {
              state.events.resolvedConflicts.next({
                input,
                output: resolved2.output
              });
              conflictWriteFork.push({
                previous: forkStateById[docId],
                document: resolved2.resolvedDoc
              });
              var assumedMasterDoc = assumedMasterState[docId];
              conflictWriteMeta[docId] = (0, _metaInstance.getMetaWriteRow)(state, (0, _utils$7.ensureNotFalsy)(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : void 0, resolved2.resolvedDoc._rev);
            }
          });
        }));
        if (conflictWriteFork.length > 0) {
          hadConflictWrites = true;
          state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;
          var forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork, "replication-up-write-conflict");
          var useMetaWrites = [];
          Object.keys(forkWriteResult.success).forEach((docId) => {
            useMetaWrites.push(conflictWriteMeta[docId]);
          });
          if (useMetaWrites.length > 0) {
            await state.input.metaInstance.bulkWrite(useMetaWrites, "replication-up-write-conflict-meta");
          }
        }
      }
      state.checkpointQueue = state.checkpointQueue.then(() => (0, _checkpoint.setCheckpoint)(state, "up", useCheckpoint));
      return hadConflictWrites;
    }).catch((unhandledError) => {
      state.events.error.next(unhandledError);
      return false;
    });
    return persistenceQueue;
  }
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    replicateRxStorageInstance: true,
    awaitRxStorageReplicationFirstInSync: true,
    awaitRxStorageReplicationInSync: true,
    awaitRxStorageReplicationIdle: true,
    rxStorageInstanceToReplicationHandler: true,
    cancelRxStorageReplication: true
  };
  exports.awaitRxStorageReplicationFirstInSync = awaitRxStorageReplicationFirstInSync;
  exports.awaitRxStorageReplicationIdle = awaitRxStorageReplicationIdle;
  exports.awaitRxStorageReplicationInSync = awaitRxStorageReplicationInSync;
  exports.cancelRxStorageReplication = cancelRxStorageReplication;
  exports.replicateRxStorageInstance = replicateRxStorageInstance;
  exports.rxStorageInstanceToReplicationHandler = rxStorageInstanceToReplicationHandler;
  var _rxjs2 = cjs;
  var _rxSchemaHelper2 = rxSchemaHelper;
  var _utils2 = utils;
  var _checkpoint2 = checkpoint;
  Object.keys(_checkpoint2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _checkpoint2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _checkpoint2[key];
      }
    });
  });
  var _downstream = downstream;
  Object.keys(_downstream).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _downstream[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _downstream[key];
      }
    });
  });
  var _helper2 = helper$2;
  Object.keys(_helper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _helper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _helper2[key];
      }
    });
  });
  var _upstream = upstream;
  Object.keys(_upstream).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _upstream[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _upstream[key];
      }
    });
  });
  var _metaInstance2 = metaInstance;
  Object.keys(_metaInstance2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _metaInstance2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _metaInstance2[key];
      }
    });
  });
  var _conflicts2 = conflicts;
  Object.keys(_conflicts2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _conflicts2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _conflicts2[key];
      }
    });
  });
  function replicateRxStorageInstance(input) {
    var checkpointKey = (0, _checkpoint2.getCheckpointKey)(input);
    var state = {
      primaryPath: (0, _rxSchemaHelper2.getPrimaryFieldOfPrimaryKey)(input.forkInstance.schema.primaryKey),
      input,
      checkpointKey,
      downstreamBulkWriteFlag: "replication-downstream-" + checkpointKey,
      events: {
        canceled: new _rxjs2.BehaviorSubject(false),
        active: {
          down: new _rxjs2.BehaviorSubject(true),
          up: new _rxjs2.BehaviorSubject(true)
        },
        processed: {
          down: new _rxjs2.Subject(),
          up: new _rxjs2.Subject()
        },
        resolvedConflicts: new _rxjs2.Subject(),
        error: new _rxjs2.Subject()
      },
      stats: {
        down: {
          addNewTask: 0,
          downstreamProcessChanges: 0,
          downstreamResyncOnce: 0,
          masterChangeStreamEmit: 0,
          persistFromMaster: 0
        },
        up: {
          forkChangeStreamEmit: 0,
          persistToMaster: 0,
          persistToMasterConflictWrites: 0,
          persistToMasterHadConflicts: 0,
          processTasks: 0,
          upstreamInitialSync: 0
        }
      },
      firstSyncDone: {
        down: new _rxjs2.BehaviorSubject(false),
        up: new _rxjs2.BehaviorSubject(false)
      },
      streamQueue: {
        down: _utils2.PROMISE_RESOLVE_VOID,
        up: _utils2.PROMISE_RESOLVE_VOID
      },
      checkpointQueue: _utils2.PROMISE_RESOLVE_VOID,
      lastCheckpointDoc: {}
    };
    (0, _downstream.startReplicationDownstream)(state);
    (0, _upstream.startReplicationUpstream)(state);
    return state;
  }
  function awaitRxStorageReplicationFirstInSync(state) {
    return (0, _rxjs2.firstValueFrom)((0, _rxjs2.combineLatest)([state.firstSyncDone.down.pipe((0, _rxjs2.filter)((v) => !!v)), state.firstSyncDone.up.pipe((0, _rxjs2.filter)((v) => !!v))])).then(() => {
    });
  }
  function awaitRxStorageReplicationInSync(replicationState) {
    return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);
  }
  async function awaitRxStorageReplicationIdle(state) {
    await awaitRxStorageReplicationFirstInSync(state);
    while (true) {
      var {
        down,
        up
      } = state.streamQueue;
      await Promise.all([up, down]);
      if (down === state.streamQueue.down && up === state.streamQueue.up) {
        return;
      }
    }
  }
  function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken) {
    var primaryPath = (0, _rxSchemaHelper2.getPrimaryFieldOfPrimaryKey)(instance.schema.primaryKey);
    var replicationHandler = {
      masterChangeStream$: instance.changeStream().pipe((0, _rxjs2.map)((eventBulk) => {
        var ret = {
          checkpoint: eventBulk.checkpoint,
          documents: eventBulk.events.map((event) => {
            return (0, _helper2.writeDocToDocState)((0, _utils2.ensureNotFalsy)(event.documentData));
          })
        };
        return ret;
      })),
      masterChangesSince(checkpoint2, batchSize) {
        return instance.getChangedDocumentsSince(batchSize, checkpoint2).then((result) => {
          return {
            checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint2,
            documents: result.documents.map((d) => (0, _helper2.writeDocToDocState)(d))
          };
        });
      },
      async masterWrite(rows) {
        var rowById = {};
        rows.forEach((row) => {
          var docId = row.newDocumentState[primaryPath];
          rowById[docId] = row;
        });
        var ids = Object.keys(rowById);
        var masterDocsState = await instance.findDocumentsById(ids, true);
        var conflicts2 = [];
        var writeRows = [];
        await Promise.all(Object.entries(rowById).map(async ([id, row]) => {
          var masterState = masterDocsState[id];
          if (!masterState) {
            writeRows.push({
              document: (0, _helper2.docStateToWriteDoc)(databaseInstanceToken, row.newDocumentState)
            });
          } else if (masterState && !row.assumedMasterState) {
            conflicts2.push((0, _helper2.writeDocToDocState)(masterState));
          } else if ((await conflictHandler({
            realMasterState: (0, _helper2.writeDocToDocState)(masterState),
            newDocumentState: (0, _utils2.ensureNotFalsy)(row.assumedMasterState)
          }, "rxStorageInstanceToReplicationHandler-masterWrite")).isEqual === true) {
            writeRows.push({
              previous: masterState,
              document: (0, _helper2.docStateToWriteDoc)(databaseInstanceToken, row.newDocumentState, masterState)
            });
          } else {
            conflicts2.push((0, _helper2.writeDocToDocState)(masterState));
          }
        }));
        if (writeRows.length > 0) {
          var result = await instance.bulkWrite(writeRows, "replication-master-write");
          Object.values(result.error).forEach((err) => {
            if (err.status !== 409) {
              throw new Error("non conflict error");
            } else {
              conflicts2.push((0, _helper2.writeDocToDocState)((0, _utils2.ensureNotFalsy)(err.documentInDb)));
            }
          });
        }
        return conflicts2;
      }
    };
    return replicationHandler;
  }
  function cancelRxStorageReplication(replicationState) {
    replicationState.events.canceled.next(true);
    replicationState.events.active.up.complete();
    replicationState.events.active.down.complete();
    replicationState.events.processed.up.complete();
    replicationState.events.processed.down.complete();
    replicationState.events.resolvedConflicts.complete();
    replicationState.events.canceled.complete();
  }
})(replicationProtocol);
var _interopRequireDefault$2 = interopRequireDefaultExports$1;
Object.defineProperty(rxCollection, "__esModule", {
  value: true
});
rxCollection.RxCollectionBase = void 0;
rxCollection.createRxCollection = createRxCollection;
rxCollection.isRxCollection = isRxCollection;
var _createClass2$1 = _interopRequireDefault$2(requireCreateClass());
var _operators$2 = operators;
var _utils$6 = utils;
var _rxCollectionHelper$1 = rxCollectionHelper;
var _rxQuery$1 = rxQuery;
var _rxError$9 = rxError;
var _docCache = requireDocCache();
var _queryCache = queryCache;
var _changeEventBuffer = requireChangeEventBuffer();
var _hooks$2 = hooks;
var _rxDocumentPrototypeMerge = rxDocumentPrototypeMerge;
var _rxStorageHelper$1 = rxStorageHelper;
var _replicationProtocol = replicationProtocol;
var _incrementalWrite = incrementalWrite;
var _rxDocument$2 = rxDocument;
var _overwritable$2 = overwritable$1;
var HOOKS_WHEN = ["pre", "post"];
var HOOKS_KEYS = ["insert", "save", "remove", "create"];
var hooksApplied = false;
var RxCollectionBase = /* @__PURE__ */ function() {
  function RxCollectionBase2(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options2 = {}, cacheReplacementPolicy = _queryCache.defaultCacheReplacementPolicy, statics = {}, conflictHandler = _replicationProtocol.defaultConflictHandler) {
    this.storageInstance = {};
    this.timeouts = /* @__PURE__ */ new Set();
    this.incrementalWriteQueue = {};
    this._incrementalUpsertQueues = /* @__PURE__ */ new Map();
    this.synced = false;
    this.hooks = {};
    this._subs = [];
    this._docCache = {};
    this._queryCache = (0, _queryCache.createQueryCache)();
    this.$ = {};
    this.checkpoint$ = {};
    this._changeEventBuffer = {};
    this.onDestroy = [];
    this.destroyed = false;
    this.database = database;
    this.name = name;
    this.schema = schema;
    this.internalStorageInstance = internalStorageInstance;
    this.instanceCreationOptions = instanceCreationOptions;
    this.migrationStrategies = migrationStrategies;
    this.methods = methods;
    this.attachments = attachments;
    this.options = options2;
    this.cacheReplacementPolicy = cacheReplacementPolicy;
    this.statics = statics;
    this.conflictHandler = conflictHandler;
    _applyHookFunctions(this.asRxCollection);
  }
  var _proto = RxCollectionBase2.prototype;
  _proto.prepare = async function prepare() {
    this.storageInstance = (0, _rxStorageHelper$1.getWrappedStorageInstance)(this.database, this.internalStorageInstance, this.schema.jsonSchema);
    this.incrementalWriteQueue = new _incrementalWrite.IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => (0, _rxDocument$2.beforeDocumentUpdateWrite)(this, newData, oldData), (result) => this._runHooks("post", "save", result));
    var collectionEventBulks$ = this.database.eventBulks$.pipe((0, _operators$2.filter)((changeEventBulk) => changeEventBulk.collectionName === this.name));
    this.$ = collectionEventBulks$.pipe((0, _operators$2.mergeMap)((changeEventBulk) => changeEventBulk.events));
    this.checkpoint$ = collectionEventBulks$.pipe((0, _operators$2.map)((changeEventBulk) => changeEventBulk.checkpoint));
    this._changeEventBuffer = (0, _changeEventBuffer.createChangeEventBuffer)(this.asRxCollection);
    this._docCache = new _docCache.DocumentCache(this.schema.primaryPath, this.$.pipe((0, _operators$2.filter)((cE) => !cE.isLocal)), (docData) => (0, _rxDocumentPrototypeMerge.createNewRxDocument)(this.asRxCollection, docData));
    var databaseStorageToken = await this.database.storageToken;
    var subDocs = this.storageInstance.changeStream().subscribe((eventBulk) => {
      var changeEventBulk = {
        id: eventBulk.id,
        internal: false,
        collectionName: this.name,
        storageToken: databaseStorageToken,
        events: eventBulk.events.map((ev) => (0, _rxStorageHelper$1.storageChangeEventToRxChangeEvent)(false, ev, this)),
        databaseToken: this.database.token,
        checkpoint: eventBulk.checkpoint,
        context: eventBulk.context
      };
      this.database.$emit(changeEventBulk);
    });
    this._subs.push(subDocs);
    this._subs.push(this.storageInstance.conflictResultionTasks().subscribe((task2) => {
      this.conflictHandler(task2.input, task2.context).then((output) => {
        this.storageInstance.resolveConflictResultionTask({
          id: task2.id,
          output
        });
      });
    }));
    return _utils$6.PROMISE_RESOLVE_VOID;
  };
  _proto.migrationNeeded = function migrationNeeded() {
    throw (0, _utils$6.pluginMissing)("migration");
  };
  _proto.getDataMigrator = function getDataMigrator() {
    throw (0, _utils$6.pluginMissing)("migration");
  };
  _proto.migrate = function migrate(batchSize = 10) {
    return this.getDataMigrator().migrate(batchSize);
  };
  _proto.migratePromise = function migratePromise(batchSize = 10) {
    return this.getDataMigrator().migratePromise(batchSize);
  };
  _proto.insert = async function insert(json) {
    var writeResult = await this.bulkInsert([json]);
    var isError = writeResult.error[0];
    (0, _rxStorageHelper$1.throwIfIsStorageWriteError)(this, json[this.schema.primaryPath], json, isError);
    var insertResult = (0, _utils$6.ensureNotFalsy)(writeResult.success[0]);
    return insertResult;
  };
  _proto.bulkInsert = async function bulkInsert(docsData) {
    if (docsData.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var primaryPath = this.schema.primaryPath;
    var useDocs = docsData.map((docData) => {
      var useDocData = (0, _rxCollectionHelper$1.fillObjectDataBeforeInsert)(this.schema, docData);
      return useDocData;
    });
    var docs = this.hasHooks("pre", "insert") ? await Promise.all(useDocs.map((doc) => {
      return this._runHooks("pre", "insert", doc).then(() => {
        return doc;
      });
    })) : useDocs;
    var docsMap = /* @__PURE__ */ new Map();
    var insertRows = docs.map((doc) => {
      docsMap.set(doc[primaryPath], doc);
      var row = {
        document: doc
      };
      return row;
    });
    var results = await this.storageInstance.bulkWrite(insertRows, "rx-collection-bulk-insert");
    var rxDocuments = Object.values(results.success).map((writtenDocData) => this._docCache.getCachedRxDocument(writtenDocData));
    if (this.hasHooks("post", "insert")) {
      await Promise.all(rxDocuments.map((doc) => {
        return this._runHooks("post", "insert", docsMap.get(doc.primary), doc);
      }));
    }
    return {
      success: rxDocuments,
      error: Object.values(results.error)
    };
  };
  _proto.bulkRemove = async function bulkRemove(ids) {
    if (ids.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var rxDocumentMap = await this.findByIds(ids).exec();
    var docsData = [];
    var docsMap = /* @__PURE__ */ new Map();
    Array.from(rxDocumentMap.values()).forEach((rxDocument2) => {
      var data = rxDocument2.toMutableJSON(true);
      docsData.push(data);
      docsMap.set(rxDocument2.primary, data);
    });
    await Promise.all(docsData.map((doc) => {
      var primary = doc[this.schema.primaryPath];
      return this._runHooks("pre", "remove", doc, rxDocumentMap.get(primary));
    }));
    var removeDocs = docsData.map((doc) => {
      var writeDoc = (0, _utils$6.flatClone)(doc);
      writeDoc._deleted = true;
      return {
        previous: doc,
        document: writeDoc
      };
    });
    var results = await this.storageInstance.bulkWrite(removeDocs, "rx-collection-bulk-remove");
    var successIds = Object.keys(results.success);
    await Promise.all(successIds.map((id) => {
      return this._runHooks("post", "remove", docsMap.get(id), rxDocumentMap.get(id));
    }));
    var rxDocuments = successIds.map((id) => (0, _utils$6.getFromMapOrThrow)(rxDocumentMap, id));
    return {
      success: rxDocuments,
      error: Object.values(results.error)
    };
  };
  _proto.bulkUpsert = async function bulkUpsert(docsData) {
    var insertData = [];
    var useJsonByDocId = /* @__PURE__ */ new Map();
    docsData.forEach((docData) => {
      var useJson = (0, _rxCollectionHelper$1.fillObjectDataBeforeInsert)(this.schema, docData);
      var primary = useJson[this.schema.primaryPath];
      if (!primary) {
        throw (0, _rxError$9.newRxError)("COL3", {
          primaryPath: this.schema.primaryPath,
          data: useJson,
          schema: this.schema.jsonSchema
        });
      }
      useJsonByDocId.set(primary, useJson);
      insertData.push(useJson);
    });
    var insertResult = await this.bulkInsert(insertData);
    var ret = insertResult.success.slice(0);
    var updatedDocs = await Promise.all(insertResult.error.map(async (error) => {
      if (error.status !== 409) {
        throw (0, _rxError$9.newRxError)("VD2", {
          collection: this.name,
          writeError: error
        });
      }
      var id = error.documentId;
      var writeData = (0, _utils$6.getFromMapOrThrow)(useJsonByDocId, id);
      var docDataInDb = (0, _utils$6.ensureNotFalsy)(error.documentInDb);
      var doc = this._docCache.getCachedRxDocument(docDataInDb);
      var newDoc = await doc.incrementalModify(() => writeData);
      return newDoc;
    }));
    (0, _utils$6.appendToArray)(ret, updatedDocs);
    return ret;
  };
  _proto.upsert = function upsert(json) {
    return this.bulkUpsert([json]).then((result) => result[0]);
  };
  _proto.incrementalUpsert = function incrementalUpsert(json) {
    var useJson = (0, _rxCollectionHelper$1.fillObjectDataBeforeInsert)(this.schema, json);
    var primary = useJson[this.schema.primaryPath];
    if (!primary) {
      throw (0, _rxError$9.newRxError)("COL4", {
        data: json
      });
    }
    var queue = this._incrementalUpsertQueues.get(primary);
    if (!queue) {
      queue = _utils$6.PROMISE_RESOLVE_VOID;
    }
    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then((wasInserted) => {
      if (!wasInserted.inserted) {
        return _incrementalUpsertUpdate(wasInserted.doc, useJson);
      } else {
        return wasInserted.doc;
      }
    });
    this._incrementalUpsertQueues.set(primary, queue);
    return queue;
  };
  _proto.find = function find2(queryObj) {
    if (typeof queryObj === "string") {
      throw (0, _rxError$9.newRxError)("COL5", {
        queryObj
      });
    }
    if (!queryObj) {
      queryObj = (0, _rxQuery$1._getDefaultQuery)();
    }
    var query2 = (0, _rxQuery$1.createRxQuery)("find", queryObj, this);
    return query2;
  };
  _proto.findOne = function findOne(queryObj) {
    var query2;
    if (typeof queryObj === "string") {
      query2 = (0, _rxQuery$1.createRxQuery)("findOne", {
        selector: {
          [this.schema.primaryPath]: queryObj
        },
        limit: 1
      }, this);
    } else {
      if (!queryObj) {
        queryObj = (0, _rxQuery$1._getDefaultQuery)();
      }
      if (queryObj.limit) {
        throw (0, _rxError$9.newRxError)("QU6");
      }
      queryObj.limit = 1;
      query2 = (0, _rxQuery$1.createRxQuery)("findOne", queryObj, this);
    }
    if (typeof queryObj === "number" || Array.isArray(queryObj)) {
      throw (0, _rxError$9.newRxTypeError)("COL6", {
        queryObj
      });
    }
    return query2;
  };
  _proto.count = function count2(queryObj) {
    if (!queryObj) {
      queryObj = (0, _rxQuery$1._getDefaultQuery)();
    }
    var query2 = (0, _rxQuery$1.createRxQuery)("count", queryObj, this);
    return query2;
  };
  _proto.findByIds = function findByIds(ids) {
    var mangoQuery = {
      selector: {
        [this.schema.primaryPath]: {
          $in: ids.slice(0)
        }
      }
    };
    var query2 = (0, _rxQuery$1.createRxQuery)("findByIds", mangoQuery, this);
    return query2;
  };
  _proto.exportJSON = function exportJSON() {
    throw (0, _utils$6.pluginMissing)("json-dump");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw (0, _utils$6.pluginMissing)("json-dump");
  };
  _proto.insertCRDT = function insertCRDT(_updateObj) {
    throw (0, _utils$6.pluginMissing)("crdt");
  };
  _proto.addHook = function addHook(when, key, fun, parallel = false) {
    if (typeof fun !== "function") {
      throw (0, _rxError$9.newRxTypeError)("COL7", {
        key,
        when
      });
    }
    if (!HOOKS_WHEN.includes(when)) {
      throw (0, _rxError$9.newRxTypeError)("COL8", {
        key,
        when
      });
    }
    if (!HOOKS_KEYS.includes(key)) {
      throw (0, _rxError$9.newRxError)("COL9", {
        key
      });
    }
    if (when === "post" && key === "create" && parallel === true) {
      throw (0, _rxError$9.newRxError)("COL10", {
        when,
        key,
        parallel
      });
    }
    var boundFun = fun.bind(this);
    var runName = parallel ? "parallel" : "series";
    this.hooks[key] = this.hooks[key] || {};
    this.hooks[key][when] = this.hooks[key][when] || {
      series: [],
      parallel: []
    };
    this.hooks[key][when][runName].push(boundFun);
  };
  _proto.getHooks = function getHooks(when, key) {
    if (!this.hooks[key] || !this.hooks[key][when]) {
      return {
        series: [],
        parallel: []
      };
    }
    return this.hooks[key][when];
  };
  _proto.hasHooks = function hasHooks(when, key) {
    var hooks2 = this.getHooks(when, key);
    if (!hooks2) {
      return false;
    }
    return hooks2.series.length > 0 || hooks2.parallel.length > 0;
  };
  _proto._runHooks = function _runHooks(when, key, data, instance) {
    var hooks2 = this.getHooks(when, key);
    if (!hooks2) {
      return _utils$6.PROMISE_RESOLVE_VOID;
    }
    var tasks = hooks2.series.map((hook) => () => hook(data, instance));
    return (0, _utils$6.promiseSeries)(tasks).then(() => Promise.all(hooks2.parallel.map((hook) => hook(data, instance))));
  };
  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {
    var hooks2 = this.getHooks(when, key);
    if (!hooks2)
      return;
    hooks2.series.forEach((hook) => hook(data, instance));
  };
  _proto.promiseWait = function promiseWait2(time) {
    var ret = new Promise((res) => {
      var timeout2 = setTimeout(() => {
        this.timeouts.delete(timeout2);
        res();
      }, time);
      this.timeouts.add(timeout2);
    });
    return ret;
  };
  _proto.destroy = function destroy() {
    if (this.destroyed) {
      return _utils$6.PROMISE_RESOLVE_FALSE;
    }
    this.destroyed = true;
    Array.from(this.timeouts).forEach((timeout2) => clearTimeout(timeout2));
    if (this._changeEventBuffer) {
      this._changeEventBuffer.destroy();
    }
    return this.database.requestIdlePromise().then(() => Promise.all(this.onDestroy.map((fn) => fn()))).then(() => this.storageInstance.close()).then(() => {
      this._subs.forEach((sub) => sub.unsubscribe());
      delete this.database.collections[this.name];
      return (0, _hooks$2.runAsyncPluginHooks)("postDestroyRxCollection", this).then(() => true);
    });
  };
  _proto.remove = async function remove() {
    await this.destroy();
    await (0, _rxCollectionHelper$1.removeCollectionStorages)(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.hashFunction);
  };
  (0, _createClass2$1.default)(RxCollectionBase2, [{
    key: "insert$",
    get: function() {
      return this.$.pipe((0, _operators$2.filter)((cE) => cE.operation === "INSERT"));
    }
  }, {
    key: "update$",
    get: function() {
      return this.$.pipe((0, _operators$2.filter)((cE) => cE.operation === "UPDATE"));
    }
  }, {
    key: "remove$",
    get: function() {
      return this.$.pipe((0, _operators$2.filter)((cE) => cE.operation === "DELETE"));
    }
    // defaults
    /**
     * When the collection is destroyed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
     */
  }, {
    key: "asRxCollection",
    get: function() {
      return this;
    }
  }]);
  return RxCollectionBase2;
}();
rxCollection.RxCollectionBase = RxCollectionBase;
function _applyHookFunctions(collection) {
  if (hooksApplied)
    return;
  hooksApplied = true;
  var colProto = Object.getPrototypeOf(collection);
  HOOKS_KEYS.forEach((key) => {
    HOOKS_WHEN.map((when) => {
      var fnName = when + (0, _utils$6.ucfirst)(key);
      colProto[fnName] = function(fun, parallel) {
        return this.addHook(when, key, fun, parallel);
      };
    });
  });
}
function _incrementalUpsertUpdate(doc, json) {
  return doc.incrementalModify((_innerDoc) => {
    return json;
  });
}
function _incrementalUpsertEnsureRxDocumentExists(rxCollection2, primary, json) {
  var docDataFromCache = rxCollection2._docCache.getLatestDocumentDataIfExists(primary);
  if (docDataFromCache) {
    return Promise.resolve({
      doc: rxCollection2._docCache.getCachedRxDocument(docDataFromCache),
      inserted: false
    });
  }
  return rxCollection2.findOne(primary).exec().then((doc) => {
    if (!doc) {
      return rxCollection2.insert(json).then((newDoc) => ({
        doc: newDoc,
        inserted: true
      }));
    } else {
      return {
        doc,
        inserted: false
      };
    }
  });
}
function createRxCollection({
  database,
  name,
  schema,
  instanceCreationOptions = {},
  migrationStrategies = {},
  autoMigrate = true,
  statics = {},
  methods = {},
  attachments = {},
  options: options2 = {},
  localDocuments = false,
  cacheReplacementPolicy = _queryCache.defaultCacheReplacementPolicy,
  conflictHandler = _replicationProtocol.defaultConflictHandler
}) {
  var storageInstanceCreationParams = {
    databaseInstanceToken: database.token,
    databaseName: database.name,
    collectionName: name,
    schema: schema.jsonSchema,
    options: instanceCreationOptions,
    multiInstance: database.multiInstance,
    password: database.password,
    devMode: _overwritable$2.overwritable.isDevMode()
  };
  (0, _hooks$2.runPluginHooks)("preCreateRxStorageInstance", storageInstanceCreationParams);
  return (0, _rxCollectionHelper$1.createRxCollectionStorageInstance)(database, storageInstanceCreationParams).then((storageInstance) => {
    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options2, cacheReplacementPolicy, statics, conflictHandler);
    return collection.prepare().then(() => {
      Object.entries(statics).forEach(([funName, fun]) => {
        Object.defineProperty(collection, funName, {
          get: () => fun.bind(collection)
        });
      });
      var ret = _utils$6.PROMISE_RESOLVE_VOID;
      if (autoMigrate && collection.schema.version !== 0) {
        ret = collection.migratePromise();
      }
      return ret;
    }).then(() => {
      (0, _hooks$2.runPluginHooks)("createRxCollection", {
        collection,
        creator: {
          name,
          schema,
          storageInstance,
          instanceCreationOptions,
          migrationStrategies,
          methods,
          attachments,
          options: options2,
          cacheReplacementPolicy,
          localDocuments,
          statics
        }
      });
      return collection;
    }).catch((err) => {
      return storageInstance.close().then(() => Promise.reject(err));
    });
  });
}
function isRxCollection(obj) {
  return obj instanceof RxCollectionBase;
}
var rxDatabase = {};
var IdleQueue = function IdleQueue2() {
  var parallels = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
  this._parallels = parallels || 1;
  this._qC = 0;
  this._iC = /* @__PURE__ */ new Set();
  this._lHN = 0;
  this._hPM = /* @__PURE__ */ new Map();
  this._pHM = /* @__PURE__ */ new Map();
};
IdleQueue.prototype = {
  isIdle: function isIdle() {
    return this._qC < this._parallels;
  },
  /**
   * creates a lock in the queue
   * and returns an unlock-function to remove the lock from the queue
   * @return {function} unlock function than must be called afterwards
   */
  lock: function lock() {
    this._qC++;
  },
  unlock: function unlock() {
    this._qC--;
    _tryIdleCall(this);
  },
  /**
   * wraps a function with lock/unlock and runs it
   * @param  {function}  fun
   * @return {Promise<any>}
   */
  wrapCall: function wrapCall(fun) {
    var _this = this;
    this.lock();
    var maybePromise;
    try {
      maybePromise = fun();
    } catch (err) {
      this.unlock();
      throw err;
    }
    if (!maybePromise.then || typeof maybePromise.then !== "function") {
      this.unlock();
      return maybePromise;
    } else {
      return maybePromise.then(function(ret) {
        _this.unlock();
        return ret;
      })["catch"](function(err) {
        _this.unlock();
        throw err;
      });
    }
  },
  /**
   * does the same as requestIdleCallback() but uses promises instead of the callback
   * @param {{timeout?: number}} options like timeout
   * @return {Promise<void>} promise that resolves when the database is in idle-mode
   */
  requestIdlePromise: function requestIdlePromise2(options2) {
    var _this2 = this;
    options2 = options2 || {};
    var resolve;
    var prom = new Promise(function(res) {
      return resolve = res;
    });
    var resolveFromOutside = function resolveFromOutside2() {
      _removeIdlePromise(_this2, prom);
      resolve();
    };
    prom._manRes = resolveFromOutside;
    if (options2.timeout) {
      var timeoutObj = setTimeout(function() {
        prom._manRes();
      }, options2.timeout);
      prom._timeoutObj = timeoutObj;
    }
    this._iC.add(prom);
    _tryIdleCall(this);
    return prom;
  },
  /**
   * remove the promise so it will never be resolved
   * @param  {Promise} promise from requestIdlePromise()
   * @return {void}
   */
  cancelIdlePromise: function cancelIdlePromise(promise) {
    _removeIdlePromise(this, promise);
  },
  /**
   * api equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback
   * @param  {Function} callback
   * @param  {options}   options  [description]
   * @return {number} handle which can be used with cancelIdleCallback()
   */
  requestIdleCallback: function requestIdleCallback2(callback, options2) {
    var handle = this._lHN++;
    var promise = this.requestIdlePromise(options2);
    this._hPM.set(handle, promise);
    this._pHM.set(promise, handle);
    promise.then(function() {
      return callback();
    });
    return handle;
  },
  /**
   * API equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback
   * @param  {number} handle returned from requestIdleCallback()
   * @return {void}
   */
  cancelIdleCallback: function cancelIdleCallback(handle) {
    var promise = this._hPM.get(handle);
    this.cancelIdlePromise(promise);
  },
  /**
   * clears and resets everything
   * @return {void}
   */
  clear: function clear() {
    var _this3 = this;
    this._iC.forEach(function(promise) {
      return _removeIdlePromise(_this3, promise);
    });
    this._qC = 0;
    this._iC.clear();
    this._hPM = /* @__PURE__ */ new Map();
    this._pHM = /* @__PURE__ */ new Map();
  }
};
function _resolveOneIdleCall(idleQueue) {
  if (idleQueue._iC.size === 0)
    return;
  var iterator2 = idleQueue._iC.values();
  var oldestPromise = iterator2.next().value;
  oldestPromise._manRes();
  setTimeout(function() {
    return _tryIdleCall(idleQueue);
  }, 0);
}
function _removeIdlePromise(idleQueue, promise) {
  if (!promise)
    return;
  if (promise._timeoutObj)
    clearTimeout(promise._timeoutObj);
  if (idleQueue._pHM.has(promise)) {
    var handle = idleQueue._pHM.get(promise);
    idleQueue._hPM["delete"](handle);
    idleQueue._pHM["delete"](promise);
  }
  idleQueue._iC["delete"](promise);
}
function _tryIdleCall(idleQueue) {
  if (idleQueue._tryIR || idleQueue._iC.size === 0)
    return;
  idleQueue._tryIR = true;
  setTimeout(function() {
    if (!idleQueue.isIdle()) {
      idleQueue._tryIR = false;
      return;
    }
    setTimeout(function() {
      if (!idleQueue.isIdle()) {
        idleQueue._tryIR = false;
        return;
      }
      _resolveOneIdleCall(idleQueue);
      idleQueue._tryIR = false;
    }, 0);
  }, 0);
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IdleQueue
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(es);
var _interopRequireDefault$1 = interopRequireDefaultExports$1;
Object.defineProperty(rxDatabase, "__esModule", {
  value: true
});
rxDatabase.RxDatabaseBase = void 0;
rxDatabase.createRxDatabase = createRxDatabase;
rxDatabase.createRxDatabaseStorageInstance = createRxDatabaseStorageInstance;
rxDatabase.dbCount = dbCount;
rxDatabase.ensureNoStartupErrors = ensureNoStartupErrors;
rxDatabase.isRxDatabase = isRxDatabase;
rxDatabase.isRxDatabaseFirstTimeInstantiated = isRxDatabaseFirstTimeInstantiated;
rxDatabase.removeRxDatabase = removeRxDatabase;
var _createClass2 = _interopRequireDefault$1(requireCreateClass());
var _customIdleQueue = require$$2;
var _utils$5 = utils;
var _rxError$8 = rxError;
var _rxSchema$2 = rxSchema;
var _hooks$1 = hooks;
var _rxjs$1 = cjs;
var _operators$1 = operators;
var _rxCollection$2 = rxCollection;
var _rxStorageHelper = rxStorageHelper;
var _obliviousSet = require$$11;
var _rxDatabaseInternalStore = rxDatabaseInternalStore;
var _rxCollectionHelper = rxCollectionHelper;
var _overwritable$1 = overwritable$1;
var USED_DATABASE_NAMES = /* @__PURE__ */ new Set();
var DB_COUNT = 0;
var RxDatabaseBase = /* @__PURE__ */ function() {
  function RxDatabaseBase2(name, token, storage, instanceCreationOptions, password, multiInstance, eventReduce2 = false, options2 = {}, internalStore, hashFunction, cleanupPolicy, allowSlowCount) {
    this.idleQueue = new _customIdleQueue.IdleQueue();
    this.storageInstances = /* @__PURE__ */ new Set();
    this._subs = [];
    this.startupErrors = [];
    this.onDestroy = [];
    this.destroyed = false;
    this.collections = {};
    this.eventBulks$ = new _rxjs$1.Subject();
    this.observable$ = this.eventBulks$.pipe((0, _operators$1.mergeMap)((changeEventBulk) => changeEventBulk.events));
    this.storageToken = _utils$5.PROMISE_RESOLVE_FALSE;
    this.storageTokenDocument = _utils$5.PROMISE_RESOLVE_FALSE;
    this.emittedEventBulkIds = new _obliviousSet.ObliviousSet(60 * 1e3);
    this.name = name;
    this.token = token;
    this.storage = storage;
    this.instanceCreationOptions = instanceCreationOptions;
    this.password = password;
    this.multiInstance = multiInstance;
    this.eventReduce = eventReduce2;
    this.options = options2;
    this.internalStore = internalStore;
    this.hashFunction = hashFunction;
    this.cleanupPolicy = cleanupPolicy;
    this.allowSlowCount = allowSlowCount;
    DB_COUNT++;
    if (this.name !== "pseudoInstance") {
      this.internalStore = (0, _rxStorageHelper.getWrappedStorageInstance)(this.asRxDatabase, internalStore, _rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA);
      this.storageTokenDocument = (0, _rxDatabaseInternalStore.ensureStorageTokenDocumentExists)(this.asRxDatabase).catch((err) => this.startupErrors.push(err));
      this.storageToken = this.storageTokenDocument.then((doc) => doc.data.token).catch((err) => this.startupErrors.push(err));
    }
  }
  var _proto = RxDatabaseBase2.prototype;
  _proto.$emit = function $emit(changeEventBulk) {
    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {
      return;
    }
    this.emittedEventBulkIds.add(changeEventBulk.id);
    this.eventBulks$.next(changeEventBulk);
  };
  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {
    var doc = await (0, _rxStorageHelper.getSingleDocument)(this.internalStore, (0, _rxDatabaseInternalStore.getPrimaryKeyOfInternalDocument)((0, _rxDatabaseInternalStore._collectionNamePrimary)(name, schema), _rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION));
    if (!doc) {
      throw (0, _rxError$8.newRxError)("SNH", {
        name,
        schema
      });
    }
    var writeDoc = (0, _rxStorageHelper.flatCloneDocWithMeta)(doc);
    writeDoc._deleted = true;
    await this.internalStore.bulkWrite([{
      document: writeDoc,
      previous: doc
    }], "rx-database-remove-collection");
  };
  _proto.addCollections = async function addCollections(collectionCreators) {
    var jsonSchemas = {};
    var schemas = {};
    var bulkPutDocs = [];
    var useArgsByCollectionName = {};
    Object.entries(collectionCreators).forEach(([name, args2]) => {
      var collectionName = name;
      var rxJsonSchema = args2.schema;
      jsonSchemas[collectionName] = rxJsonSchema;
      var schema = (0, _rxSchema$2.createRxSchema)(rxJsonSchema, this.hashFunction);
      schemas[collectionName] = schema;
      if (this.collections[name]) {
        throw (0, _rxError$8.newRxError)("DB3", {
          name
        });
      }
      var collectionNameWithVersion = (0, _rxDatabaseInternalStore._collectionNamePrimary)(name, rxJsonSchema);
      var collectionDocData = {
        id: (0, _rxDatabaseInternalStore.getPrimaryKeyOfInternalDocument)(collectionNameWithVersion, _rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION),
        key: collectionNameWithVersion,
        context: _rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION,
        data: {
          name: collectionName,
          schemaHash: schema.hash,
          schema: schema.jsonSchema,
          version: schema.version,
          connectedStorages: []
        },
        _deleted: false,
        _meta: (0, _utils$5.getDefaultRxDocumentMeta)(),
        _rev: (0, _utils$5.getDefaultRevision)(),
        _attachments: {}
      };
      bulkPutDocs.push({
        document: collectionDocData
      });
      var useArgs = Object.assign({}, args2, {
        name: collectionName,
        schema,
        database: this
      });
      var hookData = (0, _utils$5.flatClone)(args2);
      hookData.database = this;
      hookData.name = name;
      (0, _hooks$1.runPluginHooks)("preCreateRxCollection", hookData);
      useArgs.conflictHandler = hookData.conflictHandler;
      useArgsByCollectionName[collectionName] = useArgs;
    });
    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, "rx-database-add-collection");
    await ensureNoStartupErrors(this);
    Object.entries(putDocsResult.error).forEach(([_id, error]) => {
      if (error.status !== 409) {
        throw (0, _rxError$8.newRxError)("DB12", {
          database: this.name,
          writeError: error
        });
      }
      var docInDb = (0, _utils$5.ensureNotFalsy)(error.documentInDb);
      var collectionName = docInDb.data.name;
      var schema = schemas[collectionName];
      if (docInDb.data.schemaHash !== schema.hash) {
        throw (0, _rxError$8.newRxError)("DB6", {
          database: this.name,
          collection: collectionName,
          previousSchemaHash: docInDb.data.schemaHash,
          schemaHash: schema.hash,
          previousSchema: docInDb.data.schema,
          schema: (0, _utils$5.ensureNotFalsy)(jsonSchemas[collectionName])
        });
      }
    });
    var ret = {};
    await Promise.all(Object.keys(collectionCreators).map(async (collectionName) => {
      var useArgs = useArgsByCollectionName[collectionName];
      var collection = await (0, _rxCollection$2.createRxCollection)(useArgs);
      ret[collectionName] = collection;
      this.collections[collectionName] = collection;
      if (!this[collectionName]) {
        Object.defineProperty(this, collectionName, {
          get: () => this.collections[collectionName]
        });
      }
    }));
    return ret;
  };
  _proto.lockedRun = function lockedRun(fn) {
    return this.idleQueue.wrapCall(fn);
  };
  _proto.requestIdlePromise = function requestIdlePromise3() {
    return this.idleQueue.requestIdlePromise();
  };
  _proto.exportJSON = function exportJSON(_collections) {
    throw (0, _utils$5.pluginMissing)("json-dump");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw (0, _utils$5.pluginMissing)("json-dump");
  };
  _proto.backup = function backup(_options2) {
    throw (0, _utils$5.pluginMissing)("backup");
  };
  _proto.leaderElector = function leaderElector() {
    throw (0, _utils$5.pluginMissing)("leader-election");
  };
  _proto.isLeader = function isLeader() {
    throw (0, _utils$5.pluginMissing)("leader-election");
  };
  _proto.waitForLeadership = function waitForLeadership() {
    throw (0, _utils$5.pluginMissing)("leader-election");
  };
  _proto.migrationStates = function migrationStates() {
    throw (0, _utils$5.pluginMissing)("migration");
  };
  _proto.destroy = async function destroy() {
    if (this.destroyed) {
      return _utils$5.PROMISE_RESOLVE_FALSE;
    }
    this.destroyed = true;
    await (0, _hooks$1.runAsyncPluginHooks)("preDestroyRxDatabase", this);
    this.eventBulks$.complete();
    DB_COUNT--;
    this._subs.map((sub) => sub.unsubscribe());
    if (this.name === "pseudoInstance") {
      return _utils$5.PROMISE_RESOLVE_FALSE;
    }
    return this.requestIdlePromise().then(() => Promise.all(this.onDestroy.map((fn) => fn()))).then(() => Promise.all(Object.keys(this.collections).map((key) => this.collections[key]).map((col) => col.destroy()))).then(() => this.internalStore.close()).then(() => USED_DATABASE_NAMES.delete(this.name)).then(() => true);
  };
  _proto.remove = function remove() {
    return this.destroy().then(() => removeRxDatabase(this.name, this.storage));
  };
  (0, _createClass2.default)(RxDatabaseBase2, [{
    key: "$",
    get: function() {
      return this.observable$;
    }
    /**
     * Because having unhandled exceptions would fail,
     * we have to store the async errors of the constructor here
     * so we can throw them later.
     */
    /**
     * When the database is destroyed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
     */
    /**
     * Unique token that is stored with the data.
     * Used to detect if the dataset has been deleted
     * and if two RxDatabase instances work on the same dataset or not.
     *
     * Because reading and writing the storageToken runs in the hot path
     * of database creation, we do not await the storageWrites but instead
     * work with the promise when we need the value.
     */
    /**
     * Stores the whole state of the internal storage token document.
     * We need this in some plugins.
     */
    /**
     * Contains the ids of all event bulks that have been emitted
     * by the database.
     * Used to detect duplicates that come in again via BroadcastChannel
     * or other streams.
     * TODO instead of having this here, we should add a test to ensure each RxStorage
     * behaves equal and does never emit duplicate eventBulks.
     */
  }, {
    key: "asRxDatabase",
    get: function() {
      return this;
    }
  }]);
  return RxDatabaseBase2;
}();
rxDatabase.RxDatabaseBase = RxDatabaseBase;
function throwIfDatabaseNameUsed(name) {
  if (!USED_DATABASE_NAMES.has(name)) {
    return;
  } else {
    throw (0, _rxError$8.newRxError)("DB8", {
      name,
      link: "https://pubkey.github.io/rxdb/rx-database.html#ignoreduplicate"
    });
  }
}
async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options2, multiInstance, password) {
  var internalStore = await storage.createStorageInstance({
    databaseInstanceToken,
    databaseName,
    collectionName: _rxStorageHelper.INTERNAL_STORAGE_NAME,
    schema: _rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA,
    options: options2,
    multiInstance,
    password,
    devMode: _overwritable$1.overwritable.isDevMode()
  });
  return internalStore;
}
function createRxDatabase({
  storage,
  instanceCreationOptions,
  name,
  password,
  multiInstance = true,
  eventReduce: eventReduce2 = false,
  ignoreDuplicate = false,
  options: options2 = {},
  cleanupPolicy,
  allowSlowCount = false,
  localDocuments = false,
  hashFunction = _utils$5.defaultHashSha256
}) {
  (0, _hooks$1.runPluginHooks)("preCreateRxDatabase", {
    storage,
    instanceCreationOptions,
    name,
    password,
    multiInstance,
    eventReduce: eventReduce2,
    ignoreDuplicate,
    options: options2,
    localDocuments
  });
  if (!ignoreDuplicate) {
    throwIfDatabaseNameUsed(name);
  }
  USED_DATABASE_NAMES.add(name);
  var databaseInstanceToken = (0, _utils$5.randomCouchString)(10);
  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password).catch((err) => {
    USED_DATABASE_NAMES.delete(name);
    throw err;
  }).then((storageInstance) => {
    var rxDatabase2 = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce2, options2, storageInstance, hashFunction, cleanupPolicy, allowSlowCount);
    return (0, _hooks$1.runAsyncPluginHooks)("createRxDatabase", {
      database: rxDatabase2,
      creator: {
        storage,
        instanceCreationOptions,
        name,
        password,
        multiInstance,
        eventReduce: eventReduce2,
        ignoreDuplicate,
        options: options2,
        localDocuments
      }
    }).then(() => rxDatabase2);
  });
}
async function removeRxDatabase(databaseName, storage) {
  var databaseInstanceToken = (0, _utils$5.randomCouchString)(10);
  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, false);
  var collectionDocs = await (0, _rxDatabaseInternalStore.getAllCollectionDocuments)(storage.statics, dbInternalsStorageInstance);
  var collectionNames = /* @__PURE__ */ new Set();
  collectionDocs.forEach((doc) => collectionNames.add(doc.data.name));
  var removedCollectionNames = Array.from(collectionNames);
  await Promise.all(removedCollectionNames.map((collectionName) => (0, _rxCollectionHelper.removeCollectionStorages)(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName)));
  await (0, _hooks$1.runAsyncPluginHooks)("postRemoveRxDatabase", {
    databaseName,
    storage
  });
  await dbInternalsStorageInstance.remove();
  return removedCollectionNames;
}
function isRxDatabase(obj) {
  return obj instanceof RxDatabaseBase;
}
function dbCount() {
  return DB_COUNT;
}
async function isRxDatabaseFirstTimeInstantiated(database) {
  var tokenDoc = await database.storageTokenDocument;
  return tokenDoc.data.instanceToken === database.token;
}
async function ensureNoStartupErrors(rxDatabase2) {
  await rxDatabase2.storageToken;
  if (rxDatabase2.startupErrors[0]) {
    throw rxDatabase2.startupErrors[0];
  }
}
Object.defineProperty(plugin, "__esModule", {
  value: true
});
plugin.addRxPlugin = addRxPlugin;
var _rxSchema$1 = rxSchema;
var _rxDocument$1 = rxDocument;
var _rxQuery = rxQuery;
var _rxCollection$1 = rxCollection;
var _rxDatabase$1 = rxDatabase;
var _overwritable = overwritable$1;
var _hooks = hooks;
var _rxError$7 = rxError;
var PROTOTYPES = {
  RxSchema: _rxSchema$1.RxSchema.prototype,
  RxDocument: _rxDocument$1.basePrototype,
  RxQuery: _rxQuery.RxQueryBase.prototype,
  RxCollection: _rxCollection$1.RxCollectionBase.prototype,
  RxDatabase: _rxDatabase$1.RxDatabaseBase.prototype
};
var ADDED_PLUGINS = /* @__PURE__ */ new Set();
var ADDED_PLUGIN_NAMES = /* @__PURE__ */ new Set();
function addRxPlugin(plugin2) {
  (0, _hooks.runPluginHooks)("preAddRxPlugin", {
    plugin: plugin2,
    plugins: ADDED_PLUGINS
  });
  if (ADDED_PLUGINS.has(plugin2)) {
    return;
  } else {
    if (ADDED_PLUGIN_NAMES.has(plugin2.name)) {
      throw (0, _rxError$7.newRxError)("PL3", {
        name: plugin2.name,
        plugin: plugin2
      });
    }
    ADDED_PLUGINS.add(plugin2);
    ADDED_PLUGIN_NAMES.add(plugin2.name);
  }
  if (!plugin2.rxdb) {
    throw (0, _rxError$7.newRxTypeError)("PL1", {
      plugin: plugin2
    });
  }
  if (plugin2.init) {
    plugin2.init();
  }
  if (plugin2.prototypes) {
    Object.entries(plugin2.prototypes).forEach(([name, fun]) => {
      return fun(PROTOTYPES[name]);
    });
  }
  if (plugin2.overwritable) {
    Object.assign(_overwritable.overwritable, plugin2.overwritable);
  }
  if (plugin2.hooks) {
    Object.entries(plugin2.hooks).forEach(([name, hooksObj]) => {
      if (hooksObj.after) {
        _hooks.HOOKS[name].push(hooksObj.after);
      }
      if (hooksObj.before) {
        _hooks.HOOKS[name].unshift(hooksObj.before);
      }
    });
  }
}
var customIndex = {};
Object.defineProperty(customIndex, "__esModule", {
  value: true
});
customIndex.getIndexMeta = getIndexMeta;
customIndex.getIndexStringLength = getIndexStringLength;
customIndex.getIndexableStringMonad = getIndexableStringMonad;
customIndex.getNumberIndexString = getNumberIndexString;
customIndex.getPrimaryKeyFromIndexableString = getPrimaryKeyFromIndexableString;
customIndex.getStartIndexStringFromLowerBound = getStartIndexStringFromLowerBound;
customIndex.getStartIndexStringFromUpperBound = getStartIndexStringFromUpperBound;
customIndex.getStringLengthOfIndexNumber = getStringLengthOfIndexNumber;
var _rxSchemaHelper$2 = rxSchemaHelper;
var _utils$4 = utils;
var _queryPlanner = queryPlanner;
function getIndexMeta(schema, index) {
  var fieldNameProperties = index.map((fieldName) => {
    var schemaPart = (0, _rxSchemaHelper$2.getSchemaByObjectPath)(schema, fieldName);
    if (!schemaPart) {
      throw new Error("not in schema: " + fieldName);
    }
    var type2 = schemaPart.type;
    var parsedLengths;
    if (type2 === "number" || type2 === "integer") {
      parsedLengths = getStringLengthOfIndexNumber(schemaPart);
    }
    var getValue = (0, _utils$4.objectPathMonad)(fieldName);
    var maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;
    var getIndexStringPart;
    if (type2 === "string") {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        if (!fieldValue) {
          fieldValue = "";
        }
        return fieldValue.padEnd(maxLength, " ");
      };
    } else if (type2 === "boolean") {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        return fieldValue ? "1" : "0";
      };
    } else {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        return getNumberIndexString(parsedLengths, fieldValue);
      };
    }
    var ret = {
      fieldName,
      schemaPart,
      parsedLengths,
      getValue,
      getIndexStringPart
    };
    return ret;
  });
  return fieldNameProperties;
}
function getIndexableStringMonad(schema, index) {
  var fieldNameProperties = getIndexMeta(schema, index);
  var fieldNamePropertiesAmount = fieldNameProperties.length;
  var indexPartsFunctions = fieldNameProperties.map((r) => r.getIndexStringPart);
  var ret = function(docData) {
    var str = "";
    for (var i = 0; i < fieldNamePropertiesAmount; ++i) {
      str += indexPartsFunctions[i](docData);
    }
    return str;
  };
  return ret;
}
function getStringLengthOfIndexNumber(schemaPart) {
  var minimum = Math.floor(schemaPart.minimum);
  var maximum = Math.ceil(schemaPart.maximum);
  var multipleOf = schemaPart.multipleOf;
  var valueSpan = maximum - minimum;
  var nonDecimals = valueSpan.toString().length;
  var multipleOfParts = multipleOf.toString().split(".");
  var decimals = 0;
  if (multipleOfParts.length > 1) {
    decimals = multipleOfParts[1].length;
  }
  return {
    minimum,
    maximum,
    nonDecimals,
    decimals,
    roundedMinimum: minimum
  };
}
function getIndexStringLength(schema, index) {
  var fieldNameProperties = getIndexMeta(schema, index);
  var length = 0;
  fieldNameProperties.forEach((props2) => {
    var schemaPart = props2.schemaPart;
    var type2 = schemaPart.type;
    if (type2 === "string") {
      length += schemaPart.maxLength;
    } else if (type2 === "boolean") {
      length += 1;
    } else {
      var parsedLengths = props2.parsedLengths;
      length = length + parsedLengths.nonDecimals + parsedLengths.decimals;
    }
  });
  return length;
}
function getPrimaryKeyFromIndexableString(indexableString, primaryKeyLength) {
  var paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);
  var primaryKey = paddedPrimaryKey.trim();
  return primaryKey;
}
function getNumberIndexString(parsedLengths, fieldValue) {
  if (typeof fieldValue === "undefined") {
    fieldValue = 0;
  }
  if (fieldValue < parsedLengths.minimum) {
    fieldValue = parsedLengths.minimum;
  }
  if (fieldValue > parsedLengths.maximum) {
    fieldValue = parsedLengths.maximum;
  }
  var nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();
  var str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, "0");
  if (parsedLengths.decimals > 0) {
    var splitByDecimalPoint = fieldValue.toString().split(".");
    var decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : "0";
    str += decimalValueAsString.padEnd(parsedLengths.decimals, "0");
  }
  return str;
}
function getStartIndexStringFromLowerBound(schema, index, lowerBound2, inclusiveStart) {
  var str = "";
  index.forEach((fieldName, idx) => {
    var schemaPart = (0, _rxSchemaHelper$2.getSchemaByObjectPath)(schema, fieldName);
    var bound = lowerBound2[idx];
    var type2 = schemaPart.type;
    switch (type2) {
      case "string":
        var maxLength = (0, _utils$4.ensureNotFalsy)(schemaPart.maxLength);
        if (typeof bound === "string") {
          str += bound.padEnd(maxLength, " ");
        } else {
          str += "".padEnd(maxLength, " ");
        }
        break;
      case "boolean":
        if (bound === null) {
          str += inclusiveStart ? "0" : _queryPlanner.INDEX_MAX;
        } else {
          var boolToStr = bound ? "1" : "0";
          str += boolToStr;
        }
        break;
      case "number":
      case "integer":
        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);
        if (bound === null || bound === _queryPlanner.INDEX_MIN) {
          var fillChar = inclusiveStart ? "0" : _queryPlanner.INDEX_MAX;
          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else {
          str += getNumberIndexString(parsedLengths, bound);
        }
        break;
      default:
        throw new Error("unknown index type " + type2);
    }
  });
  return str;
}
function getStartIndexStringFromUpperBound(schema, index, upperBound, inclusiveEnd) {
  var str = "";
  index.forEach((fieldName, idx) => {
    var schemaPart = (0, _rxSchemaHelper$2.getSchemaByObjectPath)(schema, fieldName);
    var bound = upperBound[idx];
    var type2 = schemaPart.type;
    switch (type2) {
      case "string":
        var maxLength = (0, _utils$4.ensureNotFalsy)(schemaPart.maxLength);
        if (typeof bound === "string" && bound !== _queryPlanner.INDEX_MAX) {
          str += bound.padEnd(maxLength, " ");
        } else {
          str += "".padEnd(maxLength, inclusiveEnd ? _queryPlanner.INDEX_MAX : " ");
        }
        break;
      case "boolean":
        if (bound === null) {
          str += inclusiveEnd ? "0" : "1";
        } else {
          var boolToStr = bound ? "1" : "0";
          str += boolToStr;
        }
        break;
      case "number":
      case "integer":
        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);
        if (bound === null || bound === _queryPlanner.INDEX_MAX) {
          var fillChar = inclusiveEnd ? "9" : "0";
          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else {
          str += getNumberIndexString(parsedLengths, bound);
        }
        break;
      default:
        throw new Error("unknown index type " + type2);
    }
  });
  return str;
}
var pluginHelpers = {};
Object.defineProperty(pluginHelpers, "__esModule", {
  value: true
});
pluginHelpers.wrapRxStorageInstance = wrapRxStorageInstance;
pluginHelpers.wrappedValidateStorageFactory = wrappedValidateStorageFactory;
var _operators = operators;
var _rxSchemaHelper$1 = rxSchemaHelper;
var _utils$3 = utils;
var _rxjs = cjs;
var VALIDATOR_CACHE_BY_VALIDATOR_KEY = /* @__PURE__ */ new Map();
function wrappedValidateStorageFactory(getValidator, validatorKey) {
  var VALIDATOR_CACHE = (0, _utils$3.getFromMapOrCreate)(VALIDATOR_CACHE_BY_VALIDATOR_KEY, validatorKey, () => /* @__PURE__ */ new Map());
  function initValidator(schema) {
    var hash2 = (0, _utils$3.defaultHashSha256)(JSON.stringify(schema));
    return (0, _utils$3.getFromMapOrCreate)(VALIDATOR_CACHE, hash2, () => getValidator(schema));
  }
  return (args2) => {
    return Object.assign({}, args2.storage, {
      async createStorageInstance(params) {
        var instance = await args2.storage.createStorageInstance(params);
        var primaryPath = (0, _rxSchemaHelper$1.getPrimaryFieldOfPrimaryKey)(params.schema.primaryKey);
        var validatorCached;
        (0, _utils$3.requestIdleCallbackIfAvailable)(() => validatorCached = initValidator(params.schema));
        var oldBulkWrite = instance.bulkWrite.bind(instance);
        instance.bulkWrite = (documentWrites, context2) => {
          if (!validatorCached) {
            validatorCached = initValidator(params.schema);
          }
          var errors = [];
          var continueWrites = [];
          documentWrites.forEach((row) => {
            var documentId = row.document[primaryPath];
            var validationErrors = validatorCached(row.document);
            if (validationErrors.length > 0) {
              errors.push({
                status: 422,
                isError: true,
                documentId,
                writeRow: row,
                validationErrors
              });
            } else {
              continueWrites.push(row);
            }
          });
          var writePromise = continueWrites.length > 0 ? oldBulkWrite(continueWrites, context2) : Promise.resolve({
            error: {},
            success: {}
          });
          return writePromise.then((writeResult) => {
            errors.forEach((validationError) => {
              writeResult.error[validationError.documentId] = validationError;
            });
            return writeResult;
          });
        };
        return instance;
      }
    });
  };
}
function wrapRxStorageInstance(instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage = (v) => v) {
  async function toStorage(docData) {
    if (!docData) {
      return docData;
    }
    return await modifyToStorage(docData);
  }
  async function fromStorage(docData) {
    if (!docData) {
      return docData;
    }
    return await modifyFromStorage(docData);
  }
  async function errorFromStorage(error) {
    var ret = (0, _utils$3.flatClone)(error);
    ret.writeRow = (0, _utils$3.flatClone)(ret.writeRow);
    if (ret.documentInDb) {
      ret.documentInDb = await fromStorage(ret.documentInDb);
    }
    if (ret.writeRow.previous) {
      ret.writeRow.previous = await fromStorage(ret.writeRow.previous);
    }
    ret.writeRow.document = await fromStorage(ret.writeRow.document);
    return ret;
  }
  var processingChangesCount$ = new _rxjs.BehaviorSubject(0);
  var wrappedInstance = {
    databaseName: instance.databaseName,
    internals: instance.internals,
    cleanup: instance.cleanup.bind(instance),
    options: instance.options,
    close: instance.close.bind(instance),
    schema: instance.schema,
    collectionName: instance.collectionName,
    count: instance.count.bind(instance),
    remove: instance.remove.bind(instance),
    originalStorageInstance: instance,
    bulkWrite: async (documentWrites, context2) => {
      var useRows = [];
      await Promise.all(documentWrites.map(async (row) => {
        var [previous, document2] = await Promise.all([row.previous ? toStorage(row.previous) : void 0, toStorage(row.document)]);
        useRows.push({
          previous,
          document: document2
        });
      }));
      var writeResult = await instance.bulkWrite(useRows, context2);
      var ret = {
        success: {},
        error: {}
      };
      var promises = [];
      Object.entries(writeResult.success).forEach(([k, v]) => {
        promises.push(fromStorage(v).then((v2) => ret.success[k] = v2));
      });
      Object.entries(writeResult.error).forEach(([k, error]) => {
        promises.push(errorFromStorage(error).then((err) => ret.error[k] = err));
      });
      await Promise.all(promises);
      await (0, _rxjs.firstValueFrom)(processingChangesCount$.pipe((0, _operators.filter)((v) => v === 0)));
      return ret;
    },
    query: (preparedQuery) => {
      return instance.query(preparedQuery).then((queryResult) => {
        return Promise.all(queryResult.documents.map((doc) => fromStorage(doc)));
      }).then((documents) => ({
        documents
      }));
    },
    getAttachmentData: async (documentId, attachmentId, digest) => {
      var data = await instance.getAttachmentData(documentId, attachmentId, digest);
      data = await modifyAttachmentFromStorage(data);
      return data;
    },
    findDocumentsById: (ids, deleted) => {
      return instance.findDocumentsById(ids, deleted).then(async (findResult) => {
        var ret = {};
        await Promise.all(Object.entries(findResult).map(async ([key, doc]) => {
          ret[key] = await fromStorage(doc);
        }));
        return ret;
      });
    },
    getChangedDocumentsSince: (limit2, checkpoint2) => {
      return instance.getChangedDocumentsSince(limit2, checkpoint2).then(async (result) => {
        return {
          checkpoint: result.checkpoint,
          documents: await Promise.all(result.documents.map((d) => fromStorage(d)))
        };
      });
    },
    changeStream: () => {
      return instance.changeStream().pipe((0, _operators.tap)(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)), (0, _operators.mergeMap)(async (eventBulk) => {
        var useEvents = await Promise.all(eventBulk.events.map(async (event) => {
          var [documentData, previousDocumentData] = await Promise.all([fromStorage(event.documentData), fromStorage(event.previousDocumentData)]);
          var ev = {
            operation: event.operation,
            eventId: event.eventId,
            documentId: event.documentId,
            endTime: event.endTime,
            startTime: event.startTime,
            documentData,
            previousDocumentData,
            isLocal: false
          };
          return ev;
        }));
        var ret = {
          id: eventBulk.id,
          events: useEvents,
          checkpoint: eventBulk.checkpoint,
          context: eventBulk.context
        };
        return ret;
      }), (0, _operators.tap)(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1)));
    },
    conflictResultionTasks: () => {
      return instance.conflictResultionTasks().pipe((0, _operators.mergeMap)(async (task2) => {
        var assumedMasterState = await fromStorage(task2.input.assumedMasterState);
        var newDocumentState = await fromStorage(task2.input.newDocumentState);
        var realMasterState = await fromStorage(task2.input.realMasterState);
        return {
          id: task2.id,
          context: task2.context,
          input: {
            assumedMasterState,
            realMasterState,
            newDocumentState
          }
        };
      }));
    },
    resolveConflictResultionTask: (taskSolution) => {
      if (taskSolution.output.isEqual) {
        return instance.resolveConflictResultionTask(taskSolution);
      }
      var useSolution = {
        id: taskSolution.id,
        output: {
          isEqual: false,
          documentData: taskSolution.output.documentData
        }
      };
      return instance.resolveConflictResultionTask(useSolution);
    }
  };
  return wrappedInstance;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    addRxPlugin: true
  };
  Object.defineProperty(exports, "addRxPlugin", {
    enumerable: true,
    get: function() {
      return _plugin.addRxPlugin;
    }
  });
  var _plugin = plugin;
  var _rxDatabase2 = rxDatabase;
  Object.keys(_rxDatabase2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxDatabase2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxDatabase2[key];
      }
    });
  });
  var _rxError2 = rxError;
  Object.keys(_rxError2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxError2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxError2[key];
      }
    });
  });
  var _rxDatabaseInternalStore2 = rxDatabaseInternalStore;
  Object.keys(_rxDatabaseInternalStore2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxDatabaseInternalStore2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxDatabaseInternalStore2[key];
      }
    });
  });
  var _overwritable2 = overwritable$1;
  Object.keys(_overwritable2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _overwritable2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _overwritable2[key];
      }
    });
  });
  var _rxCollection2 = rxCollection;
  Object.keys(_rxCollection2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxCollection2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxCollection2[key];
      }
    });
  });
  var _rxCollectionHelper2 = rxCollectionHelper;
  Object.keys(_rxCollectionHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxCollectionHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxCollectionHelper2[key];
      }
    });
  });
  var _rxDocument2 = rxDocument;
  Object.keys(_rxDocument2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxDocument2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxDocument2[key];
      }
    });
  });
  var _rxChangeEvent2 = rxChangeEvent;
  Object.keys(_rxChangeEvent2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxChangeEvent2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxChangeEvent2[key];
      }
    });
  });
  var _rxDocumentPrototypeMerge2 = rxDocumentPrototypeMerge;
  Object.keys(_rxDocumentPrototypeMerge2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxDocumentPrototypeMerge2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxDocumentPrototypeMerge2[key];
      }
    });
  });
  var _rxQuery2 = rxQuery;
  Object.keys(_rxQuery2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxQuery2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxQuery2[key];
      }
    });
  });
  var _rxQueryHelper2 = rxQueryHelper;
  Object.keys(_rxQueryHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxQueryHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxQueryHelper2[key];
      }
    });
  });
  var _rxSchema2 = rxSchema;
  Object.keys(_rxSchema2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxSchema2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxSchema2[key];
      }
    });
  });
  var _rxSchemaHelper2 = rxSchemaHelper;
  Object.keys(_rxSchemaHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxSchemaHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxSchemaHelper2[key];
      }
    });
  });
  var _rxStorageHelper2 = rxStorageHelper;
  Object.keys(_rxStorageHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxStorageHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageHelper2[key];
      }
    });
  });
  var _rxStorageStatics2 = rxStorageStatics;
  Object.keys(_rxStorageStatics2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxStorageStatics2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageStatics2[key];
      }
    });
  });
  var _index = replicationProtocol;
  Object.keys(_index).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index[key];
      }
    });
  });
  var _rxStorageMultiinstance2 = rxStorageMultiinstance;
  Object.keys(_rxStorageMultiinstance2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxStorageMultiinstance2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageMultiinstance2[key];
      }
    });
  });
  var _customIndex = customIndex;
  Object.keys(_customIndex).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _customIndex[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _customIndex[key];
      }
    });
  });
  var _queryPlanner2 = queryPlanner;
  Object.keys(_queryPlanner2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _queryPlanner2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _queryPlanner2[key];
      }
    });
  });
  var _pluginHelpers = pluginHelpers;
  Object.keys(_pluginHelpers).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _pluginHelpers[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _pluginHelpers[key];
      }
    });
  });
  var _utils2 = utils;
  Object.keys(_utils2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _utils2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utils2[key];
      }
    });
  });
  var _hooks2 = hooks;
  Object.keys(_hooks2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _hooks2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _hooks2[key];
      }
    });
  });
  var _queryCache2 = queryCache;
  Object.keys(_queryCache2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _queryCache2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _queryCache2[key];
      }
    });
  });
})(lib$2);
const cartSchema = {
  title: "cart schema",
  description: "describes shopping cart",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    items: [
      {
        name: {
          type: "string"
        },
        image: {
          type: "string"
        },
        quantity: {
          type: "number"
        },
        unitPrice: {
          type: "number"
        }
      }
    ],
    timestamp: {
      type: "date-time"
    }
  },
  required: ["id", "items", "timestamp"]
};
var devMode = {};
var errorMessages = {};
Object.defineProperty(errorMessages, "__esModule", {
  value: true
});
errorMessages.ERROR_MESSAGES = void 0;
var ERROR_MESSAGES = {
  // util.js / config
  UT1: "given name is no string or empty",
  UT2: "collection- and database-names must match the regex to be compatible with couchdb databases.\n    See https://neighbourhood.ie/blog/2020/10/13/everything-you-need-to-know-about-couchdb-database-names/\n    info: if your database-name specifies a folder, the name must contain the slash-char '/' or '\\'",
  UT3: "replication-direction must either be push or pull or both. But not none",
  UT4: "given leveldown is no valid adapter",
  UT5: "keyCompression is set to true in the schema but no key-compression handler is used in the storage",
  UT6: "schema contains encrypted fields but no encryption handler is used in the storage",
  UT7: "attachments.compression is enabled but no attachment-compression plugin is used",
  // plugins
  PL1: "Given plugin is not RxDB plugin.",
  // removed in 14.0.0 - PouchDB RxStorage was removed - PL2: 'You tried importing a RxDB plugin to pouchdb. Use addRxPlugin() instead.',
  PL3: "A plugin with the same name was already added but it was not the exact same JavaScript object",
  // pouch-db.js
  // removed in 12.0.0 - P1: 'PouchDB.getBatch: limit must be > 2',
  P2: "bulkWrite() cannot be called with an empty array",
  // removed in 12.0.0 - P3: 'bulkAddRevisions cannot be called with an empty array',
  // rx-query
  QU1: "RxQuery._execOverDatabase(): op not known",
  // removed in 9.0.0 - QU2: 'limit() must get a number',
  // removed in 9.0.0 - QU3: 'skip() must get a number',
  QU4: "RxQuery.regex(): You cannot use .regex() on the primary field",
  QU5: "RxQuery.sort(): does not work because key is not defined in the schema",
  QU6: "RxQuery.limit(): cannot be called on .findOne()",
  // removed in 12.0.0 (should by ensured by the typings) - QU7: 'query must be an object',
  // removed in 12.0.0 (should by ensured by the typings) - QU8: 'query cannot be an array',
  QU9: "throwIfMissing can only be used in findOne queries",
  QU10: "result empty and throwIfMissing: true",
  QU11: "RxQuery: no valid query params given",
  QU12: "Given index is not in schema",
  QU13: "A top level field of the query is not included in the schema",
  QU14: "Running a count() query in slow mode is now allowed. Either run a count() query with a selector that fully matches an index or set allowSlowCount=true when calling the createRxDatabase",
  QU15: "For count queries it is not allowed to use skip or limit",
  // mquery.js
  MQ1: "path must be a string or object",
  MQ2: "Invalid argument",
  MQ3: "Invalid sort() argument. Must be a string, object, or array",
  MQ4: "Invalid argument. Expected instanceof mquery or plain object",
  MQ5: "method must be used after where() when called with these arguments",
  MQ6: "Can't mix sort syntaxes. Use either array or object | .sort([['field', 1], ['test', -1]]) | .sort({ field: 1, test: -1 })",
  MQ7: "Invalid sort value",
  MQ8: "Can't mix sort syntaxes. Use either array or object",
  // rx-database
  DB1: "RxDocument.prepare(): another instance on this adapter has a different password",
  DB2: "RxDatabase.addCollections(): collection-names cannot start with underscore _",
  DB3: "RxDatabase.addCollections(): collection already exists. use myDatabase.[collectionName] to get it",
  DB4: "RxDatabase.addCollections(): schema is missing",
  DB5: "RxDatabase.addCollections(): collection-name not allowed",
  DB6: "RxDatabase.addCollections(): another instance created this collection with a different schema. Read this https://pubkey.github.io/rxdb/questions-answers.html#cant-change-the-schema",
  // removed in 13.0.0 (now part of the encryption plugin) DB7: 'RxDatabase.addCollections(): schema encrypted but no password given',
  DB8: "RxDatabase.create(): A RxDatabase with the same name and adapter already exists.\nMake sure to use this combination only once or set ignoreDuplicate to true if you do this intentional",
  // removed in 14.0.0 - PouchDB RxStorage is removed - DB9: 'createRxDatabase(): Adapter not added. Use addPouchPlugin(require(\'pouchdb-adapter-[adaptername]\'));',
  // removed in 14.0.0 - PouchDB RxStorage is removed DB10: 'createRxDatabase(): To use leveldown-adapters, you have to add the leveldb-plugin. Use addPouchPlugin(require(\'pouchdb-adapter-leveldb\'));',
  DB11: "createRxDatabase(): Invalid db-name, folder-paths must not have an ending slash",
  DB12: "RxDatabase.addCollections(): could not write to internal store",
  DB13: "createRxDatabase(): Invalid db-name or collection name, name contains the dollar sign",
  // rx-collection
  COL1: "RxDocument.insert() You cannot insert an existing document",
  COL2: "RxCollection.insert() fieldName ._id can only be used as primaryKey",
  COL3: "RxCollection.upsert() does not work without primary",
  COL4: "RxCollection.incrementalUpsert() does not work without primary",
  COL5: "RxCollection.find() if you want to search by _id, use .findOne(_id)",
  COL6: "RxCollection.findOne() needs a queryObject or string",
  COL7: "hook must be a function",
  COL8: "hooks-when not known",
  COL9: "RxCollection.addHook() hook-name not known",
  COL10: "RxCollection .postCreate-hooks cannot be async",
  COL11: "migrationStrategies must be an object",
  COL12: "A migrationStrategy is missing or too much",
  COL13: "migrationStrategy must be a function",
  COL14: "given static method-name is not a string",
  COL15: "static method-names cannot start with underscore _",
  COL16: "given static method is not a function",
  COL17: "RxCollection.ORM: statics-name not allowed",
  COL18: "collection-method not allowed because fieldname is in the schema",
  // removed in 14.0.0, use CONFLICT instead - COL19: 'Document update conflict. When changing a document you must work on the previous revision',
  COL20: "Storage write error",
  CONFLICT: "Document update conflict. When changing a document you must work on the previous revision",
  // rx-document.js
  DOC1: "RxDocument.get$ cannot get observable of in-array fields because order cannot be guessed",
  DOC2: "cannot observe primary path",
  DOC3: "final fields cannot be observed",
  DOC4: "RxDocument.get$ cannot observe a non-existed field",
  DOC5: "RxDocument.populate() cannot populate a non-existed field",
  DOC6: "RxDocument.populate() cannot populate because path has no ref",
  DOC7: "RxDocument.populate() ref-collection not in database",
  DOC8: "RxDocument.set(): primary-key cannot be modified",
  DOC9: "final fields cannot be modified",
  DOC10: "RxDocument.set(): cannot set childpath when rootPath not selected",
  DOC11: "RxDocument.save(): can't save deleted document",
  // removed in 10.0.0 DOC12: 'RxDocument.save(): error',
  DOC13: "RxDocument.remove(): Document is already deleted",
  DOC14: "RxDocument.destroy() does not exist",
  DOC15: "query cannot be an array",
  DOC16: "Since version 8.0.0 RxDocument.set() can only be called on temporary RxDocuments",
  DOC17: "Since version 8.0.0 RxDocument.save() can only be called on non-temporary documents",
  DOC18: "Document property for composed primary key is missing",
  DOC19: "Value of primary key(s) cannot be changed",
  DOC20: "PrimaryKey missing",
  DOC21: "PrimaryKey must be equal to PrimaryKey.trim(). It cannot start or end with a whitespace",
  DOC22: "PrimaryKey must not contain a linebreak",
  DOC23: 'PrimaryKey must not contain a double-quote ["]',
  // data-migrator.js
  DM1: "migrate() Migration has already run",
  DM2: "migration of document failed final document does not match final schema",
  DM3: "migration already running",
  // plugins/attachments.js
  AT1: "to use attachments, please define this in your schema",
  // plugins/encryption-crypto-js.js
  EN1: "password is not valid",
  EN2: "validatePassword: min-length of password not complied",
  EN3: "Schema contains encrypted properties but no password is given",
  EN4: "Password not valid",
  // plugins/json-dump.js
  JD1: "You must create the collections before you can import their data",
  JD2: "RxCollection.importJSON(): the imported json relies on a different schema",
  JD3: "RxCollection.importJSON(): json.passwordHash does not match the own",
  // plugins/leader-election.js
  // plugins/local-documents.js
  LD1: "RxDocument.allAttachments$ can't use attachments on local documents",
  LD2: "RxDocument.get(): objPath must be a string",
  LD3: "RxDocument.get$ cannot get observable of in-array fields because order cannot be guessed",
  LD4: "cannot observe primary path",
  LD5: "RxDocument.set() id cannot be modified",
  LD6: "LocalDocument: Function is not usable on local documents",
  LD7: "Local document already exists",
  LD8: "localDocuments not activated. Set localDocuments=true on creation, when you want to store local documents on the RxDatabase or RxCollection.",
  // plugins/replication.js
  RC1: "Replication: already added",
  RC2: "replicateCouchDB() query must be from the same RxCollection",
  // removed in 14.0.0 - PouchDB RxStorage is removed RC3: 'RxCollection.syncCouchDB() Do not use a collection\'s pouchdb as remote, use the collection instead',
  RC4: "RxCouchDBReplicationState.awaitInitialReplication() cannot await initial replication when live: true",
  RC5: "RxCouchDBReplicationState.awaitInitialReplication() cannot await initial replication if multiInstance because the replication might run on another instance",
  RC6: "syncFirestore() serverTimestampField MUST NOT be part of the collections schema and MUST NOT be nested.",
  RC_PULL: "RxReplication pull handler threw an error - see .errors for more details",
  RC_STREAM: "RxReplication pull stream$ threw an error - see .errors for more details",
  RC_PUSH: "RxReplication push handler threw an error - see .errors for more details",
  RC_PUSH_NO_AR: "RxReplication push handler did not return an array with the conflicts",
  RC_P2P_PEER: "RxReplication P2P Peer has error",
  RC_COUCHDB_1: "replicateCouchDB() url must end with a slash like 'https://example.com/mydatabase/'",
  RC_COUCHDB_2: "replicateCouchDB() did not get valid result with rows.",
  // plugins/dev-mode/check-schema.js
  SC1: "fieldnames do not match the regex",
  SC2: "SchemaCheck: name 'item' reserved for array-fields",
  SC3: "SchemaCheck: fieldname has a ref-array but items-type is not string",
  SC4: "SchemaCheck: fieldname has a ref but is not type string, [string,null] or array<string>",
  SC6: "SchemaCheck: primary can only be defined at top-level",
  SC7: "SchemaCheck: default-values can only be defined at top-level",
  SC8: "SchemaCheck: first level-fields cannot start with underscore _",
  SC10: "SchemaCheck: schema defines ._rev, this will be done automatically",
  SC11: "SchemaCheck: schema needs a number >=0 as version",
  // removed in 10.0.0 - SC12: 'SchemaCheck: primary can only be defined once',
  SC13: "SchemaCheck: primary is always index, do not declare it as index",
  SC14: "SchemaCheck: primary is always unique, do not declare it as index",
  SC15: "SchemaCheck: primary cannot be encrypted",
  SC16: "SchemaCheck: primary must have type: string",
  SC17: "SchemaCheck: top-level fieldname is not allowed",
  SC18: "SchemaCheck: indexes must be an array",
  SC19: "SchemaCheck: indexes must contain strings or arrays of strings",
  SC20: "SchemaCheck: indexes.array must contain strings",
  SC21: "SchemaCheck: given index is not defined in schema",
  SC22: "SchemaCheck: given indexKey is not type:string",
  SC23: "SchemaCheck: fieldname is not allowed",
  SC24: "SchemaCheck: required fields must be set via array. See https://spacetelescope.github.io/understanding-json-schema/reference/object.html#required",
  SC25: "SchemaCheck: compoundIndexes needs to be specified in the indexes field",
  SC26: "SchemaCheck: indexes needs to be specified at collection schema level",
  SC27: "SchemaCheck: encrypted fields need to be specified at collection schema level",
  SC28: "SchemaCheck: encrypted fields is not defined in the schema",
  SC29: "SchemaCheck: missing object key 'properties'",
  SC30: "SchemaCheck: primaryKey is required",
  SC32: "SchemaCheck: primary field must have the type string/number/integer",
  SC33: "SchemaCheck: used primary key is not a property in the schema",
  SC34: "Fields of type string that are used in an index, must have set the maxLength attribute in the schema",
  SC35: "Fields of type number/integer that are used in an index, must have set the multipleOf attribute in the schema",
  SC36: "A field of this type cannot be used as index",
  SC37: "Fields of type number that are used in an index, must have set the minimum and maximum attribute in the schema",
  SC38: "Fields of type boolean that are used in an index, must be required in the schema",
  SC39: "The primary key must have the maxLength attribute set",
  // plugins/dev-mode
  // removed in 13.9.0, use PL3 instead - DEV1: 'dev-mode added multiple times',
  // plugins/validate.js
  VD1: "Sub-schema not found, does the schemaPath exists in your schema?",
  VD2: "object does not match schema",
  // plugins/in-memory.js
  // removed in 14.0.0 - PouchDB RxStorage is removed IM1: 'InMemory: Memory-Adapter must be added. Use addPouchPlugin(require(\'pouchdb-adapter-memory\'));',
  // removed in 14.0.0 - PouchDB RxStorage is removed IM2: 'inMemoryCollection.sync(): Do not replicate with the in-memory instance. Replicate with the parent instead',
  // plugins/server.js
  S1: "You cannot create collections after calling RxDatabase.server()",
  // plugins/replication-graphql.js
  GQL1: "GraphQL replication: cannot find sub schema by key",
  // removed in 13.0.0, use RC_PULL instead - GQL2: 'GraphQL replication: unknown errors occurred in replication pull - see innerErrors for more details',
  GQL3: "GraphQL replication: pull returns more documents then batchSize",
  // removed in 13.0.0, use RC_PUSH instead - GQL4: 'GraphQL replication: unknown errors occurred in replication push - see innerErrors for more details',
  // plugins/crdt/
  CRDT1: "CRDT operations cannot be used because the crdt options are not set in the schema.",
  CRDT2: "RxDocument.incrementalModify() cannot be used when CRDTs are activated.",
  CRDT3: "To use CRDTs you MUST NOT set a conflictHandler because the default CRDT conflict handler must be used",
  // plugins/storage-dexie/
  DXE1: "The dexie.js RxStorage does not support boolean indexes, see https://rxdb.info/rx-storage-dexie.html#boolean-index",
  /**
   * Should never be thrown, use this for
   * null checks etc. so you do not have to increase the
   * build size with error message strings.
   */
  SNH: "This should never happen"
};
errorMessages.ERROR_MESSAGES = ERROR_MESSAGES;
var checkSchema$1 = {};
var entityProperties = {};
Object.defineProperty(entityProperties, "__esModule", {
  value: true
});
entityProperties.rxCollectionProperties = rxCollectionProperties;
entityProperties.rxDatabaseProperties = rxDatabaseProperties;
entityProperties.rxDocumentProperties = rxDocumentProperties;
var _rxCollection = rxCollection;
var _rxDatabase = rxDatabase;
var _rxDocument = rxDocument;
var _rxCollectionProperties;
function rxCollectionProperties() {
  if (!_rxCollectionProperties) {
    var pseudoInstance = new _rxCollection.RxCollectionBase();
    var ownProperties = Object.getOwnPropertyNames(pseudoInstance);
    var prototypeProperties = Object.getOwnPropertyNames(Object.getPrototypeOf(pseudoInstance));
    _rxCollectionProperties = [...ownProperties, ...prototypeProperties];
  }
  return _rxCollectionProperties;
}
var _rxDatabaseProperties;
function rxDatabaseProperties() {
  if (!_rxDatabaseProperties) {
    var pseudoInstance = new _rxDatabase.RxDatabaseBase("pseudoInstance", "memory");
    var ownProperties = Object.getOwnPropertyNames(pseudoInstance);
    var prototypeProperties = Object.getOwnPropertyNames(Object.getPrototypeOf(pseudoInstance));
    _rxDatabaseProperties = [...ownProperties, ...prototypeProperties];
    pseudoInstance.destroy();
  }
  return _rxDatabaseProperties;
}
var pseudoConstructor = (0, _rxDocument.createRxDocumentConstructor)(_rxDocument.basePrototype);
var pseudoRxDocument = new pseudoConstructor();
var _rxDocumentProperties;
function rxDocumentProperties() {
  if (!_rxDocumentProperties) {
    var reserved = ["deleted", "synced"];
    var ownProperties = Object.getOwnPropertyNames(pseudoRxDocument);
    var prototypeProperties = Object.getOwnPropertyNames(_rxDocument.basePrototype);
    _rxDocumentProperties = [...ownProperties, ...prototypeProperties, ...reserved];
  }
  return _rxDocumentProperties;
}
Object.defineProperty(checkSchema$1, "__esModule", {
  value: true
});
checkSchema$1.checkFieldNameRegex = checkFieldNameRegex;
checkSchema$1.checkPrimaryKey = checkPrimaryKey;
checkSchema$1.checkSchema = checkSchema;
checkSchema$1.validateFieldsDeep = validateFieldsDeep;
var _rxError$6 = rxError;
var _rxSchemaHelper = rxSchemaHelper;
var _utils$2 = utils;
var _entityProperties$2 = entityProperties;
function checkFieldNameRegex(fieldName) {
  if (fieldName === "_deleted") {
    return;
  }
  if (["properties"].includes(fieldName)) {
    throw (0, _rxError$6.newRxError)("SC23", {
      fieldName
    });
  }
  var regexStr = "^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$";
  var regex2 = new RegExp(regexStr);
  if (
    /**
     * It must be allowed to set _id as primaryKey.
     * This makes it sometimes easier to work with RxDB+CouchDB
     * @link https://github.com/pubkey/rxdb/issues/681
     */
    fieldName !== "_id" && !fieldName.match(regex2)
  ) {
    throw (0, _rxError$6.newRxError)("SC1", {
      regex: regexStr,
      fieldName
    });
  }
}
function validateFieldsDeep(rxJsonSchema) {
  var primaryPath = (0, _rxSchemaHelper.getPrimaryFieldOfPrimaryKey)(rxJsonSchema.primaryKey);
  function checkField(fieldName, schemaObj, path2) {
    if (typeof fieldName === "string" && typeof schemaObj === "object" && !Array.isArray(schemaObj))
      checkFieldNameRegex(fieldName);
    if (schemaObj.hasOwnProperty("item") && schemaObj.type !== "array") {
      throw (0, _rxError$6.newRxError)("SC2", {
        fieldName
      });
    }
    if (schemaObj.hasOwnProperty("required") && typeof schemaObj.required === "boolean") {
      throw (0, _rxError$6.newRxError)("SC24", {
        fieldName
      });
    }
    if (schemaObj.hasOwnProperty("ref")) {
      if (Array.isArray(schemaObj.type)) {
        if (schemaObj.type.length > 2 || !schemaObj.type.includes("string") || !schemaObj.type.includes("null")) {
          throw (0, _rxError$6.newRxError)("SC4", {
            fieldName
          });
        }
      } else {
        switch (schemaObj.type) {
          case "string":
            break;
          case "array":
            if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== "string") {
              throw (0, _rxError$6.newRxError)("SC3", {
                fieldName
              });
            }
            break;
          default:
            throw (0, _rxError$6.newRxError)("SC4", {
              fieldName
            });
        }
      }
    }
    var isNested = path2.split(".").length >= 2;
    if (isNested) {
      if (schemaObj.primary) {
        throw (0, _rxError$6.newRxError)("SC6", {
          path: path2,
          primary: schemaObj.primary
        });
      }
      if (schemaObj.default) {
        throw (0, _rxError$6.newRxError)("SC7", {
          path: path2
        });
      }
    }
    if (!isNested) {
      if (fieldName === "_id" && primaryPath !== "_id") {
        throw (0, _rxError$6.newRxError)("COL2", {
          fieldName
        });
      }
      if (fieldName.charAt(0) === "_") {
        if (
          // exceptional allow underscore on these fields.
          fieldName === "_id" || fieldName === "_deleted"
        ) {
          return;
        }
        throw (0, _rxError$6.newRxError)("SC8", {
          fieldName
        });
      }
    }
  }
  function traverse(currentObj, currentPath) {
    if (!currentObj || typeof currentObj !== "object") {
      return;
    }
    Object.keys(currentObj).forEach((attributeName) => {
      var schemaObj = currentObj[attributeName];
      if (!currentObj.properties && schemaObj && typeof schemaObj === "object" && !Array.isArray(currentObj)) {
        checkField(attributeName, schemaObj, currentPath);
      }
      var nextPath = currentPath;
      if (attributeName !== "properties")
        nextPath = nextPath + "." + attributeName;
      traverse(schemaObj, nextPath);
    });
  }
  traverse(rxJsonSchema, "");
  return true;
}
function checkPrimaryKey(jsonSchema2) {
  if (!jsonSchema2.primaryKey) {
    throw (0, _rxError$6.newRxError)("SC30", {
      schema: jsonSchema2
    });
  }
  function validatePrimarySchemaPart(schemaPart2) {
    if (!schemaPart2) {
      throw (0, _rxError$6.newRxError)("SC33", {
        schema: jsonSchema2
      });
    }
    var type2 = schemaPart2.type;
    if (!type2 || !["string", "number", "integer"].includes(type2)) {
      throw (0, _rxError$6.newRxError)("SC32", {
        schema: jsonSchema2,
        args: {
          schemaPart: schemaPart2
        }
      });
    }
  }
  if (typeof jsonSchema2.primaryKey === "string") {
    var key = jsonSchema2.primaryKey;
    var schemaPart = jsonSchema2.properties[key];
    validatePrimarySchemaPart(schemaPart);
  } else {
    var compositePrimaryKey = jsonSchema2.primaryKey;
    var keySchemaPart = (0, _rxSchemaHelper.getSchemaByObjectPath)(jsonSchema2, compositePrimaryKey.key);
    validatePrimarySchemaPart(keySchemaPart);
    compositePrimaryKey.fields.forEach((field) => {
      var schemaPart2 = (0, _rxSchemaHelper.getSchemaByObjectPath)(jsonSchema2, field);
      validatePrimarySchemaPart(schemaPart2);
    });
  }
  var primaryPath = (0, _rxSchemaHelper.getPrimaryFieldOfPrimaryKey)(jsonSchema2.primaryKey);
  var primaryPathSchemaPart = jsonSchema2.properties[primaryPath];
  if (!primaryPathSchemaPart.maxLength) {
    throw (0, _rxError$6.newRxError)("SC39", {
      schema: jsonSchema2,
      args: {
        primaryPathSchemaPart
      }
    });
  }
}
function getSchemaPropertyRealPath(shortPath) {
  var pathParts = shortPath.split(".");
  var realPath = "";
  for (var i = 0; i < pathParts.length; i += 1) {
    if (pathParts[i] !== "[]") {
      realPath = realPath.concat(".properties.".concat(pathParts[i]));
    } else {
      realPath = realPath.concat(".items");
    }
  }
  return (0, _utils$2.trimDots)(realPath);
}
function checkSchema(jsonSchema2) {
  if (!jsonSchema2.primaryKey) {
    throw (0, _rxError$6.newRxError)("SC30", {
      schema: jsonSchema2
    });
  }
  if (!jsonSchema2.hasOwnProperty("properties")) {
    throw (0, _rxError$6.newRxError)("SC29", {
      schema: jsonSchema2
    });
  }
  if (jsonSchema2.properties._rev) {
    throw (0, _rxError$6.newRxError)("SC10", {
      schema: jsonSchema2
    });
  }
  if (!jsonSchema2.hasOwnProperty("version") || typeof jsonSchema2.version !== "number" || jsonSchema2.version < 0) {
    throw (0, _rxError$6.newRxError)("SC11", {
      version: jsonSchema2.version
    });
  }
  validateFieldsDeep(jsonSchema2);
  checkPrimaryKey(jsonSchema2);
  Object.keys(jsonSchema2.properties).forEach((key) => {
    var value = jsonSchema2.properties[key];
    if (key === jsonSchema2.primaryKey) {
      if (jsonSchema2.indexes && jsonSchema2.indexes.includes(key)) {
        throw (0, _rxError$6.newRxError)("SC13", {
          value,
          schema: jsonSchema2
        });
      }
      if (value.unique) {
        throw (0, _rxError$6.newRxError)("SC14", {
          value,
          schema: jsonSchema2
        });
      }
      if (jsonSchema2.encrypted && jsonSchema2.encrypted.includes(key)) {
        throw (0, _rxError$6.newRxError)("SC15", {
          value,
          schema: jsonSchema2
        });
      }
      if (value.type !== "string") {
        throw (0, _rxError$6.newRxError)("SC16", {
          value,
          schema: jsonSchema2
        });
      }
    }
    if ((0, _entityProperties$2.rxDocumentProperties)().includes(key)) {
      throw (0, _rxError$6.newRxError)("SC17", {
        key,
        schema: jsonSchema2
      });
    }
  });
  if (jsonSchema2.indexes) {
    if (!(0, _utils$2.isMaybeReadonlyArray)(jsonSchema2.indexes)) {
      throw (0, _rxError$6.newRxError)("SC18", {
        indexes: jsonSchema2.indexes,
        schema: jsonSchema2
      });
    }
    jsonSchema2.indexes.forEach((index) => {
      if (!(typeof index === "string" || Array.isArray(index))) {
        throw (0, _rxError$6.newRxError)("SC19", {
          index,
          schema: jsonSchema2
        });
      }
      if (Array.isArray(index)) {
        for (var i = 0; i < index.length; i += 1) {
          if (typeof index[i] !== "string") {
            throw (0, _rxError$6.newRxError)("SC20", {
              index,
              schema: jsonSchema2
            });
          }
        }
      }
      var indexAsArray = (0, _utils$2.isMaybeReadonlyArray)(index) ? index : [index];
      indexAsArray.forEach((fieldName) => {
        var schemaPart = (0, _rxSchemaHelper.getSchemaByObjectPath)(jsonSchema2, fieldName);
        var type2 = schemaPart.type;
        switch (type2) {
          case "string":
            var maxLength = schemaPart.maxLength;
            if (!maxLength) {
              throw (0, _rxError$6.newRxError)("SC34", {
                index,
                field: fieldName,
                schema: jsonSchema2
              });
            }
            break;
          case "number":
          case "integer":
            var multipleOf = schemaPart.multipleOf;
            if (!multipleOf) {
              throw (0, _rxError$6.newRxError)("SC35", {
                index,
                field: fieldName,
                schema: jsonSchema2
              });
            }
            var maximum = schemaPart.maximum;
            var minimum = schemaPart.minimum;
            if (typeof maximum === "undefined" || typeof minimum === "undefined") {
              throw (0, _rxError$6.newRxError)("SC37", {
                index,
                field: fieldName,
                schema: jsonSchema2
              });
            }
            break;
          case "boolean":
            var parentPath = "";
            var lastPathPart = fieldName;
            if (fieldName.includes(".")) {
              var partParts = fieldName.split(".");
              lastPathPart = partParts.pop();
              parentPath = partParts.join(".");
            }
            var parentSchemaPart = parentPath === "" ? jsonSchema2 : (0, _rxSchemaHelper.getSchemaByObjectPath)(jsonSchema2, parentPath);
            if (!parentSchemaPart.required || !parentSchemaPart.required.includes(lastPathPart)) {
              throw (0, _rxError$6.newRxError)("SC38", {
                index,
                field: fieldName,
                schema: jsonSchema2
              });
            }
            break;
          default:
            throw (0, _rxError$6.newRxError)("SC36", {
              fieldName,
              type: schemaPart.type,
              schema: jsonSchema2
            });
        }
      });
    });
  }
  Object.keys((0, _utils$2.flattenObject)(jsonSchema2)).map((key) => {
    var split2 = key.split(".");
    split2.pop();
    return split2.join(".");
  }).filter((key) => key !== "").filter((elem, pos, arr2) => arr2.indexOf(elem) === pos).filter((key) => {
    var value = (0, _utils$2.getProperty)(jsonSchema2, key);
    return value && !!value.index;
  }).forEach((key) => {
    key = key.replace("properties.", "");
    key = key.replace(/\.properties\./g, ".");
    throw (0, _rxError$6.newRxError)("SC26", {
      index: (0, _utils$2.trimDots)(key),
      schema: jsonSchema2
    });
  });
  (jsonSchema2.indexes || []).reduce((indexPaths, currentIndex) => {
    if ((0, _utils$2.isMaybeReadonlyArray)(currentIndex)) {
      (0, _utils$2.appendToArray)(indexPaths, currentIndex);
    } else {
      indexPaths.push(currentIndex);
    }
    return indexPaths;
  }, []).filter((elem, pos, arr2) => arr2.indexOf(elem) === pos).map((indexPath) => {
    var realPath = getSchemaPropertyRealPath(indexPath);
    var schemaObj = (0, _utils$2.getProperty)(jsonSchema2, realPath);
    if (!schemaObj || typeof schemaObj !== "object") {
      throw (0, _rxError$6.newRxError)("SC21", {
        index: indexPath,
        schema: jsonSchema2
      });
    }
    return {
      indexPath,
      schemaObj
    };
  }).filter((index) => index.schemaObj.type !== "string" && index.schemaObj.type !== "integer" && index.schemaObj.type !== "number" && index.schemaObj.type !== "boolean").forEach((index) => {
    throw (0, _rxError$6.newRxError)("SC22", {
      key: index.indexPath,
      type: index.schemaObj.type,
      schema: jsonSchema2
    });
  });
  Object.keys((0, _utils$2.flattenObject)(jsonSchema2)).map((key) => {
    var split2 = key.split(".");
    split2.pop();
    return split2.join(".");
  }).filter((key) => key !== "" && key !== "attachments").filter((elem, pos, arr2) => arr2.indexOf(elem) === pos).filter((key) => {
    var value = (0, _utils$2.getProperty)(jsonSchema2, key);
    return value && !!value.encrypted;
  }).forEach((key) => {
    key = key.replace("properties.", "");
    key = key.replace(/\.properties\./g, ".");
    throw (0, _rxError$6.newRxError)("SC27", {
      index: (0, _utils$2.trimDots)(key),
      schema: jsonSchema2
    });
  });
  if (jsonSchema2.encrypted) {
    jsonSchema2.encrypted.forEach((propPath) => {
      var realPath = getSchemaPropertyRealPath(propPath);
      var schemaObj = (0, _utils$2.getProperty)(jsonSchema2, realPath);
      if (!schemaObj || typeof schemaObj !== "object") {
        throw (0, _rxError$6.newRxError)("SC28", {
          field: propPath,
          schema: jsonSchema2
        });
      }
    });
  }
}
var checkOrm = {};
Object.defineProperty(checkOrm, "__esModule", {
  value: true
});
checkOrm.checkOrmDocumentMethods = checkOrmDocumentMethods;
checkOrm.checkOrmMethods = checkOrmMethods;
var _rxError$5 = rxError;
var _entityProperties$1 = entityProperties;
function checkOrmMethods(statics) {
  if (!statics) {
    return;
  }
  Object.entries(statics).forEach(([k, v]) => {
    if (typeof k !== "string") {
      throw (0, _rxError$5.newRxTypeError)("COL14", {
        name: k
      });
    }
    if (k.startsWith("_")) {
      throw (0, _rxError$5.newRxTypeError)("COL15", {
        name: k
      });
    }
    if (typeof v !== "function") {
      throw (0, _rxError$5.newRxTypeError)("COL16", {
        name: k,
        type: typeof k
      });
    }
    if ((0, _entityProperties$1.rxCollectionProperties)().includes(k) || (0, _entityProperties$1.rxDocumentProperties)().includes(k)) {
      throw (0, _rxError$5.newRxError)("COL17", {
        name: k
      });
    }
  });
}
function checkOrmDocumentMethods(schema, methods) {
  var topLevelFields = Object.keys(schema.properties);
  if (!methods) {
    return;
  }
  Object.keys(methods).filter((funName) => topLevelFields.includes(funName)).forEach((funName) => {
    throw (0, _rxError$5.newRxError)("COL18", {
      funName
    });
  });
}
var checkMigrationStrategies$1 = {};
Object.defineProperty(checkMigrationStrategies$1, "__esModule", {
  value: true
});
checkMigrationStrategies$1.checkMigrationStrategies = checkMigrationStrategies;
var _rxError$4 = rxError;
var _rxSchema = rxSchema;
function checkMigrationStrategies(schema, migrationStrategies) {
  if (typeof migrationStrategies !== "object" || Array.isArray(migrationStrategies)) {
    throw (0, _rxError$4.newRxTypeError)("COL11", {
      schema
    });
  }
  var previousVersions = (0, _rxSchema.getPreviousVersions)(schema);
  if (previousVersions.length !== Object.keys(migrationStrategies).length) {
    throw (0, _rxError$4.newRxError)("COL12", {
      have: Object.keys(migrationStrategies),
      should: previousVersions
    });
  }
  previousVersions.map((vNr) => ({
    v: vNr,
    s: migrationStrategies[vNr + 1]
  })).filter((strategy) => typeof strategy.s !== "function").forEach((strategy) => {
    throw (0, _rxError$4.newRxTypeError)("COL13", {
      version: strategy.v,
      type: typeof strategy,
      schema
    });
  });
  return true;
}
var unallowedProperties = {};
Object.defineProperty(unallowedProperties, "__esModule", {
  value: true
});
unallowedProperties.ensureCollectionNameValid = ensureCollectionNameValid;
unallowedProperties.ensureDatabaseNameIsValid = ensureDatabaseNameIsValid;
unallowedProperties.validateDatabaseName = validateDatabaseName;
var _rxError$3 = rxError;
var _entityProperties = entityProperties;
var _utils$1 = utils;
function ensureCollectionNameValid(args2) {
  if ((0, _entityProperties.rxDatabaseProperties)().includes(args2.name)) {
    throw (0, _rxError$3.newRxError)("DB5", {
      name: args2.name
    });
  }
  validateDatabaseName(args2.name);
}
function ensureDatabaseNameIsValid(args2) {
  validateDatabaseName(args2.name);
  if (args2.name.includes("$")) {
    throw (0, _rxError$3.newRxError)("DB13", {
      name: args2.name
    });
  }
  if ((0, _utils$1.isFolderPath)(args2.name)) {
    if (args2.name.endsWith("/") || args2.name.endsWith("\\")) {
      throw (0, _rxError$3.newRxError)("DB11", {
        name: args2.name
      });
    }
  }
}
var validCouchDBStringRegexStr = "^[a-z][_$a-z0-9\\-]*$";
var validCouchDBStringRegex = new RegExp(validCouchDBStringRegexStr);
function validateDatabaseName(name) {
  if (typeof name !== "string" || name.length === 0) {
    throw (0, _rxError$3.newRxTypeError)("UT1", {
      name
    });
  }
  if ((0, _utils$1.isFolderPath)(name)) {
    return true;
  }
  if (!name.match(validCouchDBStringRegex) && /**
   * The string ':memory:' is used in the SQLite RxStorage
   * to persist data into a memory state. Often used in tests.
   */
  name !== ":memory:") {
    throw (0, _rxError$3.newRxError)("UT2", {
      regex: validCouchDBStringRegexStr,
      givenName: name
    });
  }
  return true;
}
var checkQuery$1 = {};
Object.defineProperty(checkQuery$1, "__esModule", {
  value: true
});
checkQuery$1.areSelectorsSatisfiedByIndex = areSelectorsSatisfiedByIndex;
checkQuery$1.checkMangoQuery = checkMangoQuery;
checkQuery$1.checkQuery = checkQuery;
var _rxError$2 = rxError;
var _storageDexie = storageDexie;
var _utils = utils;
function checkQuery(args2) {
  var isPlainObject = Object.prototype.toString.call(args2.queryObj) === "[object Object]";
  if (!isPlainObject) {
    throw (0, _rxError$2.newRxTypeError)("QU11", {
      op: args2.op,
      collection: args2.collection.name,
      queryObj: args2.queryObj
    });
  }
  var validKeys = ["selector", "limit", "skip", "sort", "index"];
  Object.keys(args2.queryObj).forEach((key) => {
    if (!validKeys.includes(key)) {
      throw (0, _rxError$2.newRxTypeError)("QU11", {
        op: args2.op,
        collection: args2.collection.name,
        queryObj: args2.queryObj,
        key,
        args: {
          validKeys
        }
      });
    }
  });
  if (args2.op === "count" && (args2.queryObj.limit || args2.queryObj.skip)) {
    throw (0, _rxError$2.newRxError)("QU15", {
      collection: args2.collection.name,
      query: args2.queryObj
    });
  }
}
function checkMangoQuery(args2) {
  var schema = args2.rxQuery.collection.schema.jsonSchema;
  var massagedSelector = args2.mangoQuery.selector;
  var schemaTopLevelFields = Object.keys(schema.properties);
  Object.keys(massagedSelector).filter((fieldOrOperator) => !fieldOrOperator.startsWith("$")).filter((field) => !field.includes(".")).forEach((field) => {
    if (!schemaTopLevelFields.includes(field)) {
      throw (0, _rxError$2.newRxError)("QU13", {
        schema,
        field,
        query: args2.mangoQuery
      });
    }
  });
  var schemaIndexes = schema.indexes ? schema.indexes : [];
  var index = args2.mangoQuery.index;
  if (index) {
    var isInSchema = schemaIndexes.find((schemaIndex) => (0, _utils.deepEqual)(schemaIndex, index));
    if (!isInSchema) {
      throw (0, _rxError$2.newRxError)("QU12", {
        collection: args2.rxQuery.collection.name,
        query: args2.mangoQuery,
        schema
      });
    }
  }
  if (args2.rxQuery.op === "count") {
    if (!areSelectorsSatisfiedByIndex(args2.rxQuery.collection.schema.jsonSchema, args2.mangoQuery) && !args2.rxQuery.collection.database.allowSlowCount) {
      throw (0, _rxError$2.newRxError)("QU14", {
        collection: args2.rxQuery.collection,
        query: args2.mangoQuery
      });
    }
  }
  if (args2.mangoQuery.sort) {
    args2.mangoQuery.sort.map((sortPart) => Object.keys(sortPart)[0]).filter((field) => !field.includes(".")).forEach((field) => {
      if (!schemaTopLevelFields.includes(field)) {
        throw (0, _rxError$2.newRxError)("QU13", {
          schema,
          field,
          query: args2.mangoQuery
        });
      }
    });
  }
}
function areSelectorsSatisfiedByIndex(schema, query2) {
  var preparedQuery = _storageDexie.RxStorageDexieStatics.prepareQuery(schema, query2);
  return preparedQuery.queryPlan.selectorSatisfiedByIndex;
}
var checkDocument = {};
Object.defineProperty(checkDocument, "__esModule", {
  value: true
});
checkDocument.ensurePrimaryKeyValid = ensurePrimaryKeyValid;
var _rxError$1 = rxError;
function ensurePrimaryKeyValid(primaryKey, docData) {
  if (!primaryKey) {
    throw (0, _rxError$1.newRxError)("DOC20", {
      primaryKey,
      document: docData
    });
  }
  if (primaryKey !== primaryKey.trim()) {
    throw (0, _rxError$1.newRxError)("DOC21", {
      primaryKey,
      document: docData
    });
  }
  if (primaryKey.includes("\r") || primaryKey.includes("\n")) {
    throw (0, _rxError$1.newRxError)("DOC22", {
      primaryKey,
      document: docData
    });
  }
  if (primaryKey.includes('"')) {
    throw (0, _rxError$1.newRxError)("DOC23", {
      primaryKey,
      document: docData
    });
  }
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    deepFreezeWhenDevMode: true,
    DEV_MODE_PLUGIN_NAME: true,
    RxDBDevModePlugin: true
  };
  exports.RxDBDevModePlugin = exports.DEV_MODE_PLUGIN_NAME = void 0;
  exports.deepFreezeWhenDevMode = deepFreezeWhenDevMode;
  var _errorMessages = errorMessages;
  var _checkSchema = checkSchema$1;
  Object.keys(_checkSchema).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _checkSchema[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _checkSchema[key];
      }
    });
  });
  var _checkOrm = checkOrm;
  var _checkMigrationStrategies = checkMigrationStrategies$1;
  var _unallowedProperties = unallowedProperties;
  Object.keys(_unallowedProperties).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _unallowedProperties[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _unallowedProperties[key];
      }
    });
  });
  var _checkQuery = checkQuery$1;
  Object.keys(_checkQuery).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _checkQuery[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _checkQuery[key];
      }
    });
  });
  var _rxError2 = rxError;
  var _utils2 = utils;
  var _checkDocument = checkDocument;
  function deepFreezeWhenDevMode(obj) {
    if (!obj || typeof obj === "string" || typeof obj === "number") {
      return obj;
    }
    return (0, _utils2.deepFreeze)(obj);
  }
  var DEV_MODE_PLUGIN_NAME = "dev-mode";
  exports.DEV_MODE_PLUGIN_NAME = DEV_MODE_PLUGIN_NAME;
  var RxDBDevModePlugin = {
    name: DEV_MODE_PLUGIN_NAME,
    rxdb: true,
    init: () => {
      console.warn(["-------------- RxDB dev-mode warning -------------------------------", "you are seeing this because you use the RxDB dev-mode plugin https://rxdb.info/dev-mode.html", "This is great in development mode, because it will run many checks to ensure", "that you use RxDB correct. If you see this in production mode,", "you did something wrong because the dev-mode plugin will decrease the performance.", "", "🤗 Hint: To get the most out of RxDB, check out the Premium Plugins", "to get access to faster storages and more professional features: https://rxdb.info/premium.html", "", "Also take part in the RxDB User Survey: https://rxdb.info/survey.html", "---------------------------------------------------------------------"].join("\n"));
    },
    overwritable: {
      isDevMode() {
        return true;
      },
      deepFreezeWhenDevMode,
      tunnelErrorMessage(code) {
        if (!_errorMessages.ERROR_MESSAGES[code]) {
          console.error("RxDB: Error-Code not known: " + code);
          throw new Error("Error-Code " + code + " not known, contact the maintainer");
        }
        return _errorMessages.ERROR_MESSAGES[code];
      }
    },
    hooks: {
      preCreateRxSchema: {
        after: _checkSchema.checkSchema
      },
      preCreateRxDatabase: {
        after: function(args2) {
          (0, _unallowedProperties.ensureDatabaseNameIsValid)(args2);
        }
      },
      preCreateRxCollection: {
        after: function(args2) {
          (0, _unallowedProperties.ensureCollectionNameValid)(args2);
          (0, _checkOrm.checkOrmDocumentMethods)(args2.schema, args2.methods);
          if (args2.name.charAt(0) === "_") {
            throw (0, _rxError2.newRxError)("DB2", {
              name: args2.name
            });
          }
          if (!args2.schema) {
            throw (0, _rxError2.newRxError)("DB4", {
              name: args2.name,
              args: args2
            });
          }
        }
      },
      createRxDocument: {
        before: function(doc) {
          (0, _checkDocument.ensurePrimaryKeyValid)(doc.primary, doc.toJSON(true));
        }
      },
      preCreateRxQuery: {
        after: function(args2) {
          (0, _checkQuery.checkQuery)(args2);
        }
      },
      prePrepareQuery: {
        after: (args2) => {
          (0, _checkQuery.checkMangoQuery)(args2);
        }
      },
      createRxCollection: {
        after: (args2) => {
          (0, _checkOrm.checkOrmMethods)(args2.creator.statics);
          (0, _checkOrm.checkOrmMethods)(args2.creator.methods);
          (0, _checkOrm.checkOrmMethods)(args2.creator.attachments);
          if (args2.creator.schema && args2.creator.migrationStrategies) {
            (0, _checkMigrationStrategies.checkMigrationStrategies)(args2.creator.schema, args2.creator.migrationStrategies);
          }
        }
      }
    }
  };
  exports.RxDBDevModePlugin = RxDBDevModePlugin;
})(devMode);
var queryBuilder = {};
var nosqlQueryBuilder = {};
var mqueryUtils = {};
Object.defineProperty(mqueryUtils, "__esModule", {
  value: true
});
mqueryUtils.isObject = isObject;
mqueryUtils.merge = merge;
var SPECIAL_PROPERTIES = ["__proto__", "constructor", "prototype"];
function merge(to, from2) {
  Object.keys(from2).forEach((key) => {
    if (SPECIAL_PROPERTIES.includes(key)) {
      return;
    }
    if (typeof to[key] === "undefined") {
      to[key] = from2[key];
    } else {
      if (isObject(from2[key]))
        merge(to[key], from2[key]);
      else
        to[key] = from2[key];
    }
  });
}
function isObject(arg) {
  return "[object Object]" === arg.toString();
}
Object.defineProperty(nosqlQueryBuilder, "__esModule", {
  value: true
});
nosqlQueryBuilder.OTHER_MANGO_OPERATORS = nosqlQueryBuilder.OTHER_MANGO_ATTRIBUTES = nosqlQueryBuilder.NoSqlQueryBuilderClass = void 0;
nosqlQueryBuilder.canMerge = canMerge;
nosqlQueryBuilder.createQueryBuilder = createQueryBuilder;
nosqlQueryBuilder.mQuerySortToRxDBSort = mQuerySortToRxDBSort;
var _mqueryUtils = mqueryUtils;
var _rxError = rxError;
var NoSqlQueryBuilderClass = /* @__PURE__ */ function() {
  function NoSqlQueryBuilderClass2(mangoQuery, _path2) {
    this.options = {};
    this._conditions = {};
    this._fields = {};
    this._path = _path2;
    if (mangoQuery) {
      var queryBuilder2 = this;
      if (mangoQuery.selector) {
        queryBuilder2.find(mangoQuery.selector);
      }
      if (mangoQuery.limit) {
        queryBuilder2.limit(mangoQuery.limit);
      }
      if (mangoQuery.skip) {
        queryBuilder2.skip(mangoQuery.skip);
      }
      if (mangoQuery.sort) {
        mangoQuery.sort.forEach((s) => queryBuilder2.sort(s));
      }
    }
  }
  var _proto = NoSqlQueryBuilderClass2.prototype;
  _proto.where = function where2(_path2, _val) {
    if (!arguments.length)
      return this;
    var type2 = typeof arguments[0];
    if ("string" === type2) {
      this._path = arguments[0];
      if (2 === arguments.length) {
        this._conditions[this._path] = arguments[1];
      }
      return this;
    }
    if ("object" === type2 && !Array.isArray(arguments[0])) {
      return this.merge(arguments[0]);
    }
    throw (0, _rxError.newRxTypeError)("MQ1", {
      path: arguments[0]
    });
  };
  _proto.equals = function equals(val) {
    this._ensurePath("equals");
    var path2 = this._path;
    this._conditions[path2] = val;
    return this;
  };
  _proto.eq = function eq2(val) {
    this._ensurePath("eq");
    var path2 = this._path;
    this._conditions[path2] = val;
    return this;
  };
  _proto.or = function or2(array2) {
    var or3 = this._conditions.$or || (this._conditions.$or = []);
    if (!Array.isArray(array2))
      array2 = [array2];
    or3.push.apply(or3, array2);
    return this;
  };
  _proto.nor = function nor2(array2) {
    var nor3 = this._conditions.$nor || (this._conditions.$nor = []);
    if (!Array.isArray(array2))
      array2 = [array2];
    nor3.push.apply(nor3, array2);
    return this;
  };
  _proto.and = function and2(array2) {
    var and3 = this._conditions.$and || (this._conditions.$and = []);
    if (!Array.isArray(array2))
      array2 = [array2];
    and3.push.apply(and3, array2);
    return this;
  };
  _proto.mod = function mod2(_path2, _val) {
    var val;
    var path2;
    if (1 === arguments.length) {
      this._ensurePath("mod");
      val = arguments[0];
      path2 = this._path;
    } else if (2 === arguments.length && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = arguments.slice();
      path2 = this._path;
    } else if (3 === arguments.length) {
      val = arguments.slice(1);
      path2 = arguments[0];
    } else {
      val = arguments[1];
      path2 = arguments[0];
    }
    var conds = this._conditions[path2] || (this._conditions[path2] = {});
    conds.$mod = val;
    return this;
  };
  _proto.exists = function exists2(_path2, _val) {
    var path2;
    var val;
    if (0 === arguments.length) {
      this._ensurePath("exists");
      path2 = this._path;
      val = true;
    } else if (1 === arguments.length) {
      if ("boolean" === typeof arguments[0]) {
        this._ensurePath("exists");
        path2 = this._path;
        val = arguments[0];
      } else {
        path2 = arguments[0];
        val = true;
      }
    } else if (2 === arguments.length) {
      path2 = arguments[0];
      val = arguments[1];
    }
    var conds = this._conditions[path2] || (this._conditions[path2] = {});
    conds.$exists = val;
    return this;
  };
  _proto.elemMatch = function elemMatch2(_path2, _criteria) {
    if (null === arguments[0])
      throw (0, _rxError.newRxTypeError)("MQ2");
    var fn;
    var path2;
    var criteria;
    if ("function" === typeof arguments[0]) {
      this._ensurePath("elemMatch");
      path2 = this._path;
      fn = arguments[0];
    } else if ((0, _mqueryUtils.isObject)(arguments[0])) {
      this._ensurePath("elemMatch");
      path2 = this._path;
      criteria = arguments[0];
    } else if ("function" === typeof arguments[1]) {
      path2 = arguments[0];
      fn = arguments[1];
    } else if (arguments[1] && (0, _mqueryUtils.isObject)(arguments[1])) {
      path2 = arguments[0];
      criteria = arguments[1];
    } else
      throw (0, _rxError.newRxTypeError)("MQ2");
    if (fn) {
      criteria = new NoSqlQueryBuilderClass2();
      fn(criteria);
      criteria = criteria._conditions;
    }
    var conds = this._conditions[path2] || (this._conditions[path2] = {});
    conds.$elemMatch = criteria;
    return this;
  };
  _proto.sort = function sort2(arg) {
    if (!arg)
      return this;
    var len;
    var type2 = typeof arg;
    if (Array.isArray(arg)) {
      len = arg.length;
      for (var i = 0; i < arg.length; ++i) {
        _pushArr(this.options, arg[i][0], arg[i][1]);
      }
      return this;
    }
    if (1 === arguments.length && "string" === type2) {
      arg = arg.split(/\s+/);
      len = arg.length;
      for (var _i = 0; _i < len; ++_i) {
        var field = arg[_i];
        if (!field)
          continue;
        var ascend = "-" === field[0] ? -1 : 1;
        if (ascend === -1)
          field = field.substring(1);
        push(this.options, field, ascend);
      }
      return this;
    }
    if ((0, _mqueryUtils.isObject)(arg)) {
      var keys2 = Object.keys(arg);
      keys2.forEach((field2) => push(this.options, field2, arg[field2]));
      return this;
    }
    throw (0, _rxError.newRxTypeError)("MQ3", {
      args: arguments
    });
  };
  _proto.merge = function merge2(source) {
    if (!source) {
      return this;
    }
    if (!canMerge(source)) {
      throw (0, _rxError.newRxTypeError)("MQ4", {
        source
      });
    }
    if (source instanceof NoSqlQueryBuilderClass2) {
      if (source._conditions)
        (0, _mqueryUtils.merge)(this._conditions, source._conditions);
      if (source._fields) {
        if (!this._fields)
          this._fields = {};
        (0, _mqueryUtils.merge)(this._fields, source._fields);
      }
      if (source.options) {
        if (!this.options)
          this.options = {};
        (0, _mqueryUtils.merge)(this.options, source.options);
      }
      if (source._distinct)
        this._distinct = source._distinct;
      return this;
    }
    (0, _mqueryUtils.merge)(this._conditions, source);
    return this;
  };
  _proto.find = function find2(criteria) {
    if (canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  _proto._ensurePath = function _ensurePath(method) {
    if (!this._path) {
      throw (0, _rxError.newRxError)("MQ5", {
        method
      });
    }
  };
  _proto.toJSON = function toJSON() {
    var query2 = {
      selector: this._conditions
    };
    if (this.options.skip) {
      query2.skip = this.options.skip;
    }
    if (this.options.limit) {
      query2.limit = this.options.limit;
    }
    if (this.options.sort) {
      query2.sort = mQuerySortToRxDBSort(this.options.sort);
    }
    return {
      query: query2,
      path: this._path
    };
  };
  return NoSqlQueryBuilderClass2;
}();
nosqlQueryBuilder.NoSqlQueryBuilderClass = NoSqlQueryBuilderClass;
function mQuerySortToRxDBSort(sort2) {
  return Object.entries(sort2).map(([k, v]) => {
    var direction = v === 1 ? "asc" : "desc";
    var part = {
      [k]: direction
    };
    return part;
  });
}
var OTHER_MANGO_ATTRIBUTES = ["limit", "skip", "maxScan", "batchSize", "comment"];
nosqlQueryBuilder.OTHER_MANGO_ATTRIBUTES = OTHER_MANGO_ATTRIBUTES;
OTHER_MANGO_ATTRIBUTES.forEach(function(method) {
  NoSqlQueryBuilderClass.prototype[method] = function(v) {
    this.options[method] = v;
    return this;
  };
});
var OTHER_MANGO_OPERATORS = ["gt", "gte", "lt", "lte", "ne", "in", "nin", "all", "regex", "size"];
nosqlQueryBuilder.OTHER_MANGO_OPERATORS = OTHER_MANGO_OPERATORS;
OTHER_MANGO_OPERATORS.forEach(function($conditional) {
  NoSqlQueryBuilderClass.prototype[$conditional] = function() {
    var path2;
    var val;
    if (1 === arguments.length) {
      this._ensurePath($conditional);
      val = arguments[0];
      path2 = this._path;
    } else {
      val = arguments[1];
      path2 = arguments[0];
    }
    var conds = this._conditions[path2] === null || typeof this._conditions[path2] === "object" ? this._conditions[path2] : this._conditions[path2] = {};
    conds["$" + $conditional] = val;
    return this;
  };
});
function push(opts, field, value) {
  if (Array.isArray(opts.sort)) {
    throw (0, _rxError.newRxTypeError)("MQ6", {
      opts,
      field,
      value
    });
  }
  if (value && value.$meta) {
    var sort2 = opts.sort || (opts.sort = {});
    sort2[field] = {
      $meta: value.$meta
    };
    return;
  }
  var val = String(value || 1).toLowerCase();
  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {
    if (Array.isArray(value))
      value = "[" + value + "]";
    throw (0, _rxError.newRxTypeError)("MQ7", {
      field,
      value
    });
  }
  var s = opts.sort || (opts.sort = {});
  var valueStr = value.toString().replace("asc", "1").replace("ascending", "1").replace("desc", "-1").replace("descending", "-1");
  s[field] = parseInt(valueStr, 10);
}
function _pushArr(opts, field, value) {
  opts.sort = opts.sort || [];
  if (!Array.isArray(opts.sort)) {
    throw (0, _rxError.newRxTypeError)("MQ8", {
      opts,
      field,
      value
    });
  }
  opts.sort.push([field, value]);
}
function canMerge(conds) {
  return conds instanceof NoSqlQueryBuilderClass || (0, _mqueryUtils.isObject)(conds);
}
function createQueryBuilder(query2, path2) {
  return new NoSqlQueryBuilderClass(query2, path2);
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    runBuildingStep: true,
    applyBuildingStep: true,
    RxDBQueryBuilderPlugin: true
  };
  exports.RxDBQueryBuilderPlugin = void 0;
  exports.applyBuildingStep = applyBuildingStep;
  exports.runBuildingStep = runBuildingStep;
  var _nosqlQueryBuilder = nosqlQueryBuilder;
  Object.keys(_nosqlQueryBuilder).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _nosqlQueryBuilder[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _nosqlQueryBuilder[key];
      }
    });
  });
  var _rxQuery2 = rxQuery;
  var _utils2 = utils;
  var RXQUERY_OTHER_FLAG = "queryBuilderPath";
  function runBuildingStep(rxQuery2, functionName, value) {
    var queryBuilder2 = (0, _nosqlQueryBuilder.createQueryBuilder)((0, _utils2.clone)(rxQuery2.mangoQuery), rxQuery2.other[RXQUERY_OTHER_FLAG]);
    queryBuilder2[functionName](value);
    var queryBuilderJson = queryBuilder2.toJSON();
    return (0, _rxQuery2.createRxQuery)(rxQuery2.op, queryBuilderJson.query, rxQuery2.collection, {
      ...rxQuery2.other,
      [RXQUERY_OTHER_FLAG]: queryBuilderJson.path
    });
  }
  function applyBuildingStep(proto, functionName) {
    proto[functionName] = function(value) {
      return runBuildingStep(this, functionName, value);
    };
  }
  var RxDBQueryBuilderPlugin = {
    name: "query-builder",
    rxdb: true,
    prototypes: {
      RxQuery(proto) {
        ["where", "equals", "eq", "or", "nor", "and", "mod", "exists", "elemMatch", "sort"].forEach((attribute) => {
          applyBuildingStep(proto, attribute);
        });
        _nosqlQueryBuilder.OTHER_MANGO_ATTRIBUTES.forEach((attribute) => {
          applyBuildingStep(proto, attribute);
        });
        _nosqlQueryBuilder.OTHER_MANGO_OPERATORS.forEach((operator) => {
          applyBuildingStep(proto, operator);
        });
      }
    }
  };
  exports.RxDBQueryBuilderPlugin = RxDBQueryBuilderPlugin;
})(queryBuilder);
var update$1 = {};
var clone$2 = { exports: {} };
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone)
    return clone$2.exports;
  hasRequiredClone = 1;
  (function(module) {
    var clone2 = function() {
      function _instanceof(obj, type2) {
        return type2 != null && obj instanceof type2;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone3(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve, reject) {
              parent2.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone3.__isArray(parent2)) {
            child = [];
          } else if (clone3.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone3.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i = 0; i < symbols.length; i++) {
              var symbol = symbols[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone3.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c = function() {
        };
        c.prototype = parent;
        return new c();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone3.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone3.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone3.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone3.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global)
          flags += "g";
        if (re.ignoreCase)
          flags += "i";
        if (re.multiline)
          flags += "m";
        return flags;
      }
      clone3.__getRegExpFlags = __getRegExpFlags;
      return clone3;
    }();
    if (module.exports) {
      module.exports = clone2;
    }
  })(clone$2);
  return clone$2.exports;
}
var isArguments$1;
var hasRequiredIsArguments$1;
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1)
    return isArguments$1;
  hasRequiredIsArguments$1 = 1;
  var toStr = Object.prototype.toString;
  isArguments$1 = function isArguments2(value) {
    var str = toStr.call(value);
    var isArgs = str === "[object Arguments]";
    if (!isArgs) {
      isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    }
    return isArgs;
  };
  return isArguments$1;
}
var implementation$3;
var hasRequiredImplementation$3;
function requireImplementation$3() {
  if (hasRequiredImplementation$3)
    return implementation$3;
  hasRequiredImplementation$3 = 1;
  var keysShim;
  if (!Object.keys) {
    var has = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isArgs = requireIsArguments$1();
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim = function keys2(object2) {
      var isObject2 = object2 !== null && typeof object2 === "object";
      var isFunction2 = toStr.call(object2) === "[object Function]";
      var isArguments2 = isArgs(object2);
      var isString = isObject2 && toStr.call(object2) === "[object String]";
      var theKeys = [];
      if (!isObject2 && !isFunction2 && !isArguments2) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString && object2.length > 0 && !has.call(object2, 0)) {
        for (var i = 0; i < object2.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments2 && object2.length > 0) {
        for (var j = 0; j < object2.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name in object2) {
          if (!(skipProto && name === "prototype") && has.call(object2, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object2, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$3 = keysShim;
  return implementation$3;
}
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys)
    return objectKeys;
  hasRequiredObjectKeys = 1;
  var slice2 = Array.prototype.slice;
  var isArgs = requireIsArguments$1();
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys2(o) {
    return origKeys(o);
  } : requireImplementation$3();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args2 = Object.keys(arguments);
        return args2 && args2.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys2(object2) {
          if (isArgs(object2)) {
            return originalKeys(slice2.call(object2));
          }
          return originalKeys(object2);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  objectKeys = keysShim;
  return objectKeys;
}
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1)
    return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var hasProto;
var hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto)
    return hasProto;
  hasRequiredHasProto = 1;
  var test = {
    foo: {}
  };
  var $Object = Object;
  hasProto = function hasProto2() {
    return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
  };
  return hasProto;
}
var implementation$2;
var hasRequiredImplementation$2;
function requireImplementation$2() {
  if (hasRequiredImplementation$2)
    return implementation$2;
  hasRequiredImplementation$2 = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice2 = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  implementation$2 = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args2 = slice2.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          args2.concat(slice2.call(arguments))
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(
          that,
          args2.concat(slice2.call(arguments))
        );
      }
    };
    var boundLength = Math.max(0, target.length - args2.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs.push("$" + i);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation$2;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation$2();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var src;
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  var bind = requireFunctionBind();
  src = bind.call(Function.call, Object.prototype.hasOwnProperty);
  return src;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError = TypeError;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var hasProto2 = requireHasProto()();
  var getProto2 = Object.getPrototypeOf || (hasProto2 ? function(x) {
    return x.__proto__;
  } : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn2 = requireSrc();
  var $concat2 = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace = bind.call(Function.call, String.prototype.replace);
  var $strSlice = bind.call(Function.call, String.prototype.slice);
  var $exec = bind.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string2) {
    var first2 = $strSlice(string2, 0, 1);
    var last2 = $strSlice(string2, -1);
    if (first2 === "%" && last2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last2 === "%" && first2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string2, rePropName, function(match2, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn2(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat2([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first2 = $strSlice(part, 0, 1);
      var last2 = $strSlice(part, -1);
      if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn2(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn2(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBind = { exports: {} };
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind)
    return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var bind = requireFunctionBind();
    var GetIntrinsic = requireGetIntrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max2 = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind2(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max2(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  })(callBind);
  return callBind.exports;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = requireCallBound();
  var $toString2 = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString2(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString2(value) !== "[object Array]" && $toString2(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors)
    return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
        return true;
      } catch (e) {
        return false;
      }
    }
    return false;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!hasPropertyDescriptors()) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd)
    return gopd;
  hasRequiredGopd = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty)
    return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var hasPropertyDescriptors = requireHasPropertyDescriptors()();
  var GetIntrinsic = requireGetIntrinsic();
  var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
  var $SyntaxError = GetIntrinsic("%SyntaxError%");
  var $TypeError = GetIntrinsic("%TypeError%");
  var gopd2 = requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var defineProperties_1;
var hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties)
    return defineProperties_1;
  hasRequiredDefineProperties = 1;
  var keys2 = requireObjectKeys();
  var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr = Object.prototype.toString;
  var concat2 = Array.prototype.concat;
  var defineDataProperty2 = requireDefineDataProperty();
  var isFunction2 = function(fn) {
    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
  };
  var supportsDescriptors = requireHasPropertyDescriptors()();
  var defineProperty2 = function(object2, name, value, predicate) {
    if (name in object2) {
      if (predicate === true) {
        if (object2[name] === value) {
          return;
        }
      } else if (!isFunction2(predicate) || !predicate()) {
        return;
      }
    }
    if (supportsDescriptors) {
      defineDataProperty2(object2, name, value, true);
    } else {
      defineDataProperty2(object2, name, value);
    }
  };
  var defineProperties = function(object2, map2) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props2 = keys2(map2);
    if (hasSymbols2) {
      props2 = concat2.call(props2, Object.getOwnPropertySymbols(map2));
    }
    for (var i = 0; i < props2.length; i += 1) {
      defineProperty2(object2, props2[i], map2[props2[i]], predicates[props2[i]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  defineProperties_1 = defineProperties;
  return defineProperties_1;
}
var implementation$1;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1)
    return implementation$1;
  hasRequiredImplementation$1 = 1;
  var numberIsNaN = function(value) {
    return value !== value;
  };
  implementation$1 = function is(a, b) {
    if (a === 0 && b === 0) {
      return 1 / a === 1 / b;
    }
    if (a === b) {
      return true;
    }
    if (numberIsNaN(a) && numberIsNaN(b)) {
      return true;
    }
    return false;
  };
  return implementation$1;
}
var polyfill$1;
var hasRequiredPolyfill$1;
function requirePolyfill$1() {
  if (hasRequiredPolyfill$1)
    return polyfill$1;
  hasRequiredPolyfill$1 = 1;
  var implementation2 = requireImplementation$1();
  polyfill$1 = function getPolyfill() {
    return typeof Object.is === "function" ? Object.is : implementation2;
  };
  return polyfill$1;
}
var shim$1;
var hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1)
    return shim$1;
  hasRequiredShim$1 = 1;
  var getPolyfill = requirePolyfill$1();
  var define = requireDefineProperties();
  shim$1 = function shimObjectIs() {
    var polyfill2 = getPolyfill();
    define(Object, { is: polyfill2 }, {
      is: function testObjectIs() {
        return Object.is !== polyfill2;
      }
    });
    return polyfill2;
  };
  return shim$1;
}
var objectIs;
var hasRequiredObjectIs;
function requireObjectIs() {
  if (hasRequiredObjectIs)
    return objectIs;
  hasRequiredObjectIs = 1;
  var define = requireDefineProperties();
  var callBind2 = requireCallBind();
  var implementation2 = requireImplementation$1();
  var getPolyfill = requirePolyfill$1();
  var shim2 = requireShim$1();
  var polyfill2 = callBind2(getPolyfill(), Object);
  define(polyfill2, {
    getPolyfill,
    implementation: implementation2,
    shim: shim2
  });
  objectIs = polyfill2;
  return objectIs;
}
var isRegex;
var hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex)
    return isRegex;
  hasRequiredIsRegex = 1;
  var callBound2 = requireCallBound();
  var hasToStringTag = requireShams()();
  var has;
  var $exec;
  var isRegexMarker;
  var badStringifier;
  if (hasToStringTag) {
    has = callBound2("Object.prototype.hasOwnProperty");
    $exec = callBound2("RegExp.prototype.exec");
    isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
  }
  var $toString2 = callBound2("Object.prototype.toString");
  var gOPD = Object.getOwnPropertyDescriptor;
  var regexClass = "[object RegExp]";
  isRegex = hasToStringTag ? function isRegex2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    var descriptor = gOPD(value, "lastIndex");
    var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
    if (!hasLastIndexDataProperty) {
      return false;
    }
    try {
      $exec(value, badStringifier);
    } catch (e) {
      return e === isRegexMarker;
    }
  } : function isRegex2(value) {
    if (!value || typeof value !== "object" && typeof value !== "function") {
      return false;
    }
    return $toString2(value) === regexClass;
  };
  return isRegex;
}
var functionsHaveNames_1;
var hasRequiredFunctionsHaveNames;
function requireFunctionsHaveNames() {
  if (hasRequiredFunctionsHaveNames)
    return functionsHaveNames_1;
  hasRequiredFunctionsHaveNames = 1;
  var functionsHaveNames = function functionsHaveNames2() {
    return typeof function f() {
    }.name === "string";
  };
  var gOPD = Object.getOwnPropertyDescriptor;
  if (gOPD) {
    try {
      gOPD([], "length");
    } catch (e) {
      gOPD = null;
    }
  }
  functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
    if (!functionsHaveNames() || !gOPD) {
      return false;
    }
    var desc = gOPD(function() {
    }, "name");
    return !!desc && !!desc.configurable;
  };
  var $bind = Function.prototype.bind;
  functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
    return functionsHaveNames() && typeof $bind === "function" && function f() {
    }.bind().name !== "";
  };
  functionsHaveNames_1 = functionsHaveNames;
  return functionsHaveNames_1;
}
var setFunctionName;
var hasRequiredSetFunctionName;
function requireSetFunctionName() {
  if (hasRequiredSetFunctionName)
    return setFunctionName;
  hasRequiredSetFunctionName = 1;
  var define = requireDefineDataProperty();
  var hasDescriptors = requireHasPropertyDescriptors()();
  var functionsHaveConfigurableNames = requireFunctionsHaveNames().functionsHaveConfigurableNames();
  var $TypeError = TypeError;
  setFunctionName = function setFunctionName2(fn, name) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    if (!loose || functionsHaveConfigurableNames) {
      if (hasDescriptors) {
        define(fn, "name", name, true, true);
      } else {
        define(fn, "name", name);
      }
    }
    return fn;
  };
  return setFunctionName;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var setFunctionName2 = requireSetFunctionName();
  var $Object = Object;
  var $TypeError = TypeError;
  implementation = setFunctionName2(function flags() {
    if (this != null && this !== $Object(this)) {
      throw new $TypeError("RegExp.prototype.flags getter called on non-object");
    }
    var result = "";
    if (this.hasIndices) {
      result += "d";
    }
    if (this.global) {
      result += "g";
    }
    if (this.ignoreCase) {
      result += "i";
    }
    if (this.multiline) {
      result += "m";
    }
    if (this.dotAll) {
      result += "s";
    }
    if (this.unicode) {
      result += "u";
    }
    if (this.unicodeSets) {
      result += "v";
    }
    if (this.sticky) {
      result += "y";
    }
    return result;
  }, "get flags", true);
  return implementation;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill)
    return polyfill;
  hasRequiredPolyfill = 1;
  var implementation2 = requireImplementation();
  var supportsDescriptors = requireDefineProperties().supportsDescriptors;
  var $gOPD = Object.getOwnPropertyDescriptor;
  polyfill = function getPolyfill() {
    if (supportsDescriptors && /a/mig.flags === "gim") {
      var descriptor = $gOPD(RegExp.prototype, "flags");
      if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
        var calls = "";
        var o = {};
        Object.defineProperty(o, "hasIndices", {
          get: function() {
            calls += "d";
          }
        });
        Object.defineProperty(o, "sticky", {
          get: function() {
            calls += "y";
          }
        });
        if (calls === "dy") {
          return descriptor.get;
        }
      }
    }
    return implementation2;
  };
  return polyfill;
}
var shim;
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim)
    return shim;
  hasRequiredShim = 1;
  var supportsDescriptors = requireDefineProperties().supportsDescriptors;
  var getPolyfill = requirePolyfill();
  var gOPD = Object.getOwnPropertyDescriptor;
  var defineProperty2 = Object.defineProperty;
  var TypeErr = TypeError;
  var getProto2 = Object.getPrototypeOf;
  var regex2 = /a/;
  shim = function shimFlags() {
    if (!supportsDescriptors || !getProto2) {
      throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    }
    var polyfill2 = getPolyfill();
    var proto = getProto2(regex2);
    var descriptor = gOPD(proto, "flags");
    if (!descriptor || descriptor.get !== polyfill2) {
      defineProperty2(proto, "flags", {
        configurable: true,
        enumerable: false,
        get: polyfill2
      });
    }
    return polyfill2;
  };
  return shim;
}
var regexp_prototype_flags;
var hasRequiredRegexp_prototype_flags;
function requireRegexp_prototype_flags() {
  if (hasRequiredRegexp_prototype_flags)
    return regexp_prototype_flags;
  hasRequiredRegexp_prototype_flags = 1;
  var define = requireDefineProperties();
  var callBind2 = requireCallBind();
  var implementation2 = requireImplementation();
  var getPolyfill = requirePolyfill();
  var shim2 = requireShim();
  var flagsBound = callBind2(getPolyfill());
  define(flagsBound, {
    getPolyfill,
    implementation: implementation2,
    shim: shim2
  });
  regexp_prototype_flags = flagsBound;
  return regexp_prototype_flags;
}
var isDateObject;
var hasRequiredIsDateObject;
function requireIsDateObject() {
  if (hasRequiredIsDateObject)
    return isDateObject;
  hasRequiredIsDateObject = 1;
  var getDay = Date.prototype.getDay;
  var tryDateObject = function tryDateGetDayCall(value) {
    try {
      getDay.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var dateClass = "[object Date]";
  var hasToStringTag = requireShams()();
  isDateObject = function isDateObject2(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
  };
  return isDateObject;
}
var deepEqual_1;
var hasRequiredDeepEqual;
function requireDeepEqual() {
  if (hasRequiredDeepEqual)
    return deepEqual_1;
  hasRequiredDeepEqual = 1;
  var objectKeys2 = requireObjectKeys();
  var isArguments2 = requireIsArguments();
  var is = requireObjectIs();
  var isRegex2 = requireIsRegex();
  var flags = requireRegexp_prototype_flags();
  var isDate2 = requireIsDateObject();
  var getTime = Date.prototype.getTime;
  function deepEqual2(actual, expected, options2) {
    var opts = options2 || {};
    if (opts.strict ? is(actual, expected) : actual === expected) {
      return true;
    }
    if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
      return opts.strict ? is(actual, expected) : actual == expected;
    }
    return objEquiv(actual, expected, opts);
  }
  function isUndefinedOrNull(value) {
    return value === null || value === void 0;
  }
  function isBuffer(x) {
    if (!x || typeof x !== "object" || typeof x.length !== "number") {
      return false;
    }
    if (typeof x.copy !== "function" || typeof x.slice !== "function") {
      return false;
    }
    if (x.length > 0 && typeof x[0] !== "number") {
      return false;
    }
    return true;
  }
  function objEquiv(a, b, opts) {
    var i, key;
    if (typeof a !== typeof b) {
      return false;
    }
    if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
      return false;
    }
    if (a.prototype !== b.prototype) {
      return false;
    }
    if (isArguments2(a) !== isArguments2(b)) {
      return false;
    }
    var aIsRegex = isRegex2(a);
    var bIsRegex = isRegex2(b);
    if (aIsRegex !== bIsRegex) {
      return false;
    }
    if (aIsRegex || bIsRegex) {
      return a.source === b.source && flags(a) === flags(b);
    }
    if (isDate2(a) && isDate2(b)) {
      return getTime.call(a) === getTime.call(b);
    }
    var aIsBuffer = isBuffer(a);
    var bIsBuffer = isBuffer(b);
    if (aIsBuffer !== bIsBuffer) {
      return false;
    }
    if (aIsBuffer || bIsBuffer) {
      if (a.length !== b.length) {
        return false;
      }
      for (i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    try {
      var ka = objectKeys2(a);
      var kb = objectKeys2(b);
    } catch (e) {
      return false;
    }
    if (ka.length !== kb.length) {
      return false;
    }
    ka.sort();
    kb.sort();
    for (i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i]) {
        return false;
      }
    }
    for (i = ka.length - 1; i >= 0; i--) {
      key = ka[i];
      if (!deepEqual2(a[key], b[key], opts)) {
        return false;
      }
    }
    return true;
  }
  deepEqual_1 = deepEqual2;
  return deepEqual_1;
}
var bundle;
var hasRequiredBundle;
function requireBundle() {
  if (hasRequiredBundle)
    return bundle;
  hasRequiredBundle = 1;
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var clone2 = _interopDefault(requireClone());
  var equal = _interopDefault(requireDeepEqual());
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var isObject2 = function(variableToCheck) {
    return (typeof variableToCheck === "undefined" ? "undefined" : _typeof2(variableToCheck)) === "object" && variableToCheck !== null;
  };
  var every2 = function(arrayToIterate, cb) {
    return arrayToIterate.every(function(elem) {
      return cb && cb(elem) || elem;
    });
  };
  var has = function(objectWithKeys, key) {
    return objectWithKeys.hasOwnProperty(key);
  };
  var keys2 = function(objectWithKeys) {
    return Object.keys(objectWithKeys);
  };
  var each = function(objectToIterate, cb) {
    Object.keys(objectToIterate).forEach(function(key) {
      cb(objectToIterate[key], key);
    });
  };
  var libIsArray = function(variableToCheck) {
    return Array.isArray(variableToCheck);
  };
  var isBinary = function(variableToCheck) {
    return !!(typeof Uint8Array !== "undefined" && variableToCheck instanceof Uint8Array || variableToCheck && variableToCheck.$Uint8ArrayPolyfill);
  };
  var _$1 = { isArray: libIsArray, each };
  var isArray2 = function isArray3(x) {
    return _$1.isArray(x) && !isBinary(x);
  };
  var isIndexable = function isIndexable2(x) {
    return isArray2(x) || isPlainObject(x);
  };
  var isOperatorObject = function isOperatorObject2(valueSelector, inconsistentOK) {
    if (!isPlainObject(valueSelector))
      return false;
    var theseAreOperators = void 0;
    _$1.each(valueSelector, function(value, selKey) {
      var thisIsOperator = selKey.substr(0, 1) === "$";
      if (theseAreOperators === void 0) {
        theseAreOperators = thisIsOperator;
      } else if (theseAreOperators !== thisIsOperator) {
        if (!inconsistentOK)
          throw new Error("Inconsistent operator: " + JSON.stringify(valueSelector));
        theseAreOperators = false;
      }
    });
    return !!theseAreOperators;
  };
  var isNumericKey = function isNumericKey2(s) {
    return /^[0-9]+$/.test(s);
  };
  var isPlainObject = function(variableToCheck) {
    if (!variableToCheck)
      return false;
    if (typeof variableToCheck === "number")
      return false;
    if (typeof variableToCheck === "string")
      return false;
    if (typeof variableToCheck === "boolean")
      return false;
    if (isArray2(variableToCheck))
      return false;
    if (variableToCheck === null)
      return false;
    if (variableToCheck instanceof RegExp)
      return false;
    if (typeof variableToCheck === "function")
      return false;
    if (variableToCheck instanceof Date)
      return false;
    if (isBinary(variableToCheck))
      return false;
    return true;
  };
  var ModifyJsError = function(message) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof message === "string" && options2.field) {
      message += " for field '" + options2.field + "'";
    }
    var e = new Error(message);
    e.name = "ModifyJsError";
    return e;
  };
  var _ = { all: every2, each, keys: keys2, has, isObject: isObject2 };
  var modify = function(doc, mod2, options2) {
    if (options2 && options2.each) {
      return;
    }
    return _modify(doc, mod2, _extends({}, options2, { returnInsteadOfReplacing: true }));
  };
  var _modify = function _modify2(doc, mod2, options2) {
    options2 = options2 || {};
    if (!isPlainObject(mod2))
      throw ModifyJsError("Modifier must be an object");
    mod2 = clone2(mod2);
    var isModifier = isOperatorObject(mod2);
    var newDoc;
    if (!isModifier) {
      newDoc = mod2;
    } else {
      newDoc = clone2(doc);
      _.each(mod2, function(operand, op) {
        var modFunc = MODIFIERS[op];
        if (!modFunc)
          throw ModifyJsError("Invalid modifier specified " + op);
        _.each(operand, function(arg, keypath) {
          if (keypath === "") {
            throw ModifyJsError("An empty update path is not valid.");
          }
          var keyparts = keypath.split(".");
          if (!_.all(keyparts)) {
            throw ModifyJsError("The update path '" + keypath + "' contains an empty field name, which is not allowed.");
          }
          var target = findModTarget(newDoc, keyparts, {
            noCreate: NO_CREATE_MODIFIERS[op],
            forbidArray: op === "$rename",
            arrayIndices: options2.arrayIndices
          });
          var field = keyparts.pop();
          modFunc(target, field, arg, keypath, newDoc);
        });
      });
    }
    if (options2.returnInsteadOfReplacing) {
      return newDoc;
    } else {
      _.each(_.keys(doc), function(k) {
        if (k !== "_id")
          delete doc[k];
      });
      _.each(newDoc, function(v, k) {
        doc[k] = v;
      });
    }
  };
  var findModTarget = function findModTarget2(doc, keyparts, options2) {
    options2 = options2 || {};
    var usedArrayIndex = false;
    for (var i = 0; i < keyparts.length; i++) {
      var last2 = i === keyparts.length - 1;
      var keypart = keyparts[i];
      var indexable = isIndexable(doc);
      if (!indexable) {
        if (options2.noCreate)
          return void 0;
        var e = ModifyJsError("cannot use the part '" + keypart + "' to traverse " + doc);
        e.setPropertyError = true;
        throw e;
      }
      if (doc instanceof Array) {
        if (options2.forbidArray)
          return null;
        if (keypart === "$") {
          if (usedArrayIndex)
            throw ModifyJsError("Too many positional (i.e. '$') elements");
          if (!options2.arrayIndices || !options2.arrayIndices.length) {
            throw ModifyJsError("The positional operator did not find the match needed from the query");
          }
          keypart = options2.arrayIndices[0];
          usedArrayIndex = true;
        } else if (isNumericKey(keypart)) {
          keypart = parseInt(keypart);
        } else {
          if (options2.noCreate)
            return void 0;
          throw ModifyJsError("can't append to array using string field name [" + keypart + "]");
        }
        if (last2)
          keyparts[i] = keypart;
        if (options2.noCreate && keypart >= doc.length)
          return void 0;
        while (doc.length < keypart) {
          doc.push(null);
        }
        if (!last2) {
          if (doc.length === keypart)
            doc.push({});
          else if (_typeof2(doc[keypart]) !== "object")
            throw ModifyJsError("can't modify field '" + keyparts[i + 1] + "' of list value " + JSON.stringify(doc[keypart]));
        }
      } else {
        if (!(keypart in doc)) {
          if (options2.noCreate)
            return void 0;
          if (!last2)
            doc[keypart] = {};
        }
      }
      if (last2)
        return doc;
      doc = doc[keypart];
    }
  };
  var NO_CREATE_MODIFIERS = {
    $unset: true,
    $pop: true,
    $rename: true,
    $pull: true,
    $pullAll: true
  };
  var MODIFIERS = {
    $currentDate: function $currentDate(target, field, arg) {
      if ((typeof arg === "undefined" ? "undefined" : _typeof2(arg)) === "object" && arg.hasOwnProperty("$type")) {
        if (arg.$type !== "date") {
          throw ModifyJsError("Minimongo does currently only support the date type in $currentDate modifiers", { field });
        }
      } else if (arg !== true) {
        throw ModifyJsError("Invalid $currentDate modifier", { field });
      }
      target[field] = /* @__PURE__ */ new Date();
    },
    $min: function $min2(target, field, arg) {
      if (typeof arg !== "number") {
        throw ModifyJsError("Modifier $min allowed for numbers only", { field });
      }
      if (field in target) {
        if (typeof target[field] !== "number") {
          throw ModifyJsError("Cannot apply $min modifier to non-number", { field });
        }
        if (target[field] > arg) {
          target[field] = arg;
        }
      } else {
        target[field] = arg;
      }
    },
    $max: function $max2(target, field, arg) {
      if (typeof arg !== "number") {
        throw ModifyJsError("Modifier $max allowed for numbers only", { field });
      }
      if (field in target) {
        if (typeof target[field] !== "number") {
          throw ModifyJsError("Cannot apply $max modifier to non-number", { field });
        }
        if (target[field] < arg) {
          target[field] = arg;
        }
      } else {
        target[field] = arg;
      }
    },
    $inc: function $inc(target, field, arg) {
      if (typeof arg !== "number")
        throw ModifyJsError("Modifier $inc allowed for numbers only", { field });
      if (field in target) {
        if (typeof target[field] !== "number")
          throw ModifyJsError("Cannot apply $inc modifier to non-number", { field });
        target[field] += arg;
      } else {
        target[field] = arg;
      }
    },
    $set: function $set(target, field, arg) {
      if (!_.isObject(target)) {
        var e = ModifyJsError("Cannot set property on non-object field", { field });
        e.setPropertyError = true;
        throw e;
      }
      if (target === null) {
        var e = ModifyJsError("Cannot set property on null", { field });
        e.setPropertyError = true;
        throw e;
      }
      target[field] = arg;
    },
    $setOnInsert: function $setOnInsert(target, field, arg) {
    },
    $unset: function $unset2(target, field, arg) {
      if (target !== void 0) {
        if (target instanceof Array) {
          if (field in target)
            target[field] = null;
        } else
          delete target[field];
      }
    },
    $push: function $push2(target, field, arg) {
      if (target[field] === void 0)
        target[field] = [];
      if (!(target[field] instanceof Array))
        throw ModifyJsError("Cannot apply $push modifier to non-array", { field });
      if (!(arg && arg.$each)) {
        target[field].push(arg);
        return;
      }
      var toPush = arg.$each;
      if (!(toPush instanceof Array))
        throw ModifyJsError("$each must be an array", { field });
      var position = void 0;
      if ("$position" in arg) {
        if (typeof arg.$position !== "number")
          throw ModifyJsError("$position must be a numeric value", { field });
        if (arg.$position < 0)
          throw ModifyJsError("$position in $push must be zero or positive", { field });
        position = arg.$position;
      }
      var slice2 = void 0;
      if ("$slice" in arg) {
        if (typeof arg.$slice !== "number")
          throw ModifyJsError("$slice must be a numeric value", { field });
        if (arg.$slice > 0)
          throw ModifyJsError("$slice in $push must be zero or negative", { field });
        slice2 = arg.$slice;
      }
      if (arg.$sort) {
        throw ModifyJsError("$sort in $push not implemented yet");
      }
      if (position === void 0) {
        for (var j = 0; j < toPush.length; j++) {
          target[field].push(toPush[j]);
        }
      } else {
        var spliceArguments = [position, 0];
        for (var j = 0; j < toPush.length; j++) {
          spliceArguments.push(toPush[j]);
        }
        Array.prototype.splice.apply(target[field], spliceArguments);
      }
      if (slice2 !== void 0) {
        if (slice2 === 0)
          target[field] = [];
        else
          target[field] = target[field].slice(slice2);
      }
    },
    $pushAll: function $pushAll(target, field, arg) {
      if (!((typeof arg === "undefined" ? "undefined" : _typeof2(arg)) === "object" && arg instanceof Array))
        throw ModifyJsError("Modifier $pushAll/pullAll allowed for arrays only");
      var x = target[field];
      if (x === void 0)
        target[field] = arg;
      else if (!(x instanceof Array))
        throw ModifyJsError("Cannot apply $pushAll modifier to non-array", { field });
      else {
        for (var i = 0; i < arg.length; i++) {
          x.push(arg[i]);
        }
      }
    },
    $addToSet: function $addToSet2(target, field, arg) {
      var isEach = false;
      if ((typeof arg === "undefined" ? "undefined" : _typeof2(arg)) === "object") {
        var _keys = Object.keys(arg);
        if (_keys[0] === "$each") {
          isEach = true;
        }
      }
      var values = isEach ? arg["$each"] : [arg];
      var x = target[field];
      if (x === void 0)
        target[field] = values;
      else if (!(x instanceof Array))
        throw ModifyJsError("Cannot apply $addToSet modifier to non-array", { field });
      else {
        _.each(values, function(value) {
          for (var i = 0; i < x.length; i++) {
            if (equal(value, x[i]))
              return;
          }
          x.push(value);
        });
      }
    },
    $pop: function $pop(target, field, arg) {
      if (target === void 0)
        return;
      var x = target[field];
      if (x === void 0)
        return;
      else if (!(x instanceof Array))
        throw ModifyJsError("Cannot apply $pop modifier to non-array", { field });
      else {
        if (typeof arg === "number" && arg < 0)
          x.splice(0, 1);
        else
          x.pop();
      }
    },
    $pull: function $pull(target, field, arg) {
      if (target === void 0)
        return;
      var x = target[field];
      if (x === void 0)
        return;
      else if (!(x instanceof Array))
        throw ModifyJsError("Cannot apply $pull/pullAll modifier to non-array", { field });
      else {
        throw ModifyJsError("$pull not implemented yet");
      }
    },
    $pullAll: function $pullAll(target, field, arg) {
      if (!((typeof arg === "undefined" ? "undefined" : _typeof2(arg)) === "object" && arg instanceof Array))
        throw ModifyJsError("Modifier $pushAll/pullAll allowed for arrays only", { field });
      if (target === void 0)
        return;
      var x = target[field];
      if (x === void 0)
        return;
      else if (!(x instanceof Array))
        throw ModifyJsError("Cannot apply $pull/pullAll modifier to non-array", { field });
      else {
        var out2 = [];
        for (var i = 0; i < x.length; i++) {
          var exclude = false;
          for (var j = 0; j < arg.length; j++) {
            if (equal(x[i], arg[j])) {
              exclude = true;
              break;
            }
          }
          if (!exclude)
            out2.push(x[i]);
        }
        target[field] = out2;
      }
    },
    $rename: function $rename(target, field, arg, keypath, doc) {
      if (keypath === arg)
        throw ModifyJsError("$rename source must differ from target", { field });
      if (target === null)
        throw ModifyJsError("$rename source field invalid", { field });
      if (typeof arg !== "string")
        throw ModifyJsError("$rename target must be a string", { field });
      if (arg.indexOf("\0") > -1) {
        throw ModifyJsError("The 'to' field for $rename cannot contain an embedded null byte", { field });
      }
      if (target === void 0)
        return;
      var v = target[field];
      delete target[field];
      var keyparts = arg.split(".");
      var target2 = findModTarget(doc, keyparts, { forbidArray: true });
      if (target2 === null)
        throw ModifyJsError("$rename target field invalid", { field });
      var field2 = keyparts.pop();
      target2[field2] = v;
    },
    $bit: function $bit(target, field, arg) {
      throw ModifyJsError("$bit is not supported", { field });
    }
  };
  bundle = modify;
  return bundle;
}
var _interopRequireDefault = interopRequireDefaultExports$1;
Object.defineProperty(update$1, "__esModule", {
  value: true
});
var RxDBUpdatePlugin_1 = update$1.RxDBUpdatePlugin = void 0;
update$1.RxQueryUpdate = RxQueryUpdate;
update$1.incrementalUpdate = incrementalUpdate;
update$1.update = update;
var _modifyjs = _interopRequireDefault(requireBundle());
function incrementalUpdate(updateObj) {
  return this.incrementalModify((docData) => {
    var newDocData = (0, _modifyjs.default)(docData, updateObj);
    return newDocData;
  });
}
function update(updateObj) {
  var oldDocData = this._data;
  var newDocData = (0, _modifyjs.default)(oldDocData, updateObj);
  return this._saveData(newDocData, oldDocData);
}
function RxQueryUpdate(updateObj) {
  return this.exec().then((docs) => {
    if (!docs) {
      return null;
    }
    if (Array.isArray(docs)) {
      return Promise.all(docs.map((doc) => doc.update(updateObj))).then(() => docs);
    } else {
      return docs.update(updateObj).then(() => docs);
    }
  });
}
var RxDBUpdatePlugin = {
  name: "update",
  rxdb: true,
  prototypes: {
    RxDocument: (proto) => {
      proto.update = update;
      proto.incrementalUpdate = incrementalUpdate;
    },
    RxQuery: (proto) => {
      proto.update = RxQueryUpdate;
    }
  }
};
RxDBUpdatePlugin_1 = update$1.RxDBUpdatePlugin = RxDBUpdatePlugin;
const draftSchema = {
  title: "draft schema",
  description: "describes draft",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    customer: {
      id: {
        type: "string"
      },
      name: {
        type: "string"
      },
      phone: {
        type: "string"
      }
    },
    amount: {
      type: "number"
    },
    items: [
      {
        name: {
          type: "string"
        },
        image: {
          type: "string"
        },
        quantity: {
          type: "number"
        },
        unitPrice: {
          type: "number"
        }
      }
    ],
    timestamp: {
      type: "date-time"
    }
  },
  required: ["id", "items", "customer", "amount", "timestamp"]
};
const categorySchema = {
  title: "category",
  description: "describes categories",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    business_id: {
      type: "string"
    },
    category_type: {
      type: "string"
    },
    created_at: {
      type: "string"
    },
    created_by: {
      type: "string"
    },
    deleted_at: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    description: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    name: {
      type: "string"
    },
    parent_id: {
      type: "string"
    },
    short_code: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    slug: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    sub_categories: {
      type: "array"
    },
    updated_at: {
      type: "string"
    },
    woocommerce_cat_id: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    }
  }
};
const authSchema = {
  title: "authentication schema",
  description: "describes authentication",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    username: {
      type: "string"
    },
    password: {
      type: "string"
    },
    lastLogin: {
      type: "date-time"
    }
  },
  required: ["id", "username", "password", "lastLogin"]
};
const paymentMethodSchema = {
  title: "payment method schema",
  description: "describes payment method",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    methods: {
      cash: {
        type: "string"
      },
      card: {
        type: "string"
      },
      cheque: {
        type: "string"
      },
      bank_transfer: {
        type: "string"
      },
      custom_pay_1: {
        type: "string"
      },
      custom_pay_2: {
        type: "string"
      },
      custom_pay_3: {
        type: "string"
      },
      custom_pay_4: {
        type: "string"
      },
      custom_pay_5: {
        type: "string"
      },
      custom_pay_6: {
        type: "string"
      },
      custom_pay_7: {
        type: "string"
      },
      other: {
        type: "string"
      }
    },
    timestamp: {
      type: "date-time"
    }
  },
  required: [
    "id",
    "cash",
    "card",
    "cheque",
    "bank_transfer",
    "other",
    "timestamp"
  ]
};
const businessLocationSchema = {
  title: "businesslocation",
  description: "describes business locations",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    business_id: {
      type: "string"
    },
    city: {
      type: "string"
    },
    country: {
      type: "string"
    },
    created_at: {
      type: "string"
    },
    email: {
      type: "string"
    },
    landmark: {
      type: "string"
    },
    location_id: {
      type: "string"
    },
    mobile: {
      type: "string"
    },
    name: {
      type: "string"
    },
    state: {
      type: "string"
    },
    updated_at: {
      type: "string"
    },
    is_active: {
      type: "string"
    },
    print_receipt_on_invoice: {
      type: "string"
    },
    zip_code: {
      type: "string"
    },
    payment_methods: {
      type: "array"
    },
    timestamp: {
      type: "date-time"
    }
  }
};
const cashRegisterSchema = {
  title: "cash register schema",
  description: "describes cash register",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    location_id: {
      type: "number"
    },
    initial_amount: {
      type: "number"
    },
    created_at: {
      type: "string"
    },
    closed_at: {
      type: "string"
    },
    status: {
      type: "string"
    },
    closing_amount: {
      type: "number"
    },
    total_card_slips: {
      type: "number"
    },
    total_cheques: {
      type: "number"
    },
    closing_note: {
      type: "string"
    },
    transaction_ids: {
      type: "string"
    }
  },
  required: ["id", "location_id", "initial_amount", "created_at", "status"]
};
const stockSchema = {
  title: "stock schema",
  description: "describes product stock report",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    alert_quantity: {
      type: "string"
    },
    category_name: {
      type: "string"
    },
    enable_stock: {
      type: "string"
    },
    location_id: {
      type: "string"
    },
    location_name: {
      type: "string"
    },
    product: {
      type: "string"
    },
    product_id: {
      type: "string"
    },
    product_variation: {
      type: "string"
    },
    sku: {
      type: "string"
    },
    stock: {
      type: "string"
    },
    stock_price: {
      type: "string"
    },
    total_adjusted: {
      type: ["string", "null", "number"],
      // This property can be a string or null
      nullable: true
    },
    total_sold: {
      type: "string"
    },
    total_transfered: {
      type: ["string", "null", "number"],
      // This property can be a string or null
      nullable: true
    },
    type: {
      type: "string"
    },
    unit: {
      type: "string"
    },
    unit_price: {
      type: "string"
    },
    variation_id: {
      type: "string"
    },
    variation_name: {
      type: "string"
    }
  }
};
const productSchema = {
  title: "product",
  description: "describes product",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    alert_quantity: {
      type: "string"
    },
    barcode_type: {
      type: "string"
    },
    brand: {
      type: ["string", "null"],
      nullable: true
    },
    business_id: {
      type: "string"
    },
    category: {
      type: "object",
      properties: {
        type: "ref",
        ref: "category"
      }
    },
    created_by: {
      type: "string"
    },
    enable_sr_no: {
      type: "string"
    },
    enable_stock: {
      type: "string"
    },
    expiry_period: {
      type: ["string", "null"],
      nullable: true
    },
    image: {
      type: "string"
    },
    image_url: {
      type: "string"
    },
    is_inactive: {
      type: "string"
    },
    name: {
      type: "string"
    },
    not_for_selling: {
      type: "string"
    },
    product_description: {
      type: ["string", "null"],
      nullable: true
    },
    product_locations: {
      type: "array",
      items: {
        type: "string",
        ref: "businesslocation"
      }
    },
    product_tax: {
      type: ["string", "null"],
      nullable: true
    },
    product_variations: {
      type: "array",
      items: {
        type: "string",
        ref: "product_variation"
      }
    },
    sku: {
      type: "string"
    },
    sub_category: {
      type: "string"
    },
    type: {
      type: "string"
    },
    warranty_id: {
      type: ["string", "null"],
      nullable: true
    },
    unit: {
      type: "array"
    },
    weight: {
      type: ["string", "null"],
      nullable: true
    }
  }
};
const userSchema = {
  title: "user_schema",
  description: "describes user",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    username: {
      type: "string"
    },
    first_name: {
      type: "string"
    },
    surname: {
      type: "string"
    },
    last_name: {
      type: "string"
    },
    email: {
      type: "string"
    },
    user_type: {
      type: "string"
    },
    crm_contact_id: {
      type: "string"
    },
    allow_login: {
      type: "number"
    },
    cmmsn_percent: {
      type: "string"
    },
    max_sales_discount_percent: {
      type: "string"
    },
    dob: {
      type: "string"
    },
    gender: {
      type: "string"
    },
    marital_status: {
      type: "string"
    },
    blood_group: {
      type: "string"
    },
    alt_number: {
      type: "string"
    },
    contact_number: {
      type: "string"
    },
    family_number: {
      type: "string"
    },
    fb_link: {
      type: "string"
    },
    twitter_link: {
      type: "string"
    },
    id_proof_number: {
      type: "string"
    },
    permanent_address: {
      type: "string"
    },
    current_address: {
      type: "string"
    },
    status: {
      type: "string"
    }
  },
  required: [
    "id",
    "gender",
    "dob",
    "email",
    "first_name",
    "last_name",
    "contact_number",
    "permanent_address"
  ]
};
lib$2.addRxPlugin(queryBuilder.RxDBQueryBuilderPlugin);
lib$2.addRxPlugin(devMode.RxDBDevModePlugin);
lib$2.addRxPlugin(RxDBUpdatePlugin_1);
async function getDatabase(name) {
  try {
    const db2 = await lib$2.createRxDatabase({
      name,
      storage: storageDexie.getRxStorageDexie({
        indexedDB: fakeIndexedDB,
        IDBKeyRange: FDBKeyRange
      }),
      ignoreDuplicate: true
    });
    await db2.addCollections({
      business_locations: {
        schema: businessLocationSchema
      }
    });
    await db2.addCollections({
      cash_registers: {
        schema: cashRegisterSchema
      }
    });
    await db2.addCollections({
      product_stock_reports: {
        schema: stockSchema
      }
    });
    await db2.addCollections({
      products: {
        schema: productSchema
      }
    });
    await db2.addCollections({
      carts: {
        schema: cartSchema
      }
    });
    await db2.addCollections({
      drafts: {
        schema: draftSchema
      }
    });
    await db2.addCollections({
      categories: {
        schema: categorySchema
      }
    });
    await db2.addCollections({
      auth: {
        schema: authSchema
      }
    });
    await db2.addCollections({
      paymentmethods: {
        schema: paymentMethodSchema
      }
    });
    await db2.addCollections({
      users: {
        schema: userSchema
      }
    });
    return db2;
  } catch (error) {
    console.log("CAUGHT ERROR", error);
  }
}
var jsonc$2 = { exports: {} };
var jsonc$1 = {};
var fastSafeStringify = stringify;
stringify.default = stringify;
stringify.stable = deterministicStringify;
stringify.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = "[Circular]";
var arr = [];
var replacerStack = [];
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function stringify(obj, replacer, spacer, options2) {
  if (typeof options2 === "undefined") {
    options2 = defaultOptions();
  }
  decirc(obj, "", 0, [], void 0, 0, options2);
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer);
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function setReplace(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options2) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options2);
      }
    } else {
      var keys2 = Object.keys(val);
      for (i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        decirc(val[key], key, i, stack, val, depth, options2);
      }
    }
    stack.pop();
  }
}
function compareFunction(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function deterministicStringify(obj, replacer, spacer, options2) {
  if (typeof options2 === "undefined") {
    options2 = defaultOptions();
  }
  var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options2) || obj;
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
    }
  } catch (_) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options2) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    try {
      if (typeof val.toJSON === "function") {
        return;
      }
    } catch (_) {
      return;
    }
    if (typeof options2.depthLimit !== "undefined" && depth > options2.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options2.edgesLimit !== "undefined" && edgeIndex + 1 > options2.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options2);
      }
    } else {
      var tmp = {};
      var keys2 = Object.keys(val).sort(compareFunction);
      for (i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        deterministicDecirc(val[key], key, i, stack, val, depth, options2);
        tmp[key] = val[key];
      }
      if (typeof parent !== "undefined") {
        arr.push([parent, k, val]);
        parent[k] = tmp;
      } else {
        return tmp;
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
    return v;
  };
  return function(key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}
var isArrayish$1 = function isArrayish(obj) {
  if (!obj) {
    return false;
  }
  return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && obj.splice instanceof Function;
};
var util$1 = require$$3;
var isArrayish2 = isArrayish$1;
var errorEx$1 = function errorEx(name, properties) {
  if (!name || name.constructor !== String) {
    properties = name || {};
    name = Error.name;
  }
  var errorExError = function ErrorEXError(message) {
    if (!this) {
      return new ErrorEXError(message);
    }
    message = message instanceof Error ? message.message : message || this.message;
    Error.call(this, message);
    Error.captureStackTrace(this, errorExError);
    this.name = name;
    Object.defineProperty(this, "message", {
      configurable: true,
      enumerable: false,
      get: function() {
        var newMessage = message.split(/\r?\n/g);
        for (var key in properties) {
          if (!properties.hasOwnProperty(key)) {
            continue;
          }
          var modifier = properties[key];
          if ("message" in modifier) {
            newMessage = modifier.message(this[key], newMessage) || newMessage;
            if (!isArrayish2(newMessage)) {
              newMessage = [newMessage];
            }
          }
        }
        return newMessage.join("\n");
      },
      set: function(v) {
        message = v;
      }
    });
    var overwrittenStack = null;
    var stackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
    var stackGetter = stackDescriptor.get;
    var stackValue = stackDescriptor.value;
    delete stackDescriptor.value;
    delete stackDescriptor.writable;
    stackDescriptor.set = function(newstack) {
      overwrittenStack = newstack;
    };
    stackDescriptor.get = function() {
      var stack = (overwrittenStack || (stackGetter ? stackGetter.call(this) : stackValue)).split(/\r?\n+/g);
      if (!overwrittenStack) {
        stack[0] = this.name + ": " + this.message;
      }
      var lineCount = 1;
      for (var key in properties) {
        if (!properties.hasOwnProperty(key)) {
          continue;
        }
        var modifier = properties[key];
        if ("line" in modifier) {
          var line = modifier.line(this[key]);
          if (line) {
            stack.splice(lineCount++, 0, "    " + line);
          }
        }
        if ("stack" in modifier) {
          modifier.stack(this[key], stack);
        }
      }
      return stack.join("\n");
    };
    Object.defineProperty(this, "stack", stackDescriptor);
  };
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(errorExError.prototype, Error.prototype);
    Object.setPrototypeOf(errorExError, Error);
  } else {
    util$1.inherits(errorExError, Error);
  }
  return errorExError;
};
errorEx$1.append = function(str, def) {
  return {
    message: function(v, message) {
      v = v || def;
      if (v) {
        message[0] += " " + str.replace("%s", v.toString());
      }
      return message;
    }
  };
};
errorEx$1.line = function(str, def) {
  return {
    line: function(v) {
      v = v || def;
      if (v) {
        return str.replace("%s", v.toString());
      }
      return null;
    }
  };
};
var errorEx_1 = errorEx$1;
var jsonParseBetterErrors = parseJson$1;
function parseJson$1(txt, reviver, context2) {
  context2 = context2 || 20;
  try {
    return JSON.parse(txt, reviver);
  } catch (e) {
    if (typeof txt !== "string") {
      const isEmptyArray = Array.isArray(txt) && txt.length === 0;
      const errorMessage = "Cannot parse " + (isEmptyArray ? "an empty array" : String(txt));
      throw new TypeError(errorMessage);
    }
    const syntaxErr = e.message.match(/^Unexpected token.*position\s+(\d+)/i);
    const errIdx = syntaxErr ? +syntaxErr[1] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
    if (errIdx != null) {
      const start = errIdx <= context2 ? 0 : errIdx - context2;
      const end = errIdx + context2 >= txt.length ? txt.length : errIdx + context2;
      e.message += ` while parsing near '${start === 0 ? "" : "..."}${txt.slice(start, end)}${end === txt.length ? "" : "..."}'`;
    } else {
      e.message += ` while parsing '${txt.slice(0, context2 * 2)}'`;
    }
    throw e;
  }
}
const errorEx2 = errorEx_1;
const fallback = jsonParseBetterErrors;
const JSONError = errorEx2("JSONError", {
  fileName: errorEx2.append("in %s")
});
var parseJson = (input, reviver, filename) => {
  if (typeof reviver === "string") {
    filename = reviver;
    reviver = null;
  }
  try {
    try {
      return JSON.parse(input, reviver);
    } catch (err) {
      fallback(input, reviver);
      throw err;
    }
  } catch (err) {
    err.message = err.message.replace(/\n/g, "");
    const jsonErr = new JSONError(err);
    if (filename) {
      jsonErr.fileName = filename;
    }
    throw jsonErr;
  }
};
var stripBom = (string2) => {
  if (typeof string2 !== "string") {
    throw new TypeError(`Expected a string, got ${typeof string2}`);
  }
  if (string2.charCodeAt(0) === 65279) {
    return string2.slice(1);
  }
  return string2;
};
const singleComment = Symbol("singleComment");
const multiComment = Symbol("multiComment");
const stripWithoutWhitespace = () => "";
const stripWithWhitespace = (string2, start, end) => string2.slice(start, end).replace(/\S/g, " ");
const isEscaped = (jsonString, quotePosition) => {
  let index = quotePosition - 1;
  let backslashCount = 0;
  while (jsonString[index] === "\\") {
    index -= 1;
    backslashCount += 1;
  }
  return Boolean(backslashCount % 2);
};
var stripJsonComments = (jsonString, options2 = {}) => {
  if (typeof jsonString !== "string") {
    throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
  }
  const strip = options2.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
  let insideString = false;
  let insideComment = false;
  let offset = 0;
  let result = "";
  for (let i = 0; i < jsonString.length; i++) {
    const currentCharacter = jsonString[i];
    const nextCharacter = jsonString[i + 1];
    if (!insideComment && currentCharacter === '"') {
      const escaped = isEscaped(jsonString, i);
      if (!escaped) {
        insideString = !insideString;
      }
    }
    if (insideString) {
      continue;
    }
    if (!insideComment && currentCharacter + nextCharacter === "//") {
      result += jsonString.slice(offset, i);
      offset = i;
      insideComment = singleComment;
      i++;
    } else if (insideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
      i++;
      insideComment = false;
      result += strip(jsonString, offset, i);
      offset = i;
      continue;
    } else if (insideComment === singleComment && currentCharacter === "\n") {
      insideComment = false;
      result += strip(jsonString, offset, i);
      offset = i;
    } else if (!insideComment && currentCharacter + nextCharacter === "/*") {
      result += jsonString.slice(offset, i);
      offset = i;
      insideComment = multiComment;
      i++;
      continue;
    } else if (insideComment === multiComment && currentCharacter + nextCharacter === "*/") {
      i++;
      insideComment = false;
      result += strip(jsonString, offset, i + 1);
      offset = i + 1;
      continue;
    }
  }
  return result + (insideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
};
var helper$1 = {};
var constants = require$$0$4;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf)
    Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$1;
function patch$1(fs2) {
  if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (fs2.chmod && !fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (fs2.chown && !fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
      function rename(from2, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from2, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from2, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb)
            cb(er);
        });
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(rename, fs$rename);
      return rename;
    }(fs2.rename);
  }
  fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
    function read(fd, buffer2, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
    }
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : function(fs$readSync) {
    return function(fd, buffer2, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode, callback) {
      fs3.open(
        path2,
        constants.O_WRONLY | constants.O_SYMLINK,
        mode,
        function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs3.fchmod(fd, mode, function(err2) {
            fs3.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        }
      );
    };
    fs3.lchmodSync = function(path2, mode) {
      var fd = fs3.openSync(path2, constants.O_WRONLY | constants.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs3.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs3.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs3.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    if (constants.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
      fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb)
              cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              if (cb)
                cb(er2 || er22);
            });
          });
        });
      };
      fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs3.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    } else if (fs3.futimes) {
      fs3.lutimes = function(_a, _b, _c, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig)
      return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig)
      return orig;
    return function(target, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        if (cb)
          cb.apply(this, arguments);
      }
      return options2 ? orig.call(fs2, target, options2, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, options2) {
      var stats = options2 ? orig.call(fs2, target, options2) : orig.call(fs2, target);
      if (stats) {
        if (stats.uid < 0)
          stats.uid += 4294967296;
        if (stats.gid < 0)
          stats.gid += 4294967296;
      }
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$0$5.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options2) {
    if (!(this instanceof ReadStream))
      return new ReadStream(path2, options2);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options2 = options2 || {};
    var keys2 = Object.keys(options2);
    for (var index = 0, length = keys2.length; index < length; index++) {
      var key = keys2[index];
      this[key] = options2[key];
    }
    if (this.encoding)
      this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if ("number" !== typeof this.end) {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options2) {
    if (!(this instanceof WriteStream))
      return new WriteStream(path2, options2);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options2 = options2 || {};
    var keys2 = Object.keys(options2);
    for (var index = 0, length = keys2.length; index < length; index++) {
      var key = keys2[index];
      this[key] = options2[key];
    }
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) };
  else
    var copy = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy;
}
var fs$2 = fs$3;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util = require$$3;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context2, queue) {
  Object.defineProperty(context2, gracefulQueue, {
    get: function() {
      return queue;
    }
  });
}
var debug = noop;
if (util.debuglog)
  debug = util.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug = function() {
    var m = util.format.apply(util, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
  };
if (!fs$2[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$2, queue);
  fs$2.close = function(fs$close) {
    function close3(fd, cb) {
      return fs$close.call(fs$2, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close3, previousSymbol, {
      value: fs$close
    });
    return close3;
  }(fs$2.close);
  fs$2.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$2, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$2.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug(fs$2[gracefulQueue]);
      require$$5$1.equal(fs$2[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$2[gracefulQueue]);
}
var gracefulFs = patch(clone(fs$2));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$2.__patched) {
  gracefulFs = patch(fs$2);
  fs$2.__patched = true;
}
function patch(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options2, cb) {
    if (typeof options2 === "function")
      cb = options2, options2 = null;
    return go$readFile(path2, options2, cb);
    function go$readFile(path3, options3, cb2, startTime) {
      return fs$readFile(path3, options3, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path3, options3, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options2, cb) {
    if (typeof options2 === "function")
      cb = options2, options2 = null;
    return go$writeFile(path2, data, options2, cb);
    function go$writeFile(path3, data2, options3, cb2, startTime) {
      return fs$writeFile(path3, data2, options3, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options2, cb) {
    if (typeof options2 === "function")
      cb = options2, options2 = null;
    return go$appendFile(path2, data, options2, cb);
    function go$appendFile(path3, data2, options3, cb2, startTime) {
      return fs$appendFile(path3, data2, options3, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path3, data2, options3, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile;
  function copyFile(src2, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src2, dest, flags, cb);
    function go$copyFile(src3, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src3, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir2;
  var noReaddirOptionVersions = /^v[0-5]\./;
  function readdir2(path2, options2, cb) {
    if (typeof options2 === "function")
      cb = options2, options2 = null;
    var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path3, options3, cb2, startTime) {
      return fs$readdir(path3, fs$readdirCallback(
        path3,
        options3,
        cb2,
        startTime
      ));
    } : function go$readdir2(path3, options3, cb2, startTime) {
      return fs$readdir(path3, options3, fs$readdirCallback(
        path3,
        options3,
        cb2,
        startTime
      ));
    };
    return go$readdir(path2, options2, cb);
    function fs$readdirCallback(path3, options3, cb2, startTime) {
      return function(err, files) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([
            go$readdir,
            [path3, options3, cb2],
            err,
            startTime || Date.now(),
            Date.now()
          ]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files);
        }
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options2) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options2) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options2) {
    return new fs2.ReadStream(path2, options2);
  }
  function createWriteStream(path2, options2) {
    return new fs2.WriteStream(path2, options2);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path3, flags2, mode2, cb2, startTime) {
      return fs$open(path3, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug("ENQUEUE", elem[0].name, elem[1]);
  fs$2[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now2 = Date.now();
  for (var i = 0; i < fs$2[gracefulQueue].length; ++i) {
    if (fs$2[gracefulQueue][i].length > 2) {
      fs$2[gracefulQueue][i][3] = now2;
      fs$2[gracefulQueue][i][4] = now2;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$2[gracefulQueue].length === 0)
    return;
  var elem = fs$2[gracefulQueue].shift();
  var fn = elem[0];
  var args2 = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug("RETRY", fn.name, args2);
    fn.apply(null, args2);
  } else if (Date.now() - startTime >= 6e4) {
    debug("TIMEOUT", fn.name, args2);
    var cb = args2.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug("RETRY", fn.name, args2);
      fn.apply(null, args2.concat([startTime]));
    } else {
      fs$2[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
var path = require$$0$3;
var fs$1 = fs$3;
var _0777 = parseInt("0777", 8);
var mkdirp$1 = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
function mkdirP(p, opts, f, made) {
  if (typeof opts === "function") {
    f = opts;
    opts = {};
  } else if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  var xfs = opts.fs || fs$1;
  if (mode === void 0) {
    mode = _0777;
  }
  if (!made)
    made = null;
  var cb = f || /* istanbul ignore next */
  function() {
  };
  p = path.resolve(p);
  xfs.mkdir(p, mode, function(er) {
    if (!er) {
      made = made || p;
      return cb(null, made);
    }
    switch (er.code) {
      case "ENOENT":
        if (path.dirname(p) === p)
          return cb(er);
        mkdirP(path.dirname(p), opts, function(er2, made2) {
          if (er2)
            cb(er2, made2);
          else
            mkdirP(p, opts, cb, made2);
        });
        break;
      default:
        xfs.stat(p, function(er2, stat) {
          if (er2 || !stat.isDirectory())
            cb(er, made);
          else
            cb(null, made);
        });
        break;
    }
  });
}
mkdirP.sync = function sync(p, opts, made) {
  if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  var xfs = opts.fs || fs$1;
  if (mode === void 0) {
    mode = _0777;
  }
  if (!made)
    made = null;
  p = path.resolve(p);
  try {
    xfs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case "ENOENT":
        made = sync(path.dirname(p), opts, made);
        sync(p, opts, made);
        break;
      default:
        var stat;
        try {
          stat = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat.isDirectory())
          throw err0;
        break;
    }
  }
  return made;
};
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(helper$1, "__esModule", { value: true });
var fast_safe_stringify_1 = fastSafeStringify;
var fs = gracefulFs;
var mkdirp = mkdirp$1;
var oproto = Object.prototype;
function promisify(fn) {
  return function() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    return new Promise(function(resolve, reject) {
      fn.apply(void 0, args2.concat([function(err, result) {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      }]));
    });
  };
}
var defaultStringifyOpts = {
  replacer: null,
  space: 0,
  handleCircular: true
};
var helper = {
  isObject: function(o) {
    return oproto.toString.call(o) === "[object Object]";
  },
  isPrimitive: function(value) {
    var t = typeof value;
    return value === null || value === void 0 || t !== "function" && t !== "object";
  },
  strLog: function(value, pretty) {
    if (helper.isPrimitive(value))
      return value;
    var s = pretty ? "  " : null;
    return fast_safe_stringify_1.default(value, null, s);
  },
  getLogger: function(config2, pretty) {
    return function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var stream = config2.stream;
      var msg = args2.map(function(arg) {
        if (arg instanceof Error) {
          stream = config2.streamErr;
          return arg.stack || arg.message || String(arg);
        }
        return helper.strLog(arg, pretty);
      }).join(" ");
      stream.write(msg + "\n");
    };
  },
  getStringifyOptions: function(options2, space) {
    if (helper.isObject(options2)) {
      return __assign({}, defaultStringifyOpts, options2);
    }
    if (typeof options2 === "function" || Array.isArray(options2)) {
      return __assign({}, defaultStringifyOpts, { replacer: options2, space });
    }
    return __assign({}, defaultStringifyOpts, { space });
  },
  fs,
  mkdirp,
  promise: {
    readFile: promisify(fs.readFile),
    writeFile: promisify(fs.writeFile),
    mkdirp: promisify(mkdirp)
  },
  safeSync: function(fn) {
    return function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      try {
        return [null, fn.apply(void 0, args2)];
      } catch (err) {
        return [err, void 0];
      }
    };
  },
  safeAsync: function(promise) {
    return promise.then(function(data) {
      return [null, data];
    }).catch(function(err) {
      return [err, void 0];
    });
  }
};
helper$1.helper = helper;
var jsonc_safe = {};
var hasRequiredJsonc_safe;
function requireJsonc_safe() {
  if (hasRequiredJsonc_safe)
    return jsonc_safe;
  hasRequiredJsonc_safe = 1;
  Object.defineProperty(jsonc_safe, "__esModule", { value: true });
  var fast_safe_stringify_12 = fastSafeStringify;
  var stripJsonComments$1 = stripJsonComments;
  var helper_1 = helper$1;
  var jsonc_1 = requireJsonc();
  var safeSync = helper_1.helper.safeSync, safeAsync = helper_1.helper.safeAsync;
  var jsoncSafe = (
    /** @class */
    function() {
      function jsoncSafe2() {
      }
      jsoncSafe2.config = function(cfg) {
        jsonc_1.jsonc.config(cfg);
      };
      jsoncSafe2.log = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        jsonc_1.jsonc.log.apply(jsonc_1.jsonc, args2);
      };
      jsoncSafe2.logp = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        jsonc_1.jsonc.logp.apply(jsonc_1.jsonc, args2);
      };
      jsoncSafe2.parse = function(str, options2) {
        return safeSync(jsonc_1.jsonc.parse)(str, options2);
      };
      jsoncSafe2.stringify = function(value, optionsOrReplacer, space) {
        var opts = helper_1.helper.getStringifyOptions(optionsOrReplacer, space);
        try {
          return [null, fast_safe_stringify_12.default(value, opts.replacer, opts.space)];
        } catch (err) {
          return [err, void 0];
        }
      };
      jsoncSafe2.isJSON = function(str, allowComments) {
        if (allowComments === void 0) {
          allowComments = false;
        }
        return jsonc_1.jsonc.isJSON(str, allowComments);
      };
      jsoncSafe2.stripComments = function(str, whitespace) {
        if (whitespace === void 0) {
          whitespace = false;
        }
        return safeSync(stripJsonComments$1)(str, { whitespace });
      };
      jsoncSafe2.uglify = function(str) {
        return safeSync(jsonc_1.jsonc.uglify)(str);
      };
      jsoncSafe2.beautify = function(str, space) {
        if (space === void 0) {
          space = 2;
        }
        return safeSync(jsonc_1.jsonc.beautify)(str, space);
      };
      jsoncSafe2.normalize = function(value, replacer) {
        return safeSync(jsonc_1.jsonc.normalize)(value, replacer);
      };
      jsoncSafe2.read = function(filePath, options2) {
        return safeAsync(jsonc_1.jsonc.read(filePath, options2));
      };
      jsoncSafe2.readSync = function(filePath, options2) {
        return safeSync(jsonc_1.jsonc.readSync)(filePath, options2);
      };
      jsoncSafe2.write = function(filePath, data, options2) {
        return safeAsync(jsonc_1.jsonc.write(filePath, data, options2));
      };
      jsoncSafe2.writeSync = function(filePath, data, options2) {
        return safeSync(jsonc_1.jsonc.writeSync)(filePath, data, options2);
      };
      return jsoncSafe2;
    }()
  );
  jsonc_safe.jsoncSafe = jsoncSafe;
  return jsonc_safe;
}
var hasRequiredJsonc;
function requireJsonc() {
  if (hasRequiredJsonc)
    return jsonc$1;
  hasRequiredJsonc = 1;
  var __assign2 = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign2 = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign2.apply(this, arguments);
  };
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : new P(function(resolve2) {
          resolve2(result.value);
        }).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(jsonc$1, "__esModule", { value: true });
  var path2 = require$$0$3;
  var fast_safe_stringify_12 = fastSafeStringify;
  var parseJson$12 = parseJson;
  var stripBOM = stripBom;
  var stripJsonComments$1 = stripJsonComments;
  var helper_1 = helper$1;
  var jsonc_safe_1 = requireJsonc_safe();
  var fs2 = helper_1.helper.fs, mkdirp2 = helper_1.helper.mkdirp, promise = helper_1.helper.promise;
  /**
   *  JSON utility class that can handle comments and circular references; and
   *  other extra functionality.
   *  @class
   *  @author Onur Yıldırım <onur@cutepilot.com>
   *  @license MIT
   *  @see {@link https://github.com/onury/jsonc|GitHub Repo}
   *  @see {@link https://github.com/onury/jsonc#related-modules|Related Modules}
   *
   *  @example
   *  const jsonc = require('jsonc');
   *  // or
   *  import { jsonc } from 'jsonc';
   *
   *  const result = jsonc.parse('// comments\n{ "key": "value" }');
   *  console.log(result); // { key: "value" }
   */
  var jsonc2 = (
    /** @class */
    function() {
      function jsonc3() {
      }
      jsonc3.config = function(cfg) {
        var conf = __assign2({ stream: process.stdout, streamErr: process.stderr }, cfg || {});
        jsonc3._ = {
          logger: helper_1.helper.getLogger(conf, false),
          prettyLogger: helper_1.helper.getLogger(conf, true)
        };
      };
      jsonc3.log = function() {
        var _a;
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        (_a = jsonc3._).logger.apply(_a, args2);
      };
      jsonc3.logp = function() {
        var _a;
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        (_a = jsonc3._).prettyLogger.apply(_a, args2);
      };
      jsonc3.parse = function(str, options2) {
        var opts = typeof options2 === "function" ? { reviver: options2 } : options2 || {};
        if (opts.stripComments !== false)
          str = stripJsonComments$1(str, { whitespace: false });
        return parseJson$12(str, opts.reviver);
      };
      jsonc3.stringify = function(value, optionsOrReplacer, space) {
        var opts = helper_1.helper.getStringifyOptions(optionsOrReplacer, space);
        return opts.handleCircular ? fast_safe_stringify_12.default(value, opts.replacer, opts.space) : JSON.stringify(value, opts.replacer, opts.space);
      };
      jsonc3.isJSON = function(str, allowComments) {
        if (allowComments === void 0) {
          allowComments = false;
        }
        if (typeof str !== "string")
          return false;
        var _a = jsonc3.safe.parse(str, { stripComments: allowComments }), err = _a[0], result = _a[1];
        return !err && (helper_1.helper.isObject(result) || Array.isArray(result));
      };
      jsonc3.stripComments = function(str, whitespace) {
        if (whitespace === void 0) {
          whitespace = false;
        }
        return stripJsonComments$1(str, { whitespace });
      };
      jsonc3.uglify = function(str) {
        return jsonc3.stringify(jsonc3.parse(str, { stripComments: true }));
      };
      jsonc3.beautify = function(str, space) {
        if (space === void 0) {
          space = 2;
        }
        if (!space)
          space = 2;
        return jsonc3.stringify(jsonc3.parse(str), { space });
      };
      jsonc3.normalize = function(value, replacer) {
        return jsonc3.parse(jsonc3.stringify(value, { replacer }));
      };
      jsonc3.read = function(filePath, options2) {
        return __awaiter2(this, void 0, void 0, function() {
          var opts, data;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                opts = __assign2({ reviver: null, stripComments: true }, options2 || {});
                return [4, promise.readFile(filePath, "utf8")];
              case 1:
                data = _a.sent();
                if (opts.stripComments !== false)
                  data = stripJsonComments$1(data);
                return [2, parseJson$12(stripBOM(data), opts.reviver, filePath)];
            }
          });
        });
      };
      jsonc3.readSync = function(filePath, options2) {
        var opts = __assign2({ reviver: null, stripComments: true }, options2 || {});
        var data = fs2.readFileSync(filePath, "utf8");
        if (opts.stripComments !== false)
          data = stripJsonComments$1(data);
        return parseJson$12(stripBOM(data), opts.reviver, filePath);
      };
      jsonc3.write = function(filePath, data, options2) {
        return __awaiter2(this, void 0, void 0, function() {
          var opts, content;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                opts = __assign2({ replacer: null, space: 0, mode: 438, autoPath: true }, options2 || {});
                if (!opts.autoPath)
                  return [3, 2];
                return [4, promise.mkdirp(path2.dirname(filePath), { fs: fs2 })];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                content = JSON.stringify(data, opts.replacer, opts.space);
                return [4, promise.writeFile(filePath, content + "\n", {
                  mode: opts.mode,
                  encoding: "utf8"
                })];
              case 3:
                _a.sent();
                return [2, true];
            }
          });
        });
      };
      jsonc3.writeSync = function(filePath, data, options2) {
        var opts = __assign2({ replacer: null, space: 0, mode: 438, autoPath: true }, options2 || {});
        if (opts.autoPath)
          mkdirp2.sync(path2.dirname(filePath), { fs: fs2 });
        var content = JSON.stringify(data, opts.replacer, opts.space);
        fs2.writeFileSync(filePath, content + "\n", {
          mode: opts.mode,
          encoding: "utf8"
        });
        return true;
      };
      return jsonc3;
    }()
  );
  jsonc$1.jsonc = jsonc2;
  jsonc2.config(null);
  (function(jsonc3) {
    jsonc3.safe = jsonc_safe_1.jsoncSafe;
  })(jsonc2 || (jsonc2 = {}));
  jsonc$1.jsonc = jsonc2;
  return jsonc$1;
}
var jsonc = requireJsonc().jsonc;
jsonc$2.exports = jsonc;
var jsonc_2 = jsonc$2.exports.jsonc = jsonc;
jsonc$2.exports.safe = jsonc.safe;
let mainWindow;
const databasePath = path__namespace.join(electron$1.app.getPath("userData"), "mydb");
const storagePath = path__namespace.join(
  electron$1.app.getPath("userData"),
  "virtualrx_drugstore.json"
);
let db;
function getDeviceDimensions() {
  const mainScreen = electron$1.screen.getPrimaryDisplay();
  const width = mainScreen.bounds.width;
  const height = mainScreen.bounds.height;
  return { width, height };
}
async function createWindow() {
  const { height, width } = getDeviceDimensions();
  mainWindow = new electron$1.BrowserWindow({
    minWidth: width * 0.75,
    minHeight: height * 0.99,
    width: 1400,
    height: 850,
    webPreferences: {
      preload: path__namespace.join(__dirname, "../../out/preload/preload.js"),
      webSecurity: false,
      nodeIntegration: true,
      nodeIntegrationInWorker: true
    }
  });
  mainWindow.webContents.openDevTools();
  if (fs$3.existsSync(storagePath)) {
    const dbSource = fs$3.readFileSync(storagePath, "utf8");
    electron$1.ipcMain.handle("dbContent", () => jsonc_2.parse(dbSource));
    electron$1.ipcMain.handle("ping", () => databasePath);
  } else {
    db = await getDatabase(databasePath);
    const storage = storageDexie.getRxStorageDexie();
    electron.exposeIpcMainRxStorage({
      key: "main-storage",
      storage,
      ipcMain: electron$1.ipcMain
    });
    electron$1.ipcMain.handle("ping", () => databasePath);
  }
  mainWindow.loadURL("http://localhost:5173");
}
electron$1.app.on("ready", async function() {
  createWindow();
});
electron$1.app.on("before-quit", () => {
  saveAndCloseDatabase();
});
async function saveAndCloseDatabase() {
  if (db) {
    const jsonData = await db.exportJSON();
    fs$3.writeFileSync(storagePath, jsonc_2.stringify(jsonData, void 0, 2));
    electron$1.app.quit();
  } else {
    electron$1.app.quit();
  }
}
electron$1.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    electron$1.app.quit();
  }
});
