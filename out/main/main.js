"use strict";
const electron$1 = require("electron");
const path = require("node:path");
const require$$3 = require("util");
const fs = require("fs");
const require$$5 = require("crypto");
const require$$6 = require("os");
const require$$7 = require("events");
const require$$8 = require("net");
const require$$9 = require("path");
function _interopNamespaceDefault(e2) {
  const n2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e2) {
    for (const k2 in e2) {
      if (k2 !== "default") {
        const d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: true,
          get: () => e2[k2]
        });
      }
    }
  }
  n2.default = e2;
  return Object.freeze(n2);
}
const path__namespace = /* @__PURE__ */ _interopNamespaceDefault(path);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var electron = {};
var rxStorageIpcRenderer = {};
var cjs = {};
var Observable$1 = {};
var Subscriber = {};
var isFunction$1 = {};
Object.defineProperty(isFunction$1, "__esModule", { value: true });
isFunction$1.isFunction = void 0;
function isFunction(value) {
  return typeof value === "function";
}
isFunction$1.isFunction = isFunction;
var Subscription$1 = {};
var UnsubscriptionError = {};
var createErrorClass$1 = {};
Object.defineProperty(createErrorClass$1, "__esModule", { value: true });
createErrorClass$1.createErrorClass = void 0;
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
createErrorClass$1.createErrorClass = createErrorClass;
Object.defineProperty(UnsubscriptionError, "__esModule", { value: true });
UnsubscriptionError.UnsubscriptionError = void 0;
var createErrorClass_1$5 = createErrorClass$1;
UnsubscriptionError.UnsubscriptionError = createErrorClass_1$5.createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
var arrRemove$1 = {};
Object.defineProperty(arrRemove$1, "__esModule", { value: true });
arrRemove$1.arrRemove = void 0;
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
arrRemove$1.arrRemove = arrRemove;
var __values$8 = commonjsGlobal && commonjsGlobal.__values || function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$i = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$h = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(Subscription$1, "__esModule", { value: true });
Subscription$1.isSubscription = Subscription$1.EMPTY_SUBSCRIPTION = Subscription$1.Subscription = void 0;
var isFunction_1$p = isFunction$1;
var UnsubscriptionError_1 = UnsubscriptionError;
var arrRemove_1$7 = arrRemove$1;
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values$8(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction_1$p.isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError_1.UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values$8(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                errors = __spreadArray$h(__spreadArray$h([], __read$i(errors)), __read$i(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError_1.UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove_1$7.arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove_1$7.arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
Subscription$1.Subscription = Subscription;
Subscription$1.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction_1$p.isFunction(value.remove) && isFunction_1$p.isFunction(value.add) && isFunction_1$p.isFunction(value.unsubscribe);
}
Subscription$1.isSubscription = isSubscription;
function execFinalizer(finalizer) {
  if (isFunction_1$p.isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {};
Object.defineProperty(config, "__esModule", { value: true });
config.config = void 0;
config.config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var reportUnhandledError$1 = {};
var timeoutProvider = {};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2)
      return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
      to[j2] = from2[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutProvider = void 0;
  exports.timeoutProvider = {
    setTimeout: function(handler, timeout2) {
      var args2 = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args2[_i - 2] = arguments[_i];
      }
      var delegate = exports.timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout2], __read2(args2)));
      }
      return setTimeout.apply(void 0, __spreadArray2([handler, timeout2], __read2(args2)));
    },
    clearTimeout: function(handle) {
      var delegate = exports.timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };
})(timeoutProvider);
Object.defineProperty(reportUnhandledError$1, "__esModule", { value: true });
reportUnhandledError$1.reportUnhandledError = void 0;
var config_1$2 = config;
var timeoutProvider_1 = timeoutProvider;
function reportUnhandledError(err) {
  timeoutProvider_1.timeoutProvider.setTimeout(function() {
    var onUnhandledError = config_1$2.config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
reportUnhandledError$1.reportUnhandledError = reportUnhandledError;
var noop$1 = {};
Object.defineProperty(noop$1, "__esModule", { value: true });
noop$1.noop = void 0;
function noop() {
}
noop$1.noop = noop;
var NotificationFactories = {};
Object.defineProperty(NotificationFactories, "__esModule", { value: true });
NotificationFactories.createNotification = NotificationFactories.nextNotification = NotificationFactories.errorNotification = NotificationFactories.COMPLETE_NOTIFICATION = void 0;
NotificationFactories.COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
NotificationFactories.errorNotification = errorNotification;
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
NotificationFactories.nextNotification = nextNotification;
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
NotificationFactories.createNotification = createNotification;
var errorContext$1 = {};
Object.defineProperty(errorContext$1, "__esModule", { value: true });
errorContext$1.captureError = errorContext$1.errorContext = void 0;
var config_1$1 = config;
var context = null;
function errorContext(cb) {
  if (config_1$1.config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
errorContext$1.errorContext = errorContext;
function captureError(err) {
  if (config_1$1.config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}
errorContext$1.captureError = captureError;
(function(exports) {
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || function() {
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p2))
            d3[p2] = b3[p2];
      };
      return extendStatics(d2, b2);
    };
    return function(d2, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
  var isFunction_12 = isFunction$1;
  var Subscription_12 = Subscription$1;
  var config_12 = config;
  var reportUnhandledError_12 = reportUnhandledError$1;
  var noop_12 = noop$1;
  var NotificationFactories_1 = NotificationFactories;
  var timeoutProvider_12 = timeoutProvider;
  var errorContext_12 = errorContext$1;
  var Subscriber2 = function(_super) {
    __extends2(Subscriber3, _super);
    function Subscriber3(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (Subscription_12.isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = exports.EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber3.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber3.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber3.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber3.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber3.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber3.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber3.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber3.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber3;
  }(Subscription_12.Subscription);
  exports.Subscriber = Subscriber2;
  var _bind = Function.prototype.bind;
  function bind(fn2, thisArg) {
    return _bind.call(fn2, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends2(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction_12.isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config_12.config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber2);
  exports.SafeSubscriber = SafeSubscriber;
  function handleUnhandledError(error) {
    if (config_12.config.useDeprecatedSynchronousErrorHandling) {
      errorContext_12.captureError(error);
    } else {
      reportUnhandledError_12.reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config_12.config.onStoppedNotification;
    onStoppedNotification && timeoutProvider_12.timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  exports.EMPTY_OBSERVER = {
    closed: true,
    next: noop_12.noop,
    error: defaultErrorHandler,
    complete: noop_12.noop
  };
})(Subscriber);
var observable = {};
Object.defineProperty(observable, "__esModule", { value: true });
observable.observable = void 0;
observable.observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var pipe$1 = {};
var identity$1 = {};
Object.defineProperty(identity$1, "__esModule", { value: true });
identity$1.identity = void 0;
function identity(x2) {
  return x2;
}
identity$1.identity = identity;
Object.defineProperty(pipe$1, "__esModule", { value: true });
pipe$1.pipeFromArray = pipe$1.pipe = void 0;
var identity_1$e = identity$1;
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
pipe$1.pipe = pipe;
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity_1$e.identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}
pipe$1.pipeFromArray = pipeFromArray;
Object.defineProperty(Observable$1, "__esModule", { value: true });
Observable$1.Observable = void 0;
var Subscriber_1$3 = Subscriber;
var Subscription_1$8 = Subscription$1;
var observable_1$2 = observable;
var pipe_1$2 = pipe$1;
var config_1 = config;
var isFunction_1$o = isFunction$1;
var errorContext_1$1 = errorContext$1;
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1$3.SafeSubscriber(observerOrNext, error, complete);
    errorContext_1$1.errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new Subscriber_1$3.SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable_1$2.observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipe_1$2.pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
Observable$1.Observable = Observable;
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction_1$o.isFunction(value.next) && isFunction_1$o.isFunction(value.error) && isFunction_1$o.isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber_1$3.Subscriber || isObserver(value) && Subscription_1$8.isSubscription(value);
}
var ConnectableObservable$1 = {};
var refCount$1 = {};
var lift = {};
Object.defineProperty(lift, "__esModule", { value: true });
lift.operate = lift.hasLift = void 0;
var isFunction_1$n = isFunction$1;
function hasLift(source) {
  return isFunction_1$n.isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
lift.hasLift = hasLift;
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
lift.operate = operate;
var OperatorSubscriber$1 = {};
var __extends$f = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(OperatorSubscriber$1, "__esModule", { value: true });
OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber$1.createOperatorSubscriber = void 0;
var Subscriber_1$2 = Subscriber;
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
OperatorSubscriber$1.createOperatorSubscriber = createOperatorSubscriber;
var OperatorSubscriber = function(_super) {
  __extends$f(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber_1$2.Subscriber);
OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber;
Object.defineProperty(refCount$1, "__esModule", { value: true });
refCount$1.refCount = void 0;
var lift_1$14 = lift;
var OperatorSubscriber_1$V = OperatorSubscriber$1;
function refCount() {
  return lift_1$14.operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = OperatorSubscriber_1$V.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}
refCount$1.refCount = refCount;
var __extends$e = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(ConnectableObservable$1, "__esModule", { value: true });
ConnectableObservable$1.ConnectableObservable = void 0;
var Observable_1$n = Observable$1;
var Subscription_1$7 = Subscription$1;
var refCount_1 = refCount$1;
var OperatorSubscriber_1$U = OperatorSubscriber$1;
var lift_1$13 = lift;
var ConnectableObservable = function(_super) {
  __extends$e(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (lift_1$13.hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription_1$7.Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(OperatorSubscriber_1$U.createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription_1$7.Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount_1.refCount()(this);
  };
  return ConnectableObservable2;
}(Observable_1$n.Observable);
ConnectableObservable$1.ConnectableObservable = ConnectableObservable;
var animationFrames$1 = {};
var performanceTimestampProvider = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.performanceTimestampProvider = void 0;
  exports.performanceTimestampProvider = {
    now: function() {
      return (exports.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: void 0
  };
})(performanceTimestampProvider);
var animationFrameProvider = {};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2)
      return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
      to[j2] = from2[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrameProvider = void 0;
  var Subscription_12 = Subscription$1;
  exports.animationFrameProvider = {
    schedule: function(callback) {
      var request = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = exports.animationFrameProvider.delegate;
      if (delegate) {
        request = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle = request(function(timestamp2) {
        cancel = void 0;
        callback(timestamp2);
      });
      return new Subscription_12.Subscription(function() {
        return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
      });
    },
    requestAnimationFrame: function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read2(args2)));
    },
    cancelAnimationFrame: function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read2(args2)));
    },
    delegate: void 0
  };
})(animationFrameProvider);
Object.defineProperty(animationFrames$1, "__esModule", { value: true });
animationFrames$1.animationFrames = void 0;
var Observable_1$m = Observable$1;
var performanceTimestampProvider_1 = performanceTimestampProvider;
var animationFrameProvider_1$1 = animationFrameProvider;
function animationFrames(timestampProvider) {
  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
}
animationFrames$1.animationFrames = animationFrames;
function animationFramesFactory(timestampProvider) {
  return new Observable_1$m.Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider_1$1.animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now2 = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now2 : timestamp2,
            elapsed: now2 - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider_1$1.animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
var Subject$1 = {};
var ObjectUnsubscribedError = {};
Object.defineProperty(ObjectUnsubscribedError, "__esModule", { value: true });
ObjectUnsubscribedError.ObjectUnsubscribedError = void 0;
var createErrorClass_1$4 = createErrorClass$1;
ObjectUnsubscribedError.ObjectUnsubscribedError = createErrorClass_1$4.createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var __extends$d = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __values$7 = commonjsGlobal && commonjsGlobal.__values || function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(Subject$1, "__esModule", { value: true });
Subject$1.AnonymousSubject = Subject$1.Subject = void 0;
var Observable_1$l = Observable$1;
var Subscription_1$6 = Subscription$1;
var ObjectUnsubscribedError_1 = ObjectUnsubscribedError;
var arrRemove_1$6 = arrRemove$1;
var errorContext_1 = errorContext$1;
var Subject = function(_super) {
  __extends$d(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext_1.errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values$7(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext_1.errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext_1.errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return Subscription_1$6.EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription_1$6.Subscription(function() {
      _this.currentObservers = null;
      arrRemove_1$6.arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable_1$l.Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable_1$l.Observable);
Subject$1.Subject = Subject;
var AnonymousSubject = function(_super) {
  __extends$d(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1$6.EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
Subject$1.AnonymousSubject = AnonymousSubject;
var BehaviorSubject$1 = {};
var __extends$c = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(BehaviorSubject$1, "__esModule", { value: true });
BehaviorSubject$1.BehaviorSubject = void 0;
var Subject_1$e = Subject$1;
var BehaviorSubject = function(_super) {
  __extends$c(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject_1$e.Subject);
BehaviorSubject$1.BehaviorSubject = BehaviorSubject;
var ReplaySubject$1 = {};
var dateTimestampProvider = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dateTimestampProvider = void 0;
  exports.dateTimestampProvider = {
    now: function() {
      return (exports.dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };
})(dateTimestampProvider);
var __extends$b = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(ReplaySubject$1, "__esModule", { value: true });
ReplaySubject$1.ReplaySubject = void 0;
var Subject_1$d = Subject$1;
var dateTimestampProvider_1$2 = dateTimestampProvider;
var ReplaySubject = function(_super) {
  __extends$b(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider_1$2.dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last2 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now2; i2 += 2) {
        last2 = i2;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
}(Subject_1$d.Subject);
ReplaySubject$1.ReplaySubject = ReplaySubject;
var AsyncSubject$1 = {};
var __extends$a = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsyncSubject$1, "__esModule", { value: true });
AsyncSubject$1.AsyncSubject = void 0;
var Subject_1$c = Subject$1;
var AsyncSubject = function(_super) {
  __extends$a(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject_1$c.Subject);
AsyncSubject$1.AsyncSubject = AsyncSubject;
var asap = {};
var AsapAction$1 = {};
var AsyncAction$1 = {};
var Action$2 = {};
var __extends$9 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(Action$2, "__esModule", { value: true });
Action$2.Action = void 0;
var Subscription_1$5 = Subscription$1;
var Action$1 = function(_super) {
  __extends$9(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    return this;
  };
  return Action2;
}(Subscription_1$5.Subscription);
Action$2.Action = Action$1;
var intervalProvider = {};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2)
      return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
      to[j2] = from2[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intervalProvider = void 0;
  exports.intervalProvider = {
    setInterval: function(handler, timeout2) {
      var args2 = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args2[_i - 2] = arguments[_i];
      }
      var delegate = exports.intervalProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout2], __read2(args2)));
      }
      return setInterval.apply(void 0, __spreadArray2([handler, timeout2], __read2(args2)));
    },
    clearInterval: function(handle) {
      var delegate = exports.intervalProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: void 0
  };
})(intervalProvider);
var __extends$8 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsyncAction$1, "__esModule", { value: true });
AsyncAction$1.AsyncAction = void 0;
var Action_1 = Action$2;
var intervalProvider_1 = intervalProvider;
var arrRemove_1$5 = arrRemove$1;
var AsyncAction = function(_super) {
  __extends$8(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider_1.intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions2 = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove_1$5.arrRemove(actions2, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action_1.Action);
AsyncAction$1.AsyncAction = AsyncAction;
var immediateProvider = {};
var Immediate = {};
Object.defineProperty(Immediate, "__esModule", { value: true });
Immediate.TestTools = Immediate.Immediate = void 0;
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
Immediate.Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};
Immediate.TestTools = {
  pending: function() {
    return Object.keys(activeHandles).length;
  }
};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2)
      return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
      to[j2] = from2[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immediateProvider = void 0;
  var Immediate_1 = Immediate;
  var setImmediate2 = Immediate_1.Immediate.setImmediate, clearImmediate = Immediate_1.Immediate.clearImmediate;
  exports.immediateProvider = {
    setImmediate: function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray2([], __read2(args2)));
    },
    clearImmediate: function(handle) {
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
    },
    delegate: void 0
  };
})(immediateProvider);
var __extends$7 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsapAction$1, "__esModule", { value: true });
AsapAction$1.AsapAction = void 0;
var AsyncAction_1$3 = AsyncAction$1;
var immediateProvider_1 = immediateProvider;
var AsapAction = function(_super) {
  __extends$7(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions2 = scheduler.actions;
    if (id != null && ((_a = actions2[actions2.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider_1.immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction_1$3.AsyncAction);
AsapAction$1.AsapAction = AsapAction;
var AsapScheduler$1 = {};
var AsyncScheduler$1 = {};
var Scheduler$1 = {};
Object.defineProperty(Scheduler$1, "__esModule", { value: true });
Scheduler$1.Scheduler = void 0;
var dateTimestampProvider_1$1 = dateTimestampProvider;
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider_1$1.dateTimestampProvider.now;
  return Scheduler2;
}();
Scheduler$1.Scheduler = Scheduler;
var __extends$6 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsyncScheduler$1, "__esModule", { value: true });
AsyncScheduler$1.AsyncScheduler = void 0;
var Scheduler_1 = Scheduler$1;
var AsyncScheduler = function(_super) {
  __extends$6(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler_1.Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions2 = this.actions;
    if (this._active) {
      actions2.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions2.shift());
    this._active = false;
    if (error) {
      while (action = actions2.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler_1.Scheduler);
AsyncScheduler$1.AsyncScheduler = AsyncScheduler;
var __extends$5 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsapScheduler$1, "__esModule", { value: true });
AsapScheduler$1.AsapScheduler = void 0;
var AsyncScheduler_1$3 = AsyncScheduler$1;
var AsapScheduler = function(_super) {
  __extends$5(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions2 = this.actions;
    var error;
    action = action || actions2.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions2[0]) && action.id === flushId && actions2.shift());
    this._active = false;
    if (error) {
      while ((action = actions2[0]) && action.id === flushId && actions2.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler_1$3.AsyncScheduler);
AsapScheduler$1.AsapScheduler = AsapScheduler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.asap = exports.asapScheduler = void 0;
  var AsapAction_1 = AsapAction$1;
  var AsapScheduler_1 = AsapScheduler$1;
  exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
  exports.asap = exports.asapScheduler;
})(asap);
var async = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.async = exports.asyncScheduler = void 0;
  var AsyncAction_12 = AsyncAction$1;
  var AsyncScheduler_12 = AsyncScheduler$1;
  exports.asyncScheduler = new AsyncScheduler_12.AsyncScheduler(AsyncAction_12.AsyncAction);
  exports.async = exports.asyncScheduler;
})(async);
var queue = {};
var QueueAction$1 = {};
var __extends$4 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(QueueAction$1, "__esModule", { value: true });
QueueAction$1.QueueAction = void 0;
var AsyncAction_1$2 = AsyncAction$1;
var QueueAction = function(_super) {
  __extends$4(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction_1$2.AsyncAction);
QueueAction$1.QueueAction = QueueAction;
var QueueScheduler$1 = {};
var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(QueueScheduler$1, "__esModule", { value: true });
QueueScheduler$1.QueueScheduler = void 0;
var AsyncScheduler_1$2 = AsyncScheduler$1;
var QueueScheduler = function(_super) {
  __extends$3(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler_1$2.AsyncScheduler);
QueueScheduler$1.QueueScheduler = QueueScheduler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.queue = exports.queueScheduler = void 0;
  var QueueAction_1 = QueueAction$1;
  var QueueScheduler_1 = QueueScheduler$1;
  exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
  exports.queue = exports.queueScheduler;
})(queue);
var animationFrame = {};
var AnimationFrameAction$1 = {};
var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AnimationFrameAction$1, "__esModule", { value: true });
AnimationFrameAction$1.AnimationFrameAction = void 0;
var AsyncAction_1$1 = AsyncAction$1;
var animationFrameProvider_1 = animationFrameProvider;
var AnimationFrameAction = function(_super) {
  __extends$2(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions2 = scheduler.actions;
    if (id != null && ((_a = actions2[actions2.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction_1$1.AsyncAction);
AnimationFrameAction$1.AnimationFrameAction = AnimationFrameAction;
var AnimationFrameScheduler$1 = {};
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AnimationFrameScheduler$1, "__esModule", { value: true });
AnimationFrameScheduler$1.AnimationFrameScheduler = void 0;
var AsyncScheduler_1$1 = AsyncScheduler$1;
var AnimationFrameScheduler = function(_super) {
  __extends$1(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions2 = this.actions;
    var error;
    action = action || actions2.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions2[0]) && action.id === flushId && actions2.shift());
    this._active = false;
    if (error) {
      while ((action = actions2[0]) && action.id === flushId && actions2.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler_1$1.AsyncScheduler);
AnimationFrameScheduler$1.AnimationFrameScheduler = AnimationFrameScheduler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrame = exports.animationFrameScheduler = void 0;
  var AnimationFrameAction_1 = AnimationFrameAction$1;
  var AnimationFrameScheduler_1 = AnimationFrameScheduler$1;
  exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
  exports.animationFrame = exports.animationFrameScheduler;
})(animationFrame);
var VirtualTimeScheduler$1 = {};
var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(VirtualTimeScheduler$1, "__esModule", { value: true });
VirtualTimeScheduler$1.VirtualAction = VirtualTimeScheduler$1.VirtualTimeScheduler = void 0;
var AsyncAction_1 = AsyncAction$1;
var Subscription_1$4 = Subscription$1;
var AsyncScheduler_1 = AsyncScheduler$1;
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions2 = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions2[0]) && action.delay <= maxFrames) {
      actions2.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions2.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler_1.AsyncScheduler);
VirtualTimeScheduler$1.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription_1$4.Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions2 = scheduler.actions;
    actions2.push(this);
    actions2.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a2, b2) {
    if (a2.delay === b2.delay) {
      if (a2.index === b2.index) {
        return 0;
      } else if (a2.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction_1.AsyncAction);
VirtualTimeScheduler$1.VirtualAction = VirtualAction;
var Notification = {};
var empty = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.empty = exports.EMPTY = void 0;
  var Observable_12 = Observable$1;
  exports.EMPTY = new Observable_12.Observable(function(subscriber) {
    return subscriber.complete();
  });
  function empty2(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
  }
  exports.empty = empty2;
  function emptyScheduled(scheduler) {
    return new Observable_12.Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  }
})(empty);
var of$1 = {};
var args = {};
var isScheduler$1 = {};
Object.defineProperty(isScheduler$1, "__esModule", { value: true });
isScheduler$1.isScheduler = void 0;
var isFunction_1$m = isFunction$1;
function isScheduler(value) {
  return value && isFunction_1$m.isFunction(value.schedule);
}
isScheduler$1.isScheduler = isScheduler;
Object.defineProperty(args, "__esModule", { value: true });
args.popNumber = args.popScheduler = args.popResultSelector = void 0;
var isFunction_1$l = isFunction$1;
var isScheduler_1$3 = isScheduler$1;
function last$4(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args2) {
  return isFunction_1$l.isFunction(last$4(args2)) ? args2.pop() : void 0;
}
args.popResultSelector = popResultSelector;
function popScheduler(args2) {
  return isScheduler_1$3.isScheduler(last$4(args2)) ? args2.pop() : void 0;
}
args.popScheduler = popScheduler;
function popNumber(args2, defaultValue) {
  return typeof last$4(args2) === "number" ? args2.pop() : defaultValue;
}
args.popNumber = popNumber;
var from$1 = {};
var scheduled$1 = {};
var scheduleObservable$1 = {};
var innerFrom$1 = {};
var isArrayLike = {};
Object.defineProperty(isArrayLike, "__esModule", { value: true });
isArrayLike.isArrayLike = void 0;
isArrayLike.isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
var isPromise$2 = {};
Object.defineProperty(isPromise$2, "__esModule", { value: true });
isPromise$2.isPromise = void 0;
var isFunction_1$k = isFunction$1;
function isPromise$1(value) {
  return isFunction_1$k.isFunction(value === null || value === void 0 ? void 0 : value.then);
}
isPromise$2.isPromise = isPromise$1;
var isInteropObservable$1 = {};
Object.defineProperty(isInteropObservable$1, "__esModule", { value: true });
isInteropObservable$1.isInteropObservable = void 0;
var observable_1$1 = observable;
var isFunction_1$j = isFunction$1;
function isInteropObservable(input) {
  return isFunction_1$j.isFunction(input[observable_1$1.observable]);
}
isInteropObservable$1.isInteropObservable = isInteropObservable;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: true });
isAsyncIterable$1.isAsyncIterable = void 0;
var isFunction_1$i = isFunction$1;
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction_1$i.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var throwUnobservableError = {};
Object.defineProperty(throwUnobservableError, "__esModule", { value: true });
throwUnobservableError.createInvalidObservableTypeError = void 0;
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
throwUnobservableError.createInvalidObservableTypeError = createInvalidObservableTypeError;
var isIterable$1 = {};
var iterator = {};
Object.defineProperty(iterator, "__esModule", { value: true });
iterator.iterator = iterator.getSymbolIterator = void 0;
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
iterator.getSymbolIterator = getSymbolIterator;
iterator.iterator = getSymbolIterator();
Object.defineProperty(isIterable$1, "__esModule", { value: true });
isIterable$1.isIterable = void 0;
var iterator_1$1 = iterator;
var isFunction_1$h = isFunction$1;
function isIterable(input) {
  return isFunction_1$h.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1$1.iterator]);
}
isIterable$1.isIterable = isIterable;
var isReadableStreamLike$1 = {};
var __generator$2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __await = commonjsGlobal && commonjsGlobal.__await || function(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
};
var __asyncGenerator = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2])
      i2[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
};
Object.defineProperty(isReadableStreamLike$1, "__esModule", { value: true });
isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = void 0;
var isFunction_1$g = isFunction$1;
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator$2(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
function isReadableStreamLike(obj) {
  return isFunction_1$g.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __asyncValues = commonjsGlobal && commonjsGlobal.__asyncValues || function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values$6 === "function" ? __values$6(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
};
var __values$6 = commonjsGlobal && commonjsGlobal.__values || function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(innerFrom$1, "__esModule", { value: true });
innerFrom$1.fromReadableStreamLike = innerFrom$1.fromAsyncIterable = innerFrom$1.fromIterable = innerFrom$1.fromPromise = innerFrom$1.fromArrayLike = innerFrom$1.fromInteropObservable = innerFrom$1.innerFrom = void 0;
var isArrayLike_1$2 = isArrayLike;
var isPromise_1$1 = isPromise$2;
var Observable_1$k = Observable$1;
var isInteropObservable_1$1 = isInteropObservable$1;
var isAsyncIterable_1$1 = isAsyncIterable$1;
var throwUnobservableError_1$1 = throwUnobservableError;
var isIterable_1$1 = isIterable$1;
var isReadableStreamLike_1$2 = isReadableStreamLike$1;
var isFunction_1$f = isFunction$1;
var reportUnhandledError_1 = reportUnhandledError$1;
var observable_1 = observable;
function innerFrom(input) {
  if (input instanceof Observable_1$k.Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable_1$1.isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike_1$2.isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise_1$1.isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable_1$1.isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable_1$1.isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike_1$2.isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw throwUnobservableError_1$1.createInvalidObservableTypeError(input);
}
innerFrom$1.innerFrom = innerFrom;
function fromInteropObservable(obj) {
  return new Observable_1$k.Observable(function(subscriber) {
    var obs = obj[observable_1.observable]();
    if (isFunction_1$f.isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
innerFrom$1.fromInteropObservable = fromInteropObservable;
function fromArrayLike(array2) {
  return new Observable_1$k.Observable(function(subscriber) {
    for (var i2 = 0; i2 < array2.length && !subscriber.closed; i2++) {
      subscriber.next(array2[i2]);
    }
    subscriber.complete();
  });
}
innerFrom$1.fromArrayLike = fromArrayLike;
function fromPromise(promise) {
  return new Observable_1$k.Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError_1.reportUnhandledError);
  });
}
innerFrom$1.fromPromise = fromPromise;
function fromIterable(iterable) {
  return new Observable_1$k.Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values$6(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
innerFrom$1.fromIterable = fromIterable;
function fromAsyncIterable(asyncIterable) {
  return new Observable_1$k.Observable(function(subscriber) {
    process$1(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
innerFrom$1.fromAsyncIterable = fromAsyncIterable;
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(isReadableStreamLike_1$2.readableStreamLikeToAsyncGenerator(readableStream));
}
innerFrom$1.fromReadableStreamLike = fromReadableStreamLike;
function process$1(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator$1(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
var observeOn$1 = {};
var executeSchedule$1 = {};
Object.defineProperty(executeSchedule$1, "__esModule", { value: true });
executeSchedule$1.executeSchedule = void 0;
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}
executeSchedule$1.executeSchedule = executeSchedule;
Object.defineProperty(observeOn$1, "__esModule", { value: true });
observeOn$1.observeOn = void 0;
var executeSchedule_1$6 = executeSchedule$1;
var lift_1$12 = lift;
var OperatorSubscriber_1$T = OperatorSubscriber$1;
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return lift_1$12.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$T.createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule_1$6.executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule_1$6.executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule_1$6.executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}
observeOn$1.observeOn = observeOn;
var subscribeOn$1 = {};
Object.defineProperty(subscribeOn$1, "__esModule", { value: true });
subscribeOn$1.subscribeOn = void 0;
var lift_1$11 = lift;
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return lift_1$11.operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}
subscribeOn$1.subscribeOn = subscribeOn;
Object.defineProperty(scheduleObservable$1, "__esModule", { value: true });
scheduleObservable$1.scheduleObservable = void 0;
var innerFrom_1$D = innerFrom$1;
var observeOn_1$2 = observeOn$1;
var subscribeOn_1$2 = subscribeOn$1;
function scheduleObservable(input, scheduler) {
  return innerFrom_1$D.innerFrom(input).pipe(subscribeOn_1$2.subscribeOn(scheduler), observeOn_1$2.observeOn(scheduler));
}
scheduleObservable$1.scheduleObservable = scheduleObservable;
var schedulePromise$1 = {};
Object.defineProperty(schedulePromise$1, "__esModule", { value: true });
schedulePromise$1.schedulePromise = void 0;
var innerFrom_1$C = innerFrom$1;
var observeOn_1$1 = observeOn$1;
var subscribeOn_1$1 = subscribeOn$1;
function schedulePromise(input, scheduler) {
  return innerFrom_1$C.innerFrom(input).pipe(subscribeOn_1$1.subscribeOn(scheduler), observeOn_1$1.observeOn(scheduler));
}
schedulePromise$1.schedulePromise = schedulePromise;
var scheduleArray$1 = {};
Object.defineProperty(scheduleArray$1, "__esModule", { value: true });
scheduleArray$1.scheduleArray = void 0;
var Observable_1$j = Observable$1;
function scheduleArray(input, scheduler) {
  return new Observable_1$j.Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
scheduleArray$1.scheduleArray = scheduleArray;
var scheduleIterable$1 = {};
Object.defineProperty(scheduleIterable$1, "__esModule", { value: true });
scheduleIterable$1.scheduleIterable = void 0;
var Observable_1$i = Observable$1;
var iterator_1 = iterator;
var isFunction_1$e = isFunction$1;
var executeSchedule_1$5 = executeSchedule$1;
function scheduleIterable(input, scheduler) {
  return new Observable_1$i.Observable(function(subscriber) {
    var iterator2;
    executeSchedule_1$5.executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator_1.iterator]();
      executeSchedule_1$5.executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction_1$e.isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
scheduleIterable$1.scheduleIterable = scheduleIterable;
var scheduleAsyncIterable$1 = {};
Object.defineProperty(scheduleAsyncIterable$1, "__esModule", { value: true });
scheduleAsyncIterable$1.scheduleAsyncIterable = void 0;
var Observable_1$h = Observable$1;
var executeSchedule_1$4 = executeSchedule$1;
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable_1$h.Observable(function(subscriber) {
    executeSchedule_1$4.executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule_1$4.executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
scheduleAsyncIterable$1.scheduleAsyncIterable = scheduleAsyncIterable;
var scheduleReadableStreamLike$1 = {};
Object.defineProperty(scheduleReadableStreamLike$1, "__esModule", { value: true });
scheduleReadableStreamLike$1.scheduleReadableStreamLike = void 0;
var scheduleAsyncIterable_1$1 = scheduleAsyncIterable$1;
var isReadableStreamLike_1$1 = isReadableStreamLike$1;
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable_1$1.scheduleAsyncIterable(isReadableStreamLike_1$1.readableStreamLikeToAsyncGenerator(input), scheduler);
}
scheduleReadableStreamLike$1.scheduleReadableStreamLike = scheduleReadableStreamLike;
Object.defineProperty(scheduled$1, "__esModule", { value: true });
scheduled$1.scheduled = void 0;
var scheduleObservable_1 = scheduleObservable$1;
var schedulePromise_1 = schedulePromise$1;
var scheduleArray_1 = scheduleArray$1;
var scheduleIterable_1$1 = scheduleIterable$1;
var scheduleAsyncIterable_1 = scheduleAsyncIterable$1;
var isInteropObservable_1 = isInteropObservable$1;
var isPromise_1 = isPromise$2;
var isArrayLike_1$1 = isArrayLike;
var isIterable_1 = isIterable$1;
var isAsyncIterable_1 = isAsyncIterable$1;
var throwUnobservableError_1 = throwUnobservableError;
var isReadableStreamLike_1 = isReadableStreamLike$1;
var scheduleReadableStreamLike_1 = scheduleReadableStreamLike$1;
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable_1.isInteropObservable(input)) {
      return scheduleObservable_1.scheduleObservable(input, scheduler);
    }
    if (isArrayLike_1$1.isArrayLike(input)) {
      return scheduleArray_1.scheduleArray(input, scheduler);
    }
    if (isPromise_1.isPromise(input)) {
      return schedulePromise_1.schedulePromise(input, scheduler);
    }
    if (isAsyncIterable_1.isAsyncIterable(input)) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable_1.isIterable(input)) {
      return scheduleIterable_1$1.scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike_1.isReadableStreamLike(input)) {
      return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw throwUnobservableError_1.createInvalidObservableTypeError(input);
}
scheduled$1.scheduled = scheduled;
Object.defineProperty(from$1, "__esModule", { value: true });
from$1.from = void 0;
var scheduled_1 = scheduled$1;
var innerFrom_1$B = innerFrom$1;
function from(input, scheduler) {
  return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1$B.innerFrom(input);
}
from$1.from = from;
Object.defineProperty(of$1, "__esModule", { value: true });
of$1.of = void 0;
var args_1$c = args;
var from_1$6 = from$1;
function of() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$c.popScheduler(args2);
  return from_1$6.from(args2, scheduler);
}
of$1.of = of;
var throwError$1 = {};
Object.defineProperty(throwError$1, "__esModule", { value: true });
throwError$1.throwError = void 0;
var Observable_1$g = Observable$1;
var isFunction_1$d = isFunction$1;
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction_1$d.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable_1$g.Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}
throwError$1.throwError = throwError;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
  var empty_12 = empty;
  var of_12 = of$1;
  var throwError_1 = throwError$1;
  var isFunction_12 = isFunction$1;
  (function(NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
  })(exports.NotificationKind || (exports.NotificationKind = {}));
  var Notification2 = function() {
    function Notification3(kind, value, error) {
      this.kind = kind;
      this.value = value;
      this.error = error;
      this.hasValue = kind === "N";
    }
    Notification3.prototype.observe = function(observer) {
      return observeNotification(this, observer);
    };
    Notification3.prototype.do = function(nextHandler, errorHandler, completeHandler) {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
    };
    Notification3.prototype.accept = function(nextOrObserver, error, complete) {
      var _a;
      return isFunction_12.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
    };
    Notification3.prototype.toObservable = function() {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      var result = kind === "N" ? of_12.of(value) : kind === "E" ? throwError_1.throwError(function() {
        return error;
      }) : kind === "C" ? empty_12.EMPTY : 0;
      if (!result) {
        throw new TypeError("Unexpected notification kind " + kind);
      }
      return result;
    };
    Notification3.createNext = function(value) {
      return new Notification3("N", value);
    };
    Notification3.createError = function(err) {
      return new Notification3("E", void 0, err);
    };
    Notification3.createComplete = function() {
      return Notification3.completeNotification;
    };
    Notification3.completeNotification = new Notification3("C");
    return Notification3;
  }();
  exports.Notification = Notification2;
  function observeNotification(notification, observer) {
    var _a, _b, _c;
    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
    if (typeof kind !== "string") {
      throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
  }
  exports.observeNotification = observeNotification;
})(Notification);
var isObservable$1 = {};
Object.defineProperty(isObservable$1, "__esModule", { value: true });
isObservable$1.isObservable = void 0;
var Observable_1$f = Observable$1;
var isFunction_1$c = isFunction$1;
function isObservable(obj) {
  return !!obj && (obj instanceof Observable_1$f.Observable || isFunction_1$c.isFunction(obj.lift) && isFunction_1$c.isFunction(obj.subscribe));
}
isObservable$1.isObservable = isObservable;
var lastValueFrom$1 = {};
var EmptyError = {};
Object.defineProperty(EmptyError, "__esModule", { value: true });
EmptyError.EmptyError = void 0;
var createErrorClass_1$3 = createErrorClass$1;
EmptyError.EmptyError = createErrorClass_1$3.createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
Object.defineProperty(lastValueFrom$1, "__esModule", { value: true });
lastValueFrom$1.lastValueFrom = void 0;
var EmptyError_1$5 = EmptyError;
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve(_value);
        } else if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError_1$5.EmptyError());
        }
      }
    });
  });
}
lastValueFrom$1.lastValueFrom = lastValueFrom;
var firstValueFrom$1 = {};
Object.defineProperty(firstValueFrom$1, "__esModule", { value: true });
firstValueFrom$1.firstValueFrom = void 0;
var EmptyError_1$4 = EmptyError;
var Subscriber_1$1 = Subscriber;
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new Subscriber_1$1.SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError_1$4.EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
firstValueFrom$1.firstValueFrom = firstValueFrom;
var ArgumentOutOfRangeError = {};
Object.defineProperty(ArgumentOutOfRangeError, "__esModule", { value: true });
ArgumentOutOfRangeError.ArgumentOutOfRangeError = void 0;
var createErrorClass_1$2 = createErrorClass$1;
ArgumentOutOfRangeError.ArgumentOutOfRangeError = createErrorClass_1$2.createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});
var NotFoundError$1 = {};
Object.defineProperty(NotFoundError$1, "__esModule", { value: true });
NotFoundError$1.NotFoundError = void 0;
var createErrorClass_1$1 = createErrorClass$1;
NotFoundError$1.NotFoundError = createErrorClass_1$1.createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});
var SequenceError = {};
Object.defineProperty(SequenceError, "__esModule", { value: true });
SequenceError.SequenceError = void 0;
var createErrorClass_1 = createErrorClass$1;
SequenceError.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});
var timeout = {};
var isDate = {};
Object.defineProperty(isDate, "__esModule", { value: true });
isDate.isValidDate = void 0;
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
isDate.isValidDate = isValidDate;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeout = exports.TimeoutError = void 0;
  var async_12 = async;
  var isDate_12 = isDate;
  var lift_12 = lift;
  var innerFrom_12 = innerFrom$1;
  var createErrorClass_12 = createErrorClass$1;
  var OperatorSubscriber_12 = OperatorSubscriber$1;
  var executeSchedule_12 = executeSchedule$1;
  exports.TimeoutError = createErrorClass_12.createErrorClass(function(_super) {
    return function TimeoutErrorImpl(info) {
      if (info === void 0) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    };
  });
  function timeout2(config2, schedulerArg) {
    var _a = isDate_12.isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_12.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
    if (first2 == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return lift_12.operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = function(delay2) {
        timerSubscription = executeSchedule_12.executeSchedule(subscriber, scheduler, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom_12.innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err) {
            subscriber.error(err);
          }
        }, delay2);
      };
      originalSourceSubscription = source.subscribe(OperatorSubscriber_12.createOperatorSubscriber(subscriber, function(value) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value);
        each > 0 && startTimer(each);
      }, void 0, void 0, function() {
        if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
    });
  }
  exports.timeout = timeout2;
  function timeoutErrorFactory(info) {
    throw new exports.TimeoutError(info);
  }
})(timeout);
var bindCallback$1 = {};
var bindCallbackInternals$1 = {};
var mapOneOrManyArgs$1 = {};
var map$2 = {};
Object.defineProperty(map$2, "__esModule", { value: true });
map$2.map = void 0;
var lift_1$10 = lift;
var OperatorSubscriber_1$S = OperatorSubscriber$1;
function map$1(project2, thisArg) {
  return lift_1$10.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$S.createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project2.call(thisArg, value, index++));
    }));
  });
}
map$2.map = map$1;
var __read$h = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$g = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(mapOneOrManyArgs$1, "__esModule", { value: true });
mapOneOrManyArgs$1.mapOneOrManyArgs = void 0;
var map_1$5 = map$2;
var isArray$3 = Array.isArray;
function callOrApply(fn2, args2) {
  return isArray$3(args2) ? fn2.apply(void 0, __spreadArray$g([], __read$h(args2))) : fn2(args2);
}
function mapOneOrManyArgs(fn2) {
  return map_1$5.map(function(args2) {
    return callOrApply(fn2, args2);
  });
}
mapOneOrManyArgs$1.mapOneOrManyArgs = mapOneOrManyArgs;
var __read$g = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$f = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(bindCallbackInternals$1, "__esModule", { value: true });
bindCallbackInternals$1.bindCallbackInternals = void 0;
var isScheduler_1$2 = isScheduler$1;
var Observable_1$e = Observable$1;
var subscribeOn_1 = subscribeOn$1;
var mapOneOrManyArgs_1$6 = mapOneOrManyArgs$1;
var observeOn_1 = observeOn$1;
var AsyncSubject_1$1 = AsyncSubject$1;
function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler_1$2.isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args2).pipe(mapOneOrManyArgs_1$6.mapOneOrManyArgs(resultSelector));
      };
    }
  }
  if (scheduler) {
    return function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args2).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    };
  }
  return function() {
    var _this = this;
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var subject = new AsyncSubject_1$1.AsyncSubject();
    var uninitialized = true;
    return new Observable_1$e.Observable(function(subscriber) {
      var subs = subject.subscribe(subscriber);
      if (uninitialized) {
        uninitialized = false;
        var isAsync_1 = false;
        var isComplete_1 = false;
        callbackFunc.apply(_this, __spreadArray$f(__spreadArray$f([], __read$g(args2)), [
          function() {
            var results = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              results[_i2] = arguments[_i2];
            }
            if (isNodeStyle) {
              var err = results.shift();
              if (err != null) {
                subject.error(err);
                return;
              }
            }
            subject.next(1 < results.length ? results : results[0]);
            isComplete_1 = true;
            if (isAsync_1) {
              subject.complete();
            }
          }
        ]));
        if (isComplete_1) {
          subject.complete();
        }
        isAsync_1 = true;
      }
      return subs;
    });
  };
}
bindCallbackInternals$1.bindCallbackInternals = bindCallbackInternals;
Object.defineProperty(bindCallback$1, "__esModule", { value: true });
bindCallback$1.bindCallback = void 0;
var bindCallbackInternals_1$1 = bindCallbackInternals$1;
function bindCallback(callbackFunc, resultSelector, scheduler) {
  return bindCallbackInternals_1$1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
}
bindCallback$1.bindCallback = bindCallback;
var bindNodeCallback$1 = {};
Object.defineProperty(bindNodeCallback$1, "__esModule", { value: true });
bindNodeCallback$1.bindNodeCallback = void 0;
var bindCallbackInternals_1 = bindCallbackInternals$1;
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
}
bindNodeCallback$1.bindNodeCallback = bindNodeCallback;
var combineLatest$3 = {};
var argsArgArrayOrObject$1 = {};
Object.defineProperty(argsArgArrayOrObject$1, "__esModule", { value: true });
argsArgArrayOrObject$1.argsArgArrayOrObject = void 0;
var isArray$2 = Array.isArray;
var getPrototypeOf$1 = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(args2) {
  if (args2.length === 1) {
    var first_1 = args2[0];
    if (isArray$2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args: args2, keys: null };
}
argsArgArrayOrObject$1.argsArgArrayOrObject = argsArgArrayOrObject;
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf$1(obj) === objectProto;
}
var createObject$1 = {};
Object.defineProperty(createObject$1, "__esModule", { value: true });
createObject$1.createObject = void 0;
function createObject(keys, values) {
  return keys.reduce(function(result, key, i2) {
    return result[key] = values[i2], result;
  }, {});
}
createObject$1.createObject = createObject;
Object.defineProperty(combineLatest$3, "__esModule", { value: true });
combineLatest$3.combineLatestInit = combineLatest$3.combineLatest = void 0;
var Observable_1$d = Observable$1;
var argsArgArrayOrObject_1$1 = argsArgArrayOrObject$1;
var from_1$5 = from$1;
var identity_1$d = identity$1;
var mapOneOrManyArgs_1$5 = mapOneOrManyArgs$1;
var args_1$b = args;
var createObject_1$1 = createObject$1;
var OperatorSubscriber_1$R = OperatorSubscriber$1;
var executeSchedule_1$3 = executeSchedule$1;
function combineLatest$2() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$b.popScheduler(args2);
  var resultSelector = args_1$b.popResultSelector(args2);
  var _a = argsArgArrayOrObject_1$1.argsArgArrayOrObject(args2), observables = _a.args, keys = _a.keys;
  if (observables.length === 0) {
    return from_1$5.from([], scheduler);
  }
  var result = new Observable_1$d.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject_1$1.createObject(keys, values);
  } : identity_1$d.identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs_1$5.mapOneOrManyArgs(resultSelector)) : result;
}
combineLatest$3.combineLatest = combineLatest$2;
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity_1$d.identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i3) {
        maybeSchedule(scheduler, function() {
          var source = from_1$5.from(observables[i3], scheduler);
          var hasFirstValue = false;
          source.subscribe(OperatorSubscriber_1$R.createOperatorSubscriber(subscriber, function(value) {
            values[i3] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i2 = 0; i2 < length; i2++) {
        _loop_1(i2);
      }
    }, subscriber);
  };
}
combineLatest$3.combineLatestInit = combineLatestInit;
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule_1$3.executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
var concat$4 = {};
var concatAll$1 = {};
var mergeAll$1 = {};
var mergeMap$1 = {};
var mergeInternals$1 = {};
Object.defineProperty(mergeInternals$1, "__esModule", { value: true });
mergeInternals$1.mergeInternals = void 0;
var innerFrom_1$A = innerFrom$1;
var executeSchedule_1$2 = executeSchedule$1;
var OperatorSubscriber_1$Q = OperatorSubscriber$1;
function mergeInternals(source, subscriber, project2, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom_1$A.innerFrom(project2(value, index++)).subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule_1$2.executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
mergeInternals$1.mergeInternals = mergeInternals;
Object.defineProperty(mergeMap$1, "__esModule", { value: true });
mergeMap$1.mergeMap = void 0;
var map_1$4 = map$2;
var innerFrom_1$z = innerFrom$1;
var lift_1$$ = lift;
var mergeInternals_1$2 = mergeInternals$1;
var isFunction_1$b = isFunction$1;
function mergeMap(project2, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction_1$b.isFunction(resultSelector)) {
    return mergeMap(function(a2, i2) {
      return map_1$4.map(function(b2, ii) {
        return resultSelector(a2, b2, i2, ii);
      })(innerFrom_1$z.innerFrom(project2(a2, i2)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return lift_1$$.operate(function(source, subscriber) {
    return mergeInternals_1$2.mergeInternals(source, subscriber, project2, concurrent);
  });
}
mergeMap$1.mergeMap = mergeMap;
Object.defineProperty(mergeAll$1, "__esModule", { value: true });
mergeAll$1.mergeAll = void 0;
var mergeMap_1$6 = mergeMap$1;
var identity_1$c = identity$1;
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap_1$6.mergeMap(identity_1$c.identity, concurrent);
}
mergeAll$1.mergeAll = mergeAll;
Object.defineProperty(concatAll$1, "__esModule", { value: true });
concatAll$1.concatAll = void 0;
var mergeAll_1$2 = mergeAll$1;
function concatAll() {
  return mergeAll_1$2.mergeAll(1);
}
concatAll$1.concatAll = concatAll;
Object.defineProperty(concat$4, "__esModule", { value: true });
concat$4.concat = void 0;
var concatAll_1$1 = concatAll$1;
var args_1$a = args;
var from_1$4 = from$1;
function concat$3() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  return concatAll_1$1.concatAll()(from_1$4.from(args2, args_1$a.popScheduler(args2)));
}
concat$4.concat = concat$3;
var connectable$1 = {};
var defer$1 = {};
Object.defineProperty(defer$1, "__esModule", { value: true });
defer$1.defer = void 0;
var Observable_1$c = Observable$1;
var innerFrom_1$y = innerFrom$1;
function defer(observableFactory) {
  return new Observable_1$c.Observable(function(subscriber) {
    innerFrom_1$y.innerFrom(observableFactory()).subscribe(subscriber);
  });
}
defer$1.defer = defer;
Object.defineProperty(connectable$1, "__esModule", { value: true });
connectable$1.connectable = void 0;
var Subject_1$b = Subject$1;
var Observable_1$b = Observable$1;
var defer_1$2 = defer$1;
var DEFAULT_CONFIG$1 = {
  connector: function() {
    return new Subject_1$b.Subject();
  },
  resetOnDisconnect: true
};
function connectable(source, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG$1;
  }
  var connection = null;
  var connector = config2.connector, _a = config2.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
  var subject = connector();
  var result = new Observable_1$b.Observable(function(subscriber) {
    return subject.subscribe(subscriber);
  });
  result.connect = function() {
    if (!connection || connection.closed) {
      connection = defer_1$2.defer(function() {
        return source;
      }).subscribe(subject);
      if (resetOnDisconnect) {
        connection.add(function() {
          return subject = connector();
        });
      }
    }
    return connection;
  };
  return result;
}
connectable$1.connectable = connectable;
var forkJoin$1 = {};
Object.defineProperty(forkJoin$1, "__esModule", { value: true });
forkJoin$1.forkJoin = void 0;
var Observable_1$a = Observable$1;
var argsArgArrayOrObject_1 = argsArgArrayOrObject$1;
var innerFrom_1$x = innerFrom$1;
var args_1$9 = args;
var OperatorSubscriber_1$P = OperatorSubscriber$1;
var mapOneOrManyArgs_1$4 = mapOneOrManyArgs$1;
var createObject_1 = createObject$1;
function forkJoin() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var resultSelector = args_1$9.popResultSelector(args2);
  var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args2), sources = _a.args, keys = _a.keys;
  var result = new Observable_1$a.Observable(function(subscriber) {
    var length = sources.length;
    if (!length) {
      subscriber.complete();
      return;
    }
    var values = new Array(length);
    var remainingCompletions = length;
    var remainingEmissions = length;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom_1$x.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1$P.createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs_1$4.mapOneOrManyArgs(resultSelector)) : result;
}
forkJoin$1.forkJoin = forkJoin;
var fromEvent$1 = {};
var __read$f = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
Object.defineProperty(fromEvent$1, "__esModule", { value: true });
fromEvent$1.fromEvent = void 0;
var innerFrom_1$w = innerFrom$1;
var Observable_1$9 = Observable$1;
var mergeMap_1$5 = mergeMap$1;
var isArrayLike_1 = isArrayLike;
var isFunction_1$a = isFunction$1;
var mapOneOrManyArgs_1$3 = mapOneOrManyArgs$1;
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options2, resultSelector) {
  if (isFunction_1$a.isFunction(options2)) {
    resultSelector = options2;
    options2 = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options2).pipe(mapOneOrManyArgs_1$3.mapOneOrManyArgs(resultSelector));
  }
  var _a = __read$f(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options2);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add2 = _a[0], remove = _a[1];
  if (!add2) {
    if (isArrayLike_1.isArrayLike(target)) {
      return mergeMap_1$5.mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options2);
      })(innerFrom_1$w.innerFrom(target));
    }
  }
  if (!add2) {
    throw new TypeError("Invalid event target");
  }
  return new Observable_1$9.Observable(function(subscriber) {
    var handler = function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return subscriber.next(1 < args2.length ? args2 : args2[0]);
    };
    add2(handler);
    return function() {
      return remove(handler);
    };
  });
}
fromEvent$1.fromEvent = fromEvent;
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction_1$a.isFunction(target.addListener) && isFunction_1$a.isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction_1$a.isFunction(target.on) && isFunction_1$a.isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction_1$a.isFunction(target.addEventListener) && isFunction_1$a.isFunction(target.removeEventListener);
}
var fromEventPattern$1 = {};
Object.defineProperty(fromEventPattern$1, "__esModule", { value: true });
fromEventPattern$1.fromEventPattern = void 0;
var Observable_1$8 = Observable$1;
var isFunction_1$9 = isFunction$1;
var mapOneOrManyArgs_1$2 = mapOneOrManyArgs$1;
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1$2.mapOneOrManyArgs(resultSelector));
  }
  return new Observable_1$8.Observable(function(subscriber) {
    var handler = function() {
      var e2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e2[_i] = arguments[_i];
      }
      return subscriber.next(e2.length === 1 ? e2[0] : e2);
    };
    var retValue = addHandler(handler);
    return isFunction_1$9.isFunction(removeHandler) ? function() {
      return removeHandler(handler, retValue);
    } : void 0;
  });
}
fromEventPattern$1.fromEventPattern = fromEventPattern;
var generate$1 = {};
var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(generate$1, "__esModule", { value: true });
generate$1.generate = void 0;
var identity_1$b = identity$1;
var isScheduler_1$1 = isScheduler$1;
var defer_1$1 = defer$1;
var scheduleIterable_1 = scheduleIterable$1;
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
  var _a, _b;
  var resultSelector;
  var initialState;
  if (arguments.length === 1) {
    _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1$b.identity : _b, scheduler = _a.scheduler;
  } else {
    initialState = initialStateOrOptions;
    if (!resultSelectorOrScheduler || isScheduler_1$1.isScheduler(resultSelectorOrScheduler)) {
      resultSelector = identity_1$b.identity;
      scheduler = resultSelectorOrScheduler;
    } else {
      resultSelector = resultSelectorOrScheduler;
    }
  }
  function gen() {
    var state;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          state = initialState;
          _a2.label = 1;
        case 1:
          if (!(!condition || condition(state)))
            return [3, 4];
          return [4, resultSelector(state)];
        case 2:
          _a2.sent();
          _a2.label = 3;
        case 3:
          state = iterate(state);
          return [3, 1];
        case 4:
          return [2];
      }
    });
  }
  return defer_1$1.defer(scheduler ? function() {
    return scheduleIterable_1.scheduleIterable(gen(), scheduler);
  } : gen);
}
generate$1.generate = generate;
var iif$1 = {};
Object.defineProperty(iif$1, "__esModule", { value: true });
iif$1.iif = void 0;
var defer_1 = defer$1;
function iif(condition, trueResult, falseResult) {
  return defer_1.defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
iif$1.iif = iif;
var interval$1 = {};
var timer$1 = {};
Object.defineProperty(timer$1, "__esModule", { value: true });
timer$1.timer = void 0;
var Observable_1$7 = Observable$1;
var async_1$a = async;
var isScheduler_1 = isScheduler$1;
var isDate_1$1 = isDate;
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async_1$a.async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler_1.isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable_1$7.Observable(function(subscriber) {
    var due = isDate_1$1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n2 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n2++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
timer$1.timer = timer;
Object.defineProperty(interval$1, "__esModule", { value: true });
interval$1.interval = void 0;
var async_1$9 = async;
var timer_1$5 = timer$1;
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async_1$9.asyncScheduler;
  }
  if (period < 0) {
    period = 0;
  }
  return timer_1$5.timer(period, period, scheduler);
}
interval$1.interval = interval;
var merge$5 = {};
Object.defineProperty(merge$5, "__esModule", { value: true });
merge$5.merge = void 0;
var mergeAll_1$1 = mergeAll$1;
var innerFrom_1$v = innerFrom$1;
var empty_1$6 = empty;
var args_1$8 = args;
var from_1$3 = from$1;
function merge$4() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$8.popScheduler(args2);
  var concurrent = args_1$8.popNumber(args2, Infinity);
  var sources = args2;
  return !sources.length ? empty_1$6.EMPTY : sources.length === 1 ? innerFrom_1$v.innerFrom(sources[0]) : mergeAll_1$1.mergeAll(concurrent)(from_1$3.from(sources, scheduler));
}
merge$5.merge = merge$4;
var never = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.never = exports.NEVER = void 0;
  var Observable_12 = Observable$1;
  var noop_12 = noop$1;
  exports.NEVER = new Observable_12.Observable(noop_12.noop);
  function never2() {
    return exports.NEVER;
  }
  exports.never = never2;
})(never);
var onErrorResumeNext$1 = {};
var argsOrArgArray$1 = {};
Object.defineProperty(argsOrArgArray$1, "__esModule", { value: true });
argsOrArgArray$1.argsOrArgArray = void 0;
var isArray$1 = Array.isArray;
function argsOrArgArray(args2) {
  return args2.length === 1 && isArray$1(args2[0]) ? args2[0] : args2;
}
argsOrArgArray$1.argsOrArgArray = argsOrArgArray;
Object.defineProperty(onErrorResumeNext$1, "__esModule", { value: true });
onErrorResumeNext$1.onErrorResumeNext = void 0;
var Observable_1$6 = Observable$1;
var argsOrArgArray_1$6 = argsOrArgArray$1;
var OperatorSubscriber_1$O = OperatorSubscriber$1;
var noop_1$c = noop$1;
var innerFrom_1$u = innerFrom$1;
function onErrorResumeNext() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var nextSources = argsOrArgArray_1$6.argsOrArgArray(sources);
  return new Observable_1$6.Observable(function(subscriber) {
    var sourceIndex = 0;
    var subscribeNext = function() {
      if (sourceIndex < nextSources.length) {
        var nextSource = void 0;
        try {
          nextSource = innerFrom_1$u.innerFrom(nextSources[sourceIndex++]);
        } catch (err) {
          subscribeNext();
          return;
        }
        var innerSubscriber = new OperatorSubscriber_1$O.OperatorSubscriber(subscriber, void 0, noop_1$c.noop, noop_1$c.noop);
        nextSource.subscribe(innerSubscriber);
        innerSubscriber.add(subscribeNext);
      } else {
        subscriber.complete();
      }
    };
    subscribeNext();
  });
}
onErrorResumeNext$1.onErrorResumeNext = onErrorResumeNext;
var pairs$1 = {};
Object.defineProperty(pairs$1, "__esModule", { value: true });
pairs$1.pairs = void 0;
var from_1$2 = from$1;
function pairs(obj, scheduler) {
  return from_1$2.from(Object.entries(obj), scheduler);
}
pairs$1.pairs = pairs;
var partition$3 = {};
var not$3 = {};
Object.defineProperty(not$3, "__esModule", { value: true });
not$3.not = void 0;
function not$2(pred, thisArg) {
  return function(value, index) {
    return !pred.call(thisArg, value, index);
  };
}
not$3.not = not$2;
var filter$2 = {};
Object.defineProperty(filter$2, "__esModule", { value: true });
filter$2.filter = void 0;
var lift_1$_ = lift;
var OperatorSubscriber_1$N = OperatorSubscriber$1;
function filter$1(predicate, thisArg) {
  return lift_1$_.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$N.createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
filter$2.filter = filter$1;
Object.defineProperty(partition$3, "__esModule", { value: true });
partition$3.partition = void 0;
var not_1$1 = not$3;
var filter_1$5 = filter$2;
var innerFrom_1$t = innerFrom$1;
function partition$2(source, predicate, thisArg) {
  return [filter_1$5.filter(predicate, thisArg)(innerFrom_1$t.innerFrom(source)), filter_1$5.filter(not_1$1.not(predicate, thisArg))(innerFrom_1$t.innerFrom(source))];
}
partition$3.partition = partition$2;
var race$3 = {};
Object.defineProperty(race$3, "__esModule", { value: true });
race$3.raceInit = race$3.race = void 0;
var Observable_1$5 = Observable$1;
var innerFrom_1$s = innerFrom$1;
var argsOrArgArray_1$5 = argsOrArgArray$1;
var OperatorSubscriber_1$M = OperatorSubscriber$1;
function race$2() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray_1$5.argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom_1$s.innerFrom(sources[0]) : new Observable_1$5.Observable(raceInit(sources));
}
race$3.race = race$2;
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i3) {
      subscriptions.push(innerFrom_1$s.innerFrom(sources[i3]).subscribe(OperatorSubscriber_1$M.createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s2 = 0; s2 < subscriptions.length; s2++) {
            s2 !== i3 && subscriptions[s2].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i2 = 0; subscriptions && !subscriber.closed && i2 < sources.length; i2++) {
      _loop_1(i2);
    }
  };
}
race$3.raceInit = raceInit;
var range$2 = {};
Object.defineProperty(range$2, "__esModule", { value: true });
range$2.range = void 0;
var Observable_1$4 = Observable$1;
var empty_1$5 = empty;
function range$1(start, count2, scheduler) {
  if (count2 == null) {
    count2 = start;
    start = 0;
  }
  if (count2 <= 0) {
    return empty_1$5.EMPTY;
  }
  var end = count2 + start;
  return new Observable_1$4.Observable(scheduler ? function(subscriber) {
    var n2 = start;
    return scheduler.schedule(function() {
      if (n2 < end) {
        subscriber.next(n2++);
        this.schedule();
      } else {
        subscriber.complete();
      }
    });
  } : function(subscriber) {
    var n2 = start;
    while (n2 < end && !subscriber.closed) {
      subscriber.next(n2++);
    }
    subscriber.complete();
  });
}
range$2.range = range$1;
var using$1 = {};
Object.defineProperty(using$1, "__esModule", { value: true });
using$1.using = void 0;
var Observable_1$3 = Observable$1;
var innerFrom_1$r = innerFrom$1;
var empty_1$4 = empty;
function using(resourceFactory, observableFactory) {
  return new Observable_1$3.Observable(function(subscriber) {
    var resource = resourceFactory();
    var result = observableFactory(resource);
    var source = result ? innerFrom_1$r.innerFrom(result) : empty_1$4.EMPTY;
    source.subscribe(subscriber);
    return function() {
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
using$1.using = using;
var zip$4 = {};
var __read$e = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$e = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(zip$4, "__esModule", { value: true });
zip$4.zip = void 0;
var Observable_1$2 = Observable$1;
var innerFrom_1$q = innerFrom$1;
var argsOrArgArray_1$4 = argsOrArgArray$1;
var empty_1$3 = empty;
var OperatorSubscriber_1$L = OperatorSubscriber$1;
var args_1$7 = args;
function zip$3() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var resultSelector = args_1$7.popResultSelector(args2);
  var sources = argsOrArgArray_1$4.argsOrArgArray(args2);
  return sources.length ? new Observable_1$2.Observable(function(subscriber) {
    var buffers = sources.map(function() {
      return [];
    });
    var completed = sources.map(function() {
      return false;
    });
    subscriber.add(function() {
      buffers = completed = null;
    });
    var _loop_1 = function(sourceIndex2) {
      innerFrom_1$q.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1$L.createOperatorSubscriber(subscriber, function(value) {
        buffers[sourceIndex2].push(value);
        if (buffers.every(function(buffer2) {
          return buffer2.length;
        })) {
          var result = buffers.map(function(buffer2) {
            return buffer2.shift();
          });
          subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray$e([], __read$e(result))) : result);
          if (buffers.some(function(buffer2, i2) {
            return !buffer2.length && completed[i2];
          })) {
            subscriber.complete();
          }
        }
      }, function() {
        completed[sourceIndex2] = true;
        !buffers[sourceIndex2].length && subscriber.complete();
      }));
    };
    for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
    return function() {
      buffers = completed = null;
    };
  }) : empty_1$3.EMPTY;
}
zip$4.zip = zip$3;
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
var audit$1 = {};
Object.defineProperty(audit$1, "__esModule", { value: true });
audit$1.audit = void 0;
var lift_1$Z = lift;
var innerFrom_1$p = innerFrom$1;
var OperatorSubscriber_1$K = OperatorSubscriber$1;
function audit(durationSelector) {
  return lift_1$Z.operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var isComplete = false;
    var endDuration = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
      isComplete && subscriber.complete();
    };
    var cleanupDuration = function() {
      durationSubscriber = null;
      isComplete && subscriber.complete();
    };
    source.subscribe(OperatorSubscriber_1$K.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
      if (!durationSubscriber) {
        innerFrom_1$p.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1$K.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
      }
    }, function() {
      isComplete = true;
      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
    }));
  });
}
audit$1.audit = audit;
var auditTime$1 = {};
Object.defineProperty(auditTime$1, "__esModule", { value: true });
auditTime$1.auditTime = void 0;
var async_1$8 = async;
var audit_1 = audit$1;
var timer_1$4 = timer$1;
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$8.asyncScheduler;
  }
  return audit_1.audit(function() {
    return timer_1$4.timer(duration, scheduler);
  });
}
auditTime$1.auditTime = auditTime;
var buffer$1 = {};
Object.defineProperty(buffer$1, "__esModule", { value: true });
buffer$1.buffer = void 0;
var lift_1$Y = lift;
var noop_1$b = noop$1;
var OperatorSubscriber_1$J = OperatorSubscriber$1;
var innerFrom_1$o = innerFrom$1;
function buffer(closingNotifier) {
  return lift_1$Y.operate(function(source, subscriber) {
    var currentBuffer = [];
    source.subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(subscriber, function(value) {
      return currentBuffer.push(value);
    }, function() {
      subscriber.next(currentBuffer);
      subscriber.complete();
    }));
    innerFrom_1$o.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(subscriber, function() {
      var b2 = currentBuffer;
      currentBuffer = [];
      subscriber.next(b2);
    }, noop_1$b.noop));
    return function() {
      currentBuffer = null;
    };
  });
}
buffer$1.buffer = buffer;
var bufferCount$1 = {};
var __values$5 = commonjsGlobal && commonjsGlobal.__values || function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferCount$1, "__esModule", { value: true });
bufferCount$1.bufferCount = void 0;
var lift_1$X = lift;
var OperatorSubscriber_1$I = OperatorSubscriber$1;
var arrRemove_1$4 = arrRemove$1;
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
  return lift_1$X.operate(function(source, subscriber) {
    var buffers = [];
    var count2 = 0;
    source.subscribe(OperatorSubscriber_1$I.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a, e_2, _b;
      var toEmit = null;
      if (count2++ % startBufferEvery === 0) {
        buffers.push([]);
      }
      try {
        for (var buffers_1 = __values$5(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
          if (bufferSize <= buffer2.length) {
            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
            toEmit.push(buffer2);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
            _a.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (toEmit) {
        try {
          for (var toEmit_1 = __values$5(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
            var buffer2 = toEmit_1_1.value;
            arrRemove_1$4.arrRemove(buffers, buffer2);
            subscriber.next(buffer2);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
              _b.call(toEmit_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    }, function() {
      var e_3, _a;
      try {
        for (var buffers_2 = __values$5(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
          var buffer2 = buffers_2_1.value;
          subscriber.next(buffer2);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
            _a.call(buffers_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffers = null;
    }));
  });
}
bufferCount$1.bufferCount = bufferCount;
var bufferTime$1 = {};
var __values$4 = commonjsGlobal && commonjsGlobal.__values || function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferTime$1, "__esModule", { value: true });
bufferTime$1.bufferTime = void 0;
var Subscription_1$3 = Subscription$1;
var lift_1$W = lift;
var OperatorSubscriber_1$H = OperatorSubscriber$1;
var arrRemove_1$3 = arrRemove$1;
var async_1$7 = async;
var args_1$6 = args;
var executeSchedule_1$1 = executeSchedule$1;
function bufferTime(bufferTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler = (_a = args_1$6.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1$7.asyncScheduler;
  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxBufferSize = otherArgs[1] || Infinity;
  return lift_1$W.operate(function(source, subscriber) {
    var bufferRecords = [];
    var restartOnEmit = false;
    var emit = function(record) {
      var buffer2 = record.buffer, subs = record.subs;
      subs.unsubscribe();
      arrRemove_1$3.arrRemove(bufferRecords, record);
      subscriber.next(buffer2);
      restartOnEmit && startBuffer();
    };
    var startBuffer = function() {
      if (bufferRecords) {
        var subs = new Subscription_1$3.Subscription();
        subscriber.add(subs);
        var buffer2 = [];
        var record_1 = {
          buffer: buffer2,
          subs
        };
        bufferRecords.push(record_1);
        executeSchedule_1$1.executeSchedule(subs, scheduler, function() {
          return emit(record_1);
        }, bufferTimeSpan);
      }
    };
    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
      executeSchedule_1$1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
    } else {
      restartOnEmit = true;
    }
    startBuffer();
    var bufferTimeSubscriber = OperatorSubscriber_1$H.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a2;
      var recordsCopy = bufferRecords.slice();
      try {
        for (var recordsCopy_1 = __values$4(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
          var record = recordsCopy_1_1.value;
          var buffer2 = record.buffer;
          buffer2.push(value);
          maxBufferSize <= buffer2.length && emit(record);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
            _a2.call(recordsCopy_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
        subscriber.next(bufferRecords.shift().buffer);
      }
      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
      subscriber.complete();
      subscriber.unsubscribe();
    }, void 0, function() {
      return bufferRecords = null;
    });
    source.subscribe(bufferTimeSubscriber);
  });
}
bufferTime$1.bufferTime = bufferTime;
var bufferToggle$1 = {};
var __values$3 = commonjsGlobal && commonjsGlobal.__values || function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferToggle$1, "__esModule", { value: true });
bufferToggle$1.bufferToggle = void 0;
var Subscription_1$2 = Subscription$1;
var lift_1$V = lift;
var innerFrom_1$n = innerFrom$1;
var OperatorSubscriber_1$G = OperatorSubscriber$1;
var noop_1$a = noop$1;
var arrRemove_1$2 = arrRemove$1;
function bufferToggle(openings, closingSelector) {
  return lift_1$V.operate(function(source, subscriber) {
    var buffers = [];
    innerFrom_1$n.innerFrom(openings).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, function(openValue) {
      var buffer2 = [];
      buffers.push(buffer2);
      var closingSubscription = new Subscription_1$2.Subscription();
      var emitBuffer = function() {
        arrRemove_1$2.arrRemove(buffers, buffer2);
        subscriber.next(buffer2);
        closingSubscription.unsubscribe();
      };
      closingSubscription.add(innerFrom_1$n.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, emitBuffer, noop_1$a.noop)));
    }, noop_1$a.noop));
    source.subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var buffers_1 = __values$3(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
            _a.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (buffers.length > 0) {
        subscriber.next(buffers.shift());
      }
      subscriber.complete();
    }));
  });
}
bufferToggle$1.bufferToggle = bufferToggle;
var bufferWhen$1 = {};
Object.defineProperty(bufferWhen$1, "__esModule", { value: true });
bufferWhen$1.bufferWhen = void 0;
var lift_1$U = lift;
var noop_1$9 = noop$1;
var OperatorSubscriber_1$F = OperatorSubscriber$1;
var innerFrom_1$m = innerFrom$1;
function bufferWhen(closingSelector) {
  return lift_1$U.operate(function(source, subscriber) {
    var buffer2 = null;
    var closingSubscriber = null;
    var openBuffer = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      var b2 = buffer2;
      buffer2 = [];
      b2 && subscriber.next(b2);
      innerFrom_1$m.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1$F.createOperatorSubscriber(subscriber, openBuffer, noop_1$9.noop));
    };
    openBuffer();
    source.subscribe(OperatorSubscriber_1$F.createOperatorSubscriber(subscriber, function(value) {
      return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
    }, function() {
      buffer2 && subscriber.next(buffer2);
      subscriber.complete();
    }, void 0, function() {
      return buffer2 = closingSubscriber = null;
    }));
  });
}
bufferWhen$1.bufferWhen = bufferWhen;
var catchError$1 = {};
Object.defineProperty(catchError$1, "__esModule", { value: true });
catchError$1.catchError = void 0;
var innerFrom_1$l = innerFrom$1;
var OperatorSubscriber_1$E = OperatorSubscriber$1;
var lift_1$T = lift;
function catchError(selector) {
  return lift_1$T.operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(OperatorSubscriber_1$E.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom_1$l.innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
catchError$1.catchError = catchError;
var combineAll = {};
var combineLatestAll$1 = {};
var joinAllInternals$1 = {};
var toArray$2 = {};
var reduce$2 = {};
var scanInternals$1 = {};
Object.defineProperty(scanInternals$1, "__esModule", { value: true });
scanInternals$1.scanInternals = void 0;
var OperatorSubscriber_1$D = OperatorSubscriber$1;
function scanInternals(accumulator2, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(OperatorSubscriber_1$D.createOperatorSubscriber(subscriber, function(value) {
      var i2 = index++;
      state = hasState ? accumulator2(state, value, i2) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}
scanInternals$1.scanInternals = scanInternals;
Object.defineProperty(reduce$2, "__esModule", { value: true });
reduce$2.reduce = void 0;
var scanInternals_1$1 = scanInternals$1;
var lift_1$S = lift;
function reduce$1(accumulator2, seed) {
  return lift_1$S.operate(scanInternals_1$1.scanInternals(accumulator2, seed, arguments.length >= 2, false, true));
}
reduce$2.reduce = reduce$1;
Object.defineProperty(toArray$2, "__esModule", { value: true });
toArray$2.toArray = void 0;
var reduce_1$3 = reduce$2;
var lift_1$R = lift;
var arrReducer = function(arr, value) {
  return arr.push(value), arr;
};
function toArray$1() {
  return lift_1$R.operate(function(source, subscriber) {
    reduce_1$3.reduce(arrReducer, [])(source).subscribe(subscriber);
  });
}
toArray$2.toArray = toArray$1;
Object.defineProperty(joinAllInternals$1, "__esModule", { value: true });
joinAllInternals$1.joinAllInternals = void 0;
var identity_1$a = identity$1;
var mapOneOrManyArgs_1$1 = mapOneOrManyArgs$1;
var pipe_1$1 = pipe$1;
var mergeMap_1$4 = mergeMap$1;
var toArray_1 = toArray$2;
function joinAllInternals(joinFn, project2) {
  return pipe_1$1.pipe(toArray_1.toArray(), mergeMap_1$4.mergeMap(function(sources) {
    return joinFn(sources);
  }), project2 ? mapOneOrManyArgs_1$1.mapOneOrManyArgs(project2) : identity_1$a.identity);
}
joinAllInternals$1.joinAllInternals = joinAllInternals;
Object.defineProperty(combineLatestAll$1, "__esModule", { value: true });
combineLatestAll$1.combineLatestAll = void 0;
var combineLatest_1$2 = combineLatest$3;
var joinAllInternals_1$1 = joinAllInternals$1;
function combineLatestAll(project2) {
  return joinAllInternals_1$1.joinAllInternals(combineLatest_1$2.combineLatest, project2);
}
combineLatestAll$1.combineLatestAll = combineLatestAll;
Object.defineProperty(combineAll, "__esModule", { value: true });
combineAll.combineAll = void 0;
var combineLatestAll_1 = combineLatestAll$1;
combineAll.combineAll = combineLatestAll_1.combineLatestAll;
var combineLatestWith$1 = {};
var combineLatest$1 = {};
var __read$d = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$d = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(combineLatest$1, "__esModule", { value: true });
combineLatest$1.combineLatest = void 0;
var combineLatest_1$1 = combineLatest$3;
var lift_1$Q = lift;
var argsOrArgArray_1$3 = argsOrArgArray$1;
var mapOneOrManyArgs_1 = mapOneOrManyArgs$1;
var pipe_1 = pipe$1;
var args_1$5 = args;
function combineLatest() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var resultSelector = args_1$5.popResultSelector(args2);
  return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray$d([], __read$d(args2))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1$Q.operate(function(source, subscriber) {
    combineLatest_1$1.combineLatestInit(__spreadArray$d([source], __read$d(argsOrArgArray_1$3.argsOrArgArray(args2))))(subscriber);
  });
}
combineLatest$1.combineLatest = combineLatest;
var __read$c = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$c = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(combineLatestWith$1, "__esModule", { value: true });
combineLatestWith$1.combineLatestWith = void 0;
var combineLatest_1 = combineLatest$1;
function combineLatestWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return combineLatest_1.combineLatest.apply(void 0, __spreadArray$c([], __read$c(otherSources)));
}
combineLatestWith$1.combineLatestWith = combineLatestWith;
var concatMap$1 = {};
Object.defineProperty(concatMap$1, "__esModule", { value: true });
concatMap$1.concatMap = void 0;
var mergeMap_1$3 = mergeMap$1;
var isFunction_1$8 = isFunction$1;
function concatMap(project2, resultSelector) {
  return isFunction_1$8.isFunction(resultSelector) ? mergeMap_1$3.mergeMap(project2, resultSelector, 1) : mergeMap_1$3.mergeMap(project2, 1);
}
concatMap$1.concatMap = concatMap;
var concatMapTo$1 = {};
Object.defineProperty(concatMapTo$1, "__esModule", { value: true });
concatMapTo$1.concatMapTo = void 0;
var concatMap_1 = concatMap$1;
var isFunction_1$7 = isFunction$1;
function concatMapTo(innerObservable, resultSelector) {
  return isFunction_1$7.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
    return innerObservable;
  }, resultSelector) : concatMap_1.concatMap(function() {
    return innerObservable;
  });
}
concatMapTo$1.concatMapTo = concatMapTo;
var concatWith$1 = {};
var concat$2 = {};
var __read$b = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$b = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(concat$2, "__esModule", { value: true });
concat$2.concat = void 0;
var lift_1$P = lift;
var concatAll_1 = concatAll$1;
var args_1$4 = args;
var from_1$1 = from$1;
function concat$1() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$4.popScheduler(args2);
  return lift_1$P.operate(function(source, subscriber) {
    concatAll_1.concatAll()(from_1$1.from(__spreadArray$b([source], __read$b(args2)), scheduler)).subscribe(subscriber);
  });
}
concat$2.concat = concat$1;
var __read$a = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$a = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(concatWith$1, "__esModule", { value: true });
concatWith$1.concatWith = void 0;
var concat_1$3 = concat$2;
function concatWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return concat_1$3.concat.apply(void 0, __spreadArray$a([], __read$a(otherSources)));
}
concatWith$1.concatWith = concatWith;
var connect$1 = {};
var fromSubscribable$1 = {};
Object.defineProperty(fromSubscribable$1, "__esModule", { value: true });
fromSubscribable$1.fromSubscribable = void 0;
var Observable_1$1 = Observable$1;
function fromSubscribable(subscribable) {
  return new Observable_1$1.Observable(function(subscriber) {
    return subscribable.subscribe(subscriber);
  });
}
fromSubscribable$1.fromSubscribable = fromSubscribable;
Object.defineProperty(connect$1, "__esModule", { value: true });
connect$1.connect = void 0;
var Subject_1$a = Subject$1;
var innerFrom_1$k = innerFrom$1;
var lift_1$O = lift;
var fromSubscribable_1 = fromSubscribable$1;
var DEFAULT_CONFIG = {
  connector: function() {
    return new Subject_1$a.Subject();
  }
};
function connect(selector, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG;
  }
  var connector = config2.connector;
  return lift_1$O.operate(function(source, subscriber) {
    var subject = connector();
    innerFrom_1$k.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
    subscriber.add(source.subscribe(subject));
  });
}
connect$1.connect = connect;
var count$3 = {};
Object.defineProperty(count$3, "__esModule", { value: true });
count$3.count = void 0;
var reduce_1$2 = reduce$2;
function count$2(predicate) {
  return reduce_1$2.reduce(function(total, value, i2) {
    return !predicate || predicate(value, i2) ? total + 1 : total;
  }, 0);
}
count$3.count = count$2;
var debounce$1 = {};
Object.defineProperty(debounce$1, "__esModule", { value: true });
debounce$1.debounce = void 0;
var lift_1$N = lift;
var noop_1$8 = noop$1;
var OperatorSubscriber_1$C = OperatorSubscriber$1;
var innerFrom_1$j = innerFrom$1;
function debounce(durationSelector) {
  return lift_1$N.operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var emit = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    source.subscribe(OperatorSubscriber_1$C.createOperatorSubscriber(subscriber, function(value) {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      hasValue = true;
      lastValue = value;
      durationSubscriber = OperatorSubscriber_1$C.createOperatorSubscriber(subscriber, emit, noop_1$8.noop);
      innerFrom_1$j.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = durationSubscriber = null;
    }));
  });
}
debounce$1.debounce = debounce;
var debounceTime$1 = {};
Object.defineProperty(debounceTime$1, "__esModule", { value: true });
debounceTime$1.debounceTime = void 0;
var async_1$6 = async;
var lift_1$M = lift;
var OperatorSubscriber_1$B = OperatorSubscriber$1;
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$6.asyncScheduler;
  }
  return lift_1$M.operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now2 = scheduler.now();
      if (now2 < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now2);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(OperatorSubscriber_1$B.createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}
debounceTime$1.debounceTime = debounceTime;
var defaultIfEmpty$1 = {};
Object.defineProperty(defaultIfEmpty$1, "__esModule", { value: true });
defaultIfEmpty$1.defaultIfEmpty = void 0;
var lift_1$L = lift;
var OperatorSubscriber_1$A = OperatorSubscriber$1;
function defaultIfEmpty(defaultValue) {
  return lift_1$L.operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(OperatorSubscriber_1$A.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
defaultIfEmpty$1.defaultIfEmpty = defaultIfEmpty;
var delay$1 = {};
var delayWhen$1 = {};
var take$1 = {};
Object.defineProperty(take$1, "__esModule", { value: true });
take$1.take = void 0;
var empty_1$2 = empty;
var lift_1$K = lift;
var OperatorSubscriber_1$z = OperatorSubscriber$1;
function take(count2) {
  return count2 <= 0 ? function() {
    return empty_1$2.EMPTY;
  } : lift_1$K.operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(OperatorSubscriber_1$z.createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
take$1.take = take;
var ignoreElements$1 = {};
Object.defineProperty(ignoreElements$1, "__esModule", { value: true });
ignoreElements$1.ignoreElements = void 0;
var lift_1$J = lift;
var OperatorSubscriber_1$y = OperatorSubscriber$1;
var noop_1$7 = noop$1;
function ignoreElements() {
  return lift_1$J.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$y.createOperatorSubscriber(subscriber, noop_1$7.noop));
  });
}
ignoreElements$1.ignoreElements = ignoreElements;
var mapTo$1 = {};
Object.defineProperty(mapTo$1, "__esModule", { value: true });
mapTo$1.mapTo = void 0;
var map_1$3 = map$2;
function mapTo(value) {
  return map_1$3.map(function() {
    return value;
  });
}
mapTo$1.mapTo = mapTo;
Object.defineProperty(delayWhen$1, "__esModule", { value: true });
delayWhen$1.delayWhen = void 0;
var concat_1$2 = concat$4;
var take_1$2 = take$1;
var ignoreElements_1 = ignoreElements$1;
var mapTo_1 = mapTo$1;
var mergeMap_1$2 = mergeMap$1;
var innerFrom_1$i = innerFrom$1;
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return concat_1$2.concat(subscriptionDelay.pipe(take_1$2.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap_1$2.mergeMap(function(value, index) {
    return innerFrom_1$i.innerFrom(delayDurationSelector(value, index)).pipe(take_1$2.take(1), mapTo_1.mapTo(value));
  });
}
delayWhen$1.delayWhen = delayWhen;
Object.defineProperty(delay$1, "__esModule", { value: true });
delay$1.delay = void 0;
var async_1$5 = async;
var delayWhen_1 = delayWhen$1;
var timer_1$3 = timer$1;
function delay(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$5.asyncScheduler;
  }
  var duration = timer_1$3.timer(due, scheduler);
  return delayWhen_1.delayWhen(function() {
    return duration;
  });
}
delay$1.delay = delay;
var dematerialize$1 = {};
Object.defineProperty(dematerialize$1, "__esModule", { value: true });
dematerialize$1.dematerialize = void 0;
var Notification_1$1 = Notification;
var lift_1$I = lift;
var OperatorSubscriber_1$x = OperatorSubscriber$1;
function dematerialize() {
  return lift_1$I.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$x.createOperatorSubscriber(subscriber, function(notification) {
      return Notification_1$1.observeNotification(notification, subscriber);
    }));
  });
}
dematerialize$1.dematerialize = dematerialize;
var distinct$1 = {};
Object.defineProperty(distinct$1, "__esModule", { value: true });
distinct$1.distinct = void 0;
var lift_1$H = lift;
var OperatorSubscriber_1$w = OperatorSubscriber$1;
var noop_1$6 = noop$1;
var innerFrom_1$h = innerFrom$1;
function distinct(keySelector, flushes) {
  return lift_1$H.operate(function(source, subscriber) {
    var distinctKeys = /* @__PURE__ */ new Set();
    source.subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(subscriber, function(value) {
      var key = keySelector ? keySelector(value) : value;
      if (!distinctKeys.has(key)) {
        distinctKeys.add(key);
        subscriber.next(value);
      }
    }));
    flushes && innerFrom_1$h.innerFrom(flushes).subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(subscriber, function() {
      return distinctKeys.clear();
    }, noop_1$6.noop));
  });
}
distinct$1.distinct = distinct;
var distinctUntilChanged$1 = {};
Object.defineProperty(distinctUntilChanged$1, "__esModule", { value: true });
distinctUntilChanged$1.distinctUntilChanged = void 0;
var identity_1$9 = identity$1;
var lift_1$G = lift;
var OperatorSubscriber_1$v = OperatorSubscriber$1;
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity_1$9.identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return lift_1$G.operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(OperatorSubscriber_1$v.createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
distinctUntilChanged$1.distinctUntilChanged = distinctUntilChanged;
function defaultCompare(a2, b2) {
  return a2 === b2;
}
var distinctUntilKeyChanged$1 = {};
Object.defineProperty(distinctUntilKeyChanged$1, "__esModule", { value: true });
distinctUntilKeyChanged$1.distinctUntilKeyChanged = void 0;
var distinctUntilChanged_1 = distinctUntilChanged$1;
function distinctUntilKeyChanged(key, compare2) {
  return distinctUntilChanged_1.distinctUntilChanged(function(x2, y2) {
    return compare2 ? compare2(x2[key], y2[key]) : x2[key] === y2[key];
  });
}
distinctUntilKeyChanged$1.distinctUntilKeyChanged = distinctUntilKeyChanged;
var elementAt$1 = {};
var throwIfEmpty$1 = {};
Object.defineProperty(throwIfEmpty$1, "__esModule", { value: true });
throwIfEmpty$1.throwIfEmpty = void 0;
var EmptyError_1$3 = EmptyError;
var lift_1$F = lift;
var OperatorSubscriber_1$u = OperatorSubscriber$1;
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return lift_1$F.operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(OperatorSubscriber_1$u.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
throwIfEmpty$1.throwIfEmpty = throwIfEmpty;
function defaultErrorFactory() {
  return new EmptyError_1$3.EmptyError();
}
Object.defineProperty(elementAt$1, "__esModule", { value: true });
elementAt$1.elementAt = void 0;
var ArgumentOutOfRangeError_1 = ArgumentOutOfRangeError;
var filter_1$4 = filter$2;
var throwIfEmpty_1$2 = throwIfEmpty$1;
var defaultIfEmpty_1$2 = defaultIfEmpty$1;
var take_1$1 = take$1;
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter_1$4.filter(function(v2, i2) {
      return i2 === index;
    }), take_1$1.take(1), hasDefaultValue ? defaultIfEmpty_1$2.defaultIfEmpty(defaultValue) : throwIfEmpty_1$2.throwIfEmpty(function() {
      return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }));
  };
}
elementAt$1.elementAt = elementAt;
var endWith$1 = {};
var __read$9 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$9 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(endWith$1, "__esModule", { value: true });
endWith$1.endWith = void 0;
var concat_1$1 = concat$4;
var of_1 = of$1;
function endWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return function(source) {
    return concat_1$1.concat(source, of_1.of.apply(void 0, __spreadArray$9([], __read$9(values))));
  };
}
endWith$1.endWith = endWith;
var every$1 = {};
Object.defineProperty(every$1, "__esModule", { value: true });
every$1.every = void 0;
var lift_1$E = lift;
var OperatorSubscriber_1$t = OperatorSubscriber$1;
function every(predicate, thisArg) {
  return lift_1$E.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$t.createOperatorSubscriber(subscriber, function(value) {
      if (!predicate.call(thisArg, value, index++, source)) {
        subscriber.next(false);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}
every$1.every = every;
var exhaust = {};
var exhaustAll$1 = {};
var exhaustMap$1 = {};
Object.defineProperty(exhaustMap$1, "__esModule", { value: true });
exhaustMap$1.exhaustMap = void 0;
var map_1$2 = map$2;
var innerFrom_1$g = innerFrom$1;
var lift_1$D = lift;
var OperatorSubscriber_1$s = OperatorSubscriber$1;
function exhaustMap(project2, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a2, i2) {
        return innerFrom_1$g.innerFrom(project2(a2, i2)).pipe(map_1$2.map(function(b2, ii) {
          return resultSelector(a2, b2, i2, ii);
        }));
      }));
    };
  }
  return lift_1$D.operate(function(source, subscriber) {
    var index = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(OperatorSubscriber_1$s.createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = OperatorSubscriber_1$s.createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom_1$g.innerFrom(project2(outerValue, index++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}
exhaustMap$1.exhaustMap = exhaustMap;
Object.defineProperty(exhaustAll$1, "__esModule", { value: true });
exhaustAll$1.exhaustAll = void 0;
var exhaustMap_1 = exhaustMap$1;
var identity_1$8 = identity$1;
function exhaustAll() {
  return exhaustMap_1.exhaustMap(identity_1$8.identity);
}
exhaustAll$1.exhaustAll = exhaustAll;
Object.defineProperty(exhaust, "__esModule", { value: true });
exhaust.exhaust = void 0;
var exhaustAll_1 = exhaustAll$1;
exhaust.exhaust = exhaustAll_1.exhaustAll;
var expand$1 = {};
Object.defineProperty(expand$1, "__esModule", { value: true });
expand$1.expand = void 0;
var lift_1$C = lift;
var mergeInternals_1$1 = mergeInternals$1;
function expand(project2, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
  return lift_1$C.operate(function(source, subscriber) {
    return mergeInternals_1$1.mergeInternals(source, subscriber, project2, concurrent, void 0, true, scheduler);
  });
}
expand$1.expand = expand;
var finalize$1 = {};
Object.defineProperty(finalize$1, "__esModule", { value: true });
finalize$1.finalize = void 0;
var lift_1$B = lift;
function finalize(callback) {
  return lift_1$B.operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}
finalize$1.finalize = finalize;
var find$1 = {};
Object.defineProperty(find$1, "__esModule", { value: true });
find$1.createFind = find$1.find = void 0;
var lift_1$A = lift;
var OperatorSubscriber_1$r = OperatorSubscriber$1;
function find(predicate, thisArg) {
  return lift_1$A.operate(createFind(predicate, thisArg, "value"));
}
find$1.find = find;
function createFind(predicate, thisArg, emit) {
  var findIndex2 = emit === "index";
  return function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$r.createOperatorSubscriber(subscriber, function(value) {
      var i2 = index++;
      if (predicate.call(thisArg, value, i2, source)) {
        subscriber.next(findIndex2 ? i2 : value);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(findIndex2 ? -1 : void 0);
      subscriber.complete();
    }));
  };
}
find$1.createFind = createFind;
var findIndex$1 = {};
Object.defineProperty(findIndex$1, "__esModule", { value: true });
findIndex$1.findIndex = void 0;
var lift_1$z = lift;
var find_1 = find$1;
function findIndex(predicate, thisArg) {
  return lift_1$z.operate(find_1.createFind(predicate, thisArg, "index"));
}
findIndex$1.findIndex = findIndex;
var first$3 = {};
Object.defineProperty(first$3, "__esModule", { value: true });
first$3.first = void 0;
var EmptyError_1$2 = EmptyError;
var filter_1$3 = filter$2;
var take_1 = take$1;
var defaultIfEmpty_1$1 = defaultIfEmpty$1;
var throwIfEmpty_1$1 = throwIfEmpty$1;
var identity_1$7 = identity$1;
function first$2(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter_1$3.filter(function(v2, i2) {
      return predicate(v2, i2, source);
    }) : identity_1$7.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1$1.defaultIfEmpty(defaultValue) : throwIfEmpty_1$1.throwIfEmpty(function() {
      return new EmptyError_1$2.EmptyError();
    }));
  };
}
first$3.first = first$2;
var groupBy$1 = {};
Object.defineProperty(groupBy$1, "__esModule", { value: true });
groupBy$1.groupBy = void 0;
var Observable_1 = Observable$1;
var innerFrom_1$f = innerFrom$1;
var Subject_1$9 = Subject$1;
var lift_1$y = lift;
var OperatorSubscriber_1$q = OperatorSubscriber$1;
function groupBy(keySelector, elementOrOptions, duration, connector) {
  return lift_1$y.operate(function(source, subscriber) {
    var element2;
    if (!elementOrOptions || typeof elementOrOptions === "function") {
      element2 = elementOrOptions;
    } else {
      duration = elementOrOptions.duration, element2 = elementOrOptions.element, connector = elementOrOptions.connector;
    }
    var groups = /* @__PURE__ */ new Map();
    var notify = function(cb) {
      groups.forEach(cb);
      cb(subscriber);
    };
    var handleError = function(err) {
      return notify(function(consumer) {
        return consumer.error(err);
      });
    };
    var activeGroups = 0;
    var teardownAttempted = false;
    var groupBySourceSubscriber = new OperatorSubscriber_1$q.OperatorSubscriber(subscriber, function(value) {
      try {
        var key_1 = keySelector(value);
        var group_12 = groups.get(key_1);
        if (!group_12) {
          groups.set(key_1, group_12 = connector ? connector() : new Subject_1$9.Subject());
          var grouped = createGroupedObservable(key_1, group_12);
          subscriber.next(grouped);
          if (duration) {
            var durationSubscriber_1 = OperatorSubscriber_1$q.createOperatorSubscriber(group_12, function() {
              group_12.complete();
              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
            }, void 0, void 0, function() {
              return groups.delete(key_1);
            });
            groupBySourceSubscriber.add(innerFrom_1$f.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
          }
        }
        group_12.next(element2 ? element2(value) : value);
      } catch (err) {
        handleError(err);
      }
    }, function() {
      return notify(function(consumer) {
        return consumer.complete();
      });
    }, handleError, function() {
      return groups.clear();
    }, function() {
      teardownAttempted = true;
      return activeGroups === 0;
    });
    source.subscribe(groupBySourceSubscriber);
    function createGroupedObservable(key, groupSubject) {
      var result = new Observable_1.Observable(function(groupSubscriber) {
        activeGroups++;
        var innerSub = groupSubject.subscribe(groupSubscriber);
        return function() {
          innerSub.unsubscribe();
          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
        };
      });
      result.key = key;
      return result;
    }
  });
}
groupBy$1.groupBy = groupBy;
var isEmpty$1 = {};
Object.defineProperty(isEmpty$1, "__esModule", { value: true });
isEmpty$1.isEmpty = void 0;
var lift_1$x = lift;
var OperatorSubscriber_1$p = OperatorSubscriber$1;
function isEmpty() {
  return lift_1$x.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$p.createOperatorSubscriber(subscriber, function() {
      subscriber.next(false);
      subscriber.complete();
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}
isEmpty$1.isEmpty = isEmpty;
var last$3 = {};
var takeLast$1 = {};
var __values$2 = commonjsGlobal && commonjsGlobal.__values || function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(takeLast$1, "__esModule", { value: true });
takeLast$1.takeLast = void 0;
var empty_1$1 = empty;
var lift_1$w = lift;
var OperatorSubscriber_1$o = OperatorSubscriber$1;
function takeLast(count2) {
  return count2 <= 0 ? function() {
    return empty_1$1.EMPTY;
  } : lift_1$w.operate(function(source, subscriber) {
    var buffer2 = [];
    source.subscribe(OperatorSubscriber_1$o.createOperatorSubscriber(subscriber, function(value) {
      buffer2.push(value);
      count2 < buffer2.length && buffer2.shift();
    }, function() {
      var e_1, _a;
      try {
        for (var buffer_1 = __values$2(buffer2), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
          var value = buffer_1_1.value;
          subscriber.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
            _a.call(buffer_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffer2 = null;
    }));
  });
}
takeLast$1.takeLast = takeLast;
Object.defineProperty(last$3, "__esModule", { value: true });
last$3.last = void 0;
var EmptyError_1$1 = EmptyError;
var filter_1$2 = filter$2;
var takeLast_1 = takeLast$1;
var throwIfEmpty_1 = throwIfEmpty$1;
var defaultIfEmpty_1 = defaultIfEmpty$1;
var identity_1$6 = identity$1;
function last$2(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter_1$2.filter(function(v2, i2) {
      return predicate(v2, i2, source);
    }) : identity_1$6.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
      return new EmptyError_1$1.EmptyError();
    }));
  };
}
last$3.last = last$2;
var materialize$1 = {};
Object.defineProperty(materialize$1, "__esModule", { value: true });
materialize$1.materialize = void 0;
var Notification_1 = Notification;
var lift_1$v = lift;
var OperatorSubscriber_1$n = OperatorSubscriber$1;
function materialize() {
  return lift_1$v.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$n.createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(Notification_1.Notification.createNext(value));
    }, function() {
      subscriber.next(Notification_1.Notification.createComplete());
      subscriber.complete();
    }, function(err) {
      subscriber.next(Notification_1.Notification.createError(err));
      subscriber.complete();
    }));
  });
}
materialize$1.materialize = materialize;
var max$2 = {};
Object.defineProperty(max$2, "__esModule", { value: true });
max$2.max = void 0;
var reduce_1$1 = reduce$2;
var isFunction_1$6 = isFunction$1;
function max$1(comparer) {
  return reduce_1$1.reduce(isFunction_1$6.isFunction(comparer) ? function(x2, y2) {
    return comparer(x2, y2) > 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 > y2 ? x2 : y2;
  });
}
max$2.max = max$1;
var flatMap = {};
Object.defineProperty(flatMap, "__esModule", { value: true });
flatMap.flatMap = void 0;
var mergeMap_1$1 = mergeMap$1;
flatMap.flatMap = mergeMap_1$1.mergeMap;
var mergeMapTo$1 = {};
Object.defineProperty(mergeMapTo$1, "__esModule", { value: true });
mergeMapTo$1.mergeMapTo = void 0;
var mergeMap_1 = mergeMap$1;
var isFunction_1$5 = isFunction$1;
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction_1$5.isFunction(resultSelector)) {
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap_1.mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
mergeMapTo$1.mergeMapTo = mergeMapTo;
var mergeScan$1 = {};
Object.defineProperty(mergeScan$1, "__esModule", { value: true });
mergeScan$1.mergeScan = void 0;
var lift_1$u = lift;
var mergeInternals_1 = mergeInternals$1;
function mergeScan(accumulator2, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return lift_1$u.operate(function(source, subscriber) {
    var state = seed;
    return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
      return accumulator2(state, value, index);
    }, concurrent, function(value) {
      state = value;
    }, false, void 0, function() {
      return state = null;
    });
  });
}
mergeScan$1.mergeScan = mergeScan;
var mergeWith$1 = {};
var merge$3 = {};
var __read$8 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$8 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(merge$3, "__esModule", { value: true });
merge$3.merge = void 0;
var lift_1$t = lift;
var argsOrArgArray_1$2 = argsOrArgArray$1;
var mergeAll_1 = mergeAll$1;
var args_1$3 = args;
var from_1 = from$1;
function merge$2() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = args_1$3.popScheduler(args2);
  var concurrent = args_1$3.popNumber(args2, Infinity);
  args2 = argsOrArgArray_1$2.argsOrArgArray(args2);
  return lift_1$t.operate(function(source, subscriber) {
    mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray$8([source], __read$8(args2)), scheduler)).subscribe(subscriber);
  });
}
merge$3.merge = merge$2;
var __read$7 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$7 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(mergeWith$1, "__esModule", { value: true });
mergeWith$1.mergeWith = void 0;
var merge_1 = merge$3;
function mergeWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return merge_1.merge.apply(void 0, __spreadArray$7([], __read$7(otherSources)));
}
mergeWith$1.mergeWith = mergeWith;
var min$2 = {};
Object.defineProperty(min$2, "__esModule", { value: true });
min$2.min = void 0;
var reduce_1 = reduce$2;
var isFunction_1$4 = isFunction$1;
function min$1(comparer) {
  return reduce_1.reduce(isFunction_1$4.isFunction(comparer) ? function(x2, y2) {
    return comparer(x2, y2) < 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 < y2 ? x2 : y2;
  });
}
min$2.min = min$1;
var multicast$1 = {};
Object.defineProperty(multicast$1, "__esModule", { value: true });
multicast$1.multicast = void 0;
var ConnectableObservable_1$2 = ConnectableObservable$1;
var isFunction_1$3 = isFunction$1;
var connect_1$1 = connect$1;
function multicast(subjectOrSubjectFactory, selector) {
  var subjectFactory = isFunction_1$3.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
    return subjectOrSubjectFactory;
  };
  if (isFunction_1$3.isFunction(selector)) {
    return connect_1$1.connect(selector, {
      connector: subjectFactory
    });
  }
  return function(source) {
    return new ConnectableObservable_1$2.ConnectableObservable(source, subjectFactory);
  };
}
multicast$1.multicast = multicast;
var onErrorResumeNextWith$1 = {};
var __read$6 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$6 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(onErrorResumeNextWith$1, "__esModule", { value: true });
onErrorResumeNextWith$1.onErrorResumeNext = onErrorResumeNextWith$1.onErrorResumeNextWith = void 0;
var argsOrArgArray_1$1 = argsOrArgArray$1;
var onErrorResumeNext_1 = onErrorResumeNext$1;
function onErrorResumeNextWith() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var nextSources = argsOrArgArray_1$1.argsOrArgArray(sources);
  return function(source) {
    return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray$6([source], __read$6(nextSources)));
  };
}
onErrorResumeNextWith$1.onErrorResumeNextWith = onErrorResumeNextWith;
onErrorResumeNextWith$1.onErrorResumeNext = onErrorResumeNextWith;
var pairwise$1 = {};
Object.defineProperty(pairwise$1, "__esModule", { value: true });
pairwise$1.pairwise = void 0;
var lift_1$s = lift;
var OperatorSubscriber_1$m = OperatorSubscriber$1;
function pairwise() {
  return lift_1$s.operate(function(source, subscriber) {
    var prev;
    var hasPrev = false;
    source.subscribe(OperatorSubscriber_1$m.createOperatorSubscriber(subscriber, function(value) {
      var p2 = prev;
      prev = value;
      hasPrev && subscriber.next([p2, value]);
      hasPrev = true;
    }));
  });
}
pairwise$1.pairwise = pairwise;
var pluck$1 = {};
Object.defineProperty(pluck$1, "__esModule", { value: true });
pluck$1.pluck = void 0;
var map_1$1 = map$2;
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return map_1$1.map(function(x2) {
    var currentProp = x2;
    for (var i2 = 0; i2 < length; i2++) {
      var p2 = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i2]];
      if (typeof p2 !== "undefined") {
        currentProp = p2;
      } else {
        return void 0;
      }
    }
    return currentProp;
  });
}
pluck$1.pluck = pluck;
var publish$1 = {};
Object.defineProperty(publish$1, "__esModule", { value: true });
publish$1.publish = void 0;
var Subject_1$8 = Subject$1;
var multicast_1$1 = multicast$1;
var connect_1 = connect$1;
function publish(selector) {
  return selector ? function(source) {
    return connect_1.connect(selector)(source);
  } : function(source) {
    return multicast_1$1.multicast(new Subject_1$8.Subject())(source);
  };
}
publish$1.publish = publish;
var publishBehavior$1 = {};
Object.defineProperty(publishBehavior$1, "__esModule", { value: true });
publishBehavior$1.publishBehavior = void 0;
var BehaviorSubject_1 = BehaviorSubject$1;
var ConnectableObservable_1$1 = ConnectableObservable$1;
function publishBehavior(initialValue) {
  return function(source) {
    var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
    return new ConnectableObservable_1$1.ConnectableObservable(source, function() {
      return subject;
    });
  };
}
publishBehavior$1.publishBehavior = publishBehavior;
var publishLast$1 = {};
Object.defineProperty(publishLast$1, "__esModule", { value: true });
publishLast$1.publishLast = void 0;
var AsyncSubject_1 = AsyncSubject$1;
var ConnectableObservable_1 = ConnectableObservable$1;
function publishLast() {
  return function(source) {
    var subject = new AsyncSubject_1.AsyncSubject();
    return new ConnectableObservable_1.ConnectableObservable(source, function() {
      return subject;
    });
  };
}
publishLast$1.publishLast = publishLast;
var publishReplay$1 = {};
Object.defineProperty(publishReplay$1, "__esModule", { value: true });
publishReplay$1.publishReplay = void 0;
var ReplaySubject_1$1 = ReplaySubject$1;
var multicast_1 = multicast$1;
var isFunction_1$2 = isFunction$1;
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
  if (selectorOrScheduler && !isFunction_1$2.isFunction(selectorOrScheduler)) {
    timestampProvider = selectorOrScheduler;
  }
  var selector = isFunction_1$2.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
  return function(source) {
    return multicast_1.multicast(new ReplaySubject_1$1.ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source);
  };
}
publishReplay$1.publishReplay = publishReplay;
var raceWith$1 = {};
var __read$5 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$5 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(raceWith$1, "__esModule", { value: true });
raceWith$1.raceWith = void 0;
var race_1 = race$3;
var lift_1$r = lift;
var identity_1$5 = identity$1;
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity_1$5.identity : lift_1$r.operate(function(source, subscriber) {
    race_1.raceInit(__spreadArray$5([source], __read$5(otherSources)))(subscriber);
  });
}
raceWith$1.raceWith = raceWith;
var repeat$1 = {};
Object.defineProperty(repeat$1, "__esModule", { value: true });
repeat$1.repeat = void 0;
var empty_1 = empty;
var lift_1$q = lift;
var OperatorSubscriber_1$l = OperatorSubscriber$1;
var innerFrom_1$e = innerFrom$1;
var timer_1$2 = timer$1;
function repeat(countOrConfig) {
  var _a;
  var count2 = Infinity;
  var delay2;
  if (countOrConfig != null) {
    if (typeof countOrConfig === "object") {
      _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
    } else {
      count2 = countOrConfig;
    }
  }
  return count2 <= 0 ? function() {
    return empty_1.EMPTY;
  } : lift_1$q.operate(function(source, subscriber) {
    var soFar = 0;
    var sourceSub;
    var resubscribe = function() {
      sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
      sourceSub = null;
      if (delay2 != null) {
        var notifier = typeof delay2 === "number" ? timer_1$2.timer(delay2) : innerFrom_1$e.innerFrom(delay2(soFar));
        var notifierSubscriber_1 = OperatorSubscriber_1$l.createOperatorSubscriber(subscriber, function() {
          notifierSubscriber_1.unsubscribe();
          subscribeToSource();
        });
        notifier.subscribe(notifierSubscriber_1);
      } else {
        subscribeToSource();
      }
    };
    var subscribeToSource = function() {
      var syncUnsub = false;
      sourceSub = source.subscribe(OperatorSubscriber_1$l.createOperatorSubscriber(subscriber, void 0, function() {
        if (++soFar < count2) {
          if (sourceSub) {
            resubscribe();
          } else {
            syncUnsub = true;
          }
        } else {
          subscriber.complete();
        }
      }));
      if (syncUnsub) {
        resubscribe();
      }
    };
    subscribeToSource();
  });
}
repeat$1.repeat = repeat;
var repeatWhen$1 = {};
Object.defineProperty(repeatWhen$1, "__esModule", { value: true });
repeatWhen$1.repeatWhen = void 0;
var innerFrom_1$d = innerFrom$1;
var Subject_1$7 = Subject$1;
var lift_1$p = lift;
var OperatorSubscriber_1$k = OperatorSubscriber$1;
function repeatWhen(notifier) {
  return lift_1$p.operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var completions$;
    var isNotifierComplete = false;
    var isMainComplete = false;
    var checkComplete = function() {
      return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
    };
    var getCompletionSubject = function() {
      if (!completions$) {
        completions$ = new Subject_1$7.Subject();
        innerFrom_1$d.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1$k.createOperatorSubscriber(subscriber, function() {
          if (innerSub) {
            subscribeForRepeatWhen();
          } else {
            syncResub = true;
          }
        }, function() {
          isNotifierComplete = true;
          checkComplete();
        }));
      }
      return completions$;
    };
    var subscribeForRepeatWhen = function() {
      isMainComplete = false;
      innerSub = source.subscribe(OperatorSubscriber_1$k.createOperatorSubscriber(subscriber, void 0, function() {
        isMainComplete = true;
        !checkComplete() && getCompletionSubject().next();
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRepeatWhen();
      }
    };
    subscribeForRepeatWhen();
  });
}
repeatWhen$1.repeatWhen = repeatWhen;
var retry$1 = {};
Object.defineProperty(retry$1, "__esModule", { value: true });
retry$1.retry = void 0;
var lift_1$o = lift;
var OperatorSubscriber_1$j = OperatorSubscriber$1;
var identity_1$4 = identity$1;
var timer_1$1 = timer$1;
var innerFrom_1$c = innerFrom$1;
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity_1$4.identity : lift_1$o.operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(OperatorSubscriber_1$j.createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer_1$1.timer(delay2) : innerFrom_1$c.innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1$j.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}
retry$1.retry = retry;
var retryWhen$1 = {};
Object.defineProperty(retryWhen$1, "__esModule", { value: true });
retryWhen$1.retryWhen = void 0;
var innerFrom_1$b = innerFrom$1;
var Subject_1$6 = Subject$1;
var lift_1$n = lift;
var OperatorSubscriber_1$i = OperatorSubscriber$1;
function retryWhen(notifier) {
  return lift_1$n.operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var errors$;
    var subscribeForRetryWhen = function() {
      innerSub = source.subscribe(OperatorSubscriber_1$i.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        if (!errors$) {
          errors$ = new Subject_1$6.Subject();
          innerFrom_1$b.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1$i.createOperatorSubscriber(subscriber, function() {
            return innerSub ? subscribeForRetryWhen() : syncResub = true;
          }));
        }
        if (errors$) {
          errors$.next(err);
        }
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRetryWhen();
      }
    };
    subscribeForRetryWhen();
  });
}
retryWhen$1.retryWhen = retryWhen;
var sample$2 = {};
Object.defineProperty(sample$2, "__esModule", { value: true });
sample$2.sample = void 0;
var innerFrom_1$a = innerFrom$1;
var lift_1$m = lift;
var noop_1$5 = noop$1;
var OperatorSubscriber_1$h = OperatorSubscriber$1;
function sample$1(notifier) {
  return lift_1$m.operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    source.subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
    }));
    innerFrom_1$a.innerFrom(notifier).subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(subscriber, function() {
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    }, noop_1$5.noop));
  });
}
sample$2.sample = sample$1;
var sampleTime$1 = {};
Object.defineProperty(sampleTime$1, "__esModule", { value: true });
sampleTime$1.sampleTime = void 0;
var async_1$4 = async;
var sample_1 = sample$2;
var interval_1 = interval$1;
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$4.asyncScheduler;
  }
  return sample_1.sample(interval_1.interval(period, scheduler));
}
sampleTime$1.sampleTime = sampleTime;
var scan$1 = {};
Object.defineProperty(scan$1, "__esModule", { value: true });
scan$1.scan = void 0;
var lift_1$l = lift;
var scanInternals_1 = scanInternals$1;
function scan(accumulator2, seed) {
  return lift_1$l.operate(scanInternals_1.scanInternals(accumulator2, seed, arguments.length >= 2, true));
}
scan$1.scan = scan;
var sequenceEqual$1 = {};
Object.defineProperty(sequenceEqual$1, "__esModule", { value: true });
sequenceEqual$1.sequenceEqual = void 0;
var lift_1$k = lift;
var OperatorSubscriber_1$g = OperatorSubscriber$1;
var innerFrom_1$9 = innerFrom$1;
function sequenceEqual(compareTo, comparator) {
  if (comparator === void 0) {
    comparator = function(a2, b2) {
      return a2 === b2;
    };
  }
  return lift_1$k.operate(function(source, subscriber) {
    var aState = createState();
    var bState = createState();
    var emit = function(isEqual2) {
      subscriber.next(isEqual2);
      subscriber.complete();
    };
    var createSubscriber = function(selfState, otherState) {
      var sequenceEqualSubscriber = OperatorSubscriber_1$g.createOperatorSubscriber(subscriber, function(a2) {
        var buffer2 = otherState.buffer, complete = otherState.complete;
        if (buffer2.length === 0) {
          complete ? emit(false) : selfState.buffer.push(a2);
        } else {
          !comparator(a2, buffer2.shift()) && emit(false);
        }
      }, function() {
        selfState.complete = true;
        var complete = otherState.complete, buffer2 = otherState.buffer;
        complete && emit(buffer2.length === 0);
        sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
      });
      return sequenceEqualSubscriber;
    };
    source.subscribe(createSubscriber(aState, bState));
    innerFrom_1$9.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
  });
}
sequenceEqual$1.sequenceEqual = sequenceEqual;
function createState() {
  return {
    buffer: [],
    complete: false
  };
}
var share$1 = {};
var __read$4 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$4 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(share$1, "__esModule", { value: true });
share$1.share = void 0;
var innerFrom_1$8 = innerFrom$1;
var Subject_1$5 = Subject$1;
var Subscriber_1 = Subscriber;
var lift_1$j = lift;
function share(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _a = options2.connector, connector = _a === void 0 ? function() {
    return new Subject_1$5.Subject();
  } : _a, _b = options2.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options2.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options2.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return lift_1$j.operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom_1$8.innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
share$1.share = share;
function handleReset(reset, on2) {
  var args2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args2[_i - 2] = arguments[_i];
  }
  if (on2 === true) {
    reset();
    return;
  }
  if (on2 === false) {
    return;
  }
  var onSubscriber = new Subscriber_1.SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom_1$8.innerFrom(on2.apply(void 0, __spreadArray$4([], __read$4(args2)))).subscribe(onSubscriber);
}
var shareReplay$1 = {};
Object.defineProperty(shareReplay$1, "__esModule", { value: true });
shareReplay$1.shareReplay = void 0;
var ReplaySubject_1 = ReplaySubject$1;
var share_1 = share$1;
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share_1.share({
    connector: function() {
      return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}
shareReplay$1.shareReplay = shareReplay;
var single$1 = {};
Object.defineProperty(single$1, "__esModule", { value: true });
single$1.single = void 0;
var EmptyError_1 = EmptyError;
var SequenceError_1 = SequenceError;
var NotFoundError_1 = NotFoundError$1;
var lift_1$i = lift;
var OperatorSubscriber_1$f = OperatorSubscriber$1;
function single(predicate) {
  return lift_1$i.operate(function(source, subscriber) {
    var hasValue = false;
    var singleValue;
    var seenValue = false;
    var index = 0;
    source.subscribe(OperatorSubscriber_1$f.createOperatorSubscriber(subscriber, function(value) {
      seenValue = true;
      if (!predicate || predicate(value, index++, source)) {
        hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
        hasValue = true;
        singleValue = value;
      }
    }, function() {
      if (hasValue) {
        subscriber.next(singleValue);
        subscriber.complete();
      } else {
        subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
      }
    }));
  });
}
single$1.single = single;
var skip$2 = {};
Object.defineProperty(skip$2, "__esModule", { value: true });
skip$2.skip = void 0;
var filter_1$1 = filter$2;
function skip$1(count2) {
  return filter_1$1.filter(function(_2, index) {
    return count2 <= index;
  });
}
skip$2.skip = skip$1;
var skipLast$1 = {};
Object.defineProperty(skipLast$1, "__esModule", { value: true });
skipLast$1.skipLast = void 0;
var identity_1$3 = identity$1;
var lift_1$h = lift;
var OperatorSubscriber_1$e = OperatorSubscriber$1;
function skipLast(skipCount) {
  return skipCount <= 0 ? identity_1$3.identity : lift_1$h.operate(function(source, subscriber) {
    var ring = new Array(skipCount);
    var seen = 0;
    source.subscribe(OperatorSubscriber_1$e.createOperatorSubscriber(subscriber, function(value) {
      var valueIndex = seen++;
      if (valueIndex < skipCount) {
        ring[valueIndex] = value;
      } else {
        var index = valueIndex % skipCount;
        var oldValue = ring[index];
        ring[index] = value;
        subscriber.next(oldValue);
      }
    }));
    return function() {
      ring = null;
    };
  });
}
skipLast$1.skipLast = skipLast;
var skipUntil$1 = {};
Object.defineProperty(skipUntil$1, "__esModule", { value: true });
skipUntil$1.skipUntil = void 0;
var lift_1$g = lift;
var OperatorSubscriber_1$d = OperatorSubscriber$1;
var innerFrom_1$7 = innerFrom$1;
var noop_1$4 = noop$1;
function skipUntil(notifier) {
  return lift_1$g.operate(function(source, subscriber) {
    var taking = false;
    var skipSubscriber = OperatorSubscriber_1$d.createOperatorSubscriber(subscriber, function() {
      skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
      taking = true;
    }, noop_1$4.noop);
    innerFrom_1$7.innerFrom(notifier).subscribe(skipSubscriber);
    source.subscribe(OperatorSubscriber_1$d.createOperatorSubscriber(subscriber, function(value) {
      return taking && subscriber.next(value);
    }));
  });
}
skipUntil$1.skipUntil = skipUntil;
var skipWhile$1 = {};
Object.defineProperty(skipWhile$1, "__esModule", { value: true });
skipWhile$1.skipWhile = void 0;
var lift_1$f = lift;
var OperatorSubscriber_1$c = OperatorSubscriber$1;
function skipWhile(predicate) {
  return lift_1$f.operate(function(source, subscriber) {
    var taking = false;
    var index = 0;
    source.subscribe(OperatorSubscriber_1$c.createOperatorSubscriber(subscriber, function(value) {
      return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
    }));
  });
}
skipWhile$1.skipWhile = skipWhile;
var startWith$1 = {};
Object.defineProperty(startWith$1, "__esModule", { value: true });
startWith$1.startWith = void 0;
var concat_1 = concat$4;
var args_1$2 = args;
var lift_1$e = lift;
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = args_1$2.popScheduler(values);
  return lift_1$e.operate(function(source, subscriber) {
    (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
  });
}
startWith$1.startWith = startWith;
var switchAll$1 = {};
var switchMap$1 = {};
Object.defineProperty(switchMap$1, "__esModule", { value: true });
switchMap$1.switchMap = void 0;
var innerFrom_1$6 = innerFrom$1;
var lift_1$d = lift;
var OperatorSubscriber_1$b = OperatorSubscriber$1;
function switchMap(project2, resultSelector) {
  return lift_1$d.operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(OperatorSubscriber_1$b.createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom_1$6.innerFrom(project2(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1$b.createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
switchMap$1.switchMap = switchMap;
Object.defineProperty(switchAll$1, "__esModule", { value: true });
switchAll$1.switchAll = void 0;
var switchMap_1$2 = switchMap$1;
var identity_1$2 = identity$1;
function switchAll() {
  return switchMap_1$2.switchMap(identity_1$2.identity);
}
switchAll$1.switchAll = switchAll;
var switchMapTo$1 = {};
Object.defineProperty(switchMapTo$1, "__esModule", { value: true });
switchMapTo$1.switchMapTo = void 0;
var switchMap_1$1 = switchMap$1;
var isFunction_1$1 = isFunction$1;
function switchMapTo(innerObservable, resultSelector) {
  return isFunction_1$1.isFunction(resultSelector) ? switchMap_1$1.switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap_1$1.switchMap(function() {
    return innerObservable;
  });
}
switchMapTo$1.switchMapTo = switchMapTo;
var switchScan$1 = {};
Object.defineProperty(switchScan$1, "__esModule", { value: true });
switchScan$1.switchScan = void 0;
var switchMap_1 = switchMap$1;
var lift_1$c = lift;
function switchScan(accumulator2, seed) {
  return lift_1$c.operate(function(source, subscriber) {
    var state = seed;
    switchMap_1.switchMap(function(value, index) {
      return accumulator2(state, value, index);
    }, function(_2, innerValue) {
      return state = innerValue, innerValue;
    })(source).subscribe(subscriber);
    return function() {
      state = null;
    };
  });
}
switchScan$1.switchScan = switchScan;
var takeUntil$1 = {};
Object.defineProperty(takeUntil$1, "__esModule", { value: true });
takeUntil$1.takeUntil = void 0;
var lift_1$b = lift;
var OperatorSubscriber_1$a = OperatorSubscriber$1;
var innerFrom_1$5 = innerFrom$1;
var noop_1$3 = noop$1;
function takeUntil(notifier) {
  return lift_1$b.operate(function(source, subscriber) {
    innerFrom_1$5.innerFrom(notifier).subscribe(OperatorSubscriber_1$a.createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop_1$3.noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
takeUntil$1.takeUntil = takeUntil;
var takeWhile$1 = {};
Object.defineProperty(takeWhile$1, "__esModule", { value: true });
takeWhile$1.takeWhile = void 0;
var lift_1$a = lift;
var OperatorSubscriber_1$9 = OperatorSubscriber$1;
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return lift_1$a.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$9.createOperatorSubscriber(subscriber, function(value) {
      var result = predicate(value, index++);
      (result || inclusive) && subscriber.next(value);
      !result && subscriber.complete();
    }));
  });
}
takeWhile$1.takeWhile = takeWhile;
var tap$1 = {};
Object.defineProperty(tap$1, "__esModule", { value: true });
tap$1.tap = void 0;
var isFunction_1 = isFunction$1;
var lift_1$9 = lift;
var OperatorSubscriber_1$8 = OperatorSubscriber$1;
var identity_1$1 = identity$1;
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? lift_1$9.operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(OperatorSubscriber_1$8.createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity_1$1.identity;
}
tap$1.tap = tap;
var throttle$1 = {};
Object.defineProperty(throttle$1, "__esModule", { value: true });
throttle$1.throttle = void 0;
var lift_1$8 = lift;
var OperatorSubscriber_1$7 = OperatorSubscriber$1;
var innerFrom_1$4 = innerFrom$1;
function throttle(durationSelector, config2) {
  return lift_1$8.operate(function(source, subscriber) {
    var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    var cleanupThrottling = function() {
      throttled = null;
      isComplete && subscriber.complete();
    };
    var startThrottle = function(value) {
      return throttled = innerFrom_1$4.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    };
    var send = function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}
throttle$1.throttle = throttle;
var throttleTime$1 = {};
Object.defineProperty(throttleTime$1, "__esModule", { value: true });
throttleTime$1.throttleTime = void 0;
var async_1$3 = async;
var throttle_1 = throttle$1;
var timer_1 = timer$1;
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async_1$3.asyncScheduler;
  }
  var duration$ = timer_1.timer(duration, scheduler);
  return throttle_1.throttle(function() {
    return duration$;
  }, config2);
}
throttleTime$1.throttleTime = throttleTime;
var timeInterval$1 = {};
Object.defineProperty(timeInterval$1, "__esModule", { value: true });
timeInterval$1.TimeInterval = timeInterval$1.timeInterval = void 0;
var async_1$2 = async;
var lift_1$7 = lift;
var OperatorSubscriber_1$6 = OperatorSubscriber$1;
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async_1$2.asyncScheduler;
  }
  return lift_1$7.operate(function(source, subscriber) {
    var last2 = scheduler.now();
    source.subscribe(OperatorSubscriber_1$6.createOperatorSubscriber(subscriber, function(value) {
      var now2 = scheduler.now();
      var interval2 = now2 - last2;
      last2 = now2;
      subscriber.next(new TimeInterval(value, interval2));
    }));
  });
}
timeInterval$1.timeInterval = timeInterval;
var TimeInterval = function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();
timeInterval$1.TimeInterval = TimeInterval;
var timeoutWith$1 = {};
Object.defineProperty(timeoutWith$1, "__esModule", { value: true });
timeoutWith$1.timeoutWith = void 0;
var async_1$1 = async;
var isDate_1 = isDate;
var timeout_1 = timeout;
function timeoutWith(due, withObservable, scheduler) {
  var first2;
  var each;
  var _with;
  scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1$1.async;
  if (isDate_1.isValidDate(due)) {
    first2 = due;
  } else if (typeof due === "number") {
    each = due;
  }
  if (withObservable) {
    _with = function() {
      return withObservable;
    };
  } else {
    throw new TypeError("No observable provided to switch to");
  }
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return timeout_1.timeout({
    first: first2,
    each,
    scheduler,
    with: _with
  });
}
timeoutWith$1.timeoutWith = timeoutWith;
var timestamp$1 = {};
Object.defineProperty(timestamp$1, "__esModule", { value: true });
timestamp$1.timestamp = void 0;
var dateTimestampProvider_1 = dateTimestampProvider;
var map_1 = map$2;
function timestamp(timestampProvider) {
  if (timestampProvider === void 0) {
    timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
  }
  return map_1.map(function(value) {
    return { value, timestamp: timestampProvider.now() };
  });
}
timestamp$1.timestamp = timestamp;
var window$2 = {};
Object.defineProperty(window$2, "__esModule", { value: true });
window$2.window = void 0;
var Subject_1$4 = Subject$1;
var lift_1$6 = lift;
var OperatorSubscriber_1$5 = OperatorSubscriber$1;
var noop_1$2 = noop$1;
var innerFrom_1$3 = innerFrom$1;
function window$1(windowBoundaries) {
  return lift_1$6.operate(function(source, subscriber) {
    var windowSubject = new Subject_1$4.Subject();
    subscriber.next(windowSubject.asObservable());
    var errorHandler = function(err) {
      windowSubject.error(err);
      subscriber.error(err);
    };
    source.subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function(value) {
      return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
    }, function() {
      windowSubject.complete();
      subscriber.complete();
    }, errorHandler));
    innerFrom_1$3.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function() {
      windowSubject.complete();
      subscriber.next(windowSubject = new Subject_1$4.Subject());
    }, noop_1$2.noop, errorHandler));
    return function() {
      windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
      windowSubject = null;
    };
  });
}
window$2.window = window$1;
var windowCount$1 = {};
var __values$1 = commonjsGlobal && commonjsGlobal.__values || function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(windowCount$1, "__esModule", { value: true });
windowCount$1.windowCount = void 0;
var Subject_1$3 = Subject$1;
var lift_1$5 = lift;
var OperatorSubscriber_1$4 = OperatorSubscriber$1;
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
  return lift_1$5.operate(function(source, subscriber) {
    var windows = [new Subject_1$3.Subject()];
    var count2 = 0;
    subscriber.next(windows[0].asObservable());
    source.subscribe(OperatorSubscriber_1$4.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var windows_1 = __values$1(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
          var window_1 = windows_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
            _a.call(windows_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var c2 = count2 - windowSize + 1;
      if (c2 >= 0 && c2 % startEvery === 0) {
        windows.shift().complete();
      }
      if (++count2 % startEvery === 0) {
        var window_2 = new Subject_1$3.Subject();
        windows.push(window_2);
        subscriber.next(window_2.asObservable());
      }
    }, function() {
      while (windows.length > 0) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, function(err) {
      while (windows.length > 0) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    }, function() {
      windows = null;
    }));
  });
}
windowCount$1.windowCount = windowCount;
var windowTime$1 = {};
Object.defineProperty(windowTime$1, "__esModule", { value: true });
windowTime$1.windowTime = void 0;
var Subject_1$2 = Subject$1;
var async_1 = async;
var Subscription_1$1 = Subscription$1;
var lift_1$4 = lift;
var OperatorSubscriber_1$3 = OperatorSubscriber$1;
var arrRemove_1$1 = arrRemove$1;
var args_1$1 = args;
var executeSchedule_1 = executeSchedule$1;
function windowTime(windowTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler = (_a = args_1$1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
  var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxWindowSize = otherArgs[1] || Infinity;
  return lift_1$4.operate(function(source, subscriber) {
    var windowRecords = [];
    var restartOnClose = false;
    var closeWindow = function(record) {
      var window2 = record.window, subs = record.subs;
      window2.complete();
      subs.unsubscribe();
      arrRemove_1$1.arrRemove(windowRecords, record);
      restartOnClose && startWindow();
    };
    var startWindow = function() {
      if (windowRecords) {
        var subs = new Subscription_1$1.Subscription();
        subscriber.add(subs);
        var window_1 = new Subject_1$2.Subject();
        var record_1 = {
          window: window_1,
          subs,
          seen: 0
        };
        windowRecords.push(record_1);
        subscriber.next(window_1.asObservable());
        executeSchedule_1.executeSchedule(subs, scheduler, function() {
          return closeWindow(record_1);
        }, windowTimeSpan);
      }
    };
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
    } else {
      restartOnClose = true;
    }
    startWindow();
    var loop = function(cb) {
      return windowRecords.slice().forEach(cb);
    };
    var terminate = function(cb) {
      loop(function(_a2) {
        var window2 = _a2.window;
        return cb(window2);
      });
      cb(subscriber);
      subscriber.unsubscribe();
    };
    source.subscribe(OperatorSubscriber_1$3.createOperatorSubscriber(subscriber, function(value) {
      loop(function(record) {
        record.window.next(value);
        maxWindowSize <= ++record.seen && closeWindow(record);
      });
    }, function() {
      return terminate(function(consumer) {
        return consumer.complete();
      });
    }, function(err) {
      return terminate(function(consumer) {
        return consumer.error(err);
      });
    }));
    return function() {
      windowRecords = null;
    };
  });
}
windowTime$1.windowTime = windowTime;
var windowToggle$1 = {};
var __values = commonjsGlobal && commonjsGlobal.__values || function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(windowToggle$1, "__esModule", { value: true });
windowToggle$1.windowToggle = void 0;
var Subject_1$1 = Subject$1;
var Subscription_1 = Subscription$1;
var lift_1$3 = lift;
var innerFrom_1$2 = innerFrom$1;
var OperatorSubscriber_1$2 = OperatorSubscriber$1;
var noop_1$1 = noop$1;
var arrRemove_1 = arrRemove$1;
function windowToggle(openings, closingSelector) {
  return lift_1$3.operate(function(source, subscriber) {
    var windows = [];
    var handleError = function(err) {
      while (0 < windows.length) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    };
    innerFrom_1$2.innerFrom(openings).subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function(openValue) {
      var window2 = new Subject_1$1.Subject();
      windows.push(window2);
      var closingSubscription = new Subscription_1.Subscription();
      var closeWindow = function() {
        arrRemove_1.arrRemove(windows, window2);
        window2.complete();
        closingSubscription.unsubscribe();
      };
      var closingNotifier;
      try {
        closingNotifier = innerFrom_1$2.innerFrom(closingSelector(openValue));
      } catch (err) {
        handleError(err);
        return;
      }
      subscriber.next(window2.asObservable());
      closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, closeWindow, noop_1$1.noop, handleError)));
    }, noop_1$1.noop));
    source.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      var windowsCopy = windows.slice();
      try {
        for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
          var window_1 = windowsCopy_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
            _a.call(windowsCopy_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (0 < windows.length) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, handleError, function() {
      while (0 < windows.length) {
        windows.shift().unsubscribe();
      }
    }));
  });
}
windowToggle$1.windowToggle = windowToggle;
var windowWhen$1 = {};
Object.defineProperty(windowWhen$1, "__esModule", { value: true });
windowWhen$1.windowWhen = void 0;
var Subject_1 = Subject$1;
var lift_1$2 = lift;
var OperatorSubscriber_1$1 = OperatorSubscriber$1;
var innerFrom_1$1 = innerFrom$1;
function windowWhen(closingSelector) {
  return lift_1$2.operate(function(source, subscriber) {
    var window2;
    var closingSubscriber;
    var handleError = function(err) {
      window2.error(err);
      subscriber.error(err);
    };
    var openWindow = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window2 === null || window2 === void 0 ? void 0 : window2.complete();
      window2 = new Subject_1.Subject();
      subscriber.next(window2.asObservable());
      var closingNotifier;
      try {
        closingNotifier = innerFrom_1$1.innerFrom(closingSelector());
      } catch (err) {
        handleError(err);
        return;
      }
      closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
    };
    openWindow();
    source.subscribe(OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, function(value) {
      return window2.next(value);
    }, function() {
      window2.complete();
      subscriber.complete();
    }, handleError, function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window2 = null;
    }));
  });
}
windowWhen$1.windowWhen = windowWhen;
var withLatestFrom$1 = {};
var __read$3 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$3 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(withLatestFrom$1, "__esModule", { value: true });
withLatestFrom$1.withLatestFrom = void 0;
var lift_1$1 = lift;
var OperatorSubscriber_1 = OperatorSubscriber$1;
var innerFrom_1 = innerFrom$1;
var identity_1 = identity$1;
var noop_1 = noop$1;
var args_1 = args;
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project2 = args_1.popResultSelector(inputs);
  return lift_1$1.operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i3) {
      innerFrom_1.innerFrom(inputs[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        otherValues[i3] = value;
        if (!ready && !hasValue[i3]) {
          hasValue[i3] = true;
          (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
        }
      }, noop_1.noop));
    };
    for (var i2 = 0; i2 < len; i2++) {
      _loop_1(i2);
    }
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray$3([value], __read$3(otherValues));
        subscriber.next(project2 ? project2.apply(void 0, __spreadArray$3([], __read$3(values))) : values);
      }
    }));
  });
}
withLatestFrom$1.withLatestFrom = withLatestFrom;
var zipAll$1 = {};
Object.defineProperty(zipAll$1, "__esModule", { value: true });
zipAll$1.zipAll = void 0;
var zip_1$2 = zip$4;
var joinAllInternals_1 = joinAllInternals$1;
function zipAll(project2) {
  return joinAllInternals_1.joinAllInternals(zip_1$2.zip, project2);
}
zipAll$1.zipAll = zipAll;
var zipWith$1 = {};
var zip$2 = {};
var __read$2 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(zip$2, "__esModule", { value: true });
zip$2.zip = void 0;
var zip_1$1 = zip$4;
var lift_1 = lift;
function zip$1() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return lift_1.operate(function(source, subscriber) {
    zip_1$1.zip.apply(void 0, __spreadArray$2([source], __read$2(sources))).subscribe(subscriber);
  });
}
zip$2.zip = zip$1;
var __read$1 = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$1 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(zipWith$1, "__esModule", { value: true });
zipWith$1.zipWith = void 0;
var zip_1 = zip$2;
function zipWith() {
  var otherInputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherInputs[_i] = arguments[_i];
  }
  return zip_1.zip.apply(void 0, __spreadArray$1([], __read$1(otherInputs)));
}
zipWith$1.zipWith = zipWith;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
  exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
  exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
  exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
  var Observable_12 = Observable$1;
  Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
    return Observable_12.Observable;
  } });
  var ConnectableObservable_12 = ConnectableObservable$1;
  Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
    return ConnectableObservable_12.ConnectableObservable;
  } });
  var observable_12 = observable;
  Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
    return observable_12.observable;
  } });
  var animationFrames_1 = animationFrames$1;
  Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
    return animationFrames_1.animationFrames;
  } });
  var Subject_12 = Subject$1;
  Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
    return Subject_12.Subject;
  } });
  var BehaviorSubject_12 = BehaviorSubject$1;
  Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
    return BehaviorSubject_12.BehaviorSubject;
  } });
  var ReplaySubject_12 = ReplaySubject$1;
  Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
    return ReplaySubject_12.ReplaySubject;
  } });
  var AsyncSubject_12 = AsyncSubject$1;
  Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
    return AsyncSubject_12.AsyncSubject;
  } });
  var asap_1 = asap;
  Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
    return asap_1.asap;
  } });
  Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
    return asap_1.asapScheduler;
  } });
  var async_12 = async;
  Object.defineProperty(exports, "async", { enumerable: true, get: function() {
    return async_12.async;
  } });
  Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
    return async_12.asyncScheduler;
  } });
  var queue_1 = queue;
  Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
    return queue_1.queue;
  } });
  Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
    return queue_1.queueScheduler;
  } });
  var animationFrame_1 = animationFrame;
  Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
    return animationFrame_1.animationFrame;
  } });
  Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
    return animationFrame_1.animationFrameScheduler;
  } });
  var VirtualTimeScheduler_1 = VirtualTimeScheduler$1;
  Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualTimeScheduler;
  } });
  Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualAction;
  } });
  var Scheduler_12 = Scheduler$1;
  Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
    return Scheduler_12.Scheduler;
  } });
  var Subscription_12 = Subscription$1;
  Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
    return Subscription_12.Subscription;
  } });
  var Subscriber_12 = Subscriber;
  Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
    return Subscriber_12.Subscriber;
  } });
  var Notification_12 = Notification;
  Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
    return Notification_12.Notification;
  } });
  Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
    return Notification_12.NotificationKind;
  } });
  var pipe_12 = pipe$1;
  Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
    return pipe_12.pipe;
  } });
  var noop_12 = noop$1;
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return noop_12.noop;
  } });
  var identity_12 = identity$1;
  Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
    return identity_12.identity;
  } });
  var isObservable_1 = isObservable$1;
  Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
    return isObservable_1.isObservable;
  } });
  var lastValueFrom_1 = lastValueFrom$1;
  Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
    return lastValueFrom_1.lastValueFrom;
  } });
  var firstValueFrom_1 = firstValueFrom$1;
  Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
    return firstValueFrom_1.firstValueFrom;
  } });
  var ArgumentOutOfRangeError_12 = ArgumentOutOfRangeError;
  Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
    return ArgumentOutOfRangeError_12.ArgumentOutOfRangeError;
  } });
  var EmptyError_12 = EmptyError;
  Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
    return EmptyError_12.EmptyError;
  } });
  var NotFoundError_12 = NotFoundError$1;
  Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
    return NotFoundError_12.NotFoundError;
  } });
  var ObjectUnsubscribedError_12 = ObjectUnsubscribedError;
  Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
    return ObjectUnsubscribedError_12.ObjectUnsubscribedError;
  } });
  var SequenceError_12 = SequenceError;
  Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
    return SequenceError_12.SequenceError;
  } });
  var timeout_12 = timeout;
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_12.TimeoutError;
  } });
  var UnsubscriptionError_12 = UnsubscriptionError;
  Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
    return UnsubscriptionError_12.UnsubscriptionError;
  } });
  var bindCallback_1 = bindCallback$1;
  Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
    return bindCallback_1.bindCallback;
  } });
  var bindNodeCallback_1 = bindNodeCallback$1;
  Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
    return bindNodeCallback_1.bindNodeCallback;
  } });
  var combineLatest_12 = combineLatest$3;
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_12.combineLatest;
  } });
  var concat_12 = concat$4;
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_12.concat;
  } });
  var connectable_1 = connectable$1;
  Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
    return connectable_1.connectable;
  } });
  var defer_12 = defer$1;
  Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
    return defer_12.defer;
  } });
  var empty_12 = empty;
  Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
    return empty_12.empty;
  } });
  var forkJoin_1 = forkJoin$1;
  Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
    return forkJoin_1.forkJoin;
  } });
  var from_12 = from$1;
  Object.defineProperty(exports, "from", { enumerable: true, get: function() {
    return from_12.from;
  } });
  var fromEvent_1 = fromEvent$1;
  Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
    return fromEvent_1.fromEvent;
  } });
  var fromEventPattern_1 = fromEventPattern$1;
  Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
    return fromEventPattern_1.fromEventPattern;
  } });
  var generate_1 = generate$1;
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return generate_1.generate;
  } });
  var iif_1 = iif$1;
  Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
    return iif_1.iif;
  } });
  var interval_12 = interval$1;
  Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
    return interval_12.interval;
  } });
  var merge_12 = merge$5;
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_12.merge;
  } });
  var never_1 = never;
  Object.defineProperty(exports, "never", { enumerable: true, get: function() {
    return never_1.never;
  } });
  var of_12 = of$1;
  Object.defineProperty(exports, "of", { enumerable: true, get: function() {
    return of_12.of;
  } });
  var onErrorResumeNext_12 = onErrorResumeNext$1;
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNext_12.onErrorResumeNext;
  } });
  var pairs_1 = pairs$1;
  Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
    return pairs_1.pairs;
  } });
  var partition_1 = partition$3;
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var race_12 = race$3;
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_12.race;
  } });
  var range_1 = range$2;
  Object.defineProperty(exports, "range", { enumerable: true, get: function() {
    return range_1.range;
  } });
  var throwError_1 = throwError$1;
  Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
    return throwError_1.throwError;
  } });
  var timer_12 = timer$1;
  Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
    return timer_12.timer;
  } });
  var using_1 = using$1;
  Object.defineProperty(exports, "using", { enumerable: true, get: function() {
    return using_1.using;
  } });
  var zip_12 = zip$4;
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_12.zip;
  } });
  var scheduled_12 = scheduled$1;
  Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
    return scheduled_12.scheduled;
  } });
  var empty_2 = empty;
  Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
    return empty_2.EMPTY;
  } });
  var never_2 = never;
  Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
    return never_2.NEVER;
  } });
  __exportStar(types, exports);
  var config_12 = config;
  Object.defineProperty(exports, "config", { enumerable: true, get: function() {
    return config_12.config;
  } });
  var audit_12 = audit$1;
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_12.audit;
  } });
  var auditTime_1 = auditTime$1;
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = buffer$1;
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = bufferCount$1;
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = bufferTime$1;
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = bufferToggle$1;
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = bufferWhen$1;
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = catchError$1;
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = combineAll;
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_12 = combineLatestAll$1;
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_12.combineLatestAll;
  } });
  var combineLatestWith_1 = combineLatestWith$1;
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concatAll_12 = concatAll$1;
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_12.concatAll;
  } });
  var concatMap_12 = concatMap$1;
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_12.concatMap;
  } });
  var concatMapTo_1 = concatMapTo$1;
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = concatWith$1;
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_12 = connect$1;
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_12.connect;
  } });
  var count_1 = count$3;
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = debounce$1;
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = debounceTime$1;
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_12 = defaultIfEmpty$1;
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_12.defaultIfEmpty;
  } });
  var delay_1 = delay$1;
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_12 = delayWhen$1;
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_12.delayWhen;
  } });
  var dematerialize_1 = dematerialize$1;
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = distinct$1;
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_12 = distinctUntilChanged$1;
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_12.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = distinctUntilKeyChanged$1;
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = elementAt$1;
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = endWith$1;
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = every$1;
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = exhaust;
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_12 = exhaustAll$1;
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_12.exhaustAll;
  } });
  var exhaustMap_12 = exhaustMap$1;
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_12.exhaustMap;
  } });
  var expand_1 = expand$1;
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_12 = filter$2;
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_12.filter;
  } });
  var finalize_1 = finalize$1;
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_12 = find$1;
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_12.find;
  } });
  var findIndex_1 = findIndex$1;
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = first$3;
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = groupBy$1;
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_12 = ignoreElements$1;
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_12.ignoreElements;
  } });
  var isEmpty_1 = isEmpty$1;
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = last$3;
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_12 = map$2;
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_12.map;
  } });
  var mapTo_12 = mapTo$1;
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_12.mapTo;
  } });
  var materialize_1 = materialize$1;
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = max$2;
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var mergeAll_12 = mergeAll$1;
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_12.mergeAll;
  } });
  var flatMap_1 = flatMap;
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_12 = mergeMap$1;
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_12.mergeMap;
  } });
  var mergeMapTo_1 = mergeMapTo$1;
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = mergeScan$1;
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = mergeWith$1;
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = min$2;
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_12 = multicast$1;
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_12.multicast;
  } });
  var observeOn_12 = observeOn$1;
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_12.observeOn;
  } });
  var onErrorResumeNextWith_1 = onErrorResumeNextWith$1;
  Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNextWith;
  } });
  var pairwise_1 = pairwise$1;
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var pluck_1 = pluck$1;
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = publish$1;
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = publishBehavior$1;
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = publishLast$1;
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = publishReplay$1;
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var raceWith_12 = raceWith$1;
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_12.raceWith;
  } });
  var reduce_12 = reduce$2;
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_12.reduce;
  } });
  var repeat_1 = repeat$1;
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = repeatWhen$1;
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = retry$1;
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = retryWhen$1;
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_12 = refCount$1;
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_12.refCount;
  } });
  var sample_12 = sample$2;
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_12.sample;
  } });
  var sampleTime_1 = sampleTime$1;
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = scan$1;
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = sequenceEqual$1;
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_12 = share$1;
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_12.share;
  } });
  var shareReplay_1 = shareReplay$1;
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = single$1;
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = skip$2;
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = skipLast$1;
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = skipUntil$1;
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = skipWhile$1;
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = startWith$1;
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_12 = subscribeOn$1;
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_12.subscribeOn;
  } });
  var switchAll_1 = switchAll$1;
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_12 = switchMap$1;
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_12.switchMap;
  } });
  var switchMapTo_1 = switchMapTo$1;
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = switchScan$1;
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_12 = take$1;
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_12.take;
  } });
  var takeLast_12 = takeLast$1;
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_12.takeLast;
  } });
  var takeUntil_1 = takeUntil$1;
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = takeWhile$1;
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = tap$1;
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_12 = throttle$1;
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_12.throttle;
  } });
  var throttleTime_1 = throttleTime$1;
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_12 = throwIfEmpty$1;
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_12.throwIfEmpty;
  } });
  var timeInterval_1 = timeInterval$1;
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_2 = timeout;
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_2.timeout;
  } });
  var timeoutWith_1 = timeoutWith$1;
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = timestamp$1;
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_12 = toArray$2;
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_12.toArray;
  } });
  var window_1 = window$2;
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = windowCount$1;
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = windowTime$1;
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = windowToggle$1;
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = windowWhen$1;
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = withLatestFrom$1;
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zipAll_1 = zipAll$1;
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = zipWith$1;
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
})(cjs);
var storageRemote = {};
var rxStorageRemote = {};
var utils = {};
var utilsArray = {};
Object.defineProperty(utilsArray, "__esModule", {
  value: true
});
utilsArray.appendToArray = appendToArray;
utilsArray.arrayFilterNotEmpty = arrayFilterNotEmpty;
utilsArray.asyncFilter = asyncFilter;
utilsArray.batchArray = batchArray;
utilsArray.countUntilNotMatching = countUntilNotMatching;
utilsArray.isMaybeReadonlyArray = isMaybeReadonlyArray;
utilsArray.lastOfArray = lastOfArray;
utilsArray.maxOfNumbers = maxOfNumbers;
utilsArray.removeOneFromArrayIfMatches = removeOneFromArrayIfMatches;
utilsArray.shuffleArray = shuffleArray;
utilsArray.sumNumberArray = sumNumberArray;
utilsArray.toArray = toArray;
function lastOfArray(ar) {
  return ar[ar.length - 1];
}
function shuffleArray(arr) {
  return arr.slice(0).sort(() => Math.random() - 0.5);
}
function toArray(input) {
  return Array.isArray(input) ? input.slice(0) : [input];
}
function batchArray(array2, batchSize) {
  array2 = array2.slice(0);
  var ret = [];
  while (array2.length) {
    var batch = array2.splice(0, batchSize);
    ret.push(batch);
  }
  return ret;
}
function removeOneFromArrayIfMatches(ar, condition) {
  ar = ar.slice();
  var i2 = ar.length;
  var done = false;
  while (i2-- && !done) {
    if (condition(ar[i2])) {
      done = true;
      ar.splice(i2, 1);
    }
  }
  return ar;
}
function isMaybeReadonlyArray(x2) {
  return Array.isArray(x2);
}
function arrayFilterNotEmpty(value) {
  if (value === null || value === void 0) {
    return false;
  }
  return true;
}
function countUntilNotMatching(ar, matchingFn) {
  var count2 = 0;
  var idx = -1;
  for (var _item of ar) {
    idx = idx + 1;
    var matching = matchingFn(_item, idx);
    if (matching) {
      count2 = count2 + 1;
    } else {
      break;
    }
  }
  return count2;
}
async function asyncFilter(array2, predicate) {
  var filters = await Promise.all(array2.map(predicate));
  return array2.filter((...[, index]) => filters[index]);
}
function sumNumberArray(array2) {
  var count2 = 0;
  for (var i2 = array2.length; i2--; ) {
    count2 += array2[i2];
  }
  return count2;
}
function maxOfNumbers(arr) {
  return Math.max(...arr);
}
function appendToArray(ar, add2) {
  var amount = add2.length;
  for (var i2 = 0; i2 < amount; ++i2) {
    var element2 = add2[i2];
    ar.push(element2);
  }
}
var utilsBlob = {};
var utilsBase64 = {};
var base64 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : commonjsGlobal, function() {
    var version = "3.7.5";
    var VERSION = version;
    var _hasatob = typeof atob === "function";
    var _hasbtoa = typeof btoa === "function";
    var _hasBuffer = typeof Buffer === "function";
    var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
    var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
    var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var b64chs = Array.prototype.slice.call(b64ch);
    var b64tab = function(a2) {
      var tab = {};
      a2.forEach(function(c2, i2) {
        return tab[c2] = i2;
      });
      return tab;
    }(b64chs);
    var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    var _fromCC = String.fromCharCode.bind(String);
    var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it2) {
      return new Uint8Array(Array.prototype.slice.call(it2, 0));
    };
    var _mkUriSafe = function(src2) {
      return src2.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
        return m0 == "+" ? "-" : "_";
      });
    };
    var _tidyB64 = function(s2) {
      return s2.replace(/[^A-Za-z0-9\+\/]/g, "");
    };
    var btoaPolyfill = function(bin) {
      var u32, c0, c1, c2, asc = "";
      var pad = bin.length % 3;
      for (var i2 = 0; i2 < bin.length; ) {
        if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255)
          throw new TypeError("invalid character found");
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
      }
      return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    var _btoa = _hasbtoa ? function(bin) {
      return btoa(bin);
    } : _hasBuffer ? function(bin) {
      return Buffer.from(bin, "binary").toString("base64");
    } : btoaPolyfill;
    var _fromUint8Array = _hasBuffer ? function(u8a) {
      return Buffer.from(u8a).toString("base64");
    } : function(u8a) {
      var maxargs = 4096;
      var strs = [];
      for (var i2 = 0, l2 = u8a.length; i2 < l2; i2 += maxargs) {
        strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
      }
      return _btoa(strs.join(""));
    };
    var fromUint8Array = function(u8a, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    };
    var cb_utob = function(c2) {
      if (c2.length < 2) {
        var cc = c2.charCodeAt(0);
        return cc < 128 ? c2 : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      } else {
        var cc = 65536 + (c2.charCodeAt(0) - 55296) * 1024 + (c2.charCodeAt(1) - 56320);
        return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u2) {
      return u2.replace(re_utob, cb_utob);
    };
    var _encode = _hasBuffer ? function(s2) {
      return Buffer.from(s2, "utf8").toString("base64");
    } : _TE ? function(s2) {
      return _fromUint8Array(_TE.encode(s2));
    } : function(s2) {
      return _btoa(utob(s2));
    };
    var encode = function(src2, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_encode(src2)) : _encode(src2);
    };
    var encodeURI2 = function(src2) {
      return encode(src2, true);
    };
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function(cccc) {
      switch (cccc.length) {
        case 4:
          var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
          return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
        case 3:
          return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
        default:
          return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
      }
    };
    var btou = function(b2) {
      return b2.replace(re_btou, cb_btou);
    };
    var atobPolyfill = function(asc) {
      asc = asc.replace(/\s+/g, "");
      if (!b64re.test(asc))
        throw new TypeError("malformed base64.");
      asc += "==".slice(2 - (asc.length & 3));
      var u24, bin = "", r1, r2;
      for (var i2 = 0; i2 < asc.length; ) {
        u24 = b64tab[asc.charAt(i2++)] << 18 | b64tab[asc.charAt(i2++)] << 12 | (r1 = b64tab[asc.charAt(i2++)]) << 6 | (r2 = b64tab[asc.charAt(i2++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
      }
      return bin;
    };
    var _atob = _hasatob ? function(asc) {
      return atob(_tidyB64(asc));
    } : _hasBuffer ? function(asc) {
      return Buffer.from(asc, "base64").toString("binary");
    } : atobPolyfill;
    var _toUint8Array = _hasBuffer ? function(a2) {
      return _U8Afrom(Buffer.from(a2, "base64"));
    } : function(a2) {
      return _U8Afrom(_atob(a2).split("").map(function(c2) {
        return c2.charCodeAt(0);
      }));
    };
    var toUint8Array = function(a2) {
      return _toUint8Array(_unURI(a2));
    };
    var _decode = _hasBuffer ? function(a2) {
      return Buffer.from(a2, "base64").toString("utf8");
    } : _TD ? function(a2) {
      return _TD.decode(_toUint8Array(a2));
    } : function(a2) {
      return btou(_atob(a2));
    };
    var _unURI = function(a2) {
      return _tidyB64(a2.replace(/[-_]/g, function(m0) {
        return m0 == "-" ? "+" : "/";
      }));
    };
    var decode = function(src2) {
      return _decode(_unURI(src2));
    };
    var isValid = function(src2) {
      if (typeof src2 !== "string")
        return false;
      var s2 = src2.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(s2) || !/[^\s0-9a-zA-Z\-_]/.test(s2);
    };
    var _noEnum = function(v2) {
      return {
        value: v2,
        enumerable: false,
        writable: true,
        configurable: true
      };
    };
    var extendString = function() {
      var _add = function(name, body) {
        return Object.defineProperty(String.prototype, name, _noEnum(body));
      };
      _add("fromBase64", function() {
        return decode(this);
      });
      _add("toBase64", function(urlsafe) {
        return encode(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return encode(this, true);
      });
      _add("toBase64URL", function() {
        return encode(this, true);
      });
      _add("toUint8Array", function() {
        return toUint8Array(this);
      });
    };
    var extendUint8Array = function() {
      var _add = function(name, body) {
        return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
      };
      _add("toBase64", function(urlsafe) {
        return fromUint8Array(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return fromUint8Array(this, true);
      });
      _add("toBase64URL", function() {
        return fromUint8Array(this, true);
      });
    };
    var extendBuiltins = function() {
      extendString();
      extendUint8Array();
    };
    var gBase64 = {
      version,
      VERSION,
      atob: _atob,
      atobPolyfill,
      btoa: _btoa,
      btoaPolyfill,
      fromBase64: decode,
      toBase64: encode,
      encode,
      encodeURI: encodeURI2,
      encodeURL: encodeURI2,
      utob,
      btou,
      decode,
      isValid,
      fromUint8Array,
      toUint8Array,
      extendString,
      extendUint8Array,
      extendBuiltins
    };
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(function(k2) {
      return gBase64.Base64[k2] = gBase64[k2];
    });
    return gBase64;
  });
})(base64);
var base64Exports = base64.exports;
Object.defineProperty(utilsBase64, "__esModule", {
  value: true
});
utilsBase64.arrayBufferToBase64 = arrayBufferToBase64;
utilsBase64.b64DecodeUnicode = b64DecodeUnicode;
utilsBase64.b64EncodeUnicode = b64EncodeUnicode;
utilsBase64.base64ToArrayBuffer = base64ToArrayBuffer;
var _jsBase = base64Exports;
function b64EncodeUnicode(str) {
  return (0, _jsBase.encode)(str);
}
function b64DecodeUnicode(str) {
  return (0, _jsBase.decode)(str);
}
function arrayBufferToBase64(buffer2) {
  var binary = "";
  var bytes = new Uint8Array(buffer2);
  var len = bytes.byteLength;
  for (var i2 = 0; i2 < len; i2++) {
    binary += String.fromCharCode(bytes[i2]);
  }
  return btoa(binary);
}
function base64ToArrayBuffer(base642) {
  var binary_string = atob(base642);
  var len = binary_string.length;
  var bytes = new Uint8Array(len);
  for (var i2 = 0; i2 < len; i2++) {
    bytes[i2] = binary_string.charCodeAt(i2);
  }
  return bytes.buffer;
}
Object.defineProperty(utilsBlob, "__esModule", {
  value: true
});
utilsBlob.blobToBase64String = blobToBase64String;
utilsBlob.blobToString = blobToString;
utilsBlob.createBlob = createBlob;
utilsBlob.createBlobFromBase64 = createBlobFromBase64;
utilsBlob.getBlobSize = getBlobSize;
utilsBlob.isBlob = isBlob;
var _utilsBase = utilsBase64;
function createBlob(data, type2) {
  var blob = new Blob([data], {
    type: type2
  });
  return blob;
}
async function createBlobFromBase64(base64String, type2) {
  var base64Response = await fetch("data:" + type2 + ";base64," + base64String);
  var blob = await base64Response.blob();
  return blob;
}
function isBlob(data) {
  if (data instanceof Blob || typeof Buffer !== "undefined" && Buffer.isBuffer(data)) {
    return true;
  } else {
    return false;
  }
}
function blobToString(blob) {
  var blobType = Object.prototype.toString.call(blob);
  if (blobType === "[object Uint8Array]") {
    blob = new Blob([blob]);
  }
  if (typeof blob === "string") {
    return Promise.resolve(blob);
  }
  return blob.text();
}
async function blobToBase64String(blob) {
  if (typeof blob === "string") {
    return blob;
  }
  var blobType = Object.prototype.toString.call(blob);
  if (blobType === "[object Uint8Array]") {
    blob = new Blob([blob]);
  }
  var fetchUrl = URL.createObjectURL(blob);
  var arrayBuffer = await fetch(fetchUrl).then((res) => res.arrayBuffer());
  return (0, _utilsBase.arrayBufferToBase64)(arrayBuffer);
}
function getBlobSize(blob) {
  return blob.size;
}
var utilsRevision = {};
Object.defineProperty(utilsRevision, "__esModule", {
  value: true
});
utilsRevision.createRevision = createRevision;
utilsRevision.getHeightOfRevision = getHeightOfRevision;
utilsRevision.parseRevision = parseRevision;
function parseRevision(revision) {
  var split2 = revision.split("-");
  if (split2.length !== 2) {
    throw new Error("malformatted revision: " + revision);
  }
  return {
    height: parseInt(split2[0], 10),
    hash: split2[1]
  };
}
function getHeightOfRevision(revision) {
  var ret = parseInt(revision.split("-")[0], 10);
  return ret;
}
function createRevision(databaseInstanceToken, previousDocData) {
  var previousRevision = previousDocData ? previousDocData._rev : null;
  var previousRevisionHeight = previousRevision ? parseRevision(previousRevision).height : 0;
  var newRevisionHeight = previousRevisionHeight + 1;
  return newRevisionHeight + "-" + databaseInstanceToken;
}
var utilsDocument = {};
Object.defineProperty(utilsDocument, "__esModule", {
  value: true
});
utilsDocument.RX_META_LWT_MINIMUM = void 0;
utilsDocument.areRxDocumentArraysEqual = areRxDocumentArraysEqual;
utilsDocument.getDefaultRevision = getDefaultRevision;
utilsDocument.getDefaultRxDocumentMeta = getDefaultRxDocumentMeta;
utilsDocument.getSortDocumentsByLastWriteTimeComparator = getSortDocumentsByLastWriteTimeComparator;
utilsDocument.sortDocumentsByLastWriteTime = sortDocumentsByLastWriteTime;
utilsDocument.stripMetaDataFromDocument = stripMetaDataFromDocument;
var RX_META_LWT_MINIMUM = 1;
utilsDocument.RX_META_LWT_MINIMUM = RX_META_LWT_MINIMUM;
function getDefaultRxDocumentMeta() {
  return {
    /**
     * Set this to 1 to not waste performance
     * while calling new Date()..
     * The storage wrappers will anyway update
     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()
     */
    lwt: RX_META_LWT_MINIMUM
  };
}
function getDefaultRevision() {
  return "";
}
function stripMetaDataFromDocument(docData) {
  return Object.assign({}, docData, {
    _meta: void 0,
    _deleted: void 0,
    _rev: void 0
  });
}
function areRxDocumentArraysEqual(primaryPath, ar1, ar2) {
  if (ar1.length !== ar2.length) {
    return false;
  }
  var i2 = 0;
  var len = ar1.length;
  while (i2 < len) {
    var row1 = ar1[i2];
    var row2 = ar2[i2];
    i2++;
    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {
      return false;
    }
  }
  return true;
}
function getSortDocumentsByLastWriteTimeComparator(primaryPath) {
  return (a2, b2) => {
    if (a2._meta.lwt === b2._meta.lwt) {
      if (b2[primaryPath] < a2[primaryPath]) {
        return 1;
      } else {
        return -1;
      }
    } else {
      return a2._meta.lwt - b2._meta.lwt;
    }
  };
}
function sortDocumentsByLastWriteTime(primaryPath, docs) {
  return docs.sort(getSortDocumentsByLastWriteTimeComparator(primaryPath));
}
var utilsHash = {};
var dist$2 = {};
const defaults = Object.freeze({
  ignoreUnknown: false,
  respectType: false,
  respectFunctionNames: false,
  respectFunctionProperties: false,
  unorderedObjects: true,
  unorderedArrays: false,
  unorderedSets: false,
  excludeKeys: void 0,
  excludeValues: void 0,
  replacer: void 0
});
function objectHash(object2, options2) {
  if (options2) {
    options2 = { ...defaults, ...options2 };
  } else {
    options2 = defaults;
  }
  const hasher = createHasher(options2);
  hasher.dispatch(object2);
  return hasher.toString();
}
const defaultPrototypesKeys = Object.freeze([
  "prototype",
  "__proto__",
  "constructor"
]);
function createHasher(options2) {
  let buff = "";
  let context2 = /* @__PURE__ */ new Map();
  const write = (str) => {
    buff += str;
  };
  return {
    toString() {
      return buff;
    },
    getContext() {
      return context2;
    },
    dispatch(value) {
      if (options2.replacer) {
        value = options2.replacer(value);
      }
      const type2 = value === null ? "null" : typeof value;
      return this[type2](value);
    },
    object(object2) {
      if (object2 && typeof object2.toJSON === "function") {
        return this.object(object2.toJSON());
      }
      const objString = Object.prototype.toString.call(object2);
      let objType = "";
      const objectLength = objString.length;
      if (objectLength < 10) {
        objType = "unknown:[" + objString + "]";
      } else {
        objType = objString.slice(8, objectLength - 1);
      }
      objType = objType.toLowerCase();
      let objectNumber = null;
      if ((objectNumber = context2.get(object2)) === void 0) {
        context2.set(object2, context2.size);
      } else {
        return this.dispatch("[CIRCULAR:" + objectNumber + "]");
      }
      if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object2)) {
        write("buffer:");
        return write(object2.toString("utf8"));
      }
      if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
        if (this[objType]) {
          this[objType](object2);
        } else if (!options2.ignoreUnknown) {
          this.unkown(object2, objType);
        }
      } else {
        let keys = Object.keys(object2);
        if (options2.unorderedObjects) {
          keys = keys.sort();
        }
        let extraKeys = [];
        if (options2.respectType !== false && !isNativeFunction$1(object2)) {
          extraKeys = defaultPrototypesKeys;
        }
        if (options2.excludeKeys) {
          keys = keys.filter((key) => {
            return !options2.excludeKeys(key);
          });
          extraKeys = extraKeys.filter((key) => {
            return !options2.excludeKeys(key);
          });
        }
        write("object:" + (keys.length + extraKeys.length) + ":");
        const dispatchForKey = (key) => {
          this.dispatch(key);
          write(":");
          if (!options2.excludeValues) {
            this.dispatch(object2[key]);
          }
          write(",");
        };
        for (const key of keys) {
          dispatchForKey(key);
        }
        for (const key of extraKeys) {
          dispatchForKey(key);
        }
      }
    },
    array(arr, unordered) {
      unordered = unordered === void 0 ? options2.unorderedArrays !== false : unordered;
      write("array:" + arr.length + ":");
      if (!unordered || arr.length <= 1) {
        for (const entry of arr) {
          this.dispatch(entry);
        }
        return;
      }
      const contextAdditions = /* @__PURE__ */ new Map();
      const entries2 = arr.map((entry) => {
        const hasher = createHasher(options2);
        hasher.dispatch(entry);
        for (const [key, value] of hasher.getContext()) {
          contextAdditions.set(key, value);
        }
        return hasher.toString();
      });
      context2 = contextAdditions;
      entries2.sort();
      return this.array(entries2, false);
    },
    date(date2) {
      return write("date:" + date2.toJSON());
    },
    symbol(sym) {
      return write("symbol:" + sym.toString());
    },
    unkown(value, type2) {
      write(type2);
      if (!value) {
        return;
      }
      write(":");
      if (value && typeof value.entries === "function") {
        return this.array(
          Array.from(value.entries()),
          true
          /* ordered */
        );
      }
    },
    error(err) {
      return write("error:" + err.toString());
    },
    boolean(bool) {
      return write("bool:" + bool);
    },
    string(string2) {
      write("string:" + string2.length + ":");
      write(string2);
    },
    function(fn2) {
      write("fn:");
      if (isNativeFunction$1(fn2)) {
        this.dispatch("[native]");
      } else {
        this.dispatch(fn2.toString());
      }
      if (options2.respectFunctionNames !== false) {
        this.dispatch("function-name:" + String(fn2.name));
      }
      if (options2.respectFunctionProperties) {
        this.object(fn2);
      }
    },
    number(number) {
      return write("number:" + number);
    },
    xml(xml) {
      return write("xml:" + xml.toString());
    },
    null() {
      return write("Null");
    },
    undefined() {
      return write("Undefined");
    },
    regexp(regex2) {
      return write("regex:" + regex2.toString());
    },
    uint8array(arr) {
      write("uint8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint8clampedarray(arr) {
      write("uint8clampedarray:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int8array(arr) {
      write("int8array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint16array(arr) {
      write("uint16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int16array(arr) {
      write("int16array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    uint32array(arr) {
      write("uint32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    int32array(arr) {
      write("int32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    float32array(arr) {
      write("float32array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    float64array(arr) {
      write("float64array:");
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    arraybuffer(arr) {
      write("arraybuffer:");
      return this.dispatch(new Uint8Array(arr));
    },
    url(url) {
      return write("url:" + url.toString());
    },
    map(map2) {
      write("map:");
      const arr = [...map2];
      return this.array(arr, options2.unorderedSets !== false);
    },
    set(set2) {
      write("set:");
      const arr = [...set2];
      return this.array(arr, options2.unorderedSets !== false);
    },
    file(file) {
      write("file:");
      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
    },
    blob() {
      if (options2.ignoreUnknown) {
        return write("[blob]");
      }
      throw new Error(
        'Hashing Blob objects is currently not supported\nUse "options.replacer" or "options.ignoreUnknown"\n'
      );
    },
    domwindow() {
      return write("domwindow");
    },
    bigint(number) {
      return write("bigint:" + number.toString());
    },
    /* Node.js standard native objects */
    process() {
      return write("process");
    },
    timer() {
      return write("timer");
    },
    pipe() {
      return write("pipe");
    },
    tcp() {
      return write("tcp");
    },
    udp() {
      return write("udp");
    },
    tty() {
      return write("tty");
    },
    statwatcher() {
      return write("statwatcher");
    },
    securecontext() {
      return write("securecontext");
    },
    connection() {
      return write("connection");
    },
    zlib() {
      return write("zlib");
    },
    context() {
      return write("context");
    },
    nodescript() {
      return write("nodescript");
    },
    httpparser() {
      return write("httpparser");
    },
    dataview() {
      return write("dataview");
    },
    signal() {
      return write("signal");
    },
    fsevent() {
      return write("fsevent");
    },
    tlswrap() {
      return write("tlswrap");
    }
  };
}
const nativeFunc = "[native code] }";
const nativeFuncLength = nativeFunc.length;
function isNativeFunction$1(f2) {
  if (typeof f2 !== "function") {
    return false;
  }
  return Function.prototype.toString.call(f2).slice(-nativeFuncLength) === nativeFunc;
}
class WordArray {
  constructor(words, sigBytes) {
    words = this.words = words || [];
    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;
  }
  toString(encoder) {
    return (encoder || Hex).stringify(this);
  }
  concat(wordArray) {
    this.clamp();
    if (this.sigBytes % 4) {
      for (let i2 = 0; i2 < wordArray.sigBytes; i2++) {
        const thatByte = wordArray.words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
        this.words[this.sigBytes + i2 >>> 2] |= thatByte << 24 - (this.sigBytes + i2) % 4 * 8;
      }
    } else {
      for (let j2 = 0; j2 < wordArray.sigBytes; j2 += 4) {
        this.words[this.sigBytes + j2 >>> 2] = wordArray.words[j2 >>> 2];
      }
    }
    this.sigBytes += wordArray.sigBytes;
    return this;
  }
  clamp() {
    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;
    this.words.length = Math.ceil(this.sigBytes / 4);
  }
  clone() {
    return new WordArray([...this.words]);
  }
}
const Hex = {
  stringify(wordArray) {
    const hexChars = [];
    for (let i2 = 0; i2 < wordArray.sigBytes; i2++) {
      const bite = wordArray.words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));
    }
    return hexChars.join("");
  }
};
const Base64 = {
  stringify(wordArray) {
    const keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const base64Chars = [];
    for (let i2 = 0; i2 < wordArray.sigBytes; i2 += 3) {
      const byte1 = wordArray.words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
      const byte2 = wordArray.words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
      const byte3 = wordArray.words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
      const triplet = byte1 << 16 | byte2 << 8 | byte3;
      for (let j2 = 0; j2 < 4 && i2 * 8 + j2 * 6 < wordArray.sigBytes * 8; j2++) {
        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j2) & 63));
      }
    }
    return base64Chars.join("");
  }
};
const Latin1 = {
  parse(latin1Str) {
    const latin1StrLength = latin1Str.length;
    const words = [];
    for (let i2 = 0; i2 < latin1StrLength; i2++) {
      words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
    }
    return new WordArray(words, latin1StrLength);
  }
};
const Utf8 = {
  parse(utf8Str) {
    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  }
};
class BufferedBlockAlgorithm {
  constructor() {
    this._data = new WordArray();
    this._nDataBytes = 0;
    this._minBufferSize = 0;
    this.blockSize = 512 / 32;
  }
  reset() {
    this._data = new WordArray();
    this._nDataBytes = 0;
  }
  _append(data) {
    if (typeof data === "string") {
      data = Utf8.parse(data);
    }
    this._data.concat(data);
    this._nDataBytes += data.sigBytes;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _doProcessBlock(_dataWords, _offset) {
  }
  _process(doFlush) {
    let processedWords;
    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);
    if (doFlush) {
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }
    const nWordsReady = nBlocksReady * this.blockSize;
    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);
    if (nWordsReady) {
      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {
        this._doProcessBlock(this._data.words, offset);
      }
      processedWords = this._data.words.splice(0, nWordsReady);
      this._data.sigBytes -= nBytesReady;
    }
    return new WordArray(processedWords, nBytesReady);
  }
}
class Hasher extends BufferedBlockAlgorithm {
  update(messageUpdate) {
    this._append(messageUpdate);
    this._process();
    return this;
  }
  finalize(messageUpdate) {
    if (messageUpdate) {
      this._append(messageUpdate);
    }
  }
}
const H$1 = [
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
];
const K$1 = [
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
];
const W$1 = [];
class SHA256 extends Hasher {
  constructor() {
    super(...arguments);
    this._hash = new WordArray([...H$1]);
  }
  reset() {
    super.reset();
    this._hash = new WordArray([...H$1]);
  }
  _doProcessBlock(M2, offset) {
    const H2 = this._hash.words;
    let a2 = H2[0];
    let b2 = H2[1];
    let c2 = H2[2];
    let d2 = H2[3];
    let e2 = H2[4];
    let f2 = H2[5];
    let g2 = H2[6];
    let h2 = H2[7];
    for (let i2 = 0; i2 < 64; i2++) {
      if (i2 < 16) {
        W$1[i2] = M2[offset + i2] | 0;
      } else {
        const gamma0x = W$1[i2 - 15];
        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
        const gamma1x = W$1[i2 - 2];
        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
        W$1[i2] = gamma0 + W$1[i2 - 7] + gamma1 + W$1[i2 - 16];
      }
      const ch = e2 & f2 ^ ~e2 & g2;
      const maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
      const sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
      const sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
      const t1 = h2 + sigma1 + ch + K$1[i2] + W$1[i2];
      const t2 = sigma0 + maj;
      h2 = g2;
      g2 = f2;
      f2 = e2;
      e2 = d2 + t1 | 0;
      d2 = c2;
      c2 = b2;
      b2 = a2;
      a2 = t1 + t2 | 0;
    }
    H2[0] = H2[0] + a2 | 0;
    H2[1] = H2[1] + b2 | 0;
    H2[2] = H2[2] + c2 | 0;
    H2[3] = H2[3] + d2 | 0;
    H2[4] = H2[4] + e2 | 0;
    H2[5] = H2[5] + f2 | 0;
    H2[6] = H2[6] + g2 | 0;
    H2[7] = H2[7] + h2 | 0;
  }
  finalize(messageUpdate) {
    super.finalize(messageUpdate);
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = this._data.sigBytes * 8;
    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(
      nBitsTotal / 4294967296
    );
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
    this._data.sigBytes = this._data.words.length * 4;
    this._process();
    return this._hash;
  }
}
function sha256(message) {
  return new SHA256().finalize(message).toString();
}
function sha256base64(message) {
  return new SHA256().finalize(message).toString(Base64);
}
function hash(object2, options2 = {}) {
  const hashed = typeof object2 === "string" ? object2 : objectHash(object2, options2);
  return sha256base64(hashed).slice(0, 10);
}
function murmurHash(key, seed = 0) {
  if (typeof key === "string") {
    key = createBuffer(key);
  }
  let i2 = 0;
  let h1 = seed;
  let k1;
  let h1b;
  const remainder = key.length & 3;
  const bytes = key.length - remainder;
  const c1 = 3432918353;
  const c2 = 461845907;
  while (i2 < bytes) {
    k1 = key[i2] & 255 | (key[++i2] & 255) << 8 | (key[++i2] & 255) << 16 | (key[++i2] & 255) << 24;
    ++i2;
    k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
    h1 ^= k1;
    h1 = h1 << 13 | h1 >>> 19;
    h1b = (h1 & 65535) * 5 + (((h1 >>> 16) * 5 & 65535) << 16) & 4294967295;
    h1 = (h1b & 65535) + 27492 + (((h1b >>> 16) + 58964 & 65535) << 16);
  }
  k1 = 0;
  switch (remainder) {
    case 3: {
      k1 ^= (key[i2 + 2] & 255) << 16;
      break;
    }
    case 2: {
      k1 ^= (key[i2 + 1] & 255) << 8;
      break;
    }
    case 1: {
      k1 ^= key[i2] & 255;
      k1 = (k1 & 65535) * c1 + (((k1 >>> 16) * c1 & 65535) << 16) & 4294967295;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 65535) * c2 + (((k1 >>> 16) * c2 & 65535) << 16) & 4294967295;
      h1 ^= k1;
    }
  }
  h1 ^= key.length;
  h1 ^= h1 >>> 16;
  h1 = (h1 & 65535) * 2246822507 + (((h1 >>> 16) * 2246822507 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 13;
  h1 = (h1 & 65535) * 3266489909 + (((h1 >>> 16) * 3266489909 & 65535) << 16) & 4294967295;
  h1 ^= h1 >>> 16;
  return h1 >>> 0;
}
function createBuffer(val) {
  return new TextEncoder().encode(val);
}
function isEqual(object1, object2, hashOptions = {}) {
  if (object1 === object2) {
    return true;
  }
  if (objectHash(object1, hashOptions) === objectHash(object2, hashOptions)) {
    return true;
  }
  return false;
}
function diff(obj1, obj2, opts = {}) {
  const h1 = _toHashedObject(obj1, opts);
  const h2 = _toHashedObject(obj2, opts);
  return _diff(h1, h2, opts);
}
function _diff(h1, h2, opts = {}) {
  const diffs = [];
  const allProps = /* @__PURE__ */ new Set([
    ...Object.keys(h1.props || {}),
    ...Object.keys(h2.props || {})
  ]);
  if (h1.props && h2.props) {
    for (const prop of allProps) {
      const p1 = h1.props[prop];
      const p2 = h2.props[prop];
      if (p1 && p2) {
        diffs.push(..._diff(h1.props?.[prop], h2.props?.[prop], opts));
      } else if (p1 || p2) {
        diffs.push(
          new DiffEntry((p2 || p1).key, p1 ? "removed" : "added", p2, p1)
        );
      }
    }
  }
  if (allProps.size === 0 && h1.hash !== h2.hash) {
    diffs.push(new DiffEntry((h2 || h1).key, "changed", h2, h1));
  }
  return diffs;
}
function _toHashedObject(obj, opts, key = "") {
  if (obj && typeof obj !== "object") {
    return new DiffHashedObject(key, obj, objectHash(obj, opts));
  }
  const props = {};
  const hashes = [];
  for (const _key in obj) {
    props[_key] = _toHashedObject(
      obj[_key],
      opts,
      key ? `${key}.${_key}` : _key
    );
    hashes.push(props[_key].hash);
  }
  return new DiffHashedObject(key, obj, `{${hashes.join(":")}}`, props);
}
class DiffEntry {
  // eslint-disable-next-line no-useless-constructor
  constructor(key, type2, newValue, oldValue) {
    this.key = key;
    this.type = type2;
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
  toString() {
    return this.toJSON();
  }
  toJSON() {
    switch (this.type) {
      case "added": {
        return `Added   \`${this.key}\``;
      }
      case "removed": {
        return `Removed \`${this.key}\``;
      }
      case "changed": {
        return `Changed \`${this.key}\` from \`${this.oldValue?.toString() || "-"}\` to \`${this.newValue.toString()}\``;
      }
    }
  }
}
class DiffHashedObject {
  // eslint-disable-next-line no-useless-constructor
  constructor(key, value, hash2, props) {
    this.key = key;
    this.value = value;
    this.hash = hash2;
    this.props = props;
  }
  toString() {
    if (this.props) {
      return `{${Object.keys(this.props).join(",")}}`;
    } else {
      return JSON.stringify(this.value);
    }
  }
  toJSON() {
    const k2 = this.key || ".";
    if (this.props) {
      return `${k2}({${Object.keys(this.props).join(",")}})`;
    }
    return `${k2}(${this.value})`;
  }
}
dist$2.diff = diff;
dist$2.hash = hash;
dist$2.isEqual = isEqual;
dist$2.murmurHash = murmurHash;
dist$2.objectHash = objectHash;
dist$2.sha256 = sha256;
dist$2.sha256base64 = sha256base64;
Object.defineProperty(utilsHash, "__esModule", {
  value: true
});
utilsHash.defaultHashSha256 = defaultHashSha256;
var _ohash = dist$2;
function defaultHashSha256(input) {
  return (0, _ohash.sha256)(input);
}
var utilsPromise = {};
Object.defineProperty(utilsPromise, "__esModule", {
  value: true
});
utilsPromise.PROMISE_RESOLVE_VOID = utilsPromise.PROMISE_RESOLVE_TRUE = utilsPromise.PROMISE_RESOLVE_NULL = utilsPromise.PROMISE_RESOLVE_FALSE = void 0;
utilsPromise.nextTick = nextTick;
utilsPromise.promiseSeries = promiseSeries;
utilsPromise.promiseWait = promiseWait;
utilsPromise.requestIdleCallbackIfAvailable = requestIdleCallbackIfAvailable;
utilsPromise.requestIdlePromise = requestIdlePromise;
utilsPromise.toPromise = toPromise;
function nextTick() {
  return new Promise((res) => setTimeout(res, 0));
}
function promiseWait(ms = 0) {
  return new Promise((res) => setTimeout(res, ms));
}
function toPromise(maybePromise) {
  if (maybePromise && typeof maybePromise.then === "function") {
    return maybePromise;
  } else {
    return Promise.resolve(maybePromise);
  }
}
var PROMISE_RESOLVE_TRUE = Promise.resolve(true);
utilsPromise.PROMISE_RESOLVE_TRUE = PROMISE_RESOLVE_TRUE;
var PROMISE_RESOLVE_FALSE = Promise.resolve(false);
utilsPromise.PROMISE_RESOLVE_FALSE = PROMISE_RESOLVE_FALSE;
var PROMISE_RESOLVE_NULL = Promise.resolve(null);
utilsPromise.PROMISE_RESOLVE_NULL = PROMISE_RESOLVE_NULL;
var PROMISE_RESOLVE_VOID = Promise.resolve();
utilsPromise.PROMISE_RESOLVE_VOID = PROMISE_RESOLVE_VOID;
var idlePromiseQueue = PROMISE_RESOLVE_VOID;
function requestIdlePromise(timeout2 = void 0) {
  idlePromiseQueue = idlePromiseQueue.then(() => {
    if (typeof requestIdleCallback === "function") {
      return new Promise((res) => {
        requestIdleCallback(() => res(), {
          timeout: timeout2
        });
      });
    } else {
      return promiseWait(0);
    }
  });
  return idlePromiseQueue;
}
function requestIdleCallbackIfAvailable(fun) {
  if (typeof requestIdleCallback === "function") {
    requestIdleCallback(() => {
      fun();
    });
  }
}
function promiseSeries(tasks, initial) {
  return tasks.reduce((current, next) => current.then(next), Promise.resolve(initial));
}
var utilsString = {};
Object.defineProperty(utilsString, "__esModule", {
  value: true
});
utilsString.RANDOM_STRING = void 0;
utilsString.arrayBufferToString = arrayBufferToString;
utilsString.isFolderPath = isFolderPath;
utilsString.randomCouchString = randomCouchString;
utilsString.stringToArrayBuffer = stringToArrayBuffer;
utilsString.trimDots = trimDots;
utilsString.ucfirst = ucfirst;
function randomCouchString(length = 10) {
  var text = "";
  var possible = "abcdefghijklmnopqrstuvwxyz";
  for (var i2 = 0; i2 < length; i2++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
var RANDOM_STRING = "Fz7SZXPmYJujkzjY1rpXWvlWBqoGAfAX";
utilsString.RANDOM_STRING = RANDOM_STRING;
function ucfirst(str) {
  str += "";
  var f2 = str.charAt(0).toUpperCase();
  return f2 + str.substr(1);
}
function trimDots(str) {
  while (str.charAt(0) === ".") {
    str = str.substr(1);
  }
  while (str.slice(-1) === ".") {
    str = str.slice(0, -1);
  }
  return str;
}
function isFolderPath(name) {
  if (name.includes("/") || // unix
  name.includes("\\")) {
    return true;
  } else {
    return false;
  }
}
function arrayBufferToString(buf) {
  return String.fromCharCode.apply(null, new Uint16Array(buf));
}
function stringToArrayBuffer(str) {
  var buf = new ArrayBuffer(str.length * 2);
  var bufView = new Uint16Array(buf);
  for (var i2 = 0, strLen = str.length; i2 < strLen; i2++) {
    bufView[i2] = str.charCodeAt(i2);
  }
  return buf;
}
var utilsObjectDeepEqual = {};
Object.defineProperty(utilsObjectDeepEqual, "__esModule", {
  value: true
});
utilsObjectDeepEqual.deepEqual = deepEqual;
function deepEqual(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length;
    var i2;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!deepEqual(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    var keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys[i2];
      if (!deepEqual(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
var utilsObjectDotProp = {};
Object.defineProperty(utilsObjectDotProp, "__esModule", {
  value: true
});
utilsObjectDotProp.deepKeys = deepKeys;
utilsObjectDotProp.deleteProperty = deleteProperty;
utilsObjectDotProp.getProperty = getProperty;
utilsObjectDotProp.hasProperty = hasProperty;
utilsObjectDotProp.setProperty = setProperty;
var isObject$1 = (value) => {
  var type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
var disallowedKeys = /* @__PURE__ */ new Set(["__proto__", "prototype", "constructor"]);
var digits = new Set("0123456789");
function getPathSegments(path2) {
  var parts = [];
  var currentSegment = "";
  var currentPart = "start";
  var isIgnoring = false;
  for (var character of path2) {
    switch (character) {
      case "\\": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (isIgnoring) {
          currentSegment += character;
        }
        currentPart = "property";
        isIgnoring = !isIgnoring;
        break;
      }
      case ".": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "property";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character;
          break;
        }
        if (disallowedKeys.has(currentSegment)) {
          return [];
        }
        parts.push(currentSegment);
        currentSegment = "";
        currentPart = "property";
        break;
      }
      case "[": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "index";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character;
          break;
        }
        if (currentPart === "property") {
          if (disallowedKeys.has(currentSegment)) {
            return [];
          }
          parts.push(currentSegment);
          currentSegment = "";
        }
        currentPart = "index";
        break;
      }
      case "]": {
        if (currentPart === "index") {
          parts.push(Number.parseInt(currentSegment, 10));
          currentSegment = "";
          currentPart = "indexEnd";
          break;
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
      }
      default: {
        if (currentPart === "index" && !digits.has(character)) {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (currentPart === "start") {
          currentPart = "property";
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += "\\";
        }
        currentSegment += character;
      }
    }
  }
  if (isIgnoring) {
    currentSegment += "\\";
  }
  switch (currentPart) {
    case "property": {
      if (disallowedKeys.has(currentSegment)) {
        return [];
      }
      parts.push(currentSegment);
      break;
    }
    case "index": {
      throw new Error("Index was not closed");
    }
    case "start": {
      parts.push("");
      break;
    }
  }
  return parts;
}
function isStringIndex(object2, key) {
  if (typeof key !== "number" && Array.isArray(object2)) {
    var index = Number.parseInt(key, 10);
    return Number.isInteger(index) && object2[index] === object2[key];
  }
  return false;
}
function assertNotStringIndex(object2, key) {
  if (isStringIndex(object2, key)) {
    throw new Error("Cannot use string index");
  }
}
function getProperty(object2, path2, value) {
  if (Array.isArray(path2)) {
    path2 = path2.join(".");
  }
  if (!isObject$1(object2) || typeof path2 !== "string") {
    return value === void 0 ? object2 : value;
  }
  var pathArray = getPathSegments(path2);
  if (pathArray.length === 0) {
    return value;
  }
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    if (isStringIndex(object2, key)) {
      object2 = index === pathArray.length - 1 ? void 0 : null;
    } else {
      object2 = object2[key];
    }
    if (object2 === void 0 || object2 === null) {
      if (index !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object2 === void 0 ? value : object2;
}
function setProperty(object2, path2, value) {
  if (Array.isArray(path2)) {
    path2 = path2.join(".");
  }
  if (!isObject$1(object2) || typeof path2 !== "string") {
    return object2;
  }
  var root = object2;
  var pathArray = getPathSegments(path2);
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    assertNotStringIndex(object2, key);
    if (index === pathArray.length - 1) {
      object2[key] = value;
    } else if (!isObject$1(object2[key])) {
      object2[key] = typeof pathArray[index + 1] === "number" ? [] : {};
    }
    object2 = object2[key];
  }
  return root;
}
function deleteProperty(object2, path2) {
  if (!isObject$1(object2) || typeof path2 !== "string") {
    return false;
  }
  var pathArray = getPathSegments(path2);
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    assertNotStringIndex(object2, key);
    if (index === pathArray.length - 1) {
      delete object2[key];
      return true;
    }
    object2 = object2[key];
    if (!isObject$1(object2)) {
      return false;
    }
  }
}
function hasProperty(object2, path2) {
  if (!isObject$1(object2) || typeof path2 !== "string") {
    return false;
  }
  var pathArray = getPathSegments(path2);
  if (pathArray.length === 0) {
    return false;
  }
  for (var key of pathArray) {
    if (!isObject$1(object2) || !(key in object2) || isStringIndex(object2, key)) {
      return false;
    }
    object2 = object2[key];
  }
  return true;
}
function escapePath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return path2.replace(/[\\.[]/g, "\\$&");
}
function entries(value) {
  if (Array.isArray(value)) {
    return value.map((v2, index) => [index, v2]);
  }
  return Object.entries(value);
}
function stringifyPath(pathSegments) {
  var result = "";
  for (var [index, segment] of entries(pathSegments)) {
    if (typeof segment === "number") {
      result += "[" + segment + "]";
    } else {
      segment = escapePath(segment);
      result += index === 0 ? segment : "." + segment;
    }
  }
  return result;
}
function* deepKeysIterator(object2, currentPath = []) {
  if (!isObject$1(object2)) {
    if (currentPath.length > 0) {
      yield stringifyPath(currentPath);
    }
    return;
  }
  for (var [key, value] of entries(object2)) {
    yield* deepKeysIterator(value, [...currentPath, key]);
  }
}
function deepKeys(object2) {
  return [...deepKeysIterator(object2)];
}
var utilsObject = {};
Object.defineProperty(utilsObject, "__esModule", {
  value: true
});
utilsObject.clone = void 0;
utilsObject.deepFreeze = deepFreeze;
utilsObject.firstPropertyNameOfObject = firstPropertyNameOfObject;
utilsObject.firstPropertyValueOfObject = firstPropertyValueOfObject;
utilsObject.flatClone = flatClone;
utilsObject.flattenObject = flattenObject;
utilsObject.getFromObjectOrThrow = getFromObjectOrThrow;
utilsObject.objectPathMonad = objectPathMonad;
utilsObject.overwriteGetterForCaching = overwriteGetterForCaching;
utilsObject.sortObject = sortObject;
utilsObject.stringifyFilter = stringifyFilter;
function deepFreeze(o2) {
  Object.freeze(o2);
  Object.getOwnPropertyNames(o2).forEach(function(prop) {
    if (o2.hasOwnProperty(prop) && o2[prop] !== null && (typeof o2[prop] === "object" || typeof o2[prop] === "function") && !Object.isFrozen(o2[prop])) {
      deepFreeze(o2[prop]);
    }
  });
  return o2;
}
function objectPathMonad(objectPath) {
  var split2 = objectPath.split(".");
  var splitLength = split2.length;
  if (splitLength === 1) {
    return (obj) => obj[objectPath];
  }
  return (obj) => {
    var currentVal = obj;
    for (var i2 = 0; i2 < splitLength; ++i2) {
      var subPath = split2[i2];
      currentVal = currentVal[subPath];
      if (typeof currentVal === "undefined") {
        return currentVal;
      }
    }
    return currentVal;
  };
}
function getFromObjectOrThrow(obj, key) {
  var val = obj[key];
  if (!val) {
    throw new Error("missing value from object " + key);
  }
  return val;
}
function flattenObject(ob) {
  var toReturn = {};
  for (var i2 in ob) {
    if (!ob.hasOwnProperty(i2))
      continue;
    if (typeof ob[i2] === "object") {
      var flatObject = flattenObject(ob[i2]);
      for (var x2 in flatObject) {
        if (!flatObject.hasOwnProperty(x2))
          continue;
        toReturn[i2 + "." + x2] = flatObject[x2];
      }
    } else {
      toReturn[i2] = ob[i2];
    }
  }
  return toReturn;
}
function flatClone(obj) {
  return Object.assign({}, obj);
}
function firstPropertyNameOfObject(obj) {
  return Object.keys(obj)[0];
}
function firstPropertyValueOfObject(obj) {
  var key = Object.keys(obj)[0];
  return obj[key];
}
function sortObject(obj, noArraySort = false) {
  if (!obj)
    return obj;
  if (!noArraySort && Array.isArray(obj)) {
    return obj.sort((a2, b2) => {
      if (typeof a2 === "string" && typeof b2 === "string")
        return a2.localeCompare(b2);
      if (typeof a2 === "object")
        return 1;
      else
        return -1;
    }).map((i2) => sortObject(i2, noArraySort));
  }
  if (typeof obj === "object" && !Array.isArray(obj)) {
    if (obj instanceof RegExp) {
      return obj;
    }
    var out2 = {};
    Object.keys(obj).sort((a2, b2) => a2.localeCompare(b2)).forEach((key) => {
      out2[key] = sortObject(obj[key], noArraySort);
    });
    return out2;
  }
  return obj;
}
function deepClone(src2) {
  if (!src2) {
    return src2;
  }
  if (src2 === null || typeof src2 !== "object") {
    return src2;
  }
  if (Array.isArray(src2)) {
    var ret = new Array(src2.length);
    var i2 = ret.length;
    while (i2--) {
      ret[i2] = deepClone(src2[i2]);
    }
    return ret;
  }
  var dest = {};
  for (var key in src2) {
    dest[key] = deepClone(src2[key]);
  }
  return dest;
}
var clone$1 = deepClone;
utilsObject.clone = clone$1;
function overwriteGetterForCaching(obj, getterName, value) {
  Object.defineProperty(obj, getterName, {
    get: function() {
      return value;
    }
  });
  return value;
}
function stringifyFilter(key, value) {
  if (value instanceof RegExp) {
    return value.toString();
  }
  return value;
}
var utilsMap = {};
Object.defineProperty(utilsMap, "__esModule", {
  value: true
});
utilsMap.getFromMapOrCreate = getFromMapOrCreate;
utilsMap.getFromMapOrThrow = getFromMapOrThrow;
function getFromMapOrThrow(map2, key) {
  var val = map2.get(key);
  if (typeof val === "undefined") {
    throw new Error("missing value from map " + key);
  }
  return val;
}
function getFromMapOrCreate(map2, index, creator, ifWasThere) {
  var value = map2.get(index);
  if (typeof value === "undefined") {
    value = creator();
    map2.set(index, value);
  } else if (ifWasThere) {
    ifWasThere(value);
  }
  return value;
}
var utilsError = {};
Object.defineProperty(utilsError, "__esModule", {
  value: true
});
utilsError.errorToPlainJson = errorToPlainJson;
utilsError.pluginMissing = pluginMissing;
var _utilsString = utilsString;
function pluginMissing(pluginKey) {
  var keyParts = pluginKey.split("-");
  var pluginName = "RxDB";
  keyParts.forEach((part) => {
    pluginName += (0, _utilsString.ucfirst)(part);
  });
  pluginName += "Plugin";
  return new Error("You are using a function which must be overwritten by a plugin.\n        You should either prevent the usage of this function or add the plugin via:\n            import { " + pluginName + " } from 'rxdb/plugins/" + pluginKey + "';\n            addRxPlugin(" + pluginName + ");\n        ");
}
function errorToPlainJson(err) {
  var ret = {
    name: err.name,
    message: err.message,
    rxdb: err.rxdb,
    parameters: err.parameters,
    code: err.code,
    /**
     * stack must be last to make it easier to read the json in a console.
     * Also we ensure that each linebreak is spaced so that the chrome devtools
     * shows urls to the source code that can be clicked to inspect
     * the correct place in the code.
     */
    stack: !err.stack ? void 0 : err.stack.replaceAll("\n", " \n ")
  };
  return ret;
}
var utilsTime = {};
Object.defineProperty(utilsTime, "__esModule", {
  value: true
});
utilsTime.now = now$2;
var _lastNow = 0;
function now$2() {
  var ret = (/* @__PURE__ */ new Date()).getTime();
  ret = ret + 0.01;
  if (ret <= _lastNow) {
    ret = _lastNow + 0.01;
  }
  var twoDecimals = parseFloat(ret.toFixed(2));
  _lastNow = twoDecimals;
  return twoDecimals;
}
var utilsRegex = {};
var utilsOther = {};
Object.defineProperty(utilsOther, "__esModule", {
  value: true
});
utilsOther.RXJS_SHARE_REPLAY_DEFAULTS = void 0;
utilsOther.ensureInteger = ensureInteger;
utilsOther.ensureNotFalsy = ensureNotFalsy;
utilsOther.runXTimes = runXTimes;
function runXTimes(xTimes, fn2) {
  new Array(xTimes).fill(0).forEach((_v, idx) => fn2(idx));
}
function ensureNotFalsy(obj) {
  if (!obj) {
    throw new Error("ensureNotFalsy() is falsy");
  }
  return obj;
}
function ensureInteger(obj) {
  if (!Number.isInteger(obj)) {
    throw new Error("ensureInteger() is falsy");
  }
  return obj;
}
var RXJS_SHARE_REPLAY_DEFAULTS = {
  bufferSize: 1,
  refCount: true
};
utilsOther.RXJS_SHARE_REPLAY_DEFAULTS = RXJS_SHARE_REPLAY_DEFAULTS;
Object.defineProperty(utilsRegex, "__esModule", {
  value: true
});
utilsRegex.REGEX_PARSE_REGEX_EXPRESSION = utilsRegex.REGEX_ALL_PIPES = utilsRegex.REGEX_ALL_DOTS = void 0;
utilsRegex.parseRegex = parseRegex;
var _utilsOther = utilsOther;
var REGEX_ALL_DOTS = /\./g;
utilsRegex.REGEX_ALL_DOTS = REGEX_ALL_DOTS;
var REGEX_ALL_PIPES = /\|/g;
utilsRegex.REGEX_ALL_PIPES = REGEX_ALL_PIPES;
var REGEX_PARSE_REGEX_EXPRESSION = /(\/?)(.+)\1([a-z]*)/i;
utilsRegex.REGEX_PARSE_REGEX_EXPRESSION = REGEX_PARSE_REGEX_EXPRESSION;
function parseRegex(regex2) {
  var matches = (0, _utilsOther.ensureNotFalsy)(regex2.toString().match(REGEX_PARSE_REGEX_EXPRESSION));
  return {
    pattern: matches[2],
    flags: matches[3]
  };
}
var utilsRxdbVersion = {};
Object.defineProperty(utilsRxdbVersion, "__esModule", {
  value: true
});
utilsRxdbVersion.RXDB_VERSION = void 0;
var RXDB_VERSION = "14.17.1";
utilsRxdbVersion.RXDB_VERSION = RXDB_VERSION;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _utilsArray = utilsArray;
  Object.keys(_utilsArray).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsArray[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsArray[key];
      }
    });
  });
  var _utilsBlob = utilsBlob;
  Object.keys(_utilsBlob).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsBlob[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsBlob[key];
      }
    });
  });
  var _utilsBase2 = utilsBase64;
  Object.keys(_utilsBase2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsBase2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsBase2[key];
      }
    });
  });
  var _utilsRevision = utilsRevision;
  Object.keys(_utilsRevision).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsRevision[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsRevision[key];
      }
    });
  });
  var _utilsDocument = utilsDocument;
  Object.keys(_utilsDocument).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsDocument[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsDocument[key];
      }
    });
  });
  var _utilsHash = utilsHash;
  Object.keys(_utilsHash).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsHash[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsHash[key];
      }
    });
  });
  var _utilsPromise = utilsPromise;
  Object.keys(_utilsPromise).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsPromise[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsPromise[key];
      }
    });
  });
  var _utilsString2 = utilsString;
  Object.keys(_utilsString2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsString2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsString2[key];
      }
    });
  });
  var _utilsObjectDeepEqual = utilsObjectDeepEqual;
  Object.keys(_utilsObjectDeepEqual).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsObjectDeepEqual[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsObjectDeepEqual[key];
      }
    });
  });
  var _utilsObjectDotProp = utilsObjectDotProp;
  Object.keys(_utilsObjectDotProp).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsObjectDotProp[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsObjectDotProp[key];
      }
    });
  });
  var _utilsObject = utilsObject;
  Object.keys(_utilsObject).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsObject[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsObject[key];
      }
    });
  });
  var _utilsMap = utilsMap;
  Object.keys(_utilsMap).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsMap[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsMap[key];
      }
    });
  });
  var _utilsError = utilsError;
  Object.keys(_utilsError).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsError[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsError[key];
      }
    });
  });
  var _utilsTime = utilsTime;
  Object.keys(_utilsTime).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsTime[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsTime[key];
      }
    });
  });
  var _utilsRegex = utilsRegex;
  Object.keys(_utilsRegex).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsRegex[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsRegex[key];
      }
    });
  });
  var _utilsOther2 = utilsOther;
  Object.keys(_utilsOther2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsOther2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsOther2[key];
      }
    });
  });
  var _utilsRxdbVersion = utilsRxdbVersion;
  Object.keys(_utilsRxdbVersion).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _utilsRxdbVersion[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utilsRxdbVersion[key];
      }
    });
  });
})(utils);
var messageChannelCache = {};
Object.defineProperty(messageChannelCache, "__esModule", {
  value: true
});
messageChannelCache.OPEN_REMOTE_MESSAGE_CHANNELS = messageChannelCache.MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER = messageChannelCache.CACHE_ITEM_BY_MESSAGE_CHANNEL = void 0;
messageChannelCache.closeMessageChannel = closeMessageChannel;
messageChannelCache.getMessageChannel = getMessageChannel;
var _utils$t = utils;
var MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER = /* @__PURE__ */ new Map();
messageChannelCache.MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER = MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER;
var CACHE_ITEM_BY_MESSAGE_CHANNEL = /* @__PURE__ */ new WeakMap();
messageChannelCache.CACHE_ITEM_BY_MESSAGE_CHANNEL = CACHE_ITEM_BY_MESSAGE_CHANNEL;
var OPEN_REMOTE_MESSAGE_CHANNELS = /* @__PURE__ */ new Set();
messageChannelCache.OPEN_REMOTE_MESSAGE_CHANNELS = OPEN_REMOTE_MESSAGE_CHANNELS;
function getMessageChannelCache(identifier) {
  return (0, _utils$t.getFromMapOrCreate)(MESSAGE_CHANNEL_CACHE_BY_IDENTIFIER, identifier, () => /* @__PURE__ */ new Map());
}
function getMessageChannel(settings, cacheKeys, keepAlive = false) {
  var cacheKey = getCacheKey(settings, cacheKeys);
  var cacheItem = (0, _utils$t.getFromMapOrCreate)(getMessageChannelCache(settings.identifier), cacheKey, () => {
    var newCacheItem = {
      identifier: settings.identifier,
      cacheKey,
      keepAlive,
      refCount: 1,
      messageChannel: settings.messageChannelCreator().then((messageChannel) => {
        OPEN_REMOTE_MESSAGE_CHANNELS.add(messageChannel);
        CACHE_ITEM_BY_MESSAGE_CHANNEL.set(messageChannel, newCacheItem);
        return messageChannel;
      })
    };
    return newCacheItem;
  }, (existingCacheItem) => {
    existingCacheItem.refCount = existingCacheItem.refCount + 1;
  });
  return cacheItem.messageChannel;
}
function closeMessageChannel(messageChannel) {
  var cacheItem = (0, _utils$t.getFromMapOrThrow)(CACHE_ITEM_BY_MESSAGE_CHANNEL, messageChannel);
  cacheItem.refCount = cacheItem.refCount - 1;
  if (cacheItem.refCount === 0 && !cacheItem.keepAlive) {
    getMessageChannelCache(cacheItem.identifier).delete(cacheItem.cacheKey);
    OPEN_REMOTE_MESSAGE_CHANNELS.delete(messageChannel);
    return messageChannel.close();
  } else {
    return _utils$t.PROMISE_RESOLVE_VOID;
  }
}
function getCacheKey(settings, cacheKeys) {
  cacheKeys = cacheKeys.slice(0);
  cacheKeys.unshift(settings.identifier);
  return cacheKeys.join("||");
}
var rxStorageHelper = {};
var overwritable$1 = {};
Object.defineProperty(overwritable$1, "__esModule", {
  value: true
});
overwritable$1.overwritable = void 0;
var overwritable = {
  /**
   * if this method is overwritten with one
   * that returns true, we do additional checks
   * which help the developer but have bad performance
   */
  isDevMode() {
    return false;
  },
  /**
   * Deep freezes and object when in dev-mode.
   * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.
   * Also, we can ensure the readonly state via typescript
   * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
   */
  deepFreezeWhenDevMode(obj) {
    return obj;
  },
  /**
   * overwritten to map error-codes to text-messages
   */
  tunnelErrorMessage(message) {
    return "RxDB Error-Code " + message + ".\n        Error messages are not included in RxDB core to reduce build size.\n        - To find out what this error means, either use the dev-mode-plugin https://rxdb.info/dev-mode.html\n        - or search for the error code here: https://github.com/pubkey/rxdb/search?q=" + message + "\n        ";
  }
};
overwritable$1.overwritable = overwritable;
var rxError = {};
var interopRequireDefault$1 = { exports: {} };
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault$1);
var interopRequireDefaultExports$1 = interopRequireDefault$1.exports;
var createClass = { exports: {} };
var toPropertyKey = { exports: {} };
var _typeof$2 = { exports: {} };
var hasRequired_typeof;
function require_typeof() {
  if (hasRequired_typeof)
    return _typeof$2.exports;
  hasRequired_typeof = 1;
  (function(module) {
    function _typeof2(o2) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o2);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof$2);
  return _typeof$2.exports;
}
var toPrimitive = { exports: {} };
var hasRequiredToPrimitive;
function requireToPrimitive() {
  if (hasRequiredToPrimitive)
    return toPrimitive.exports;
  hasRequiredToPrimitive = 1;
  (function(module) {
    var _typeof2 = require_typeof()["default"];
    function _toPrimitive(input, hint) {
      if (_typeof2(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof2(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(toPrimitive);
  return toPrimitive.exports;
}
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  if (hasRequiredToPropertyKey)
    return toPropertyKey.exports;
  hasRequiredToPropertyKey = 1;
  (function(module) {
    var _typeof2 = require_typeof()["default"];
    var toPrimitive2 = requireToPrimitive();
    function _toPropertyKey(arg) {
      var key = toPrimitive2(arg, "string");
      return _typeof2(key) === "symbol" ? key : String(key);
    }
    module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(toPropertyKey);
  return toPropertyKey.exports;
}
var hasRequiredCreateClass;
function requireCreateClass() {
  if (hasRequiredCreateClass)
    return createClass.exports;
  hasRequiredCreateClass = 1;
  (function(module) {
    var toPropertyKey2 = requireToPropertyKey();
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey2(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(createClass);
  return createClass.exports;
}
var inheritsLoose = { exports: {} };
var setPrototypeOf = { exports: {} };
var hasRequiredSetPrototypeOf;
function requireSetPrototypeOf() {
  if (hasRequiredSetPrototypeOf)
    return setPrototypeOf.exports;
  hasRequiredSetPrototypeOf = 1;
  (function(module) {
    function _setPrototypeOf(o2, p2) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _setPrototypeOf(o2, p2);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(setPrototypeOf);
  return setPrototypeOf.exports;
}
var hasRequiredInheritsLoose;
function requireInheritsLoose() {
  if (hasRequiredInheritsLoose)
    return inheritsLoose.exports;
  hasRequiredInheritsLoose = 1;
  (function(module) {
    var setPrototypeOf2 = requireSetPrototypeOf();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      setPrototypeOf2(subClass, superClass);
    }
    module.exports = _inheritsLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(inheritsLoose);
  return inheritsLoose.exports;
}
var wrapNativeSuper = { exports: {} };
var getPrototypeOf = { exports: {} };
var hasRequiredGetPrototypeOf;
function requireGetPrototypeOf() {
  if (hasRequiredGetPrototypeOf)
    return getPrototypeOf.exports;
  hasRequiredGetPrototypeOf = 1;
  (function(module) {
    function _getPrototypeOf(o2) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _getPrototypeOf(o2);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(getPrototypeOf);
  return getPrototypeOf.exports;
}
var isNativeFunction = { exports: {} };
var hasRequiredIsNativeFunction;
function requireIsNativeFunction() {
  if (hasRequiredIsNativeFunction)
    return isNativeFunction.exports;
  hasRequiredIsNativeFunction = 1;
  (function(module) {
    function _isNativeFunction(fn2) {
      return Function.toString.call(fn2).indexOf("[native code]") !== -1;
    }
    module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(isNativeFunction);
  return isNativeFunction.exports;
}
var construct = { exports: {} };
var isNativeReflectConstruct = { exports: {} };
var hasRequiredIsNativeReflectConstruct;
function requireIsNativeReflectConstruct() {
  if (hasRequiredIsNativeReflectConstruct)
    return isNativeReflectConstruct.exports;
  hasRequiredIsNativeReflectConstruct = 1;
  (function(module) {
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(isNativeReflectConstruct);
  return isNativeReflectConstruct.exports;
}
var hasRequiredConstruct;
function requireConstruct() {
  if (hasRequiredConstruct)
    return construct.exports;
  hasRequiredConstruct = 1;
  (function(module) {
    var setPrototypeOf2 = requireSetPrototypeOf();
    var isNativeReflectConstruct2 = requireIsNativeReflectConstruct();
    function _construct(Parent, args2, Class) {
      if (isNativeReflectConstruct2()) {
        module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
      } else {
        module.exports = _construct = function _construct2(Parent2, args3, Class2) {
          var a2 = [null];
          a2.push.apply(a2, args3);
          var Constructor = Function.bind.apply(Parent2, a2);
          var instance = new Constructor();
          if (Class2)
            setPrototypeOf2(instance, Class2.prototype);
          return instance;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      }
      return _construct.apply(null, arguments);
    }
    module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(construct);
  return construct.exports;
}
var hasRequiredWrapNativeSuper;
function requireWrapNativeSuper() {
  if (hasRequiredWrapNativeSuper)
    return wrapNativeSuper.exports;
  hasRequiredWrapNativeSuper = 1;
  (function(module) {
    var getPrototypeOf2 = requireGetPrototypeOf();
    var setPrototypeOf2 = requireSetPrototypeOf();
    var isNativeFunction2 = requireIsNativeFunction();
    var construct2 = requireConstruct();
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      module.exports = _wrapNativeSuper = function _wrapNativeSuper3(Class2) {
        if (Class2 === null || !isNativeFunction2(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return construct2(Class2, arguments, getPrototypeOf2(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return setPrototypeOf2(Wrapper, Class2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _wrapNativeSuper(Class);
    }
    module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(wrapNativeSuper);
  return wrapNativeSuper.exports;
}
var _interopRequireDefault$6 = interopRequireDefaultExports$1;
Object.defineProperty(rxError, "__esModule", {
  value: true
});
rxError.RxTypeError = rxError.RxError = void 0;
rxError.isBulkWriteConflictError = isBulkWriteConflictError;
rxError.newRxError = newRxError;
rxError.newRxTypeError = newRxTypeError;
rxError.rxStorageWriteErrorToRxError = rxStorageWriteErrorToRxError;
var _createClass2$4 = _interopRequireDefault$6(requireCreateClass());
var _inheritsLoose2 = _interopRequireDefault$6(requireInheritsLoose());
var _wrapNativeSuper2 = _interopRequireDefault$6(requireWrapNativeSuper());
var _overwritable$9 = overwritable$1;
function parametersToString(parameters) {
  var ret = "";
  if (Object.keys(parameters).length === 0)
    return ret;
  ret += "Given parameters: {\n";
  ret += Object.keys(parameters).map((k2) => {
    var paramStr = "[object Object]";
    try {
      if (k2 === "errors") {
        paramStr = parameters[k2].map((err) => JSON.stringify(err, Object.getOwnPropertyNames(err)));
      } else {
        paramStr = JSON.stringify(parameters[k2], function(_k, v2) {
          return v2 === void 0 ? null : v2;
        }, 2);
      }
    } catch (e2) {
    }
    return k2 + ":" + paramStr;
  }).join("\n");
  ret += "}";
  return ret;
}
function messageForError(message, code, parameters) {
  return "RxError (" + code + "):\n" + message + "\n" + parametersToString(parameters);
}
var RxError = /* @__PURE__ */ function(_Error) {
  (0, _inheritsLoose2.default)(RxError2, _Error);
  function RxError2(code, message, parameters = {}) {
    var _this;
    var mes = messageForError(message, code, parameters);
    _this = _Error.call(this, mes) || this;
    _this.code = code;
    _this.message = mes;
    _this.parameters = parameters;
    _this.rxdb = true;
    return _this;
  }
  var _proto = RxError2.prototype;
  _proto.toString = function toString2() {
    return this.message;
  };
  (0, _createClass2$4.default)(RxError2, [{
    key: "name",
    get: function() {
      return "RxError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return false;
    }
  }]);
  return RxError2;
}(/* @__PURE__ */ (0, _wrapNativeSuper2.default)(Error));
rxError.RxError = RxError;
var RxTypeError = /* @__PURE__ */ function(_TypeError) {
  (0, _inheritsLoose2.default)(RxTypeError2, _TypeError);
  function RxTypeError2(code, message, parameters = {}) {
    var _this2;
    var mes = messageForError(message, code, parameters);
    _this2 = _TypeError.call(this, mes) || this;
    _this2.code = code;
    _this2.message = mes;
    _this2.parameters = parameters;
    _this2.rxdb = true;
    return _this2;
  }
  var _proto2 = RxTypeError2.prototype;
  _proto2.toString = function toString2() {
    return this.message;
  };
  (0, _createClass2$4.default)(RxTypeError2, [{
    key: "name",
    get: function() {
      return "RxTypeError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return true;
    }
  }]);
  return RxTypeError2;
}(/* @__PURE__ */ (0, _wrapNativeSuper2.default)(TypeError));
rxError.RxTypeError = RxTypeError;
function newRxError(code, parameters) {
  return new RxError(code, _overwritable$9.overwritable.tunnelErrorMessage(code), parameters);
}
function newRxTypeError(code, parameters) {
  return new RxTypeError(code, _overwritable$9.overwritable.tunnelErrorMessage(code), parameters);
}
function isBulkWriteConflictError(err) {
  if (err && err.status === 409) {
    return err;
  } else {
    return false;
  }
}
var STORAGE_WRITE_ERROR_CODE_TO_MESSAGE = {
  409: "document write conflict",
  422: "schema validation error",
  510: "attachment data missing"
};
function rxStorageWriteErrorToRxError(err) {
  return newRxError("COL20", {
    name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],
    document: err.documentId,
    writeError: err
  });
}
var rxSchemaHelper = {};
Object.defineProperty(rxSchemaHelper, "__esModule", {
  value: true
});
rxSchemaHelper.RX_META_SCHEMA = rxSchemaHelper.DEFAULT_CHECKPOINT_SCHEMA = void 0;
rxSchemaHelper.fillObjectWithDefaults = fillObjectWithDefaults;
rxSchemaHelper.fillPrimaryKey = fillPrimaryKey;
rxSchemaHelper.fillWithDefaultSettings = fillWithDefaultSettings;
rxSchemaHelper.getComposedPrimaryKeyOfDocumentData = getComposedPrimaryKeyOfDocumentData;
rxSchemaHelper.getFinalFields = getFinalFields;
rxSchemaHelper.getLengthOfPrimaryKey = getLengthOfPrimaryKey;
rxSchemaHelper.getPrimaryFieldOfPrimaryKey = getPrimaryFieldOfPrimaryKey;
rxSchemaHelper.getPseudoSchemaForVersion = getPseudoSchemaForVersion;
rxSchemaHelper.getSchemaByObjectPath = getSchemaByObjectPath;
rxSchemaHelper.normalizeRxJsonSchema = normalizeRxJsonSchema;
var _rxError$f = rxError;
var _utils$s = utils;
function getPseudoSchemaForVersion(version, primaryKey) {
  var pseudoSchema = fillWithDefaultSettings({
    version,
    type: "object",
    primaryKey,
    properties: {
      [primaryKey]: {
        type: "string",
        maxLength: 100
      }
    },
    required: [primaryKey]
  });
  return pseudoSchema;
}
function getSchemaByObjectPath(rxJsonSchema, path2) {
  var usePath = path2;
  usePath = usePath.replace(_utils$s.REGEX_ALL_DOTS, ".properties.");
  usePath = "properties." + usePath;
  usePath = (0, _utils$s.trimDots)(usePath);
  var ret = (0, _utils$s.getProperty)(rxJsonSchema, usePath);
  return ret;
}
function fillPrimaryKey(primaryPath, jsonSchema2, documentData) {
  if (typeof jsonSchema2.primaryKey === "string") {
    return documentData;
  }
  var newPrimary = getComposedPrimaryKeyOfDocumentData(jsonSchema2, documentData);
  var existingPrimary = documentData[primaryPath];
  if (existingPrimary && existingPrimary !== newPrimary) {
    throw (0, _rxError$f.newRxError)("DOC19", {
      args: {
        documentData,
        existingPrimary,
        newPrimary
      },
      schema: jsonSchema2
    });
  }
  documentData[primaryPath] = newPrimary;
  return documentData;
}
function getPrimaryFieldOfPrimaryKey(primaryKey) {
  if (typeof primaryKey === "string") {
    return primaryKey;
  } else {
    return primaryKey.key;
  }
}
function getLengthOfPrimaryKey(schema) {
  var primaryPath = getPrimaryFieldOfPrimaryKey(schema.primaryKey);
  var schemaPart = getSchemaByObjectPath(schema, primaryPath);
  return (0, _utils$s.ensureNotFalsy)(schemaPart.maxLength);
}
function getComposedPrimaryKeyOfDocumentData(jsonSchema2, documentData) {
  if (typeof jsonSchema2.primaryKey === "string") {
    return documentData[jsonSchema2.primaryKey];
  }
  var compositePrimary = jsonSchema2.primaryKey;
  return compositePrimary.fields.map((field) => {
    var value = (0, _utils$s.getProperty)(documentData, field);
    if (typeof value === "undefined") {
      throw (0, _rxError$f.newRxError)("DOC18", {
        args: {
          field,
          documentData
        }
      });
    }
    return value;
  }).join(compositePrimary.separator);
}
function normalizeRxJsonSchema(jsonSchema2) {
  var normalizedSchema = (0, _utils$s.sortObject)(jsonSchema2, true);
  return normalizedSchema;
}
function fillWithDefaultSettings(schemaObj) {
  schemaObj = (0, _utils$s.flatClone)(schemaObj);
  var primaryPath = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);
  schemaObj.properties = (0, _utils$s.flatClone)(schemaObj.properties);
  schemaObj.additionalProperties = false;
  if (!schemaObj.hasOwnProperty("keyCompression")) {
    schemaObj.keyCompression = false;
  }
  schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];
  schemaObj.properties._rev = {
    type: "string",
    minLength: 1
  };
  schemaObj.properties._attachments = {
    type: "object"
  };
  schemaObj.properties._deleted = {
    type: "boolean"
  };
  schemaObj.properties._meta = RX_META_SCHEMA;
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.required.push("_deleted");
  schemaObj.required.push("_rev");
  schemaObj.required.push("_meta");
  schemaObj.required.push("_attachments");
  var finalFields = getFinalFields(schemaObj);
  (0, _utils$s.appendToArray)(schemaObj.required, finalFields);
  schemaObj.required = schemaObj.required.filter((field) => !field.includes(".")).filter((elem, pos, arr) => arr.indexOf(elem) === pos);
  schemaObj.version = schemaObj.version || 0;
  if (schemaObj.indexes) {
    schemaObj.indexes = schemaObj.indexes.map((index) => {
      var arIndex = (0, _utils$s.isMaybeReadonlyArray)(index) ? index.slice(0) : [index];
      if (!arIndex.includes(primaryPath)) {
        var modifiedIndex = arIndex.slice(0);
        modifiedIndex.push(primaryPath);
        return modifiedIndex;
      }
      return arIndex;
    });
  }
  return schemaObj;
}
var RX_META_SCHEMA = {
  type: "object",
  properties: {
    /**
     * The last-write time.
     * Unix time in milliseconds.
     */
    lwt: {
      type: "number",
      /**
       * We use 1 as minimum so that the value is never falsy.
       */
      minimum: _utils$s.RX_META_LWT_MINIMUM,
      maximum: 1e15,
      multipleOf: 0.01
    }
  },
  /**
   * Additional properties are allowed
   * and can be used by plugins to set various flags.
   */
  additionalProperties: true,
  required: ["lwt"]
};
rxSchemaHelper.RX_META_SCHEMA = RX_META_SCHEMA;
function getFinalFields(jsonSchema2) {
  var ret = Object.keys(jsonSchema2.properties).filter((key) => jsonSchema2.properties[key].final);
  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema2.primaryKey);
  ret.push(primaryPath);
  if (typeof jsonSchema2.primaryKey !== "string") {
    jsonSchema2.primaryKey.fields.forEach((field) => ret.push(field));
  }
  return ret;
}
function fillObjectWithDefaults(rxSchema2, obj) {
  var defaultKeys = Object.keys(rxSchema2.defaultValues);
  for (var i2 = 0; i2 < defaultKeys.length; ++i2) {
    var key = defaultKeys[i2];
    if (!obj.hasOwnProperty(key) || typeof obj[key] === "undefined") {
      obj[key] = rxSchema2.defaultValues[key];
    }
  }
  return obj;
}
var DEFAULT_CHECKPOINT_SCHEMA = {
  type: "object",
  properties: {
    id: {
      type: "string"
    },
    lwt: {
      type: "number"
    }
  },
  required: ["id", "lwt"],
  additionalProperties: false
};
rxSchemaHelper.DEFAULT_CHECKPOINT_SCHEMA = DEFAULT_CHECKPOINT_SCHEMA;
Object.defineProperty(rxStorageHelper, "__esModule", {
  value: true
});
rxStorageHelper.RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = rxStorageHelper.INTERNAL_STORAGE_NAME = void 0;
rxStorageHelper.attachmentWriteDataToNormalData = attachmentWriteDataToNormalData;
rxStorageHelper.categorizeBulkWriteRows = categorizeBulkWriteRows;
rxStorageHelper.ensureRxStorageInstanceParamsAreCorrect = ensureRxStorageInstanceParamsAreCorrect;
rxStorageHelper.flatCloneDocWithMeta = flatCloneDocWithMeta;
rxStorageHelper.getAttachmentSize = getAttachmentSize;
rxStorageHelper.getSingleDocument = getSingleDocument;
rxStorageHelper.getUniqueDeterministicEventKey = getUniqueDeterministicEventKey;
rxStorageHelper.getWrappedStorageInstance = getWrappedStorageInstance;
rxStorageHelper.hasEncryption = hasEncryption;
rxStorageHelper.stackCheckpoints = stackCheckpoints;
rxStorageHelper.storageChangeEventToRxChangeEvent = storageChangeEventToRxChangeEvent;
rxStorageHelper.stripAttachmentsDataFromDocument = stripAttachmentsDataFromDocument;
rxStorageHelper.stripAttachmentsDataFromRow = stripAttachmentsDataFromRow;
rxStorageHelper.throwIfIsStorageWriteError = throwIfIsStorageWriteError;
rxStorageHelper.writeSingle = writeSingle;
var _overwritable$8 = overwritable$1;
var _rxError$e = rxError;
var _rxSchemaHelper$d = rxSchemaHelper;
var _utils$r = utils;
var INTERNAL_STORAGE_NAME = "_rxdb_internal";
rxStorageHelper.INTERNAL_STORAGE_NAME = INTERNAL_STORAGE_NAME;
var RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = "rxdatabase_storage_local";
rxStorageHelper.RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = RX_DATABASE_LOCAL_DOCS_STORAGE_NAME;
async function getSingleDocument(storageInstance, documentId) {
  var results = await storageInstance.findDocumentsById([documentId], false);
  var doc = results[documentId];
  if (doc) {
    return doc;
  } else {
    return null;
  }
}
async function writeSingle(instance, writeRow, context2) {
  var writeResult = await instance.bulkWrite([writeRow], context2);
  if (Object.keys(writeResult.error).length > 0) {
    var error = (0, _utils$r.firstPropertyValueOfObject)(writeResult.error);
    throw error;
  } else {
    var ret = (0, _utils$r.firstPropertyValueOfObject)(writeResult.success);
    return ret;
  }
}
function stackCheckpoints(checkpoints) {
  return Object.assign({}, ...checkpoints);
}
function storageChangeEventToRxChangeEvent(isLocal, rxStorageChangeEvent, rxCollection2) {
  var documentData = rxStorageChangeEvent.documentData;
  var previousDocumentData = rxStorageChangeEvent.previousDocumentData;
  var ret = {
    eventId: rxStorageChangeEvent.eventId,
    documentId: rxStorageChangeEvent.documentId,
    collectionName: rxCollection2 ? rxCollection2.name : void 0,
    startTime: rxStorageChangeEvent.startTime,
    endTime: rxStorageChangeEvent.endTime,
    isLocal,
    operation: rxStorageChangeEvent.operation,
    documentData: _overwritable$8.overwritable.deepFreezeWhenDevMode(documentData),
    previousDocumentData: _overwritable$8.overwritable.deepFreezeWhenDevMode(previousDocumentData)
  };
  return ret;
}
function throwIfIsStorageWriteError(collection, documentId, writeData, error) {
  if (error) {
    if (error.status === 409) {
      throw (0, _rxError$e.newRxError)("CONFLICT", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else if (error.status === 422) {
      throw (0, _rxError$e.newRxError)("VD2", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else {
      throw error;
    }
  }
}
function categorizeBulkWriteRows(storageInstance, primaryPath, docsInDb, bulkWriteRows, context2) {
  var hasAttachments = !!storageInstance.schema.attachments;
  var bulkInsertDocs = [];
  var bulkUpdateDocs = [];
  var errors = {};
  var changeByDocId = /* @__PURE__ */ new Map();
  var eventBulkId = (0, _utils$r.randomCouchString)(10);
  var eventBulk = {
    id: eventBulkId,
    events: [],
    checkpoint: null,
    context: context2
  };
  var eventBulkEvents = eventBulk.events;
  var attachmentsAdd = [];
  var attachmentsRemove = [];
  var attachmentsUpdate = [];
  var startTime = (0, _utils$r.now)();
  var docsByIdIsMap = typeof docsInDb.get === "function";
  var hasDocsInDb = docsByIdIsMap ? docsInDb.size > 0 : Object.keys(docsInDb).length > 0;
  var newestRow;
  var rowAmount = bulkWriteRows.length;
  var _loop = function() {
    var writeRow = bulkWriteRows[rowId];
    var docId = writeRow.document[primaryPath];
    var documentInDb = false;
    if (hasDocsInDb) {
      documentInDb = docsByIdIsMap ? docsInDb.get(docId) : docsInDb[docId];
    }
    var attachmentError;
    if (!documentInDb) {
      var insertedIsDeleted = writeRow.document._deleted ? true : false;
      if (hasAttachments) {
        Object.entries(writeRow.document._attachments).forEach(([attachmentId, attachmentData]) => {
          if (!attachmentData.data) {
            attachmentError = {
              documentId: docId,
              isError: true,
              status: 510,
              writeRow,
              attachmentId
            };
            errors[docId] = attachmentError;
          } else {
            attachmentsAdd.push({
              documentId: docId,
              attachmentId,
              attachmentData,
              digest: (0, _utils$r.defaultHashSha256)(attachmentData.data)
            });
          }
        });
      }
      if (!attachmentError) {
        if (hasAttachments) {
          bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));
        } else {
          bulkInsertDocs.push(writeRow);
        }
        if (!newestRow || newestRow.document._meta.lwt < writeRow.document._meta.lwt) {
          newestRow = writeRow;
        }
      }
      if (!insertedIsDeleted) {
        var event = {
          eventId: getUniqueDeterministicEventKey(eventBulkId, rowId, docId, writeRow),
          documentId: docId,
          operation: "INSERT",
          documentData: hasAttachments ? stripAttachmentsDataFromDocument(writeRow.document) : writeRow.document,
          previousDocumentData: hasAttachments && writeRow.previous ? stripAttachmentsDataFromDocument(writeRow.previous) : writeRow.previous,
          startTime,
          endTime: (0, _utils$r.now)()
        };
        changeByDocId.set(docId, event);
        eventBulkEvents.push(event);
      }
    } else {
      var revInDb = documentInDb._rev;
      if (!writeRow.previous || !!writeRow.previous && revInDb !== writeRow.previous._rev) {
        var err = {
          isError: true,
          status: 409,
          documentId: docId,
          writeRow,
          documentInDb
        };
        errors[docId] = err;
        return 1;
      }
      var updatedRow = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow;
      if (hasAttachments) {
        if (writeRow.document._deleted) {
          if (writeRow.previous) {
            Object.keys(writeRow.previous._attachments).forEach((attachmentId) => {
              attachmentsRemove.push({
                documentId: docId,
                attachmentId,
                digest: (0, _utils$r.ensureNotFalsy)(writeRow.previous)._attachments[attachmentId].digest
              });
            });
          }
        } else {
          Object.entries(writeRow.document._attachments).find(([attachmentId, attachmentData]) => {
            var previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : void 0;
            if (!previousAttachmentData && !attachmentData.data) {
              attachmentError = {
                documentId: docId,
                documentInDb,
                isError: true,
                status: 510,
                writeRow,
                attachmentId
              };
            }
            return true;
          });
          if (!attachmentError) {
            Object.entries(writeRow.document._attachments).forEach(([attachmentId, attachmentData]) => {
              var previousAttachmentData = writeRow.previous ? writeRow.previous._attachments[attachmentId] : void 0;
              if (!previousAttachmentData) {
                attachmentsAdd.push({
                  documentId: docId,
                  attachmentId,
                  attachmentData,
                  digest: (0, _utils$r.defaultHashSha256)(attachmentData.data)
                });
              } else {
                var newDigest = updatedRow.document._attachments[attachmentId].digest;
                if (attachmentData.data && /**
                 * Performance shortcut,
                 * do not update the attachment data if it did not change.
                 */
                previousAttachmentData.digest !== newDigest) {
                  attachmentsUpdate.push({
                    documentId: docId,
                    attachmentId,
                    attachmentData,
                    digest: (0, _utils$r.defaultHashSha256)(attachmentData.data)
                  });
                }
              }
            });
          }
        }
      }
      if (attachmentError) {
        errors[docId] = attachmentError;
      } else {
        bulkUpdateDocs.push(updatedRow);
        if (!newestRow || newestRow.document._meta.lwt < updatedRow.document._meta.lwt) {
          newestRow = updatedRow;
        }
      }
      var writeDoc = writeRow.document;
      var eventDocumentData = null;
      var previousEventDocumentData = null;
      var operation = null;
      if (writeRow.previous && writeRow.previous._deleted && !writeDoc._deleted) {
        operation = "INSERT";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc;
      } else if (writeRow.previous && !writeRow.previous._deleted && !writeDoc._deleted) {
        operation = "UPDATE";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(writeDoc) : writeDoc;
        previousEventDocumentData = writeRow.previous;
      } else if (writeDoc._deleted) {
        operation = "DELETE";
        eventDocumentData = (0, _utils$r.ensureNotFalsy)(writeRow.document);
        previousEventDocumentData = writeRow.previous;
      } else {
        throw (0, _rxError$e.newRxError)("SNH", {
          args: {
            writeRow
          }
        });
      }
      var _event = {
        eventId: getUniqueDeterministicEventKey(eventBulkId, rowId, docId, writeRow),
        documentId: docId,
        documentData: eventDocumentData,
        previousDocumentData: previousEventDocumentData,
        operation,
        startTime,
        endTime: (0, _utils$r.now)()
      };
      changeByDocId.set(docId, _event);
      eventBulkEvents.push(_event);
    }
  };
  for (var rowId = 0; rowId < rowAmount; rowId++) {
    if (_loop())
      continue;
  }
  return {
    bulkInsertDocs,
    bulkUpdateDocs,
    newestRow,
    errors,
    changeByDocId,
    eventBulk,
    attachmentsAdd,
    attachmentsRemove,
    attachmentsUpdate
  };
}
function stripAttachmentsDataFromRow(writeRow) {
  return {
    previous: writeRow.previous,
    document: stripAttachmentsDataFromDocument(writeRow.document)
  };
}
function getAttachmentSize(attachmentBase64String) {
  return atob(attachmentBase64String).length;
}
function attachmentWriteDataToNormalData(writeData) {
  var data = writeData.data;
  if (!data) {
    return writeData;
  }
  var ret = {
    digest: (0, _utils$r.defaultHashSha256)(data),
    length: getAttachmentSize(data),
    type: writeData.type
  };
  return ret;
}
function stripAttachmentsDataFromDocument(doc) {
  var useDoc = (0, _utils$r.flatClone)(doc);
  useDoc._attachments = {};
  Object.entries(doc._attachments).forEach(([attachmentId, attachmentData]) => {
    useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);
  });
  return useDoc;
}
function flatCloneDocWithMeta(doc) {
  var ret = (0, _utils$r.flatClone)(doc);
  ret._meta = (0, _utils$r.flatClone)(doc._meta);
  return ret;
}
function getUniqueDeterministicEventKey(eventBulkId, rowId, docId, writeRow) {
  return eventBulkId + "|" + rowId + "|" + docId + "|" + writeRow.document._rev;
}
function getWrappedStorageInstance(database, storageInstance, rxJsonSchema) {
  _overwritable$8.overwritable.deepFreezeWhenDevMode(rxJsonSchema);
  var primaryPath = (0, _rxSchemaHelper$d.getPrimaryFieldOfPrimaryKey)(rxJsonSchema.primaryKey);
  function transformDocumentDataFromRxDBToRxStorage(writeRow) {
    var data = (0, _utils$r.flatClone)(writeRow.document);
    data._meta = (0, _utils$r.flatClone)(data._meta);
    if (_overwritable$8.overwritable.isDevMode()) {
      data = (0, _rxSchemaHelper$d.fillPrimaryKey)(primaryPath, rxJsonSchema, data);
      if (writeRow.previous)
        ;
      if (writeRow.previous) {
        Object.keys(writeRow.previous._meta).forEach((metaFieldName) => {
          if (!writeRow.document._meta.hasOwnProperty(metaFieldName)) {
            throw (0, _rxError$e.newRxError)("SNH", {
              dataBefore: writeRow.previous,
              dataAfter: writeRow.document
            });
          }
        });
      }
    }
    data._meta.lwt = (0, _utils$r.now)();
    data._rev = (0, _utils$r.createRevision)(database.token, writeRow.previous);
    return {
      document: data,
      previous: writeRow.previous
    };
  }
  var ret = {
    originalStorageInstance: storageInstance,
    schema: storageInstance.schema,
    internals: storageInstance.internals,
    collectionName: storageInstance.collectionName,
    databaseName: storageInstance.databaseName,
    options: storageInstance.options,
    bulkWrite(rows, context2) {
      var toStorageWriteRows = rows.map((row) => transformDocumentDataFromRxDBToRxStorage(row));
      return database.lockedRun(() => storageInstance.bulkWrite(toStorageWriteRows, context2)).then((writeResult) => {
        var reInsertErrors = Object.values(writeResult.error).filter((error) => {
          if (error.status === 409 && !error.writeRow.previous && !error.writeRow.document._deleted && (0, _utils$r.ensureNotFalsy)(error.documentInDb)._deleted) {
            return true;
          }
          return false;
        });
        if (reInsertErrors.length > 0) {
          var useWriteResult = {
            error: (0, _utils$r.flatClone)(writeResult.error),
            success: (0, _utils$r.flatClone)(writeResult.success)
          };
          var reInserts = reInsertErrors.map((error) => {
            delete useWriteResult.error[error.documentId];
            return {
              previous: error.documentInDb,
              document: Object.assign({}, error.writeRow.document, {
                _rev: (0, _utils$r.createRevision)(database.token, error.documentInDb)
              })
            };
          });
          return database.lockedRun(() => storageInstance.bulkWrite(reInserts, context2)).then((subResult) => {
            useWriteResult.error = Object.assign(useWriteResult.error, subResult.error);
            useWriteResult.success = Object.assign(useWriteResult.success, subResult.success);
            return useWriteResult;
          });
        }
        return writeResult;
      });
    },
    query(preparedQuery) {
      return database.lockedRun(() => storageInstance.query(preparedQuery));
    },
    count(preparedQuery) {
      return database.lockedRun(() => storageInstance.count(preparedQuery));
    },
    findDocumentsById(ids, deleted) {
      return database.lockedRun(() => storageInstance.findDocumentsById(ids, deleted));
    },
    getAttachmentData(documentId, attachmentId, digest) {
      return database.lockedRun(() => storageInstance.getAttachmentData(documentId, attachmentId, digest));
    },
    getChangedDocumentsSince(limit2, checkpoint2) {
      return database.lockedRun(() => storageInstance.getChangedDocumentsSince((0, _utils$r.ensureNotFalsy)(limit2), checkpoint2));
    },
    cleanup(minDeletedTime) {
      return database.lockedRun(() => storageInstance.cleanup(minDeletedTime));
    },
    remove() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.remove());
    },
    close() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.close());
    },
    changeStream() {
      return storageInstance.changeStream();
    },
    conflictResultionTasks() {
      return storageInstance.conflictResultionTasks();
    },
    resolveConflictResultionTask(taskSolution) {
      if (taskSolution.output.isEqual) {
        return storageInstance.resolveConflictResultionTask(taskSolution);
      }
      var doc = Object.assign({}, taskSolution.output.documentData, {
        _meta: (0, _utils$r.getDefaultRxDocumentMeta)(),
        _rev: (0, _utils$r.getDefaultRevision)(),
        _attachments: {}
      });
      var documentData = (0, _utils$r.flatClone)(doc);
      delete documentData._meta;
      delete documentData._rev;
      delete documentData._attachments;
      return storageInstance.resolveConflictResultionTask({
        id: taskSolution.id,
        output: {
          isEqual: false,
          documentData
        }
      });
    }
  };
  database.storageInstances.add(ret);
  return ret;
}
function ensureRxStorageInstanceParamsAreCorrect(params) {
  if (params.schema.keyCompression) {
    throw (0, _rxError$e.newRxError)("UT5", {
      args: {
        params
      }
    });
  }
  if (hasEncryption(params.schema)) {
    throw (0, _rxError$e.newRxError)("UT6", {
      args: {
        params
      }
    });
  }
  if (params.schema.attachments && params.schema.attachments.compression) {
    throw (0, _rxError$e.newRxError)("UT7", {
      args: {
        params
      }
    });
  }
}
function hasEncryption(jsonSchema2) {
  if (!!jsonSchema2.encrypted && jsonSchema2.encrypted.length > 0 || jsonSchema2.attachments && jsonSchema2.attachments.encrypted) {
    return true;
  } else {
    return false;
  }
}
Object.defineProperty(rxStorageRemote, "__esModule", {
  value: true
});
rxStorageRemote.RxStorageRemote = rxStorageRemote.RxStorageInstanceRemote = void 0;
rxStorageRemote.getRxStorageRemote = getRxStorageRemote;
var _rxjs$a = cjs;
var _utils$q = utils;
var _messageChannelCache = messageChannelCache;
var _rxStorageHelper$b = rxStorageHelper;
var RxStorageRemote = /* @__PURE__ */ function() {
  function RxStorageRemote2(settings) {
    this.name = "remote";
    this.seed = (0, _utils$q.randomCouchString)(10);
    this.lastRequestId = 0;
    this.settings = settings;
    this.statics = settings.statics;
    if (settings.mode === "one") {
      this.messageChannelIfOneMode = (0, _messageChannelCache.getMessageChannel)(settings, [], true);
    }
  }
  var _proto = RxStorageRemote2.prototype;
  _proto.getRequestId = function getRequestId() {
    var newId = this.lastRequestId++;
    return this.seed + "|" + newId;
  };
  _proto.createStorageInstance = async function createStorageInstance(params) {
    (0, _rxStorageHelper$b.ensureRxStorageInstanceParamsAreCorrect)(params);
    var connectionId = "c|" + this.getRequestId();
    var cacheKeys = ["mode-" + this.settings.mode];
    switch (this.settings.mode) {
      case "collection":
        cacheKeys.push("collection-" + params.collectionName);
      case "database":
        cacheKeys.push("database-" + params.databaseName);
      case "storage":
        cacheKeys.push("seed-" + this.seed);
    }
    var messageChannel = await (this.messageChannelIfOneMode ? this.messageChannelIfOneMode : (0, _messageChannelCache.getMessageChannel)(this.settings, cacheKeys));
    var requestId = this.getRequestId();
    var waitForOkPromise = (0, _rxjs$a.firstValueFrom)(messageChannel.messages$.pipe((0, _rxjs$a.filter)((msg) => msg.answerTo === requestId)));
    messageChannel.send({
      connectionId,
      method: "create",
      requestId,
      params
    });
    var waitForOkResult = await waitForOkPromise;
    if (waitForOkResult.error) {
      throw new Error("could not create instance " + JSON.stringify(waitForOkResult.error));
    }
    return new RxStorageInstanceRemote(this, params.databaseName, params.collectionName, params.schema, {
      params,
      connectionId,
      messageChannel
    }, params.options);
  };
  _proto.customRequest = async function customRequest(data) {
    var messageChannel = await this.settings.messageChannelCreator();
    var requestId = this.getRequestId();
    var connectionId = "custom|request|" + requestId;
    var waitForAnswerPromise = (0, _rxjs$a.firstValueFrom)(messageChannel.messages$.pipe((0, _rxjs$a.filter)((msg) => msg.answerTo === requestId)));
    messageChannel.send({
      connectionId,
      method: "custom",
      requestId,
      params: data
    });
    var response = await waitForAnswerPromise;
    if (response.error) {
      await messageChannel.close();
      throw new Error("could not run customRequest(): " + JSON.stringify({
        data,
        error: response.error
      }));
    } else {
      await messageChannel.close();
      return response.return;
    }
  };
  return RxStorageRemote2;
}();
rxStorageRemote.RxStorageRemote = RxStorageRemote;
function getMessageReturn(msg) {
  if (msg.method === "getAttachmentData") {
    return msg.return;
  } else {
    if (typeof msg.return === "string") {
      return JSON.parse(msg.return);
    } else {
      return msg.return;
    }
  }
}
var RxStorageInstanceRemote = /* @__PURE__ */ function() {
  function RxStorageInstanceRemote2(storage, databaseName, collectionName, schema, internals, options2) {
    this.changes$ = new _rxjs$a.Subject();
    this.conflicts$ = new _rxjs$a.Subject();
    this.subs = [];
    this.closed = false;
    this.storage = storage;
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.schema = schema;
    this.internals = internals;
    this.options = options2;
    this.messages$ = this.internals.messageChannel.messages$.pipe((0, _rxjs$a.filter)((msg) => msg.connectionId === this.internals.connectionId));
    this.subs.push(this.messages$.subscribe((msg) => {
      if (msg.method === "changeStream") {
        this.changes$.next(getMessageReturn(msg));
      }
      if (msg.method === "conflictResultionTasks") {
        this.conflicts$.next(msg.return);
      }
    }));
  }
  var _proto2 = RxStorageInstanceRemote2.prototype;
  _proto2.requestRemote = async function requestRemote(methodName, params) {
    var requestId = this.storage.getRequestId();
    var responsePromise = (0, _rxjs$a.firstValueFrom)(this.messages$.pipe((0, _rxjs$a.filter)((msg) => msg.answerTo === requestId)));
    var message = {
      connectionId: this.internals.connectionId,
      requestId,
      method: methodName,
      params
    };
    this.internals.messageChannel.send(message);
    var response = await responsePromise;
    if (response.error) {
      throw new Error("could not requestRemote: " + JSON.stringify({
        methodName,
        params,
        error: response.error
      }, null, 4));
    } else {
      return getMessageReturn(response);
    }
  };
  _proto2.bulkWrite = function bulkWrite(documentWrites, context2) {
    return this.requestRemote("bulkWrite", [documentWrites, context2]);
  };
  _proto2.findDocumentsById = function findDocumentsById(ids, deleted) {
    return this.requestRemote("findDocumentsById", [ids, deleted]);
  };
  _proto2.query = function query2(preparedQuery) {
    return this.requestRemote("query", [preparedQuery]);
  };
  _proto2.count = function count2(preparedQuery) {
    return this.requestRemote("count", [preparedQuery]);
  };
  _proto2.getAttachmentData = function getAttachmentData(documentId, attachmentId, digest) {
    return this.requestRemote("getAttachmentData", [documentId, attachmentId, digest]);
  };
  _proto2.getChangedDocumentsSince = function getChangedDocumentsSince(limit2, checkpoint2) {
    return this.requestRemote("getChangedDocumentsSince", [limit2, checkpoint2]);
  };
  _proto2.changeStream = function changeStream() {
    return this.changes$.asObservable();
  };
  _proto2.cleanup = function cleanup(minDeletedTime) {
    return this.requestRemote("cleanup", [minDeletedTime]);
  };
  _proto2.close = async function close3() {
    if (this.closed) {
      return Promise.reject(new Error("already closed"));
    }
    this.closed = true;
    this.subs.forEach((sub) => sub.unsubscribe());
    this.changes$.complete();
    await this.requestRemote("close", []);
    await (0, _messageChannelCache.closeMessageChannel)(this.internals.messageChannel);
  };
  _proto2.remove = async function remove() {
    this.closed = true;
    await this.requestRemote("remove", []);
    await (0, _messageChannelCache.closeMessageChannel)(this.internals.messageChannel);
  };
  _proto2.conflictResultionTasks = function conflictResultionTasks() {
    return this.conflicts$;
  };
  _proto2.resolveConflictResultionTask = async function resolveConflictResultionTask(taskSolution) {
    await this.requestRemote("resolveConflictResultionTask", [taskSolution]);
  };
  return RxStorageInstanceRemote2;
}();
rxStorageRemote.RxStorageInstanceRemote = RxStorageInstanceRemote;
function getRxStorageRemote(settings) {
  var withDefaults = Object.assign({
    mode: "storage"
  }, settings);
  return new RxStorageRemote(withDefaults);
}
var storageRemoteTypes = {};
var storageRemoteHelpers = {};
Object.defineProperty(storageRemoteHelpers, "__esModule", {
  value: true
});
storageRemoteHelpers.createAnswer = createAnswer;
storageRemoteHelpers.createErrorAnswer = createErrorAnswer;
var _utils$p = utils;
function createErrorAnswer(msg, error) {
  return {
    connectionId: msg.connectionId,
    answerTo: msg.requestId,
    method: msg.method,
    error: (0, _utils$p.errorToPlainJson)(error)
  };
}
function createAnswer(msg, ret) {
  return {
    connectionId: msg.connectionId,
    answerTo: msg.requestId,
    method: msg.method,
    return: ret
  };
}
var remote = {};
Object.defineProperty(remote, "__esModule", {
  value: true
});
remote.exposeRxStorageRemote = exposeRxStorageRemote;
var _rxjs$9 = cjs;
var _utils$o = utils;
var _storageRemoteHelpers = storageRemoteHelpers;
function exposeRxStorageRemote(settings) {
  var instanceByFullName = /* @__PURE__ */ new Map();
  settings.messages$.pipe((0, _rxjs$9.filter)((msg) => msg.method === "custom")).subscribe(async (msg) => {
    if (!settings.customRequestHandler) {
      settings.send((0, _storageRemoteHelpers.createErrorAnswer)(msg, new Error("Remote storage: cannot resolve custom request because settings.customRequestHandler is not set")));
    } else {
      try {
        var result = await settings.customRequestHandler(msg.params);
        settings.send((0, _storageRemoteHelpers.createAnswer)(msg, result));
      } catch (err) {
        settings.send((0, _storageRemoteHelpers.createErrorAnswer)(msg, err));
      }
    }
  });
  function getRxStorageInstance(params) {
    if (settings.storage) {
      return settings.storage.createStorageInstance(params);
    } else if (settings.database) {
      var storageInstances = Array.from(settings.database.storageInstances);
      var collectionName = params.collectionName;
      var storageInstance = storageInstances.find((instance) => instance.collectionName === collectionName);
      if (!storageInstance) {
        console.dir(storageInstances);
        throw new Error("storageInstance does not exist " + JSON.stringify({
          collectionName
        }));
      }
      var schema = params.schema;
      if (!(0, _utils$o.deepEqual)(schema, storageInstance.schema)) {
        throw new Error("Wrong schema " + JSON.stringify({
          schema,
          existingSchema: storageInstance.schema
        }));
      }
      return Promise.resolve(storageInstance);
    } else {
      throw new Error("no base given");
    }
  }
  settings.messages$.pipe((0, _rxjs$9.filter)((msg) => msg.method === "create")).subscribe(async (msg) => {
    var connectionId = msg.connectionId;
    if (Array.isArray(msg.params)) {
      return;
    }
    var params = msg.params;
    var collectionName = params.collectionName;
    var fullName = [params.databaseName, params.collectionName, params.schema.version].join("|");
    var state = instanceByFullName.get(fullName);
    if (!state) {
      try {
        state = {
          /**
           * We work with a promise here to ensure
           * that parallel create-calls will still end up
           * with exactly one instance and not more.
           */
          storageInstancePromise: getRxStorageInstance(params),
          connectionIds: /* @__PURE__ */ new Set(),
          params
        };
        instanceByFullName.set(fullName, state);
      } catch (err) {
        settings.send((0, _storageRemoteHelpers.createErrorAnswer)(msg, err));
        return;
      }
    } else {
      if (!(0, _utils$o.deepEqual)(params.schema, state.params.schema)) {
        settings.send((0, _storageRemoteHelpers.createErrorAnswer)(msg, new Error("Remote storage: schema not equal to existing storage")));
        return;
      }
    }
    state.connectionIds.add(msg.connectionId);
    var subs = [];
    var storageInstance = await state.storageInstancePromise;
    subs.push(storageInstance.changeStream().subscribe((changes) => {
      var message = {
        connectionId,
        answerTo: "changestream",
        method: "changeStream",
        return: changes
      };
      settings.send(message);
    }));
    subs.push(storageInstance.conflictResultionTasks().subscribe((conflicts2) => {
      var message = {
        connectionId,
        answerTo: "conflictResultionTasks",
        method: "conflictResultionTasks",
        return: conflicts2
      };
      settings.send(message);
    }));
    var connectionClosed = false;
    function closeThisConnection() {
      if (connectionClosed) {
        return;
      }
      connectionClosed = true;
      subs.forEach((sub) => sub.unsubscribe());
      (0, _utils$o.ensureNotFalsy)(state).connectionIds.delete(connectionId);
      instanceByFullName.delete(fullName);
    }
    if (settings.database) {
      var database = settings.database;
      var collection = database.collections[collectionName];
      if (collection) {
        collection.onDestroy.push(() => closeThisConnection());
      } else {
        database.onDestroy.push(() => closeThisConnection());
      }
    }
    subs.push(settings.messages$.pipe((0, _rxjs$9.filter)((subMsg) => subMsg.connectionId === connectionId)).subscribe(async (plainMessage) => {
      var message = plainMessage;
      if (message.method === "create" || message.method === "custom") {
        return;
      }
      if (!Array.isArray(message.params)) {
        return;
      }
      var result;
      try {
        if (message.method === "close" && settings.database) {
          settings.send((0, _storageRemoteHelpers.createAnswer)(message, null));
          return;
        }
        if (message.method === "close" && (0, _utils$o.ensureNotFalsy)(state).connectionIds.size > 1) {
          settings.send((0, _storageRemoteHelpers.createAnswer)(message, null));
          (0, _utils$o.ensureNotFalsy)(state).connectionIds.delete(connectionId);
          subs.forEach((sub) => sub.unsubscribe());
          return;
        }
        result = await storageInstance[message.method](message.params[0], message.params[1], message.params[2], message.params[3]);
        if (message.method === "close" || message.method === "remove") {
          closeThisConnection();
        }
        settings.send((0, _storageRemoteHelpers.createAnswer)(message, result));
      } catch (err) {
        settings.send((0, _storageRemoteHelpers.createErrorAnswer)(message, err));
      }
    }));
    settings.send((0, _storageRemoteHelpers.createAnswer)(msg, "ok"));
  });
  return {
    instanceByFullName
  };
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _rxStorageRemote = rxStorageRemote;
  Object.keys(_rxStorageRemote).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageRemote[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageRemote[key];
      }
    });
  });
  var _storageRemoteTypes = storageRemoteTypes;
  Object.keys(_storageRemoteTypes).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _storageRemoteTypes[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _storageRemoteTypes[key];
      }
    });
  });
  var _storageRemoteHelpers2 = storageRemoteHelpers;
  Object.keys(_storageRemoteHelpers2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _storageRemoteHelpers2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _storageRemoteHelpers2[key];
      }
    });
  });
  var _messageChannelCache2 = messageChannelCache;
  Object.keys(_messageChannelCache2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _messageChannelCache2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _messageChannelCache2[key];
      }
    });
  });
  var _remote = remote;
  Object.keys(_remote).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _remote[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _remote[key];
      }
    });
  });
})(storageRemote);
var electronHelper = {};
Object.defineProperty(electronHelper, "__esModule", {
  value: true
});
electronHelper.IPC_RENDERER_TO_MAIN = electronHelper.IPC_RENDERER_KEY_PREFIX = void 0;
var IPC_RENDERER_KEY_PREFIX = "rxdb-ipc-renderer-storage";
electronHelper.IPC_RENDERER_KEY_PREFIX = IPC_RENDERER_KEY_PREFIX;
var IPC_RENDERER_TO_MAIN = "rxdb-renderer-to-main";
electronHelper.IPC_RENDERER_TO_MAIN = IPC_RENDERER_TO_MAIN;
Object.defineProperty(rxStorageIpcRenderer, "__esModule", {
  value: true
});
rxStorageIpcRenderer.getRxStorageIpcRenderer = getRxStorageIpcRenderer;
var _rxjs$8 = cjs;
var _storageRemote$1 = storageRemote;
var _electronHelper$1 = electronHelper;
var _utils$n = utils;
function getRxStorageIpcRenderer(settings) {
  var channelId = [_electronHelper$1.IPC_RENDERER_KEY_PREFIX, settings.key].join("|");
  var storage = (0, _storageRemote$1.getRxStorageRemote)({
    identifier: "electron-ipc-renderer",
    statics: settings.statics,
    mode: settings.mode,
    messageChannelCreator() {
      var messages$ = new _rxjs$8.Subject();
      var listener = (_event, message) => {
        messages$.next(message);
      };
      settings.ipcRenderer.on(channelId, listener);
      settings.ipcRenderer.postMessage(channelId, false);
      return Promise.resolve({
        messages$,
        send(msg) {
          settings.ipcRenderer.postMessage(channelId, msg);
        },
        close() {
          settings.ipcRenderer.removeListener(channelId, listener);
          return _utils$n.PROMISE_RESOLVE_VOID;
        }
      });
    }
  });
  return storage;
}
var rxStorageIpcMain = {};
Object.defineProperty(rxStorageIpcMain, "__esModule", {
  value: true
});
rxStorageIpcMain.exposeIpcMainRxStorage = exposeIpcMainRxStorage;
var _rxjs$7 = cjs;
var _electronHelper = electronHelper;
var _storageRemote = storageRemote;
function exposeIpcMainRxStorage(args2) {
  var channelId = [_electronHelper.IPC_RENDERER_KEY_PREFIX, args2.key].join("|");
  var messages$ = new _rxjs$7.Subject();
  var openRenderers = /* @__PURE__ */ new Set();
  args2.ipcMain.on(channelId, (event, message) => {
    openRenderers.add(event.sender);
    if (message) {
      messages$.next(message);
    }
  });
  var send = (msg) => {
    openRenderers.forEach((sender) => {
      sender.send(channelId, msg);
    });
  };
  (0, _storageRemote.exposeRxStorageRemote)({
    storage: args2.storage,
    messages$,
    send
  });
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _rxStorageIpcRenderer = rxStorageIpcRenderer;
  Object.keys(_rxStorageIpcRenderer).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageIpcRenderer[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageIpcRenderer[key];
      }
    });
  });
  var _rxStorageIpcMain = rxStorageIpcMain;
  Object.keys(_rxStorageIpcMain).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageIpcMain[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageIpcMain[key];
      }
    });
  });
})(electron);
var storageDexie = {};
var rxStorageDexie = {};
var dexieHelper = {};
const e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, t = Object.keys, n = Array.isArray;
function r(e2, n2) {
  return "object" != typeof n2 || t(n2).forEach(function(t2) {
    e2[t2] = n2[t2];
  }), e2;
}
"undefined" == typeof Promise || e.Promise || (e.Promise = Promise);
const s = Object.getPrototypeOf, i = {}.hasOwnProperty;
function o(e2, t2) {
  return i.call(e2, t2);
}
function a(e2, n2) {
  "function" == typeof n2 && (n2 = n2(s(e2))), ("undefined" == typeof Reflect ? t : Reflect.ownKeys)(n2).forEach((t2) => {
    l(e2, t2, n2[t2]);
  });
}
const u = Object.defineProperty;
function l(e2, t2, n2, s2) {
  u(e2, t2, r(n2 && o(n2, "get") && "function" == typeof n2.get ? { get: n2.get, set: n2.set, configurable: true } : { value: n2, configurable: true, writable: true }, s2));
}
function c(e2) {
  return { from: function(t2) {
    return e2.prototype = Object.create(t2.prototype), l(e2.prototype, "constructor", e2), { extend: a.bind(null, e2.prototype) };
  } };
}
const h = Object.getOwnPropertyDescriptor;
function d(e2, t2) {
  let n2;
  return h(e2, t2) || (n2 = s(e2)) && d(n2, t2);
}
const f = [].slice;
function p(e2, t2, n2) {
  return f.call(e2, t2, n2);
}
function y(e2, t2) {
  return t2(e2);
}
function m(e2) {
  if (!e2)
    throw new Error("Assertion Failed");
}
function v(t2) {
  e.setImmediate ? setImmediate(t2) : setTimeout(t2, 0);
}
function g(e2, t2) {
  return e2.reduce((e3, n2, r2) => {
    var s2 = t2(n2, r2);
    return s2 && (e3[s2[0]] = s2[1]), e3;
  }, {});
}
function b(e2, t2) {
  if (o(e2, t2))
    return e2[t2];
  if (!t2)
    return e2;
  if ("string" != typeof t2) {
    for (var n2 = [], r2 = 0, s2 = t2.length; r2 < s2; ++r2) {
      var i2 = b(e2, t2[r2]);
      n2.push(i2);
    }
    return n2;
  }
  var a2 = t2.indexOf(".");
  if (-1 !== a2) {
    var u2 = e2[t2.substr(0, a2)];
    return void 0 === u2 ? void 0 : b(u2, t2.substr(a2 + 1));
  }
}
function _(e2, t2, r2) {
  if (e2 && void 0 !== t2 && (!("isFrozen" in Object) || !Object.isFrozen(e2)))
    if ("string" != typeof t2 && "length" in t2) {
      m("string" != typeof r2 && "length" in r2);
      for (var s2 = 0, i2 = t2.length; s2 < i2; ++s2)
        _(e2, t2[s2], r2[s2]);
    } else {
      var a2 = t2.indexOf(".");
      if (-1 !== a2) {
        var u2 = t2.substr(0, a2), l2 = t2.substr(a2 + 1);
        if ("" === l2)
          void 0 === r2 ? n(e2) && !isNaN(parseInt(u2)) ? e2.splice(u2, 1) : delete e2[u2] : e2[u2] = r2;
        else {
          var c2 = e2[u2];
          c2 && o(e2, u2) || (c2 = e2[u2] = {}), _(c2, l2, r2);
        }
      } else
        void 0 === r2 ? n(e2) && !isNaN(parseInt(t2)) ? e2.splice(t2, 1) : delete e2[t2] : e2[t2] = r2;
    }
}
function w(e2) {
  var t2 = {};
  for (var n2 in e2)
    o(e2, n2) && (t2[n2] = e2[n2]);
  return t2;
}
const x = [].concat;
function k(e2) {
  return x.apply([], e2);
}
const E = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(k([8, 16, 32, 64].map((e2) => ["Int", "Uint", "Float"].map((t2) => t2 + e2 + "Array")))).filter((t2) => e[t2]), P = E.map((t2) => e[t2]);
g(E, (e2) => [e2, true]);
let K = null;
function O(e2) {
  K = "undefined" != typeof WeakMap && /* @__PURE__ */ new WeakMap();
  const t2 = S(e2);
  return K = null, t2;
}
function S(e2) {
  if (!e2 || "object" != typeof e2)
    return e2;
  let t2 = K && K.get(e2);
  if (t2)
    return t2;
  if (n(e2)) {
    t2 = [], K && K.set(e2, t2);
    for (var r2 = 0, i2 = e2.length; r2 < i2; ++r2)
      t2.push(S(e2[r2]));
  } else if (P.indexOf(e2.constructor) >= 0)
    t2 = e2;
  else {
    const n2 = s(e2);
    for (var a2 in t2 = n2 === Object.prototype ? {} : Object.create(n2), K && K.set(e2, t2), e2)
      o(e2, a2) && (t2[a2] = S(e2[a2]));
  }
  return t2;
}
const { toString: A } = {};
function C(e2) {
  return A.call(e2).slice(8, -1);
}
const j = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator", D = "symbol" == typeof j ? function(e2) {
  var t2;
  return null != e2 && (t2 = e2[j]) && t2.apply(e2);
} : function() {
  return null;
}, I = {};
function B(e2) {
  var t2, r2, s2, i2;
  if (1 === arguments.length) {
    if (n(e2))
      return e2.slice();
    if (this === I && "string" == typeof e2)
      return [e2];
    if (i2 = D(e2)) {
      for (r2 = []; !(s2 = i2.next()).done; )
        r2.push(s2.value);
      return r2;
    }
    if (null == e2)
      return [e2];
    if ("number" == typeof (t2 = e2.length)) {
      for (r2 = new Array(t2); t2--; )
        r2[t2] = e2[t2];
      return r2;
    }
    return [e2];
  }
  for (t2 = arguments.length, r2 = new Array(t2); t2--; )
    r2[t2] = arguments[t2];
  return r2;
}
const T = "undefined" != typeof Symbol ? (e2) => "AsyncFunction" === e2[Symbol.toStringTag] : () => false;
var R = "undefined" != typeof location && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function F(e2, t2) {
  R = e2, M = t2;
}
var M = () => true;
const N = !new Error("").stack;
function q() {
  if (N)
    try {
      throw q.arguments, new Error();
    } catch (e2) {
      return e2;
    }
  return new Error();
}
function $(e2, t2) {
  var n2 = e2.stack;
  return n2 ? (t2 = t2 || 0, 0 === n2.indexOf(e2.name) && (t2 += (e2.name + e2.message).split("\n").length), n2.split("\n").slice(t2).filter(M).map((e3) => "\n" + e3).join("")) : "";
}
var U = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], L = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(U), V = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function W(e2, t2) {
  this._e = q(), this.name = e2, this.message = t2;
}
function Y(e2, t2) {
  return e2 + ". Errors: " + Object.keys(t2).map((e3) => t2[e3].toString()).filter((e3, t3, n2) => n2.indexOf(e3) === t3).join("\n");
}
function z(e2, t2, n2, r2) {
  this._e = q(), this.failures = t2, this.failedKeys = r2, this.successCount = n2, this.message = Y(e2, t2);
}
function G(e2, t2) {
  this._e = q(), this.name = "BulkError", this.failures = Object.keys(t2).map((e3) => t2[e3]), this.failuresByPos = t2, this.message = Y(e2, t2);
}
c(W).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + $(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), c(z).from(W), c(G).from(W);
var H = L.reduce((e2, t2) => (e2[t2] = t2 + "Error", e2), {});
const Q = W;
var X = L.reduce((e2, t2) => {
  var n2 = t2 + "Error";
  function r2(e3, r3) {
    this._e = q(), this.name = n2, e3 ? "string" == typeof e3 ? (this.message = `${e3}${r3 ? "\n " + r3 : ""}`, this.inner = r3 || null) : "object" == typeof e3 && (this.message = `${e3.name} ${e3.message}`, this.inner = e3) : (this.message = V[t2] || n2, this.inner = null);
  }
  return c(r2).from(Q), e2[t2] = r2, e2;
}, {});
X.Syntax = SyntaxError, X.Type = TypeError, X.Range = RangeError;
var J = U.reduce((e2, t2) => (e2[t2 + "Error"] = X[t2], e2), {});
var Z = L.reduce((e2, t2) => (-1 === ["Syntax", "Type", "Range"].indexOf(t2) && (e2[t2 + "Error"] = X[t2]), e2), {});
function ee() {
}
function te(e2) {
  return e2;
}
function ne$2(e2, t2) {
  return null == e2 || e2 === te ? t2 : function(n2) {
    return t2(e2(n2));
  };
}
function re(e2, t2) {
  return function() {
    e2.apply(this, arguments), t2.apply(this, arguments);
  };
}
function se(e2, t2) {
  return e2 === ee ? t2 : function() {
    var n2 = e2.apply(this, arguments);
    void 0 !== n2 && (arguments[0] = n2);
    var r2 = this.onsuccess, s2 = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var i2 = t2.apply(this, arguments);
    return r2 && (this.onsuccess = this.onsuccess ? re(r2, this.onsuccess) : r2), s2 && (this.onerror = this.onerror ? re(s2, this.onerror) : s2), void 0 !== i2 ? i2 : n2;
  };
}
function ie(e2, t2) {
  return e2 === ee ? t2 : function() {
    e2.apply(this, arguments);
    var n2 = this.onsuccess, r2 = this.onerror;
    this.onsuccess = this.onerror = null, t2.apply(this, arguments), n2 && (this.onsuccess = this.onsuccess ? re(n2, this.onsuccess) : n2), r2 && (this.onerror = this.onerror ? re(r2, this.onerror) : r2);
  };
}
function oe(e2, t2) {
  return e2 === ee ? t2 : function(n2) {
    var s2 = e2.apply(this, arguments);
    r(n2, s2);
    var i2 = this.onsuccess, o2 = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var a2 = t2.apply(this, arguments);
    return i2 && (this.onsuccess = this.onsuccess ? re(i2, this.onsuccess) : i2), o2 && (this.onerror = this.onerror ? re(o2, this.onerror) : o2), void 0 === s2 ? void 0 === a2 ? void 0 : a2 : r(s2, a2);
  };
}
function ae(e2, t2) {
  return e2 === ee ? t2 : function() {
    return false !== t2.apply(this, arguments) && e2.apply(this, arguments);
  };
}
function ue(e2, t2) {
  return e2 === ee ? t2 : function() {
    var n2 = e2.apply(this, arguments);
    if (n2 && "function" == typeof n2.then) {
      for (var r2 = this, s2 = arguments.length, i2 = new Array(s2); s2--; )
        i2[s2] = arguments[s2];
      return n2.then(function() {
        return t2.apply(r2, i2);
      });
    }
    return t2.apply(this, arguments);
  };
}
Z.ModifyError = z, Z.DexieError = W, Z.BulkError = G;
var le = {};
const [ce, he, de] = "undefined" == typeof Promise ? [] : (() => {
  let e2 = Promise.resolve();
  if ("undefined" == typeof crypto || !crypto.subtle)
    return [e2, s(e2), e2];
  const t2 = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [t2, s(t2), e2];
})(), fe = he && he.then, pe = ce && ce.constructor, ye = !!de;
var me = false, ve = de ? () => {
  de.then(qe);
} : e.setImmediate ? setImmediate.bind(null, qe) : e.MutationObserver ? () => {
  var e2 = document.createElement("div");
  new MutationObserver(() => {
    qe(), e2 = null;
  }).observe(e2, { attributes: true }), e2.setAttribute("i", "1");
} : () => {
  setTimeout(qe, 0);
}, ge = function(e2, t2) {
  Oe.push([e2, t2]), _e && (ve(), _e = false);
}, be = true, _e = true, we = [], xe = [], ke = null, Ee = te, Pe = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: ct, pgp: false, env: {}, finalize: function() {
  this.unhandleds.forEach((e2) => {
    try {
      ct(e2[0], e2[1]);
    } catch (e3) {
    }
  });
} }, Ke = Pe, Oe = [], Se = 0, Ae = [];
function Ce(e2) {
  if ("object" != typeof this)
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = ee, this._lib = false;
  var t2 = this._PSD = Ke;
  if (R && (this._stackHolder = q(), this._prev = null, this._numPrev = 0), "function" != typeof e2) {
    if (e2 !== le)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (false === this._state && Be(this, this._value));
  }
  this._state = null, this._value = null, ++t2.ref, Ie(this, e2);
}
const je = { get: function() {
  var e2 = Ke, t2 = Qe;
  function n2(n3, r2) {
    var s2 = !e2.global && (e2 !== Ke || t2 !== Qe);
    const i2 = s2 && !et();
    var o2 = new Ce((t3, o3) => {
      Re(this, new De(ut(n3, e2, s2, i2), ut(r2, e2, s2, i2), t3, o3, e2));
    });
    return R && Ne(o2, this), o2;
  }
  return n2.prototype = le, n2;
}, set: function(e2) {
  l(this, "then", e2 && e2.prototype === le ? je : { get: function() {
    return e2;
  }, set: je.set });
} };
function De(e2, t2, n2, r2, s2) {
  this.onFulfilled = "function" == typeof e2 ? e2 : null, this.onRejected = "function" == typeof t2 ? t2 : null, this.resolve = n2, this.reject = r2, this.psd = s2;
}
function Ie(e2, t2) {
  try {
    t2((t3) => {
      if (null === e2._state) {
        if (t3 === e2)
          throw new TypeError("A promise cannot be resolved with itself.");
        var n2 = e2._lib && $e();
        t3 && "function" == typeof t3.then ? Ie(e2, (e3, n3) => {
          t3 instanceof Ce ? t3._then(e3, n3) : t3.then(e3, n3);
        }) : (e2._state = true, e2._value = t3, Te(e2)), n2 && Ue();
      }
    }, Be.bind(null, e2));
  } catch (t3) {
    Be(e2, t3);
  }
}
function Be(e2, t2) {
  if (xe.push(t2), null === e2._state) {
    var n2 = e2._lib && $e();
    t2 = Ee(t2), e2._state = false, e2._value = t2, R && null !== t2 && "object" == typeof t2 && !t2._promise && function(e3, t3, n3) {
      try {
        e3.apply(null, n3);
      } catch (e4) {
        t3 && t3(e4);
      }
    }(() => {
      var n3 = d(t2, "stack");
      t2._promise = e2, l(t2, "stack", { get: () => me ? n3 && (n3.get ? n3.get.apply(t2) : n3.value) : e2.stack });
    }), function(e3) {
      we.some((t3) => t3._value === e3._value) || we.push(e3);
    }(e2), Te(e2), n2 && Ue();
  }
}
function Te(e2) {
  var t2 = e2._listeners;
  e2._listeners = [];
  for (var n2 = 0, r2 = t2.length; n2 < r2; ++n2)
    Re(e2, t2[n2]);
  var s2 = e2._PSD;
  --s2.ref || s2.finalize(), 0 === Se && (++Se, ge(() => {
    0 == --Se && Le();
  }, []));
}
function Re(e2, t2) {
  if (null !== e2._state) {
    var n2 = e2._state ? t2.onFulfilled : t2.onRejected;
    if (null === n2)
      return (e2._state ? t2.resolve : t2.reject)(e2._value);
    ++t2.psd.ref, ++Se, ge(Fe, [n2, e2, t2]);
  } else
    e2._listeners.push(t2);
}
function Fe(e2, t2, n2) {
  try {
    ke = t2;
    var r2, s2 = t2._value;
    t2._state ? r2 = e2(s2) : (xe.length && (xe = []), r2 = e2(s2), -1 === xe.indexOf(s2) && function(e3) {
      var t3 = we.length;
      for (; t3; )
        if (we[--t3]._value === e3._value)
          return void we.splice(t3, 1);
    }(t2)), n2.resolve(r2);
  } catch (e3) {
    n2.reject(e3);
  } finally {
    ke = null, 0 == --Se && Le(), --n2.psd.ref || n2.psd.finalize();
  }
}
function Me(e2, t2, n2) {
  if (t2.length === n2)
    return t2;
  var r2 = "";
  if (false === e2._state) {
    var s2, i2, o2 = e2._value;
    null != o2 ? (s2 = o2.name || "Error", i2 = o2.message || o2, r2 = $(o2, 0)) : (s2 = o2, i2 = ""), t2.push(s2 + (i2 ? ": " + i2 : "") + r2);
  }
  return R && ((r2 = $(e2._stackHolder, 2)) && -1 === t2.indexOf(r2) && t2.push(r2), e2._prev && Me(e2._prev, t2, n2)), t2;
}
function Ne(e2, t2) {
  var n2 = t2 ? t2._numPrev + 1 : 0;
  n2 < 100 && (e2._prev = t2, e2._numPrev = n2);
}
function qe() {
  $e() && Ue();
}
function $e() {
  var e2 = be;
  return be = false, _e = false, e2;
}
function Ue() {
  var e2, t2, n2;
  do {
    for (; Oe.length > 0; )
      for (e2 = Oe, Oe = [], n2 = e2.length, t2 = 0; t2 < n2; ++t2) {
        var r2 = e2[t2];
        r2[0].apply(null, r2[1]);
      }
  } while (Oe.length > 0);
  be = true, _e = true;
}
function Le() {
  var e2 = we;
  we = [], e2.forEach((e3) => {
    e3._PSD.onunhandled.call(null, e3._value, e3);
  });
  for (var t2 = Ae.slice(0), n2 = t2.length; n2; )
    t2[--n2]();
}
function Ve(e2) {
  return new Ce(le, false, e2);
}
function We(e2, t2) {
  var n2 = Ke;
  return function() {
    var r2 = $e(), s2 = Ke;
    try {
      return st(n2, true), e2.apply(this, arguments);
    } catch (e3) {
      t2 && t2(e3);
    } finally {
      st(s2, false), r2 && Ue();
    }
  };
}
a(Ce.prototype, { then: je, _then: function(e2, t2) {
  Re(this, new De(null, null, e2, t2, Ke));
}, catch: function(e2) {
  if (1 === arguments.length)
    return this.then(null, e2);
  var t2 = arguments[0], n2 = arguments[1];
  return "function" == typeof t2 ? this.then(null, (e3) => e3 instanceof t2 ? n2(e3) : Ve(e3)) : this.then(null, (e3) => e3 && e3.name === t2 ? n2(e3) : Ve(e3));
}, finally: function(e2) {
  return this.then((t2) => (e2(), t2), (t2) => (e2(), Ve(t2)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    me = true;
    var e2 = Me(this, [], 20).join("\nFrom previous: ");
    return null !== this._state && (this._stack = e2), e2;
  } finally {
    me = false;
  }
} }, timeout: function(e2, t2) {
  return e2 < 1 / 0 ? new Ce((n2, r2) => {
    var s2 = setTimeout(() => r2(new X.Timeout(t2)), e2);
    this.then(n2, r2).finally(clearTimeout.bind(null, s2));
  }) : this;
} }), "undefined" != typeof Symbol && Symbol.toStringTag && l(Ce.prototype, Symbol.toStringTag, "Dexie.Promise"), Pe.env = it(), a(Ce, { all: function() {
  var e2 = B.apply(null, arguments).map(tt);
  return new Ce(function(t2, n2) {
    0 === e2.length && t2([]);
    var r2 = e2.length;
    e2.forEach((s2, i2) => Ce.resolve(s2).then((n3) => {
      e2[i2] = n3, --r2 || t2(e2);
    }, n2));
  });
}, resolve: (e2) => {
  if (e2 instanceof Ce)
    return e2;
  if (e2 && "function" == typeof e2.then)
    return new Ce((t3, n2) => {
      e2.then(t3, n2);
    });
  var t2 = new Ce(le, true, e2);
  return Ne(t2, ke), t2;
}, reject: Ve, race: function() {
  var e2 = B.apply(null, arguments).map(tt);
  return new Ce((t2, n2) => {
    e2.map((e3) => Ce.resolve(e3).then(t2, n2));
  });
}, PSD: { get: () => Ke, set: (e2) => Ke = e2 }, totalEchoes: { get: () => Qe }, newPSD: Je, usePSD: ot, scheduler: { get: () => ge, set: (e2) => {
  ge = e2;
} }, rejectionMapper: { get: () => Ee, set: (e2) => {
  Ee = e2;
} }, follow: (e2, t2) => new Ce((n2, r2) => Je((t3, n3) => {
  var r3 = Ke;
  r3.unhandleds = [], r3.onunhandled = n3, r3.finalize = re(function() {
    !function(e3) {
      function t4() {
        e3(), Ae.splice(Ae.indexOf(t4), 1);
      }
      Ae.push(t4), ++Se, ge(() => {
        0 == --Se && Le();
      }, []);
    }(() => {
      0 === this.unhandleds.length ? t3() : n3(this.unhandleds[0]);
    });
  }, r3.finalize), e2();
}, t2, n2, r2)) }), pe && (pe.allSettled && l(Ce, "allSettled", function() {
  const e2 = B.apply(null, arguments).map(tt);
  return new Ce((t2) => {
    0 === e2.length && t2([]);
    let n2 = e2.length;
    const r2 = new Array(n2);
    e2.forEach((e3, s2) => Ce.resolve(e3).then((e4) => r2[s2] = { status: "fulfilled", value: e4 }, (e4) => r2[s2] = { status: "rejected", reason: e4 }).then(() => --n2 || t2(r2)));
  });
}), pe.any && "undefined" != typeof AggregateError && l(Ce, "any", function() {
  const e2 = B.apply(null, arguments).map(tt);
  return new Ce((t2, n2) => {
    0 === e2.length && n2(new AggregateError([]));
    let r2 = e2.length;
    const s2 = new Array(r2);
    e2.forEach((e3, i2) => Ce.resolve(e3).then((e4) => t2(e4), (e4) => {
      s2[i2] = e4, --r2 || n2(new AggregateError(s2));
    }));
  });
}));
const Ye = { awaits: 0, echoes: 0, id: 0 };
var ze = 0, Ge = [], He = 0, Qe = 0, Xe = 0;
function Je(e2, t2, n2, s2) {
  var i2 = Ke, o2 = Object.create(i2);
  o2.parent = i2, o2.ref = 0, o2.global = false, o2.id = ++Xe;
  var a2 = Pe.env;
  o2.env = ye ? { Promise: Ce, PromiseProp: { value: Ce, configurable: true, writable: true }, all: Ce.all, race: Ce.race, allSettled: Ce.allSettled, any: Ce.any, resolve: Ce.resolve, reject: Ce.reject, nthen: lt$2(a2.nthen, o2), gthen: lt$2(a2.gthen, o2) } : {}, t2 && r(o2, t2), ++i2.ref, o2.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var u2 = ot(o2, e2, n2, s2);
  return 0 === o2.ref && o2.finalize(), u2;
}
function Ze() {
  return Ye.id || (Ye.id = ++ze), ++Ye.awaits, Ye.echoes += 100, Ye.id;
}
function et() {
  return !!Ye.awaits && (0 == --Ye.awaits && (Ye.id = 0), Ye.echoes = 100 * Ye.awaits, true);
}
function tt(e2) {
  return Ye.echoes && e2 && e2.constructor === pe ? (Ze(), e2.then((e3) => (et(), e3), (e3) => (et(), ht(e3)))) : e2;
}
function nt(e2) {
  ++Qe, Ye.echoes && 0 != --Ye.echoes || (Ye.echoes = Ye.id = 0), Ge.push(Ke), st(e2, true);
}
function rt() {
  var e2 = Ge[Ge.length - 1];
  Ge.pop(), st(e2, false);
}
function st(t2, n2) {
  var r2 = Ke;
  if ((n2 ? !Ye.echoes || He++ && t2 === Ke : !He || --He && t2 === Ke) || at(n2 ? nt.bind(null, t2) : rt), t2 !== Ke && (Ke = t2, r2 === Pe && (Pe.env = it()), ye)) {
    var s2 = Pe.env.Promise, i2 = t2.env;
    he.then = i2.nthen, s2.prototype.then = i2.gthen, (r2.global || t2.global) && (Object.defineProperty(e, "Promise", i2.PromiseProp), s2.all = i2.all, s2.race = i2.race, s2.resolve = i2.resolve, s2.reject = i2.reject, i2.allSettled && (s2.allSettled = i2.allSettled), i2.any && (s2.any = i2.any));
  }
}
function it() {
  var t2 = e.Promise;
  return ye ? { Promise: t2, PromiseProp: Object.getOwnPropertyDescriptor(e, "Promise"), all: t2.all, race: t2.race, allSettled: t2.allSettled, any: t2.any, resolve: t2.resolve, reject: t2.reject, nthen: he.then, gthen: t2.prototype.then } : {};
}
function ot(e2, t2, n2, r2, s2) {
  var i2 = Ke;
  try {
    return st(e2, true), t2(n2, r2, s2);
  } finally {
    st(i2, false);
  }
}
function at(e2) {
  fe.call(ce, e2);
}
function ut(e2, t2, n2, r2) {
  return "function" != typeof e2 ? e2 : function() {
    var s2 = Ke;
    n2 && Ze(), st(t2, true);
    try {
      return e2.apply(this, arguments);
    } finally {
      st(s2, false), r2 && at(et);
    }
  };
}
function lt$2(e2, t2) {
  return function(n2, r2) {
    return e2.call(this, ut(n2, t2), ut(r2, t2));
  };
}
-1 === ("" + fe).indexOf("[native code]") && (Ze = et = ee);
function ct(t2, n2) {
  var s2;
  try {
    s2 = n2.onuncatched(t2);
  } catch (e2) {
  }
  if (false !== s2)
    try {
      var i2, o2 = { promise: n2, reason: t2 };
      if (e.document && document.createEvent ? ((i2 = document.createEvent("Event")).initEvent("unhandledrejection", true, true), r(i2, o2)) : e.CustomEvent && r(i2 = new CustomEvent("unhandledrejection", { detail: o2 }), o2), i2 && e.dispatchEvent && (dispatchEvent(i2), !e.PromiseRejectionEvent && e.onunhandledrejection))
        try {
          e.onunhandledrejection(i2);
        } catch (e2) {
        }
      R && i2 && !i2.defaultPrevented && console.warn(`Unhandled rejection: ${t2.stack || t2}`);
    } catch (e2) {
    }
}
var ht = Ce.reject;
function dt(e2, t2, n2, r2) {
  if (e2.idbdb && (e2._state.openComplete || Ke.letThrough || e2._vip)) {
    var s2 = e2._createTransaction(t2, n2, e2._dbSchema);
    try {
      s2.create(), e2._state.PR1398_maxLoop = 3;
    } catch (s3) {
      return s3.name === H.InvalidState && e2.isOpen() && --e2._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e2._close(), e2.open().then(() => dt(e2, t2, n2, r2))) : ht(s3);
    }
    return s2._promise(t2, (e3, t3) => Je(() => (Ke.trans = s2, r2(e3, t3, s2)))).then((e3) => s2._completion.then(() => e3));
  }
  if (e2._state.openComplete)
    return ht(new X.DatabaseClosed(e2._state.dbOpenError));
  if (!e2._state.isBeingOpened) {
    if (!e2._options.autoOpen)
      return ht(new X.DatabaseClosed());
    e2.open().catch(ee);
  }
  return e2._state.dbReadyPromise.then(() => dt(e2, t2, n2, r2));
}
const ft = String.fromCharCode(65535), pt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", yt = [], mt = "undefined" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent), vt = mt, gt$2 = mt, bt = (e2) => !/(dexie\.js|dexie\.min\.js)/.test(e2);
function _t(e2, t2) {
  return e2 ? t2 ? function() {
    return e2.apply(this, arguments) && t2.apply(this, arguments);
  } : e2 : t2;
}
const wt = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };
function xt(e2) {
  return "string" != typeof e2 || /\./.test(e2) ? (e3) => e3 : (t2) => (void 0 === t2[e2] && e2 in t2 && delete (t2 = O(t2))[e2], t2);
}
function kt() {
  throw X.Type();
}
class Et {
  _trans(e2, t2, n2) {
    const r2 = this._tx || Ke.trans, s2 = this.name;
    function i2(e3, n3, r3) {
      if (!r3.schema[s2])
        throw new X.NotFound("Table " + s2 + " not part of transaction");
      return t2(r3.idbtrans, r3);
    }
    const o2 = $e();
    try {
      return r2 && r2.db === this.db ? r2 === Ke.trans ? r2._promise(e2, i2, n2) : Je(() => r2._promise(e2, i2, n2), { trans: r2, transless: Ke.transless || Ke }) : dt(this.db, e2, [this.name], i2);
    } finally {
      o2 && Ue();
    }
  }
  get(e2, t2) {
    return e2 && e2.constructor === Object ? this.where(e2).first(t2) : this._trans("readonly", (t3) => this.core.get({ trans: t3, key: e2 }).then((e3) => this.hook.reading.fire(e3))).then(t2);
  }
  where(e2) {
    if ("string" == typeof e2)
      return new this.db.WhereClause(this, e2);
    if (n(e2))
      return new this.db.WhereClause(this, `[${e2.join("+")}]`);
    const r2 = t(e2);
    if (1 === r2.length)
      return this.where(r2[0]).equals(e2[r2[0]]);
    const s2 = this.schema.indexes.concat(this.schema.primKey).filter((e3) => e3.compound && r2.every((t2) => e3.keyPath.indexOf(t2) >= 0) && e3.keyPath.every((e4) => r2.indexOf(e4) >= 0))[0];
    if (s2 && this.db._maxKey !== ft)
      return this.where(s2.name).equals(s2.keyPath.map((t2) => e2[t2]));
    !s2 && R && console.warn(`The query ${JSON.stringify(e2)} on ${this.name} would benefit of a compound index [${r2.join("+")}]`);
    const { idxByName: i2 } = this.schema, o2 = this.db._deps.indexedDB;
    function a2(e3, t2) {
      try {
        return 0 === o2.cmp(e3, t2);
      } catch (e4) {
        return false;
      }
    }
    const [u2, l2] = r2.reduce(([t2, r3], s3) => {
      const o3 = i2[s3], u3 = e2[s3];
      return [t2 || o3, t2 || !o3 ? _t(r3, o3 && o3.multi ? (e3) => {
        const t3 = b(e3, s3);
        return n(t3) && t3.some((e4) => a2(u3, e4));
      } : (e3) => a2(u3, b(e3, s3))) : r3];
    }, [null, null]);
    return u2 ? this.where(u2.name).equals(e2[u2.keyPath]).filter(l2) : s2 ? this.filter(l2) : this.where(r2).equals("");
  }
  filter(e2) {
    return this.toCollection().and(e2);
  }
  count(e2) {
    return this.toCollection().count(e2);
  }
  offset(e2) {
    return this.toCollection().offset(e2);
  }
  limit(e2) {
    return this.toCollection().limit(e2);
  }
  each(e2) {
    return this.toCollection().each(e2);
  }
  toArray(e2) {
    return this.toCollection().toArray(e2);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(e2) {
    return new this.db.Collection(new this.db.WhereClause(this, n(e2) ? `[${e2.join("+")}]` : e2));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(e2) {
    const { db: t2, name: n2 } = this;
    this.schema.mappedClass = e2, e2.prototype instanceof kt && (e2 = class extends e2 {
      get db() {
        return t2;
      }
      table() {
        return n2;
      }
    });
    const r2 = /* @__PURE__ */ new Set();
    for (let t3 = e2.prototype; t3; t3 = s(t3))
      Object.getOwnPropertyNames(t3).forEach((e3) => r2.add(e3));
    const i2 = (t3) => {
      if (!t3)
        return t3;
      const n3 = Object.create(e2.prototype);
      for (let e3 in t3)
        if (!r2.has(e3))
          try {
            n3[e3] = t3[e3];
          } catch (e4) {
          }
      return n3;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = i2, this.hook("reading", i2), e2;
  }
  defineClass() {
    return this.mapToClass(function(e2) {
      r(this, e2);
    });
  }
  add(e2, t2) {
    const { auto: n2, keyPath: r2 } = this.schema.primKey;
    let s2 = e2;
    return r2 && n2 && (s2 = xt(r2)(e2)), this._trans("readwrite", (e3) => this.core.mutate({ trans: e3, type: "add", keys: null != t2 ? [t2] : null, values: [s2] })).then((e3) => e3.numFailures ? Ce.reject(e3.failures[0]) : e3.lastResult).then((t3) => {
      if (r2)
        try {
          _(e2, r2, t3);
        } catch (e3) {
        }
      return t3;
    });
  }
  update(e2, r2) {
    if ("object" != typeof e2 || n(e2))
      return this.where(":id").equals(e2).modify(r2);
    {
      const n2 = b(e2, this.schema.primKey.keyPath);
      if (void 0 === n2)
        return ht(new X.InvalidArgument("Given object does not contain its primary key"));
      try {
        "function" != typeof r2 ? t(r2).forEach((t2) => {
          _(e2, t2, r2[t2]);
        }) : r2(e2, { value: e2, primKey: n2 });
      } catch (e3) {
      }
      return this.where(":id").equals(n2).modify(r2);
    }
  }
  put(e2, t2) {
    const { auto: n2, keyPath: r2 } = this.schema.primKey;
    let s2 = e2;
    return r2 && n2 && (s2 = xt(r2)(e2)), this._trans("readwrite", (e3) => this.core.mutate({ trans: e3, type: "put", values: [s2], keys: null != t2 ? [t2] : null })).then((e3) => e3.numFailures ? Ce.reject(e3.failures[0]) : e3.lastResult).then((t3) => {
      if (r2)
        try {
          _(e2, r2, t3);
        } catch (e3) {
        }
      return t3;
    });
  }
  delete(e2) {
    return this._trans("readwrite", (t2) => this.core.mutate({ trans: t2, type: "delete", keys: [e2] })).then((e3) => e3.numFailures ? Ce.reject(e3.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (e2) => this.core.mutate({ trans: e2, type: "deleteRange", range: wt })).then((e2) => e2.numFailures ? Ce.reject(e2.failures[0]) : void 0);
  }
  bulkGet(e2) {
    return this._trans("readonly", (t2) => this.core.getMany({ keys: e2, trans: t2 }).then((e3) => e3.map((e4) => this.hook.reading.fire(e4))));
  }
  bulkAdd(e2, t2, n2) {
    const r2 = Array.isArray(t2) ? t2 : void 0, s2 = (n2 = n2 || (r2 ? void 0 : t2)) ? n2.allKeys : void 0;
    return this._trans("readwrite", (t3) => {
      const { auto: n3, keyPath: i2 } = this.schema.primKey;
      if (i2 && r2)
        throw new X.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (r2 && r2.length !== e2.length)
        throw new X.InvalidArgument("Arguments objects and keys must have the same length");
      const o2 = e2.length;
      let a2 = i2 && n3 ? e2.map(xt(i2)) : e2;
      return this.core.mutate({ trans: t3, type: "add", keys: r2, values: a2, wantResults: s2 }).then(({ numFailures: e3, results: t4, lastResult: n4, failures: r3 }) => {
        if (0 === e3)
          return s2 ? t4 : n4;
        throw new G(`${this.name}.bulkAdd(): ${e3} of ${o2} operations failed`, r3);
      });
    });
  }
  bulkPut(e2, t2, n2) {
    const r2 = Array.isArray(t2) ? t2 : void 0, s2 = (n2 = n2 || (r2 ? void 0 : t2)) ? n2.allKeys : void 0;
    return this._trans("readwrite", (t3) => {
      const { auto: n3, keyPath: i2 } = this.schema.primKey;
      if (i2 && r2)
        throw new X.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (r2 && r2.length !== e2.length)
        throw new X.InvalidArgument("Arguments objects and keys must have the same length");
      const o2 = e2.length;
      let a2 = i2 && n3 ? e2.map(xt(i2)) : e2;
      return this.core.mutate({ trans: t3, type: "put", keys: r2, values: a2, wantResults: s2 }).then(({ numFailures: e3, results: t4, lastResult: n4, failures: r3 }) => {
        if (0 === e3)
          return s2 ? t4 : n4;
        throw new G(`${this.name}.bulkPut(): ${e3} of ${o2} operations failed`, r3);
      });
    });
  }
  bulkDelete(e2) {
    const t2 = e2.length;
    return this._trans("readwrite", (t3) => this.core.mutate({ trans: t3, type: "delete", keys: e2 })).then(({ numFailures: e3, lastResult: n2, failures: r2 }) => {
      if (0 === e3)
        return n2;
      throw new G(`${this.name}.bulkDelete(): ${e3} of ${t2} operations failed`, r2);
    });
  }
}
function Pt(e2) {
  var r2 = {}, s2 = function(t2, n2) {
    if (n2) {
      for (var s3 = arguments.length, i3 = new Array(s3 - 1); --s3; )
        i3[s3 - 1] = arguments[s3];
      return r2[t2].subscribe.apply(null, i3), e2;
    }
    if ("string" == typeof t2)
      return r2[t2];
  };
  s2.addEventType = a2;
  for (var i2 = 1, o2 = arguments.length; i2 < o2; ++i2)
    a2(arguments[i2]);
  return s2;
  function a2(e3, t2, n2) {
    if ("object" == typeof e3)
      return u2(e3);
    t2 || (t2 = ae), n2 || (n2 = ee);
    var i3 = { subscribers: [], fire: n2, subscribe: function(e4) {
      -1 === i3.subscribers.indexOf(e4) && (i3.subscribers.push(e4), i3.fire = t2(i3.fire, e4));
    }, unsubscribe: function(e4) {
      i3.subscribers = i3.subscribers.filter(function(t3) {
        return t3 !== e4;
      }), i3.fire = i3.subscribers.reduce(t2, n2);
    } };
    return r2[e3] = s2[e3] = i3, i3;
  }
  function u2(e3) {
    t(e3).forEach(function(t2) {
      var r3 = e3[t2];
      if (n(r3))
        a2(t2, e3[t2][0], e3[t2][1]);
      else {
        if ("asap" !== r3)
          throw new X.InvalidArgument("Invalid event config");
        var s3 = a2(t2, te, function() {
          for (var e4 = arguments.length, t3 = new Array(e4); e4--; )
            t3[e4] = arguments[e4];
          s3.subscribers.forEach(function(e5) {
            v(function() {
              e5.apply(null, t3);
            });
          });
        });
      }
    });
  }
}
function Kt(e2, t2) {
  return c(t2).from({ prototype: e2 }), t2;
}
function Ot(e2, t2) {
  return !(e2.filter || e2.algorithm || e2.or) && (t2 ? e2.justLimit : !e2.replayFilter);
}
function St(e2, t2) {
  e2.filter = _t(e2.filter, t2);
}
function At(e2, t2, n2) {
  var r2 = e2.replayFilter;
  e2.replayFilter = r2 ? () => _t(r2(), t2()) : t2, e2.justLimit = n2 && !r2;
}
function Ct(e2, t2) {
  if (e2.isPrimKey)
    return t2.primaryKey;
  const n2 = t2.getIndexByKeyPath(e2.index);
  if (!n2)
    throw new X.Schema("KeyPath " + e2.index + " on object store " + t2.name + " is not indexed");
  return n2;
}
function jt(e2, t2, n2) {
  const r2 = Ct(e2, t2.schema);
  return t2.openCursor({ trans: n2, values: !e2.keysOnly, reverse: "prev" === e2.dir, unique: !!e2.unique, query: { index: r2, range: e2.range } });
}
function Dt(e2, t2, n2, r2) {
  const s2 = e2.replayFilter ? _t(e2.filter, e2.replayFilter()) : e2.filter;
  if (e2.or) {
    const i2 = {}, a2 = (e3, n3, r3) => {
      if (!s2 || s2(n3, r3, (e4) => n3.stop(e4), (e4) => n3.fail(e4))) {
        var a3 = n3.primaryKey, u2 = "" + a3;
        "[object ArrayBuffer]" === u2 && (u2 = "" + new Uint8Array(a3)), o(i2, u2) || (i2[u2] = true, t2(e3, n3, r3));
      }
    };
    return Promise.all([e2.or._iterate(a2, n2), It(jt(e2, r2, n2), e2.algorithm, a2, !e2.keysOnly && e2.valueMapper)]);
  }
  return It(jt(e2, r2, n2), _t(e2.algorithm, s2), t2, !e2.keysOnly && e2.valueMapper);
}
function It(e2, t2, n2, r2) {
  var s2 = We(r2 ? (e3, t3, s3) => n2(r2(e3), t3, s3) : n2);
  return e2.then((e3) => {
    if (e3)
      return e3.start(() => {
        var n3 = () => e3.continue();
        t2 && !t2(e3, (e4) => n3 = e4, (t3) => {
          e3.stop(t3), n3 = ee;
        }, (t3) => {
          e3.fail(t3), n3 = ee;
        }) || s2(e3.value, e3, (e4) => n3 = e4), n3();
      });
  });
}
function Bt(e2, t2) {
  try {
    const n2 = Tt(e2), r2 = Tt(t2);
    if (n2 !== r2)
      return "Array" === n2 ? 1 : "Array" === r2 ? -1 : "binary" === n2 ? 1 : "binary" === r2 ? -1 : "string" === n2 ? 1 : "string" === r2 ? -1 : "Date" === n2 ? 1 : "Date" !== r2 ? NaN : -1;
    switch (n2) {
      case "number":
      case "Date":
      case "string":
        return e2 > t2 ? 1 : e2 < t2 ? -1 : 0;
      case "binary":
        return function(e3, t3) {
          const n3 = e3.length, r3 = t3.length, s2 = n3 < r3 ? n3 : r3;
          for (let n4 = 0; n4 < s2; ++n4)
            if (e3[n4] !== t3[n4])
              return e3[n4] < t3[n4] ? -1 : 1;
          return n3 === r3 ? 0 : n3 < r3 ? -1 : 1;
        }(Rt(e2), Rt(t2));
      case "Array":
        return function(e3, t3) {
          const n3 = e3.length, r3 = t3.length, s2 = n3 < r3 ? n3 : r3;
          for (let n4 = 0; n4 < s2; ++n4) {
            const r4 = Bt(e3[n4], t3[n4]);
            if (0 !== r4)
              return r4;
          }
          return n3 === r3 ? 0 : n3 < r3 ? -1 : 1;
        }(e2, t2);
    }
  } catch (e3) {
  }
  return NaN;
}
function Tt(e2) {
  const t2 = typeof e2;
  if ("object" !== t2)
    return t2;
  if (ArrayBuffer.isView(e2))
    return "binary";
  const n2 = C(e2);
  return "ArrayBuffer" === n2 ? "binary" : n2;
}
function Rt(e2) {
  return e2 instanceof Uint8Array ? e2 : ArrayBuffer.isView(e2) ? new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength) : new Uint8Array(e2);
}
class Ft {
  _read(e2, t2) {
    var n2 = this._ctx;
    return n2.error ? n2.table._trans(null, ht.bind(null, n2.error)) : n2.table._trans("readonly", e2).then(t2);
  }
  _write(e2) {
    var t2 = this._ctx;
    return t2.error ? t2.table._trans(null, ht.bind(null, t2.error)) : t2.table._trans("readwrite", e2, "locked");
  }
  _addAlgorithm(e2) {
    var t2 = this._ctx;
    t2.algorithm = _t(t2.algorithm, e2);
  }
  _iterate(e2, t2) {
    return Dt(this._ctx, e2, t2, this._ctx.table.core);
  }
  clone(e2) {
    var t2 = Object.create(this.constructor.prototype), n2 = Object.create(this._ctx);
    return e2 && r(n2, e2), t2._ctx = n2, t2;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(e2) {
    var t2 = this._ctx;
    return this._read((n2) => Dt(t2, e2, n2, t2.table.core));
  }
  count(e2) {
    return this._read((e3) => {
      const t2 = this._ctx, n2 = t2.table.core;
      if (Ot(t2, true))
        return n2.count({ trans: e3, query: { index: Ct(t2, n2.schema), range: t2.range } }).then((e4) => Math.min(e4, t2.limit));
      var r2 = 0;
      return Dt(t2, () => (++r2, false), e3, n2).then(() => r2);
    }).then(e2);
  }
  sortBy(e2, t2) {
    const n2 = e2.split(".").reverse(), r2 = n2[0], s2 = n2.length - 1;
    function i2(e3, t3) {
      return t3 ? i2(e3[n2[t3]], t3 - 1) : e3[r2];
    }
    var o2 = "next" === this._ctx.dir ? 1 : -1;
    function a2(e3, t3) {
      var n3 = i2(e3, s2), r3 = i2(t3, s2);
      return n3 < r3 ? -o2 : n3 > r3 ? o2 : 0;
    }
    return this.toArray(function(e3) {
      return e3.sort(a2);
    }).then(t2);
  }
  toArray(e2) {
    return this._read((e3) => {
      var t2 = this._ctx;
      if ("next" === t2.dir && Ot(t2, true) && t2.limit > 0) {
        const { valueMapper: n2 } = t2, r2 = Ct(t2, t2.table.core.schema);
        return t2.table.core.query({ trans: e3, limit: t2.limit, values: true, query: { index: r2, range: t2.range } }).then(({ result: e4 }) => n2 ? e4.map(n2) : e4);
      }
      {
        const n2 = [];
        return Dt(t2, (e4) => n2.push(e4), e3, t2.table.core).then(() => n2);
      }
    }, e2);
  }
  offset(e2) {
    var t2 = this._ctx;
    return e2 <= 0 || (t2.offset += e2, Ot(t2) ? At(t2, () => {
      var t3 = e2;
      return (e3, n2) => 0 === t3 || (1 === t3 ? (--t3, false) : (n2(() => {
        e3.advance(t3), t3 = 0;
      }), false));
    }) : At(t2, () => {
      var t3 = e2;
      return () => --t3 < 0;
    })), this;
  }
  limit(e2) {
    return this._ctx.limit = Math.min(this._ctx.limit, e2), At(this._ctx, () => {
      var t2 = e2;
      return function(e3, n2, r2) {
        return --t2 <= 0 && n2(r2), t2 >= 0;
      };
    }, true), this;
  }
  until(e2, t2) {
    return St(this._ctx, function(n2, r2, s2) {
      return !e2(n2.value) || (r2(s2), t2);
    }), this;
  }
  first(e2) {
    return this.limit(1).toArray(function(e3) {
      return e3[0];
    }).then(e2);
  }
  last(e2) {
    return this.reverse().first(e2);
  }
  filter(e2) {
    var t2, n2;
    return St(this._ctx, function(t3) {
      return e2(t3.value);
    }), t2 = this._ctx, n2 = e2, t2.isMatch = _t(t2.isMatch, n2), this;
  }
  and(e2) {
    return this.filter(e2);
  }
  or(e2) {
    return new this.db.WhereClause(this._ctx.table, e2, this);
  }
  reverse() {
    return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(e2) {
    var t2 = this._ctx;
    return t2.keysOnly = !t2.isMatch, this.each(function(t3, n2) {
      e2(n2.key, n2);
    });
  }
  eachUniqueKey(e2) {
    return this._ctx.unique = "unique", this.eachKey(e2);
  }
  eachPrimaryKey(e2) {
    var t2 = this._ctx;
    return t2.keysOnly = !t2.isMatch, this.each(function(t3, n2) {
      e2(n2.primaryKey, n2);
    });
  }
  keys(e2) {
    var t2 = this._ctx;
    t2.keysOnly = !t2.isMatch;
    var n2 = [];
    return this.each(function(e3, t3) {
      n2.push(t3.key);
    }).then(function() {
      return n2;
    }).then(e2);
  }
  primaryKeys(e2) {
    var t2 = this._ctx;
    if ("next" === t2.dir && Ot(t2, true) && t2.limit > 0)
      return this._read((e3) => {
        var n3 = Ct(t2, t2.table.core.schema);
        return t2.table.core.query({ trans: e3, values: false, limit: t2.limit, query: { index: n3, range: t2.range } });
      }).then(({ result: e3 }) => e3).then(e2);
    t2.keysOnly = !t2.isMatch;
    var n2 = [];
    return this.each(function(e3, t3) {
      n2.push(t3.primaryKey);
    }).then(function() {
      return n2;
    }).then(e2);
  }
  uniqueKeys(e2) {
    return this._ctx.unique = "unique", this.keys(e2);
  }
  firstKey(e2) {
    return this.limit(1).keys(function(e3) {
      return e3[0];
    }).then(e2);
  }
  lastKey(e2) {
    return this.reverse().firstKey(e2);
  }
  distinct() {
    var e2 = this._ctx, t2 = e2.index && e2.table.schema.idxByName[e2.index];
    if (!t2 || !t2.multi)
      return this;
    var n2 = {};
    return St(this._ctx, function(e3) {
      var t3 = e3.primaryKey.toString(), r2 = o(n2, t3);
      return n2[t3] = true, !r2;
    }), this;
  }
  modify(e2) {
    var n2 = this._ctx;
    return this._write((r2) => {
      var s2;
      if ("function" == typeof e2)
        s2 = e2;
      else {
        var i2 = t(e2), o2 = i2.length;
        s2 = function(t2) {
          for (var n3 = false, r3 = 0; r3 < o2; ++r3) {
            var s3 = i2[r3], a3 = e2[s3];
            b(t2, s3) !== a3 && (_(t2, s3, a3), n3 = true);
          }
          return n3;
        };
      }
      const a2 = n2.table.core, { outbound: u2, extractKey: l2 } = a2.schema.primaryKey, c2 = this.db._options.modifyChunkSize || 200, h2 = [];
      let d2 = 0;
      const f2 = [], p2 = (e3, n3) => {
        const { failures: r3, numFailures: s3 } = n3;
        d2 += e3 - s3;
        for (let e4 of t(r3))
          h2.push(r3[e4]);
      };
      return this.clone().primaryKeys().then((t2) => {
        const i3 = (o3) => {
          const h3 = Math.min(c2, t2.length - o3);
          return a2.getMany({ trans: r2, keys: t2.slice(o3, o3 + h3), cache: "immutable" }).then((d3) => {
            const f3 = [], y2 = [], m2 = u2 ? [] : null, v2 = [];
            for (let e3 = 0; e3 < h3; ++e3) {
              const n3 = d3[e3], r3 = { value: O(n3), primKey: t2[o3 + e3] };
              false !== s2.call(r3, r3.value, r3) && (null == r3.value ? v2.push(t2[o3 + e3]) : u2 || 0 === Bt(l2(n3), l2(r3.value)) ? (y2.push(r3.value), u2 && m2.push(t2[o3 + e3])) : (v2.push(t2[o3 + e3]), f3.push(r3.value)));
            }
            const g2 = Ot(n2) && n2.limit === 1 / 0 && ("function" != typeof e2 || e2 === Mt) && { index: n2.index, range: n2.range };
            return Promise.resolve(f3.length > 0 && a2.mutate({ trans: r2, type: "add", values: f3 }).then((e3) => {
              for (let t3 in e3.failures)
                v2.splice(parseInt(t3), 1);
              p2(f3.length, e3);
            })).then(() => (y2.length > 0 || g2 && "object" == typeof e2) && a2.mutate({ trans: r2, type: "put", keys: m2, values: y2, criteria: g2, changeSpec: "function" != typeof e2 && e2 }).then((e3) => p2(y2.length, e3))).then(() => (v2.length > 0 || g2 && e2 === Mt) && a2.mutate({ trans: r2, type: "delete", keys: v2, criteria: g2 }).then((e3) => p2(v2.length, e3))).then(() => t2.length > o3 + h3 && i3(o3 + c2));
          });
        };
        return i3(0).then(() => {
          if (h2.length > 0)
            throw new z("Error modifying one or more objects", h2, d2, f2);
          return t2.length;
        });
      });
    });
  }
  delete() {
    var e2 = this._ctx, t2 = e2.range;
    return Ot(e2) && (e2.isPrimKey && !gt$2 || 3 === t2.type) ? this._write((n2) => {
      const { primaryKey: r2 } = e2.table.core.schema, s2 = t2;
      return e2.table.core.count({ trans: n2, query: { index: r2, range: s2 } }).then((t3) => e2.table.core.mutate({ trans: n2, type: "deleteRange", range: s2 }).then(({ failures: e3, lastResult: n3, results: r3, numFailures: s3 }) => {
        if (s3)
          throw new z("Could not delete some values", Object.keys(e3).map((t4) => e3[t4]), t3 - s3);
        return t3 - s3;
      }));
    }) : this.modify(Mt);
  }
}
const Mt = (e2, t2) => t2.value = null;
function Nt(e2, t2) {
  return e2 < t2 ? -1 : e2 === t2 ? 0 : 1;
}
function qt(e2, t2) {
  return e2 > t2 ? -1 : e2 === t2 ? 0 : 1;
}
function $t(e2, t2, n2) {
  var r2 = e2 instanceof zt ? new e2.Collection(e2) : e2;
  return r2._ctx.error = n2 ? new n2(t2) : new TypeError(t2), r2;
}
function Ut(e2) {
  return new e2.Collection(e2, () => Yt("")).limit(0);
}
function Lt(e2, t2, n2, r2, s2, i2) {
  for (var o2 = Math.min(e2.length, r2.length), a2 = -1, u2 = 0; u2 < o2; ++u2) {
    var l2 = t2[u2];
    if (l2 !== r2[u2])
      return s2(e2[u2], n2[u2]) < 0 ? e2.substr(0, u2) + n2[u2] + n2.substr(u2 + 1) : s2(e2[u2], r2[u2]) < 0 ? e2.substr(0, u2) + r2[u2] + n2.substr(u2 + 1) : a2 >= 0 ? e2.substr(0, a2) + t2[a2] + n2.substr(a2 + 1) : null;
    s2(e2[u2], l2) < 0 && (a2 = u2);
  }
  return o2 < r2.length && "next" === i2 ? e2 + n2.substr(e2.length) : o2 < e2.length && "prev" === i2 ? e2.substr(0, n2.length) : a2 < 0 ? null : e2.substr(0, a2) + r2[a2] + n2.substr(a2 + 1);
}
function Vt(e2, t2, n2, r2) {
  var s2, i2, o2, a2, u2, l2, c2, h2 = n2.length;
  if (!n2.every((e3) => "string" == typeof e3))
    return $t(e2, "String expected.");
  function d2(e3) {
    s2 = function(e4) {
      return "next" === e4 ? (e5) => e5.toUpperCase() : (e5) => e5.toLowerCase();
    }(e3), i2 = function(e4) {
      return "next" === e4 ? (e5) => e5.toLowerCase() : (e5) => e5.toUpperCase();
    }(e3), o2 = "next" === e3 ? Nt : qt;
    var t3 = n2.map(function(e4) {
      return { lower: i2(e4), upper: s2(e4) };
    }).sort(function(e4, t4) {
      return o2(e4.lower, t4.lower);
    });
    a2 = t3.map(function(e4) {
      return e4.upper;
    }), u2 = t3.map(function(e4) {
      return e4.lower;
    }), l2 = e3, c2 = "next" === e3 ? "" : r2;
  }
  d2("next");
  var f2 = new e2.Collection(e2, () => Wt(a2[0], u2[h2 - 1] + r2));
  f2._ondirectionchange = function(e3) {
    d2(e3);
  };
  var p2 = 0;
  return f2._addAlgorithm(function(e3, n3, r3) {
    var s3 = e3.key;
    if ("string" != typeof s3)
      return false;
    var d3 = i2(s3);
    if (t2(d3, u2, p2))
      return true;
    for (var f3 = null, y2 = p2; y2 < h2; ++y2) {
      var m2 = Lt(s3, d3, a2[y2], u2[y2], o2, l2);
      null === m2 && null === f3 ? p2 = y2 + 1 : (null === f3 || o2(f3, m2) > 0) && (f3 = m2);
    }
    return n3(null !== f3 ? function() {
      e3.continue(f3 + c2);
    } : r3), false;
  }), f2;
}
function Wt(e2, t2, n2, r2) {
  return { type: 2, lower: e2, upper: t2, lowerOpen: n2, upperOpen: r2 };
}
function Yt(e2) {
  return { type: 1, lower: e2, upper: e2 };
}
class zt {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(e2, t2, n2, r2) {
    n2 = false !== n2, r2 = true === r2;
    try {
      return this._cmp(e2, t2) > 0 || 0 === this._cmp(e2, t2) && (n2 || r2) && (!n2 || !r2) ? Ut(this) : new this.Collection(this, () => Wt(e2, t2, !n2, !r2));
    } catch (e3) {
      return $t(this, pt);
    }
  }
  equals(e2) {
    return null == e2 ? $t(this, pt) : new this.Collection(this, () => Yt(e2));
  }
  above(e2) {
    return null == e2 ? $t(this, pt) : new this.Collection(this, () => Wt(e2, void 0, true));
  }
  aboveOrEqual(e2) {
    return null == e2 ? $t(this, pt) : new this.Collection(this, () => Wt(e2, void 0, false));
  }
  below(e2) {
    return null == e2 ? $t(this, pt) : new this.Collection(this, () => Wt(void 0, e2, false, true));
  }
  belowOrEqual(e2) {
    return null == e2 ? $t(this, pt) : new this.Collection(this, () => Wt(void 0, e2));
  }
  startsWith(e2) {
    return "string" != typeof e2 ? $t(this, "String expected.") : this.between(e2, e2 + ft, true, true);
  }
  startsWithIgnoreCase(e2) {
    return "" === e2 ? this.startsWith(e2) : Vt(this, (e3, t2) => 0 === e3.indexOf(t2[0]), [e2], ft);
  }
  equalsIgnoreCase(e2) {
    return Vt(this, (e3, t2) => e3 === t2[0], [e2], "");
  }
  anyOfIgnoreCase() {
    var e2 = B.apply(I, arguments);
    return 0 === e2.length ? Ut(this) : Vt(this, (e3, t2) => -1 !== t2.indexOf(e3), e2, "");
  }
  startsWithAnyOfIgnoreCase() {
    var e2 = B.apply(I, arguments);
    return 0 === e2.length ? Ut(this) : Vt(this, (e3, t2) => t2.some((t3) => 0 === e3.indexOf(t3)), e2, ft);
  }
  anyOf() {
    const e2 = B.apply(I, arguments);
    let t2 = this._cmp;
    try {
      e2.sort(t2);
    } catch (e3) {
      return $t(this, pt);
    }
    if (0 === e2.length)
      return Ut(this);
    const n2 = new this.Collection(this, () => Wt(e2[0], e2[e2.length - 1]));
    n2._ondirectionchange = (n3) => {
      t2 = "next" === n3 ? this._ascending : this._descending, e2.sort(t2);
    };
    let r2 = 0;
    return n2._addAlgorithm((n3, s2, i2) => {
      const o2 = n3.key;
      for (; t2(o2, e2[r2]) > 0; )
        if (++r2, r2 === e2.length)
          return s2(i2), false;
      return 0 === t2(o2, e2[r2]) || (s2(() => {
        n3.continue(e2[r2]);
      }), false);
    }), n2;
  }
  notEqual(e2) {
    return this.inAnyRange([[-(1 / 0), e2], [e2, this.db._maxKey]], { includeLowers: false, includeUppers: false });
  }
  noneOf() {
    const e2 = B.apply(I, arguments);
    if (0 === e2.length)
      return new this.Collection(this);
    try {
      e2.sort(this._ascending);
    } catch (e3) {
      return $t(this, pt);
    }
    const t2 = e2.reduce((e3, t3) => e3 ? e3.concat([[e3[e3.length - 1][1], t3]]) : [[-(1 / 0), t3]], null);
    return t2.push([e2[e2.length - 1], this.db._maxKey]), this.inAnyRange(t2, { includeLowers: false, includeUppers: false });
  }
  inAnyRange(e2, t2) {
    const n2 = this._cmp, r2 = this._ascending, s2 = this._descending, i2 = this._min, o2 = this._max;
    if (0 === e2.length)
      return Ut(this);
    if (!e2.every((e3) => void 0 !== e3[0] && void 0 !== e3[1] && r2(e3[0], e3[1]) <= 0))
      return $t(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", X.InvalidArgument);
    const a2 = !t2 || false !== t2.includeLowers, u2 = t2 && true === t2.includeUppers;
    let l2, c2 = r2;
    function h2(e3, t3) {
      return c2(e3[0], t3[0]);
    }
    try {
      l2 = e2.reduce(function(e3, t3) {
        let r3 = 0, s3 = e3.length;
        for (; r3 < s3; ++r3) {
          const s4 = e3[r3];
          if (n2(t3[0], s4[1]) < 0 && n2(t3[1], s4[0]) > 0) {
            s4[0] = i2(s4[0], t3[0]), s4[1] = o2(s4[1], t3[1]);
            break;
          }
        }
        return r3 === s3 && e3.push(t3), e3;
      }, []), l2.sort(h2);
    } catch (e3) {
      return $t(this, pt);
    }
    let d2 = 0;
    const f2 = u2 ? (e3) => r2(e3, l2[d2][1]) > 0 : (e3) => r2(e3, l2[d2][1]) >= 0, p2 = a2 ? (e3) => s2(e3, l2[d2][0]) > 0 : (e3) => s2(e3, l2[d2][0]) >= 0;
    let y2 = f2;
    const m2 = new this.Collection(this, () => Wt(l2[0][0], l2[l2.length - 1][1], !a2, !u2));
    return m2._ondirectionchange = (e3) => {
      "next" === e3 ? (y2 = f2, c2 = r2) : (y2 = p2, c2 = s2), l2.sort(h2);
    }, m2._addAlgorithm((e3, t3, n3) => {
      for (var s3 = e3.key; y2(s3); )
        if (++d2, d2 === l2.length)
          return t3(n3), false;
      return !!function(e4) {
        return !f2(e4) && !p2(e4);
      }(s3) || (0 === this._cmp(s3, l2[d2][1]) || 0 === this._cmp(s3, l2[d2][0]) || t3(() => {
        c2 === r2 ? e3.continue(l2[d2][0]) : e3.continue(l2[d2][1]);
      }), false);
    }), m2;
  }
  startsWithAnyOf() {
    const e2 = B.apply(I, arguments);
    return e2.every((e3) => "string" == typeof e3) ? 0 === e2.length ? Ut(this) : this.inAnyRange(e2.map((e3) => [e3, e3 + ft])) : $t(this, "startsWithAnyOf() only works with strings");
  }
}
function Gt(e2) {
  return We(function(t2) {
    return Ht(t2), e2(t2.target.error), false;
  });
}
function Ht(e2) {
  e2.stopPropagation && e2.stopPropagation(), e2.preventDefault && e2.preventDefault();
}
const Qt = Pt(null, "storagemutated");
class Xt {
  _lock() {
    return m(!Ke.global), ++this._reculock, 1 !== this._reculock || Ke.global || (Ke.lockOwnerFor = this), this;
  }
  _unlock() {
    if (m(!Ke.global), 0 == --this._reculock)
      for (Ke.global || (Ke.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var e2 = this._blockedFuncs.shift();
        try {
          ot(e2[1], e2[0]);
        } catch (e3) {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && Ke.lockOwnerFor !== this;
  }
  create(e2) {
    if (!this.mode)
      return this;
    const t2 = this.db.idbdb, n2 = this.db._state.dbOpenError;
    if (m(!this.idbtrans), !e2 && !t2)
      switch (n2 && n2.name) {
        case "DatabaseClosedError":
          throw new X.DatabaseClosed(n2);
        case "MissingAPIError":
          throw new X.MissingAPI(n2.message, n2);
        default:
          throw new X.OpenFailed(n2);
      }
    if (!this.active)
      throw new X.TransactionInactive();
    return m(null === this._completion._state), (e2 = this.idbtrans = e2 || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : t2.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = We((t3) => {
      Ht(t3), this._reject(e2.error);
    }), e2.onabort = We((t3) => {
      Ht(t3), this.active && this._reject(new X.Abort(e2.error)), this.active = false, this.on("abort").fire(t3);
    }), e2.oncomplete = We(() => {
      this.active = false, this._resolve(), "mutatedParts" in e2 && Qt.storagemutated.fire(e2.mutatedParts);
    }), this;
  }
  _promise(e2, t2, n2) {
    if ("readwrite" === e2 && "readwrite" !== this.mode)
      return ht(new X.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return ht(new X.TransactionInactive());
    if (this._locked())
      return new Ce((r3, s2) => {
        this._blockedFuncs.push([() => {
          this._promise(e2, t2, n2).then(r3, s2);
        }, Ke]);
      });
    if (n2)
      return Je(() => {
        var e3 = new Ce((e4, n3) => {
          this._lock();
          const r3 = t2(e4, n3, this);
          r3 && r3.then && r3.then(e4, n3);
        });
        return e3.finally(() => this._unlock()), e3._lib = true, e3;
      });
    var r2 = new Ce((e3, n3) => {
      var r3 = t2(e3, n3, this);
      r3 && r3.then && r3.then(e3, n3);
    });
    return r2._lib = true, r2;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(e2) {
    var t2 = this._root();
    const n2 = Ce.resolve(e2);
    if (t2._waitingFor)
      t2._waitingFor = t2._waitingFor.then(() => n2);
    else {
      t2._waitingFor = n2, t2._waitingQueue = [];
      var r2 = t2.idbtrans.objectStore(t2.storeNames[0]);
      !function e3() {
        for (++t2._spinCount; t2._waitingQueue.length; )
          t2._waitingQueue.shift()();
        t2._waitingFor && (r2.get(-1 / 0).onsuccess = e3);
      }();
    }
    var s2 = t2._waitingFor;
    return new Ce((e3, r3) => {
      n2.then((n3) => t2._waitingQueue.push(We(e3.bind(null, n3))), (e4) => t2._waitingQueue.push(We(r3.bind(null, e4)))).finally(() => {
        t2._waitingFor === s2 && (t2._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new X.Abort()));
  }
  table(e2) {
    const t2 = this._memoizedTables || (this._memoizedTables = {});
    if (o(t2, e2))
      return t2[e2];
    const n2 = this.schema[e2];
    if (!n2)
      throw new X.NotFound("Table " + e2 + " not part of transaction");
    const r2 = new this.db.Table(e2, n2, this);
    return r2.core = this.db.core.table(e2), t2[e2] = r2, r2;
  }
}
function Jt(e2, t2, n2, r2, s2, i2, o2) {
  return { name: e2, keyPath: t2, unique: n2, multi: r2, auto: s2, compound: i2, src: (n2 && !o2 ? "&" : "") + (r2 ? "*" : "") + (s2 ? "++" : "") + Zt(t2) };
}
function Zt(e2) {
  return "string" == typeof e2 ? e2 : e2 ? "[" + [].join.call(e2, "+") + "]" : "";
}
function en(e2, t2, n2) {
  return { name: e2, primKey: t2, indexes: n2, mappedClass: null, idxByName: g(n2, (e3) => [e3.name, e3]) };
}
let tn = (e2) => {
  try {
    return e2.only([[]]), tn = () => [[]], [[]];
  } catch (e3) {
    return tn = () => ft, ft;
  }
};
function nn(e2) {
  return null == e2 ? () => {
  } : "string" == typeof e2 ? function(e3) {
    return 1 === e3.split(".").length ? (t2) => t2[e3] : (t2) => b(t2, e3);
  }(e2) : (t2) => b(t2, e2);
}
function rn(e2) {
  return [].slice.call(e2);
}
let sn = 0;
function on(e2) {
  return null == e2 ? ":id" : "string" == typeof e2 ? e2 : `[${e2.join("+")}]`;
}
function an(e2, t2, r2) {
  function s2(e3) {
    if (3 === e3.type)
      return null;
    if (4 === e3.type)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: n2, upper: r3, lowerOpen: s3, upperOpen: i3 } = e3;
    return void 0 === n2 ? void 0 === r3 ? null : t2.upperBound(r3, !!i3) : void 0 === r3 ? t2.lowerBound(n2, !!s3) : t2.bound(n2, r3, !!s3, !!i3);
  }
  const { schema: i2, hasGetAll: o2 } = function(e3, t3) {
    const r3 = rn(e3.objectStoreNames);
    return { schema: { name: e3.name, tables: r3.map((e4) => t3.objectStore(e4)).map((e4) => {
      const { keyPath: t4, autoIncrement: r4 } = e4, s3 = n(t4), i3 = null == t4, o3 = {}, a3 = { name: e4.name, primaryKey: { name: null, isPrimaryKey: true, outbound: i3, compound: s3, keyPath: t4, autoIncrement: r4, unique: true, extractKey: nn(t4) }, indexes: rn(e4.indexNames).map((t5) => e4.index(t5)).map((e5) => {
        const { name: t5, unique: r5, multiEntry: s4, keyPath: i4 } = e5, a4 = { name: t5, compound: n(i4), keyPath: i4, unique: r5, multiEntry: s4, extractKey: nn(i4) };
        return o3[on(i4)] = a4, a4;
      }), getIndexByKeyPath: (e5) => o3[on(e5)] };
      return o3[":id"] = a3.primaryKey, null != t4 && (o3[on(t4)] = a3.primaryKey), a3;
    }) }, hasGetAll: r3.length > 0 && "getAll" in t3.objectStore(r3[0]) && !("undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(e2, r2), a2 = i2.tables.map((e3) => function(e4) {
    const t3 = e4.name;
    return { name: t3, schema: e4, mutate: function({ trans: e5, type: n2, keys: r3, values: i3, range: o3 }) {
      return new Promise((a3, u3) => {
        a3 = We(a3);
        const l2 = e5.objectStore(t3), c2 = null == l2.keyPath, h2 = "put" === n2 || "add" === n2;
        if (!h2 && "delete" !== n2 && "deleteRange" !== n2)
          throw new Error("Invalid operation type: " + n2);
        const { length: d2 } = r3 || i3 || { length: 1 };
        if (r3 && i3 && r3.length !== i3.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (0 === d2)
          return a3({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let f2;
        const p2 = [], y2 = [];
        let m2 = 0;
        const v2 = (e6) => {
          ++m2, Ht(e6);
        };
        if ("deleteRange" === n2) {
          if (4 === o3.type)
            return a3({ numFailures: m2, failures: y2, results: [], lastResult: void 0 });
          3 === o3.type ? p2.push(f2 = l2.clear()) : p2.push(f2 = l2.delete(s2(o3)));
        } else {
          const [e6, t4] = h2 ? c2 ? [i3, r3] : [i3, null] : [r3, null];
          if (h2)
            for (let r4 = 0; r4 < d2; ++r4)
              p2.push(f2 = t4 && void 0 !== t4[r4] ? l2[n2](e6[r4], t4[r4]) : l2[n2](e6[r4])), f2.onerror = v2;
          else
            for (let t5 = 0; t5 < d2; ++t5)
              p2.push(f2 = l2[n2](e6[t5])), f2.onerror = v2;
        }
        const g2 = (e6) => {
          const t4 = e6.target.result;
          p2.forEach((e7, t5) => null != e7.error && (y2[t5] = e7.error)), a3({ numFailures: m2, failures: y2, results: "delete" === n2 ? r3 : p2.map((e7) => e7.result), lastResult: t4 });
        };
        f2.onerror = (e6) => {
          v2(e6), g2(e6);
        }, f2.onsuccess = g2;
      });
    }, getMany: ({ trans: e5, keys: n2 }) => new Promise((r3, s3) => {
      r3 = We(r3);
      const i3 = e5.objectStore(t3), o3 = n2.length, a3 = new Array(o3);
      let u3, l2 = 0, c2 = 0;
      const h2 = (e6) => {
        const t4 = e6.target;
        a3[t4._pos] = t4.result, ++c2 === l2 && r3(a3);
      }, d2 = Gt(s3);
      for (let e6 = 0; e6 < o3; ++e6)
        null != n2[e6] && (u3 = i3.get(n2[e6]), u3._pos = e6, u3.onsuccess = h2, u3.onerror = d2, ++l2);
      0 === l2 && r3(a3);
    }), get: ({ trans: e5, key: n2 }) => new Promise((r3, s3) => {
      r3 = We(r3);
      const i3 = e5.objectStore(t3).get(n2);
      i3.onsuccess = (e6) => r3(e6.target.result), i3.onerror = Gt(s3);
    }), query: function(e5) {
      return (n2) => new Promise((r3, i3) => {
        r3 = We(r3);
        const { trans: o3, values: a3, limit: u3, query: l2 } = n2, c2 = u3 === 1 / 0 ? void 0 : u3, { index: h2, range: d2 } = l2, f2 = o3.objectStore(t3), p2 = h2.isPrimaryKey ? f2 : f2.index(h2.name), y2 = s2(d2);
        if (0 === u3)
          return r3({ result: [] });
        if (e5) {
          const e6 = a3 ? p2.getAll(y2, c2) : p2.getAllKeys(y2, c2);
          e6.onsuccess = (e7) => r3({ result: e7.target.result }), e6.onerror = Gt(i3);
        } else {
          let e6 = 0;
          const t4 = a3 || !("openKeyCursor" in p2) ? p2.openCursor(y2) : p2.openKeyCursor(y2), n3 = [];
          t4.onsuccess = (s3) => {
            const i4 = t4.result;
            return i4 ? (n3.push(a3 ? i4.value : i4.primaryKey), ++e6 === u3 ? r3({ result: n3 }) : void i4.continue()) : r3({ result: n3 });
          }, t4.onerror = Gt(i3);
        }
      });
    }(o2), openCursor: function({ trans: e5, values: n2, query: r3, reverse: i3, unique: o3 }) {
      return new Promise((a3, u3) => {
        a3 = We(a3);
        const { index: l2, range: c2 } = r3, h2 = e5.objectStore(t3), d2 = l2.isPrimaryKey ? h2 : h2.index(l2.name), f2 = i3 ? o3 ? "prevunique" : "prev" : o3 ? "nextunique" : "next", p2 = n2 || !("openKeyCursor" in d2) ? d2.openCursor(s2(c2), f2) : d2.openKeyCursor(s2(c2), f2);
        p2.onerror = Gt(u3), p2.onsuccess = We((t4) => {
          const n3 = p2.result;
          if (!n3)
            return void a3(null);
          n3.___id = ++sn, n3.done = false;
          const r4 = n3.continue.bind(n3);
          let s3 = n3.continuePrimaryKey;
          s3 && (s3 = s3.bind(n3));
          const i4 = n3.advance.bind(n3), o4 = () => {
            throw new Error("Cursor not stopped");
          };
          n3.trans = e5, n3.stop = n3.continue = n3.continuePrimaryKey = n3.advance = () => {
            throw new Error("Cursor not started");
          }, n3.fail = We(u3), n3.next = function() {
            let e6 = 1;
            return this.start(() => e6-- ? this.continue() : this.stop()).then(() => this);
          }, n3.start = (e6) => {
            const t5 = new Promise((e7, t6) => {
              e7 = We(e7), p2.onerror = Gt(t6), n3.fail = t6, n3.stop = (t7) => {
                n3.stop = n3.continue = n3.continuePrimaryKey = n3.advance = o4, e7(t7);
              };
            }), a4 = () => {
              if (p2.result)
                try {
                  e6();
                } catch (e7) {
                  n3.fail(e7);
                }
              else
                n3.done = true, n3.start = () => {
                  throw new Error("Cursor behind last entry");
                }, n3.stop();
            };
            return p2.onsuccess = We((e7) => {
              p2.onsuccess = a4, a4();
            }), n3.continue = r4, n3.continuePrimaryKey = s3, n3.advance = i4, a4(), t5;
          }, a3(n3);
        }, u3);
      });
    }, count({ query: e5, trans: n2 }) {
      const { index: r3, range: i3 } = e5;
      return new Promise((e6, o3) => {
        const a3 = n2.objectStore(t3), u3 = r3.isPrimaryKey ? a3 : a3.index(r3.name), l2 = s2(i3), c2 = l2 ? u3.count(l2) : u3.count();
        c2.onsuccess = We((t4) => e6(t4.target.result)), c2.onerror = Gt(o3);
      });
    } };
  }(e3)), u2 = {};
  return a2.forEach((e3) => u2[e3.name] = e3), { stack: "dbcore", transaction: e2.transaction.bind(e2), table(e3) {
    if (!u2[e3])
      throw new Error(`Table '${e3}' not found`);
    return u2[e3];
  }, MIN_KEY: -1 / 0, MAX_KEY: tn(t2), schema: i2 };
}
function un({ _novip: e2 }, t2) {
  const n2 = t2.db, r2 = function(e3, t3, { IDBKeyRange: n3, indexedDB: r3 }, s2) {
    const i2 = function(e4, t4) {
      return t4.reduce((e5, { create: t5 }) => ({ ...e5, ...t5(e5) }), e4);
    }(an(t3, n3, s2), e3.dbcore);
    return { dbcore: i2 };
  }(e2._middlewares, n2, e2._deps, t2);
  e2.core = r2.dbcore, e2.tables.forEach((t3) => {
    const n3 = t3.name;
    e2.core.schema.tables.some((e3) => e3.name === n3) && (t3.core = e2.core.table(n3), e2[n3] instanceof e2.Table && (e2[n3].core = t3.core));
  });
}
function ln$1({ _novip: e2 }, t2, n2, r2) {
  n2.forEach((n3) => {
    const s2 = r2[n3];
    t2.forEach((t3) => {
      const r3 = d(t3, n3);
      (!r3 || "value" in r3 && void 0 === r3.value) && (t3 === e2.Transaction.prototype || t3 instanceof e2.Transaction ? l(t3, n3, { get() {
        return this.table(n3);
      }, set(e3) {
        u(this, n3, { value: e3, writable: true, configurable: true, enumerable: true });
      } }) : t3[n3] = new e2.Table(n3, s2));
    });
  });
}
function cn({ _novip: e2 }, t2) {
  t2.forEach((t3) => {
    for (let n2 in t3)
      t3[n2] instanceof e2.Table && delete t3[n2];
  });
}
function hn(e2, t2) {
  return e2._cfg.version - t2._cfg.version;
}
function dn(e2, n2, r2, s2) {
  const i2 = e2._dbSchema, o2 = e2._createTransaction("readwrite", e2._storeNames, i2);
  o2.create(r2), o2._completion.catch(s2);
  const a2 = o2._reject.bind(o2), u2 = Ke.transless || Ke;
  Je(() => {
    Ke.trans = o2, Ke.transless = u2, 0 === n2 ? (t(i2).forEach((e3) => {
      pn(r2, e3, i2[e3].primKey, i2[e3].indexes);
    }), un(e2, r2), Ce.follow(() => e2.on.populate.fire(o2)).catch(a2)) : function({ _novip: e3 }, n3, r3, s3) {
      const i3 = [], o3 = e3._versions;
      let a3 = e3._dbSchema = mn(e3, e3.idbdb, s3), u3 = false;
      function l2() {
        return i3.length ? Ce.resolve(i3.shift()(r3.idbtrans)).then(l2) : Ce.resolve();
      }
      return o3.filter((e4) => e4._cfg.version >= n3).forEach((o4) => {
        i3.push(() => {
          const i4 = a3, l3 = o4._cfg.dbschema;
          vn(e3, i4, s3), vn(e3, l3, s3), a3 = e3._dbSchema = l3;
          const c2 = fn(i4, l3);
          c2.add.forEach((e4) => {
            pn(s3, e4[0], e4[1].primKey, e4[1].indexes);
          }), c2.change.forEach((e4) => {
            if (e4.recreate)
              throw new X.Upgrade("Not yet support for changing primary key");
            {
              const t2 = s3.objectStore(e4.name);
              e4.add.forEach((e5) => yn(t2, e5)), e4.change.forEach((e5) => {
                t2.deleteIndex(e5.name), yn(t2, e5);
              }), e4.del.forEach((e5) => t2.deleteIndex(e5));
            }
          });
          const h2 = o4._cfg.contentUpgrade;
          if (h2 && o4._cfg.version > n3) {
            un(e3, s3), r3._memoizedTables = {}, u3 = true;
            let n4 = w(l3);
            c2.del.forEach((e4) => {
              n4[e4] = i4[e4];
            }), cn(e3, [e3.Transaction.prototype]), ln$1(e3, [e3.Transaction.prototype], t(n4), n4), r3.schema = n4;
            const o5 = T(h2);
            let a4;
            o5 && Ze();
            const d2 = Ce.follow(() => {
              if (a4 = h2(r3), a4 && o5) {
                var e4 = et.bind(null, null);
                a4.then(e4, e4);
              }
            });
            return a4 && "function" == typeof a4.then ? Ce.resolve(a4) : d2.then(() => a4);
          }
        }), i3.push((t2) => {
          if (!u3 || !vt) {
            !function(e4, t3) {
              [].slice.call(t3.db.objectStoreNames).forEach((n4) => null == e4[n4] && t3.db.deleteObjectStore(n4));
            }(o4._cfg.dbschema, t2);
          }
          cn(e3, [e3.Transaction.prototype]), ln$1(e3, [e3.Transaction.prototype], e3._storeNames, e3._dbSchema), r3.schema = e3._dbSchema;
        });
      }), l2().then(() => {
        var e4, n4;
        n4 = s3, t(e4 = a3).forEach((t2) => {
          n4.db.objectStoreNames.contains(t2) || pn(n4, t2, e4[t2].primKey, e4[t2].indexes);
        });
      });
    }(e2, n2, o2, r2).catch(a2);
  });
}
function fn(e2, t2) {
  const n2 = { del: [], add: [], change: [] };
  let r2;
  for (r2 in e2)
    t2[r2] || n2.del.push(r2);
  for (r2 in t2) {
    const s2 = e2[r2], i2 = t2[r2];
    if (s2) {
      const e3 = { name: r2, def: i2, recreate: false, del: [], add: [], change: [] };
      if ("" + (s2.primKey.keyPath || "") != "" + (i2.primKey.keyPath || "") || s2.primKey.auto !== i2.primKey.auto && !mt)
        e3.recreate = true, n2.change.push(e3);
      else {
        const t3 = s2.idxByName, r3 = i2.idxByName;
        let o2;
        for (o2 in t3)
          r3[o2] || e3.del.push(o2);
        for (o2 in r3) {
          const n3 = t3[o2], s3 = r3[o2];
          n3 ? n3.src !== s3.src && e3.change.push(s3) : e3.add.push(s3);
        }
        (e3.del.length > 0 || e3.add.length > 0 || e3.change.length > 0) && n2.change.push(e3);
      }
    } else
      n2.add.push([r2, i2]);
  }
  return n2;
}
function pn(e2, t2, n2, r2) {
  const s2 = e2.db.createObjectStore(t2, n2.keyPath ? { keyPath: n2.keyPath, autoIncrement: n2.auto } : { autoIncrement: n2.auto });
  return r2.forEach((e3) => yn(s2, e3)), s2;
}
function yn(e2, t2) {
  e2.createIndex(t2.name, t2.keyPath, { unique: t2.unique, multiEntry: t2.multi });
}
function mn(e2, t2, n2) {
  const r2 = {};
  return p(t2.objectStoreNames, 0).forEach((e3) => {
    const t3 = n2.objectStore(e3);
    let s2 = t3.keyPath;
    const i2 = Jt(Zt(s2), s2 || "", false, false, !!t3.autoIncrement, s2 && "string" != typeof s2, true), o2 = [];
    for (let e4 = 0; e4 < t3.indexNames.length; ++e4) {
      const n3 = t3.index(t3.indexNames[e4]);
      s2 = n3.keyPath;
      var a2 = Jt(n3.name, s2, !!n3.unique, !!n3.multiEntry, false, s2 && "string" != typeof s2, false);
      o2.push(a2);
    }
    r2[e3] = en(e3, i2, o2);
  }), r2;
}
function vn({ _novip: t2 }, n2, r2) {
  const s2 = r2.db.objectStoreNames;
  for (let e2 = 0; e2 < s2.length; ++e2) {
    const i2 = s2[e2], o2 = r2.objectStore(i2);
    t2._hasGetAll = "getAll" in o2;
    for (let e3 = 0; e3 < o2.indexNames.length; ++e3) {
      const t3 = o2.indexNames[e3], r3 = o2.index(t3).keyPath, s3 = "string" == typeof r3 ? r3 : "[" + p(r3).join("+") + "]";
      if (n2[i2]) {
        const e4 = n2[i2].idxByName[s3];
        e4 && (e4.name = t3, delete n2[i2].idxByName[s3], n2[i2].idxByName[t3] = e4);
      }
    }
  }
  "undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && e.WorkerGlobalScope && e instanceof e.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (t2._hasGetAll = false);
}
class gn {
  _parseStoresSpec(e2, r2) {
    t(e2).forEach((t2) => {
      if (null !== e2[t2]) {
        var s2 = e2[t2].split(",").map((e3, t3) => {
          const r3 = (e3 = e3.trim()).replace(/([&*]|\+\+)/g, ""), s3 = /^\[/.test(r3) ? r3.match(/^\[(.*)\]$/)[1].split("+") : r3;
          return Jt(r3, s3 || null, /\&/.test(e3), /\*/.test(e3), /\+\+/.test(e3), n(s3), 0 === t3);
        }), i2 = s2.shift();
        if (i2.multi)
          throw new X.Schema("Primary key cannot be multi-valued");
        s2.forEach((e3) => {
          if (e3.auto)
            throw new X.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!e3.keyPath)
            throw new X.Schema("Index must have a name and cannot be an empty string");
        }), r2[t2] = en(t2, i2, s2);
      }
    });
  }
  stores(e2) {
    const n2 = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? r(this._cfg.storesSource, e2) : e2;
    const s2 = n2._versions, i2 = {};
    let o2 = {};
    return s2.forEach((e3) => {
      r(i2, e3._cfg.storesSource), o2 = e3._cfg.dbschema = {}, e3._parseStoresSpec(i2, o2);
    }), n2._dbSchema = o2, cn(n2, [n2._allTables, n2, n2.Transaction.prototype]), ln$1(n2, [n2._allTables, n2, n2.Transaction.prototype, this._cfg.tables], t(o2), o2), n2._storeNames = t(o2), this;
  }
  upgrade(e2) {
    return this._cfg.contentUpgrade = ue(this._cfg.contentUpgrade || ee, e2), this;
  }
}
function bn(e2, t2) {
  let n2 = e2._dbNamesDB;
  return n2 || (n2 = e2._dbNamesDB = new Un("__dbnames", { addons: [], indexedDB: e2, IDBKeyRange: t2 }), n2.version(1).stores({ dbnames: "name" })), n2.table("dbnames");
}
function _n(e2) {
  return e2 && "function" == typeof e2.databases;
}
function wn(e2) {
  return Je(function() {
    return Ke.letThrough = true, e2();
  });
}
function xn() {
  var e2;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(t2) {
    var n2 = function() {
      return indexedDB.databases().finally(t2);
    };
    e2 = setInterval(n2, 100), n2();
  }).finally(function() {
    return clearInterval(e2);
  }) : Promise.resolve();
}
function kn(e2) {
  const n2 = e2._state, { indexedDB: r2 } = e2._deps;
  if (n2.isBeingOpened || e2.idbdb)
    return n2.dbReadyPromise.then(() => n2.dbOpenError ? ht(n2.dbOpenError) : e2);
  R && (n2.openCanceller._stackHolder = q()), n2.isBeingOpened = true, n2.dbOpenError = null, n2.openComplete = false;
  const s2 = n2.openCanceller;
  function i2() {
    if (n2.openCanceller !== s2)
      throw new X.DatabaseClosed("db.open() was cancelled");
  }
  let o2 = n2.dbReadyResolve, a2 = null, u2 = false;
  return Ce.race([s2, ("undefined" == typeof navigator ? Ce.resolve() : xn()).then(() => new Ce((s3, o3) => {
    if (i2(), !r2)
      throw new X.MissingAPI();
    const l2 = e2.name, c2 = n2.autoSchema ? r2.open(l2) : r2.open(l2, Math.round(10 * e2.verno));
    if (!c2)
      throw new X.MissingAPI();
    c2.onerror = Gt(o3), c2.onblocked = We(e2._fireOnBlocked), c2.onupgradeneeded = We((t2) => {
      if (a2 = c2.transaction, n2.autoSchema && !e2._options.allowEmptyDB) {
        c2.onerror = Ht, a2.abort(), c2.result.close();
        const e3 = r2.deleteDatabase(l2);
        e3.onsuccess = e3.onerror = We(() => {
          o3(new X.NoSuchDatabase(`Database ${l2} doesnt exist`));
        });
      } else {
        a2.onerror = Gt(o3);
        var s4 = t2.oldVersion > Math.pow(2, 62) ? 0 : t2.oldVersion;
        u2 = s4 < 1, e2._novip.idbdb = c2.result, dn(e2, s4 / 10, a2, o3);
      }
    }, o3), c2.onsuccess = We(() => {
      a2 = null;
      const r3 = e2._novip.idbdb = c2.result, i3 = p(r3.objectStoreNames);
      if (i3.length > 0)
        try {
          const s4 = r3.transaction(1 === (o4 = i3).length ? o4[0] : o4, "readonly");
          n2.autoSchema ? function({ _novip: e3 }, n3, r4) {
            e3.verno = n3.version / 10;
            const s5 = e3._dbSchema = mn(0, n3, r4);
            e3._storeNames = p(n3.objectStoreNames, 0), ln$1(e3, [e3._allTables], t(s5), s5);
          }(e2, r3, s4) : (vn(e2, e2._dbSchema, s4), function(e3, t2) {
            const n3 = fn(mn(0, e3.idbdb, t2), e3._dbSchema);
            return !(n3.add.length || n3.change.some((e4) => e4.add.length || e4.change.length));
          }(e2, s4) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), un(e2, s4);
        } catch (e3) {
        }
      var o4;
      yt.push(e2), r3.onversionchange = We((t2) => {
        n2.vcFired = true, e2.on("versionchange").fire(t2);
      }), r3.onclose = We((t2) => {
        e2.on("close").fire(t2);
      }), u2 && function({ indexedDB: e3, IDBKeyRange: t2 }, n3) {
        !_n(e3) && "__dbnames" !== n3 && bn(e3, t2).put({ name: n3 }).catch(ee);
      }(e2._deps, l2), s3();
    }, o3);
  }))]).then(() => (i2(), n2.onReadyBeingFired = [], Ce.resolve(wn(() => e2.on.ready.fire(e2.vip))).then(function t2() {
    if (n2.onReadyBeingFired.length > 0) {
      let r3 = n2.onReadyBeingFired.reduce(ue, ee);
      return n2.onReadyBeingFired = [], Ce.resolve(wn(() => r3(e2.vip))).then(t2);
    }
  }))).finally(() => {
    n2.onReadyBeingFired = null, n2.isBeingOpened = false;
  }).then(() => e2).catch((t2) => {
    n2.dbOpenError = t2;
    try {
      a2 && a2.abort();
    } catch (e3) {
    }
    return s2 === n2.openCanceller && e2._close(), ht(t2);
  }).finally(() => {
    n2.openComplete = true, o2();
  });
}
function En(e2) {
  var t2 = (t3) => e2.next(t3), r2 = i2(t2), s2 = i2((t3) => e2.throw(t3));
  function i2(e3) {
    return (t3) => {
      var i3 = e3(t3), o2 = i3.value;
      return i3.done ? o2 : o2 && "function" == typeof o2.then ? o2.then(r2, s2) : n(o2) ? Promise.all(o2).then(r2, s2) : r2(o2);
    };
  }
  return i2(t2)();
}
function Pn(e2, t2, n2) {
  var r2 = arguments.length;
  if (r2 < 2)
    throw new X.InvalidArgument("Too few arguments");
  for (var s2 = new Array(r2 - 1); --r2; )
    s2[r2 - 1] = arguments[r2];
  n2 = s2.pop();
  var i2 = k(s2);
  return [e2, i2, n2];
}
function Kn(e2, t2, n2, r2, s2) {
  return Ce.resolve().then(() => {
    const i2 = Ke.transless || Ke, o2 = e2._createTransaction(t2, n2, e2._dbSchema, r2), a2 = { trans: o2, transless: i2 };
    if (r2)
      o2.idbtrans = r2.idbtrans;
    else
      try {
        o2.create(), e2._state.PR1398_maxLoop = 3;
      } catch (r3) {
        return r3.name === H.InvalidState && e2.isOpen() && --e2._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), e2._close(), e2.open().then(() => Kn(e2, t2, n2, null, s2))) : ht(r3);
      }
    const u2 = T(s2);
    let l2;
    u2 && Ze();
    const c2 = Ce.follow(() => {
      if (l2 = s2.call(o2, o2), l2)
        if (u2) {
          var e3 = et.bind(null, null);
          l2.then(e3, e3);
        } else
          "function" == typeof l2.next && "function" == typeof l2.throw && (l2 = En(l2));
    }, a2);
    return (l2 && "function" == typeof l2.then ? Ce.resolve(l2).then((e3) => o2.active ? e3 : ht(new X.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : c2.then(() => l2)).then((e3) => (r2 && o2._resolve(), o2._completion.then(() => e3))).catch((e3) => (o2._reject(e3), ht(e3)));
  });
}
function On(e2, t2, r2) {
  const s2 = n(e2) ? e2.slice() : [e2];
  for (let e3 = 0; e3 < r2; ++e3)
    s2.push(t2);
  return s2;
}
const Sn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e2) {
  return { ...e2, table(t2) {
    const n2 = e2.table(t2), { schema: r2 } = n2, s2 = {}, i2 = [];
    function o2(e3, t3, n3) {
      const r3 = on(e3), a3 = s2[r3] = s2[r3] || [], u3 = null == e3 ? 0 : "string" == typeof e3 ? 1 : e3.length, l3 = t3 > 0, c2 = { ...n3, isVirtual: l3, keyTail: t3, keyLength: u3, extractKey: nn(e3), unique: !l3 && n3.unique };
      if (a3.push(c2), c2.isPrimaryKey || i2.push(c2), u3 > 1) {
        o2(2 === u3 ? e3[0] : e3.slice(0, u3 - 1), t3 + 1, n3);
      }
      return a3.sort((e4, t4) => e4.keyTail - t4.keyTail), c2;
    }
    const a2 = o2(r2.primaryKey.keyPath, 0, r2.primaryKey);
    s2[":id"] = [a2];
    for (const e3 of r2.indexes)
      o2(e3.keyPath, 0, e3);
    function u2(t3) {
      const n3 = t3.query.index;
      return n3.isVirtual ? { ...t3, query: { index: n3, range: (r3 = t3.query.range, s3 = n3.keyTail, { type: 1 === r3.type ? 2 : r3.type, lower: On(r3.lower, r3.lowerOpen ? e2.MAX_KEY : e2.MIN_KEY, s3), lowerOpen: true, upper: On(r3.upper, r3.upperOpen ? e2.MIN_KEY : e2.MAX_KEY, s3), upperOpen: true }) } } : t3;
      var r3, s3;
    }
    const l2 = { ...n2, schema: { ...r2, primaryKey: a2, indexes: i2, getIndexByKeyPath: function(e3) {
      const t3 = s2[on(e3)];
      return t3 && t3[0];
    } }, count: (e3) => n2.count(u2(e3)), query: (e3) => n2.query(u2(e3)), openCursor(t3) {
      const { keyTail: r3, isVirtual: s3, keyLength: i3 } = t3.query.index;
      if (!s3)
        return n2.openCursor(t3);
      return n2.openCursor(u2(t3)).then((n3) => n3 && function(n4) {
        const s4 = Object.create(n4, { continue: { value: function(s5) {
          null != s5 ? n4.continue(On(s5, t3.reverse ? e2.MAX_KEY : e2.MIN_KEY, r3)) : t3.unique ? n4.continue(n4.key.slice(0, i3).concat(t3.reverse ? e2.MIN_KEY : e2.MAX_KEY, r3)) : n4.continue();
        } }, continuePrimaryKey: { value(t4, s5) {
          n4.continuePrimaryKey(On(t4, e2.MAX_KEY, r3), s5);
        } }, primaryKey: { get: () => n4.primaryKey }, key: { get() {
          const e3 = n4.key;
          return 1 === i3 ? e3[0] : e3.slice(0, i3);
        } }, value: { get: () => n4.value } });
        return s4;
      }(n3));
    } };
    return l2;
  } };
} };
function An(e2, n2, r2, s2) {
  return r2 = r2 || {}, s2 = s2 || "", t(e2).forEach((t2) => {
    if (o(n2, t2)) {
      var i2 = e2[t2], a2 = n2[t2];
      if ("object" == typeof i2 && "object" == typeof a2 && i2 && a2) {
        const e3 = C(i2);
        e3 !== C(a2) ? r2[s2 + t2] = n2[t2] : "Object" === e3 ? An(i2, a2, r2, s2 + t2 + ".") : i2 !== a2 && (r2[s2 + t2] = n2[t2]);
      } else
        i2 !== a2 && (r2[s2 + t2] = n2[t2]);
    } else
      r2[s2 + t2] = void 0;
  }), t(n2).forEach((t2) => {
    o(e2, t2) || (r2[s2 + t2] = n2[t2]);
  }), r2;
}
const Cn = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (e2) => ({ ...e2, table(t2) {
  const n2 = e2.table(t2), { primaryKey: r2 } = n2.schema, s2 = { ...n2, mutate(e3) {
    const s3 = Ke.trans, { deleting: i2, creating: a2, updating: u2 } = s3.table(t2).hook;
    switch (e3.type) {
      case "add":
        if (a2.fire === ee)
          break;
        return s3._promise("readwrite", () => l2(e3), true);
      case "put":
        if (a2.fire === ee && u2.fire === ee)
          break;
        return s3._promise("readwrite", () => l2(e3), true);
      case "delete":
        if (i2.fire === ee)
          break;
        return s3._promise("readwrite", () => l2(e3), true);
      case "deleteRange":
        if (i2.fire === ee)
          break;
        return s3._promise("readwrite", () => function(e4) {
          return c2(e4.trans, e4.range, 1e4);
        }(e3), true);
    }
    return n2.mutate(e3);
    function l2(e4) {
      const t3 = Ke.trans, s4 = e4.keys || function(e5, t4) {
        return "delete" === t4.type ? t4.keys : t4.keys || t4.values.map(e5.extractKey);
      }(r2, e4);
      if (!s4)
        throw new Error("Keys missing");
      return "delete" !== (e4 = "add" === e4.type || "put" === e4.type ? { ...e4, keys: s4 } : { ...e4 }).type && (e4.values = [...e4.values]), e4.keys && (e4.keys = [...e4.keys]), function(e5, t4, n3) {
        return "add" === t4.type ? Promise.resolve([]) : e5.getMany({ trans: t4.trans, keys: n3, cache: "immutable" });
      }(n2, e4, s4).then((l3) => {
        const c3 = s4.map((n3, s5) => {
          const c4 = l3[s5], h2 = { onerror: null, onsuccess: null };
          if ("delete" === e4.type)
            i2.fire.call(h2, n3, c4, t3);
          else if ("add" === e4.type || void 0 === c4) {
            const i3 = a2.fire.call(h2, n3, e4.values[s5], t3);
            null == n3 && null != i3 && (n3 = i3, e4.keys[s5] = n3, r2.outbound || _(e4.values[s5], r2.keyPath, n3));
          } else {
            const r3 = An(c4, e4.values[s5]), i3 = u2.fire.call(h2, r3, n3, c4, t3);
            if (i3) {
              const t4 = e4.values[s5];
              Object.keys(i3).forEach((e5) => {
                o(t4, e5) ? t4[e5] = i3[e5] : _(t4, e5, i3[e5]);
              });
            }
          }
          return h2;
        });
        return n2.mutate(e4).then(({ failures: t4, results: n3, numFailures: r3, lastResult: i3 }) => {
          for (let r4 = 0; r4 < s4.length; ++r4) {
            const i4 = n3 ? n3[r4] : s4[r4], o2 = c3[r4];
            null == i4 ? o2.onerror && o2.onerror(t4[r4]) : o2.onsuccess && o2.onsuccess("put" === e4.type && l3[r4] ? e4.values[r4] : i4);
          }
          return { failures: t4, results: n3, numFailures: r3, lastResult: i3 };
        }).catch((e5) => (c3.forEach((t4) => t4.onerror && t4.onerror(e5)), Promise.reject(e5)));
      });
    }
    function c2(e4, t3, s4) {
      return n2.query({ trans: e4, values: false, query: { index: r2, range: t3 }, limit: s4 }).then(({ result: n3 }) => l2({ type: "delete", keys: n3, trans: e4 }).then((r3) => r3.numFailures > 0 ? Promise.reject(r3.failures[0]) : n3.length < s4 ? { failures: [], numFailures: 0, lastResult: void 0 } : c2(e4, { ...t3, lower: n3[n3.length - 1], lowerOpen: true }, s4)));
    }
  } };
  return s2;
} }) };
function jn(e2, t2, n2) {
  try {
    if (!t2)
      return null;
    if (t2.keys.length < e2.length)
      return null;
    const r2 = [];
    for (let s2 = 0, i2 = 0; s2 < t2.keys.length && i2 < e2.length; ++s2)
      0 === Bt(t2.keys[s2], e2[i2]) && (r2.push(n2 ? O(t2.values[s2]) : t2.values[s2]), ++i2);
    return r2.length === e2.length ? r2 : null;
  } catch (e3) {
    return null;
  }
}
const Dn = { stack: "dbcore", level: -1, create: (e2) => ({ table: (t2) => {
  const n2 = e2.table(t2);
  return { ...n2, getMany: (e3) => {
    if (!e3.cache)
      return n2.getMany(e3);
    const t3 = jn(e3.keys, e3.trans._cache, "clone" === e3.cache);
    return t3 ? Ce.resolve(t3) : n2.getMany(e3).then((t4) => (e3.trans._cache = { keys: e3.keys, values: "clone" === e3.cache ? O(t4) : t4 }, t4));
  }, mutate: (e3) => ("add" !== e3.type && (e3.trans._cache = null), n2.mutate(e3)) };
} }) };
function In(e2) {
  return !("from" in e2);
}
const Bn = function(e2, t2) {
  if (!this) {
    const t3 = new Bn();
    return e2 && "d" in e2 && r(t3, e2), t3;
  }
  r(this, arguments.length ? { d: 1, from: e2, to: arguments.length > 1 ? t2 : e2 } : { d: 0 });
};
function Tn(e2, t2, n2) {
  const s2 = Bt(t2, n2);
  if (isNaN(s2))
    return;
  if (s2 > 0)
    throw RangeError();
  if (In(e2))
    return r(e2, { from: t2, to: n2, d: 1 });
  const i2 = e2.l, o2 = e2.r;
  if (Bt(n2, e2.from) < 0)
    return i2 ? Tn(i2, t2, n2) : e2.l = { from: t2, to: n2, d: 1, l: null, r: null }, Nn(e2);
  if (Bt(t2, e2.to) > 0)
    return o2 ? Tn(o2, t2, n2) : e2.r = { from: t2, to: n2, d: 1, l: null, r: null }, Nn(e2);
  Bt(t2, e2.from) < 0 && (e2.from = t2, e2.l = null, e2.d = o2 ? o2.d + 1 : 1), Bt(n2, e2.to) > 0 && (e2.to = n2, e2.r = null, e2.d = e2.l ? e2.l.d + 1 : 1);
  const a2 = !e2.r;
  i2 && !e2.l && Rn(e2, i2), o2 && a2 && Rn(e2, o2);
}
function Rn(e2, t2) {
  In(t2) || function e3(t3, { from: n2, to: r2, l: s2, r: i2 }) {
    Tn(t3, n2, r2), s2 && e3(t3, s2), i2 && e3(t3, i2);
  }(e2, t2);
}
function Fn(e2, t2) {
  const n2 = Mn(t2);
  let r2 = n2.next();
  if (r2.done)
    return false;
  let s2 = r2.value;
  const i2 = Mn(e2);
  let o2 = i2.next(s2.from), a2 = o2.value;
  for (; !r2.done && !o2.done; ) {
    if (Bt(a2.from, s2.to) <= 0 && Bt(a2.to, s2.from) >= 0)
      return true;
    Bt(s2.from, a2.from) < 0 ? s2 = (r2 = n2.next(a2.from)).value : a2 = (o2 = i2.next(s2.from)).value;
  }
  return false;
}
function Mn(e2) {
  let t2 = In(e2) ? null : { s: 0, n: e2 };
  return { next(e3) {
    const n2 = arguments.length > 0;
    for (; t2; )
      switch (t2.s) {
        case 0:
          if (t2.s = 1, n2)
            for (; t2.n.l && Bt(e3, t2.n.from) < 0; )
              t2 = { up: t2, n: t2.n.l, s: 1 };
          else
            for (; t2.n.l; )
              t2 = { up: t2, n: t2.n.l, s: 1 };
        case 1:
          if (t2.s = 2, !n2 || Bt(e3, t2.n.to) <= 0)
            return { value: t2.n, done: false };
        case 2:
          if (t2.n.r) {
            t2.s = 3, t2 = { up: t2, n: t2.n.r, s: 0 };
            continue;
          }
        case 3:
          t2 = t2.up;
      }
    return { done: true };
  } };
}
function Nn(e2) {
  var t2, n2;
  const r2 = ((null === (t2 = e2.r) || void 0 === t2 ? void 0 : t2.d) || 0) - ((null === (n2 = e2.l) || void 0 === n2 ? void 0 : n2.d) || 0), s2 = r2 > 1 ? "r" : r2 < -1 ? "l" : "";
  if (s2) {
    const t3 = "r" === s2 ? "l" : "r", n3 = { ...e2 }, r3 = e2[s2];
    e2.from = r3.from, e2.to = r3.to, e2[s2] = r3[s2], n3[s2] = r3[t3], e2[t3] = n3, n3.d = qn(n3);
  }
  e2.d = qn(e2);
}
function qn({ r: e2, l: t2 }) {
  return (e2 ? t2 ? Math.max(e2.d, t2.d) : e2.d : t2 ? t2.d : 0) + 1;
}
a(Bn.prototype, { add(e2) {
  return Rn(this, e2), this;
}, addKey(e2) {
  return Tn(this, e2, e2), this;
}, addKeys(e2) {
  return e2.forEach((e3) => Tn(this, e3, e3)), this;
}, [j]() {
  return Mn(this);
} });
const $n = { stack: "dbcore", level: 0, create: (e2) => {
  const r2 = e2.schema.name, s2 = new Bn(e2.MIN_KEY, e2.MAX_KEY);
  return { ...e2, table: (i2) => {
    const o2 = e2.table(i2), { schema: a2 } = o2, { primaryKey: u2 } = a2, { extractKey: l2, outbound: c2 } = u2, h2 = { ...o2, mutate: (e3) => {
      const t2 = e3.trans, u3 = t2.mutatedParts || (t2.mutatedParts = {}), l3 = (e4) => {
        const t3 = `idb://${r2}/${i2}/${e4}`;
        return u3[t3] || (u3[t3] = new Bn());
      }, c3 = l3(""), h3 = l3(":dels"), { type: d3 } = e3;
      let [f3, p2] = "deleteRange" === e3.type ? [e3.range] : "delete" === e3.type ? [e3.keys] : e3.values.length < 50 ? [[], e3.values] : [];
      const y2 = e3.trans._cache;
      return o2.mutate(e3).then((e4) => {
        if (n(f3)) {
          "delete" !== d3 && (f3 = e4.results), c3.addKeys(f3);
          const t3 = jn(f3, y2);
          t3 || "add" === d3 || h3.addKeys(f3), (t3 || p2) && function(e5, t4, r3, s3) {
            function i3(t5) {
              const i4 = e5(t5.name || "");
              function o3(e6) {
                return null != e6 ? t5.extractKey(e6) : null;
              }
              const a3 = (e6) => t5.multiEntry && n(e6) ? e6.forEach((e7) => i4.addKey(e7)) : i4.addKey(e6);
              (r3 || s3).forEach((e6, t6) => {
                const n2 = r3 && o3(r3[t6]), i5 = s3 && o3(s3[t6]);
                0 !== Bt(n2, i5) && (null != n2 && a3(n2), null != i5 && a3(i5));
              });
            }
            t4.indexes.forEach(i3);
          }(l3, a2, t3, p2);
        } else if (f3) {
          const e5 = { from: f3.lower, to: f3.upper };
          h3.add(e5), c3.add(e5);
        } else
          c3.add(s2), h3.add(s2), a2.indexes.forEach((e5) => l3(e5.name).add(s2));
        return e4;
      });
    } }, d2 = ({ query: { index: t2, range: n2 } }) => {
      var r3, s3;
      return [t2, new Bn(null !== (r3 = n2.lower) && void 0 !== r3 ? r3 : e2.MIN_KEY, null !== (s3 = n2.upper) && void 0 !== s3 ? s3 : e2.MAX_KEY)];
    }, f2 = { get: (e3) => [u2, new Bn(e3.key)], getMany: (e3) => [u2, new Bn().addKeys(e3.keys)], count: d2, query: d2, openCursor: d2 };
    return t(f2).forEach((e3) => {
      h2[e3] = function(t2) {
        const { subscr: n2 } = Ke;
        if (n2) {
          const a3 = (e4) => {
            const t3 = `idb://${r2}/${i2}/${e4}`;
            return n2[t3] || (n2[t3] = new Bn());
          }, u3 = a3(""), h3 = a3(":dels"), [d3, p2] = f2[e3](t2);
          if (a3(d3.name || "").add(p2), !d3.isPrimaryKey) {
            if ("count" !== e3) {
              const n3 = "query" === e3 && c2 && t2.values && o2.query({ ...t2, values: false });
              return o2[e3].apply(this, arguments).then((r3) => {
                if ("query" === e3) {
                  if (c2 && t2.values)
                    return n3.then(({ result: e5 }) => (u3.addKeys(e5), r3));
                  const e4 = t2.values ? r3.result.map(l2) : r3.result;
                  t2.values ? u3.addKeys(e4) : h3.addKeys(e4);
                } else if ("openCursor" === e3) {
                  const e4 = r3, n4 = t2.values;
                  return e4 && Object.create(e4, { key: { get: () => (h3.addKey(e4.primaryKey), e4.key) }, primaryKey: { get() {
                    const t3 = e4.primaryKey;
                    return h3.addKey(t3), t3;
                  } }, value: { get: () => (n4 && u3.addKey(e4.primaryKey), e4.value) } });
                }
                return r3;
              });
            }
            h3.add(s2);
          }
        }
        return o2[e3].apply(this, arguments);
      };
    }), h2;
  } };
} };
class Un {
  constructor(e2, t2) {
    this._middlewares = {}, this.verno = 0;
    const n2 = Un.dependencies;
    this._options = t2 = { addons: Un.addons, autoOpen: true, indexedDB: n2.indexedDB, IDBKeyRange: n2.IDBKeyRange, ...t2 }, this._deps = { indexedDB: t2.indexedDB, IDBKeyRange: t2.IDBKeyRange };
    const { addons: r2 } = t2;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const s2 = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: ee, dbReadyPromise: null, cancelOpen: ee, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3 };
    var i2;
    s2.dbReadyPromise = new Ce((e3) => {
      s2.dbReadyResolve = e3;
    }), s2.openCanceller = new Ce((e3, t3) => {
      s2.cancelOpen = t3;
    }), this._state = s2, this.name = e2, this.on = Pt(this, "populate", "blocked", "versionchange", "close", { ready: [ue, ee] }), this.on.ready.subscribe = y(this.on.ready.subscribe, (e3) => (t3, n3) => {
      Un.vip(() => {
        const r3 = this._state;
        if (r3.openComplete)
          r3.dbOpenError || Ce.resolve().then(t3), n3 && e3(t3);
        else if (r3.onReadyBeingFired)
          r3.onReadyBeingFired.push(t3), n3 && e3(t3);
        else {
          e3(t3);
          const r4 = this;
          n3 || e3(function e4() {
            r4.on.ready.unsubscribe(t3), r4.on.ready.unsubscribe(e4);
          });
        }
      });
    }), this.Collection = (i2 = this, Kt(Ft.prototype, function(e3, t3) {
      this.db = i2;
      let n3 = wt, r3 = null;
      if (t3)
        try {
          n3 = t3();
        } catch (e4) {
          r3 = e4;
        }
      const s3 = e3._ctx, o2 = s3.table, a2 = o2.hook.reading.fire;
      this._ctx = { table: o2, index: s3.index, isPrimKey: !s3.index || o2.schema.primKey.keyPath && s3.index === o2.schema.primKey.name, range: n3, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: r3, or: s3.or, valueMapper: a2 !== te ? a2 : null };
    })), this.Table = function(e3) {
      return Kt(Et.prototype, function(t3, n3, r3) {
        this.db = e3, this._tx = r3, this.name = t3, this.schema = n3, this.hook = e3._allTables[t3] ? e3._allTables[t3].hook : Pt(null, { creating: [se, ee], reading: [ne$2, te], updating: [oe, ee], deleting: [ie, ee] });
      });
    }(this), this.Transaction = function(e3) {
      return Kt(Xt.prototype, function(t3, n3, r3, s3, i3) {
        this.db = e3, this.mode = t3, this.storeNames = n3, this.schema = r3, this.chromeTransactionDurability = s3, this.idbtrans = null, this.on = Pt(this, "complete", "error", "abort"), this.parent = i3 || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Ce((e4, t4) => {
          this._resolve = e4, this._reject = t4;
        }), this._completion.then(() => {
          this.active = false, this.on.complete.fire();
        }, (e4) => {
          var t4 = this.active;
          return this.active = false, this.on.error.fire(e4), this.parent ? this.parent._reject(e4) : t4 && this.idbtrans && this.idbtrans.abort(), ht(e4);
        });
      });
    }(this), this.Version = function(e3) {
      return Kt(gn.prototype, function(t3) {
        this.db = e3, this._cfg = { version: t3, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(e3) {
      return Kt(zt.prototype, function(t3, n3, r3) {
        this.db = e3, this._ctx = { table: t3, index: ":id" === n3 ? null : n3, or: r3 };
        const s3 = e3._deps.indexedDB;
        if (!s3)
          throw new X.MissingAPI();
        this._cmp = this._ascending = s3.cmp.bind(s3), this._descending = (e4, t4) => s3.cmp(t4, e4), this._max = (e4, t4) => s3.cmp(e4, t4) > 0 ? e4 : t4, this._min = (e4, t4) => s3.cmp(e4, t4) < 0 ? e4 : t4, this._IDBKeyRange = e3._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (e3) => {
      e3.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (e3) => {
      !e3.newVersion || e3.newVersion < e3.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${e3.oldVersion / 10}`);
    }), this._maxKey = tn(t2.IDBKeyRange), this._createTransaction = (e3, t3, n3, r3) => new this.Transaction(e3, t3, n3, this._options.chromeTransactionDurability, r3), this._fireOnBlocked = (e3) => {
      this.on("blocked").fire(e3), yt.filter((e4) => e4.name === this.name && e4 !== this && !e4._state.vcFired).map((t3) => t3.on("versionchange").fire(e3));
    }, this.use(Sn), this.use(Cn), this.use($n), this.use(Dn), this.vip = Object.create(this, { _vip: { value: true } }), r2.forEach((e3) => e3(this));
  }
  version(e2) {
    if (isNaN(e2) || e2 < 0.1)
      throw new X.Type("Given version is not a positive number");
    if (e2 = Math.round(10 * e2) / 10, this.idbdb || this._state.isBeingOpened)
      throw new X.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, e2);
    const t2 = this._versions;
    var n2 = t2.filter((t3) => t3._cfg.version === e2)[0];
    return n2 || (n2 = new this.Version(e2), t2.push(n2), t2.sort(hn), n2.stores({}), this._state.autoSchema = false, n2);
  }
  _whenReady(e2) {
    return this.idbdb && (this._state.openComplete || Ke.letThrough || this._vip) ? e2() : new Ce((e3, t2) => {
      if (this._state.openComplete)
        return t2(new X.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void t2(new X.DatabaseClosed());
        this.open().catch(ee);
      }
      this._state.dbReadyPromise.then(e3, t2);
    }).then(e2);
  }
  use({ stack: e2, create: t2, level: n2, name: r2 }) {
    r2 && this.unuse({ stack: e2, name: r2 });
    const s2 = this._middlewares[e2] || (this._middlewares[e2] = []);
    return s2.push({ stack: e2, create: t2, level: null == n2 ? 10 : n2, name: r2 }), s2.sort((e3, t3) => e3.level - t3.level), this;
  }
  unuse({ stack: e2, name: t2, create: n2 }) {
    return e2 && this._middlewares[e2] && (this._middlewares[e2] = this._middlewares[e2].filter((e3) => n2 ? e3.create !== n2 : !!t2 && e3.name !== t2)), this;
  }
  open() {
    return kn(this);
  }
  _close() {
    const e2 = this._state, t2 = yt.indexOf(this);
    if (t2 >= 0 && yt.splice(t2, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch (e3) {
      }
      this._novip.idbdb = null;
    }
    e2.dbReadyPromise = new Ce((t3) => {
      e2.dbReadyResolve = t3;
    }), e2.openCanceller = new Ce((t3, n2) => {
      e2.cancelOpen = n2;
    });
  }
  close() {
    this._close();
    const e2 = this._state;
    this._options.autoOpen = false, e2.dbOpenError = new X.DatabaseClosed(), e2.isBeingOpened && e2.cancelOpen(e2.dbOpenError);
  }
  delete() {
    const e2 = arguments.length > 0, t2 = this._state;
    return new Ce((n2, r2) => {
      const s2 = () => {
        this.close();
        var e3 = this._deps.indexedDB.deleteDatabase(this.name);
        e3.onsuccess = We(() => {
          !function({ indexedDB: e4, IDBKeyRange: t3 }, n3) {
            !_n(e4) && "__dbnames" !== n3 && bn(e4, t3).delete(n3).catch(ee);
          }(this._deps, this.name), n2();
        }), e3.onerror = Gt(r2), e3.onblocked = this._fireOnBlocked;
      };
      if (e2)
        throw new X.InvalidArgument("Arguments not allowed in db.delete()");
      t2.isBeingOpened ? t2.dbReadyPromise.then(s2) : s2();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return null !== this.idbdb;
  }
  hasBeenClosed() {
    const e2 = this._state.dbOpenError;
    return e2 && "DatabaseClosed" === e2.name;
  }
  hasFailed() {
    return null !== this._state.dbOpenError;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return t(this._allTables).map((e2) => this._allTables[e2]);
  }
  transaction() {
    const e2 = Pn.apply(this, arguments);
    return this._transaction.apply(this, e2);
  }
  _transaction(e2, t2, n2) {
    let r2 = Ke.trans;
    r2 && r2.db === this && -1 === e2.indexOf("!") || (r2 = null);
    const s2 = -1 !== e2.indexOf("?");
    let i2, o2;
    e2 = e2.replace("!", "").replace("?", "");
    try {
      if (o2 = t2.map((e3) => {
        var t3 = e3 instanceof this.Table ? e3.name : e3;
        if ("string" != typeof t3)
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return t3;
      }), "r" == e2 || "readonly" === e2)
        i2 = "readonly";
      else {
        if ("rw" != e2 && "readwrite" != e2)
          throw new X.InvalidArgument("Invalid transaction mode: " + e2);
        i2 = "readwrite";
      }
      if (r2) {
        if ("readonly" === r2.mode && "readwrite" === i2) {
          if (!s2)
            throw new X.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          r2 = null;
        }
        r2 && o2.forEach((e3) => {
          if (r2 && -1 === r2.storeNames.indexOf(e3)) {
            if (!s2)
              throw new X.SubTransaction("Table " + e3 + " not included in parent transaction.");
            r2 = null;
          }
        }), s2 && r2 && !r2.active && (r2 = null);
      }
    } catch (e3) {
      return r2 ? r2._promise(null, (t3, n3) => {
        n3(e3);
      }) : ht(e3);
    }
    const a2 = Kn.bind(null, this, i2, o2, r2, n2);
    return r2 ? r2._promise(i2, a2, "lock") : Ke.trans ? ot(Ke.transless, () => this._whenReady(a2)) : this._whenReady(a2);
  }
  table(e2) {
    if (!o(this._allTables, e2))
      throw new X.InvalidTable(`Table ${e2} does not exist`);
    return this._allTables[e2];
  }
}
const Ln = "undefined" != typeof Symbol && "observable" in Symbol ? Symbol.observable : "@@observable";
class Vn {
  constructor(e2) {
    this._subscribe = e2;
  }
  subscribe(e2, t2, n2) {
    return this._subscribe(e2 && "function" != typeof e2 ? e2 : { next: e2, error: t2, complete: n2 });
  }
  [Ln]() {
    return this;
  }
}
function Wn(e2, n2) {
  return t(n2).forEach((t2) => {
    Rn(e2[t2] || (e2[t2] = new Bn()), n2[t2]);
  }), e2;
}
function Yn(e2) {
  return new Vn((n2) => {
    const r2 = T(e2);
    let s2 = false, i2 = {}, o2 = {};
    const a2 = { get closed() {
      return s2;
    }, unsubscribe: () => {
      s2 = true, Qt.storagemutated.unsubscribe(h2);
    } };
    n2.start && n2.start(a2);
    let u2 = false, l2 = false;
    function c2() {
      return t(o2).some((e3) => i2[e3] && Fn(i2[e3], o2[e3]));
    }
    const h2 = (e3) => {
      Wn(i2, e3), c2() && d2();
    }, d2 = () => {
      if (u2 || s2)
        return;
      i2 = {};
      const t2 = {}, f2 = function(t3) {
        r2 && Ze();
        const n3 = () => Je(e2, { subscr: t3, trans: null }), s3 = Ke.trans ? ot(Ke.transless, n3) : n3();
        return r2 && s3.then(et, et), s3;
      }(t2);
      l2 || (Qt("storagemutated", h2), l2 = true), u2 = true, Promise.resolve(f2).then((e3) => {
        u2 = false, s2 || (c2() ? d2() : (i2 = {}, o2 = t2, n2.next && n2.next(e3)));
      }, (e3) => {
        ["DatabaseClosedError", "AbortError"].includes(null == e3 ? void 0 : e3.name) || (u2 = false, n2.error && n2.error(e3), a2.unsubscribe());
      });
    };
    return d2(), a2;
  });
}
let zn;
try {
  zn = { indexedDB: e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB, IDBKeyRange: e.IDBKeyRange || e.webkitIDBKeyRange };
} catch (e2) {
  zn = { indexedDB: null, IDBKeyRange: null };
}
const Gn = Un;
function Hn(e2) {
  let t2 = Qn;
  try {
    Qn = true, Qt.storagemutated.fire(e2);
  } finally {
    Qn = t2;
  }
}
a(Gn, { ...Z, delete: (e2) => new Gn(e2, { addons: [] }).delete(), exists: (e2) => new Gn(e2, { addons: [] }).open().then((e3) => (e3.close(), true)).catch("NoSuchDatabaseError", () => false), getDatabaseNames(e2) {
  try {
    return function({ indexedDB: e3, IDBKeyRange: t2 }) {
      return _n(e3) ? Promise.resolve(e3.databases()).then((e4) => e4.map((e5) => e5.name).filter((e5) => "__dbnames" !== e5)) : bn(e3, t2).toCollection().primaryKeys();
    }(Gn.dependencies).then(e2);
  } catch (e3) {
    return ht(new X.MissingAPI());
  }
}, defineClass: () => function(e2) {
  r(this, e2);
}, ignoreTransaction: (e2) => Ke.trans ? ot(Ke.transless, e2) : e2(), vip: wn, async: function(e2) {
  return function() {
    try {
      var t2 = En(e2.apply(this, arguments));
      return t2 && "function" == typeof t2.then ? t2 : Ce.resolve(t2);
    } catch (e3) {
      return ht(e3);
    }
  };
}, spawn: function(e2, t2, n2) {
  try {
    var r2 = En(e2.apply(n2, t2 || []));
    return r2 && "function" == typeof r2.then ? r2 : Ce.resolve(r2);
  } catch (e3) {
    return ht(e3);
  }
}, currentTransaction: { get: () => Ke.trans || null }, waitFor: function(e2, t2) {
  const n2 = Ce.resolve("function" == typeof e2 ? Gn.ignoreTransaction(e2) : e2).timeout(t2 || 6e4);
  return Ke.trans ? Ke.trans.waitFor(n2) : n2;
}, Promise: Ce, debug: { get: () => R, set: (e2) => {
  F(e2, "dexie" === e2 ? () => true : bt);
} }, derive: c, extend: r, props: a, override: y, Events: Pt, on: Qt, liveQuery: Yn, extendObservabilitySet: Wn, getByKeyPath: b, setByKeyPath: _, delByKeyPath: function(e2, t2) {
  "string" == typeof t2 ? _(e2, t2, void 0) : "length" in t2 && [].map.call(t2, function(t3) {
    _(e2, t3, void 0);
  });
}, shallowClone: w, deepClone: O, getObjectDiff: An, cmp: Bt, asap: v, minKey: -(1 / 0), addons: [], connections: yt, errnames: H, dependencies: zn, semVer: "4.0.0-alpha.4", version: "4.0.0-alpha.4".split(".").map((e2) => parseInt(e2)).reduce((e2, t2, n2) => e2 + t2 / Math.pow(10, 2 * n2)) }), Gn.maxKey = tn(Gn.dependencies.IDBKeyRange), "undefined" != typeof dispatchEvent && "undefined" != typeof addEventListener && (Qt("storagemutated", (e2) => {
  if (!Qn) {
    let t2;
    mt ? (t2 = document.createEvent("CustomEvent"), t2.initCustomEvent("x-storagemutated-1", true, true, e2)) : t2 = new CustomEvent("x-storagemutated-1", { detail: e2 }), Qn = true, dispatchEvent(t2), Qn = false;
  }
}), addEventListener("x-storagemutated-1", ({ detail: e2 }) => {
  Qn || Hn(e2);
}));
let Qn = false;
if ("undefined" != typeof BroadcastChannel) {
  const e2 = new BroadcastChannel("x-storagemutated-1");
  "function" == typeof e2.unref && e2.unref(), Qt("storagemutated", (t2) => {
    Qn || e2.postMessage(t2);
  }), e2.onmessage = (e3) => {
    e3.data && Hn(e3.data);
  };
} else if ("undefined" != typeof self && "undefined" != typeof navigator) {
  Qt("storagemutated", (e3) => {
    try {
      Qn || ("undefined" != typeof localStorage && localStorage.setItem("x-storagemutated-1", JSON.stringify({ trig: Math.random(), changedParts: e3 })), "object" == typeof self.clients && [...self.clients.matchAll({ includeUncontrolled: true })].forEach((t2) => t2.postMessage({ type: "x-storagemutated-1", changedParts: e3 })));
    } catch (e4) {
    }
  }), "undefined" != typeof addEventListener && addEventListener("storage", (e3) => {
    if ("x-storagemutated-1" === e3.key) {
      const t2 = JSON.parse(e3.newValue);
      t2 && Hn(t2.changedParts);
    }
  });
  const e2 = self.document && navigator.serviceWorker;
  e2 && e2.addEventListener("message", function({ data: e3 }) {
    e3 && "x-storagemutated-1" === e3.type && Hn(e3.changedParts);
  });
}
Ce.rejectionMapper = function(e2, t2) {
  if (!e2 || e2 instanceof W || e2 instanceof TypeError || e2 instanceof SyntaxError || !e2.name || !J[e2.name])
    return e2;
  var n2 = new J[e2.name](t2 || e2.message, e2);
  return "stack" in e2 && l(n2, "stack", { get: function() {
    return this.inner.stack;
  } }), n2;
}, F(R, bt);
const dexie_min = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Dexie: Un,
  Entity: kt,
  RangeSet: Bn,
  cmp: Bt,
  default: Un,
  liveQuery: Yn,
  mergeRanges: Rn,
  rangesOverlap: Fn
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(dexie_min);
var rxStorageStatics = {};
var queryPlanner = {};
Object.defineProperty(queryPlanner, "__esModule", {
  value: true
});
queryPlanner.UPPER_BOUND_LOGICAL_OPERATORS = queryPlanner.LOWER_BOUND_LOGICAL_OPERATORS = queryPlanner.LOGICAL_OPERATORS = queryPlanner.INDEX_MIN = queryPlanner.INDEX_MAX = void 0;
queryPlanner.getMatcherQueryOpts = getMatcherQueryOpts;
queryPlanner.getQueryPlan = getQueryPlan;
queryPlanner.isSelectorSatisfiedByIndex = isSelectorSatisfiedByIndex;
queryPlanner.rateQueryPlan = rateQueryPlan;
var _utils$m = utils;
var _rxSchemaHelper$c = rxSchemaHelper;
var INDEX_MAX = String.fromCharCode(65535);
queryPlanner.INDEX_MAX = INDEX_MAX;
var INDEX_MIN = Number.MIN_VALUE;
queryPlanner.INDEX_MIN = INDEX_MIN;
function getQueryPlan(schema, query2) {
  var primaryPath = (0, _rxSchemaHelper$c.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);
  var selector = query2.selector;
  var indexes = schema.indexes ? schema.indexes.slice(0) : [];
  if (query2.index) {
    indexes = [query2.index];
  } else {
    indexes.push([primaryPath]);
  }
  var optimalSortIndex = query2.sort.map((sortField) => Object.keys(sortField)[0]);
  var optimalSortIndexCompareString = optimalSortIndex.join(",");
  var hasDescSorting = !!query2.sort.find((sortField) => Object.values(sortField)[0] === "desc");
  var currentBestQuality = -1;
  var currentBestQueryPlan;
  indexes.forEach((index) => {
    var inclusiveEnd = true;
    var inclusiveStart = true;
    var opts = index.map((indexField) => {
      var matcher = selector[indexField];
      var operators2 = matcher ? Object.keys(matcher) : [];
      var matcherOpts = {};
      if (!matcher || !operators2.length) {
        var startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;
        matcherOpts = {
          startKey,
          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,
          inclusiveStart: true,
          inclusiveEnd: true
        };
      } else {
        operators2.forEach((operator) => {
          if (LOGICAL_OPERATORS.has(operator)) {
            var operatorValue = matcher[operator];
            var partialOpts = getMatcherQueryOpts(operator, operatorValue);
            matcherOpts = Object.assign(matcherOpts, partialOpts);
          }
        });
      }
      if (typeof matcherOpts.startKey === "undefined") {
        matcherOpts.startKey = INDEX_MIN;
      }
      if (typeof matcherOpts.endKey === "undefined") {
        matcherOpts.endKey = INDEX_MAX;
      }
      if (typeof matcherOpts.inclusiveStart === "undefined") {
        matcherOpts.inclusiveStart = true;
      }
      if (typeof matcherOpts.inclusiveEnd === "undefined") {
        matcherOpts.inclusiveEnd = true;
      }
      if (inclusiveStart && !matcherOpts.inclusiveStart) {
        inclusiveStart = false;
      }
      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {
        inclusiveEnd = false;
      }
      return matcherOpts;
    });
    var queryPlan = {
      index,
      startKeys: opts.map((opt) => opt.startKey),
      endKeys: opts.map((opt) => opt.endKey),
      inclusiveEnd,
      inclusiveStart,
      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === index.join(","),
      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query2.selector)
    };
    var quality = rateQueryPlan(schema, query2, queryPlan);
    if (quality > 0 && quality > currentBestQuality || query2.index) {
      currentBestQuality = quality;
      currentBestQueryPlan = queryPlan;
    }
  });
  if (!currentBestQueryPlan) {
    currentBestQueryPlan = {
      index: [primaryPath],
      startKeys: [INDEX_MIN],
      endKeys: [INDEX_MAX],
      inclusiveEnd: true,
      inclusiveStart: true,
      sortFieldsSameAsIndexFields: !hasDescSorting && optimalSortIndexCompareString === primaryPath,
      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex([primaryPath], query2.selector)
    };
  }
  return currentBestQueryPlan;
}
var LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte", "$lt", "$lte"]);
queryPlanner.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
var LOWER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte"]);
queryPlanner.LOWER_BOUND_LOGICAL_OPERATORS = LOWER_BOUND_LOGICAL_OPERATORS;
var UPPER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$lt", "$lte"]);
queryPlanner.UPPER_BOUND_LOGICAL_OPERATORS = UPPER_BOUND_LOGICAL_OPERATORS;
function isSelectorSatisfiedByIndex(index, selector) {
  var selectorEntries = Object.entries(selector);
  var hasNonMatchingOperator = selectorEntries.find(([fieldName, operation]) => {
    if (!index.includes(fieldName)) {
      return true;
    }
    var hasNonLogicOperator = Object.entries(operation).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));
    return hasNonLogicOperator;
  });
  if (hasNonMatchingOperator) {
    return false;
  }
  var prevLowerBoundaryField;
  var hasMoreThenOneLowerBoundaryField = index.find((fieldName) => {
    var operation = selector[fieldName];
    if (!operation) {
      return false;
    }
    var hasLowerLogicOp = Object.keys(operation).find((key) => LOWER_BOUND_LOGICAL_OPERATORS.has(key));
    if (prevLowerBoundaryField && hasLowerLogicOp) {
      return true;
    } else if (hasLowerLogicOp !== "$eq") {
      prevLowerBoundaryField = hasLowerLogicOp;
    }
    return false;
  });
  if (hasMoreThenOneLowerBoundaryField) {
    return false;
  }
  var prevUpperBoundaryField;
  var hasMoreThenOneUpperBoundaryField = index.find((fieldName) => {
    var operation = selector[fieldName];
    if (!operation) {
      return false;
    }
    var hasUpperLogicOp = Object.keys(operation).find((key) => UPPER_BOUND_LOGICAL_OPERATORS.has(key));
    if (prevUpperBoundaryField && hasUpperLogicOp) {
      return true;
    } else if (hasUpperLogicOp !== "$eq") {
      prevUpperBoundaryField = hasUpperLogicOp;
    }
    return false;
  });
  if (hasMoreThenOneUpperBoundaryField) {
    return false;
  }
  return true;
}
function getMatcherQueryOpts(operator, operatorValue) {
  switch (operator) {
    case "$eq":
      return {
        startKey: operatorValue,
        endKey: operatorValue
      };
    case "$lte":
      return {
        endKey: operatorValue
      };
    case "$gte":
      return {
        startKey: operatorValue
      };
    case "$lt":
      return {
        endKey: operatorValue,
        inclusiveEnd: false
      };
    case "$gt":
      return {
        startKey: operatorValue,
        inclusiveStart: false
      };
    default:
      throw new Error("SNH");
  }
}
function rateQueryPlan(schema, query2, queryPlan) {
  var quality = 0;
  var addQuality = (value) => {
    if (value > 0) {
      quality = quality + value;
    }
  };
  var pointsPerMatchingKey = 10;
  var nonMinKeyCount = (0, _utils$m.countUntilNotMatching)(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);
  addQuality(nonMinKeyCount * pointsPerMatchingKey);
  var nonMaxKeyCount = (0, _utils$m.countUntilNotMatching)(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);
  addQuality(nonMaxKeyCount * pointsPerMatchingKey);
  var equalKeyCount = (0, _utils$m.countUntilNotMatching)(queryPlan.startKeys, (keyValue, idx) => {
    if (keyValue === queryPlan.endKeys[idx]) {
      return true;
    } else {
      return false;
    }
  });
  addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);
  var pointsIfNoReSortMustBeDone = queryPlan.sortFieldsSameAsIndexFields ? 5 : 0;
  addQuality(pointsIfNoReSortMustBeDone);
  return quality;
}
Object.defineProperty(rxStorageStatics, "__esModule", {
  value: true
});
rxStorageStatics.RxStorageDefaultStatics = void 0;
var _rxError$d = rxError;
var _queryPlanner$3 = queryPlanner;
var _rxSchemaHelper$b = rxSchemaHelper;
var RxStorageDefaultStatics = {
  prepareQuery(schema, mutateableQuery) {
    if (!mutateableQuery.sort) {
      throw (0, _rxError$d.newRxError)("SNH", {
        query: mutateableQuery
      });
    }
    var queryPlan = (0, _queryPlanner$3.getQueryPlan)(schema, mutateableQuery);
    return {
      query: mutateableQuery,
      queryPlan
    };
  },
  checkpointSchema: _rxSchemaHelper$b.DEFAULT_CHECKPOINT_SCHEMA
};
rxStorageStatics.RxStorageDefaultStatics = RxStorageDefaultStatics;
Object.defineProperty(dexieHelper, "__esModule", {
  value: true
});
dexieHelper.RxStorageDexieStatics = dexieHelper.RX_STORAGE_NAME_DEXIE = dexieHelper.DEXIE_PIPE_SUBSTITUTE = dexieHelper.DEXIE_DOCS_TABLE_NAME = dexieHelper.DEXIE_DELETED_DOCS_TABLE_NAME = dexieHelper.DEXIE_CHANGES_TABLE_NAME = void 0;
dexieHelper.closeDexieDb = closeDexieDb;
dexieHelper.dexieReplaceIfStartsWithPipe = dexieReplaceIfStartsWithPipe;
dexieHelper.dexieReplaceIfStartsWithPipeRevert = dexieReplaceIfStartsWithPipeRevert;
dexieHelper.ensureNoBooleanIndex = ensureNoBooleanIndex;
dexieHelper.fromDexieToStorage = fromDexieToStorage;
dexieHelper.fromStorageToDexie = fromStorageToDexie;
dexieHelper.getDexieDbWithTables = getDexieDbWithTables;
dexieHelper.getDexieStoreSchema = getDexieStoreSchema;
dexieHelper.getDocsInDb = getDocsInDb;
var _dexie = require$$0$2;
var _utils$l = utils;
var _rxError$c = rxError;
var _rxSchemaHelper$a = rxSchemaHelper;
var _rxStorageStatics = rxStorageStatics;
var DEXIE_DOCS_TABLE_NAME = "docs";
dexieHelper.DEXIE_DOCS_TABLE_NAME = DEXIE_DOCS_TABLE_NAME;
var DEXIE_DELETED_DOCS_TABLE_NAME = "deleted-docs";
dexieHelper.DEXIE_DELETED_DOCS_TABLE_NAME = DEXIE_DELETED_DOCS_TABLE_NAME;
var DEXIE_CHANGES_TABLE_NAME = "changes";
dexieHelper.DEXIE_CHANGES_TABLE_NAME = DEXIE_CHANGES_TABLE_NAME;
var RX_STORAGE_NAME_DEXIE = "dexie";
dexieHelper.RX_STORAGE_NAME_DEXIE = RX_STORAGE_NAME_DEXIE;
var RxStorageDexieStatics = _rxStorageStatics.RxStorageDefaultStatics;
dexieHelper.RxStorageDexieStatics = RxStorageDexieStatics;
var DEXIE_STATE_DB_BY_NAME = /* @__PURE__ */ new Map();
var REF_COUNT_PER_DEXIE_DB = /* @__PURE__ */ new Map();
function getDexieDbWithTables(databaseName, collectionName, settings, schema) {
  var primaryPath = (0, _rxSchemaHelper$a.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);
  var dexieDbName = "rxdb-dexie-" + databaseName + "--" + schema.version + "--" + collectionName;
  var state = (0, _utils$l.getFromMapOrCreate)(DEXIE_STATE_DB_BY_NAME, dexieDbName, () => {
    var value = (async () => {
      var useSettings = (0, _utils$l.flatClone)(settings);
      useSettings.autoOpen = false;
      var dexieDb = new _dexie.Dexie(dexieDbName, useSettings);
      var dexieStoresSettings = {
        [DEXIE_DOCS_TABLE_NAME]: getDexieStoreSchema(schema),
        [DEXIE_CHANGES_TABLE_NAME]: "++sequence, id",
        /**
         * Instead of adding {deleted: false} to every query we run over the document store,
         * we move deleted documents into a separate store where they can only be queried
         * by primary key.
         * This increases performance because it is way easier for the query planner to select
         * a good index and we also do not have to add the _deleted field to every index.
         *
         * We also need the [_meta.lwt+' + primaryPath + '] index for getChangedDocumentsSince()
         */
        [DEXIE_DELETED_DOCS_TABLE_NAME]: primaryPath + ",_meta.lwt,[_meta.lwt+" + primaryPath + "]"
      };
      dexieDb.version(1).stores(dexieStoresSettings);
      await dexieDb.open();
      return {
        dexieDb,
        dexieTable: dexieDb[DEXIE_DOCS_TABLE_NAME],
        dexieDeletedTable: dexieDb[DEXIE_DELETED_DOCS_TABLE_NAME]
      };
    })();
    DEXIE_STATE_DB_BY_NAME.set(dexieDbName, state);
    REF_COUNT_PER_DEXIE_DB.set(state, 0);
    return value;
  });
  return state;
}
async function closeDexieDb(statePromise) {
  var state = await statePromise;
  var prevCount = REF_COUNT_PER_DEXIE_DB.get(statePromise);
  var newCount = prevCount - 1;
  if (newCount === 0) {
    state.dexieDb.close();
    REF_COUNT_PER_DEXIE_DB.delete(statePromise);
  } else {
    REF_COUNT_PER_DEXIE_DB.set(statePromise, newCount);
  }
}
function ensureNoBooleanIndex(schema) {
  if (!schema.indexes) {
    return;
  }
  var checkedFields = /* @__PURE__ */ new Set();
  schema.indexes.forEach((index) => {
    var fields = (0, _utils$l.toArray)(index);
    fields.forEach((field) => {
      if (checkedFields.has(field)) {
        return;
      }
      checkedFields.add(field);
      var schemaObj = (0, _rxSchemaHelper$a.getSchemaByObjectPath)(schema, field);
      if (schemaObj.type === "boolean") {
        throw (0, _rxError$c.newRxError)("DXE1", {
          schema,
          index,
          field
        });
      }
    });
  });
}
var DEXIE_PIPE_SUBSTITUTE = "__";
dexieHelper.DEXIE_PIPE_SUBSTITUTE = DEXIE_PIPE_SUBSTITUTE;
function dexieReplaceIfStartsWithPipe(str) {
  var split2 = str.split(".");
  if (split2.length > 1) {
    return split2.map((part) => dexieReplaceIfStartsWithPipe(part)).join(".");
  }
  if (str.startsWith("|")) {
    var withoutFirst = str.substring(1);
    return DEXIE_PIPE_SUBSTITUTE + withoutFirst;
  } else {
    return str;
  }
}
function dexieReplaceIfStartsWithPipeRevert(str) {
  var split2 = str.split(".");
  if (split2.length > 1) {
    return split2.map((part) => dexieReplaceIfStartsWithPipeRevert(part)).join(".");
  }
  if (str.startsWith(DEXIE_PIPE_SUBSTITUTE)) {
    var withoutFirst = str.substring(DEXIE_PIPE_SUBSTITUTE.length);
    return "|" + withoutFirst;
  } else {
    return str;
  }
}
function fromStorageToDexie(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromStorageToDexie(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object") {
        value = fromStorageToDexie(value);
      }
      ret[dexieReplaceIfStartsWithPipe(key)] = value;
    });
    return ret;
  }
}
function fromDexieToStorage(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromDexieToStorage(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object" || Array.isArray(documentData)) {
        value = fromDexieToStorage(value);
      }
      ret[dexieReplaceIfStartsWithPipeRevert(key)] = value;
    });
    return ret;
  }
}
function getDexieStoreSchema(rxJsonSchema) {
  var parts = [];
  var primaryKey = (0, _rxSchemaHelper$a.getPrimaryFieldOfPrimaryKey)(rxJsonSchema.primaryKey);
  parts.push([primaryKey]);
  if (rxJsonSchema.indexes) {
    rxJsonSchema.indexes.forEach((index) => {
      var arIndex = (0, _utils$l.toArray)(index);
      parts.push(arIndex);
    });
  }
  parts.push(["_meta.lwt", primaryKey]);
  parts = parts.map((part) => {
    return part.map((str) => dexieReplaceIfStartsWithPipe(str));
  });
  return parts.map((part) => {
    if (part.length === 1) {
      return part[0];
    } else {
      return "[" + part.join("+") + "]";
    }
  }).join(", ");
}
async function getDocsInDb(internals, docIds) {
  var state = await internals;
  var [nonDeletedDocsInDb, deletedDocsInDb] = await Promise.all([state.dexieTable.bulkGet(docIds), state.dexieDeletedTable.bulkGet(docIds)]);
  var docsInDb = deletedDocsInDb.slice(0);
  nonDeletedDocsInDb.forEach((doc, idx) => {
    if (doc) {
      docsInDb[idx] = doc;
    }
  });
  return docsInDb;
}
var rxStorageInstanceDexie = {};
var dexieQuery$1 = {};
var rxQueryHelper = {};
var util$3 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalize = exports.isOperator = exports.removeValue = exports.setValue = exports.walk = exports.filterMissing = exports.resolveGraph = exports.resolve = exports.memoize = exports.into = exports.groupBy = exports.sortBy = exports.hashCode = exports.stringify = exports.unique = exports.isEqual = exports.flatten = exports.intersection = exports.merge = exports.has = exports.ensureArray = exports.isMissing = exports.isEmpty = exports.truthy = exports.notInArray = exports.inArray = exports.isNil = exports.isFunction = exports.isRegExp = exports.isDate = exports.isObjectLike = exports.isObject = exports.isArray = exports.isNotNaN = exports.isNumber = exports.isString = exports.isBoolean = exports.getType = exports.cloneDeep = exports.assert = exports.compare = exports.MIN_LONG = exports.MAX_LONG = exports.MIN_INT = exports.MAX_INT = void 0;
  exports.MAX_INT = 2147483647;
  exports.MIN_INT = -2147483648;
  exports.MAX_LONG = Number.MAX_SAFE_INTEGER;
  exports.MIN_LONG = Number.MIN_SAFE_INTEGER;
  const MISSING = Symbol("missing");
  const OBJECT_PROTOTYPE = Object.getPrototypeOf({});
  const OBJECT_TAG = "[object Object]";
  const OBJECT_TYPE_RE = /^\[object ([a-zA-Z0-9]+)\]$/;
  const DEFAULT_HASH_FUNCTION = (value) => {
    const s2 = stringify(value);
    let hash2 = 0;
    let i2 = s2.length;
    while (i2)
      hash2 = (hash2 << 5) - hash2 ^ s2.charCodeAt(--i2);
    return hash2 >>> 0;
  };
  const JS_SIMPLE_TYPES = /* @__PURE__ */ new Set([
    "null",
    "undefined",
    "boolean",
    "number",
    "string",
    "date",
    "regexp"
  ]);
  const SORT_ORDER_BY_TYPE = {
    null: 0,
    undefined: 0,
    number: 1,
    string: 2,
    object: 3,
    array: 4,
    boolean: 5,
    date: 6,
    regexp: 7,
    function: 8
  };
  const compare2 = (a2, b2) => {
    if (a2 === MISSING)
      a2 = void 0;
    if (b2 === MISSING)
      b2 = void 0;
    const [u2, v2] = [a2, b2].map((n2) => SORT_ORDER_BY_TYPE[(0, exports.getType)(n2).toLowerCase()]);
    if (u2 !== v2)
      return u2 - v2;
    if (u2 === 1 || u2 === 2 || u2 === 6) {
      if (a2 < b2)
        return -1;
      if (a2 > b2)
        return 1;
      return 0;
    }
    if (isEqual2(a2, b2))
      return 0;
    if (a2 < b2)
      return -1;
    if (a2 > b2)
      return 1;
    return 0;
  };
  exports.compare = compare2;
  function assert(condition, message) {
    if (!condition)
      throw new Error(message);
  }
  exports.assert = assert;
  const cloneDeep = (obj) => {
    const m2 = /* @__PURE__ */ new Map();
    const add2 = (v2) => {
      if (m2.has(v2))
        throw new Error("cycle detected during clone operation.");
      m2.set(v2, true);
    };
    const clone2 = (val) => {
      if (val instanceof Date)
        return new Date(val);
      if ((0, exports.isArray)(val)) {
        add2(val);
        const res = new Array(val.length);
        const len = val.length;
        for (let i2 = 0; i2 < len; i2++)
          res[i2] = clone2(val[i2]);
        return res;
      }
      if ((0, exports.isObject)(val)) {
        add2(val);
        const res = {};
        for (const k2 in val)
          res[k2] = clone2(val[k2]);
        return res;
      }
      return val;
    };
    return clone2(obj);
  };
  exports.cloneDeep = cloneDeep;
  const getType2 = (v2) => OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v2))[1];
  exports.getType = getType2;
  const isBoolean = (v2) => typeof v2 === "boolean";
  exports.isBoolean = isBoolean;
  const isString = (v2) => typeof v2 === "string";
  exports.isString = isString;
  const isNumber2 = (v2) => !isNaN(v2) && typeof v2 === "number";
  exports.isNumber = isNumber2;
  const isNotNaN = (v2) => !(isNaN(v2) && typeof v2 === "number");
  exports.isNotNaN = isNotNaN;
  exports.isArray = Array.isArray;
  const isObject2 = (v2) => {
    if (!v2)
      return false;
    const proto = Object.getPrototypeOf(v2);
    return (proto === OBJECT_PROTOTYPE || proto === null) && OBJECT_TAG === Object.prototype.toString.call(v2);
  };
  exports.isObject = isObject2;
  const isObjectLike = (v2) => v2 === Object(v2);
  exports.isObjectLike = isObjectLike;
  const isDate2 = (v2) => v2 instanceof Date;
  exports.isDate = isDate2;
  const isRegExp = (v2) => v2 instanceof RegExp;
  exports.isRegExp = isRegExp;
  const isFunction2 = (v2) => typeof v2 === "function";
  exports.isFunction = isFunction2;
  const isNil = (v2) => v2 === null || v2 === void 0;
  exports.isNil = isNil;
  const inArray = (arr, item) => arr.includes(item);
  exports.inArray = inArray;
  const notInArray = (arr, item) => !(0, exports.inArray)(arr, item);
  exports.notInArray = notInArray;
  const truthy = (arg, strict = true) => !!arg || strict && arg === "";
  exports.truthy = truthy;
  const isEmpty2 = (x2) => (0, exports.isNil)(x2) || (0, exports.isString)(x2) && !x2 || x2 instanceof Array && x2.length === 0 || (0, exports.isObject)(x2) && Object.keys(x2).length === 0;
  exports.isEmpty = isEmpty2;
  const isMissing = (v2) => v2 === MISSING;
  exports.isMissing = isMissing;
  const ensureArray = (x2) => x2 instanceof Array ? x2 : [x2];
  exports.ensureArray = ensureArray;
  const has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);
  exports.has = has;
  const mergeable = (left, right) => (0, exports.isObject)(left) && (0, exports.isObject)(right) || (0, exports.isArray)(left) && (0, exports.isArray)(right);
  function merge2(target, obj, options2) {
    options2 = options2 || { flatten: false };
    if ((0, exports.isMissing)(target) || (0, exports.isNil)(target))
      return obj;
    if ((0, exports.isMissing)(obj) || (0, exports.isNil)(obj))
      return target;
    if (!mergeable(target, obj)) {
      if (options2.skipValidation)
        return obj || target;
      throw Error("mismatched types. must both be array or object");
    }
    options2.skipValidation = true;
    if ((0, exports.isArray)(target)) {
      const result = target;
      const input = obj;
      if (options2.flatten) {
        let i2 = 0;
        let j2 = 0;
        while (i2 < result.length && j2 < input.length) {
          result[i2] = merge2(result[i2++], input[j2++], options2);
        }
        while (j2 < input.length) {
          result.push(obj[j2++]);
        }
      } else {
        into(result, input);
      }
    } else {
      for (const k2 in obj) {
        target[k2] = merge2(target[k2], obj[k2], options2);
      }
    }
    return target;
  }
  exports.merge = merge2;
  function buildHashIndex(arr, hashFunction = DEFAULT_HASH_FUNCTION) {
    const map2 = /* @__PURE__ */ new Map();
    arr.forEach((o2, i2) => {
      const h2 = hashCode(o2, hashFunction);
      if (map2.has(h2)) {
        if (!map2.get(h2).some((j2) => isEqual2(arr[j2], o2))) {
          map2.get(h2).push(i2);
        }
      } else {
        map2.set(h2, [i2]);
      }
    });
    return map2;
  }
  function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {
    if (input.some((arr) => arr.length == 0))
      return [];
    if (input.length === 1)
      return Array.from(input);
    const sortedIndex = sortBy(input.map((a2, i2) => [i2, a2.length]), (a2) => a2[1]);
    const smallest = input[sortedIndex[0][0]];
    const map2 = buildHashIndex(smallest, hashFunction);
    const rmap = /* @__PURE__ */ new Map();
    const results = new Array();
    map2.forEach((v2, k2) => {
      const lhs = v2.map((j2) => smallest[j2]);
      const res = lhs.map((_2) => 0);
      const stable = lhs.map((_2) => [sortedIndex[0][0], 0]);
      let found = false;
      for (let i2 = 1; i2 < input.length; i2++) {
        const [currIndex, _2] = sortedIndex[i2];
        const arr = input[currIndex];
        if (!rmap.has(i2))
          rmap.set(i2, buildHashIndex(arr));
        if (rmap.get(i2).has(k2)) {
          const rhs = rmap.get(i2).get(k2).map((j2) => arr[j2]);
          found = lhs.map((s2, n2) => rhs.some((t2, m2) => {
            const p2 = res[n2];
            if (isEqual2(s2, t2)) {
              res[n2]++;
              if (currIndex < stable[n2][0]) {
                stable[n2] = [currIndex, rmap.get(i2).get(k2)[m2]];
              }
            }
            return p2 < res[n2];
          })).some(Boolean);
        }
        if (!found)
          return;
      }
      if (found) {
        into(results, res.map((n2, i2) => {
          return n2 === input.length - 1 ? [lhs[i2], stable[i2]] : MISSING;
        }).filter((n2) => n2 !== MISSING));
      }
    });
    return results.sort((a2, b2) => {
      const [_i, [u2, m2]] = a2;
      const [_j, [v2, n2]] = b2;
      const r2 = (0, exports.compare)(u2, v2);
      if (r2 !== 0)
        return r2;
      return (0, exports.compare)(m2, n2);
    }).map((v2) => v2[0]);
  }
  exports.intersection = intersection;
  function flatten(xs, depth = 0) {
    const arr = new Array();
    function flatten2(ys, n2) {
      for (let i2 = 0, len = ys.length; i2 < len; i2++) {
        if ((0, exports.isArray)(ys[i2]) && (n2 > 0 || n2 < 0)) {
          flatten2(ys[i2], Math.max(-1, n2 - 1));
        } else {
          arr.push(ys[i2]);
        }
      }
    }
    flatten2(xs, depth);
    return arr;
  }
  exports.flatten = flatten;
  function isEqual2(a2, b2) {
    const lhs = [a2];
    const rhs = [b2];
    while (lhs.length > 0) {
      a2 = lhs.pop();
      b2 = rhs.pop();
      if (a2 === b2)
        continue;
      const nativeType = (0, exports.getType)(a2).toLowerCase();
      if (nativeType !== (0, exports.getType)(b2).toLowerCase() || nativeType === "function") {
        return false;
      }
      if (nativeType === "array") {
        const xs = a2;
        const ys = b2;
        if (xs.length !== ys.length)
          return false;
        if (xs.length === ys.length && xs.length === 0)
          continue;
        into(lhs, xs);
        into(rhs, ys);
      } else if (nativeType === "object") {
        const aKeys = Object.keys(a2);
        const bKeys = Object.keys(b2);
        if (aKeys.length !== bKeys.length)
          return false;
        for (let i2 = 0, len = aKeys.length; i2 < len; i2++) {
          const k2 = aKeys[i2];
          if (!(0, exports.has)(b2, k2))
            return false;
          lhs.push(a2[k2]);
          rhs.push(b2[k2]);
        }
      } else {
        if (stringify(a2) !== stringify(b2))
          return false;
      }
    }
    return lhs.length === 0;
  }
  exports.isEqual = isEqual2;
  function unique(input, hashFunction = DEFAULT_HASH_FUNCTION) {
    const result = input.map((_2) => MISSING);
    buildHashIndex(input, hashFunction).forEach((v2, _2) => {
      v2.forEach((i2) => result[i2] = input[i2]);
    });
    return result.filter((v2) => v2 !== MISSING);
  }
  exports.unique = unique;
  function stringify(value) {
    const type2 = (0, exports.getType)(value).toLowerCase();
    switch (type2) {
      case "boolean":
      case "number":
      case "regexp":
        return value.toString();
      case "string":
        return JSON.stringify(value);
      case "date":
        return value.toISOString();
      case "null":
      case "undefined":
        return type2;
      case "array":
        return "[" + value.map(stringify).join(",") + "]";
    }
    const prefix = type2 === "object" ? "" : `${(0, exports.getType)(value)}`;
    const objKeys = Object.keys(value);
    objKeys.sort();
    return `${prefix}{` + objKeys.map((k2) => `${stringify(k2)}:${stringify(value[k2])}`).join(",") + "}";
  }
  exports.stringify = stringify;
  function hashCode(value, hashFunction) {
    hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;
    if ((0, exports.isNil)(value))
      return null;
    return hashFunction(value).toString();
  }
  exports.hashCode = hashCode;
  function sortBy(collection, keyFn, comparator = exports.compare) {
    if ((0, exports.isEmpty)(collection))
      return collection;
    const sorted = new Array();
    const result = new Array();
    for (let i2 = 0; i2 < collection.length; i2++) {
      const obj = collection[i2];
      const key = keyFn(obj, i2);
      if ((0, exports.isNil)(key)) {
        result.push(obj);
      } else {
        sorted.push([key, obj]);
      }
    }
    sorted.sort((a2, b2) => comparator(a2[0], b2[0]));
    return into(result, sorted.map((o2) => o2[1]));
  }
  exports.sortBy = sortBy;
  function groupBy2(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {
    if (collection.length < 1)
      return /* @__PURE__ */ new Map();
    const lookup2 = /* @__PURE__ */ new Map();
    const result = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < collection.length; i2++) {
      const obj = collection[i2];
      const key = keyFn(obj, i2);
      const hash2 = hashCode(key, hashFunction);
      if (hash2 === null) {
        if (result.has(null)) {
          result.get(null).push(obj);
        } else {
          result.set(null, [obj]);
        }
      } else {
        const existingKey = lookup2.has(hash2) ? lookup2.get(hash2).find((k2) => isEqual2(k2, key)) : null;
        if ((0, exports.isNil)(existingKey)) {
          result.set(key, [obj]);
          if (lookup2.has(hash2)) {
            lookup2.get(hash2).push(key);
          } else {
            lookup2.set(hash2, [key]);
          }
        } else {
          result.get(existingKey).push(obj);
        }
      }
    }
    return result;
  }
  exports.groupBy = groupBy2;
  const MAX_ARRAY_PUSH = 5e4;
  function into(target, ...rest) {
    if (target instanceof Array) {
      return rest.reduce((acc, arr) => {
        let i2 = Math.ceil(arr.length / MAX_ARRAY_PUSH);
        let begin = 0;
        while (i2-- > 0) {
          Array.prototype.push.apply(acc, arr.slice(begin, begin + MAX_ARRAY_PUSH));
          begin += MAX_ARRAY_PUSH;
        }
        return acc;
      }, target);
    } else {
      return rest.filter(exports.isObjectLike).reduce((acc, item) => {
        Object.assign(acc, item);
        return acc;
      }, target);
    }
  }
  exports.into = into;
  function memoize(fn2, hashFunction = DEFAULT_HASH_FUNCTION) {
    return ((memo2) => {
      return (...args2) => {
        const key = hashCode(args2, hashFunction) || "";
        if (!(0, exports.has)(memo2, key)) {
          memo2[key] = fn2.apply(this, args2);
        }
        return memo2[key];
      };
    })({
      /* storage */
    });
  }
  exports.memoize = memoize;
  function getValue(obj, key) {
    return (0, exports.isObjectLike)(obj) ? obj[key] : void 0;
  }
  function unwrap(arr, depth) {
    if (depth < 1)
      return arr;
    while (depth-- && arr.length === 1)
      arr = arr[0];
    return arr;
  }
  function resolve(obj, selector, options2) {
    let depth = 0;
    function resolve2(o2, path2) {
      let value = o2;
      for (let i2 = 0; i2 < path2.length; i2++) {
        const field = path2[i2];
        const isText = /^\d+$/.exec(field) === null;
        if (isText && value instanceof Array) {
          if (i2 === 0 && depth > 0)
            break;
          depth += 1;
          const subpath = path2.slice(i2);
          value = value.reduce((acc, item) => {
            const v2 = resolve2(item, subpath);
            if (v2 !== void 0)
              acc.push(v2);
            return acc;
          }, []);
          break;
        } else {
          value = getValue(value, field);
        }
        if (value === void 0)
          break;
      }
      return value;
    }
    const result = JS_SIMPLE_TYPES.has((0, exports.getType)(obj).toLowerCase()) ? obj : resolve2(obj, selector.split("."));
    return result instanceof Array && (options2 === null || options2 === void 0 ? void 0 : options2.unwrapArray) ? unwrap(result, depth) : result;
  }
  exports.resolve = resolve;
  function resolveGraph(obj, selector, options2) {
    const names = selector.split(".");
    const key = names[0];
    const next = names.slice(1).join(".");
    const isIndex = /^\d+$/.exec(key) !== null;
    const hasNext = names.length > 1;
    let result;
    let value;
    if (obj instanceof Array) {
      if (isIndex) {
        result = getValue(obj, Number(key));
        if (hasNext) {
          result = resolveGraph(result, next, options2);
        }
        result = [result];
      } else {
        result = [];
        for (const item of obj) {
          value = resolveGraph(item, selector, options2);
          if (options2 === null || options2 === void 0 ? void 0 : options2.preserveMissing) {
            if (value === void 0) {
              value = MISSING;
            }
            result.push(value);
          } else if (value !== void 0) {
            result.push(value);
          }
        }
      }
    } else {
      value = getValue(obj, key);
      if (hasNext) {
        value = resolveGraph(value, next, options2);
      }
      if (value === void 0)
        return void 0;
      result = (options2 === null || options2 === void 0 ? void 0 : options2.preserveKeys) ? Object.assign({}, obj) : {};
      result[key] = value;
    }
    return result;
  }
  exports.resolveGraph = resolveGraph;
  function filterMissing(obj) {
    if (obj instanceof Array) {
      for (let i2 = obj.length - 1; i2 >= 0; i2--) {
        if (obj[i2] === MISSING) {
          obj.splice(i2, 1);
        } else {
          filterMissing(obj[i2]);
        }
      }
    } else if ((0, exports.isObject)(obj)) {
      for (const k2 in obj) {
        if ((0, exports.has)(obj, k2)) {
          filterMissing(obj[k2]);
        }
      }
    }
  }
  exports.filterMissing = filterMissing;
  const NUMBER_RE = /^\d+$/;
  function walk(obj, selector, fn2, options2) {
    const names = selector.split(".");
    const key = names[0];
    const next = names.slice(1).join(".");
    if (names.length === 1) {
      if ((0, exports.isObject)(obj) || (0, exports.isArray)(obj) && NUMBER_RE.test(key)) {
        fn2(obj, key);
      }
    } else {
      if ((options2 === null || options2 === void 0 ? void 0 : options2.buildGraph) && (0, exports.isNil)(obj[key])) {
        obj[key] = {};
      }
      const item = obj[key];
      if (!item)
        return;
      const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));
      if (item instanceof Array && (options2 === null || options2 === void 0 ? void 0 : options2.descendArray) && !isNextArrayIndex) {
        item.forEach((e2) => walk(e2, next, fn2, options2));
      } else {
        walk(item, next, fn2, options2);
      }
    }
  }
  exports.walk = walk;
  function setValue(obj, selector, value) {
    walk(obj, selector, (item, key) => {
      item[key] = value;
    }, { buildGraph: true });
  }
  exports.setValue = setValue;
  function removeValue(obj, selector, options2) {
    walk(obj, selector, (item, key) => {
      if (item instanceof Array) {
        if (/^\d+$/.test(key)) {
          item.splice(parseInt(key), 1);
        } else if (options2 && options2.descendArray) {
          for (const elem of item) {
            if ((0, exports.isObject)(elem)) {
              delete elem[key];
            }
          }
        }
      } else if ((0, exports.isObject)(item)) {
        delete item[key];
      }
    }, options2);
  }
  exports.removeValue = removeValue;
  const OPERATOR_NAME_PATTERN = /^\$[a-zA-Z0-9_]+$/;
  function isOperator(name) {
    return OPERATOR_NAME_PATTERN.test(name);
  }
  exports.isOperator = isOperator;
  function normalize(expr2) {
    if (JS_SIMPLE_TYPES.has((0, exports.getType)(expr2).toLowerCase())) {
      return (0, exports.isRegExp)(expr2) ? { $regex: expr2 } : { $eq: expr2 };
    }
    if ((0, exports.isObjectLike)(expr2)) {
      const exprObj = expr2;
      if (!Object.keys(exprObj).some(isOperator)) {
        return { $eq: expr2 };
      }
      if ((0, exports.has)(expr2, "$regex")) {
        const newExpr = Object.assign({}, expr2);
        newExpr["$regex"] = new RegExp(expr2["$regex"], expr2["$options"]);
        delete newExpr["$options"];
        return newExpr;
      }
    }
    return expr2;
  }
  exports.normalize = normalize;
})(util$3);
var rxQueryMingo = {};
var core = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redact = exports.computeValue = exports.getOperator = exports.useOperators = exports.Context = exports.OperatorType = exports.initOptions = exports.ComputeOptions = exports.ProcessingMode = void 0;
  const util_12 = util$3;
  var ProcessingMode;
  (function(ProcessingMode2) {
    ProcessingMode2["CLONE_ALL"] = "CLONE_ALL";
    ProcessingMode2["CLONE_INPUT"] = "CLONE_INPUT";
    ProcessingMode2["CLONE_OUTPUT"] = "CLONE_OUTPUT";
    ProcessingMode2["CLONE_OFF"] = "CLONE_OFF";
  })(ProcessingMode = exports.ProcessingMode || (exports.ProcessingMode = {}));
  class ComputeOptions {
    constructor(_opts, _root, _local, timestamp2 = Date.now()) {
      this._opts = _opts;
      this._root = _root;
      this._local = _local;
      this.timestamp = timestamp2;
      this.update(_root, _local);
    }
    /**
     * Initialize new ComputeOptions.
     *
     * @param options
     * @param root
     * @param local
     * @returns {ComputeOptions}
     */
    static init(options2, root, local) {
      return options2 instanceof ComputeOptions ? new ComputeOptions(options2._opts, (0, util_12.isNil)(options2.root) ? root : options2.root, Object.assign({}, options2.local, local)) : new ComputeOptions(options2, root, local);
    }
    /** Updates the internal mutable state. */
    update(root, local) {
      var _a;
      this._root = root;
      this._local = local ? Object.assign({}, local, {
        variables: Object.assign({}, (_a = this._local) === null || _a === void 0 ? void 0 : _a.variables, local === null || local === void 0 ? void 0 : local.variables)
      }) : local;
      return this;
    }
    getOptions() {
      return Object.freeze(Object.assign(Object.assign({}, this._opts), { context: Context.from(this._opts.context) }));
    }
    get root() {
      return this._root;
    }
    get local() {
      return this._local;
    }
    get idKey() {
      return this._opts.idKey;
    }
    get collation() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collation;
    }
    get processingMode() {
      var _a;
      return ((_a = this._opts) === null || _a === void 0 ? void 0 : _a.processingMode) || ProcessingMode.CLONE_OFF;
    }
    get useStrictMode() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useStrictMode;
    }
    get scriptEnabled() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.scriptEnabled;
    }
    get useGlobalContext() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useGlobalContext;
    }
    get hashFunction() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.hashFunction;
    }
    get collectionResolver() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collectionResolver;
    }
    get jsonSchemaValidator() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.jsonSchemaValidator;
    }
    get variables() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.variables;
    }
    get context() {
      var _a;
      return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.context;
    }
  }
  exports.ComputeOptions = ComputeOptions;
  function initOptions(options2) {
    return options2 instanceof ComputeOptions ? options2.getOptions() : Object.freeze(Object.assign(Object.assign({ idKey: "_id", scriptEnabled: true, useStrictMode: true, useGlobalContext: true, processingMode: ProcessingMode.CLONE_OFF }, options2), { context: (options2 === null || options2 === void 0 ? void 0 : options2.context) ? Context.from(options2 === null || options2 === void 0 ? void 0 : options2.context) : Context.init({}) }));
  }
  exports.initOptions = initOptions;
  var OperatorType;
  (function(OperatorType2) {
    OperatorType2["ACCUMULATOR"] = "accumulator";
    OperatorType2["EXPRESSION"] = "expression";
    OperatorType2["PIPELINE"] = "pipeline";
    OperatorType2["PROJECTION"] = "projection";
    OperatorType2["QUERY"] = "query";
    OperatorType2["WINDOW"] = "window";
  })(OperatorType = exports.OperatorType || (exports.OperatorType = {}));
  class Context {
    constructor(ops) {
      this.operators = (0, util_12.cloneDeep)(ops);
    }
    static init(ops) {
      return new Context((0, util_12.merge)({
        [OperatorType.ACCUMULATOR]: {},
        [OperatorType.EXPRESSION]: {},
        [OperatorType.PIPELINE]: {},
        [OperatorType.PROJECTION]: {},
        [OperatorType.QUERY]: {},
        [OperatorType.WINDOW]: {}
      }, ops, { skipValidation: true }));
    }
    static from(ctx) {
      return new Context(ctx.operators);
    }
    addOperators(type2, ops) {
      for (const [name, fn2] of Object.entries(ops)) {
        if (!this.getOperator(type2, name)) {
          this.operators[type2][name] = fn2;
        }
      }
      return this;
    }
    // register
    addAccumulatorOps(ops) {
      return this.addOperators(OperatorType.ACCUMULATOR, ops);
    }
    addExpressionOps(ops) {
      return this.addOperators(OperatorType.EXPRESSION, ops);
    }
    addQueryOps(ops) {
      return this.addOperators(OperatorType.QUERY, ops);
    }
    addPipelineOps(ops) {
      return this.addOperators(OperatorType.PIPELINE, ops);
    }
    addProjectionOps(ops) {
      return this.addOperators(OperatorType.PROJECTION, ops);
    }
    addWindowOps(ops) {
      return this.addOperators(OperatorType.WINDOW, ops);
    }
    // getters
    getOperator(type2, name) {
      return type2 in this.operators ? this.operators[type2][name] || null : null;
    }
  }
  exports.Context = Context;
  const CONTEXT = Context.init({});
  function useOperators(type2, operators2) {
    for (const [name, fn2] of Object.entries(operators2)) {
      (0, util_12.assert)((0, util_12.isFunction)(fn2) && (0, util_12.isOperator)(name), `'${name}' is not a valid operator`);
      const currentFn = getOperator(type2, name, null);
      (0, util_12.assert)(!currentFn || fn2 === currentFn, `${name} already exists for '${type2}' operators. Cannot change operator function once registered.`);
    }
    CONTEXT.addOperators(type2, operators2);
  }
  exports.useOperators = useOperators;
  function getOperator(type2, operator, options2) {
    const { context: ctx, useGlobalContext: fallback } = options2 || {};
    const fn2 = ctx ? ctx.getOperator(type2, operator) : null;
    return !fn2 && fallback ? CONTEXT.getOperator(type2, operator) : fn2;
  }
  exports.getOperator = getOperator;
  const systemVariables = {
    $$ROOT(obj, expr2, options2) {
      return options2.root;
    },
    $$CURRENT(obj, expr2, options2) {
      return obj;
    },
    $$REMOVE(obj, expr2, options2) {
      return void 0;
    },
    $$NOW(obj, expr2, options2) {
      return new Date(options2.timestamp);
    }
  };
  const redactVariables = {
    $$KEEP(obj, expr2, options2) {
      return obj;
    },
    $$PRUNE(obj, expr2, options2) {
      return void 0;
    },
    $$DESCEND(obj, expr2, options2) {
      if (!(0, util_12.has)(expr2, "$cond"))
        return obj;
      let result;
      for (const [key, current] of Object.entries(obj)) {
        if ((0, util_12.isObjectLike)(current)) {
          if (current instanceof Array) {
            const array2 = [];
            for (let elem of current) {
              if ((0, util_12.isObject)(elem)) {
                elem = redact2(elem, expr2, options2.update(elem));
              }
              if (!(0, util_12.isNil)(elem)) {
                array2.push(elem);
              }
            }
            result = array2;
          } else {
            result = redact2(current, expr2, options2.update(current));
          }
          if ((0, util_12.isNil)(result)) {
            delete obj[key];
          } else {
            obj[key] = result;
          }
        }
      }
      return obj;
    }
  };
  function computeValue(obj, expr2, operator, options2) {
    var _a;
    const copts = ComputeOptions.init(options2, obj);
    operator = operator || "";
    if ((0, util_12.isOperator)(operator)) {
      const callExpression = getOperator(OperatorType.EXPRESSION, operator, options2);
      if (callExpression)
        return callExpression(obj, expr2, copts);
      const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator, options2);
      if (callAccumulator) {
        if (!(obj instanceof Array)) {
          obj = computeValue(obj, expr2, null, copts);
          expr2 = null;
        }
        (0, util_12.assert)(obj instanceof Array, `'${operator}' target must be an array.`);
        return callAccumulator(
          obj,
          expr2,
          // reset the root object for accumulators.
          copts.update(null, copts.local)
        );
      }
      throw new Error(`operator '${operator}' is not registered`);
    }
    if ((0, util_12.isString)(expr2) && expr2.length > 0 && expr2[0] === "$") {
      if ((0, util_12.has)(redactVariables, expr2)) {
        return expr2;
      }
      let context2 = copts.root;
      const arr = expr2.split(".");
      if ((0, util_12.has)(systemVariables, arr[0])) {
        context2 = systemVariables[arr[0]](obj, null, copts);
        expr2 = expr2.slice(arr[0].length + 1);
      } else if (arr[0].slice(0, 2) === "$$") {
        context2 = Object.assign(
          {},
          copts.variables,
          // global vars
          // current item is added before local variables because the binding may be changed.
          { this: obj },
          (_a = copts.local) === null || _a === void 0 ? void 0 : _a.variables
          // local vars
        );
        const prefix = arr[0].slice(2);
        (0, util_12.assert)((0, util_12.has)(context2, prefix), `Use of undefined variable: ${prefix}`);
        expr2 = expr2.slice(2);
      } else {
        expr2 = expr2.slice(1);
      }
      if (expr2 === "")
        return context2;
      return (0, util_12.resolve)(context2, expr2);
    }
    if ((0, util_12.isArray)(expr2)) {
      return expr2.map((item) => computeValue(obj, item, null, copts));
    } else if ((0, util_12.isObject)(expr2)) {
      const result = {};
      for (const [key, val] of Object.entries(expr2)) {
        result[key] = computeValue(obj, val, key, copts);
        if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some((t2) => !!getOperator(t2, key, options2))) {
          (0, util_12.assert)(Object.keys(expr2).length === 1, "Invalid aggregation expression '" + JSON.stringify(expr2) + "'");
          return result[key];
        }
      }
      return result;
    }
    return expr2;
  }
  exports.computeValue = computeValue;
  function redact2(obj, expr2, options2) {
    const result = computeValue(obj, expr2, null, options2);
    return (0, util_12.has)(redactVariables, result) ? redactVariables[result](obj, expr2, options2) : result;
  }
  exports.redact = redact2;
})(core);
var query = {};
var cursor = {};
var aggregator = {};
var lazy = {};
Object.defineProperty(lazy, "__esModule", { value: true });
lazy.Iterator = lazy.compose = lazy.Lazy = void 0;
function Lazy(source) {
  return source instanceof Iterator ? source : new Iterator(source);
}
lazy.Lazy = Lazy;
function compose(...iterators) {
  let index = 0;
  return Lazy(() => {
    while (index < iterators.length) {
      const o2 = iterators[index].next();
      if (!o2.done)
        return o2;
      index++;
    }
    return { done: true };
  });
}
lazy.compose = compose;
function isGenerator(o2) {
  return !!o2 && typeof o2 === "object" && (o2 === null || o2 === void 0 ? void 0 : o2.next) instanceof Function;
}
function dropItem(array2, i2) {
  const rest = array2.slice(i2 + 1);
  array2.splice(i2);
  Array.prototype.push.apply(array2, rest);
}
const DONE = new Error();
var Action;
(function(Action2) {
  Action2[Action2["MAP"] = 0] = "MAP";
  Action2[Action2["FILTER"] = 1] = "FILTER";
  Action2[Action2["TAKE"] = 2] = "TAKE";
  Action2[Action2["DROP"] = 3] = "DROP";
})(Action || (Action = {}));
function createCallback(nextFn, iteratees, buffer2) {
  let done = false;
  let index = -1;
  let bufferIndex = 0;
  return function(storeResult) {
    try {
      outer:
        while (!done) {
          let o2 = nextFn();
          index++;
          let i2 = -1;
          const size2 = iteratees.length;
          let innerDone = false;
          while (++i2 < size2) {
            const r2 = iteratees[i2];
            switch (r2.action) {
              case Action.MAP:
                o2 = r2.func(o2, index);
                break;
              case Action.FILTER:
                if (!r2.func(o2, index))
                  continue outer;
                break;
              case Action.TAKE:
                --r2.count;
                if (!r2.count)
                  innerDone = true;
                break;
              case Action.DROP:
                --r2.count;
                if (!r2.count)
                  dropItem(iteratees, i2);
                continue outer;
              default:
                break outer;
            }
          }
          done = innerDone;
          if (storeResult) {
            buffer2[bufferIndex++] = o2;
          } else {
            return { value: o2, done: false };
          }
        }
    } catch (e2) {
      if (e2 !== DONE)
        throw e2;
    }
    done = true;
    return { done };
  };
}
class Iterator {
  /**
   * @param {*} source An iterable object or function.
   *    Array - return one element per cycle
   *    Object{next:Function} - call next() for the next value (this also handles generator functions)
   *    Function - call to return the next value
   * @param {Function} fn An optional transformation function
   */
  constructor(source) {
    this.iteratees = [];
    this.yieldedValues = [];
    this.isDone = false;
    let nextVal;
    if (source instanceof Function) {
      source = { next: source };
    }
    if (isGenerator(source)) {
      const src2 = source;
      nextVal = () => {
        const o2 = src2.next();
        if (o2.done)
          throw DONE;
        return o2.value;
      };
    } else if (source instanceof Array) {
      const data = source;
      const size2 = data.length;
      let index = 0;
      nextVal = () => {
        if (index < size2)
          return data[index++];
        throw DONE;
      };
    } else if (!(source instanceof Function)) {
      throw new Error(`Source is of type '${typeof source}'. Must be Array, Function, or Generator`);
    }
    this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);
  }
  /**
   * Add an iteratee to this lazy sequence
   */
  push(action, value) {
    if (typeof value === "function") {
      this.iteratees.push({ action, func: value });
    } else if (typeof value === "number") {
      this.iteratees.push({ action, count: value });
    }
    return this;
  }
  next() {
    return this.getNext();
  }
  // Iteratees methods
  /**
   * Transform each item in the sequence to a new value
   * @param {Function} f
   */
  map(f2) {
    return this.push(Action.MAP, f2);
  }
  /**
   * Select only items matching the given predicate
   * @param {Function} pred
   */
  filter(predicate) {
    return this.push(Action.FILTER, predicate);
  }
  /**
   * Take given numbe for values from sequence
   * @param {Number} n A number greater than 0
   */
  take(n2) {
    return n2 > 0 ? this.push(Action.TAKE, n2) : this;
  }
  /**
   * Drop a number of values from the sequence
   * @param {Number} n Number of items to drop greater than 0
   */
  drop(n2) {
    return n2 > 0 ? this.push(Action.DROP, n2) : this;
  }
  // Transformations
  /**
   * Returns a new lazy object with results of the transformation
   * The entire sequence is realized.
   *
   * @param {Function} fn Tranform function of type (Array) => (Any)
   */
  transform(fn2) {
    const self2 = this;
    let iter;
    return Lazy(() => {
      if (!iter) {
        iter = Lazy(fn2(self2.value()));
      }
      return iter.next();
    });
  }
  // Terminal methods
  /**
   * Returns the fully realized values of the iterators.
   * The return value will be an array unless `lazy.first()` was used.
   * The realized values are cached for subsequent calls.
   */
  value() {
    if (!this.isDone) {
      this.isDone = this.getNext(true).done;
    }
    return this.yieldedValues;
  }
  /**
   * Execute the funcion for each value. Will stop when an execution returns false.
   * @param {Function} f
   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true
   */
  each(f2) {
    for (; ; ) {
      const o2 = this.next();
      if (o2.done)
        break;
      if (f2(o2.value) === false)
        return false;
    }
    return true;
  }
  /**
   * Returns the reduction of sequence according the reducing function
   *
   * @param {*} f a reducing function
   * @param {*} initialValue
   */
  reduce(f2, initialValue) {
    let o2 = this.next();
    if (initialValue === void 0 && !o2.done) {
      initialValue = o2.value;
      o2 = this.next();
    }
    while (!o2.done) {
      initialValue = f2(initialValue, o2.value);
      o2 = this.next();
    }
    return initialValue;
  }
  /**
   * Returns the number of matched items in the sequence
   */
  size() {
    return this.reduce((acc, _2) => ++acc, 0);
  }
  [Symbol.iterator]() {
    return this;
  }
}
lazy.Iterator = Iterator;
Object.defineProperty(aggregator, "__esModule", { value: true });
aggregator.Aggregator = void 0;
const core_1$1M = core;
const lazy_1$6 = lazy;
const util_1$1L = util$3;
class Aggregator {
  constructor(pipeline2, options2) {
    this.pipeline = pipeline2;
    this.options = (0, core_1$1M.initOptions)(options2);
  }
  /**
   * Returns an `Lazy` iterator for processing results of pipeline
   *
   * @param {*} collection An array or iterator object
   * @returns {Iterator} an iterator object
   */
  stream(collection) {
    let iterator2 = (0, lazy_1$6.Lazy)(collection);
    const mode = this.options.processingMode;
    if (mode == core_1$1M.ProcessingMode.CLONE_ALL || mode == core_1$1M.ProcessingMode.CLONE_INPUT) {
      iterator2.map(util_1$1L.cloneDeep);
    }
    const pipelineOperators = new Array();
    if (!(0, util_1$1L.isEmpty)(this.pipeline)) {
      for (const operator of this.pipeline) {
        const operatorKeys = Object.keys(operator);
        const opName = operatorKeys[0];
        const call = (0, core_1$1M.getOperator)(core_1$1M.OperatorType.PIPELINE, opName, this.options);
        (0, util_1$1L.assert)(operatorKeys.length === 1 && !!call, `invalid pipeline operator ${opName}`);
        pipelineOperators.push(opName);
        iterator2 = call(iterator2, operator[opName], this.options);
      }
    }
    if (mode == core_1$1M.ProcessingMode.CLONE_OUTPUT || mode == core_1$1M.ProcessingMode.CLONE_ALL && !!(0, util_1$1L.intersection)([["$group", "$unwind"], pipelineOperators]).length) {
      iterator2.map(util_1$1L.cloneDeep);
    }
    return iterator2;
  }
  /**
   * Return the results of the aggregation as an array.
   *
   * @param {*} collection
   * @param {*} query
   */
  run(collection) {
    return this.stream(collection).value();
  }
}
aggregator.Aggregator = Aggregator;
Object.defineProperty(cursor, "__esModule", { value: true });
cursor.Cursor = void 0;
const aggregator_1$6 = aggregator;
const lazy_1$5 = lazy;
const util_1$1K = util$3;
class Cursor {
  constructor(source, predicate, projection, options2) {
    this.source = source;
    this.predicate = predicate;
    this.projection = projection;
    this.options = options2;
    this.operators = [];
    this.result = null;
    this.buffer = [];
  }
  /** Returns the iterator from running the query */
  fetch() {
    if (this.result)
      return this.result;
    if ((0, util_1$1K.isObject)(this.projection)) {
      this.operators.push({ $project: this.projection });
    }
    this.result = (0, lazy_1$5.Lazy)(this.source).filter(this.predicate);
    if (this.operators.length > 0) {
      this.result = new aggregator_1$6.Aggregator(this.operators, this.options).stream(this.result);
    }
    return this.result;
  }
  /** Returns an iterator with the buffered data included */
  fetchAll() {
    const buffered = (0, lazy_1$5.Lazy)([...this.buffer]);
    this.buffer = [];
    return (0, lazy_1$5.compose)(buffered, this.fetch());
  }
  /**
   * Return remaining objects in the cursor as an array. This method exhausts the cursor
   * @returns {Array}
   */
  all() {
    return this.fetchAll().value();
  }
  /**
   * Returns the number of objects return in the cursor. This method exhausts the cursor
   * @returns {Number}
   */
  count() {
    return this.all().length;
  }
  /**
   * Returns a cursor that begins returning results only after passing or skipping a number of documents.
   * @param {Number} n the number of results to skip.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  skip(n2) {
    this.operators.push({ $skip: n2 });
    return this;
  }
  /**
   * Constrains the size of a cursor's result set.
   * @param {Number} n the number of results to limit to.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  limit(n2) {
    this.operators.push({ $limit: n2 });
    return this;
  }
  /**
   * Returns results ordered according to a sort specification.
   * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  sort(modifier) {
    this.operators.push({ $sort: modifier });
    return this;
  }
  /**
   * Specifies the collation for the cursor returned by the `mingo.Query.find`
   * @param {*} spec
   */
  collation(spec) {
    this.options = Object.assign(Object.assign({}, this.options), { collation: spec });
    return this;
  }
  /**
   * Returns the next document in a cursor.
   * @returns {Object | Boolean}
   */
  next() {
    if (this.buffer.length > 0) {
      return this.buffer.pop();
    }
    const o2 = this.fetch().next();
    if (o2.done)
      return;
    return o2.value;
  }
  /**
   * Returns true if the cursor has documents and can be iterated.
   * @returns {boolean}
   */
  hasNext() {
    if (this.buffer.length > 0)
      return true;
    const o2 = this.fetch().next();
    if (o2.done)
      return false;
    this.buffer.push(o2.value);
    return true;
  }
  /**
   * Applies a function to each document in a cursor and collects the return values in an array.
   * @param fn
   * @returns {Array}
   */
  map(fn2) {
    return this.all().map(fn2);
  }
  /**
   * Applies a JavaScript function for every document in a cursor.
   * @param fn
   */
  forEach(fn2) {
    this.all().forEach(fn2);
  }
  [Symbol.iterator]() {
    return this.fetchAll();
  }
}
cursor.Cursor = Cursor;
Object.defineProperty(query, "__esModule", { value: true });
query.Query = void 0;
const core_1$1L = core;
const cursor_1 = cursor;
const util_1$1J = util$3;
class Query {
  constructor(condition, options2) {
    this.condition = condition;
    this.options = (0, core_1$1L.initOptions)(options2);
    this.compiled = [];
    this.compile();
  }
  compile() {
    (0, util_1$1J.assert)((0, util_1$1J.isObject)(this.condition), "query criteria must be an object");
    const whereOperator = {};
    for (const [field, expr2] of Object.entries(this.condition)) {
      if ("$where" === field) {
        Object.assign(whereOperator, { field, expr: expr2 });
      } else if ((0, util_1$1J.inArray)(["$and", "$or", "$nor", "$expr", "$jsonSchema"], field)) {
        this.processOperator(field, field, expr2);
      } else {
        (0, util_1$1J.assert)(!(0, util_1$1J.isOperator)(field), `unknown top level operator: ${field}`);
        for (const [operator, val] of Object.entries((0, util_1$1J.normalize)(expr2))) {
          this.processOperator(field, operator, val);
        }
      }
      if (whereOperator.field) {
        this.processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);
      }
    }
  }
  processOperator(field, operator, value) {
    const call = (0, core_1$1L.getOperator)(core_1$1L.OperatorType.QUERY, operator, this.options);
    if (!call) {
      throw new Error(`unknown operator ${operator}`);
    }
    const fn2 = call(field, value, this.options);
    this.compiled.push(fn2);
  }
  /**
   * Checks if the object passes the query criteria. Returns true if so, false otherwise.
   *
   * @param obj The object to test
   * @returns {boolean} True or false
   */
  test(obj) {
    for (let i2 = 0, len = this.compiled.length; i2 < len; i2++) {
      if (!this.compiled[i2](obj)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns a cursor to select matching documents from the input source.
   *
   * @param source A source providing a sequence of documents
   * @param projection An optional projection criteria
   * @returns {Cursor} A Cursor for iterating over the results
   */
  find(collection, projection) {
    return new cursor_1.Cursor(collection, (x2) => this.test(x2), projection || {}, this.options);
  }
  /**
   * Remove matched documents from the collection returning the remainder
   *
   * @param collection An array of documents
   * @returns {Array} A new array with matching elements removed
   */
  remove(collection) {
    return collection.reduce((acc, obj) => {
      if (!this.test(obj))
        acc.push(obj);
      return acc;
    }, []);
  }
}
query.Query = Query;
var pipeline = {};
var addFields = {};
Object.defineProperty(addFields, "__esModule", { value: true });
addFields.$addFields = void 0;
const core_1$1K = core;
const util_1$1I = util$3;
const $addFields = (collection, expr2, options2) => {
  const newFields = Object.keys(expr2);
  if (newFields.length === 0)
    return collection;
  return collection.map((obj) => {
    const newObj = Object.assign({}, obj);
    for (const field of newFields) {
      const newValue = (0, core_1$1K.computeValue)(obj, expr2[field], null, options2);
      if (newValue !== void 0) {
        (0, util_1$1I.setValue)(newObj, field, newValue);
      } else {
        (0, util_1$1I.removeValue)(newObj, field);
      }
    }
    return newObj;
  });
};
addFields.$addFields = $addFields;
var bucket = {};
Object.defineProperty(bucket, "__esModule", { value: true });
bucket.$bucket = void 0;
const core_1$1J = core;
const lazy_1$4 = lazy;
const util_1$1H = util$3;
const $bucket = (collection, expr2, options2) => {
  const boundaries = [...expr2.boundaries];
  const defaultKey = expr2.default;
  const lower = boundaries[0];
  const upper = boundaries[boundaries.length - 1];
  const outputExpr = expr2.output || { count: { $sum: 1 } };
  (0, util_1$1H.assert)(expr2.boundaries.length > 2, "$bucket 'boundaries' expression must have at least 3 elements");
  const boundType = (0, util_1$1H.getType)(lower);
  for (let i2 = 0, len = boundaries.length - 1; i2 < len; i2++) {
    (0, util_1$1H.assert)(boundType === (0, util_1$1H.getType)(boundaries[i2 + 1]), "$bucket 'boundaries' must all be of the same type");
    (0, util_1$1H.assert)((0, util_1$1H.compare)(boundaries[i2], boundaries[i2 + 1]) < 0, "$bucket 'boundaries' must be sorted in ascending order");
  }
  !(0, util_1$1H.isNil)(defaultKey) && (0, util_1$1H.getType)(expr2.default) === (0, util_1$1H.getType)(lower) && (0, util_1$1H.assert)((0, util_1$1H.compare)(expr2.default, upper) >= 0 || (0, util_1$1H.compare)(expr2.default, lower) < 0, "$bucket 'default' expression must be out of boundaries range");
  const grouped = {};
  for (const k2 of boundaries) {
    grouped[k2] = [];
  }
  if (!(0, util_1$1H.isNil)(defaultKey))
    grouped[defaultKey] = [];
  let iterator2;
  return (0, lazy_1$4.Lazy)(() => {
    if (!iterator2) {
      collection.each((obj) => {
        const key = (0, core_1$1J.computeValue)(obj, expr2.groupBy, null, options2);
        if ((0, util_1$1H.isNil)(key) || (0, util_1$1H.compare)(key, lower) < 0 || (0, util_1$1H.compare)(key, upper) >= 0) {
          (0, util_1$1H.assert)(!(0, util_1$1H.isNil)(defaultKey), "$bucket require a default for out of range values");
          grouped[defaultKey].push(obj);
        } else {
          (0, util_1$1H.assert)((0, util_1$1H.compare)(key, lower) >= 0 && (0, util_1$1H.compare)(key, upper) < 0, "$bucket 'groupBy' expression must resolve to a value in range of boundaries");
          const index = findInsertIndex(boundaries, key);
          const boundKey = boundaries[Math.max(0, index - 1)];
          grouped[boundKey].push(obj);
        }
      });
      boundaries.pop();
      if (!(0, util_1$1H.isNil)(defaultKey))
        boundaries.push(defaultKey);
      iterator2 = (0, lazy_1$4.Lazy)(boundaries).map((key) => {
        const acc = (0, core_1$1J.computeValue)(grouped[key], outputExpr, null, options2);
        return (0, util_1$1H.into)(acc, { _id: key });
      });
    }
    return iterator2.next();
  });
};
bucket.$bucket = $bucket;
function findInsertIndex(sorted, item) {
  let lo = 0;
  let hi = sorted.length - 1;
  while (lo <= hi) {
    const mid = Math.round(lo + (hi - lo) / 2);
    if ((0, util_1$1H.compare)(item, sorted[mid]) < 0) {
      hi = mid - 1;
    } else if ((0, util_1$1H.compare)(item, sorted[mid]) > 0) {
      lo = mid + 1;
    } else {
      return mid;
    }
  }
  return lo;
}
var bucketAuto = {};
Object.defineProperty(bucketAuto, "__esModule", { value: true });
bucketAuto.$bucketAuto = void 0;
const core_1$1I = core;
const util_1$1G = util$3;
const $bucketAuto = (collection, expr2, options2) => {
  const outputExpr = expr2.output || { count: { $sum: 1 } };
  const groupByExpr = expr2.groupBy;
  const bucketCount = expr2.buckets;
  (0, util_1$1G.assert)(bucketCount > 0, `The $bucketAuto 'buckets' field must be greater than 0, but found: ${bucketCount}`);
  const ID_KEY2 = "_id";
  return collection.transform((coll) => {
    const approxBucketSize = Math.max(1, Math.round(coll.length / bucketCount));
    const computeValueOptimized = (0, util_1$1G.memoize)(core_1$1I.computeValue, options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
    const grouped = /* @__PURE__ */ new Map();
    const remaining = [];
    const sorted = (0, util_1$1G.sortBy)(coll, (o2) => {
      const key = computeValueOptimized(o2, groupByExpr, null, options2);
      if ((0, util_1$1G.isNil)(key)) {
        remaining.push(o2);
      } else {
        if (!grouped.has(key))
          grouped.set(key, []);
        grouped.get(key).push(o2);
      }
      return key;
    });
    const result = [];
    let index = 0;
    for (let i2 = 0, len = sorted.length; i2 < bucketCount && index < len; i2++) {
      const boundaries = {};
      const bucketItems = [];
      for (let j2 = 0; j2 < approxBucketSize && index < len; j2++) {
        let key = computeValueOptimized(sorted[index], groupByExpr, null, options2);
        if ((0, util_1$1G.isNil)(key))
          key = null;
        (0, util_1$1G.into)(bucketItems, (0, util_1$1G.isNil)(key) ? remaining : grouped.get(key));
        index += (0, util_1$1G.isNil)(key) ? remaining.length : grouped.get(key).length;
        if (!(0, util_1$1G.has)(boundaries, "min"))
          boundaries.min = key;
        if (result.length > 0) {
          const lastBucket = result[result.length - 1];
          lastBucket[ID_KEY2].max = boundaries.min;
        }
      }
      if (i2 == bucketCount - 1) {
        (0, util_1$1G.into)(bucketItems, sorted.slice(index));
      }
      const values = (0, core_1$1I.computeValue)(bucketItems, outputExpr, null, options2);
      result.push((0, util_1$1G.into)(values, {
        _id: boundaries
      }));
    }
    if (result.length > 0) {
      result[result.length - 1][ID_KEY2].max = computeValueOptimized(sorted[sorted.length - 1], groupByExpr, null, options2);
    }
    return result;
  });
};
bucketAuto.$bucketAuto = $bucketAuto;
var count$1 = {};
Object.defineProperty(count$1, "__esModule", { value: true });
count$1.$count = void 0;
const lazy_1$3 = lazy;
const util_1$1F = util$3;
const $count$1 = (collection, expr2, _2) => {
  (0, util_1$1F.assert)((0, util_1$1F.isString)(expr2) && expr2.trim() !== "" && expr2.indexOf(".") === -1 && expr2.trim()[0] !== "$", "Invalid expression value for $count");
  return (0, lazy_1$3.Lazy)([
    {
      [expr2]: collection.size()
    }
  ]);
};
count$1.$count = $count$1;
var facet = {};
Object.defineProperty(facet, "__esModule", { value: true });
facet.$facet = void 0;
const aggregator_1$5 = aggregator;
const core_1$1H = core;
const $facet = (collection, expr2, options2) => {
  return collection.transform((array2) => {
    const o2 = {};
    for (const [k2, pipeline2] of Object.entries(expr2)) {
      o2[k2] = new aggregator_1$5.Aggregator(pipeline2, Object.assign(Object.assign({}, options2), { processingMode: core_1$1H.ProcessingMode.CLONE_INPUT })).run(array2);
    }
    return [o2];
  });
};
facet.$facet = $facet;
var fill = {};
var ifNull = {};
Object.defineProperty(ifNull, "__esModule", { value: true });
ifNull.$ifNull = void 0;
const core_1$1G = core;
const util_1$1E = util$3;
const $ifNull = (obj, expr2, options2) => {
  const args2 = (0, core_1$1G.computeValue)(obj, expr2, null, options2);
  return args2.find((arg) => !(0, util_1$1E.isNil)(arg));
};
ifNull.$ifNull = $ifNull;
var linearFill = {};
var accumulator$1 = {};
var accumulator = {};
Object.defineProperty(accumulator, "__esModule", { value: true });
accumulator.$accumulator = void 0;
const core_1$1F = core;
const util_1$1D = util$3;
const $accumulator = (collection, expr2, options2) => {
  var _a;
  (0, util_1$1D.assert)(!!options2 && options2.scriptEnabled, "$accumulator operator requires 'scriptEnabled' option to be true");
  if (collection.length == 0)
    return expr2.initArgs;
  const copts = core_1$1F.ComputeOptions.init(options2);
  const initArgs = (0, core_1$1F.computeValue)({}, expr2.initArgs || [], null, copts.update(((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId) || {}));
  let state = expr2.init.call(null, ...initArgs);
  for (const doc of collection) {
    const args2 = (0, core_1$1F.computeValue)(doc, expr2.accumulateArgs, null, copts.update(doc));
    state = expr2.accumulate.call(null, ...[state, ...args2]);
  }
  return expr2.finalize ? expr2.finalize.call(null, state) : state;
};
accumulator.$accumulator = $accumulator;
var addToSet = {};
var push$1 = {};
Object.defineProperty(push$1, "__esModule", { value: true });
push$1.$push = void 0;
const core_1$1E = core;
const util_1$1C = util$3;
const $push = (collection, expr2, options2) => {
  if ((0, util_1$1C.isNil)(expr2))
    return collection;
  const copts = core_1$1E.ComputeOptions.init(options2);
  return collection.map((obj) => (0, core_1$1E.computeValue)(obj, expr2, null, copts.update(obj)));
};
push$1.$push = $push;
Object.defineProperty(addToSet, "__esModule", { value: true });
addToSet.$addToSet = void 0;
const util_1$1B = util$3;
const push_1$f = push$1;
const $addToSet = (collection, expr2, options2) => {
  return (0, util_1$1B.unique)((0, push_1$f.$push)(collection, expr2, options2), options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
};
addToSet.$addToSet = $addToSet;
var avg = {};
Object.defineProperty(avg, "__esModule", { value: true });
avg.$avg = void 0;
const util_1$1A = util$3;
const push_1$e = push$1;
const $avg = (collection, expr2, options2) => {
  const data = (0, push_1$e.$push)(collection, expr2, options2).filter(util_1$1A.isNumber);
  const sum2 = data.reduce((acc, n2) => acc + n2, 0);
  return sum2 / (data.length || 1);
};
avg.$avg = $avg;
var bottom = {};
var bottomN = {};
Object.defineProperty(bottomN, "__esModule", { value: true });
bottomN.$bottomN = void 0;
const aggregator_1$4 = aggregator;
const core_1$1D = core;
const push_1$d = push$1;
const $bottomN = (collection, expr2, options2) => {
  const copts = core_1$1D.ComputeOptions.init(options2);
  const { n: n2, sortBy } = (0, core_1$1D.computeValue)(copts.local.groupId, expr2, null, copts);
  const result = new aggregator_1$4.Aggregator([{ $sort: sortBy }], copts).run(collection);
  const m2 = result.length;
  const p2 = n2;
  return (0, push_1$d.$push)(m2 <= p2 ? result : result.slice(m2 - p2), expr2.output, copts);
};
bottomN.$bottomN = $bottomN;
Object.defineProperty(bottom, "__esModule", { value: true });
bottom.$bottom = void 0;
const bottomN_1 = bottomN;
const $bottom = (collection, expr2, options2) => (0, bottomN_1.$bottomN)(collection, Object.assign(Object.assign({}, expr2), { n: 1 }), options2);
bottom.$bottom = $bottom;
var count = {};
Object.defineProperty(count, "__esModule", { value: true });
count.$count = void 0;
const $count = (collection, _expr, _options2) => collection.length;
count.$count = $count;
var covariancePop = {};
var _internal$7 = {};
Object.defineProperty(_internal$7, "__esModule", { value: true });
_internal$7.covariance = _internal$7.stddev = void 0;
function stddev(data, sampled = true) {
  const sum2 = data.reduce((acc, n2) => acc + n2, 0);
  const N2 = data.length || 1;
  const avg2 = sum2 / N2;
  return Math.sqrt(data.reduce((acc, n2) => acc + Math.pow(n2 - avg2, 2), 0) / (N2 - Number(sampled)));
}
_internal$7.stddev = stddev;
function covariance(dataset, sampled = true) {
  if (!dataset)
    return null;
  if (dataset.length < 2)
    return sampled ? null : 0;
  let meanX = 0;
  let meanY = 0;
  for (const [x2, y2] of dataset) {
    meanX += x2;
    meanY += y2;
  }
  meanX /= dataset.length;
  meanY /= dataset.length;
  let result = 0;
  for (const [x2, y2] of dataset) {
    result += (x2 - meanX) * (y2 - meanY);
  }
  return result / (dataset.length - Number(sampled));
}
_internal$7.covariance = covariance;
Object.defineProperty(covariancePop, "__esModule", { value: true });
covariancePop.$covariancePop = void 0;
const _internal_1$Q = _internal$7;
const push_1$c = push$1;
const $covariancePop = (collection, expr2, options2) => (0, _internal_1$Q.covariance)((0, push_1$c.$push)(collection, expr2, options2), false);
covariancePop.$covariancePop = $covariancePop;
var covarianceSamp = {};
Object.defineProperty(covarianceSamp, "__esModule", { value: true });
covarianceSamp.$covarianceSamp = void 0;
const _internal_1$P = _internal$7;
const push_1$b = push$1;
const $covarianceSamp = (collection, expr2, options2) => (0, _internal_1$P.covariance)((0, push_1$b.$push)(collection, expr2, options2), true);
covarianceSamp.$covarianceSamp = $covarianceSamp;
var first$1 = {};
Object.defineProperty(first$1, "__esModule", { value: true });
first$1.$first = void 0;
const core_1$1C = core;
const $first$1 = (collection, expr2, options2) => {
  return collection.length > 0 ? (0, core_1$1C.computeValue)(collection[0], expr2, null, options2) : void 0;
};
first$1.$first = $first$1;
var firstN$1 = {};
Object.defineProperty(firstN$1, "__esModule", { value: true });
firstN$1.$firstN = void 0;
const core_1$1B = core;
const push_1$a = push$1;
const $firstN$1 = (collection, expr2, options2) => {
  var _a;
  const copts = core_1$1B.ComputeOptions.init(options2);
  const m2 = collection.length;
  const n2 = (0, core_1$1B.computeValue)((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId, expr2.n, null, copts);
  return (0, push_1$a.$push)(m2 <= n2 ? collection : collection.slice(0, n2), expr2.input, options2);
};
firstN$1.$firstN = $firstN$1;
var last$1 = {};
Object.defineProperty(last$1, "__esModule", { value: true });
last$1.$last = void 0;
const core_1$1A = core;
const $last$1 = (collection, expr2, options2) => {
  return collection.length > 0 ? (0, core_1$1A.computeValue)(collection[collection.length - 1], expr2, null, options2) : void 0;
};
last$1.$last = $last$1;
var lastN$1 = {};
Object.defineProperty(lastN$1, "__esModule", { value: true });
lastN$1.$lastN = void 0;
const core_1$1z = core;
const push_1$9 = push$1;
const $lastN$1 = (collection, expr2, options2) => {
  var _a;
  const copts = core_1$1z.ComputeOptions.init(options2);
  const m2 = collection.length;
  const n2 = (0, core_1$1z.computeValue)((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId, expr2.n, null, copts);
  return (0, push_1$9.$push)(m2 <= n2 ? collection : collection.slice(m2 - n2), expr2.input, options2);
};
lastN$1.$lastN = $lastN$1;
var max = {};
Object.defineProperty(max, "__esModule", { value: true });
max.$max = void 0;
const util_1$1z = util$3;
const push_1$8 = push$1;
const $max = (collection, expr2, options2) => {
  const nums = (0, push_1$8.$push)(collection, expr2, options2).filter(util_1$1z.isNotNaN);
  const n2 = nums.reduce((acc, n3) => (0, util_1$1z.compare)(n3, acc) >= 0 ? n3 : acc, -Infinity);
  return n2 === -Infinity ? void 0 : n2;
};
max.$max = $max;
var maxN$1 = {};
Object.defineProperty(maxN$1, "__esModule", { value: true });
maxN$1.$maxN = void 0;
const core_1$1y = core;
const util_1$1y = util$3;
const push_1$7 = push$1;
const $maxN$1 = (collection, expr2, options2) => {
  var _a;
  const copts = core_1$1y.ComputeOptions.init(options2);
  const m2 = collection.length;
  const n2 = (0, core_1$1y.computeValue)((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId, expr2.n, null, copts);
  const arr = (0, push_1$7.$push)(collection, expr2.input, options2).filter((o2) => !(0, util_1$1y.isNil)(o2));
  arr.sort((a2, b2) => -1 * (0, util_1$1y.compare)(a2, b2));
  return m2 <= n2 ? arr : arr.slice(0, n2);
};
maxN$1.$maxN = $maxN$1;
var mergeObjects$1 = {};
var mergeObjects = {};
Object.defineProperty(mergeObjects, "__esModule", { value: true });
mergeObjects.$mergeObjects = void 0;
const core_1$1x = core;
const util_1$1x = util$3;
const $mergeObjects$1 = (obj, expr2, options2) => {
  const docs = (0, core_1$1x.computeValue)(obj, expr2, null, options2);
  return docs instanceof Array ? docs.reduce((memo2, o2) => (0, util_1$1x.into)(memo2, o2), {}) : {};
};
mergeObjects.$mergeObjects = $mergeObjects$1;
Object.defineProperty(mergeObjects$1, "__esModule", { value: true });
mergeObjects$1.$mergeObjects = void 0;
const mergeObjects_1 = mergeObjects;
const $mergeObjects = (collection, _2, options2) => (0, mergeObjects_1.$mergeObjects)({ docs: collection }, "$docs", options2);
mergeObjects$1.$mergeObjects = $mergeObjects;
var min = {};
Object.defineProperty(min, "__esModule", { value: true });
min.$min = void 0;
const util_1$1w = util$3;
const push_1$6 = push$1;
const $min = (collection, expr2, options2) => {
  const nums = (0, push_1$6.$push)(collection, expr2, options2).filter(util_1$1w.isNotNaN);
  const n2 = nums.reduce((acc, n3) => (0, util_1$1w.compare)(n3, acc) <= 0 ? n3 : acc, Infinity);
  return n2 === Infinity ? void 0 : n2;
};
min.$min = $min;
var minN$1 = {};
Object.defineProperty(minN$1, "__esModule", { value: true });
minN$1.$minN = void 0;
const core_1$1w = core;
const util_1$1v = util$3;
const push_1$5 = push$1;
const $minN$1 = (collection, expr2, options2) => {
  var _a;
  const copts = core_1$1w.ComputeOptions.init(options2);
  const m2 = collection.length;
  const n2 = (0, core_1$1w.computeValue)((_a = copts === null || copts === void 0 ? void 0 : copts.local) === null || _a === void 0 ? void 0 : _a.groupId, expr2.n, null, copts);
  const arr = (0, push_1$5.$push)(collection, expr2.input, options2).filter((o2) => !(0, util_1$1v.isNil)(o2));
  arr.sort(util_1$1v.compare);
  return m2 <= n2 ? arr : arr.slice(0, n2);
};
minN$1.$minN = $minN$1;
var stdDevPop = {};
Object.defineProperty(stdDevPop, "__esModule", { value: true });
stdDevPop.$stdDevPop = void 0;
const util_1$1u = util$3;
const _internal_1$O = _internal$7;
const push_1$4 = push$1;
const $stdDevPop = (collection, expr2, options2) => (0, _internal_1$O.stddev)((0, push_1$4.$push)(collection, expr2, options2).filter(util_1$1u.isNumber), false);
stdDevPop.$stdDevPop = $stdDevPop;
var stdDevSamp = {};
Object.defineProperty(stdDevSamp, "__esModule", { value: true });
stdDevSamp.$stdDevSamp = void 0;
const util_1$1t = util$3;
const _internal_1$N = _internal$7;
const push_1$3 = push$1;
const $stdDevSamp = (collection, expr2, options2) => (0, _internal_1$N.stddev)((0, push_1$3.$push)(collection, expr2, options2).filter(util_1$1t.isNumber), true);
stdDevSamp.$stdDevSamp = $stdDevSamp;
var sum = {};
Object.defineProperty(sum, "__esModule", { value: true });
sum.$sum = void 0;
const util_1$1s = util$3;
const push_1$2 = push$1;
const $sum = (collection, expr2, options2) => {
  if (!(0, util_1$1s.isArray)(collection))
    return 0;
  if ((0, util_1$1s.isNumber)(expr2))
    return collection.length * expr2;
  const nums = (0, push_1$2.$push)(collection, expr2, options2).filter(util_1$1s.isNumber);
  return nums.reduce((acc, n2) => acc + n2, 0);
};
sum.$sum = $sum;
var top = {};
var topN = {};
Object.defineProperty(topN, "__esModule", { value: true });
topN.$topN = void 0;
const aggregator_1$3 = aggregator;
const core_1$1v = core;
const push_1$1 = push$1;
const $topN = (collection, expr2, options2) => {
  const copts = core_1$1v.ComputeOptions.init(options2);
  const { n: n2, sortBy } = (0, core_1$1v.computeValue)(copts.local.groupId, expr2, null, copts);
  const result = new aggregator_1$3.Aggregator([{ $sort: sortBy }, { $limit: n2 }], copts).run(collection);
  return (0, push_1$1.$push)(result, expr2.output, copts);
};
topN.$topN = $topN;
Object.defineProperty(top, "__esModule", { value: true });
top.$top = void 0;
const topN_1 = topN;
const $top = (collection, expr2, options2) => (0, topN_1.$topN)(collection, Object.assign(Object.assign({}, expr2), { n: 1 }), options2);
top.$top = $top;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(accumulator, exports);
  __exportStar(addToSet, exports);
  __exportStar(avg, exports);
  __exportStar(bottom, exports);
  __exportStar(bottomN, exports);
  __exportStar(count, exports);
  __exportStar(covariancePop, exports);
  __exportStar(covarianceSamp, exports);
  __exportStar(first$1, exports);
  __exportStar(firstN$1, exports);
  __exportStar(last$1, exports);
  __exportStar(lastN$1, exports);
  __exportStar(max, exports);
  __exportStar(maxN$1, exports);
  __exportStar(mergeObjects$1, exports);
  __exportStar(min, exports);
  __exportStar(minN$1, exports);
  __exportStar(push$1, exports);
  __exportStar(stdDevPop, exports);
  __exportStar(stdDevSamp, exports);
  __exportStar(sum, exports);
  __exportStar(top, exports);
  __exportStar(topN, exports);
})(accumulator$1);
var _internal$6 = {};
var _internal$5 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexStrip = exports.regexQuote = exports.padDigits = exports.computeDate = exports.adjustDate = exports.formatTimezone = exports.parseTimezone = exports.DATE_SYM_TABLE = exports.DATE_PART_INTERVAL = exports.DATE_FORMAT = exports.DURATION_IN_MILLIS = exports.MILLIS_PER_DAY = exports.MINUTES_PER_HOUR = exports.isoWeekYear = exports.isoWeek = exports.getDayOfYear = exports.isLeapYear = void 0;
  const core_12 = core;
  const util_12 = util$3;
  const COMMON_YEAR_DAYS_OFFSET = [
    0,
    31,
    59,
    90,
    120,
    151,
    181,
    212,
    243,
    273,
    304,
    334
  ];
  const LEAP_YEAR_DAYS_OFFSET = [
    0,
    31,
    60,
    91,
    121,
    152,
    182,
    213,
    244,
    274,
    305,
    335
  ];
  const p2 = (y2) => (y2 + Math.floor(y2 / 4) - Math.floor(y2 / 100) + Math.floor(y2 / 400)) % 7;
  const weeks = (y2) => 52 + Number(p2(y2) == 4 || p2(y2 - 1) == 3);
  const isLeapYear = (year2) => (year2 & 3) == 0 && (year2 % 100 != 0 || year2 % 400 == 0);
  exports.isLeapYear = isLeapYear;
  const getDayOfYear = (d2) => ((0, exports.isLeapYear)(d2.getUTCFullYear()) ? LEAP_YEAR_DAYS_OFFSET : COMMON_YEAR_DAYS_OFFSET)[d2.getUTCMonth()] + d2.getUTCDate();
  exports.getDayOfYear = getDayOfYear;
  function isoWeek2(d2) {
    const w2 = Math.floor((10 + (0, exports.getDayOfYear)(d2) - (d2.getUTCDay() || 7)) / 7);
    if (w2 < 1)
      return weeks(d2.getUTCFullYear() - 1);
    if (w2 > weeks(d2.getUTCFullYear()))
      return 1;
    return w2;
  }
  exports.isoWeek = isoWeek2;
  function isoWeekYear2(d2) {
    return d2.getUTCFullYear() - Number(d2.getUTCMonth() == 0 && d2.getUTCDate() == 1 && d2.getUTCDay() < 1);
  }
  exports.isoWeekYear = isoWeekYear2;
  exports.MINUTES_PER_HOUR = 60;
  exports.MILLIS_PER_DAY = 1e3 * 60 * 60 * 24;
  exports.DURATION_IN_MILLIS = {
    week: exports.MILLIS_PER_DAY * 7,
    day: exports.MILLIS_PER_DAY,
    hour: 1e3 * 60 * 60,
    minute: 1e3 * 60,
    second: 1e3,
    millisecond: 1
  };
  exports.DATE_FORMAT = "%Y-%m-%dT%H:%M:%S.%LZ";
  exports.DATE_PART_INTERVAL = [
    ["year", 0, 9999],
    ["month", 1, 12],
    ["day", 1, 31],
    ["hour", 0, 23],
    ["minute", 0, 59],
    ["second", 0, 59],
    ["millisecond", 0, 999]
  ];
  exports.DATE_SYM_TABLE = {
    "%Y": { name: "year", padding: 4, re: /([0-9]{4})/ },
    "%G": { name: "year", padding: 4, re: /([0-9]{4})/ },
    "%m": { name: "month", padding: 2, re: /(0[1-9]|1[012])/ },
    "%d": { name: "day", padding: 2, re: /(0[1-9]|[12][0-9]|3[01])/ },
    "%H": { name: "hour", padding: 2, re: /([01][0-9]|2[0-3])/ },
    "%M": { name: "minute", padding: 2, re: /([0-5][0-9])/ },
    "%S": { name: "second", padding: 2, re: /([0-5][0-9]|60)/ },
    "%L": { name: "millisecond", padding: 3, re: /([0-9]{3})/ },
    "%u": { name: "weekday", padding: 1, re: /([1-7])/ },
    "%U": { name: "week", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },
    "%V": { name: "isoWeek", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },
    "%z": {
      name: "timezone",
      padding: 2,
      re: /(([+-][01][0-9]|2[0-3]):?([0-5][0-9])?)/
    },
    "%Z": { name: "minuteOffset", padding: 3, re: /([+-][0-9]{3})/ }
    // "%%": "%",
  };
  function parseTimezone(tzstr) {
    if ((0, util_12.isNil)(tzstr))
      return 0;
    const m2 = exports.DATE_SYM_TABLE["%z"].re.exec(tzstr);
    if (!m2)
      throw Error(`invalid or location-based timezone '${tzstr}' not supported`);
    const hr = parseInt(m2[2]) || 0;
    const min2 = parseInt(m2[3]) || 0;
    return (Math.abs(hr * exports.MINUTES_PER_HOUR) + min2) * (hr < 0 ? -1 : 1);
  }
  exports.parseTimezone = parseTimezone;
  function formatTimezone(minuteOffset) {
    return (minuteOffset < 0 ? "-" : "+") + padDigits(Math.abs(Math.floor(minuteOffset / exports.MINUTES_PER_HOUR)), 2) + padDigits(Math.abs(minuteOffset) % exports.MINUTES_PER_HOUR, 2);
  }
  exports.formatTimezone = formatTimezone;
  function adjustDate(d2, minuteOffset) {
    d2.setUTCMinutes(d2.getUTCMinutes() + minuteOffset);
  }
  exports.adjustDate = adjustDate;
  function computeDate(obj, expr2, options2) {
    const d2 = (0, core_12.computeValue)(obj, expr2, null, options2);
    if ((0, util_12.isDate)(d2))
      return new Date(d2);
    if ((0, util_12.isNumber)(d2))
      return new Date(d2 * 1e3);
    if (d2.date) {
      const date2 = (0, util_12.isDate)(d2.date) ? new Date(d2.date) : new Date(d2.date * 1e3);
      if (d2.timezone) {
        adjustDate(date2, parseTimezone(d2.timezone));
      }
      return date2;
    }
    throw Error(`cannot convert ${expr2 === null || expr2 === void 0 ? void 0 : expr2.toString()} to date`);
  }
  exports.computeDate = computeDate;
  function padDigits(n2, digits2) {
    return new Array(Math.max(digits2 - String(n2).length + 1, 0)).join("0") + n2.toString();
  }
  exports.padDigits = padDigits;
  function regexQuote(s2) {
    "^.-*?$".split("").forEach((c2) => {
      s2 = s2.replace(c2, `\\${c2}`);
    });
    return s2;
  }
  exports.regexQuote = regexQuote;
  function regexStrip(s2) {
    return s2.replace(/^\//, "").replace(/\/$/, "");
  }
  exports.regexStrip = regexStrip;
})(_internal$5);
var _internal$4 = {};
Object.defineProperty(_internal$4, "__esModule", { value: true });
_internal$4.isUnbounded = void 0;
const isUnbounded = (window2) => {
  const boundary = (window2 === null || window2 === void 0 ? void 0 : window2.documents) || (window2 === null || window2 === void 0 ? void 0 : window2.range);
  return !boundary || boundary[0] === "unbounded" && boundary[1] === "unbounded";
};
_internal$4.isUnbounded = isUnbounded;
Object.defineProperty(_internal$6, "__esModule", { value: true });
_internal$6.rank = _internal$6.withMemo = _internal$6.MILLIS_PER_UNIT = void 0;
const util_1$1r = util$3;
const accumulator_1$3 = accumulator$1;
const _internal_1$M = _internal$5;
const _internal_2 = _internal$4;
_internal$6.MILLIS_PER_UNIT = {
  week: _internal_1$M.MILLIS_PER_DAY * 7,
  day: _internal_1$M.MILLIS_PER_DAY,
  hour: _internal_1$M.MILLIS_PER_DAY / 24,
  minute: 6e4,
  second: 1e3,
  millisecond: 1
};
const memo = /* @__PURE__ */ new WeakMap();
function withMemo(collection, expr2, cacheFn, fn2) {
  if (!(0, _internal_2.isUnbounded)(expr2.parentExpr.output[expr2.field].window)) {
    return fn2(cacheFn());
  }
  if (!memo.has(collection)) {
    memo.set(collection, { [expr2.field]: cacheFn() });
  }
  const data = memo.get(collection);
  if (data[expr2.field] === void 0) {
    data[expr2.field] = cacheFn();
  }
  let failed = false;
  try {
    return fn2(data[expr2.field]);
  } catch (e2) {
    failed = true;
  } finally {
    if (failed || expr2.documentNumber === collection.length) {
      delete data[expr2.field];
      if (Object.keys(data).length === 0)
        memo.delete(collection);
    }
  }
}
_internal$6.withMemo = withMemo;
function rank(_2, collection, expr2, options2, dense) {
  return withMemo(collection, expr2, () => {
    const sortKey = "$" + Object.keys(expr2.parentExpr.sortBy)[0];
    const values = (0, accumulator_1$3.$push)(collection, sortKey, options2);
    const groups = (0, util_1$1r.groupBy)(values, (_3, n2) => values[n2], options2.hashFunction);
    return { values, groups };
  }, (input) => {
    const { values, groups: partitions } = input;
    if (partitions.size == collection.length) {
      return expr2.documentNumber;
    }
    const current = values[expr2.documentNumber - 1];
    let i2 = 0;
    let offset = 0;
    for (const key of partitions.keys()) {
      if ((0, util_1$1r.isEqual)(current, key)) {
        return dense ? i2 + 1 : offset + 1;
      }
      i2++;
      offset += partitions.get(key).length;
    }
    throw new Error("rank: invalid return value. please submit a bug report.");
  });
}
_internal$6.rank = rank;
Object.defineProperty(linearFill, "__esModule", { value: true });
linearFill.$linearFill = void 0;
const util_1$1q = util$3;
const accumulator_1$2 = accumulator$1;
const _internal_1$L = _internal$6;
const interpolate = (x1, y1, x2, y2, x3) => y1 + (x3 - x1) * ((y2 - y1) / (x2 - x1));
function $linearFill(_2, collection, expr2, options2) {
  return (0, _internal_1$L.withMemo)(collection, expr2, () => {
    const sortKey = "$" + Object.keys(expr2.parentExpr.sortBy)[0];
    const points = (0, accumulator_1$2.$push)(collection, [sortKey, expr2.inputExpr], options2).filter(([x2, _3]) => (0, util_1$1q.isNumber)(+x2));
    if (points.length !== collection.length)
      return null;
    let lindex = -1;
    let rindex = 0;
    while (rindex < points.length) {
      while (lindex + 1 < points.length && (0, util_1$1q.isNumber)(points[lindex + 1][1])) {
        lindex++;
        rindex = lindex;
      }
      while (rindex + 1 < points.length && !(0, util_1$1q.isNumber)(points[rindex + 1][1])) {
        rindex++;
      }
      if (rindex + 1 >= points.length)
        break;
      rindex++;
      while (lindex + 1 < rindex) {
        points[lindex + 1][1] = interpolate(points[lindex][0], points[lindex][1], points[rindex][0], points[rindex][1], points[lindex + 1][0]);
        lindex++;
      }
      lindex = rindex;
    }
    return points.map(([_3, y2]) => y2);
  }, (values) => values[expr2.documentNumber - 1]);
}
linearFill.$linearFill = $linearFill;
var locf = {};
Object.defineProperty(locf, "__esModule", { value: true });
locf.$locf = void 0;
const util_1$1p = util$3;
const push_1 = push$1;
const _internal_1$K = _internal$6;
function $locf(_2, collection, expr2, options2) {
  return (0, _internal_1$K.withMemo)(collection, expr2, () => {
    const values = (0, push_1.$push)(collection, expr2.inputExpr, options2);
    for (let i2 = 1; i2 < values.length; i2++) {
      if ((0, util_1$1p.isNil)(values[i2]))
        values[i2] = values[i2 - 1];
    }
    return values;
  }, (series) => series[expr2.documentNumber - 1]);
}
locf.$locf = $locf;
var setWindowFields = {};
var expression = {};
var arithmetic = {};
var abs = {};
Object.defineProperty(abs, "__esModule", { value: true });
abs.$abs = void 0;
const core_1$1u = core;
const util_1$1o = util$3;
const $abs = (obj, expr2, options2) => {
  const n2 = (0, core_1$1u.computeValue)(obj, expr2, null, options2);
  return (0, util_1$1o.isNil)(n2) ? null : Math.abs(n2);
};
abs.$abs = $abs;
var add$1 = {};
Object.defineProperty(add$1, "__esModule", { value: true });
add$1.$add = void 0;
const core_1$1t = core;
const util_1$1n = util$3;
const $add = (obj, expr2, options2) => {
  const args2 = (0, core_1$1t.computeValue)(obj, expr2, null, options2);
  let foundDate = false;
  const result = args2.reduce((acc, val) => {
    if ((0, util_1$1n.isDate)(val)) {
      (0, util_1$1n.assert)(!foundDate, "'$add' can only have one date value");
      foundDate = true;
      val = val.getTime();
    }
    acc += val;
    return acc;
  }, 0);
  return foundDate ? new Date(result) : result;
};
add$1.$add = $add;
var ceil = {};
Object.defineProperty(ceil, "__esModule", { value: true });
ceil.$ceil = void 0;
const core_1$1s = core;
const util_1$1m = util$3;
const $ceil = (obj, expr2, options2) => {
  const n2 = (0, core_1$1s.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1m.isNil)(n2))
    return null;
  (0, util_1$1m.assert)((0, util_1$1m.isNumber)(n2) || isNaN(n2), "$ceil expression must resolve to a number.");
  return Math.ceil(n2);
};
ceil.$ceil = $ceil;
var divide = {};
Object.defineProperty(divide, "__esModule", { value: true });
divide.$divide = void 0;
const core_1$1r = core;
const $divide = (obj, expr2, options2) => {
  const args2 = (0, core_1$1r.computeValue)(obj, expr2, null, options2);
  return args2[0] / args2[1];
};
divide.$divide = $divide;
var exp = {};
Object.defineProperty(exp, "__esModule", { value: true });
exp.$exp = void 0;
const core_1$1q = core;
const util_1$1l = util$3;
const $exp = (obj, expr2, options2) => {
  const n2 = (0, core_1$1q.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1l.isNil)(n2))
    return null;
  (0, util_1$1l.assert)((0, util_1$1l.isNumber)(n2) || isNaN(n2), "$exp expression must resolve to a number.");
  return Math.exp(n2);
};
exp.$exp = $exp;
var floor = {};
Object.defineProperty(floor, "__esModule", { value: true });
floor.$floor = void 0;
const core_1$1p = core;
const util_1$1k = util$3;
const $floor = (obj, expr2, options2) => {
  const n2 = (0, core_1$1p.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1k.isNil)(n2))
    return null;
  (0, util_1$1k.assert)((0, util_1$1k.isNumber)(n2) || isNaN(n2), "$floor expression must resolve to a number.");
  return Math.floor(n2);
};
floor.$floor = $floor;
var ln = {};
Object.defineProperty(ln, "__esModule", { value: true });
ln.$ln = void 0;
const core_1$1o = core;
const util_1$1j = util$3;
const $ln = (obj, expr2, options2) => {
  const n2 = (0, core_1$1o.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1j.isNil)(n2))
    return null;
  (0, util_1$1j.assert)((0, util_1$1j.isNumber)(n2) || isNaN(n2), "$ln expression must resolve to a number.");
  return Math.log(n2);
};
ln.$ln = $ln;
var log = {};
Object.defineProperty(log, "__esModule", { value: true });
log.$log = void 0;
const core_1$1n = core;
const util_1$1i = util$3;
const $log = (obj, expr2, options2) => {
  const args2 = (0, core_1$1n.computeValue)(obj, expr2, null, options2);
  const msg = "$log expression must resolve to array(2) of numbers";
  (0, util_1$1i.assert)((0, util_1$1i.isArray)(args2) && args2.length === 2, msg);
  if (args2.some(util_1$1i.isNil))
    return null;
  (0, util_1$1i.assert)(args2.some(isNaN) || args2.every(util_1$1i.isNumber), msg);
  return Math.log10(args2[0]) / Math.log10(args2[1]);
};
log.$log = $log;
var log10 = {};
Object.defineProperty(log10, "__esModule", { value: true });
log10.$log10 = void 0;
const core_1$1m = core;
const util_1$1h = util$3;
const $log10 = (obj, expr2, options2) => {
  const n2 = (0, core_1$1m.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1h.isNil)(n2))
    return null;
  (0, util_1$1h.assert)((0, util_1$1h.isNumber)(n2) || isNaN(n2), "$log10 expression must resolve to a number.");
  return Math.log10(n2);
};
log10.$log10 = $log10;
var mod$1 = {};
Object.defineProperty(mod$1, "__esModule", { value: true });
mod$1.$mod = void 0;
const core_1$1l = core;
const $mod$1 = (obj, expr2, options2) => {
  const args2 = (0, core_1$1l.computeValue)(obj, expr2, null, options2);
  return args2[0] % args2[1];
};
mod$1.$mod = $mod$1;
var multiply = {};
Object.defineProperty(multiply, "__esModule", { value: true });
multiply.$multiply = void 0;
const core_1$1k = core;
const $multiply = (obj, expr2, options2) => {
  const args2 = (0, core_1$1k.computeValue)(obj, expr2, null, options2);
  return args2.reduce((acc, num) => acc * num, 1);
};
multiply.$multiply = $multiply;
var pow = {};
Object.defineProperty(pow, "__esModule", { value: true });
pow.$pow = void 0;
const core_1$1j = core;
const util_1$1g = util$3;
const $pow = (obj, expr2, options2) => {
  const args2 = (0, core_1$1j.computeValue)(obj, expr2, null, options2);
  (0, util_1$1g.assert)((0, util_1$1g.isArray)(args2) && args2.length === 2 && args2.every(util_1$1g.isNumber), "$pow expression must resolve to array(2) of numbers");
  (0, util_1$1g.assert)(!(args2[0] === 0 && args2[1] < 0), "$pow cannot raise 0 to a negative exponent");
  return Math.pow(args2[0], args2[1]);
};
pow.$pow = $pow;
var round = {};
var _internal$3 = {};
Object.defineProperty(_internal$3, "__esModule", { value: true });
_internal$3.truncate = void 0;
function truncate(num, places, roundOff) {
  const sign = Math.abs(num) === num ? 1 : -1;
  num = Math.abs(num);
  let result = Math.trunc(num);
  const decimals = parseFloat((num - result).toFixed(places + 1));
  if (places === 0) {
    const firstDigit = Math.trunc(10 * decimals);
    if (roundOff && ((result & 1) === 1 && firstDigit >= 5 || firstDigit > 5)) {
      result++;
    }
  } else if (places > 0) {
    const offset = Math.pow(10, places);
    let remainder = Math.trunc(decimals * offset);
    const lastDigit = Math.trunc(decimals * offset * 10) % 10;
    if (roundOff && lastDigit > 5) {
      remainder += 1;
    }
    result = (result * offset + remainder) / offset;
  } else if (places < 0) {
    const offset = Math.pow(10, -1 * places);
    let excess = result % offset;
    result = Math.max(0, result - excess);
    if (roundOff && sign === -1) {
      while (excess > 10) {
        excess -= excess % 10;
      }
      if (result > 0 && excess >= 5) {
        result += offset;
      }
    }
  }
  return result * sign;
}
_internal$3.truncate = truncate;
Object.defineProperty(round, "__esModule", { value: true });
round.$round = void 0;
const core_1$1i = core;
const util_1$1f = util$3;
const _internal_1$J = _internal$3;
const $round = (obj, expr2, options2) => {
  const args2 = (0, core_1$1i.computeValue)(obj, expr2, null, options2);
  const num = args2[0];
  const place = args2[1];
  if ((0, util_1$1f.isNil)(num) || isNaN(num) || Math.abs(num) === Infinity)
    return num;
  (0, util_1$1f.assert)((0, util_1$1f.isNumber)(num), "$round expression must resolve to a number.");
  return (0, _internal_1$J.truncate)(num, place, true);
};
round.$round = $round;
var sqrt = {};
Object.defineProperty(sqrt, "__esModule", { value: true });
sqrt.$sqrt = void 0;
const core_1$1h = core;
const util_1$1e = util$3;
const $sqrt = (obj, expr2, options2) => {
  const n2 = (0, core_1$1h.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$1e.isNil)(n2))
    return null;
  (0, util_1$1e.assert)((0, util_1$1e.isNumber)(n2) && n2 > 0 || isNaN(n2), "$sqrt expression must resolve to non-negative number.");
  return Math.sqrt(n2);
};
sqrt.$sqrt = $sqrt;
var subtract = {};
Object.defineProperty(subtract, "__esModule", { value: true });
subtract.$subtract = void 0;
const core_1$1g = core;
const $subtract = (obj, expr2, options2) => {
  const args2 = (0, core_1$1g.computeValue)(obj, expr2, null, options2);
  return args2[0] - args2[1];
};
subtract.$subtract = $subtract;
var trunc = {};
Object.defineProperty(trunc, "__esModule", { value: true });
trunc.$trunc = void 0;
const core_1$1f = core;
const util_1$1d = util$3;
const _internal_1$I = _internal$3;
const $trunc = (obj, expr2, options2) => {
  const arr = (0, core_1$1f.computeValue)(obj, expr2, null, options2);
  const num = arr[0];
  const places = arr[1];
  if ((0, util_1$1d.isNil)(num) || isNaN(num) || Math.abs(num) === Infinity)
    return num;
  (0, util_1$1d.assert)((0, util_1$1d.isNumber)(num), "$trunc expression must resolve to a number.");
  (0, util_1$1d.assert)((0, util_1$1d.isNil)(places) || (0, util_1$1d.isNumber)(places) && places > -20 && places < 100, "$trunc expression has invalid place");
  return (0, _internal_1$I.truncate)(num, places, false);
};
trunc.$trunc = $trunc;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(abs, exports);
  __exportStar(add$1, exports);
  __exportStar(ceil, exports);
  __exportStar(divide, exports);
  __exportStar(exp, exports);
  __exportStar(floor, exports);
  __exportStar(ln, exports);
  __exportStar(log, exports);
  __exportStar(log10, exports);
  __exportStar(mod$1, exports);
  __exportStar(multiply, exports);
  __exportStar(pow, exports);
  __exportStar(round, exports);
  __exportStar(sqrt, exports);
  __exportStar(subtract, exports);
  __exportStar(trunc, exports);
})(arithmetic);
var array$1 = {};
var arrayElemAt = {};
Object.defineProperty(arrayElemAt, "__esModule", { value: true });
arrayElemAt.$arrayElemAt = void 0;
const core_1$1e = core;
const util_1$1c = util$3;
const $arrayElemAt = (obj, expr2, options2) => {
  const args2 = (0, core_1$1e.computeValue)(obj, expr2, null, options2);
  (0, util_1$1c.assert)(args2 instanceof Array && args2.length === 2, "$arrayElemAt expression must resolve to array(2)");
  if (args2.some(util_1$1c.isNil))
    return null;
  const index = args2[1];
  const arr = args2[0];
  if (index < 0 && Math.abs(index) <= arr.length) {
    return arr[(index + arr.length) % arr.length];
  } else if (index >= 0 && index < arr.length) {
    return arr[index];
  }
  return void 0;
};
arrayElemAt.$arrayElemAt = $arrayElemAt;
var arrayToObject = {};
Object.defineProperty(arrayToObject, "__esModule", { value: true });
arrayToObject.$arrayToObject = void 0;
const core_1$1d = core;
const util_1$1b = util$3;
const $arrayToObject = (obj, expr2, options2) => {
  const arr = (0, core_1$1d.computeValue)(obj, expr2, null, options2);
  (0, util_1$1b.assert)((0, util_1$1b.isArray)(arr), "$arrayToObject expression must resolve to an array");
  return arr.reduce((newObj, val) => {
    while ((0, util_1$1b.isArray)(val) && val.length === 1)
      val = val[0];
    if (val instanceof Array && val.length == 2) {
      newObj[val[0]] = val[1];
    } else {
      const valObj = val;
      (0, util_1$1b.assert)((0, util_1$1b.isObject)(valObj) && (0, util_1$1b.has)(valObj, "k") && (0, util_1$1b.has)(valObj, "v"), "$arrayToObject expression is invalid.");
      newObj[valObj.k] = valObj.v;
    }
    return newObj;
  }, {});
};
arrayToObject.$arrayToObject = $arrayToObject;
var concatArrays = {};
Object.defineProperty(concatArrays, "__esModule", { value: true });
concatArrays.$concatArrays = void 0;
const core_1$1c = core;
const util_1$1a = util$3;
const $concatArrays = (obj, expr2, options2) => {
  const arr = (0, core_1$1c.computeValue)(obj, expr2, null, options2);
  (0, util_1$1a.assert)((0, util_1$1a.isArray)(arr), "$concatArrays must resolve to an array");
  if (arr.some(util_1$1a.isNil))
    return null;
  return arr.reduce((acc, item) => (0, util_1$1a.into)(acc, item), []);
};
concatArrays.$concatArrays = $concatArrays;
var filter = {};
Object.defineProperty(filter, "__esModule", { value: true });
filter.$filter = void 0;
const core_1$1b = core;
const util_1$19 = util$3;
const $filter = (obj, expr2, options2) => {
  const input = (0, core_1$1b.computeValue)(obj, expr2.input, null, options2);
  (0, util_1$19.assert)((0, util_1$19.isArray)(input), "$filter 'input' expression must resolve to an array");
  const copts = core_1$1b.ComputeOptions.init(options2, obj);
  const k2 = expr2.as || "this";
  const local = {
    variables: { [k2]: null }
  };
  return input.filter((o2) => {
    local.variables[k2] = o2;
    const b2 = (0, core_1$1b.computeValue)(obj, expr2.cond, null, copts.update(copts.root, local));
    return (0, util_1$19.truthy)(b2, options2.useStrictMode);
  });
};
filter.$filter = $filter;
var first = {};
Object.defineProperty(first, "__esModule", { value: true });
first.$first = void 0;
const core_1$1a = core;
const util_1$18 = util$3;
const accumulator_1$1 = accumulator$1;
const $first = (obj, expr2, options2) => {
  const copts = core_1$1a.ComputeOptions.init(options2);
  if (obj instanceof Array)
    return (0, accumulator_1$1.$first)(obj, expr2, copts.update());
  const arr = (0, core_1$1a.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$18.isNil)(arr))
    return null;
  (0, util_1$18.assert)((0, util_1$18.isArray)(arr), "Must resolve to an array/null or missing");
  return (0, accumulator_1$1.$first)(arr, "$$this", options2);
};
first.$first = $first;
var firstN = {};
Object.defineProperty(firstN, "__esModule", { value: true });
firstN.$firstN = void 0;
const core_1$19 = core;
const util_1$17 = util$3;
const firstN_1 = firstN$1;
const $firstN = (obj, expr2, options2) => {
  if (obj instanceof Array)
    return (0, firstN_1.$firstN)(obj, expr2, options2);
  const { input, n: n2 } = (0, core_1$19.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$17.isNil)(input))
    return null;
  (0, util_1$17.assert)((0, util_1$17.isArray)(input), "Must resolve to an array/null or missing");
  return (0, firstN_1.$firstN)(input, { n: n2, input: "$$this" }, options2);
};
firstN.$firstN = $firstN;
var _in$1 = {};
Object.defineProperty(_in$1, "__esModule", { value: true });
_in$1.$in = void 0;
const core_1$18 = core;
const util_1$16 = util$3;
const $in$1 = (obj, expr2, options2) => {
  const [item, arr] = (0, core_1$18.computeValue)(obj, expr2, null, options2);
  (0, util_1$16.assert)((0, util_1$16.isArray)(arr), "$in second argument must be an array");
  return arr.some(util_1$16.isEqual.bind(null, item));
};
_in$1.$in = $in$1;
var indexOfArray = {};
Object.defineProperty(indexOfArray, "__esModule", { value: true });
indexOfArray.$indexOfArray = void 0;
const core_1$17 = core;
const util_1$15 = util$3;
const $indexOfArray = (obj, expr2, options2) => {
  const args2 = (0, core_1$17.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$15.isNil)(args2))
    return null;
  let arr = args2[0];
  const searchValue = args2[1];
  if ((0, util_1$15.isNil)(arr))
    return null;
  (0, util_1$15.assert)((0, util_1$15.isArray)(arr), "$indexOfArray expression must resolve to an array.");
  const start = args2[2] || 0;
  let end = args2[3];
  if ((0, util_1$15.isNil)(end))
    end = arr.length;
  if (start > end)
    return -1;
  (0, util_1$15.assert)(start >= 0 && end >= 0, "$indexOfArray expression is invalid");
  if (start > 0 || end < arr.length) {
    arr = arr.slice(start, end);
  }
  let index = -1;
  arr.some((v2, i2) => {
    const b2 = (0, util_1$15.isEqual)(v2, searchValue);
    if (b2)
      index = i2;
    return b2;
  });
  return index + start;
};
indexOfArray.$indexOfArray = $indexOfArray;
var isArray = {};
Object.defineProperty(isArray, "__esModule", { value: true });
isArray.$isArray = void 0;
const core_1$16 = core;
const $isArray = (obj, expr2, options2) => {
  return (0, core_1$16.computeValue)(obj, expr2[0], null, options2) instanceof Array;
};
isArray.$isArray = $isArray;
var last = {};
Object.defineProperty(last, "__esModule", { value: true });
last.$last = void 0;
const core_1$15 = core;
const util_1$14 = util$3;
const accumulator_1 = accumulator$1;
const $last = (obj, expr2, options2) => {
  const copts = core_1$15.ComputeOptions.init(options2);
  if (obj instanceof Array)
    return (0, accumulator_1.$last)(obj, expr2, copts.update());
  const arr = (0, core_1$15.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$14.isNil)(arr))
    return null;
  (0, util_1$14.assert)((0, util_1$14.isArray)(arr), "Must resolve to an array/null or missing");
  return (0, accumulator_1.$last)(arr, "$$this", options2);
};
last.$last = $last;
var lastN = {};
Object.defineProperty(lastN, "__esModule", { value: true });
lastN.$lastN = void 0;
const core_1$14 = core;
const util_1$13 = util$3;
const lastN_1 = lastN$1;
const $lastN = (obj, expr2, options2) => {
  if (obj instanceof Array)
    return (0, lastN_1.$lastN)(obj, expr2, options2);
  const { input, n: n2 } = (0, core_1$14.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$13.isNil)(input))
    return null;
  (0, util_1$13.assert)((0, util_1$13.isArray)(input), "Must resolve to an array/null or missing");
  return (0, lastN_1.$lastN)(input, { n: n2, input: "$$this" }, options2);
};
lastN.$lastN = $lastN;
var map = {};
Object.defineProperty(map, "__esModule", { value: true });
map.$map = void 0;
const core_1$13 = core;
const util_1$12 = util$3;
const $map = (obj, expr2, options2) => {
  const input = (0, core_1$13.computeValue)(obj, expr2.input, null, options2);
  (0, util_1$12.assert)((0, util_1$12.isArray)(input), `$map 'input' expression must resolve to an array`);
  const copts = core_1$13.ComputeOptions.init(options2);
  const k2 = expr2.as || "this";
  return input.map((o2) => {
    return (0, core_1$13.computeValue)(obj, expr2.in, null, copts.update(copts.root, {
      variables: { [k2]: o2 }
    }));
  });
};
map.$map = $map;
var maxN = {};
Object.defineProperty(maxN, "__esModule", { value: true });
maxN.$maxN = void 0;
const core_1$12 = core;
const util_1$11 = util$3;
const maxN_1 = maxN$1;
const $maxN = (obj, expr2, options2) => {
  if (obj instanceof Array)
    return (0, maxN_1.$maxN)(obj, expr2, options2);
  const { input, n: n2 } = (0, core_1$12.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$11.isNil)(input))
    return null;
  (0, util_1$11.assert)((0, util_1$11.isArray)(input), "Must resolve to an array/null or missing");
  return (0, maxN_1.$maxN)(input, { n: n2, input: "$$this" }, options2);
};
maxN.$maxN = $maxN;
var minN = {};
Object.defineProperty(minN, "__esModule", { value: true });
minN.$minN = void 0;
const core_1$11 = core;
const util_1$10 = util$3;
const minN_1 = minN$1;
const $minN = (obj, expr2, options2) => {
  if (obj instanceof Array)
    return (0, minN_1.$minN)(obj, expr2, options2);
  const { input, n: n2 } = (0, core_1$11.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$10.isNil)(input))
    return null;
  (0, util_1$10.assert)((0, util_1$10.isArray)(input), "Must resolve to an array/null or missing");
  return (0, minN_1.$minN)(input, { n: n2, input: "$$this" }, options2);
};
minN.$minN = $minN;
var nin$1 = {};
var _predicates = {};
Object.defineProperty(_predicates, "__esModule", { value: true });
_predicates.$type = _predicates.$elemMatch = _predicates.$size = _predicates.$all = _predicates.$exists = _predicates.$regex = _predicates.$mod = _predicates.$gte = _predicates.$gt = _predicates.$lte = _predicates.$lt = _predicates.$nin = _predicates.$in = _predicates.$ne = _predicates.$eq = _predicates.createExpressionOperator = _predicates.createQueryOperator = void 0;
const core_1$10 = core;
const query_1$4 = query;
const util_1$$ = util$3;
function createQueryOperator(predicate) {
  const f2 = (selector, value, options2) => {
    const opts = { unwrapArray: true };
    const depth = Math.max(1, selector.split(".").length - 1);
    return (obj) => {
      const lhs = (0, util_1$$.resolve)(obj, selector, opts);
      return predicate(lhs, value, Object.assign(Object.assign({}, options2), { depth }));
    };
  };
  f2.op = "query";
  return f2;
}
_predicates.createQueryOperator = createQueryOperator;
function createExpressionOperator(predicate) {
  return (obj, expr2, options2) => {
    const args2 = (0, core_1$10.computeValue)(obj, expr2, null, options2);
    return predicate(...args2);
  };
}
_predicates.createExpressionOperator = createExpressionOperator;
function $eq(a2, b2, options2) {
  if ((0, util_1$$.isEqual)(a2, b2))
    return true;
  if ((0, util_1$$.isNil)(a2) && (0, util_1$$.isNil)(b2))
    return true;
  if (a2 instanceof Array) {
    const eq2 = util_1$$.isEqual.bind(null, b2);
    return a2.some(eq2) || (0, util_1$$.flatten)(a2, options2 === null || options2 === void 0 ? void 0 : options2.depth).some(eq2);
  }
  return false;
}
_predicates.$eq = $eq;
function $ne(a2, b2, options2) {
  return !$eq(a2, b2, options2);
}
_predicates.$ne = $ne;
function $in(a2, b2, options2) {
  if ((0, util_1$$.isNil)(a2))
    return b2.some((v2) => v2 === null);
  return (0, util_1$$.intersection)([(0, util_1$$.ensureArray)(a2), b2], options2 === null || options2 === void 0 ? void 0 : options2.hashFunction).length > 0;
}
_predicates.$in = $in;
function $nin(a2, b2, options2) {
  return !$in(a2, b2, options2);
}
_predicates.$nin = $nin;
function $lt(a2, b2, options2) {
  return compare(a2, b2, (x2, y2) => (0, util_1$$.compare)(x2, y2) < 0);
}
_predicates.$lt = $lt;
function $lte(a2, b2, options2) {
  return compare(a2, b2, (x2, y2) => (0, util_1$$.compare)(x2, y2) <= 0);
}
_predicates.$lte = $lte;
function $gt(a2, b2, options2) {
  return compare(a2, b2, (x2, y2) => (0, util_1$$.compare)(x2, y2) > 0);
}
_predicates.$gt = $gt;
function $gte(a2, b2, options2) {
  return compare(a2, b2, (x2, y2) => (0, util_1$$.compare)(x2, y2) >= 0);
}
_predicates.$gte = $gte;
function $mod(a2, b2, options2) {
  return (0, util_1$$.ensureArray)(a2).some((x2) => b2.length === 2 && x2 % b2[0] === b2[1]);
}
_predicates.$mod = $mod;
function $regex(a2, b2, options2) {
  const lhs = (0, util_1$$.ensureArray)(a2);
  const match2 = (x2) => (0, util_1$$.isString)(x2) && (0, util_1$$.truthy)(b2.exec(x2), options2 === null || options2 === void 0 ? void 0 : options2.useStrictMode);
  return lhs.some(match2) || (0, util_1$$.flatten)(lhs, 1).some(match2);
}
_predicates.$regex = $regex;
function $exists(a2, b2, options2) {
  return (b2 === false || b2 === 0) && a2 === void 0 || (b2 === true || b2 === 1) && a2 !== void 0;
}
_predicates.$exists = $exists;
function $all(values, queries, options2) {
  if (!(0, util_1$$.isArray)(values) || !(0, util_1$$.isArray)(queries) || !values.length || !queries.length) {
    return false;
  }
  let matched = true;
  for (const query2 of queries) {
    if (!matched)
      break;
    if ((0, util_1$$.isObject)(query2) && (0, util_1$$.inArray)(Object.keys(query2), "$elemMatch")) {
      matched = $elemMatch(values, query2["$elemMatch"], options2);
    } else if (query2 instanceof RegExp) {
      matched = values.some((s2) => typeof s2 === "string" && query2.test(s2));
    } else {
      matched = values.some((v2) => (0, util_1$$.isEqual)(query2, v2));
    }
  }
  return matched;
}
_predicates.$all = $all;
function $size$1(a2, b2, options2) {
  return Array.isArray(a2) && a2.length === b2;
}
_predicates.$size = $size$1;
function isNonBooleanOperator(name) {
  return (0, util_1$$.isOperator)(name) && ["$and", "$or", "$nor"].indexOf(name) === -1;
}
function $elemMatch(a2, b2, options2) {
  if ((0, util_1$$.isArray)(a2) && !(0, util_1$$.isEmpty)(a2)) {
    let format = (x2) => x2;
    let criteria = b2;
    if (Object.keys(b2).every(isNonBooleanOperator)) {
      criteria = { temp: b2 };
      format = (x2) => ({ temp: x2 });
    }
    const query2 = new query_1$4.Query(criteria, options2);
    for (let i2 = 0, len = a2.length; i2 < len; i2++) {
      if (query2.test(format(a2[i2]))) {
        return true;
      }
    }
  }
  return false;
}
_predicates.$elemMatch = $elemMatch;
const isNull = (a2) => a2 === null;
const isInt = (a2) => (0, util_1$$.isNumber)(a2) && a2 >= util_1$$.MIN_INT && a2 <= util_1$$.MAX_INT && a2.toString().indexOf(".") === -1;
const isLong = (a2) => (0, util_1$$.isNumber)(a2) && a2 >= util_1$$.MIN_LONG && a2 <= util_1$$.MAX_LONG && a2.toString().indexOf(".") === -1;
const compareFuncs = {
  array: util_1$$.isArray,
  bool: util_1$$.isBoolean,
  boolean: util_1$$.isBoolean,
  date: util_1$$.isDate,
  decimal: util_1$$.isNumber,
  double: util_1$$.isNumber,
  int: isInt,
  long: isLong,
  number: util_1$$.isNumber,
  null: isNull,
  object: util_1$$.isObject,
  regex: util_1$$.isRegExp,
  regexp: util_1$$.isRegExp,
  string: util_1$$.isString,
  // added for completeness
  undefined: util_1$$.isNil,
  function: (_2) => {
    throw new Error("unsupported type key `function`.");
  },
  // Mongo identifiers
  1: util_1$$.isNumber,
  2: util_1$$.isString,
  3: util_1$$.isObject,
  4: util_1$$.isArray,
  6: util_1$$.isNil,
  8: util_1$$.isBoolean,
  9: util_1$$.isDate,
  10: isNull,
  11: util_1$$.isRegExp,
  16: isInt,
  18: isLong,
  19: util_1$$.isNumber
  //decimal
};
function compareType(a2, b2, _2) {
  const f2 = compareFuncs[b2];
  return f2 ? f2(a2) : false;
}
function $type$1(a2, b2, options2) {
  return Array.isArray(b2) ? b2.findIndex((t2) => compareType(a2, t2)) >= 0 : compareType(a2, b2);
}
_predicates.$type = $type$1;
function compare(a2, b2, f2) {
  return (0, util_1$$.ensureArray)(a2).some((x2) => (0, util_1$$.getType)(x2) === (0, util_1$$.getType)(b2) && f2(x2, b2));
}
Object.defineProperty(nin$1, "__esModule", { value: true });
nin$1.$nin = void 0;
const _predicates_1$l = _predicates;
nin$1.$nin = (0, _predicates_1$l.createExpressionOperator)(_predicates_1$l.$nin);
var range = {};
Object.defineProperty(range, "__esModule", { value: true });
range.$range = void 0;
const core_1$$ = core;
const $range = (obj, expr2, options2) => {
  const arr = (0, core_1$$.computeValue)(obj, expr2, null, options2);
  const start = arr[0];
  const end = arr[1];
  const step = arr[2] || 1;
  const result = new Array();
  let counter = start;
  while (counter < end && step > 0 || counter > end && step < 0) {
    result.push(counter);
    counter += step;
  }
  return result;
};
range.$range = $range;
var reduce = {};
Object.defineProperty(reduce, "__esModule", { value: true });
reduce.$reduce = void 0;
const core_1$_ = core;
const util_1$_ = util$3;
const $reduce = (obj, expr2, options2) => {
  const copts = core_1$_.ComputeOptions.init(options2);
  const input = (0, core_1$_.computeValue)(obj, expr2.input, null, copts);
  const initialValue = (0, core_1$_.computeValue)(obj, expr2.initialValue, null, copts);
  const inExpr = expr2["in"];
  if ((0, util_1$_.isNil)(input))
    return null;
  (0, util_1$_.assert)((0, util_1$_.isArray)(input), "$reduce 'input' expression must resolve to an array");
  return input.reduce((acc, n2) => {
    return (0, core_1$_.computeValue)(n2, inExpr, null, copts.update(copts.root, {
      variables: { value: acc }
    }));
  }, initialValue);
};
reduce.$reduce = $reduce;
var reverseArray = {};
Object.defineProperty(reverseArray, "__esModule", { value: true });
reverseArray.$reverseArray = void 0;
const core_1$Z = core;
const util_1$Z = util$3;
const $reverseArray = (obj, expr2, options2) => {
  const arr = (0, core_1$Z.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$Z.isNil)(arr))
    return null;
  (0, util_1$Z.assert)((0, util_1$Z.isArray)(arr), "$reverseArray expression must resolve to an array");
  const result = arr.slice(0);
  result.reverse();
  return result;
};
reverseArray.$reverseArray = $reverseArray;
var size$1 = {};
Object.defineProperty(size$1, "__esModule", { value: true });
size$1.$size = void 0;
const core_1$Y = core;
const util_1$Y = util$3;
const $size = (obj, expr2, options2) => {
  const value = (0, core_1$Y.computeValue)(obj, expr2, null, options2);
  return (0, util_1$Y.isArray)(value) ? value.length : void 0;
};
size$1.$size = $size;
var slice = {};
Object.defineProperty(slice, "__esModule", { value: true });
slice.$slice = void 0;
const core_1$X = core;
const util_1$X = util$3;
const $slice = (obj, expr2, options2) => {
  const args2 = (0, core_1$X.computeValue)(obj, expr2, null, options2);
  const arr = args2[0];
  let skip2 = args2[1];
  let limit2 = args2[2];
  if ((0, util_1$X.isNil)(limit2)) {
    if (skip2 < 0) {
      skip2 = Math.max(0, arr.length + skip2);
      limit2 = arr.length - skip2 + 1;
    } else {
      limit2 = skip2;
      skip2 = 0;
    }
  } else {
    if (skip2 < 0) {
      skip2 = Math.max(0, arr.length + skip2);
    }
    (0, util_1$X.assert)(limit2 > 0, `Invalid argument for $slice operator. Limit must be a positive number`);
    limit2 += skip2;
  }
  return arr.slice(skip2, limit2);
};
slice.$slice = $slice;
var sortArray = {};
Object.defineProperty(sortArray, "__esModule", { value: true });
sortArray.$sortArray = void 0;
const aggregator_1$2 = aggregator;
const core_1$W = core;
const util_1$W = util$3;
const $sortArray = (obj, expr2, options2) => {
  const { input, sortBy } = (0, core_1$W.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$W.isNil)(input))
    return null;
  (0, util_1$W.assert)((0, util_1$W.isArray)(input), "$sortArray expression must resolve to an array");
  if ((0, util_1$W.isObject)(sortBy)) {
    return new aggregator_1$2.Aggregator([{ $sort: sortBy }]).run(input);
  }
  const result = [...input];
  result.sort(util_1$W.compare);
  if (sortBy === -1)
    result.reverse();
  return result;
};
sortArray.$sortArray = $sortArray;
var zip = {};
Object.defineProperty(zip, "__esModule", { value: true });
zip.$zip = void 0;
const core_1$V = core;
const util_1$V = util$3;
const $zip = (obj, expr2, options2) => {
  const inputs = (0, core_1$V.computeValue)(obj, expr2.inputs, null, options2);
  const useLongestLength = expr2.useLongestLength || false;
  (0, util_1$V.assert)((0, util_1$V.isArray)(inputs), "'inputs' expression must resolve to an array");
  (0, util_1$V.assert)((0, util_1$V.isBoolean)(useLongestLength), "'useLongestLength' must be a boolean");
  if ((0, util_1$V.isArray)(expr2.defaults)) {
    (0, util_1$V.assert)(useLongestLength, "'useLongestLength' must be set to true to use 'defaults'");
  }
  let zipCount = 0;
  for (let i2 = 0, len = inputs.length; i2 < len; i2++) {
    const arr = inputs[i2];
    if ((0, util_1$V.isNil)(arr))
      return null;
    (0, util_1$V.assert)((0, util_1$V.isArray)(arr), "'inputs' expression values must resolve to an array or null");
    zipCount = useLongestLength ? Math.max(zipCount, arr.length) : Math.min(zipCount || arr.length, arr.length);
  }
  const result = [];
  const defaults2 = expr2.defaults || [];
  for (let i2 = 0; i2 < zipCount; i2++) {
    const temp = inputs.map((val, index) => {
      return (0, util_1$V.isNil)(val[i2]) ? defaults2[index] || null : val[i2];
    });
    result.push(temp);
  }
  return result;
};
zip.$zip = $zip;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(arrayElemAt, exports);
  __exportStar(arrayToObject, exports);
  __exportStar(concatArrays, exports);
  __exportStar(filter, exports);
  __exportStar(first, exports);
  __exportStar(firstN, exports);
  __exportStar(_in$1, exports);
  __exportStar(indexOfArray, exports);
  __exportStar(isArray, exports);
  __exportStar(last, exports);
  __exportStar(lastN, exports);
  __exportStar(map, exports);
  __exportStar(maxN, exports);
  __exportStar(minN, exports);
  __exportStar(nin$1, exports);
  __exportStar(range, exports);
  __exportStar(reduce, exports);
  __exportStar(reverseArray, exports);
  __exportStar(size$1, exports);
  __exportStar(slice, exports);
  __exportStar(sortArray, exports);
  __exportStar(zip, exports);
})(array$1);
var boolean = {};
var and$1 = {};
Object.defineProperty(and$1, "__esModule", { value: true });
and$1.$and = void 0;
const core_1$U = core;
const util_1$U = util$3;
const $and$1 = (obj, expr2, options2) => {
  const value = (0, core_1$U.computeValue)(obj, expr2, null, options2);
  return (0, util_1$U.truthy)(value, options2.useStrictMode) && value.every((v2) => (0, util_1$U.truthy)(v2, options2.useStrictMode));
};
and$1.$and = $and$1;
var not$1 = {};
Object.defineProperty(not$1, "__esModule", { value: true });
not$1.$not = void 0;
const core_1$T = core;
const util_1$T = util$3;
const $not$1 = (obj, expr2, options2) => {
  const booleanExpr = (0, util_1$T.ensureArray)(expr2);
  if (booleanExpr.length == 0)
    return false;
  if (booleanExpr.length == 1)
    return !(0, core_1$T.computeValue)(obj, booleanExpr[0], null, options2);
  throw "Expression $not takes exactly 1 argument";
};
not$1.$not = $not$1;
var or$1 = {};
Object.defineProperty(or$1, "__esModule", { value: true });
or$1.$or = void 0;
const core_1$S = core;
const util_1$S = util$3;
const $or$1 = (obj, expr2, options2) => {
  const value = (0, core_1$S.computeValue)(obj, expr2, null, options2);
  const strict = options2.useStrictMode;
  return (0, util_1$S.truthy)(value, strict) && value.some((v2) => (0, util_1$S.truthy)(v2, strict));
};
or$1.$or = $or$1;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(and$1, exports);
  __exportStar(not$1, exports);
  __exportStar(or$1, exports);
})(boolean);
var comparison$1 = {};
var cmp$1 = {};
Object.defineProperty(cmp$1, "__esModule", { value: true });
cmp$1.$cmp = void 0;
const core_1$R = core;
const $cmp = (obj, expr2, options2) => {
  const args2 = (0, core_1$R.computeValue)(obj, expr2, null, options2);
  if (args2[0] > args2[1])
    return 1;
  if (args2[0] < args2[1])
    return -1;
  return 0;
};
cmp$1.$cmp = $cmp;
var eq$1 = {};
Object.defineProperty(eq$1, "__esModule", { value: true });
eq$1.$eq = void 0;
const _predicates_1$k = _predicates;
eq$1.$eq = (0, _predicates_1$k.createExpressionOperator)(_predicates_1$k.$eq);
var gt$1 = {};
Object.defineProperty(gt$1, "__esModule", { value: true });
gt$1.$gt = void 0;
const _predicates_1$j = _predicates;
gt$1.$gt = (0, _predicates_1$j.createExpressionOperator)(_predicates_1$j.$gt);
var gte$1 = {};
Object.defineProperty(gte$1, "__esModule", { value: true });
gte$1.$gte = void 0;
const _predicates_1$i = _predicates;
gte$1.$gte = (0, _predicates_1$i.createExpressionOperator)(_predicates_1$i.$gte);
var lt$1 = {};
Object.defineProperty(lt$1, "__esModule", { value: true });
lt$1.$lt = void 0;
const _predicates_1$h = _predicates;
lt$1.$lt = (0, _predicates_1$h.createExpressionOperator)(_predicates_1$h.$lt);
var lte$1 = {};
Object.defineProperty(lte$1, "__esModule", { value: true });
lte$1.$lte = void 0;
const _predicates_1$g = _predicates;
lte$1.$lte = (0, _predicates_1$g.createExpressionOperator)(_predicates_1$g.$lte);
var ne$1 = {};
Object.defineProperty(ne$1, "__esModule", { value: true });
ne$1.$ne = void 0;
const _predicates_1$f = _predicates;
ne$1.$ne = (0, _predicates_1$f.createExpressionOperator)(_predicates_1$f.$ne);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(cmp$1, exports);
  __exportStar(eq$1, exports);
  __exportStar(gt$1, exports);
  __exportStar(gte$1, exports);
  __exportStar(lt$1, exports);
  __exportStar(lte$1, exports);
  __exportStar(ne$1, exports);
})(comparison$1);
var conditional = {};
var cond = {};
Object.defineProperty(cond, "__esModule", { value: true });
cond.$cond = void 0;
const core_1$Q = core;
const util_1$R = util$3;
const $cond = (obj, expr2, options2) => {
  let ifExpr;
  let thenExpr;
  let elseExpr;
  const errorMsg = "$cond: invalid arguments";
  if (expr2 instanceof Array) {
    (0, util_1$R.assert)(expr2.length === 3, errorMsg);
    ifExpr = expr2[0];
    thenExpr = expr2[1];
    elseExpr = expr2[2];
  } else {
    (0, util_1$R.assert)((0, util_1$R.isObject)(expr2), errorMsg);
    ifExpr = expr2.if;
    thenExpr = expr2.then;
    elseExpr = expr2.else;
  }
  const condition = (0, util_1$R.truthy)((0, core_1$Q.computeValue)(obj, ifExpr, null, options2), options2.useStrictMode);
  return (0, core_1$Q.computeValue)(obj, condition ? thenExpr : elseExpr, null, options2);
};
cond.$cond = $cond;
var _switch = {};
Object.defineProperty(_switch, "__esModule", { value: true });
_switch.$switch = void 0;
const core_1$P = core;
const util_1$Q = util$3;
const $switch = (obj, expr2, options2) => {
  let thenExpr = null;
  expr2.branches.some((b2) => {
    const condition = (0, util_1$Q.truthy)((0, core_1$P.computeValue)(obj, b2.case, null, options2), options2.useStrictMode);
    if (condition)
      thenExpr = b2.then;
    return condition;
  });
  return (0, core_1$P.computeValue)(obj, thenExpr !== null ? thenExpr : expr2.default, null, options2);
};
_switch.$switch = $switch;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(cond, exports);
  __exportStar(ifNull, exports);
  __exportStar(_switch, exports);
})(conditional);
var custom = {};
var _function = {};
Object.defineProperty(_function, "__esModule", { value: true });
_function.$function = void 0;
const core_1$O = core;
const util_1$P = util$3;
const $function = (obj, expr2, options2) => {
  (0, util_1$P.assert)(options2.scriptEnabled, "$function operator requires 'scriptEnabled' option to be true");
  const fn2 = (0, core_1$O.computeValue)(obj, expr2, null, options2);
  return fn2.body.apply(null, fn2.args);
};
_function.$function = $function;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(_function, exports);
})(custom);
var date = {};
var dateAdd = {};
Object.defineProperty(dateAdd, "__esModule", { value: true });
dateAdd.$dateAdd = void 0;
const core_1$N = core;
const _internal_1$H = _internal$5;
const $dateAdd = (obj, expr2, options2) => {
  const args2 = (0, core_1$N.computeValue)(obj, expr2, null, options2);
  const d2 = (0, _internal_1$H.computeDate)(obj, expr2.startDate, options2);
  switch (args2.unit) {
    case "year":
      d2.setUTCFullYear(d2.getUTCFullYear() + args2.amount);
      break;
    case "quarter":
      addMonth(d2, 3 * args2.amount);
      break;
    case "month":
      addMonth(d2, args2.amount);
      break;
    default:
      d2.setTime(d2.getTime() + _internal_1$H.DURATION_IN_MILLIS[args2.unit] * args2.amount);
  }
  if (args2.timezone) {
    const tz = (0, _internal_1$H.parseTimezone)(args2.timezone);
    (0, _internal_1$H.adjustDate)(d2, tz);
  }
  return d2;
};
dateAdd.$dateAdd = $dateAdd;
function addMonth(d2, amount) {
  const m2 = d2.getUTCMonth() + amount;
  const yearOffset = Math.floor(m2 / 12);
  if (m2 < 0) {
    const month2 = m2 % 12 + 12;
    d2.setUTCFullYear(d2.getUTCFullYear() + yearOffset, month2, d2.getUTCDate());
  } else {
    d2.setUTCFullYear(d2.getUTCFullYear() + yearOffset, m2 % 12, d2.getUTCDate());
  }
}
var dateDiff = {};
Object.defineProperty(dateDiff, "__esModule", { value: true });
dateDiff.$dateDiff = void 0;
const core_1$M = core;
const _internal_1$G = _internal$5;
const $dateDiff = (obj, expr2, options2) => {
  const args2 = (0, core_1$M.computeValue)(obj, expr2, null, options2);
  const d1 = (0, _internal_1$G.computeDate)(obj, expr2.startDate, options2);
  const d2 = (0, _internal_1$G.computeDate)(obj, expr2.endDate, options2);
  let diff2;
  switch (args2.unit) {
    case "year":
    case "quarter":
    case "month":
      diff2 = diffYQM(d1, d2, args2.unit);
      break;
    default:
      diff2 = (d2.getTime() - d1.getTime()) / _internal_1$G.DURATION_IN_MILLIS[args2.unit];
  }
  return diff2;
};
dateDiff.$dateDiff = $dateDiff;
const unitMonths = {
  year: 12,
  quarter: 3,
  month: 1
};
function diffYQM(d1, d2, unit) {
  let months = (d2.getUTCFullYear() - d1.getUTCFullYear()) * 12;
  months -= d1.getUTCMonth();
  months += d2.getUTCMonth();
  return Math.trunc(months / unitMonths[unit]);
}
var dateFromParts = {};
Object.defineProperty(dateFromParts, "__esModule", { value: true });
dateFromParts.$dateFromParts = void 0;
const core_1$L = core;
const _internal_1$F = _internal$5;
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const getDaysInMonth = (date2) => {
  return date2.month == 2 && (0, _internal_1$F.isLeapYear)(date2.year) ? 29 : DAYS_IN_MONTH[date2.month - 1];
};
const $dateFromParts = (obj, expr2, options2) => {
  const args2 = (0, core_1$L.computeValue)(obj, expr2, null, options2);
  const minuteOffset = (0, _internal_1$F.parseTimezone)(args2.timezone);
  for (let i2 = _internal_1$F.DATE_PART_INTERVAL.length - 1, remainder = 0; i2 >= 0; i2--) {
    const datePartInterval = _internal_1$F.DATE_PART_INTERVAL[i2];
    const k2 = datePartInterval[0];
    const min2 = datePartInterval[1];
    const max2 = datePartInterval[2];
    let part = (args2[k2] || 0) + remainder;
    remainder = 0;
    const limit2 = max2 + 1;
    if (k2 == "hour")
      part += Math.floor(minuteOffset / _internal_1$F.MINUTES_PER_HOUR) * -1;
    if (k2 == "minute")
      part += minuteOffset % _internal_1$F.MINUTES_PER_HOUR * -1;
    if (part < min2) {
      const delta = min2 - part;
      remainder = -1 * Math.ceil(delta / limit2);
      part = limit2 - delta % limit2;
    } else if (part > max2) {
      part += min2;
      remainder = Math.trunc(part / limit2);
      part %= limit2;
    }
    args2[k2] = part;
  }
  args2.day = Math.min(args2.day, getDaysInMonth(args2));
  return new Date(Date.UTC(args2.year, args2.month - 1, args2.day, args2.hour, args2.minute, args2.second, args2.millisecond));
};
dateFromParts.$dateFromParts = $dateFromParts;
var dateFromString = {};
Object.defineProperty(dateFromString, "__esModule", { value: true });
dateFromString.$dateFromString = void 0;
const core_1$K = core;
const util_1$O = util$3;
const _internal_1$E = _internal$5;
const buildMap = (letters, sign) => {
  const h2 = {};
  letters.split("").forEach((v2, i2) => h2[v2] = sign * (i2 + 1));
  return h2;
};
const TZ_LETTER_OFFSETS = Object.assign(Object.assign(Object.assign({}, buildMap("ABCDEFGHIKLM", 1)), buildMap("NOPQRSTUVWXY", -1)), { Z: 0 });
const $dateFromString = (obj, expr2, options2) => {
  const args2 = (0, core_1$K.computeValue)(obj, expr2, null, options2);
  args2.format = args2.format || _internal_1$E.DATE_FORMAT;
  args2.onNull = args2.onNull || null;
  let dateString = args2.dateString;
  if ((0, util_1$O.isNil)(dateString))
    return args2.onNull;
  const separators = args2.format.split(/%[YGmdHMSLuVzZ]/);
  separators.reverse();
  const matches = args2.format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%V|%z|%Z)/g);
  const dateParts = {};
  let expectedPattern = "";
  for (let i2 = 0, len = matches.length; i2 < len; i2++) {
    const formatSpecifier = matches[i2];
    const props = _internal_1$E.DATE_SYM_TABLE[formatSpecifier];
    if ((0, util_1$O.isObject)(props)) {
      const m3 = props.re.exec(dateString);
      const delimiter = separators.pop() || "";
      if (m3 !== null) {
        dateParts[props.name] = /^\d+$/.exec(m3[0]) ? parseInt(m3[0]) : m3[0];
        dateString = dateString.substr(0, m3.index) + dateString.substr(m3.index + m3[0].length);
        expectedPattern += (0, _internal_1$E.regexQuote)(delimiter) + (0, _internal_1$E.regexStrip)(props.re.toString());
      } else {
        dateParts[props.name] = null;
      }
    }
  }
  if ((0, util_1$O.isNil)(dateParts.year) || (0, util_1$O.isNil)(dateParts.month) || (0, util_1$O.isNil)(dateParts.day) || !new RegExp("^" + expectedPattern + "[A-Z]?$").exec(args2.dateString)) {
    return args2.onError;
  }
  const m2 = args2.dateString.match(/([A-Z])$/);
  (0, util_1$O.assert)(
    // only one of in-date timeone or timezone argument but not both.
    !(m2 && args2.timezone),
    `$dateFromString: you cannot pass in a date/time string with time zone information ('${m2 && m2[0]}') together with a timezone argument`
  );
  const minuteOffset = m2 ? TZ_LETTER_OFFSETS[m2[0]] * _internal_1$E.MINUTES_PER_HOUR : (0, _internal_1$E.parseTimezone)(args2.timezone);
  const d2 = new Date(Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day, 0, 0, 0));
  if (!(0, util_1$O.isNil)(dateParts.hour))
    d2.setUTCHours(dateParts.hour);
  if (!(0, util_1$O.isNil)(dateParts.minute))
    d2.setUTCMinutes(dateParts.minute);
  if (!(0, util_1$O.isNil)(dateParts.second))
    d2.setUTCSeconds(dateParts.second);
  if (!(0, util_1$O.isNil)(dateParts.millisecond))
    d2.setUTCMilliseconds(dateParts.millisecond);
  (0, _internal_1$E.adjustDate)(d2, -minuteOffset);
  return d2;
};
dateFromString.$dateFromString = $dateFromString;
var dateSubtract = {};
Object.defineProperty(dateSubtract, "__esModule", { value: true });
dateSubtract.$dateSubtract = void 0;
const core_1$J = core;
const dateAdd_1$1 = dateAdd;
const $dateSubtract = (obj, expr2, options2) => {
  const amount = (0, core_1$J.computeValue)(obj, expr2 === null || expr2 === void 0 ? void 0 : expr2.amount, null, options2);
  return (0, dateAdd_1$1.$dateAdd)(obj, Object.assign(Object.assign({}, expr2), { amount: -1 * amount }), options2);
};
dateSubtract.$dateSubtract = $dateSubtract;
var dateToParts = {};
Object.defineProperty(dateToParts, "__esModule", { value: true });
dateToParts.$dateToParts = void 0;
const core_1$I = core;
const _internal_1$D = _internal$5;
const $dateToParts = (obj, expr2, options2) => {
  const args2 = (0, core_1$I.computeValue)(obj, expr2, null, options2);
  const d2 = new Date(args2.date);
  const tz = (0, _internal_1$D.parseTimezone)(args2.timezone);
  (0, _internal_1$D.adjustDate)(d2, tz);
  const timePart = {
    hour: d2.getUTCHours(),
    minute: d2.getUTCMinutes(),
    second: d2.getUTCSeconds(),
    millisecond: d2.getUTCMilliseconds()
  };
  if (args2.iso8601 == true) {
    return Object.assign(timePart, {
      isoWeekYear: (0, _internal_1$D.isoWeekYear)(d2),
      isoWeek: (0, _internal_1$D.isoWeek)(d2),
      isoDayOfWeek: d2.getUTCDay() || 7
    });
  }
  return Object.assign(timePart, {
    year: d2.getUTCFullYear(),
    month: d2.getUTCMonth() + 1,
    day: d2.getUTCDate()
  });
};
dateToParts.$dateToParts = $dateToParts;
var dateToString = {};
var dayOfMonth = {};
Object.defineProperty(dayOfMonth, "__esModule", { value: true });
dayOfMonth.$dayOfMonth = void 0;
const _internal_1$C = _internal$5;
const $dayOfMonth = (obj, expr2, options2) => {
  return (0, _internal_1$C.computeDate)(obj, expr2, options2).getUTCDate();
};
dayOfMonth.$dayOfMonth = $dayOfMonth;
var hour = {};
Object.defineProperty(hour, "__esModule", { value: true });
hour.$hour = void 0;
const _internal_1$B = _internal$5;
const $hour = (obj, expr2, options2) => {
  return (0, _internal_1$B.computeDate)(obj, expr2, options2).getUTCHours();
};
hour.$hour = $hour;
var isoDayOfWeek = {};
Object.defineProperty(isoDayOfWeek, "__esModule", { value: true });
isoDayOfWeek.$isoDayOfWeek = void 0;
const _internal_1$A = _internal$5;
const $isoDayOfWeek = (obj, expr2, options2) => {
  return (0, _internal_1$A.computeDate)(obj, expr2, options2).getUTCDay() || 7;
};
isoDayOfWeek.$isoDayOfWeek = $isoDayOfWeek;
var isoWeek = {};
Object.defineProperty(isoWeek, "__esModule", { value: true });
isoWeek.$isoWeek = void 0;
const _internal_1$z = _internal$5;
const $isoWeek = (obj, expr2, options2) => {
  return (0, _internal_1$z.isoWeek)((0, _internal_1$z.computeDate)(obj, expr2, options2));
};
isoWeek.$isoWeek = $isoWeek;
var millisecond = {};
Object.defineProperty(millisecond, "__esModule", { value: true });
millisecond.$millisecond = void 0;
const _internal_1$y = _internal$5;
const $millisecond = (obj, expr2, options2) => {
  return (0, _internal_1$y.computeDate)(obj, expr2, options2).getUTCMilliseconds();
};
millisecond.$millisecond = $millisecond;
var minute = {};
Object.defineProperty(minute, "__esModule", { value: true });
minute.$minute = void 0;
const _internal_1$x = _internal$5;
const $minute = (obj, expr2, options2) => {
  return (0, _internal_1$x.computeDate)(obj, expr2, options2).getUTCMinutes();
};
minute.$minute = $minute;
var month = {};
Object.defineProperty(month, "__esModule", { value: true });
month.$month = void 0;
const _internal_1$w = _internal$5;
const $month = (obj, expr2, options2) => {
  return (0, _internal_1$w.computeDate)(obj, expr2, options2).getUTCMonth() + 1;
};
month.$month = $month;
var second = {};
Object.defineProperty(second, "__esModule", { value: true });
second.$second = void 0;
const _internal_1$v = _internal$5;
const $second = (obj, expr2, options2) => {
  return (0, _internal_1$v.computeDate)(obj, expr2, options2).getUTCSeconds();
};
second.$second = $second;
var week = {};
Object.defineProperty(week, "__esModule", { value: true });
week.$week = void 0;
const _internal_1$u = _internal$5;
const $week = (obj, expr2, options2) => {
  const d2 = (0, _internal_1$u.computeDate)(obj, expr2, options2);
  const result = (0, _internal_1$u.isoWeek)(d2);
  if (d2.getUTCDay() > 0 && d2.getUTCDate() == 1 && d2.getUTCMonth() == 0)
    return 0;
  if (d2.getUTCDay() == 0)
    return result + 1;
  return result;
};
week.$week = $week;
var year = {};
Object.defineProperty(year, "__esModule", { value: true });
year.$year = void 0;
const _internal_1$t = _internal$5;
const $year = (obj, expr2, options2) => {
  return (0, _internal_1$t.computeDate)(obj, expr2, options2).getUTCFullYear();
};
year.$year = $year;
Object.defineProperty(dateToString, "__esModule", { value: true });
dateToString.$dateToString = void 0;
const core_1$H = core;
const util_1$N = util$3;
const _internal_1$s = _internal$5;
const dayOfMonth_1 = dayOfMonth;
const hour_1 = hour;
const isoDayOfWeek_1 = isoDayOfWeek;
const isoWeek_1 = isoWeek;
const millisecond_1 = millisecond;
const minute_1 = minute;
const month_1 = month;
const second_1 = second;
const week_1 = week;
const year_1 = year;
const DATE_FUNCTIONS = {
  "%Y": year_1.$year,
  "%G": year_1.$year,
  "%m": month_1.$month,
  "%d": dayOfMonth_1.$dayOfMonth,
  "%H": hour_1.$hour,
  "%M": minute_1.$minute,
  "%S": second_1.$second,
  "%L": millisecond_1.$millisecond,
  "%u": isoDayOfWeek_1.$isoDayOfWeek,
  "%U": week_1.$week,
  "%V": isoWeek_1.$isoWeek
};
const $dateToString = (obj, expr2, options2) => {
  const args2 = (0, core_1$H.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$N.isNil)(args2.onNull))
    args2.onNull = null;
  if ((0, util_1$N.isNil)(args2.date))
    return args2.onNull;
  const date2 = (0, _internal_1$s.computeDate)(obj, args2.date, options2);
  let format = args2.format || _internal_1$s.DATE_FORMAT;
  const minuteOffset = (0, _internal_1$s.parseTimezone)(args2.timezone);
  const matches = format.match(/(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%U|%V|%z|%Z)/g);
  (0, _internal_1$s.adjustDate)(date2, minuteOffset);
  for (let i2 = 0, len = matches.length; i2 < len; i2++) {
    const formatSpecifier = matches[i2];
    const props = _internal_1$s.DATE_SYM_TABLE[formatSpecifier];
    const operatorFn = DATE_FUNCTIONS[formatSpecifier];
    let value;
    if ((0, util_1$N.isObject)(props)) {
      if (props.name === "timezone") {
        value = (0, _internal_1$s.formatTimezone)(minuteOffset);
      } else if (props.name === "minuteOffset") {
        value = minuteOffset.toString();
      } else {
        (0, util_1$N.assert)(!!operatorFn, `unsupported date format specifier '${formatSpecifier}'`);
        value = (0, _internal_1$s.padDigits)(operatorFn(obj, date2, options2), props.padding);
      }
    }
    format = format.replace(formatSpecifier, value);
  }
  return format;
};
dateToString.$dateToString = $dateToString;
var dayOfWeek = {};
Object.defineProperty(dayOfWeek, "__esModule", { value: true });
dayOfWeek.$dayOfWeek = void 0;
const _internal_1$r = _internal$5;
const $dayOfWeek = (obj, expr2, options2) => {
  return (0, _internal_1$r.computeDate)(obj, expr2, options2).getUTCDay() + 1;
};
dayOfWeek.$dayOfWeek = $dayOfWeek;
var dayOfYear = {};
Object.defineProperty(dayOfYear, "__esModule", { value: true });
dayOfYear.$dayOfYear = void 0;
const _internal_1$q = _internal$5;
const $dayOfYear = (obj, expr2, options2) => {
  return (0, _internal_1$q.getDayOfYear)((0, _internal_1$q.computeDate)(obj, expr2, options2));
};
dayOfYear.$dayOfYear = $dayOfYear;
var isoWeekYear = {};
Object.defineProperty(isoWeekYear, "__esModule", { value: true });
isoWeekYear.$isoWeekYear = void 0;
const _internal_1$p = _internal$5;
const $isoWeekYear = (obj, expr2, options2) => {
  const d2 = (0, _internal_1$p.computeDate)(obj, expr2, options2);
  return d2.getUTCFullYear() - Number(d2.getUTCMonth() == 0 && d2.getUTCDate() == 1 && d2.getUTCDay() < 1);
};
isoWeekYear.$isoWeekYear = $isoWeekYear;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(dateAdd, exports);
  __exportStar(dateDiff, exports);
  __exportStar(dateFromParts, exports);
  __exportStar(dateFromString, exports);
  __exportStar(dateSubtract, exports);
  __exportStar(dateToParts, exports);
  __exportStar(dateToString, exports);
  __exportStar(dayOfMonth, exports);
  __exportStar(dayOfWeek, exports);
  __exportStar(dayOfYear, exports);
  __exportStar(hour, exports);
  __exportStar(isoDayOfWeek, exports);
  __exportStar(isoWeek, exports);
  __exportStar(isoWeekYear, exports);
  __exportStar(millisecond, exports);
  __exportStar(minute, exports);
  __exportStar(month, exports);
  __exportStar(second, exports);
  __exportStar(week, exports);
  __exportStar(year, exports);
})(date);
var literal = {};
Object.defineProperty(literal, "__esModule", { value: true });
literal.$literal = void 0;
const $literal = (_obj, expr2, _options2) => expr2;
literal.$literal = $literal;
var misc = {};
var getField = {};
Object.defineProperty(getField, "__esModule", { value: true });
getField.$getField = void 0;
const core_1$G = core;
const util_1$M = util$3;
const $getField = (obj, expr2, options2) => {
  const args2 = (0, core_1$G.computeValue)(obj, expr2, null, options2);
  let input = obj;
  let field = args2;
  if ((0, util_1$M.isObject)(args2) && args2.input && args2.field) {
    input = args2.input;
    field = args2.field;
  }
  if ((0, util_1$M.isNil)(input))
    return null;
  (0, util_1$M.assert)((0, util_1$M.isObject)(input), "$getField expression 'input' must evaluate to an object");
  (0, util_1$M.assert)((0, util_1$M.isString)(field), "$getField expression 'field' must evaluate to a string");
  return input[field];
};
getField.$getField = $getField;
var rand = {};
Object.defineProperty(rand, "__esModule", { value: true });
rand.$rand = void 0;
const $rand = (_obj, _expr, _options2) => Math.random();
rand.$rand = $rand;
var sampleRate = {};
Object.defineProperty(sampleRate, "__esModule", { value: true });
sampleRate.$sampleRate = void 0;
const core_1$F = core;
const $sampleRate = (obj, expr2, options2) => Math.random() <= (0, core_1$F.computeValue)(obj, expr2, null, options2);
sampleRate.$sampleRate = $sampleRate;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(getField, exports);
  __exportStar(rand, exports);
  __exportStar(sampleRate, exports);
})(misc);
var object = {};
var objectToArray = {};
Object.defineProperty(objectToArray, "__esModule", { value: true });
objectToArray.$objectToArray = void 0;
const core_1$E = core;
const util_1$L = util$3;
const $objectToArray = (obj, expr2, options2) => {
  const val = (0, core_1$E.computeValue)(obj, expr2, null, options2);
  (0, util_1$L.assert)((0, util_1$L.isObject)(val), "$objectToArray expression must resolve to an object");
  const entries2 = Object.entries(val);
  const result = new Array(entries2.length);
  let i2 = 0;
  for (const [k2, v2] of entries2) {
    result[i2++] = { k: k2, v: v2 };
  }
  return result;
};
objectToArray.$objectToArray = $objectToArray;
var setField = {};
Object.defineProperty(setField, "__esModule", { value: true });
setField.$setField = void 0;
const core_1$D = core;
const util_1$K = util$3;
const $setField = (obj, expr2, options2) => {
  const args2 = (0, core_1$D.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$K.isNil)(args2.input))
    return null;
  (0, util_1$K.assert)((0, util_1$K.isObject)(args2.input), "$setField expression 'input' must evaluate to an object");
  (0, util_1$K.assert)((0, util_1$K.isString)(args2.field), "$setField expression 'field' must evaluate to a string");
  if (expr2.value == "$$REMOVE") {
    delete obj[args2.field];
  } else {
    obj[args2.field] = args2.value;
  }
  return obj;
};
setField.$setField = $setField;
var unsetField = {};
Object.defineProperty(unsetField, "__esModule", { value: true });
unsetField.$unsetField = void 0;
const setField_1 = setField;
const $unsetField = (obj, expr2, options2) => {
  return (0, setField_1.$setField)(obj, Object.assign(Object.assign({}, expr2), { value: "$$REMOVE" }), options2);
};
unsetField.$unsetField = $unsetField;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(mergeObjects, exports);
  __exportStar(objectToArray, exports);
  __exportStar(setField, exports);
  __exportStar(unsetField, exports);
})(object);
var set$1 = {};
var allElementsTrue = {};
Object.defineProperty(allElementsTrue, "__esModule", { value: true });
allElementsTrue.$allElementsTrue = void 0;
const core_1$C = core;
const util_1$J = util$3;
const $allElementsTrue = (obj, expr2, options2) => {
  const args2 = (0, core_1$C.computeValue)(obj, expr2, null, options2)[0];
  return args2.every((v2) => (0, util_1$J.truthy)(v2, options2.useStrictMode));
};
allElementsTrue.$allElementsTrue = $allElementsTrue;
var anyElementTrue = {};
Object.defineProperty(anyElementTrue, "__esModule", { value: true });
anyElementTrue.$anyElementTrue = void 0;
const core_1$B = core;
const util_1$I = util$3;
const $anyElementTrue = (obj, expr2, options2) => {
  const args2 = (0, core_1$B.computeValue)(obj, expr2, null, options2)[0];
  return args2.some((v2) => (0, util_1$I.truthy)(v2, options2.useStrictMode));
};
anyElementTrue.$anyElementTrue = $anyElementTrue;
var setDifference = {};
Object.defineProperty(setDifference, "__esModule", { value: true });
setDifference.$setDifference = void 0;
const core_1$A = core;
const util_1$H = util$3;
const $setDifference = (obj, expr2, options2) => {
  const args2 = (0, core_1$A.computeValue)(obj, expr2, null, options2);
  return args2[0].filter(util_1$H.notInArray.bind(null, args2[1]));
};
setDifference.$setDifference = $setDifference;
var setEquals = {};
Object.defineProperty(setEquals, "__esModule", { value: true });
setEquals.$setEquals = void 0;
const core_1$z = core;
const util_1$G = util$3;
const $setEquals = (obj, expr2, options2) => {
  const args2 = (0, core_1$z.computeValue)(obj, expr2, null, options2);
  const xs = (0, util_1$G.unique)(args2[0], options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
  const ys = (0, util_1$G.unique)(args2[1], options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
  return xs.length === ys.length && xs.length === (0, util_1$G.intersection)([xs, ys], options2 === null || options2 === void 0 ? void 0 : options2.hashFunction).length;
};
setEquals.$setEquals = $setEquals;
var setIntersection = {};
Object.defineProperty(setIntersection, "__esModule", { value: true });
setIntersection.$setIntersection = void 0;
const core_1$y = core;
const util_1$F = util$3;
const $setIntersection = (obj, expr2, options2) => {
  const args2 = (0, core_1$y.computeValue)(obj, expr2, null, options2);
  (0, util_1$F.assert)((0, util_1$F.isArray)(args2) && args2.every(util_1$F.isArray), "$setIntersection: expresssion must resolve to array of arrays");
  return (0, util_1$F.intersection)(args2, options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
};
setIntersection.$setIntersection = $setIntersection;
var setIsSubset = {};
Object.defineProperty(setIsSubset, "__esModule", { value: true });
setIsSubset.$setIsSubset = void 0;
const core_1$x = core;
const util_1$E = util$3;
const $setIsSubset = (obj, expr2, options2) => {
  const args2 = (0, core_1$x.computeValue)(obj, expr2, null, options2);
  return (0, util_1$E.intersection)(args2, options2 === null || options2 === void 0 ? void 0 : options2.hashFunction).length === args2[0].length;
};
setIsSubset.$setIsSubset = $setIsSubset;
var setUnion = {};
Object.defineProperty(setUnion, "__esModule", { value: true });
setUnion.$setUnion = void 0;
const core_1$w = core;
const util_1$D = util$3;
const $setUnion = (obj, expr2, options2) => {
  const args2 = (0, core_1$w.computeValue)(obj, expr2, null, options2);
  (0, util_1$D.assert)((0, util_1$D.isArray)(args2) && args2.length == 2 && args2.every(util_1$D.isArray), "$setUnion: arguments must be arrays");
  return (0, util_1$D.unique)(args2[0].concat(args2[1]), options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
};
setUnion.$setUnion = $setUnion;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(allElementsTrue, exports);
  __exportStar(anyElementTrue, exports);
  __exportStar(setDifference, exports);
  __exportStar(setEquals, exports);
  __exportStar(setIntersection, exports);
  __exportStar(setIsSubset, exports);
  __exportStar(setUnion, exports);
})(set$1);
var string = {};
var concat = {};
Object.defineProperty(concat, "__esModule", { value: true });
concat.$concat = void 0;
const core_1$v = core;
const util_1$C = util$3;
const $concat = (obj, expr2, options2) => {
  const args2 = (0, core_1$v.computeValue)(obj, expr2, null, options2);
  if ([null, void 0].some(util_1$C.inArray.bind(null, args2)))
    return null;
  return args2.join("");
};
concat.$concat = $concat;
var indexOfBytes = {};
Object.defineProperty(indexOfBytes, "__esModule", { value: true });
indexOfBytes.$indexOfBytes = void 0;
const core_1$u = core;
const util_1$B = util$3;
const $indexOfBytes = (obj, expr2, options2) => {
  const arr = (0, core_1$u.computeValue)(obj, expr2, null, options2);
  const errorMsg = "$indexOfBytes expression resolves to invalid an argument";
  if ((0, util_1$B.isNil)(arr[0]))
    return null;
  (0, util_1$B.assert)((0, util_1$B.isString)(arr[0]) && (0, util_1$B.isString)(arr[1]), errorMsg);
  const str = arr[0];
  const searchStr = arr[1];
  let start = arr[2];
  let end = arr[3];
  let valid = (0, util_1$B.isNil)(start) || (0, util_1$B.isNumber)(start) && start >= 0 && Math.round(start) === start;
  valid = valid && ((0, util_1$B.isNil)(end) || (0, util_1$B.isNumber)(end) && end >= 0 && Math.round(end) === end);
  (0, util_1$B.assert)(valid, errorMsg);
  start = start || 0;
  end = end || str.length;
  if (start > end)
    return -1;
  const index = str.substring(start, end).indexOf(searchStr);
  return index > -1 ? index + start : index;
};
indexOfBytes.$indexOfBytes = $indexOfBytes;
var ltrim = {};
var _internal$2 = {};
Object.defineProperty(_internal$2, "__esModule", { value: true });
_internal$2.regexSearch = _internal$2.trimString = void 0;
const core_1$t = core;
const util_1$A = util$3;
const WHITESPACE_CHARS = [
  0,
  32,
  9,
  10,
  11,
  12,
  13,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202
  // Hair space
];
function trimString(obj, expr2, options2, trimOpts) {
  const val = (0, core_1$t.computeValue)(obj, expr2, null, options2);
  const s2 = val.input;
  if ((0, util_1$A.isNil)(s2))
    return null;
  const codepoints = (0, util_1$A.isNil)(val.chars) ? WHITESPACE_CHARS : val.chars.split("").map((c2) => c2.codePointAt(0));
  let i2 = 0;
  let j2 = s2.length - 1;
  while (trimOpts.left && i2 <= j2 && codepoints.indexOf(s2[i2].codePointAt(0)) !== -1)
    i2++;
  while (trimOpts.right && i2 <= j2 && codepoints.indexOf(s2[j2].codePointAt(0)) !== -1)
    j2--;
  return s2.substring(i2, j2 + 1);
}
_internal$2.trimString = trimString;
function regexSearch(obj, expr2, options2, reOpts) {
  const val = (0, core_1$t.computeValue)(obj, expr2, null, options2);
  if (!(0, util_1$A.isString)(val.input))
    return [];
  const regexOptions = val.options;
  if (regexOptions) {
    (0, util_1$A.assert)(regexOptions.indexOf("x") === -1, "extended capability option 'x' not supported");
    (0, util_1$A.assert)(regexOptions.indexOf("g") === -1, "global option 'g' not supported");
  }
  let input = val.input;
  const re2 = new RegExp(val.regex, regexOptions);
  let m2;
  const matches = new Array();
  let offset = 0;
  while (m2 = re2.exec(input)) {
    const result = {
      match: m2[0],
      idx: m2.index + offset,
      captures: []
    };
    for (let i2 = 1; i2 < m2.length; i2++)
      result.captures.push(m2[i2] || null);
    matches.push(result);
    if (!reOpts.global)
      break;
    offset = m2.index + m2[0].length;
    input = input.substring(offset);
  }
  return matches;
}
_internal$2.regexSearch = regexSearch;
Object.defineProperty(ltrim, "__esModule", { value: true });
ltrim.$ltrim = void 0;
const _internal_1$o = _internal$2;
const $ltrim = (obj, expr2, options2) => {
  return (0, _internal_1$o.trimString)(obj, expr2, options2, { left: true, right: false });
};
ltrim.$ltrim = $ltrim;
var regexFind = {};
Object.defineProperty(regexFind, "__esModule", { value: true });
regexFind.$regexFind = void 0;
const _internal_1$n = _internal$2;
const $regexFind = (obj, expr2, options2) => {
  const result = (0, _internal_1$n.regexSearch)(obj, expr2, options2, { global: false });
  return result && result.length > 0 ? result[0] : null;
};
regexFind.$regexFind = $regexFind;
var regexFindAll = {};
Object.defineProperty(regexFindAll, "__esModule", { value: true });
regexFindAll.$regexFindAll = void 0;
const _internal_1$m = _internal$2;
const $regexFindAll = (obj, expr2, options2) => {
  return (0, _internal_1$m.regexSearch)(obj, expr2, options2, { global: true });
};
regexFindAll.$regexFindAll = $regexFindAll;
var regexMatch = {};
Object.defineProperty(regexMatch, "__esModule", { value: true });
regexMatch.$regexMatch = void 0;
const _internal_1$l = _internal$2;
const $regexMatch = (obj, expr2, options2) => {
  return (0, _internal_1$l.regexSearch)(obj, expr2, options2, { global: false }).length != 0;
};
regexMatch.$regexMatch = $regexMatch;
var replaceAll = {};
Object.defineProperty(replaceAll, "__esModule", { value: true });
replaceAll.$replaceAll = void 0;
const core_1$s = core;
const util_1$z = util$3;
const $replaceAll = (obj, expr2, options2) => {
  const args2 = (0, core_1$s.computeValue)(obj, expr2, null, options2);
  const arr = [args2.input, args2.find, args2.replacement];
  if (arr.some(util_1$z.isNil))
    return null;
  (0, util_1$z.assert)(arr.every(util_1$z.isString), "$replaceAll expression fields must evaluate to string");
  return args2.input.replace(new RegExp(args2.find, "g"), args2.replacement);
};
replaceAll.$replaceAll = $replaceAll;
var replaceOne = {};
Object.defineProperty(replaceOne, "__esModule", { value: true });
replaceOne.$replaceOne = void 0;
const core_1$r = core;
const util_1$y = util$3;
const $replaceOne = (obj, expr2, options2) => {
  const args2 = (0, core_1$r.computeValue)(obj, expr2, null, options2);
  const arr = [args2.input, args2.find, args2.replacement];
  if (arr.some(util_1$y.isNil))
    return null;
  (0, util_1$y.assert)(arr.every(util_1$y.isString), "$replaceOne expression fields must evaluate to string");
  return args2.input.replace(args2.find, args2.replacement);
};
replaceOne.$replaceOne = $replaceOne;
var rtrim = {};
Object.defineProperty(rtrim, "__esModule", { value: true });
rtrim.$rtrim = void 0;
const _internal_1$k = _internal$2;
const $rtrim = (obj, expr2, options2) => {
  return (0, _internal_1$k.trimString)(obj, expr2, options2, { left: false, right: true });
};
rtrim.$rtrim = $rtrim;
var split = {};
Object.defineProperty(split, "__esModule", { value: true });
split.$split = void 0;
const core_1$q = core;
const util_1$x = util$3;
const $split = (obj, expr2, options2) => {
  const args2 = (0, core_1$q.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$x.isNil)(args2[0]))
    return null;
  (0, util_1$x.assert)(args2.every(util_1$x.isString), "$split expression must result to array(2) of strings");
  return args2[0].split(args2[1]);
};
split.$split = $split;
var strcasecmp = {};
Object.defineProperty(strcasecmp, "__esModule", { value: true });
strcasecmp.$strcasecmp = void 0;
const core_1$p = core;
const util_1$w = util$3;
const $strcasecmp = (obj, expr2, options2) => {
  const args2 = (0, core_1$p.computeValue)(obj, expr2, null, options2);
  let a2 = args2[0];
  let b2 = args2[1];
  if ((0, util_1$w.isEqual)(a2, b2) || args2.every(util_1$w.isNil))
    return 0;
  (0, util_1$w.assert)(args2.every(util_1$w.isString), "$strcasecmp must resolve to array(2) of strings");
  a2 = a2.toUpperCase();
  b2 = b2.toUpperCase();
  return a2 > b2 && 1 || a2 < b2 && -1 || 0;
};
strcasecmp.$strcasecmp = $strcasecmp;
var strLenBytes = {};
Object.defineProperty(strLenBytes, "__esModule", { value: true });
strLenBytes.$strLenBytes = void 0;
const core_1$o = core;
const $strLenBytes = (obj, expr2, options2) => {
  return ~-encodeURI((0, core_1$o.computeValue)(obj, expr2, null, options2)).split(/%..|./).length;
};
strLenBytes.$strLenBytes = $strLenBytes;
var strLenCP = {};
Object.defineProperty(strLenCP, "__esModule", { value: true });
strLenCP.$strLenCP = void 0;
const core_1$n = core;
const $strLenCP = (obj, expr2, options2) => {
  return (0, core_1$n.computeValue)(obj, expr2, null, options2).length;
};
strLenCP.$strLenCP = $strLenCP;
var substr = {};
Object.defineProperty(substr, "__esModule", { value: true });
substr.$substr = void 0;
const core_1$m = core;
const util_1$v = util$3;
const $substr = (obj, expr2, options2) => {
  const args2 = (0, core_1$m.computeValue)(obj, expr2, null, options2);
  const s2 = args2[0];
  const index = args2[1];
  const count2 = args2[2];
  if ((0, util_1$v.isString)(s2)) {
    if (index < 0) {
      return "";
    } else if (count2 < 0) {
      return s2.substr(index);
    } else {
      return s2.substr(index, count2);
    }
  }
  return "";
};
substr.$substr = $substr;
var substrBytes = {};
Object.defineProperty(substrBytes, "__esModule", { value: true });
substrBytes.$substrBytes = void 0;
const core_1$l = core;
const util_1$u = util$3;
const UTF8_MASK = [192, 224, 240];
function toUtf8(n2) {
  if (n2 < 128)
    return [n2];
  let count2 = n2 < 2048 && 1 || n2 < 65536 && 2 || 3;
  const offset = UTF8_MASK[count2 - 1];
  const utf8 = [(n2 >> 6 * count2) + offset];
  while (count2 > 0)
    utf8.push(128 | n2 >> 6 * --count2 & 63);
  return utf8;
}
function utf8Encode(s2) {
  const buf = [];
  for (let i2 = 0, len = s2.length; i2 < len; i2++) {
    buf.push(toUtf8(s2.codePointAt(i2)));
  }
  return buf;
}
const $substrBytes = (obj, expr2, options2) => {
  const args2 = (0, core_1$l.computeValue)(obj, expr2, null, options2);
  const s2 = args2[0];
  const index = args2[1];
  const count2 = args2[2];
  (0, util_1$u.assert)((0, util_1$u.isString)(s2) && (0, util_1$u.isNumber)(index) && index >= 0 && (0, util_1$u.isNumber)(count2) && count2 >= 0, "$substrBytes: invalid arguments");
  const buf = utf8Encode(s2);
  const validIndex = [];
  let acc = 0;
  for (let i2 = 0; i2 < buf.length; i2++) {
    validIndex.push(acc);
    acc += buf[i2].length;
  }
  const begin = validIndex.indexOf(index);
  const end = validIndex.indexOf(index + count2);
  (0, util_1$u.assert)(begin > -1 && end > -1, "$substrBytes: invalid range, start or end index is a UTF-8 continuation byte.");
  return s2.substring(begin, end);
};
substrBytes.$substrBytes = $substrBytes;
var substrCP = {};
Object.defineProperty(substrCP, "__esModule", { value: true });
substrCP.$substrCP = void 0;
const substr_1 = substr;
const $substrCP = (obj, expr2, options2) => {
  return (0, substr_1.$substr)(obj, expr2, options2);
};
substrCP.$substrCP = $substrCP;
var toLower = {};
Object.defineProperty(toLower, "__esModule", { value: true });
toLower.$toLower = void 0;
const core_1$k = core;
const util_1$t = util$3;
const $toLower = (obj, expr2, options2) => {
  const value = (0, core_1$k.computeValue)(obj, expr2, null, options2);
  return (0, util_1$t.isEmpty)(value) ? "" : value.toLowerCase();
};
toLower.$toLower = $toLower;
var toUpper = {};
Object.defineProperty(toUpper, "__esModule", { value: true });
toUpper.$toUpper = void 0;
const core_1$j = core;
const util_1$s = util$3;
const $toUpper = (obj, expr2, options2) => {
  const value = (0, core_1$j.computeValue)(obj, expr2, null, options2);
  return (0, util_1$s.isEmpty)(value) ? "" : value.toUpperCase();
};
toUpper.$toUpper = $toUpper;
var trim = {};
Object.defineProperty(trim, "__esModule", { value: true });
trim.$trim = void 0;
const _internal_1$j = _internal$2;
const $trim = (obj, expr2, options2) => {
  return (0, _internal_1$j.trimString)(obj, expr2, options2, { left: true, right: true });
};
trim.$trim = $trim;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(concat, exports);
  __exportStar(indexOfBytes, exports);
  __exportStar(ltrim, exports);
  __exportStar(regexFind, exports);
  __exportStar(regexFindAll, exports);
  __exportStar(regexMatch, exports);
  __exportStar(replaceAll, exports);
  __exportStar(replaceOne, exports);
  __exportStar(rtrim, exports);
  __exportStar(split, exports);
  __exportStar(strcasecmp, exports);
  __exportStar(strLenBytes, exports);
  __exportStar(strLenCP, exports);
  __exportStar(substr, exports);
  __exportStar(substrBytes, exports);
  __exportStar(substrCP, exports);
  __exportStar(toLower, exports);
  __exportStar(toUpper, exports);
  __exportStar(trim, exports);
})(string);
var trignometry = {};
var acos = {};
var _internal$1 = {};
Object.defineProperty(_internal$1, "__esModule", { value: true });
_internal$1.createTrignometryOperator = void 0;
const core_1$i = core;
const FIXED_POINTS = {
  undefined: null,
  null: null,
  NaN: NaN,
  Infinity: new Error(),
  "-Infinity": new Error()
};
function createTrignometryOperator(f2, fixedPoints = FIXED_POINTS) {
  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);
  const keySet = new Set(Object.keys(fp));
  return (obj, expr2, options2) => {
    const n2 = (0, core_1$i.computeValue)(obj, expr2, null, options2);
    if (keySet.has(`${n2}`)) {
      const res = fp[`${n2}`];
      if (res instanceof Error) {
        throw new Error(`cannot apply $${f2.name} to -inf, value must in (-inf,inf)`);
      }
      return res;
    }
    return f2(n2);
  };
}
_internal$1.createTrignometryOperator = createTrignometryOperator;
Object.defineProperty(acos, "__esModule", { value: true });
acos.$acos = void 0;
const _internal_1$i = _internal$1;
acos.$acos = (0, _internal_1$i.createTrignometryOperator)(Math.acos, {
  Infinity: Infinity,
  0: new Error()
});
var acosh = {};
Object.defineProperty(acosh, "__esModule", { value: true });
acosh.$acosh = void 0;
const _internal_1$h = _internal$1;
acosh.$acosh = (0, _internal_1$h.createTrignometryOperator)(Math.acosh, {
  Infinity: Infinity,
  0: new Error()
});
var asin = {};
Object.defineProperty(asin, "__esModule", { value: true });
asin.$asin = void 0;
const _internal_1$g = _internal$1;
asin.$asin = (0, _internal_1$g.createTrignometryOperator)(Math.asin);
var asinh = {};
Object.defineProperty(asinh, "__esModule", { value: true });
asinh.$asinh = void 0;
const _internal_1$f = _internal$1;
asinh.$asinh = (0, _internal_1$f.createTrignometryOperator)(Math.asinh, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});
var atan = {};
Object.defineProperty(atan, "__esModule", { value: true });
atan.$atan = void 0;
const _internal_1$e = _internal$1;
atan.$atan = (0, _internal_1$e.createTrignometryOperator)(Math.atan);
var atan2 = {};
Object.defineProperty(atan2, "__esModule", { value: true });
atan2.$atan2 = void 0;
const core_1$h = core;
const util_1$r = util$3;
const $atan2 = (obj, expr2, options2) => {
  const [y2, x2] = (0, core_1$h.computeValue)(obj, expr2, null, options2);
  if (isNaN(y2) || (0, util_1$r.isNil)(y2))
    return y2;
  if (isNaN(x2) || (0, util_1$r.isNil)(x2))
    return x2;
  return Math.atan2(y2, x2);
};
atan2.$atan2 = $atan2;
var atanh = {};
Object.defineProperty(atanh, "__esModule", { value: true });
atanh.$atanh = void 0;
const _internal_1$d = _internal$1;
atanh.$atanh = (0, _internal_1$d.createTrignometryOperator)(Math.atanh, {
  1: Infinity,
  "-1": -Infinity
});
var cos = {};
Object.defineProperty(cos, "__esModule", { value: true });
cos.$cos = void 0;
const _internal_1$c = _internal$1;
cos.$cos = (0, _internal_1$c.createTrignometryOperator)(Math.cos);
var cosh = {};
Object.defineProperty(cosh, "__esModule", { value: true });
cosh.$cosh = void 0;
const _internal_1$b = _internal$1;
cosh.$cosh = (0, _internal_1$b.createTrignometryOperator)(Math.cosh, {
  "-Infinity": Infinity,
  Infinity: Infinity
  // [Math.PI]: -1,
});
var degreesToRadians = {};
Object.defineProperty(degreesToRadians, "__esModule", { value: true });
degreesToRadians.$degreesToRadians = void 0;
const _internal_1$a = _internal$1;
const RADIANS_FACTOR = Math.PI / 180;
degreesToRadians.$degreesToRadians = (0, _internal_1$a.createTrignometryOperator)((n2) => n2 * RADIANS_FACTOR, {
  Infinity: Infinity,
  "-Infinity": Infinity
});
var radiansToDegrees = {};
Object.defineProperty(radiansToDegrees, "__esModule", { value: true });
radiansToDegrees.$radiansToDegrees = void 0;
const _internal_1$9 = _internal$1;
const DEGREES_FACTOR = 180 / Math.PI;
radiansToDegrees.$radiansToDegrees = (0, _internal_1$9.createTrignometryOperator)((n2) => n2 * DEGREES_FACTOR, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});
var sin = {};
Object.defineProperty(sin, "__esModule", { value: true });
sin.$sin = void 0;
const _internal_1$8 = _internal$1;
sin.$sin = (0, _internal_1$8.createTrignometryOperator)(Math.sin);
var sinh = {};
Object.defineProperty(sinh, "__esModule", { value: true });
sinh.$sinh = void 0;
const _internal_1$7 = _internal$1;
sinh.$sinh = (0, _internal_1$7.createTrignometryOperator)(Math.sinh, {
  "-Infinity": -Infinity,
  Infinity: Infinity
});
var tan = {};
Object.defineProperty(tan, "__esModule", { value: true });
tan.$tan = void 0;
const _internal_1$6 = _internal$1;
tan.$tan = (0, _internal_1$6.createTrignometryOperator)(Math.tan);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(acos, exports);
  __exportStar(acosh, exports);
  __exportStar(asin, exports);
  __exportStar(asinh, exports);
  __exportStar(atan, exports);
  __exportStar(atan2, exports);
  __exportStar(atanh, exports);
  __exportStar(cos, exports);
  __exportStar(cosh, exports);
  __exportStar(degreesToRadians, exports);
  __exportStar(radiansToDegrees, exports);
  __exportStar(sin, exports);
  __exportStar(sinh, exports);
  __exportStar(tan, exports);
})(trignometry);
var type$7 = {};
var convert = {};
var _internal = {};
Object.defineProperty(_internal, "__esModule", { value: true });
_internal.toInteger = _internal.TypeConvertError = void 0;
const core_1$g = core;
const util_1$q = util$3;
class TypeConvertError extends Error {
  constructor(message) {
    super(message);
  }
}
_internal.TypeConvertError = TypeConvertError;
function toInteger(obj, expr2, options2, max2, min2, typename) {
  const val = (0, core_1$g.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$q.isNil)(val))
    return null;
  if (val instanceof Date)
    return val.getTime();
  if (val === true)
    return 1;
  if (val === false)
    return 0;
  const n2 = Number(val);
  if ((0, util_1$q.isNumber)(n2) && n2 >= min2 && n2 <= max2) {
    if (!(0, util_1$q.isString)(val) || n2.toString().indexOf(".") === -1) {
      return Math.trunc(n2);
    }
  }
  throw new TypeConvertError(`cannot convert '${val}' to ${typename}`);
}
_internal.toInteger = toInteger;
var toBool = {};
Object.defineProperty(toBool, "__esModule", { value: true });
toBool.$toBool = void 0;
const core_1$f = core;
const util_1$p = util$3;
const $toBool = (obj, expr2, options2) => {
  const val = (0, core_1$f.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$p.isNil)(val))
    return null;
  if ((0, util_1$p.isString)(val))
    return true;
  return Boolean(val);
};
toBool.$toBool = $toBool;
var toDate = {};
Object.defineProperty(toDate, "__esModule", { value: true });
toDate.$toDate = void 0;
const core_1$e = core;
const util_1$o = util$3;
const _internal_1$5 = _internal;
const $toDate = (obj, expr2, options2) => {
  const val = (0, core_1$e.computeValue)(obj, expr2, null, options2);
  if (val instanceof Date)
    return val;
  if ((0, util_1$o.isNil)(val))
    return null;
  const d2 = new Date(val);
  const n2 = d2.getTime();
  if (!isNaN(n2))
    return d2;
  throw new _internal_1$5.TypeConvertError(`cannot convert '${val}' to date`);
};
toDate.$toDate = $toDate;
var toDouble = {};
Object.defineProperty(toDouble, "__esModule", { value: true });
toDouble.$toDouble = void 0;
const core_1$d = core;
const util_1$n = util$3;
const _internal_1$4 = _internal;
const $toDouble = (obj, expr2, options2) => {
  const val = (0, core_1$d.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$n.isNil)(val))
    return null;
  if (val instanceof Date)
    return val.getTime();
  if (val === true)
    return 1;
  if (val === false)
    return 0;
  const n2 = Number(val);
  if ((0, util_1$n.isNumber)(n2))
    return n2;
  throw new _internal_1$4.TypeConvertError(`cannot convert '${val}' to double/decimal`);
};
toDouble.$toDouble = $toDouble;
var toInt = {};
Object.defineProperty(toInt, "__esModule", { value: true });
toInt.$toInt = void 0;
const util_1$m = util$3;
const _internal_1$3 = _internal;
const $toInt = (obj, expr2, options2) => {
  return (0, _internal_1$3.toInteger)(obj, expr2, options2, util_1$m.MAX_INT, util_1$m.MIN_INT, "int");
};
toInt.$toInt = $toInt;
var toLong = {};
Object.defineProperty(toLong, "__esModule", { value: true });
toLong.$toLong = void 0;
const util_1$l = util$3;
const _internal_1$2 = _internal;
const $toLong = (obj, expr2, options2) => {
  return (0, _internal_1$2.toInteger)(obj, expr2, options2, util_1$l.MAX_LONG, util_1$l.MIN_LONG, "long");
};
toLong.$toLong = $toLong;
var toString = {};
Object.defineProperty(toString, "__esModule", { value: true });
toString.$toString = void 0;
const core_1$c = core;
const util_1$k = util$3;
const dateToString_1 = dateToString;
const $toString = (obj, expr2, options2) => {
  const val = (0, core_1$c.computeValue)(obj, expr2, null, options2);
  if ((0, util_1$k.isNil)(val))
    return null;
  if (val instanceof Date) {
    const dateExpr = {
      date: expr2,
      format: "%Y-%m-%dT%H:%M:%S.%LZ"
    };
    return (0, dateToString_1.$dateToString)(obj, dateExpr, options2);
  } else {
    return val.toString();
  }
};
toString.$toString = $toString;
Object.defineProperty(convert, "__esModule", { value: true });
convert.$convert = void 0;
const core_1$b = core;
const util_1$j = util$3;
const _internal_1$1 = _internal;
const toBool_1 = toBool;
const toDate_1 = toDate;
const toDouble_1$1 = toDouble;
const toInt_1 = toInt;
const toLong_1 = toLong;
const toString_1 = toString;
const $convert = (obj, expr2, options2) => {
  const args2 = (0, core_1$b.computeValue)(obj, expr2, null, options2);
  args2.onNull = args2.onNull === void 0 ? null : args2.onNull;
  if ((0, util_1$j.isNil)(args2.input))
    return args2.onNull;
  try {
    switch (args2.to) {
      case 2:
      case "string":
        return (0, toString_1.$toString)(obj, args2.input, options2);
      case 8:
      case "boolean":
      case "bool":
        return (0, toBool_1.$toBool)(obj, args2.input, options2);
      case 9:
      case "date":
        return (0, toDate_1.$toDate)(obj, args2.input, options2);
      case 1:
      case 19:
      case "double":
      case "decimal":
      case "number":
        return (0, toDouble_1$1.$toDouble)(obj, args2.input, options2);
      case 16:
      case "int":
        return (0, toInt_1.$toInt)(obj, args2.input, options2);
      case 18:
      case "long":
        return (0, toLong_1.$toLong)(obj, args2.input, options2);
    }
  } catch (e2) {
  }
  if (args2.onError !== void 0)
    return args2.onError;
  throw new _internal_1$1.TypeConvertError(`could not convert to type ${args2.to}.`);
};
convert.$convert = $convert;
var isNumber = {};
Object.defineProperty(isNumber, "__esModule", { value: true });
isNumber.$isNumber = void 0;
const core_1$a = core;
const util_1$i = util$3;
const $isNumber = (obj, expr2, options2) => {
  const n2 = (0, core_1$a.computeValue)(obj, expr2, null, options2);
  return (0, util_1$i.isNumber)(n2);
};
isNumber.$isNumber = $isNumber;
var toDecimal = {};
Object.defineProperty(toDecimal, "__esModule", { value: true });
toDecimal.$toDecimal = void 0;
const toDouble_1 = toDouble;
toDecimal.$toDecimal = toDouble_1.$toDouble;
var type$6 = {};
Object.defineProperty(type$6, "__esModule", { value: true });
type$6.$type = void 0;
const core_1$9 = core;
const util_1$h = util$3;
const $type = (obj, expr2, options2) => {
  const val = (0, core_1$9.computeValue)(obj, expr2, null, options2);
  const typename = (0, util_1$h.getType)(val);
  const nativeType = typename.toLowerCase();
  switch (nativeType) {
    case "boolean":
      return "bool";
    case "number":
      if (val.toString().indexOf(".") >= 0)
        return "double";
      return val >= util_1$h.MIN_INT && val <= util_1$h.MAX_INT ? "int" : "long";
    case "regexp":
      return "regex";
    default:
      return nativeType;
  }
};
type$6.$type = $type;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(convert, exports);
  __exportStar(isNumber, exports);
  __exportStar(toBool, exports);
  __exportStar(toDate, exports);
  __exportStar(toDecimal, exports);
  __exportStar(toDouble, exports);
  __exportStar(toInt, exports);
  __exportStar(toLong, exports);
  __exportStar(toString, exports);
  __exportStar(type$6, exports);
})(type$7);
var variable = {};
var _let = {};
Object.defineProperty(_let, "__esModule", { value: true });
_let.$let = void 0;
const core_1$8 = core;
const $let = (obj, expr2, options2) => {
  const variables = {};
  for (const [key, val] of Object.entries(expr2.vars)) {
    variables[key] = (0, core_1$8.computeValue)(obj, val, null, options2);
  }
  return (0, core_1$8.computeValue)(obj, expr2.in, null, core_1$8.ComputeOptions.init(options2, obj, { variables }));
};
_let.$let = $let;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(_let, exports);
})(variable);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(arithmetic, exports);
  __exportStar(array$1, exports);
  __exportStar(boolean, exports);
  __exportStar(comparison$1, exports);
  __exportStar(conditional, exports);
  __exportStar(custom, exports);
  __exportStar(date, exports);
  __exportStar(literal, exports);
  __exportStar(misc, exports);
  __exportStar(object, exports);
  __exportStar(set$1, exports);
  __exportStar(string, exports);
  __exportStar(trignometry, exports);
  __exportStar(type$7, exports);
  __exportStar(variable, exports);
})(expression);
var group = {};
Object.defineProperty(group, "__esModule", { value: true });
group.$group = void 0;
const core_1$7 = core;
const util_1$g = util$3;
const ID_KEY = "_id";
const $group = (collection, expr2, options2) => {
  (0, util_1$g.assert)((0, util_1$g.has)(expr2, ID_KEY), "a group specification must include an _id");
  const idExpr = expr2[ID_KEY];
  const copts = core_1$7.ComputeOptions.init(options2);
  return collection.transform((coll) => {
    const partitions = (0, util_1$g.groupBy)(coll, (obj) => (0, core_1$7.computeValue)(obj, idExpr, null, options2), options2.hashFunction);
    expr2 = Object.assign({}, expr2);
    delete expr2[ID_KEY];
    let i2 = -1;
    const partitionKeys = Array.from(partitions.keys());
    const size2 = partitions.size;
    return () => {
      if (++i2 === size2)
        return { done: true };
      const groupId = partitionKeys[i2];
      const obj = {};
      if (groupId !== void 0) {
        obj[ID_KEY] = groupId;
      }
      for (const [key, val] of Object.entries(expr2)) {
        obj[key] = (0, core_1$7.computeValue)(partitions.get(groupId), val, key, copts.update(null, { groupId }));
      }
      return { value: obj, done: false };
    };
  });
};
group.$group = $group;
var sort = {};
Object.defineProperty(sort, "__esModule", { value: true });
sort.$sort = void 0;
const util_1$f = util$3;
const $sort = (collection, sortKeys, options2) => {
  if ((0, util_1$f.isEmpty)(sortKeys) || !(0, util_1$f.isObject)(sortKeys))
    return collection;
  let cmp2 = util_1$f.compare;
  const collationSpec = options2.collation;
  if ((0, util_1$f.isObject)(collationSpec) && (0, util_1$f.isString)(collationSpec.locale)) {
    cmp2 = collationComparator(collationSpec);
  }
  return collection.transform((coll) => {
    const modifiers = Object.keys(sortKeys);
    for (const key of modifiers.reverse()) {
      const groups = (0, util_1$f.groupBy)(coll, (obj) => (0, util_1$f.resolve)(obj, key), options2.hashFunction);
      const sortedKeys = Array.from(groups.keys()).sort(cmp2);
      if (sortKeys[key] === -1)
        sortedKeys.reverse();
      coll = [];
      sortedKeys.reduce((acc, key2) => (0, util_1$f.into)(acc, groups.get(key2)), coll);
    }
    return coll;
  });
};
sort.$sort = $sort;
const COLLATION_STRENGTH = {
  // Only strings that differ in base letters compare as unequal. Examples: a  b, a = , a = A.
  1: "base",
  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.
  // Examples: a  b, a  , a = A.
  2: "accent",
  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.
  // Other differences may also be taken into consideration. Examples: a  b, a  , a  A
  3: "variant"
  // case - Only strings that differ in base letters or case compare as unequal. Examples: a  b, a = , a  A.
};
function collationComparator(spec) {
  const localeOpt = {
    sensitivity: COLLATION_STRENGTH[spec.strength || 3],
    caseFirst: spec.caseFirst === "off" ? "false" : spec.caseFirst || "false",
    numeric: spec.numericOrdering || false,
    ignorePunctuation: spec.alternate === "shifted"
  };
  if ((spec.caseLevel || false) === true) {
    if (localeOpt.sensitivity === "base")
      localeOpt.sensitivity = "case";
    if (localeOpt.sensitivity === "accent")
      localeOpt.sensitivity = "variant";
  }
  const collator = new Intl.Collator(spec.locale, localeOpt);
  return (a2, b2) => {
    if (!(0, util_1$f.isString)(a2) || !(0, util_1$f.isString)(b2))
      return (0, util_1$f.compare)(a2, b2);
    const i2 = collator.compare(a2, b2);
    if (i2 < 0)
      return -1;
    if (i2 > 0)
      return 1;
    return 0;
  };
}
Object.defineProperty(setWindowFields, "__esModule", { value: true });
setWindowFields.$setWindowFields = void 0;
const core_1$6 = core;
const lazy_1$2 = lazy;
const util_1$e = util$3;
const expression_1$1 = expression;
const dateAdd_1 = dateAdd;
const _internal_1 = _internal$4;
const addFields_1$2 = addFields;
const group_1$1 = group;
const sort_1$1 = sort;
const SORT_REQUIRED_OPS = /* @__PURE__ */ new Set([
  "$denseRank",
  "$documentNumber",
  "$first",
  "$last",
  "$linearFill",
  "$rank",
  "$shift"
]);
const WINDOW_UNBOUNDED_OPS = /* @__PURE__ */ new Set([
  "$denseRank",
  "$expMovingAvg",
  "$linearFill",
  "$locf",
  "$rank",
  "$shift"
]);
const $setWindowFields = (collection, expr2, options2) => {
  options2 = (0, core_1$6.initOptions)(options2);
  options2.context.addExpressionOps({ $function: expression_1$1.$function });
  for (const outputExpr of Object.values(expr2.output)) {
    const keys = Object.keys(outputExpr);
    const op = keys.find(util_1$e.isOperator);
    (0, util_1$e.assert)(!!(0, core_1$6.getOperator)(core_1$6.OperatorType.WINDOW, op, options2) || !!(0, core_1$6.getOperator)(core_1$6.OperatorType.ACCUMULATOR, op, options2), `'${op}' is not a valid window operator`);
    (0, util_1$e.assert)(keys.length > 0 && keys.length <= 2 && (keys.length == 1 || keys.includes("window")), "'output' option should have a single window operator.");
    if (outputExpr === null || outputExpr === void 0 ? void 0 : outputExpr.window) {
      const { documents, range: range2 } = outputExpr.window;
      (0, util_1$e.assert)(!!documents && !range2 || !documents && !!range2 || !documents && !range2, "'window' option supports only one of 'documents' or 'range'.");
    }
  }
  if (expr2.sortBy) {
    collection = (0, sort_1$1.$sort)(collection, expr2.sortBy, options2);
  }
  collection = (0, group_1$1.$group)(collection, {
    _id: expr2.partitionBy,
    items: { $push: "$$CURRENT" }
  }, options2);
  return collection.transform((partitions) => {
    const iterators = [];
    const outputConfig = [];
    for (const [field, outputExpr] of Object.entries(expr2.output)) {
      const op = Object.keys(outputExpr).find(util_1$e.isOperator);
      const config2 = {
        operatorName: op,
        func: {
          left: (0, core_1$6.getOperator)(core_1$6.OperatorType.ACCUMULATOR, op, options2),
          right: (0, core_1$6.getOperator)(core_1$6.OperatorType.WINDOW, op, options2)
        },
        args: outputExpr[op],
        field,
        window: outputExpr.window
      };
      (0, util_1$e.assert)(!!expr2.sortBy || !(SORT_REQUIRED_OPS.has(op) || !config2.window), `${SORT_REQUIRED_OPS.has(op) ? `'${op}'` : "bounded window operation"} requires a sortBy.`);
      (0, util_1$e.assert)(!config2.window || !WINDOW_UNBOUNDED_OPS.has(op), `${op} does not accept a 'window' field.`);
      outputConfig.push(config2);
    }
    partitions.forEach((group2) => {
      const items = group2.items;
      let iterator2 = (0, lazy_1$2.Lazy)(items);
      const windowResultMap = {};
      for (const config2 of outputConfig) {
        const { func, args: args2, field, window: window2 } = config2;
        const makeResultFunc = (getItemsFn) => {
          let index = -1;
          return (obj) => {
            ++index;
            if (func.left) {
              return func.left(getItemsFn(obj, index), args2, options2);
            } else if (func.right) {
              return func.right(
                obj,
                getItemsFn(obj, index),
                {
                  parentExpr: expr2,
                  inputExpr: args2,
                  documentNumber: index + 1,
                  field
                },
                // must use raw options only since it operates over a collection.
                options2
              );
            }
          };
        };
        if (window2) {
          const { documents, range: range2, unit } = window2;
          const boundary = documents || range2;
          if (!(0, _internal_1.isUnbounded)(window2)) {
            const [begin, end] = boundary;
            const toBeginIndex = (currentIndex) => {
              if (begin == "current")
                return currentIndex;
              if (begin == "unbounded")
                return 0;
              return Math.max(begin + currentIndex, 0);
            };
            const toEndIndex = (currentIndex) => {
              if (end == "current")
                return currentIndex + 1;
              if (end == "unbounded")
                return items.length;
              return end + currentIndex + 1;
            };
            const getItems = (current, index) => {
              if (!!documents || boundary.every(util_1$e.isString)) {
                return items.slice(toBeginIndex(index), toEndIndex(index));
              }
              const sortKey = Object.keys(expr2.sortBy)[0];
              let lower;
              let upper;
              if (unit) {
                const getTime = (amount) => {
                  return (0, dateAdd_1.$dateAdd)(current, {
                    startDate: new Date(current[sortKey]),
                    unit,
                    amount
                  }, options2).getTime();
                };
                lower = (0, util_1$e.isNumber)(begin) ? getTime(begin) : -Infinity;
                upper = (0, util_1$e.isNumber)(end) ? getTime(end) : Infinity;
              } else {
                const currentValue = current[sortKey];
                lower = (0, util_1$e.isNumber)(begin) ? currentValue + begin : -Infinity;
                upper = (0, util_1$e.isNumber)(end) ? currentValue + end : Infinity;
              }
              let array2 = items;
              if (begin == "current")
                array2 = items.slice(index);
              if (end == "current")
                array2 = items.slice(0, index + 1);
              return array2.filter((o2) => {
                const value = o2[sortKey];
                const n2 = +value;
                return n2 >= lower && n2 <= upper;
              });
            };
            windowResultMap[field] = makeResultFunc(getItems);
          }
        }
        if (!windowResultMap[field]) {
          windowResultMap[field] = makeResultFunc((_2) => items);
        }
        iterator2 = (0, addFields_1$2.$addFields)(iterator2, {
          [field]: {
            $function: {
              body: (obj) => windowResultMap[field](obj),
              args: ["$$CURRENT"]
            }
          }
        }, options2);
      }
      iterators.push(iterator2);
    });
    return (0, lazy_1$2.compose)(...iterators);
  });
};
setWindowFields.$setWindowFields = $setWindowFields;
Object.defineProperty(fill, "__esModule", { value: true });
fill.$fill = void 0;
const core_1$5 = core;
const util_1$d = util$3;
const ifNull_1 = ifNull;
const linearFill_1 = linearFill;
const locf_1 = locf;
const addFields_1$1 = addFields;
const setWindowFields_1 = setWindowFields;
const FILL_METHODS = {
  locf: "$locf",
  linear: "$linearFill"
};
const $fill = (collection, expr2, options2) => {
  var _a, _b;
  (0, util_1$d.assert)(!expr2.sortBy || (0, util_1$d.isObject)(expr2.sortBy), "sortBy must be an object.");
  (0, util_1$d.assert)(!!expr2.sortBy || Object.values(expr2.output).every((m2) => (0, util_1$d.has)(m2, "value")), "sortBy required if any output field specifies a 'method'.");
  (0, util_1$d.assert)(!(expr2.partitionBy && expr2.partitionByFields), "specify either partitionBy or partitionByFields.");
  (0, util_1$d.assert)(!expr2.partitionByFields || ((_a = expr2 === null || expr2 === void 0 ? void 0 : expr2.partitionByFields) === null || _a === void 0 ? void 0 : _a.every((s2) => s2[0] !== "$")), "fields in partitionByFields cannot begin with '$'.");
  options2 = (0, core_1$5.initOptions)(options2);
  options2.context.addExpressionOps({ $ifNull: ifNull_1.$ifNull });
  options2.context.addWindowOps({ $locf: locf_1.$locf, $linearFill: linearFill_1.$linearFill });
  const partitionExpr = expr2.partitionBy || ((_b = expr2 === null || expr2 === void 0 ? void 0 : expr2.partitionByFields) === null || _b === void 0 ? void 0 : _b.map((s2) => `$${s2}`));
  const valueExpr = {};
  const methodExpr = {};
  for (const [k2, m2] of Object.entries(expr2.output)) {
    if ((0, util_1$d.has)(m2, "value")) {
      valueExpr[k2] = { $ifNull: [`$$CURRENT.${k2}`, m2["value"]] };
    } else {
      const fillOp = FILL_METHODS[m2["method"]];
      (0, util_1$d.assert)(!!fillOp, `invalid fill method '${m2["method"]}'.`);
      methodExpr[k2] = { [fillOp]: "$" + k2 };
    }
  }
  if (Object.keys(methodExpr).length > 0) {
    collection = (0, setWindowFields_1.$setWindowFields)(collection, {
      sortBy: expr2.sortBy || {},
      partitionBy: partitionExpr,
      output: methodExpr
    }, options2);
  }
  if (Object.keys(valueExpr).length > 0) {
    collection = (0, addFields_1$1.$addFields)(collection, valueExpr, options2);
  }
  return collection;
};
fill.$fill = $fill;
var limit = {};
Object.defineProperty(limit, "__esModule", { value: true });
limit.$limit = void 0;
const $limit = (collection, expr2, options2) => {
  return collection.take(expr2);
};
limit.$limit = $limit;
var lookup = {};
Object.defineProperty(lookup, "__esModule", { value: true });
lookup.$lookup = void 0;
const util_1$c = util$3;
const $lookup = (collection, expr2, options2) => {
  const joinColl = (0, util_1$c.isString)(expr2.from) ? options2 === null || options2 === void 0 ? void 0 : options2.collectionResolver(expr2.from) : expr2.from;
  (0, util_1$c.assert)(joinColl instanceof Array, `'from' field must resolve to an array`);
  const hash2 = {};
  for (const obj of joinColl) {
    const k2 = (0, util_1$c.hashCode)((0, util_1$c.resolve)(obj, expr2.foreignField), options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
    hash2[k2] = hash2[k2] || [];
    hash2[k2].push(obj);
  }
  return collection.map((obj) => {
    const k2 = (0, util_1$c.hashCode)((0, util_1$c.resolve)(obj, expr2.localField), options2 === null || options2 === void 0 ? void 0 : options2.hashFunction);
    const newObj = (0, util_1$c.into)({}, obj);
    newObj[expr2.as] = hash2[k2] || [];
    return newObj;
  });
};
lookup.$lookup = $lookup;
var match = {};
Object.defineProperty(match, "__esModule", { value: true });
match.$match = void 0;
const query_1$3 = query;
const $match = (collection, expr2, options2) => {
  const q2 = new query_1$3.Query(expr2, options2);
  return collection.filter((o2) => q2.test(o2));
};
match.$match = $match;
var merge$1 = {};
Object.defineProperty(merge$1, "__esModule", { value: true });
merge$1.$merge = void 0;
const aggregator_1$1 = aggregator;
const core_1$4 = core;
const util_1$b = util$3;
const expression_1 = expression;
const $merge = (collection, expr2, options2) => {
  const output = (0, util_1$b.isString)(expr2.into) ? options2 === null || options2 === void 0 ? void 0 : options2.collectionResolver(expr2.into) : expr2.into;
  (0, util_1$b.assert)(output instanceof Array, `$merge: option 'into' must resolve to an array`);
  const onField = expr2.on || options2.idKey;
  const getHash = (o2) => {
    const val = (0, util_1$b.isString)(onField) ? (0, util_1$b.resolve)(o2, onField) : onField.map((s2) => (0, util_1$b.resolve)(o2, s2));
    return (0, util_1$b.hashCode)(val, options2.hashFunction);
  };
  const hash2 = {};
  for (let i2 = 0; i2 < output.length; i2++) {
    const obj = output[i2];
    const k2 = getHash(obj);
    (0, util_1$b.assert)(!hash2[k2], "$merge: 'into' collection must have unique entries for the 'on' field.");
    hash2[k2] = [obj, i2];
  }
  const copts = core_1$4.ComputeOptions.init(options2);
  return collection.map((o2) => {
    const k2 = getHash(o2);
    if (hash2[k2]) {
      const [target, i2] = hash2[k2];
      const variables = (0, core_1$4.computeValue)(
        target,
        expr2.let || { new: "$$ROOT" },
        null,
        // 'root' is the item from the iteration.
        copts.update(o2)
      );
      if ((0, util_1$b.isArray)(expr2.whenMatched)) {
        const aggregator2 = new aggregator_1$1.Aggregator(expr2.whenMatched, Object.assign(Object.assign({}, options2), { variables }));
        output[i2] = aggregator2.run([target])[0];
      } else {
        switch (expr2.whenMatched) {
          case "replace":
            output[i2] = o2;
            break;
          case "fail":
            throw new Error("$merge: failed due to matching as specified by 'whenMatched' option.");
          case "keepExisting":
            break;
          case "merge":
          default:
            output[i2] = (0, expression_1.$mergeObjects)(
              target,
              [target, o2],
              // 'root' is the item from the iteration.
              copts.update(o2, { variables })
            );
            break;
        }
      }
    } else {
      switch (expr2.whenNotMatched) {
        case "discard":
          break;
        case "fail":
          throw new Error("$merge: failed due to matching as specified by 'whenMatched' option.");
        case "insert":
        default:
          output.push(o2);
          break;
      }
    }
    return o2;
  });
};
merge$1.$merge = $merge;
var out = {};
Object.defineProperty(out, "__esModule", { value: true });
out.$out = void 0;
const util_1$a = util$3;
const $out = (collection, expr2, options2) => {
  const outputColl = (0, util_1$a.isString)(expr2) ? options2 === null || options2 === void 0 ? void 0 : options2.collectionResolver(expr2) : expr2;
  (0, util_1$a.assert)(outputColl instanceof Array, `expression must resolve to an array`);
  return collection.map((o2) => {
    outputColl.push((0, util_1$a.cloneDeep)(o2));
    return o2;
  });
};
out.$out = $out;
var project = {};
Object.defineProperty(project, "__esModule", { value: true });
project.$project = void 0;
const core_1$3 = core;
const util_1$9 = util$3;
const $project = (collection, expr2, options2) => {
  if ((0, util_1$9.isEmpty)(expr2))
    return collection;
  let expressionKeys = Object.keys(expr2);
  let idOnlyExcluded = false;
  validateExpression(expr2, options2);
  const ID_KEY2 = options2.idKey;
  if ((0, util_1$9.inArray)(expressionKeys, ID_KEY2)) {
    const id = expr2[ID_KEY2];
    if (id === 0 || id === false) {
      expressionKeys = expressionKeys.filter(util_1$9.notInArray.bind(null, [ID_KEY2]));
      idOnlyExcluded = expressionKeys.length == 0;
    }
  } else {
    expressionKeys.push(ID_KEY2);
  }
  const copts = core_1$3.ComputeOptions.init(options2);
  return collection.map((obj) => processObject(obj, expr2, copts.update(obj), expressionKeys, idOnlyExcluded));
};
project.$project = $project;
function processObject(obj, expr2, options2, expressionKeys, idOnlyExcluded) {
  let newObj = {};
  let foundSlice = false;
  let foundExclusion = false;
  const dropKeys = [];
  if (idOnlyExcluded) {
    dropKeys.push(options2.idKey);
  }
  for (const key of expressionKeys) {
    let value = void 0;
    const subExpr = expr2[key];
    if (key !== options2.idKey && (0, util_1$9.inArray)([0, false], subExpr)) {
      foundExclusion = true;
    }
    if (key === options2.idKey && (0, util_1$9.isEmpty)(subExpr)) {
      value = obj[key];
    } else if ((0, util_1$9.isString)(subExpr)) {
      value = (0, core_1$3.computeValue)(obj, subExpr, key, options2);
    } else if ((0, util_1$9.inArray)([1, true], subExpr))
      ;
    else if (subExpr instanceof Array) {
      value = subExpr.map((v2) => {
        const r2 = (0, core_1$3.computeValue)(obj, v2, null, options2);
        if ((0, util_1$9.isNil)(r2))
          return null;
        return r2;
      });
    } else if ((0, util_1$9.isObject)(subExpr)) {
      const subExprObj = subExpr;
      const subExprKeys = Object.keys(subExpr);
      const operator = subExprKeys.length == 1 ? subExprKeys[0] : "";
      const call = (0, core_1$3.getOperator)(core_1$3.OperatorType.PROJECTION, operator, options2);
      if (call) {
        if (operator === "$slice") {
          if ((0, util_1$9.ensureArray)(subExprObj[operator]).every(util_1$9.isNumber)) {
            value = call(obj, subExprObj[operator], key, options2);
            foundSlice = true;
          } else {
            value = (0, core_1$3.computeValue)(obj, subExprObj, key, options2);
          }
        } else {
          value = call(obj, subExprObj[operator], key, options2);
        }
      } else if ((0, util_1$9.isOperator)(operator)) {
        value = (0, core_1$3.computeValue)(obj, subExprObj[operator], operator, options2);
      } else if ((0, util_1$9.has)(obj, key)) {
        validateExpression(subExprObj, options2);
        let target = obj[key];
        if (target instanceof Array) {
          value = target.map((o2) => processObject(o2, subExprObj, options2, subExprKeys, false));
        } else {
          target = (0, util_1$9.isObject)(target) ? target : obj;
          value = processObject(target, subExprObj, options2, subExprKeys, false);
        }
      } else {
        value = (0, core_1$3.computeValue)(obj, subExpr, null, options2);
      }
    } else {
      dropKeys.push(key);
      continue;
    }
    const objPathGraph = (0, util_1$9.resolveGraph)(obj, key, {
      preserveMissing: true
    });
    if (objPathGraph !== void 0) {
      (0, util_1$9.merge)(newObj, objPathGraph, {
        flatten: true
      });
    }
    if ((0, util_1$9.notInArray)([0, 1, false, true], subExpr)) {
      if (value === void 0) {
        (0, util_1$9.removeValue)(newObj, key, { descendArray: true });
      } else {
        (0, util_1$9.setValue)(newObj, key, value);
      }
    }
  }
  (0, util_1$9.filterMissing)(newObj);
  if (foundSlice || foundExclusion || idOnlyExcluded) {
    newObj = (0, util_1$9.into)({}, obj, newObj);
    if (dropKeys.length > 0) {
      for (const k2 of dropKeys) {
        (0, util_1$9.removeValue)(newObj, k2, { descendArray: true });
      }
    }
  }
  return newObj;
}
function validateExpression(expr2, options2) {
  const check = [false, false];
  for (const [k2, v2] of Object.entries(expr2)) {
    if (k2 === (options2 === null || options2 === void 0 ? void 0 : options2.idKey))
      return;
    if (v2 === 0 || v2 === false) {
      check[0] = true;
    } else if (v2 === 1 || v2 === true) {
      check[1] = true;
    }
    (0, util_1$9.assert)(!(check[0] && check[1]), "Projection cannot have a mix of inclusion and exclusion.");
  }
}
var redact = {};
Object.defineProperty(redact, "__esModule", { value: true });
redact.$redact = void 0;
const core_1$2 = core;
const $redact = (collection, expr2, options2) => {
  const copts = core_1$2.ComputeOptions.init(options2);
  return collection.map((obj) => (0, core_1$2.redact)(obj, expr2, copts.update(obj)));
};
redact.$redact = $redact;
var replaceRoot = {};
Object.defineProperty(replaceRoot, "__esModule", { value: true });
replaceRoot.$replaceRoot = void 0;
const core_1$1 = core;
const util_1$8 = util$3;
const $replaceRoot = (collection, expr2, options2) => {
  return collection.map((obj) => {
    obj = (0, core_1$1.computeValue)(obj, expr2.newRoot, null, options2);
    (0, util_1$8.assert)((0, util_1$8.isObject)(obj), "$replaceRoot expression must return an object");
    return obj;
  });
};
replaceRoot.$replaceRoot = $replaceRoot;
var replaceWith = {};
Object.defineProperty(replaceWith, "__esModule", { value: true });
replaceWith.$replaceWith = void 0;
const replaceRoot_1 = replaceRoot;
replaceWith.$replaceWith = replaceRoot_1.$replaceRoot;
var sample = {};
Object.defineProperty(sample, "__esModule", { value: true });
sample.$sample = void 0;
const $sample = (collection, expr2, _options2) => {
  return collection.transform((xs) => {
    const len = xs.length;
    let i2 = -1;
    return () => {
      if (++i2 === expr2.size)
        return { done: true };
      const n2 = Math.floor(Math.random() * len);
      return { value: xs[n2], done: false };
    };
  });
};
sample.$sample = $sample;
var set = {};
Object.defineProperty(set, "__esModule", { value: true });
set.$set = void 0;
const addFields_1 = addFields;
set.$set = addFields_1.$addFields;
var skip = {};
Object.defineProperty(skip, "__esModule", { value: true });
skip.$skip = void 0;
const $skip = (collection, expr2, options2) => {
  return collection.drop(expr2);
};
skip.$skip = $skip;
var sortByCount = {};
Object.defineProperty(sortByCount, "__esModule", { value: true });
sortByCount.$sortByCount = void 0;
const group_1 = group;
const sort_1 = sort;
const $sortByCount = (collection, expr2, options2) => {
  const newExpr = { count: { $sum: 1 } };
  newExpr["_id"] = expr2;
  return (0, sort_1.$sort)((0, group_1.$group)(collection, newExpr, options2), { count: -1 }, options2);
};
sortByCount.$sortByCount = $sortByCount;
var unionWith = {};
Object.defineProperty(unionWith, "__esModule", { value: true });
unionWith.$unionWith = void 0;
const aggregator_1 = aggregator;
const lazy_1$1 = lazy;
const util_1$7 = util$3;
const $unionWith = (collection, expr2, options2) => {
  const array2 = (0, util_1$7.isString)(expr2.coll) ? options2.collectionResolver(expr2.coll) : expr2.coll;
  const iterators = [collection];
  iterators.push(expr2.pipeline ? new aggregator_1.Aggregator(expr2.pipeline, options2).stream(array2) : (0, lazy_1$1.Lazy)(array2));
  return (0, lazy_1$1.compose)(...iterators);
};
unionWith.$unionWith = $unionWith;
var unset = {};
Object.defineProperty(unset, "__esModule", { value: true });
unset.$unset = void 0;
const util_1$6 = util$3;
const project_1 = project;
const $unset = (collection, expr2, options2) => {
  expr2 = (0, util_1$6.ensureArray)(expr2);
  const doc = {};
  for (const k2 of expr2)
    doc[k2] = 0;
  return (0, project_1.$project)(collection, doc, options2);
};
unset.$unset = $unset;
var unwind = {};
Object.defineProperty(unwind, "__esModule", { value: true });
unwind.$unwind = void 0;
const lazy_1 = lazy;
const util_1$5 = util$3;
const $unwind = (collection, expr2, _options2) => {
  if ((0, util_1$5.isString)(expr2))
    expr2 = { path: expr2 };
  const path2 = expr2.path;
  const field = path2.substring(1);
  const includeArrayIndex = (expr2 === null || expr2 === void 0 ? void 0 : expr2.includeArrayIndex) || false;
  const preserveNullAndEmptyArrays = expr2.preserveNullAndEmptyArrays || false;
  const format = (o2, i2) => {
    if (includeArrayIndex !== false)
      o2[includeArrayIndex] = i2;
    return o2;
  };
  let value;
  return (0, lazy_1.Lazy)(() => {
    for (; ; ) {
      if (value instanceof lazy_1.Iterator) {
        const tmp = value.next();
        if (!tmp.done)
          return tmp;
      }
      const wrapper = collection.next();
      if (wrapper.done)
        return wrapper;
      const obj = wrapper.value;
      value = (0, util_1$5.resolve)(obj, field);
      if (value instanceof Array) {
        if (value.length === 0 && preserveNullAndEmptyArrays === true) {
          value = null;
          (0, util_1$5.removeValue)(obj, field);
          return { value: format(obj, null), done: false };
        } else {
          value = (0, lazy_1.Lazy)(value).map((item, i2) => {
            const newObj = (0, util_1$5.resolveGraph)(obj, field, {
              preserveKeys: true
            });
            (0, util_1$5.setValue)(newObj, field, item);
            return format(newObj, i2);
          });
        }
      } else if (!(0, util_1$5.isEmpty)(value) || preserveNullAndEmptyArrays === true) {
        return { value: format(obj, null), done: false };
      }
    }
  });
};
unwind.$unwind = $unwind;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(addFields, exports);
  __exportStar(bucket, exports);
  __exportStar(bucketAuto, exports);
  __exportStar(count$1, exports);
  __exportStar(facet, exports);
  __exportStar(fill, exports);
  __exportStar(group, exports);
  __exportStar(limit, exports);
  __exportStar(lookup, exports);
  __exportStar(match, exports);
  __exportStar(merge$1, exports);
  __exportStar(out, exports);
  __exportStar(project, exports);
  __exportStar(redact, exports);
  __exportStar(replaceRoot, exports);
  __exportStar(replaceWith, exports);
  __exportStar(sample, exports);
  __exportStar(set, exports);
  __exportStar(setWindowFields, exports);
  __exportStar(skip, exports);
  __exportStar(sort, exports);
  __exportStar(sortByCount, exports);
  __exportStar(unionWith, exports);
  __exportStar(unset, exports);
  __exportStar(unwind, exports);
})(pipeline);
var logical = {};
var and = {};
Object.defineProperty(and, "__esModule", { value: true });
and.$and = void 0;
const query_1$2 = query;
const util_1$4 = util$3;
const $and = (_2, rhs, options2) => {
  (0, util_1$4.assert)((0, util_1$4.isArray)(rhs), "Invalid expression: $and expects value to be an Array.");
  const queries = rhs.map((expr2) => new query_1$2.Query(expr2, options2));
  return (obj) => queries.every((q2) => q2.test(obj));
};
and.$and = $and;
var nor = {};
var or = {};
Object.defineProperty(or, "__esModule", { value: true });
or.$or = void 0;
const query_1$1 = query;
const util_1$3 = util$3;
const $or = (_2, rhs, options2) => {
  (0, util_1$3.assert)((0, util_1$3.isArray)(rhs), "Invalid expression. $or expects value to be an Array");
  const queries = rhs.map((expr2) => new query_1$1.Query(expr2, options2));
  return (obj) => queries.some((q2) => q2.test(obj));
};
or.$or = $or;
Object.defineProperty(nor, "__esModule", { value: true });
nor.$nor = void 0;
const util_1$2 = util$3;
const or_1 = or;
const $nor = (_2, rhs, options2) => {
  (0, util_1$2.assert)((0, util_1$2.isArray)(rhs), "Invalid expression. $nor expects value to be an array.");
  const f2 = (0, or_1.$or)("$or", rhs, options2);
  return (obj) => !f2(obj);
};
nor.$nor = $nor;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
not.$not = void 0;
const query_1 = query;
const util_1$1 = util$3;
const $not = (selector, rhs, options2) => {
  const criteria = {};
  criteria[selector] = (0, util_1$1.normalize)(rhs);
  const query2 = new query_1.Query(criteria, options2);
  return (obj) => !query2.test(obj);
};
not.$not = $not;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(and, exports);
  __exportStar(nor, exports);
  __exportStar(not, exports);
  __exportStar(or, exports);
})(logical);
var comparison = {};
var eq = {};
Object.defineProperty(eq, "__esModule", { value: true });
eq.$eq = void 0;
const _predicates_1$e = _predicates;
eq.$eq = (0, _predicates_1$e.createQueryOperator)(_predicates_1$e.$eq);
var gt = {};
Object.defineProperty(gt, "__esModule", { value: true });
gt.$gt = void 0;
const _predicates_1$d = _predicates;
gt.$gt = (0, _predicates_1$d.createQueryOperator)(_predicates_1$d.$gt);
var gte = {};
Object.defineProperty(gte, "__esModule", { value: true });
gte.$gte = void 0;
const _predicates_1$c = _predicates;
gte.$gte = (0, _predicates_1$c.createQueryOperator)(_predicates_1$c.$gte);
var _in = {};
Object.defineProperty(_in, "__esModule", { value: true });
_in.$in = void 0;
const _predicates_1$b = _predicates;
_in.$in = (0, _predicates_1$b.createQueryOperator)(_predicates_1$b.$in);
var lt = {};
Object.defineProperty(lt, "__esModule", { value: true });
lt.$lt = void 0;
const _predicates_1$a = _predicates;
lt.$lt = (0, _predicates_1$a.createQueryOperator)(_predicates_1$a.$lt);
var lte = {};
Object.defineProperty(lte, "__esModule", { value: true });
lte.$lte = void 0;
const _predicates_1$9 = _predicates;
lte.$lte = (0, _predicates_1$9.createQueryOperator)(_predicates_1$9.$lte);
var ne = {};
Object.defineProperty(ne, "__esModule", { value: true });
ne.$ne = void 0;
const _predicates_1$8 = _predicates;
ne.$ne = (0, _predicates_1$8.createQueryOperator)(_predicates_1$8.$ne);
var nin = {};
Object.defineProperty(nin, "__esModule", { value: true });
nin.$nin = void 0;
const _predicates_1$7 = _predicates;
nin.$nin = (0, _predicates_1$7.createQueryOperator)(_predicates_1$7.$nin);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.$nin = exports.$ne = exports.$lte = exports.$lt = exports.$in = exports.$gte = exports.$gt = exports.$eq = void 0;
  var eq_1 = eq;
  Object.defineProperty(exports, "$eq", { enumerable: true, get: function() {
    return eq_1.$eq;
  } });
  var gt_1 = gt;
  Object.defineProperty(exports, "$gt", { enumerable: true, get: function() {
    return gt_1.$gt;
  } });
  var gte_1 = gte;
  Object.defineProperty(exports, "$gte", { enumerable: true, get: function() {
    return gte_1.$gte;
  } });
  var in_1 = _in;
  Object.defineProperty(exports, "$in", { enumerable: true, get: function() {
    return in_1.$in;
  } });
  var lt_1 = lt;
  Object.defineProperty(exports, "$lt", { enumerable: true, get: function() {
    return lt_1.$lt;
  } });
  var lte_1 = lte;
  Object.defineProperty(exports, "$lte", { enumerable: true, get: function() {
    return lte_1.$lte;
  } });
  var ne_1 = ne;
  Object.defineProperty(exports, "$ne", { enumerable: true, get: function() {
    return ne_1.$ne;
  } });
  var nin_1 = nin;
  Object.defineProperty(exports, "$nin", { enumerable: true, get: function() {
    return nin_1.$nin;
  } });
})(comparison);
var evaluation = {};
var expr = {};
Object.defineProperty(expr, "__esModule", { value: true });
expr.$expr = void 0;
const core_1 = core;
function $expr(_2, rhs, options2) {
  return (obj) => (0, core_1.computeValue)(obj, rhs, null, options2);
}
expr.$expr = $expr;
var jsonSchema = {};
Object.defineProperty(jsonSchema, "__esModule", { value: true });
jsonSchema.$jsonSchema = void 0;
function $jsonSchema(_2, schema, options2) {
  if (!(options2 === null || options2 === void 0 ? void 0 : options2.jsonSchemaValidator)) {
    throw new Error("Missing option 'jsonSchemaValidator'. Configure to use '$jsonSchema' operator.");
  }
  const validate = options2 === null || options2 === void 0 ? void 0 : options2.jsonSchemaValidator(schema);
  return (obj) => validate(obj);
}
jsonSchema.$jsonSchema = $jsonSchema;
var mod = {};
Object.defineProperty(mod, "__esModule", { value: true });
mod.$mod = void 0;
const _predicates_1$6 = _predicates;
mod.$mod = (0, _predicates_1$6.createQueryOperator)(_predicates_1$6.$mod);
var regex = {};
Object.defineProperty(regex, "__esModule", { value: true });
regex.$regex = void 0;
const _predicates_1$5 = _predicates;
regex.$regex = (0, _predicates_1$5.createQueryOperator)(_predicates_1$5.$regex);
var where = {};
Object.defineProperty(where, "__esModule", { value: true });
where.$where = void 0;
const util_1 = util$3;
function $where(_2, rhs, options2) {
  (0, util_1.assert)(options2.scriptEnabled, "$where operator requires 'scriptEnabled' option to be true");
  const f2 = rhs;
  (0, util_1.assert)((0, util_1.isFunction)(f2), "$where only accepts a Function object");
  return (obj) => (0, util_1.truthy)(f2.call(obj), options2 === null || options2 === void 0 ? void 0 : options2.useStrictMode);
}
where.$where = $where;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(expr, exports);
  __exportStar(jsonSchema, exports);
  __exportStar(mod, exports);
  __exportStar(regex, exports);
  __exportStar(where, exports);
})(evaluation);
var array = {};
var all = {};
Object.defineProperty(all, "__esModule", { value: true });
all.$all = void 0;
const _predicates_1$4 = _predicates;
all.$all = (0, _predicates_1$4.createQueryOperator)(_predicates_1$4.$all);
var elemMatch = {};
Object.defineProperty(elemMatch, "__esModule", { value: true });
elemMatch.$elemMatch = void 0;
const _predicates_1$3 = _predicates;
elemMatch.$elemMatch = (0, _predicates_1$3.createQueryOperator)(_predicates_1$3.$elemMatch);
var size = {};
Object.defineProperty(size, "__esModule", { value: true });
size.$size = void 0;
const _predicates_1$2 = _predicates;
size.$size = (0, _predicates_1$2.createQueryOperator)(_predicates_1$2.$size);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(all, exports);
  __exportStar(elemMatch, exports);
  __exportStar(size, exports);
})(array);
var element = {};
var exists = {};
Object.defineProperty(exists, "__esModule", { value: true });
exists.$exists = void 0;
const _predicates_1$1 = _predicates;
exists.$exists = (0, _predicates_1$1.createQueryOperator)(_predicates_1$1.$exists);
var type$5 = {};
Object.defineProperty(type$5, "__esModule", { value: true });
type$5.$type = void 0;
const _predicates_1 = _predicates;
type$5.$type = (0, _predicates_1.createQueryOperator)(_predicates_1.$type);
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(exists, exports);
  __exportStar(type$5, exports);
})(element);
Object.defineProperty(rxQueryMingo, "__esModule", {
  value: true
});
rxQueryMingo.getMingoQuery = getMingoQuery;
var _core = core;
var _query = query;
var _pipeline = pipeline;
var _logical = logical;
var _comparison = comparison;
var _evaluation = evaluation;
var _array = array;
var _element = element;
var mingoInitDone = false;
function getMingoQuery(selector) {
  if (!mingoInitDone) {
    (0, _core.useOperators)(_core.OperatorType.PIPELINE, {
      $sort: _pipeline.$sort,
      $project: _pipeline.$project
    });
    (0, _core.useOperators)(_core.OperatorType.QUERY, {
      $and: _logical.$and,
      $eq: _comparison.$eq,
      $elemMatch: _array.$elemMatch,
      $exists: _element.$exists,
      $gt: _comparison.$gt,
      $gte: _comparison.$gte,
      $in: _comparison.$in,
      $lt: _comparison.$lt,
      $lte: _comparison.$lte,
      $ne: _comparison.$ne,
      $nin: _comparison.$nin,
      $mod: _evaluation.$mod,
      $nor: _logical.$nor,
      $not: _logical.$not,
      $or: _logical.$or,
      $regex: _evaluation.$regex,
      $size: _array.$size,
      $type: _element.$type
    });
    mingoInitDone = true;
  }
  return new _query.Query(selector);
}
Object.defineProperty(rxQueryHelper, "__esModule", {
  value: true
});
rxQueryHelper.getQueryMatcher = getQueryMatcher;
rxQueryHelper.getSortComparator = getSortComparator;
rxQueryHelper.normalizeMangoQuery = normalizeMangoQuery;
rxQueryHelper.normalizeQueryRegex = normalizeQueryRegex;
var _queryPlanner$2 = queryPlanner;
var _rxSchemaHelper$9 = rxSchemaHelper;
var _utils$k = utils;
var _util$8 = util$3;
var _rxError$b = rxError;
var _rxQueryMingo = rxQueryMingo;
function normalizeMangoQuery(schema, mangoQuery) {
  var primaryKey = (0, _rxSchemaHelper$9.getPrimaryFieldOfPrimaryKey)(schema.primaryKey);
  mangoQuery = (0, _utils$k.flatClone)(mangoQuery);
  if (mangoQuery.selector) {
    mangoQuery.selector = normalizeQueryRegex(mangoQuery.selector);
  }
  var normalizedMangoQuery = (0, _utils$k.clone)(mangoQuery);
  if (typeof normalizedMangoQuery.skip !== "number") {
    normalizedMangoQuery.skip = 0;
  }
  if (!normalizedMangoQuery.selector) {
    normalizedMangoQuery.selector = {};
  } else {
    normalizedMangoQuery.selector = normalizedMangoQuery.selector;
    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
      if (typeof matcher !== "object" || matcher === null) {
        normalizedMangoQuery.selector[field] = {
          $eq: matcher
        };
      }
    });
  }
  if (normalizedMangoQuery.index) {
    var indexAr = (0, _utils$k.toArray)(normalizedMangoQuery.index);
    if (!indexAr.includes(primaryKey)) {
      indexAr.push(primaryKey);
    }
    normalizedMangoQuery.index = indexAr;
  }
  if (!normalizedMangoQuery.sort) {
    if (normalizedMangoQuery.index) {
      normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field) => {
        return {
          [field]: "asc"
        };
      });
    } else {
      if (schema.indexes) {
        var fieldsWithLogicalOperator = /* @__PURE__ */ new Set();
        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
          var hasLogical = false;
          if (typeof matcher === "object" && matcher !== null) {
            hasLogical = !!Object.keys(matcher).find((operator) => _queryPlanner$2.LOGICAL_OPERATORS.has(operator));
          } else {
            hasLogical = true;
          }
          if (hasLogical) {
            fieldsWithLogicalOperator.add(field);
          }
        });
        var currentFieldsAmount = -1;
        var currentBestIndexForSort;
        schema.indexes.forEach((index) => {
          var useIndex = (0, _utils$k.isMaybeReadonlyArray)(index) ? index : [index];
          var firstWrongIndex = useIndex.findIndex((indexField) => !fieldsWithLogicalOperator.has(indexField));
          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {
            currentFieldsAmount = firstWrongIndex;
            currentBestIndexForSort = useIndex;
          }
        });
        if (currentBestIndexForSort) {
          normalizedMangoQuery.sort = currentBestIndexForSort.map((field) => {
            return {
              [field]: "asc"
            };
          });
        }
      }
      if (!normalizedMangoQuery.sort) {
        normalizedMangoQuery.sort = [{
          [primaryKey]: "asc"
        }];
      }
    }
  } else {
    var isPrimaryInSort = normalizedMangoQuery.sort.find((p2) => (0, _utils$k.firstPropertyNameOfObject)(p2) === primaryKey);
    if (!isPrimaryInSort) {
      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);
      normalizedMangoQuery.sort.push({
        [primaryKey]: "asc"
      });
    }
  }
  return normalizedMangoQuery;
}
function normalizeQueryRegex(selector) {
  if (typeof selector !== "object" || selector === null) {
    return selector;
  }
  var keys = Object.keys(selector);
  var ret = {};
  keys.forEach((key) => {
    var value = selector[key];
    if (key === "$regex" && value instanceof RegExp) {
      var parsed = (0, _utils$k.parseRegex)(value);
      ret.$regex = parsed.pattern;
      ret.$options = parsed.flags;
    } else if (Array.isArray(value)) {
      ret[key] = value.map((item) => normalizeQueryRegex(item));
    } else {
      ret[key] = normalizeQueryRegex(value);
    }
  });
  return ret;
}
function getSortComparator(schema, query2) {
  if (!query2.sort) {
    throw (0, _rxError$b.newRxError)("SNH", {
      query: query2
    });
  }
  var sortParts = [];
  query2.sort.forEach((sortBlock) => {
    var key = Object.keys(sortBlock)[0];
    var direction = Object.values(sortBlock)[0];
    sortParts.push({
      key,
      direction,
      getValueFn: (0, _utils$k.objectPathMonad)(key)
    });
  });
  var fun = (a2, b2) => {
    for (var i2 = 0; i2 < sortParts.length; ++i2) {
      var sortPart = sortParts[i2];
      var valueA = sortPart.getValueFn(a2);
      var valueB = sortPart.getValueFn(b2);
      if (valueA !== valueB) {
        var ret = sortPart.direction === "asc" ? (0, _util$8.compare)(valueA, valueB) : (0, _util$8.compare)(valueB, valueA);
        return ret;
      }
    }
  };
  return fun;
}
function getQueryMatcher(_schema, query2) {
  if (!query2.sort) {
    throw (0, _rxError$b.newRxError)("SNH", {
      query: query2
    });
  }
  var mingoQuery = (0, _rxQueryMingo.getMingoQuery)(query2.selector);
  var fun = (doc) => {
    if (doc._deleted) {
      return false;
    }
    var cursor2 = mingoQuery.find([doc]);
    var next = cursor2.next();
    if (next) {
      return true;
    } else {
      return false;
    }
  };
  return fun;
}
Object.defineProperty(dexieQuery$1, "__esModule", {
  value: true
});
dexieQuery$1.dexieCount = dexieCount;
dexieQuery$1.dexieQuery = dexieQuery;
dexieQuery$1.getKeyRangeByQueryPlan = getKeyRangeByQueryPlan;
dexieQuery$1.mapKeyForKeyRange = mapKeyForKeyRange;
var _queryPlanner$1 = queryPlanner;
var _rxQueryHelper$1 = rxQueryHelper;
var _dexieHelper$2 = dexieHelper;
function mapKeyForKeyRange(k2) {
  if (k2 === _queryPlanner$1.INDEX_MIN) {
    return -Infinity;
  } else {
    return k2;
  }
}
function getKeyRangeByQueryPlan(queryPlan, IDBKeyRange2) {
  if (!IDBKeyRange2) {
    if (typeof window === "undefined") {
      throw new Error("IDBKeyRange missing");
    } else {
      IDBKeyRange2 = window.IDBKeyRange;
    }
  }
  var startKeys = queryPlan.startKeys.map(mapKeyForKeyRange);
  var endKeys = queryPlan.endKeys.map(mapKeyForKeyRange);
  var ret;
  if (queryPlan.index.length === 1) {
    var equalKeys = startKeys[0] === endKeys[0];
    ret = IDBKeyRange2.bound(startKeys[0], endKeys[0], equalKeys ? false : !queryPlan.inclusiveStart, equalKeys ? false : !queryPlan.inclusiveEnd);
  } else {
    ret = IDBKeyRange2.bound(startKeys, endKeys, !queryPlan.inclusiveStart, !queryPlan.inclusiveEnd);
  }
  return ret;
}
async function dexieQuery(instance, preparedQuery) {
  var state = await instance.internals;
  var query2 = preparedQuery.query;
  var skip2 = query2.skip ? query2.skip : 0;
  var limit2 = query2.limit ? query2.limit : Infinity;
  var skipPlusLimit = skip2 + limit2;
  var queryPlan = preparedQuery.queryPlan;
  var queryMatcher = false;
  if (!queryPlan.selectorSatisfiedByIndex) {
    queryMatcher = (0, _rxQueryHelper$1.getQueryMatcher)(instance.schema, preparedQuery.query);
  }
  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);
  var queryPlanFields = queryPlan.index;
  var rows = [];
  await state.dexieDb.transaction("r", state.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store = tx.objectStore(_dexieHelper$2.DEXIE_DOCS_TABLE_NAME);
    var index;
    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {
      index = store;
    } else {
      var indexName;
      if (queryPlanFields.length === 1) {
        indexName = (0, _dexieHelper$2.dexieReplaceIfStartsWithPipe)(queryPlanFields[0]);
      } else {
        indexName = "[" + queryPlanFields.map((field) => (0, _dexieHelper$2.dexieReplaceIfStartsWithPipe)(field)).join("+") + "]";
      }
      index = store.index(indexName);
    }
    var cursorReq = index.openCursor(keyRange);
    await new Promise((res) => {
      cursorReq.onsuccess = function(e2) {
        var cursor2 = e2.target.result;
        if (cursor2) {
          var docData = (0, _dexieHelper$2.fromDexieToStorage)(cursor2.value);
          if (!docData._deleted && (!queryMatcher || queryMatcher(docData))) {
            rows.push(docData);
          }
          if (queryPlan.sortFieldsSameAsIndexFields && rows.length === skipPlusLimit) {
            res();
          } else {
            cursor2.continue();
          }
        } else {
          res();
        }
      };
    });
  });
  if (!queryPlan.sortFieldsSameAsIndexFields) {
    var sortComparator = (0, _rxQueryHelper$1.getSortComparator)(instance.schema, preparedQuery.query);
    rows = rows.sort(sortComparator);
  }
  rows = rows.slice(skip2, skipPlusLimit);
  return {
    documents: rows
  };
}
async function dexieCount(instance, preparedQuery) {
  var state = await instance.internals;
  var queryPlan = preparedQuery.queryPlan;
  var queryPlanFields = queryPlan.index;
  var keyRange = getKeyRangeByQueryPlan(queryPlan, state.dexieDb._options.IDBKeyRange);
  var count2 = -1;
  await state.dexieDb.transaction("r", state.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store = tx.objectStore(_dexieHelper$2.DEXIE_DOCS_TABLE_NAME);
    var index;
    if (queryPlanFields.length === 1 && queryPlanFields[0] === instance.primaryPath) {
      index = store;
    } else {
      var indexName;
      if (queryPlanFields.length === 1) {
        indexName = (0, _dexieHelper$2.dexieReplaceIfStartsWithPipe)(queryPlanFields[0]);
      } else {
        indexName = "[" + queryPlanFields.map((field) => (0, _dexieHelper$2.dexieReplaceIfStartsWithPipe)(field)).join("+") + "]";
      }
      index = store.index(indexName);
    }
    var request = index.count(keyRange);
    count2 = await new Promise((res, rej) => {
      request.onsuccess = function() {
        res(request.result);
      };
      request.onerror = (err) => rej(err);
    });
  });
  return count2;
}
var rxStorageMultiinstance = {};
var operators = {};
var partition$1 = {};
Object.defineProperty(partition$1, "__esModule", { value: true });
partition$1.partition = void 0;
var not_1 = not$3;
var filter_1 = filter$2;
function partition(predicate, thisArg) {
  return function(source) {
    return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];
  };
}
partition$1.partition = partition;
var race$1 = {};
var __read = commonjsGlobal && commonjsGlobal.__read || function(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
Object.defineProperty(race$1, "__esModule", { value: true });
race$1.race = void 0;
var argsOrArgArray_1 = argsOrArgArray$1;
var raceWith_1 = raceWith$1;
function race() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  return raceWith_1.raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray_1.argsOrArgArray(args2))));
}
race$1.race = race;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeAll = exports.merge = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.concat = exports.combineLatestWith = exports.combineLatest = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = void 0;
  exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.race = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.partition = exports.pairwise = exports.onErrorResumeNext = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = void 0;
  exports.zipWith = exports.zipAll = exports.zip = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = void 0;
  var audit_12 = audit$1;
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_12.audit;
  } });
  var auditTime_1 = auditTime$1;
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = buffer$1;
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = bufferCount$1;
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = bufferTime$1;
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = bufferToggle$1;
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = bufferWhen$1;
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = catchError$1;
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = combineAll;
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_12 = combineLatestAll$1;
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_12.combineLatestAll;
  } });
  var combineLatest_12 = combineLatest$1;
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_12.combineLatest;
  } });
  var combineLatestWith_1 = combineLatestWith$1;
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concat_12 = concat$2;
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_12.concat;
  } });
  var concatAll_12 = concatAll$1;
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_12.concatAll;
  } });
  var concatMap_12 = concatMap$1;
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_12.concatMap;
  } });
  var concatMapTo_1 = concatMapTo$1;
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = concatWith$1;
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_12 = connect$1;
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_12.connect;
  } });
  var count_1 = count$3;
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = debounce$1;
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = debounceTime$1;
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_12 = defaultIfEmpty$1;
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_12.defaultIfEmpty;
  } });
  var delay_1 = delay$1;
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_12 = delayWhen$1;
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_12.delayWhen;
  } });
  var dematerialize_1 = dematerialize$1;
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = distinct$1;
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_12 = distinctUntilChanged$1;
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_12.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = distinctUntilKeyChanged$1;
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = elementAt$1;
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = endWith$1;
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = every$1;
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = exhaust;
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_12 = exhaustAll$1;
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_12.exhaustAll;
  } });
  var exhaustMap_12 = exhaustMap$1;
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_12.exhaustMap;
  } });
  var expand_1 = expand$1;
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_12 = filter$2;
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_12.filter;
  } });
  var finalize_1 = finalize$1;
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_12 = find$1;
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_12.find;
  } });
  var findIndex_1 = findIndex$1;
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = first$3;
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = groupBy$1;
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_12 = ignoreElements$1;
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_12.ignoreElements;
  } });
  var isEmpty_1 = isEmpty$1;
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = last$3;
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_12 = map$2;
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_12.map;
  } });
  var mapTo_12 = mapTo$1;
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_12.mapTo;
  } });
  var materialize_1 = materialize$1;
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = max$2;
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var merge_12 = merge$3;
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_12.merge;
  } });
  var mergeAll_12 = mergeAll$1;
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_12.mergeAll;
  } });
  var flatMap_1 = flatMap;
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_12 = mergeMap$1;
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_12.mergeMap;
  } });
  var mergeMapTo_1 = mergeMapTo$1;
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = mergeScan$1;
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = mergeWith$1;
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = min$2;
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_12 = multicast$1;
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_12.multicast;
  } });
  var observeOn_12 = observeOn$1;
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_12.observeOn;
  } });
  var onErrorResumeNextWith_1 = onErrorResumeNextWith$1;
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNext;
  } });
  var pairwise_1 = pairwise$1;
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var partition_1 = partition$1;
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var pluck_1 = pluck$1;
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = publish$1;
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = publishBehavior$1;
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = publishLast$1;
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = publishReplay$1;
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var race_12 = race$1;
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_12.race;
  } });
  var raceWith_12 = raceWith$1;
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_12.raceWith;
  } });
  var reduce_12 = reduce$2;
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_12.reduce;
  } });
  var repeat_1 = repeat$1;
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = repeatWhen$1;
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = retry$1;
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = retryWhen$1;
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_12 = refCount$1;
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_12.refCount;
  } });
  var sample_12 = sample$2;
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_12.sample;
  } });
  var sampleTime_1 = sampleTime$1;
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = scan$1;
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = sequenceEqual$1;
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_12 = share$1;
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_12.share;
  } });
  var shareReplay_1 = shareReplay$1;
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = single$1;
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = skip$2;
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = skipLast$1;
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = skipUntil$1;
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = skipWhile$1;
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = startWith$1;
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_12 = subscribeOn$1;
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_12.subscribeOn;
  } });
  var switchAll_1 = switchAll$1;
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_12 = switchMap$1;
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_12.switchMap;
  } });
  var switchMapTo_1 = switchMapTo$1;
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = switchScan$1;
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_12 = take$1;
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_12.take;
  } });
  var takeLast_12 = takeLast$1;
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_12.takeLast;
  } });
  var takeUntil_1 = takeUntil$1;
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = takeWhile$1;
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = tap$1;
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_12 = throttle$1;
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_12.throttle;
  } });
  var throttleTime_1 = throttleTime$1;
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_12 = throwIfEmpty$1;
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_12.throwIfEmpty;
  } });
  var timeInterval_1 = timeInterval$1;
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_12 = timeout;
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_12.timeout;
  } });
  var timeoutWith_1 = timeoutWith$1;
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = timestamp$1;
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_12 = toArray$2;
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_12.toArray;
  } });
  var window_1 = window$2;
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = windowCount$1;
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = windowTime$1;
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = windowToggle$1;
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = windowWhen$1;
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = withLatestFrom$1;
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zip_12 = zip$2;
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_12.zip;
  } });
  var zipAll_1 = zipAll$1;
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = zipWith$1;
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
})(operators);
var es5node = {};
var broadcastChannel = {};
var util$2 = {};
Object.defineProperty(util$2, "__esModule", {
  value: true
});
util$2.PROMISE_RESOLVED_VOID = util$2.PROMISE_RESOLVED_TRUE = util$2.PROMISE_RESOLVED_FALSE = void 0;
util$2.isPromise = isPromise;
util$2.microSeconds = microSeconds$5;
util$2.randomInt = randomInt;
util$2.randomToken = randomToken;
util$2.sleep = sleep;
util$2.supportsWebLockAPI = supportsWebLockAPI;
function isPromise(obj) {
  return obj && typeof obj.then === "function";
}
var PROMISE_RESOLVED_FALSE = Promise.resolve(false);
util$2.PROMISE_RESOLVED_FALSE = PROMISE_RESOLVED_FALSE;
var PROMISE_RESOLVED_TRUE = Promise.resolve(true);
util$2.PROMISE_RESOLVED_TRUE = PROMISE_RESOLVED_TRUE;
var PROMISE_RESOLVED_VOID = Promise.resolve();
util$2.PROMISE_RESOLVED_VOID = PROMISE_RESOLVED_VOID;
function sleep(time, resolveWith) {
  if (!time)
    time = 0;
  return new Promise(function(res) {
    return setTimeout(function() {
      return res(resolveWith);
    }, time);
  });
}
function randomInt(min2, max2) {
  return Math.floor(Math.random() * (max2 - min2 + 1) + min2);
}
function randomToken() {
  return Math.random().toString(36).substring(2);
}
var lastMs = 0;
var additional = 0;
function microSeconds$5() {
  var ms = (/* @__PURE__ */ new Date()).getTime();
  if (ms === lastMs) {
    additional++;
    return ms * 1e3 + additional;
  } else {
    lastMs = ms;
    additional = 0;
    return ms * 1e3;
  }
}
function supportsWebLockAPI() {
  if (typeof navigator !== "undefined" && typeof navigator.locks !== "undefined" && typeof navigator.locks.request === "function") {
    return true;
  } else {
    return false;
  }
}
var methodChooser = {};
var _typeof$1 = { exports: {} };
(function(module) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(obj);
  }
  module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof$1);
var _typeofExports = _typeof$1.exports;
var native = {};
Object.defineProperty(native, "__esModule", {
  value: true
});
native.NativeMethod = void 0;
native.averageResponseTime = averageResponseTime$4;
native.canBeUsed = canBeUsed$4;
native.close = close$4;
native.create = create$4;
native.microSeconds = void 0;
native.onMessage = onMessage$4;
native.postMessage = postMessage$4;
native.type = void 0;
var _util$7 = util$2;
var microSeconds$4 = _util$7.microSeconds;
native.microSeconds = microSeconds$4;
var type$4 = "native";
native.type = type$4;
function create$4(channelName) {
  var state = {
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: []
    // subscriberFunctions
  };
  state.bc.onmessage = function(msg) {
    if (state.messagesCallback) {
      state.messagesCallback(msg.data);
    }
  };
  return state;
}
function close$4(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}
function postMessage$4(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return _util$7.PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}
function onMessage$4(channelState, fn2) {
  channelState.messagesCallback = fn2;
}
function canBeUsed$4() {
  if ((typeof window !== "undefined" || typeof self !== "undefined") && typeof BroadcastChannel === "function") {
    if (BroadcastChannel._pubkey) {
      throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
    }
    return true;
  } else {
    return false;
  }
}
function averageResponseTime$4() {
  return 150;
}
var NativeMethod = {
  create: create$4,
  close: close$4,
  onMessage: onMessage$4,
  postMessage: postMessage$4,
  canBeUsed: canBeUsed$4,
  type: type$4,
  averageResponseTime: averageResponseTime$4,
  microSeconds: microSeconds$4
};
native.NativeMethod = NativeMethod;
var indexedDb = {};
var ObliviousSet = (
  /** @class */
  function() {
    function ObliviousSet2(ttl) {
      this.ttl = ttl;
      this.map = /* @__PURE__ */ new Map();
      this._to = false;
    }
    ObliviousSet2.prototype.has = function(value) {
      return this.map.has(value);
    };
    ObliviousSet2.prototype.add = function(value) {
      var _this = this;
      this.map.set(value, now$1());
      if (!this._to) {
        this._to = true;
        setTimeout(function() {
          _this._to = false;
          removeTooOldValues(_this);
        }, 0);
      }
    };
    ObliviousSet2.prototype.clear = function() {
      this.map.clear();
    };
    return ObliviousSet2;
  }()
);
function removeTooOldValues(obliviousSet) {
  var olderThen = now$1() - obliviousSet.ttl;
  var iterator2 = obliviousSet.map[Symbol.iterator]();
  while (true) {
    var next = iterator2.next().value;
    if (!next) {
      return;
    }
    var value = next[0];
    var time = next[1];
    if (time < olderThen) {
      obliviousSet.map.delete(value);
    } else {
      return;
    }
  }
}
function now$1() {
  return (/* @__PURE__ */ new Date()).getTime();
}
const es$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ObliviousSet,
  now: now$1,
  removeTooOldValues
}, Symbol.toStringTag, { value: "Module" }));
const require$$11 = /* @__PURE__ */ getAugmentedNamespace(es$3);
var options = {};
Object.defineProperty(options, "__esModule", {
  value: true
});
options.fillOptionsWithDefaults = fillOptionsWithDefaults$1;
function fillOptionsWithDefaults$1() {
  var originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var options2 = JSON.parse(JSON.stringify(originalOptions));
  if (typeof options2.webWorkerSupport === "undefined")
    options2.webWorkerSupport = true;
  if (!options2.idb)
    options2.idb = {};
  if (!options2.idb.ttl)
    options2.idb.ttl = 1e3 * 45;
  if (!options2.idb.fallbackInterval)
    options2.idb.fallbackInterval = 150;
  if (originalOptions.idb && typeof originalOptions.idb.onclose === "function")
    options2.idb.onclose = originalOptions.idb.onclose;
  if (!options2.localstorage)
    options2.localstorage = {};
  if (!options2.localstorage.removeTimeout)
    options2.localstorage.removeTimeout = 1e3 * 60;
  if (originalOptions.methods)
    options2.methods = originalOptions.methods;
  if (!options2.node)
    options2.node = {};
  if (!options2.node.ttl)
    options2.node.ttl = 1e3 * 60 * 2;
  if (!options2.node.maxParallelWrites)
    options2.node.maxParallelWrites = 2048;
  if (typeof options2.node.useFastPath === "undefined")
    options2.node.useFastPath = true;
  return options2;
}
Object.defineProperty(indexedDb, "__esModule", {
  value: true
});
indexedDb.TRANSACTION_SETTINGS = indexedDb.IndexedDBMethod = void 0;
indexedDb.averageResponseTime = averageResponseTime$3;
indexedDb.canBeUsed = canBeUsed$3;
indexedDb.cleanOldMessages = cleanOldMessages$1;
indexedDb.close = close$3;
indexedDb.commitIndexedDBTransaction = commitIndexedDBTransaction;
indexedDb.create = create$3;
indexedDb.createDatabase = createDatabase;
indexedDb.getAllMessages = getAllMessages$1;
indexedDb.getIdb = getIdb;
indexedDb.getMessagesHigherThan = getMessagesHigherThan;
indexedDb.getOldMessages = getOldMessages;
indexedDb.microSeconds = void 0;
indexedDb.onMessage = onMessage$3;
indexedDb.postMessage = postMessage$3;
indexedDb.removeMessagesById = removeMessagesById;
indexedDb.type = void 0;
indexedDb.writeMessage = writeMessage$1;
var _util$6 = util$2;
var _obliviousSet$3 = require$$11;
var _options$3 = options;
var microSeconds$3 = _util$6.microSeconds;
indexedDb.microSeconds = microSeconds$3;
var DB_PREFIX = "pubkey.broadcast-channel-0-";
var OBJECT_STORE_ID = "messages";
var TRANSACTION_SETTINGS = {
  durability: "relaxed"
};
indexedDb.TRANSACTION_SETTINGS = TRANSACTION_SETTINGS;
var type$3 = "idb";
indexedDb.type = type$3;
function getIdb() {
  if (typeof indexedDB !== "undefined")
    return indexedDB;
  if (typeof window !== "undefined") {
    if (typeof window.mozIndexedDB !== "undefined")
      return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== "undefined")
      return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== "undefined")
      return window.msIndexedDB;
  }
  return false;
}
function commitIndexedDBTransaction(tx) {
  if (tx.commit) {
    tx.commit();
  }
}
function createDatabase(channelName) {
  var IndexedDB = getIdb();
  var dbName = DB_PREFIX + channelName;
  var openRequest = IndexedDB.open(dbName);
  openRequest.onupgradeneeded = function(ev) {
    var db = ev.target.result;
    db.createObjectStore(OBJECT_STORE_ID, {
      keyPath: "id",
      autoIncrement: true
    });
  };
  return new Promise(function(res, rej) {
    openRequest.onerror = function(ev) {
      return rej(ev);
    };
    openRequest.onsuccess = function() {
      res(openRequest.result);
    };
  });
}
function writeMessage$1(db, readerUuid, messageJson) {
  var time = (/* @__PURE__ */ new Date()).getTime();
  var writeObject = {
    uuid: readerUuid,
    time,
    data: messageJson
  };
  var tx = db.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  return new Promise(function(res, rej) {
    tx.oncomplete = function() {
      return res();
    };
    tx.onerror = function(ev) {
      return rej(ev);
    };
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
    commitIndexedDBTransaction(tx);
  });
}
function getAllMessages$1(db) {
  var tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function(res) {
    objectStore.openCursor().onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        ret.push(cursor2.value);
        cursor2["continue"]();
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function getMessagesHigherThan(db, lastCursorId) {
  var tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
  if (objectStore.getAll) {
    var getAllRequest = objectStore.getAll(keyRangeValue);
    return new Promise(function(res, rej) {
      getAllRequest.onerror = function(err) {
        return rej(err);
      };
      getAllRequest.onsuccess = function(e2) {
        res(e2.target.result);
      };
    });
  }
  function openCursor() {
    try {
      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e2) {
      return objectStore.openCursor();
    }
  }
  return new Promise(function(res, rej) {
    var openCursorRequest = openCursor();
    openCursorRequest.onerror = function(err) {
      return rej(err);
    };
    openCursorRequest.onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        if (cursor2.value.id < lastCursorId + 1) {
          cursor2["continue"](lastCursorId + 1);
        } else {
          ret.push(cursor2.value);
          cursor2["continue"]();
        }
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function removeMessagesById(channelState, ids) {
  if (channelState.closed) {
    return Promise.resolve([]);
  }
  var tx = channelState.db.transaction(OBJECT_STORE_ID, "readwrite", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  return Promise.all(ids.map(function(id) {
    var deleteRequest = objectStore["delete"](id);
    return new Promise(function(res) {
      deleteRequest.onsuccess = function() {
        return res();
      };
    });
  }));
}
function getOldMessages(db, ttl) {
  var olderThen = (/* @__PURE__ */ new Date()).getTime() - ttl;
  var tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function(res) {
    objectStore.openCursor().onsuccess = function(ev) {
      var cursor2 = ev.target.result;
      if (cursor2) {
        var msgObk = cursor2.value;
        if (msgObk.time < olderThen) {
          ret.push(msgObk);
          cursor2["continue"]();
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
        }
      } else {
        res(ret);
      }
    };
  });
}
function cleanOldMessages$1(channelState) {
  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function(tooOld) {
    return removeMessagesById(channelState, tooOld.map(function(msg) {
      return msg.id;
    }));
  });
}
function create$3(channelName, options2) {
  options2 = (0, _options$3.fillOptionsWithDefaults)(options2);
  return createDatabase(channelName).then(function(db) {
    var state = {
      closed: false,
      lastCursorId: 0,
      channelName,
      options: options2,
      uuid: (0, _util$6.randomToken)(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new _obliviousSet$3.ObliviousSet(options2.idb.ttl * 2),
      // ensures we do not read messages in parallel
      writeBlockPromise: _util$6.PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db
    };
    db.onclose = function() {
      state.closed = true;
      if (options2.idb.onclose)
        options2.idb.onclose();
    };
    _readLoop(state);
    return state;
  });
}
function _readLoop(state) {
  if (state.closed)
    return;
  readNewMessages(state).then(function() {
    return (0, _util$6.sleep)(state.options.idb.fallbackInterval);
  }).then(function() {
    return _readLoop(state);
  });
}
function _filterMessage$1(msgObj, state) {
  if (msgObj.uuid === state.uuid)
    return false;
  if (state.eMIs.has(msgObj.id))
    return false;
  if (msgObj.data.time < state.messagesCallbackTime)
    return false;
  return true;
}
function readNewMessages(state) {
  if (state.closed)
    return _util$6.PROMISE_RESOLVED_VOID;
  if (!state.messagesCallback)
    return _util$6.PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state.db, state.lastCursorId).then(function(newerMessages) {
    var useMessages = newerMessages.filter(function(msgObj) {
      return !!msgObj;
    }).map(function(msgObj) {
      if (msgObj.id > state.lastCursorId) {
        state.lastCursorId = msgObj.id;
      }
      return msgObj;
    }).filter(function(msgObj) {
      return _filterMessage$1(msgObj, state);
    }).sort(function(msgObjA, msgObjB) {
      return msgObjA.time - msgObjB.time;
    });
    useMessages.forEach(function(msgObj) {
      if (state.messagesCallback) {
        state.eMIs.add(msgObj.id);
        state.messagesCallback(msgObj.data);
      }
    });
    return _util$6.PROMISE_RESOLVED_VOID;
  });
}
function close$3(channelState) {
  channelState.closed = true;
  channelState.db.close();
}
function postMessage$3(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {
    return writeMessage$1(channelState.db, channelState.uuid, messageJson);
  }).then(function() {
    if ((0, _util$6.randomInt)(0, 10) === 0) {
      cleanOldMessages$1(channelState);
    }
  });
  return channelState.writeBlockPromise;
}
function onMessage$3(channelState, fn2, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn2;
  readNewMessages(channelState);
}
function canBeUsed$3() {
  return !!getIdb();
}
function averageResponseTime$3(options2) {
  return options2.idb.fallbackInterval * 2;
}
var IndexedDBMethod = {
  create: create$3,
  close: close$3,
  onMessage: onMessage$3,
  postMessage: postMessage$3,
  canBeUsed: canBeUsed$3,
  type: type$3,
  averageResponseTime: averageResponseTime$3,
  microSeconds: microSeconds$3
};
indexedDb.IndexedDBMethod = IndexedDBMethod;
var localstorage = {};
Object.defineProperty(localstorage, "__esModule", {
  value: true
});
localstorage.LocalstorageMethod = void 0;
localstorage.addStorageEventListener = addStorageEventListener;
localstorage.averageResponseTime = averageResponseTime$2;
localstorage.canBeUsed = canBeUsed$2;
localstorage.close = close$2;
localstorage.create = create$2;
localstorage.getLocalStorage = getLocalStorage;
localstorage.microSeconds = void 0;
localstorage.onMessage = onMessage$2;
localstorage.postMessage = postMessage$2;
localstorage.removeStorageEventListener = removeStorageEventListener;
localstorage.storageKey = storageKey;
localstorage.type = void 0;
var _obliviousSet$2 = require$$11;
var _options$2 = options;
var _util$5 = util$2;
var microSeconds$2 = _util$5.microSeconds;
localstorage.microSeconds = microSeconds$2;
var KEY_PREFIX = "pubkey.broadcastChannel-";
var type$2 = "localstorage";
localstorage.type = type$2;
function getLocalStorage() {
  var localStorage2;
  if (typeof window === "undefined")
    return null;
  try {
    localStorage2 = window.localStorage;
    localStorage2 = window["ie8-eventlistener/storage"] || window.localStorage;
  } catch (e2) {
  }
  return localStorage2;
}
function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}
function postMessage$2(channelState, messageJson) {
  return new Promise(function(res) {
    (0, _util$5.sleep)().then(function() {
      var key = storageKey(channelState.channelName);
      var writeObj = {
        token: (0, _util$5.randomToken)(),
        time: (/* @__PURE__ */ new Date()).getTime(),
        data: messageJson,
        uuid: channelState.uuid
      };
      var value = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value);
      var ev = document.createEvent("Event");
      ev.initEvent("storage", true, true);
      ev.key = key;
      ev.newValue = value;
      window.dispatchEvent(ev);
      res();
    });
  });
}
function addStorageEventListener(channelName, fn2) {
  var key = storageKey(channelName);
  var listener = function listener2(ev) {
    if (ev.key === key) {
      fn2(JSON.parse(ev.newValue));
    }
  };
  window.addEventListener("storage", listener);
  return listener;
}
function removeStorageEventListener(listener) {
  window.removeEventListener("storage", listener);
}
function create$2(channelName, options2) {
  options2 = (0, _options$2.fillOptionsWithDefaults)(options2);
  if (!canBeUsed$2()) {
    throw new Error("BroadcastChannel: localstorage cannot be used");
  }
  var uuid = (0, _util$5.randomToken)();
  var eMIs = new _obliviousSet$2.ObliviousSet(options2.localstorage.removeTimeout);
  var state = {
    channelName,
    uuid,
    eMIs
    // emittedMessagesIds
  };
  state.listener = addStorageEventListener(channelName, function(msgObj) {
    if (!state.messagesCallback)
      return;
    if (msgObj.uuid === uuid)
      return;
    if (!msgObj.token || eMIs.has(msgObj.token))
      return;
    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime)
      return;
    eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  return state;
}
function close$2(channelState) {
  removeStorageEventListener(channelState.listener);
}
function onMessage$2(channelState, fn2, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn2;
}
function canBeUsed$2() {
  var ls = getLocalStorage();
  if (!ls)
    return false;
  try {
    var key = "__broadcastchannel_check";
    ls.setItem(key, "works");
    ls.removeItem(key);
  } catch (e2) {
    return false;
  }
  return true;
}
function averageResponseTime$2() {
  var defaultTime = 120;
  var userAgent = navigator.userAgent.toLowerCase();
  if (userAgent.includes("safari") && !userAgent.includes("chrome")) {
    return defaultTime * 2;
  }
  return defaultTime;
}
var LocalstorageMethod = {
  create: create$2,
  close: close$2,
  onMessage: onMessage$2,
  postMessage: postMessage$2,
  canBeUsed: canBeUsed$2,
  type: type$2,
  averageResponseTime: averageResponseTime$2,
  microSeconds: microSeconds$2
};
localstorage.LocalstorageMethod = LocalstorageMethod;
var simulate = {};
Object.defineProperty(simulate, "__esModule", {
  value: true
});
simulate.SimulateMethod = void 0;
simulate.averageResponseTime = averageResponseTime$1;
simulate.canBeUsed = canBeUsed$1;
simulate.close = close$1;
simulate.create = create$1;
simulate.microSeconds = void 0;
simulate.onMessage = onMessage$1;
simulate.postMessage = postMessage$1;
simulate.type = void 0;
var _util$4 = util$2;
var microSeconds$1 = _util$4.microSeconds;
simulate.microSeconds = microSeconds$1;
var type$1 = "simulate";
simulate.type = type$1;
var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
function create$1(channelName) {
  var state = {
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state);
  return state;
}
function close$1(channelState) {
  SIMULATE_CHANNELS["delete"](channelState);
}
function postMessage$1(channelState, messageJson) {
  return new Promise(function(res) {
    return setTimeout(function() {
      var channelArray = Array.from(SIMULATE_CHANNELS);
      channelArray.filter(function(channel) {
        return channel.name === channelState.name;
      }).filter(function(channel) {
        return channel !== channelState;
      }).filter(function(channel) {
        return !!channel.messagesCallback;
      }).forEach(function(channel) {
        return channel.messagesCallback(messageJson);
      });
      res();
    }, 5);
  });
}
function onMessage$1(channelState, fn2) {
  channelState.messagesCallback = fn2;
}
function canBeUsed$1() {
  return true;
}
function averageResponseTime$1() {
  return 5;
}
var SimulateMethod = {
  create: create$1,
  close: close$1,
  onMessage: onMessage$1,
  postMessage: postMessage$1,
  canBeUsed: canBeUsed$1,
  type: type$1,
  averageResponseTime: averageResponseTime$1,
  microSeconds: microSeconds$1
};
simulate.SimulateMethod = SimulateMethod;
var node = {};
var interopRequireDefault = { exports: {} };
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
var regeneratorRuntime$1 = { exports: {} };
var hasRequiredRegeneratorRuntime;
function requireRegeneratorRuntime() {
  if (hasRequiredRegeneratorRuntime)
    return regeneratorRuntime$1.exports;
  hasRequiredRegeneratorRuntime = 1;
  (function(module) {
    var _typeof2 = _typeofExports["default"];
    function _regeneratorRuntime() {
      module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define2(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context2)
        }), generator;
      }
      function tryCatch(fn2, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn2.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value = result.value;
            return value && "object" == _typeof2(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function value(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context2) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return {
              value: void 0,
              done: true
            };
          }
          for (context2.method = method, context2.arg = arg; ; ) {
            var delegate = context2.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context2);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context2.method)
              context2.sent = context2._sent = context2.arg;
            else if ("throw" === context2.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context2.arg;
              context2.dispatchException(context2.arg);
            } else
              "return" === context2.method && context2.abrupt("return", context2.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context2);
            if ("normal" === record.type) {
              if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context2.done
              };
            }
            "throw" === record.type && (state = "completed", context2.method = "throw", context2.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context2) {
        var methodName = context2.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context2.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method) || "return" !== methodName && (context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context2.arg);
        if ("throw" === record.type)
          return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context2[delegate.resultName] = info.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable || "" === iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i2 = -1, next = function next2() {
              for (; ++i2 < iterable.length; )
                if (hasOwn.call(iterable, i2))
                  return next2.value = iterable[i2], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        throw new TypeError(_typeof2(iterable) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
      }), define(Gp, "toString", function() {
        return "[object Generator]";
      }), exports.keys = function(val) {
        var object2 = Object(val), keys = [];
        for (var key in object2)
          keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object2)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context2 = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type2, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type2 || "continue" === type2) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type2, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports;
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);
  return regeneratorRuntime$1.exports;
}
var regenerator;
var hasRequiredRegenerator;
function requireRegenerator() {
  if (hasRequiredRegenerator)
    return regenerator;
  hasRequiredRegenerator = 1;
  var runtime = requireRegeneratorRuntime()();
  regenerator = runtime;
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
  return regenerator;
}
var asyncToGenerator = { exports: {} };
var hasRequiredAsyncToGenerator;
function requireAsyncToGenerator() {
  if (hasRequiredAsyncToGenerator)
    return asyncToGenerator.exports;
  hasRequiredAsyncToGenerator = 1;
  (function(module) {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn2) {
      return function() {
        var self2 = this, args2 = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn2.apply(self2, args2);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(asyncToGenerator);
  return asyncToGenerator.exports;
}
var dist$1 = {};
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3)
    return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn2, context2, once) {
      this.fn = fn2;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context2, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
        ee2[i2] = handlers[i2].fn;
      }
      return ee2;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args2, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args2 = new Array(len - 1); i2 < len; i2++) {
          args2[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args2);
      } else {
        var length = listeners.length, j2;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args2)
                for (j2 = 1, args2 = new Array(len - 1); j2 < len; j2++) {
                  args2[j2 - 1] = arguments[j2];
                }
              listeners[i2].fn.apply(listeners[i2].context, args2);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on2(event, fn2, context2) {
      return addListener(this, event, fn2, context2, false);
    };
    EventEmitter.prototype.once = function once(event, fn2, context2) {
      return addListener(this, event, fn2, context2, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn2, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn2 || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
            events.push(listeners[i2]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    {
      module.exports = EventEmitter;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var pTimeout = { exports: {} };
var pFinally;
var hasRequiredPFinally;
function requirePFinally() {
  if (hasRequiredPFinally)
    return pFinally;
  hasRequiredPFinally = 1;
  pFinally = (promise, onFinally) => {
    onFinally = onFinally || (() => {
    });
    return promise.then(
      (val) => new Promise((resolve) => {
        resolve(onFinally());
      }).then(() => val),
      (err) => new Promise((resolve) => {
        resolve(onFinally());
      }).then(() => {
        throw err;
      })
    );
  };
  return pFinally;
}
var hasRequiredPTimeout;
function requirePTimeout() {
  if (hasRequiredPTimeout)
    return pTimeout.exports;
  hasRequiredPTimeout = 1;
  const pFinally2 = requirePFinally();
  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  const pTimeout$1 = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || milliseconds < 0) {
      throw new TypeError("Expected `milliseconds` to be a positive number");
    }
    if (milliseconds === Infinity) {
      resolve(promise);
      return;
    }
    const timer2 = setTimeout(() => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    pFinally2(
      // eslint-disable-next-line promise/prefer-await-to-then
      promise.then(resolve, reject),
      () => {
        clearTimeout(timer2);
      }
    );
  });
  pTimeout.exports = pTimeout$1;
  pTimeout.exports.default = pTimeout$1;
  pTimeout.exports.TimeoutError = TimeoutError;
  return pTimeout.exports;
}
var priorityQueue = {};
var lowerBound = {};
var hasRequiredLowerBound;
function requireLowerBound() {
  if (hasRequiredLowerBound)
    return lowerBound;
  hasRequiredLowerBound = 1;
  Object.defineProperty(lowerBound, "__esModule", { value: true });
  function lowerBound$1(array2, value, comparator) {
    let first2 = 0;
    let count2 = array2.length;
    while (count2 > 0) {
      const step = count2 / 2 | 0;
      let it2 = first2 + step;
      if (comparator(array2[it2], value) <= 0) {
        first2 = ++it2;
        count2 -= step + 1;
      } else {
        count2 = step;
      }
    }
    return first2;
  }
  lowerBound.default = lowerBound$1;
  return lowerBound;
}
var hasRequiredPriorityQueue;
function requirePriorityQueue() {
  if (hasRequiredPriorityQueue)
    return priorityQueue;
  hasRequiredPriorityQueue = 1;
  Object.defineProperty(priorityQueue, "__esModule", { value: true });
  const lower_bound_1 = requireLowerBound();
  class PriorityQueue {
    constructor() {
      this._queue = [];
    }
    enqueue(run, options2) {
      options2 = Object.assign({ priority: 0 }, options2);
      const element2 = {
        priority: options2.priority,
        run
      };
      if (this.size && this._queue[this.size - 1].priority >= options2.priority) {
        this._queue.push(element2);
        return;
      }
      const index = lower_bound_1.default(this._queue, element2, (a2, b2) => b2.priority - a2.priority);
      this._queue.splice(index, 0, element2);
    }
    dequeue() {
      const item = this._queue.shift();
      return item === null || item === void 0 ? void 0 : item.run;
    }
    filter(options2) {
      return this._queue.filter((element2) => element2.priority === options2.priority).map((element2) => element2.run);
    }
    get size() {
      return this._queue.length;
    }
  }
  priorityQueue.default = PriorityQueue;
  return priorityQueue;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist)
    return dist$1;
  hasRequiredDist = 1;
  Object.defineProperty(dist$1, "__esModule", { value: true });
  const EventEmitter = requireEventemitter3();
  const p_timeout_1 = requirePTimeout();
  const priority_queue_1 = requirePriorityQueue();
  const empty2 = () => {
  };
  const timeoutError = new p_timeout_1.TimeoutError();
  class PQueue extends EventEmitter {
    constructor(options2) {
      var _a, _b, _c, _d;
      super();
      this._intervalCount = 0;
      this._intervalEnd = 0;
      this._pendingCount = 0;
      this._resolveEmpty = empty2;
      this._resolveIdle = empty2;
      options2 = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options2);
      if (!(typeof options2.intervalCap === "number" && options2.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options2.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options2.intervalCap})`);
      }
      if (options2.interval === void 0 || !(Number.isFinite(options2.interval) && options2.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options2.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options2.interval})`);
      }
      this._carryoverConcurrencyCount = options2.carryoverConcurrencyCount;
      this._isIntervalIgnored = options2.intervalCap === Infinity || options2.interval === 0;
      this._intervalCap = options2.intervalCap;
      this._interval = options2.interval;
      this._queue = new options2.queueClass();
      this._queueClass = options2.queueClass;
      this.concurrency = options2.concurrency;
      this._timeout = options2.timeout;
      this._throwOnTimeout = options2.throwOnTimeout === true;
      this._isPaused = options2.autoStart === false;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--;
      this._tryToStartAnother();
      this.emit("next");
    }
    _resolvePromises() {
      this._resolveEmpty();
      this._resolveEmpty = empty2;
      if (this._pendingCount === 0) {
        this._resolveIdle();
        this._resolveIdle = empty2;
        this.emit("idle");
      }
    }
    _onResumeInterval() {
      this._onInterval();
      this._initializeIntervalIfNeeded();
      this._timeoutId = void 0;
    }
    _isIntervalPaused() {
      const now2 = Date.now();
      if (this._intervalId === void 0) {
        const delay2 = this._intervalEnd - now2;
        if (delay2 < 0) {
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        } else {
          if (this._timeoutId === void 0) {
            this._timeoutId = setTimeout(() => {
              this._onResumeInterval();
            }, delay2);
          }
          return true;
        }
      }
      return false;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0) {
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }
        this._intervalId = void 0;
        this._resolvePromises();
        return false;
      }
      if (!this._isPaused) {
        const canInitializeInterval = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          const job = this._queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit("active");
          job();
          if (canInitializeInterval) {
            this._initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
    _initializeIntervalIfNeeded() {
      if (this._isIntervalIgnored || this._intervalId !== void 0) {
        return;
      }
      this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval);
      this._intervalEnd = Date.now() + this._interval;
    }
    _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = void 0;
      }
      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      this._processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    _processQueue() {
      while (this._tryToStartAnother()) {
      }
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      this._concurrency = newConcurrency;
      this._processQueue();
    }
    /**
    Adds a sync or async task to the queue. Always returns a promise.
    */
    async add(fn2, options2 = {}) {
      return new Promise((resolve, reject) => {
        const run = async () => {
          this._pendingCount++;
          this._intervalCount++;
          try {
            const operation = this._timeout === void 0 && options2.timeout === void 0 ? fn2() : p_timeout_1.default(Promise.resolve(fn2()), options2.timeout === void 0 ? this._timeout : options2.timeout, () => {
              if (options2.throwOnTimeout === void 0 ? this._throwOnTimeout : options2.throwOnTimeout) {
                reject(timeoutError);
              }
              return void 0;
            });
            resolve(await operation);
          } catch (error) {
            reject(error);
          }
          this._next();
        };
        this._queue.enqueue(run, options2);
        this._tryToStartAnother();
        this.emit("add");
      });
    }
    /**
    	    Same as `.add()`, but accepts an array of sync or async functions.
    
    	    @returns A promise that resolves when all functions are resolved.
    	    */
    async addAll(functions, options2) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options2)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this._processQueue();
      return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      this._isPaused = true;
    }
    /**
    Clear the queue.
    */
    clear() {
      this._queue = new this._queueClass();
    }
    /**
    	    Can be called multiple times. Useful if you for example add additional items at a later time.
    
    	    @returns A promise that settles when the queue becomes empty.
    	    */
    async onEmpty() {
      if (this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveEmpty;
        this._resolveEmpty = () => {
          existingResolve();
          resolve();
        };
      });
    }
    /**
    	    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
    	    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    	    */
    async onIdle() {
      if (this._pendingCount === 0 && this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveIdle;
        this._resolveIdle = () => {
          existingResolve();
          resolve();
        };
      });
    }
    /**
    Size of the queue.
    */
    get size() {
      return this._queue.size;
    }
    /**
    	    Size of the queue, filtered by the given options.
    
    	    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    	    */
    sizeBy(options2) {
      return this._queue.filter(options2).length;
    }
    /**
    Number of pending promises.
    */
    get pending() {
      return this._pendingCount;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    /**
    Set the timeout for future operations.
    */
    set timeout(milliseconds) {
      this._timeout = milliseconds;
    }
  }
  dist$1.default = PQueue;
  return dist$1;
}
function addBrowser(fn2) {
  if (typeof WorkerGlobalScope === "function" && self instanceof WorkerGlobalScope) {
    var oldClose = self.close.bind(self);
    self.close = function() {
      fn2();
      return oldClose();
    };
  } else {
    if (typeof window.addEventListener !== "function") {
      return;
    }
    window.addEventListener("beforeunload", function() {
      fn2();
    }, true);
    window.addEventListener("unload", function() {
      fn2();
    }, true);
  }
}
function addNode(fn2) {
  process.on("exit", function() {
    return fn2();
  });
  process.on("beforeExit", function() {
    return fn2().then(function() {
      return process.exit();
    });
  });
  process.on("SIGINT", function() {
    return fn2().then(function() {
      return process.exit();
    });
  });
  process.on("uncaughtException", function(err) {
    return fn2().then(function() {
      console.trace(err);
      process.exit(101);
    });
  });
}
var isNode = Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var USE_METHOD = isNode ? addNode : addBrowser;
var LISTENERS = /* @__PURE__ */ new Set();
var startedListening = false;
function startListening() {
  if (startedListening) {
    return;
  }
  startedListening = true;
  USE_METHOD(runAll);
}
function add(fn2) {
  startListening();
  if (typeof fn2 !== "function") {
    throw new Error("Listener is no function");
  }
  LISTENERS.add(fn2);
  var addReturn = {
    remove: function remove() {
      return LISTENERS["delete"](fn2);
    },
    run: function run() {
      LISTENERS["delete"](fn2);
      return fn2();
    }
  };
  return addReturn;
}
function runAll() {
  var promises = [];
  LISTENERS.forEach(function(fn2) {
    promises.push(fn2());
    LISTENERS["delete"](fn2);
  });
  return Promise.all(promises);
}
function removeAll() {
  LISTENERS.clear();
}
function getSize() {
  return LISTENERS.size;
}
const es$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add,
  getSize,
  removeAll,
  runAll
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(es$2);
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(node, "__esModule", {
  value: true
});
node.TMP_FOLDER_BASE = void 0;
node._filterMessage = _filterMessage;
node.averageResponseTime = averageResponseTime;
node.canBeUsed = canBeUsed;
node.cleanOldMessages = cleanOldMessages;
node.cleanPipeName = cleanPipeName;
node.clearNodeFolder = clearNodeFolder$1;
node.close = close;
node.countChannelFolders = countChannelFolders;
node.create = create;
node.createSocketEventEmitter = createSocketEventEmitter;
node.createSocketInfoFile = createSocketInfoFile;
node.emitOverFastPath = emitOverFastPath;
node.ensureFoldersExist = ensureFoldersExist;
node.getAllMessages = getAllMessages;
node.getPaths = getPaths;
node.getReadersUuids = getReadersUuids;
node.getSingleMessage = getSingleMessage;
node.handleMessagePing = handleMessagePing;
node.messagePath = messagePath;
node.microSeconds = microSeconds;
node.onMessage = onMessage;
node.openClientConnection = openClientConnection;
node.postMessage = postMessage;
node.readMessage = readMessage;
node.refreshReaderClients = refreshReaderClients;
node.socketInfoPath = socketInfoPath;
node.socketPath = socketPath;
node.type = void 0;
node.writeMessage = writeMessage;
var _regenerator = _interopRequireDefault$5(requireRegenerator());
var _asyncToGenerator2 = _interopRequireDefault$5(requireAsyncToGenerator());
var _util$3 = _interopRequireDefault$5(require$$3);
var _fs = _interopRequireDefault$5(fs);
var _crypto = _interopRequireDefault$5(require$$5);
var _os = _interopRequireDefault$5(require$$6);
var _events = _interopRequireDefault$5(require$$7);
var _net = _interopRequireDefault$5(require$$8);
var _path = _interopRequireDefault$5(require$$9);
var _pQueue = _interopRequireDefault$5(requireDist());
var _unload$1 = require$$0$1;
var _options$1 = options;
var _util2 = util$2;
var _obliviousSet$1 = require$$11;
function cleanPipeName(str) {
  if (process.platform === "win32" && !str.startsWith("\\\\.\\pipe\\")) {
    str = str.replace(/^\//, "");
    str = str.replace(/\//g, "-");
    return "\\\\.\\pipe\\" + str;
  } else {
    return str;
  }
}
var mkdir = _util$3["default"].promisify(_fs["default"].mkdir);
var writeFile = _util$3["default"].promisify(_fs["default"].writeFile);
var readFile = _util$3["default"].promisify(_fs["default"].readFile);
var unlink = _util$3["default"].promisify(_fs["default"].unlink);
var readdir = _util$3["default"].promisify(_fs["default"].readdir);
var chmod = _util$3["default"].promisify(_fs["default"].chmod);
var rmDir = _util$3["default"].promisify(_fs["default"].rm);
var removeDir = /* @__PURE__ */ function() {
  var _ref = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee(p2) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return rmDir(p2, {
              recursive: true
            });
          case 3:
            return _context.abrupt("return", _context.sent);
          case 6:
            _context.prev = 6;
            _context.t0 = _context["catch"](0);
            if (!(_context.t0.code !== "ENOENT")) {
              _context.next = 10;
              break;
            }
            throw _context.t0;
          case 10:
          case "end":
            return _context.stop();
        }
    }, _callee, null, [[0, 6]]);
  }));
  return function removeDir2(_x) {
    return _ref.apply(this, arguments);
  };
}();
var OTHER_INSTANCES = {};
var TMP_FOLDER_NAME = "pubkey.bc";
var TMP_FOLDER_BASE = _path["default"].join(_os["default"].tmpdir(), TMP_FOLDER_NAME);
node.TMP_FOLDER_BASE = TMP_FOLDER_BASE;
var getPathsCache = /* @__PURE__ */ new Map();
function getPaths(channelName) {
  if (!getPathsCache.has(channelName)) {
    var channelHash = _crypto["default"].createHash("sha256").update(channelName).digest("hex");
    var channelFolder = "A" + channelHash.substring(0, 20);
    var channelPathBase = _path["default"].join(TMP_FOLDER_BASE, channelFolder);
    var folderPathReaders = _path["default"].join(channelPathBase, "rdrs");
    var folderPathMessages = _path["default"].join(channelPathBase, "msgs");
    var ret = {
      channelBase: channelPathBase,
      readers: folderPathReaders,
      messages: folderPathMessages
    };
    getPathsCache.set(channelName, ret);
    return ret;
  }
  return getPathsCache.get(channelName);
}
var ENSURE_BASE_FOLDER_EXISTS_PROMISE = null;
function ensureBaseFolderExists() {
  return _ensureBaseFolderExists.apply(this, arguments);
}
function _ensureBaseFolderExists() {
  _ensureBaseFolderExists = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee4() {
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1)
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!ENSURE_BASE_FOLDER_EXISTS_PROMISE) {
              ENSURE_BASE_FOLDER_EXISTS_PROMISE = mkdir(TMP_FOLDER_BASE)["catch"](function() {
                return null;
              });
            }
            return _context4.abrupt("return", ENSURE_BASE_FOLDER_EXISTS_PROMISE);
          case 2:
          case "end":
            return _context4.stop();
        }
    }, _callee4);
  }));
  return _ensureBaseFolderExists.apply(this, arguments);
}
function ensureFoldersExist(_x2, _x3) {
  return _ensureFoldersExist.apply(this, arguments);
}
function _ensureFoldersExist() {
  _ensureFoldersExist = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee5(channelName, paths) {
    var chmodValue;
    return _regenerator["default"].wrap(function _callee5$(_context5) {
      while (1)
        switch (_context5.prev = _context5.next) {
          case 0:
            paths = paths || getPaths(channelName);
            _context5.next = 3;
            return ensureBaseFolderExists();
          case 3:
            _context5.next = 5;
            return mkdir(paths.channelBase)["catch"](function() {
              return null;
            });
          case 5:
            _context5.next = 7;
            return Promise.all([mkdir(paths.readers)["catch"](function() {
              return null;
            }), mkdir(paths.messages)["catch"](function() {
              return null;
            })]);
          case 7:
            chmodValue = "777";
            _context5.next = 10;
            return Promise.all([chmod(paths.channelBase, chmodValue), chmod(paths.readers, chmodValue), chmod(paths.messages, chmodValue)])["catch"](function() {
              return null;
            });
          case 10:
          case "end":
            return _context5.stop();
        }
    }, _callee5);
  }));
  return _ensureFoldersExist.apply(this, arguments);
}
function clearNodeFolder$1() {
  return _clearNodeFolder.apply(this, arguments);
}
function _clearNodeFolder() {
  _clearNodeFolder = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee6() {
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1)
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(!TMP_FOLDER_BASE || TMP_FOLDER_BASE === "" || TMP_FOLDER_BASE === "/")) {
              _context6.next = 2;
              break;
            }
            throw new Error("BroadcastChannel.clearNodeFolder(): path is wrong");
          case 2:
            ENSURE_BASE_FOLDER_EXISTS_PROMISE = null;
            _context6.next = 5;
            return removeDir(TMP_FOLDER_BASE);
          case 5:
            ENSURE_BASE_FOLDER_EXISTS_PROMISE = null;
            return _context6.abrupt("return", true);
          case 7:
          case "end":
            return _context6.stop();
        }
    }, _callee6);
  }));
  return _clearNodeFolder.apply(this, arguments);
}
function socketPath(channelName, readerUuid, paths) {
  paths = paths || getPaths(channelName);
  var socketPath2 = _path["default"].join(paths.readers, readerUuid + ".s");
  return cleanPipeName(socketPath2);
}
function socketInfoPath(channelName, readerUuid, paths) {
  paths = paths || getPaths(channelName);
  return _path["default"].join(paths.readers, readerUuid + ".json");
}
function createSocketInfoFile(channelName, readerUuid, paths) {
  var pathToFile = socketInfoPath(channelName, readerUuid, paths);
  return writeFile(pathToFile, JSON.stringify({
    time: microSeconds()
  })).then(function() {
    return pathToFile;
  });
}
function countChannelFolders() {
  return _countChannelFolders.apply(this, arguments);
}
function _countChannelFolders() {
  _countChannelFolders = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee7() {
    var folders;
    return _regenerator["default"].wrap(function _callee7$(_context7) {
      while (1)
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return ensureBaseFolderExists();
          case 2:
            _context7.next = 4;
            return readdir(TMP_FOLDER_BASE);
          case 4:
            folders = _context7.sent;
            return _context7.abrupt("return", folders.length);
          case 6:
          case "end":
            return _context7.stop();
        }
    }, _callee7);
  }));
  return _countChannelFolders.apply(this, arguments);
}
function connectionError(_x4) {
  return _connectionError.apply(this, arguments);
}
function _connectionError() {
  _connectionError = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee8(originalError) {
    var count2, addObj, text;
    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1)
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return countChannelFolders();
          case 2:
            count2 = _context8.sent;
            if (!(count2 < 30)) {
              _context8.next = 5;
              break;
            }
            return _context8.abrupt("return", originalError);
          case 5:
            addObj = {};
            Object.entries(originalError).forEach(function(_ref4) {
              var k2 = _ref4[0], v2 = _ref4[1];
              return addObj[k2] = v2;
            });
            text = "BroadcastChannel.create(): error: This might happen if you have created to many channels, like when you use BroadcastChannel in unit-tests.Try using BroadcastChannel.clearNodeFolder() to clear the tmp-folder before each test.See https://github.com/pubkey/broadcast-channel#clear-tmp-folder";
            return _context8.abrupt("return", new Error(text + ": " + JSON.stringify(addObj, null, 2)));
          case 9:
          case "end":
            return _context8.stop();
        }
    }, _callee8);
  }));
  return _connectionError.apply(this, arguments);
}
function createSocketEventEmitter(_x5, _x6, _x7) {
  return _createSocketEventEmitter.apply(this, arguments);
}
function _createSocketEventEmitter() {
  _createSocketEventEmitter = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee11(channelName, readerUuid, paths) {
    var pathToSocket, emitter, server;
    return _regenerator["default"].wrap(function _callee11$(_context11) {
      while (1)
        switch (_context11.prev = _context11.next) {
          case 0:
            pathToSocket = socketPath(channelName, readerUuid, paths);
            emitter = new _events["default"].EventEmitter();
            server = _net["default"].createServer(function(stream) {
              stream.on("end", function() {
              });
              stream.on("data", function(msg) {
                emitter.emit("data", msg.toString());
              });
            });
            _context11.next = 5;
            return new Promise(function(resolve, reject) {
              server.on("error", /* @__PURE__ */ function() {
                var _ref5 = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee9(err) {
                  var useErr;
                  return _regenerator["default"].wrap(function _callee9$(_context9) {
                    while (1)
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          _context9.next = 2;
                          return connectionError(err);
                        case 2:
                          useErr = _context9.sent;
                          reject(useErr);
                        case 4:
                        case "end":
                          return _context9.stop();
                      }
                  }, _callee9);
                }));
                return function(_x27) {
                  return _ref5.apply(this, arguments);
                };
              }());
              server.listen(pathToSocket, /* @__PURE__ */ function() {
                var _ref6 = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee10(err, res) {
                  var useErr;
                  return _regenerator["default"].wrap(function _callee10$(_context10) {
                    while (1)
                      switch (_context10.prev = _context10.next) {
                        case 0:
                          if (!err) {
                            _context10.next = 7;
                            break;
                          }
                          _context10.next = 3;
                          return connectionError(err);
                        case 3:
                          useErr = _context10.sent;
                          reject(useErr);
                          _context10.next = 8;
                          break;
                        case 7:
                          resolve(res);
                        case 8:
                        case "end":
                          return _context10.stop();
                      }
                  }, _callee10);
                }));
                return function(_x28, _x29) {
                  return _ref6.apply(this, arguments);
                };
              }());
            });
          case 5:
            return _context11.abrupt("return", {
              path: pathToSocket,
              emitter,
              server
            });
          case 6:
          case "end":
            return _context11.stop();
        }
    }, _callee11);
  }));
  return _createSocketEventEmitter.apply(this, arguments);
}
function openClientConnection(_x8, _x9) {
  return _openClientConnection.apply(this, arguments);
}
function _openClientConnection() {
  _openClientConnection = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee12(channelName, readerUuid) {
    var pathToSocket, client;
    return _regenerator["default"].wrap(function _callee12$(_context12) {
      while (1)
        switch (_context12.prev = _context12.next) {
          case 0:
            pathToSocket = socketPath(channelName, readerUuid);
            client = new _net["default"].Socket();
            return _context12.abrupt("return", new Promise(function(res, rej) {
              client.connect(pathToSocket, function() {
                return res(client);
              });
              client.on("error", function(err) {
                return rej(err);
              });
            }));
          case 3:
          case "end":
            return _context12.stop();
        }
    }, _callee12);
  }));
  return _openClientConnection.apply(this, arguments);
}
function writeMessage(channelName, readerUuid, messageJson, paths) {
  paths = paths || getPaths(channelName);
  var time = microSeconds();
  var writeObject = {
    uuid: readerUuid,
    time,
    data: messageJson
  };
  var token = (0, _util2.randomToken)();
  var fileName = time + "_" + readerUuid + "_" + token + ".json";
  var msgPath = _path["default"].join(paths.messages, fileName);
  return writeFile(msgPath, JSON.stringify(writeObject)).then(function() {
    return {
      time,
      uuid: readerUuid,
      token,
      path: msgPath
    };
  });
}
function getReadersUuids(_x10, _x11) {
  return _getReadersUuids.apply(this, arguments);
}
function _getReadersUuids() {
  _getReadersUuids = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee13(channelName, paths) {
    var readersPath, files;
    return _regenerator["default"].wrap(function _callee13$(_context13) {
      while (1)
        switch (_context13.prev = _context13.next) {
          case 0:
            paths = paths || getPaths(channelName);
            readersPath = paths.readers;
            _context13.next = 4;
            return readdir(readersPath);
          case 4:
            files = _context13.sent;
            return _context13.abrupt("return", files.map(function(file) {
              return file.split(".");
            }).filter(function(split2) {
              return split2[1] === "json";
            }).map(function(split2) {
              return split2[0];
            }));
          case 6:
          case "end":
            return _context13.stop();
        }
    }, _callee13);
  }));
  return _getReadersUuids.apply(this, arguments);
}
function messagePath(_x12, _x13, _x14, _x15) {
  return _messagePath.apply(this, arguments);
}
function _messagePath() {
  _messagePath = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee14(channelName, time, token, writerUuid) {
    var fileName;
    return _regenerator["default"].wrap(function _callee14$(_context14) {
      while (1)
        switch (_context14.prev = _context14.next) {
          case 0:
            fileName = time + "_" + writerUuid + "_" + token + ".json";
            return _context14.abrupt("return", _path["default"].join(getPaths(channelName).messages, fileName));
          case 2:
          case "end":
            return _context14.stop();
        }
    }, _callee14);
  }));
  return _messagePath.apply(this, arguments);
}
function getAllMessages(_x16, _x17) {
  return _getAllMessages.apply(this, arguments);
}
function _getAllMessages() {
  _getAllMessages = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee15(channelName, paths) {
    var messagesPath, files;
    return _regenerator["default"].wrap(function _callee15$(_context15) {
      while (1)
        switch (_context15.prev = _context15.next) {
          case 0:
            paths = paths || getPaths(channelName);
            messagesPath = paths.messages;
            _context15.next = 4;
            return readdir(messagesPath);
          case 4:
            files = _context15.sent;
            return _context15.abrupt("return", files.map(function(file) {
              var fileName = file.split(".")[0];
              var split2 = fileName.split("_");
              return {
                path: _path["default"].join(messagesPath, file),
                time: parseInt(split2[0]),
                senderUuid: split2[1],
                token: split2[2]
              };
            }));
          case 6:
          case "end":
            return _context15.stop();
        }
    }, _callee15);
  }));
  return _getAllMessages.apply(this, arguments);
}
function getSingleMessage(channelName, msgObj, paths) {
  paths = paths || getPaths(channelName);
  return {
    path: _path["default"].join(paths.messages, msgObj.t + "_" + msgObj.u + "_" + msgObj.to + ".json"),
    time: msgObj.t,
    senderUuid: msgObj.u,
    token: msgObj.to
  };
}
function readMessage(messageObj) {
  return readFile(messageObj.path, "utf8").then(function(content) {
    return JSON.parse(content);
  });
}
function cleanOldMessages(_x18, _x19) {
  return _cleanOldMessages.apply(this, arguments);
}
function _cleanOldMessages() {
  _cleanOldMessages = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee16(messageObjects, ttl) {
    var olderThan;
    return _regenerator["default"].wrap(function _callee16$(_context16) {
      while (1)
        switch (_context16.prev = _context16.next) {
          case 0:
            olderThan = microSeconds() - ttl * 1e3;
            _context16.next = 3;
            return Promise.all(messageObjects.filter(function(obj) {
              return obj.time < olderThan;
            }).map(function(obj) {
              return unlink(obj.path)["catch"](function() {
                return null;
              });
            }));
          case 3:
          case "end":
            return _context16.stop();
        }
    }, _callee16);
  }));
  return _cleanOldMessages.apply(this, arguments);
}
var type = "node";
node.type = type;
function create(_x20) {
  return _create.apply(this, arguments);
}
function _create() {
  _create = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee17(channelName) {
    var options2, time, paths, ensureFolderExistsPromise, uuid, state, _yield$Promise$all, socketEE, infoFilePath, _args17 = arguments;
    return _regenerator["default"].wrap(function _callee17$(_context17) {
      while (1)
        switch (_context17.prev = _context17.next) {
          case 0:
            options2 = _args17.length > 1 && _args17[1] !== void 0 ? _args17[1] : {};
            options2 = (0, _options$1.fillOptionsWithDefaults)(options2);
            time = microSeconds();
            paths = getPaths(channelName);
            ensureFolderExistsPromise = ensureFoldersExist(channelName, paths);
            uuid = (0, _util2.randomToken)();
            state = {
              time,
              channelName,
              options: options2,
              uuid,
              paths,
              // contains all messages that have been emitted before
              emittedMessagesIds: new _obliviousSet$1.ObliviousSet(options2.node.ttl * 2),
              /**
               * Used to ensure we do not write too many files at once
               * which could throw an error.
               * Must always be smaller than options.node.maxParallelWrites
               */
              writeFileQueue: new _pQueue["default"]({
                concurrency: options2.node.maxParallelWrites
              }),
              messagesCallbackTime: null,
              messagesCallback: null,
              // ensures we do not read messages in parallel
              writeBlockPromise: _util2.PROMISE_RESOLVED_VOID,
              otherReaderClients: {},
              // ensure if process crashes, everything is cleaned up
              removeUnload: (0, _unload$1.add)(function() {
                return close(state);
              }),
              closed: false
            };
            if (!OTHER_INSTANCES[channelName])
              OTHER_INSTANCES[channelName] = [];
            OTHER_INSTANCES[channelName].push(state);
            _context17.next = 11;
            return ensureFolderExistsPromise;
          case 11:
            _context17.next = 13;
            return Promise.all([createSocketEventEmitter(channelName, uuid, paths), createSocketInfoFile(channelName, uuid, paths), refreshReaderClients(state)]);
          case 13:
            _yield$Promise$all = _context17.sent;
            socketEE = _yield$Promise$all[0];
            infoFilePath = _yield$Promise$all[1];
            state.socketEE = socketEE;
            state.infoFilePath = infoFilePath;
            socketEE.emitter.on("data", function(data) {
              var singleOnes = data.split("|");
              singleOnes.filter(function(single2) {
                return single2 !== "";
              }).forEach(function(single2) {
                try {
                  var obj = JSON.parse(single2);
                  handleMessagePing(state, obj);
                } catch (err) {
                  throw new Error("could not parse data: " + single2);
                }
              });
            });
            return _context17.abrupt("return", state);
          case 20:
          case "end":
            return _context17.stop();
        }
    }, _callee17);
  }));
  return _create.apply(this, arguments);
}
function _filterMessage(msgObj, state) {
  if (msgObj.senderUuid === state.uuid)
    return false;
  if (state.emittedMessagesIds.has(msgObj.token))
    return false;
  if (!state.messagesCallback)
    return false;
  if (msgObj.time < state.messagesCallbackTime)
    return false;
  if (msgObj.time < state.time)
    return false;
  state.emittedMessagesIds.add(msgObj.token);
  return true;
}
function handleMessagePing(_x21, _x22) {
  return _handleMessagePing.apply(this, arguments);
}
function _handleMessagePing() {
  _handleMessagePing = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee18(state, msgObj) {
    var messages2, useMessages;
    return _regenerator["default"].wrap(function _callee18$(_context18) {
      while (1)
        switch (_context18.prev = _context18.next) {
          case 0:
            if (state.messagesCallback) {
              _context18.next = 2;
              break;
            }
            return _context18.abrupt("return");
          case 2:
            if (msgObj) {
              _context18.next = 8;
              break;
            }
            _context18.next = 5;
            return getAllMessages(state.channelName, state.paths);
          case 5:
            messages2 = _context18.sent;
            _context18.next = 9;
            break;
          case 8:
            messages2 = [getSingleMessage(state.channelName, msgObj, state.paths)];
          case 9:
            useMessages = messages2.filter(function(msgObj2) {
              return _filterMessage(msgObj2, state);
            }).sort(function(msgObjA, msgObjB) {
              return msgObjA.time - msgObjB.time;
            });
            if (!(!useMessages.length || !state.messagesCallback)) {
              _context18.next = 12;
              break;
            }
            return _context18.abrupt("return");
          case 12:
            _context18.next = 14;
            return Promise.all(useMessages.map(function(msgObj2) {
              return readMessage(msgObj2).then(function(content) {
                return msgObj2.content = content;
              });
            }));
          case 14:
            useMessages.forEach(function(msgObj2) {
              state.emittedMessagesIds.add(msgObj2.token);
              if (state.messagesCallback) {
                state.messagesCallback(msgObj2.content.data);
              }
            });
          case 15:
          case "end":
            return _context18.stop();
        }
    }, _callee18);
  }));
  return _handleMessagePing.apply(this, arguments);
}
function refreshReaderClients(channelState) {
  return getReadersUuids(channelState.channelName, channelState.paths).then(function(otherReaders) {
    Object.keys(channelState.otherReaderClients).filter(function(readerUuid) {
      return !otherReaders.includes(readerUuid);
    }).forEach(/* @__PURE__ */ function() {
      var _ref2 = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee2(readerUuid) {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return channelState.otherReaderClients[readerUuid].destroy();
              case 3:
                _context2.next = 7;
                break;
              case 5:
                _context2.prev = 5;
                _context2.t0 = _context2["catch"](0);
              case 7:
                delete channelState.otherReaderClients[readerUuid];
              case 8:
              case "end":
                return _context2.stop();
            }
        }, _callee2, null, [[0, 5]]);
      }));
      return function(_x23) {
        return _ref2.apply(this, arguments);
      };
    }());
    return Promise.all(otherReaders.filter(function(readerUuid) {
      return readerUuid !== channelState.uuid;
    }).filter(function(readerUuid) {
      return !channelState.otherReaderClients[readerUuid];
    }).map(/* @__PURE__ */ function() {
      var _ref3 = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee3(readerUuid) {
        var client;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                if (!channelState.closed) {
                  _context3.next = 3;
                  break;
                }
                return _context3.abrupt("return");
              case 3:
                _context3.prev = 3;
                _context3.next = 6;
                return openClientConnection(channelState.channelName, readerUuid);
              case 6:
                client = _context3.sent;
                channelState.otherReaderClients[readerUuid] = client;
                _context3.next = 12;
                break;
              case 10:
                _context3.prev = 10;
                _context3.t0 = _context3["catch"](3);
              case 12:
                _context3.next = 16;
                break;
              case 14:
                _context3.prev = 14;
                _context3.t1 = _context3["catch"](0);
              case 16:
              case "end":
                return _context3.stop();
            }
        }, _callee3, null, [[0, 14], [3, 10]]);
      }));
      return function(_x24) {
        return _ref3.apply(this, arguments);
      };
    }()));
  });
}
function postMessage(_x25, _x26) {
  return _postMessage.apply(this, arguments);
}
function _postMessage() {
  _postMessage = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee20(channelState, messageJson) {
    var writePromise;
    return _regenerator["default"].wrap(function _callee20$(_context20) {
      while (1)
        switch (_context20.prev = _context20.next) {
          case 0:
            writePromise = channelState.writeFileQueue.add(function() {
              return writeMessage(channelState.channelName, channelState.uuid, messageJson, channelState.paths);
            });
            channelState.writeBlockPromise = channelState.writeBlockPromise.then(/* @__PURE__ */ (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee19() {
              var _yield$Promise$all2, msgObj, pingStr, writeToReadersPromise;
              return _regenerator["default"].wrap(function _callee19$(_context19) {
                while (1)
                  switch (_context19.prev = _context19.next) {
                    case 0:
                      _context19.next = 2;
                      return new Promise(function(res) {
                        return setTimeout(res, 0);
                      });
                    case 2:
                      _context19.next = 4;
                      return Promise.all([writePromise, refreshReaderClients(channelState)]);
                    case 4:
                      _yield$Promise$all2 = _context19.sent;
                      msgObj = _yield$Promise$all2[0];
                      emitOverFastPath(channelState, msgObj, messageJson);
                      pingStr = '{"t":' + msgObj.time + ',"u":"' + msgObj.uuid + '","to":"' + msgObj.token + '"}|';
                      writeToReadersPromise = Promise.all(Object.values(channelState.otherReaderClients).filter(function(client) {
                        return client.writable;
                      }).map(function(client) {
                        return new Promise(function(res) {
                          client.write(pingStr, res);
                        });
                      }));
                      if ((0, _util2.randomInt)(0, 20) === 0) {
                        getAllMessages(channelState.channelName, channelState.paths).then(function(allMessages) {
                          return cleanOldMessages(allMessages, channelState.options.node.ttl);
                        });
                      }
                      return _context19.abrupt("return", writeToReadersPromise);
                    case 11:
                    case "end":
                      return _context19.stop();
                  }
              }, _callee19);
            })));
            return _context20.abrupt("return", channelState.writeBlockPromise);
          case 3:
          case "end":
            return _context20.stop();
        }
    }, _callee20);
  }));
  return _postMessage.apply(this, arguments);
}
function emitOverFastPath(state, msgObj, messageJson) {
  if (!state.options.node.useFastPath) {
    return;
  }
  var others = OTHER_INSTANCES[state.channelName].filter(function(s2) {
    return s2 !== state;
  });
  var checkObj = {
    time: msgObj.time,
    senderUuid: msgObj.uuid,
    token: msgObj.token
  };
  others.filter(function(otherState) {
    return _filterMessage(checkObj, otherState);
  }).forEach(function(otherState) {
    otherState.messagesCallback(messageJson);
  });
}
function onMessage(channelState, fn2) {
  var time = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : microSeconds();
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn2;
  handleMessagePing(channelState);
}
function close(channelState) {
  if (channelState.closed)
    return _util2.PROMISE_RESOLVED_VOID;
  channelState.closed = true;
  channelState.emittedMessagesIds.clear();
  OTHER_INSTANCES[channelState.channelName] = OTHER_INSTANCES[channelState.channelName].filter(function(o2) {
    return o2 !== channelState;
  });
  if (channelState.removeUnload) {
    channelState.removeUnload.remove();
  }
  return new Promise(function(res) {
    if (channelState.socketEE)
      channelState.socketEE.emitter.removeAllListeners();
    Object.values(channelState.otherReaderClients).forEach(function(client) {
      return client.destroy();
    });
    if (channelState.infoFilePath) {
      try {
        _fs["default"].unlinkSync(channelState.infoFilePath);
      } catch (err) {
      }
    }
    setTimeout(function() {
      channelState.socketEE.server.close();
      res();
    }, 200);
  });
}
function canBeUsed() {
  return typeof _fs["default"].mkdir === "function";
}
function averageResponseTime() {
  return 200;
}
function microSeconds() {
  return parseInt(now() / 1e3);
}
function now() {
  return Number(process.hrtime.bigint());
}
var _typeof = _typeofExports;
Object.defineProperty(methodChooser, "__esModule", {
  value: true
});
methodChooser.chooseMethod = chooseMethod;
var _native = native;
var _indexedDb = indexedDb;
var _localstorage = localstorage;
var _simulate = simulate;
var NodeMethod = _interopRequireWildcard(node);
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function")
    return null;
  var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
  var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
    return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return { "default": obj };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj["default"] = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
var METHODS = [
  _native.NativeMethod,
  // fastest
  _indexedDb.IndexedDBMethod,
  _localstorage.LocalstorageMethod
];
function chooseMethod(options2) {
  var chooseMethods = [].concat(options2.methods, METHODS).filter(Boolean);
  chooseMethods.push(NodeMethod);
  if (options2.type) {
    if (options2.type === "simulate") {
      return _simulate.SimulateMethod;
    }
    var ret = chooseMethods.find(function(m2) {
      return m2.type === options2.type;
    });
    if (!ret)
      throw new Error("method-type " + options2.type + " not found");
    else
      return ret;
  }
  if (!options2.webWorkerSupport) {
    chooseMethods = chooseMethods.filter(function(m2) {
      return m2.type !== "idb";
    });
  }
  var useMethod = chooseMethods.find(function(method) {
    return method.canBeUsed();
  });
  if (!useMethod) {
    throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function(m2) {
      return m2.type;
    })));
  } else {
    return useMethod;
  }
}
Object.defineProperty(broadcastChannel, "__esModule", {
  value: true
});
broadcastChannel.OPEN_BROADCAST_CHANNELS = broadcastChannel.BroadcastChannel = void 0;
broadcastChannel.clearNodeFolder = clearNodeFolder;
broadcastChannel.enforceOptions = enforceOptions;
var _util$2 = util$2;
var _methodChooser = methodChooser;
var _options = options;
var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
broadcastChannel.OPEN_BROADCAST_CHANNELS = OPEN_BROADCAST_CHANNELS;
var lastId = 0;
var BroadcastChannel$1 = function BroadcastChannel2(name, options2) {
  this.id = lastId++;
  OPEN_BROADCAST_CHANNELS.add(this);
  this.name = name;
  if (ENFORCED_OPTIONS) {
    options2 = ENFORCED_OPTIONS;
  }
  this.options = (0, _options.fillOptionsWithDefaults)(options2);
  this.method = (0, _methodChooser.chooseMethod)(this.options);
  this._iL = false;
  this._onML = null;
  this._addEL = {
    message: [],
    internal: []
  };
  this._uMP = /* @__PURE__ */ new Set();
  this._befC = [];
  this._prepP = null;
  _prepareChannel(this);
};
broadcastChannel.BroadcastChannel = BroadcastChannel$1;
BroadcastChannel$1._pubkey = true;
function clearNodeFolder(options2) {
  options2 = (0, _options.fillOptionsWithDefaults)(options2);
  var method = (0, _methodChooser.chooseMethod)(options2);
  if (method.type === "node") {
    return method.clearNodeFolder().then(function() {
      return true;
    });
  } else {
    return _util$2.PROMISE_RESOLVED_FALSE;
  }
}
var ENFORCED_OPTIONS;
function enforceOptions(options2) {
  ENFORCED_OPTIONS = options2;
}
BroadcastChannel$1.prototype = {
  postMessage: function postMessage2(msg) {
    if (this.closed) {
      throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
       * In the past when this error appeared, it was really hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(msg));
    }
    return _post(this, "message", msg);
  },
  postInternal: function postInternal(msg) {
    return _post(this, "internal", msg);
  },
  set onmessage(fn2) {
    var time = this.method.microSeconds();
    var listenObj = {
      time,
      fn: fn2
    };
    _removeListenerObject(this, "message", this._onML);
    if (fn2 && typeof fn2 === "function") {
      this._onML = listenObj;
      _addListenerObject(this, "message", listenObj);
    } else {
      this._onML = null;
    }
  },
  addEventListener: function addEventListener2(type2, fn2) {
    var time = this.method.microSeconds();
    var listenObj = {
      time,
      fn: fn2
    };
    _addListenerObject(this, type2, listenObj);
  },
  removeEventListener: function removeEventListener(type2, fn2) {
    var obj = this._addEL[type2].find(function(obj2) {
      return obj2.fn === fn2;
    });
    _removeListenerObject(this, type2, obj);
  },
  close: function close2() {
    var _this = this;
    if (this.closed) {
      return;
    }
    OPEN_BROADCAST_CHANNELS["delete"](this);
    this.closed = true;
    var awaitPrepare = this._prepP ? this._prepP : _util$2.PROMISE_RESOLVED_VOID;
    this._onML = null;
    this._addEL.message = [];
    return awaitPrepare.then(function() {
      return Promise.all(Array.from(_this._uMP));
    }).then(function() {
      return Promise.all(_this._befC.map(function(fn2) {
        return fn2();
      }));
    }).then(function() {
      return _this.method.close(_this._state);
    });
  },
  get type() {
    return this.method.type;
  },
  get isClosed() {
    return this.closed;
  }
};
function _post(broadcastChannel2, type2, msg) {
  var time = broadcastChannel2.method.microSeconds();
  var msgObj = {
    time,
    type: type2,
    data: msg
  };
  var awaitPrepare = broadcastChannel2._prepP ? broadcastChannel2._prepP : _util$2.PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(function() {
    var sendPromise = broadcastChannel2.method.postMessage(broadcastChannel2._state, msgObj);
    broadcastChannel2._uMP.add(sendPromise);
    sendPromise["catch"]().then(function() {
      return broadcastChannel2._uMP["delete"](sendPromise);
    });
    return sendPromise;
  });
}
function _prepareChannel(channel) {
  var maybePromise = channel.method.create(channel.name, channel.options);
  if ((0, _util$2.isPromise)(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then(function(s2) {
      channel._state = s2;
    });
  } else {
    channel._state = maybePromise;
  }
}
function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0)
    return true;
  if (channel._addEL.internal.length > 0)
    return true;
  return false;
}
function _addListenerObject(channel, type2, obj) {
  channel._addEL[type2].push(obj);
  _startListening(channel);
}
function _removeListenerObject(channel, type2, obj) {
  channel._addEL[type2] = channel._addEL[type2].filter(function(o2) {
    return o2 !== obj;
  });
  _stopListening(channel);
}
function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    var listenerFn = function listenerFn2(msgObj) {
      channel._addEL[msgObj.type].forEach(function(listenerObject) {
        var hundredMsInMicro = 100 * 1e3;
        var minMessageTime = listenerObject.time - hundredMsInMicro;
        if (msgObj.time >= minMessageTime) {
          listenerObject.fn(msgObj.data);
        }
      });
    };
    var time = channel.method.microSeconds();
    if (channel._prepP) {
      channel._prepP.then(function() {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time);
    }
  }
}
function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    channel._iL = false;
    var time = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time);
  }
}
var leaderElection = {};
var leaderElectionUtil = {};
Object.defineProperty(leaderElectionUtil, "__esModule", {
  value: true
});
leaderElectionUtil.beLeader = beLeader;
leaderElectionUtil.sendLeaderMessage = sendLeaderMessage;
var _unload = require$$0$1;
function sendLeaderMessage(leaderElector, action) {
  var msgJson = {
    context: "leader",
    action,
    token: leaderElector.token
  };
  return leaderElector.broadcastChannel.postInternal(msgJson);
}
function beLeader(leaderElector) {
  leaderElector.isLeader = true;
  leaderElector._hasLeader = true;
  var unloadFn = (0, _unload.add)(function() {
    return leaderElector.die();
  });
  leaderElector._unl.push(unloadFn);
  var isLeaderListener = function isLeaderListener2(msg) {
    if (msg.context === "leader" && msg.action === "apply") {
      sendLeaderMessage(leaderElector, "tell");
    }
    if (msg.context === "leader" && msg.action === "tell" && !leaderElector._dpLC) {
      leaderElector._dpLC = true;
      leaderElector._dpL();
      sendLeaderMessage(leaderElector, "tell");
    }
  };
  leaderElector.broadcastChannel.addEventListener("internal", isLeaderListener);
  leaderElector._lstns.push(isLeaderListener);
  return sendLeaderMessage(leaderElector, "tell");
}
var leaderElectionWebLock = {};
Object.defineProperty(leaderElectionWebLock, "__esModule", {
  value: true
});
leaderElectionWebLock.LeaderElectionWebLock = void 0;
var _util$1 = util$2;
var _leaderElectionUtil$1 = leaderElectionUtil;
var LeaderElectionWebLock = function LeaderElectionWebLock2(broadcastChannel2, options2) {
  var _this = this;
  this.broadcastChannel = broadcastChannel2;
  broadcastChannel2._befC.push(function() {
    return _this.die();
  });
  this._options = options2;
  this.isLeader = false;
  this.isDead = false;
  this.token = (0, _util$1.randomToken)();
  this._lstns = [];
  this._unl = [];
  this._dpL = function() {
  };
  this._dpLC = false;
  this._wKMC = {};
  this.lN = "pubkey-bc||" + broadcastChannel2.method.type + "||" + broadcastChannel2.name;
};
leaderElectionWebLock.LeaderElectionWebLock = LeaderElectionWebLock;
LeaderElectionWebLock.prototype = {
  hasLeader: function hasLeader() {
    var _this2 = this;
    return navigator.locks.query().then(function(locks) {
      var relevantLocks = locks.held ? locks.held.filter(function(lock2) {
        return lock2.name === _this2.lN;
      }) : [];
      if (relevantLocks && relevantLocks.length > 0) {
        return true;
      } else {
        return false;
      }
    });
  },
  awaitLeadership: function awaitLeadership() {
    var _this3 = this;
    if (!this._wLMP) {
      this._wKMC.c = new AbortController();
      var returnPromise = new Promise(function(res, rej) {
        _this3._wKMC.res = res;
        _this3._wKMC.rej = rej;
      });
      this._wLMP = new Promise(function(res) {
        navigator.locks.request(_this3.lN, {
          signal: _this3._wKMC.c.signal
        }, function() {
          _this3._wKMC.c = void 0;
          (0, _leaderElectionUtil$1.beLeader)(_this3);
          res();
          return returnPromise;
        })["catch"](function() {
        });
      });
    }
    return this._wLMP;
  },
  set onduplicate(_fn) {
  },
  die: function die() {
    var _this4 = this;
    this._lstns.forEach(function(listener) {
      return _this4.broadcastChannel.removeEventListener("internal", listener);
    });
    this._lstns = [];
    this._unl.forEach(function(uFn) {
      return uFn.remove();
    });
    this._unl = [];
    if (this.isLeader) {
      this.isLeader = false;
    }
    this.isDead = true;
    if (this._wKMC.res) {
      this._wKMC.res();
    }
    if (this._wKMC.c) {
      this._wKMC.c.abort("LeaderElectionWebLock.die() called");
    }
    return (0, _leaderElectionUtil$1.sendLeaderMessage)(this, "death");
  }
};
Object.defineProperty(leaderElection, "__esModule", {
  value: true
});
leaderElection.createLeaderElection = createLeaderElection;
var _util = util$2;
var _leaderElectionUtil = leaderElectionUtil;
var _leaderElectionWebLock = leaderElectionWebLock;
var LeaderElection = function LeaderElection2(broadcastChannel2, options2) {
  var _this = this;
  this.broadcastChannel = broadcastChannel2;
  this._options = options2;
  this.isLeader = false;
  this._hasLeader = false;
  this.isDead = false;
  this.token = (0, _util.randomToken)();
  this._aplQ = _util.PROMISE_RESOLVED_VOID;
  this._aplQC = 0;
  this._unl = [];
  this._lstns = [];
  this._dpL = function() {
  };
  this._dpLC = false;
  var hasLeaderListener = function hasLeaderListener2(msg) {
    if (msg.context === "leader") {
      if (msg.action === "death") {
        _this._hasLeader = false;
      }
      if (msg.action === "tell") {
        _this._hasLeader = true;
      }
    }
  };
  this.broadcastChannel.addEventListener("internal", hasLeaderListener);
  this._lstns.push(hasLeaderListener);
};
LeaderElection.prototype = {
  hasLeader: function hasLeader2() {
    return Promise.resolve(this._hasLeader);
  },
  /**
   * Returns true if the instance is leader,
   * false if not.
   * @async
   */
  applyOnce: function applyOnce(isFromFallbackInterval) {
    var _this2 = this;
    if (this.isLeader) {
      return (0, _util.sleep)(0, true);
    }
    if (this.isDead) {
      return (0, _util.sleep)(0, false);
    }
    if (this._aplQC > 1) {
      return this._aplQ;
    }
    var applyRun = function applyRun2() {
      if (_this2.isLeader) {
        return _util.PROMISE_RESOLVED_TRUE;
      }
      var stopCriteria = false;
      var stopCriteriaPromiseResolve;
      var stopCriteriaPromise = new Promise(function(res) {
        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve2() {
          stopCriteria = true;
          res();
        };
      });
      var handleMessage = function handleMessage2(msg) {
        if (msg.context === "leader" && msg.token != _this2.token) {
          if (msg.action === "apply") {
            if (msg.token > _this2.token) {
              stopCriteriaPromiseResolve();
            }
          }
          if (msg.action === "tell") {
            stopCriteriaPromiseResolve();
            _this2._hasLeader = true;
          }
        }
      };
      _this2.broadcastChannel.addEventListener("internal", handleMessage);
      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;
      return (0, _leaderElectionUtil.sendLeaderMessage)(_this2, "apply").then(function() {
        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function() {
          return Promise.reject(new Error());
        })]);
      }).then(function() {
        return (0, _leaderElectionUtil.sendLeaderMessage)(_this2, "apply");
      }).then(function() {
        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function() {
          return Promise.reject(new Error());
        })]);
      })["catch"](function() {
      }).then(function() {
        _this2.broadcastChannel.removeEventListener("internal", handleMessage);
        if (!stopCriteria) {
          return (0, _leaderElectionUtil.beLeader)(_this2).then(function() {
            return true;
          });
        } else {
          return false;
        }
      });
    };
    this._aplQC = this._aplQC + 1;
    this._aplQ = this._aplQ.then(function() {
      return applyRun();
    }).then(function() {
      _this2._aplQC = _this2._aplQC - 1;
    });
    return this._aplQ.then(function() {
      return _this2.isLeader;
    });
  },
  awaitLeadership: function awaitLeadership2() {
    if (
      /* _awaitLeadershipPromise */
      !this._aLP
    ) {
      this._aLP = _awaitLeadershipOnce(this);
    }
    return this._aLP;
  },
  set onduplicate(fn2) {
    this._dpL = fn2;
  },
  die: function die2() {
    var _this3 = this;
    this._lstns.forEach(function(listener) {
      return _this3.broadcastChannel.removeEventListener("internal", listener);
    });
    this._lstns = [];
    this._unl.forEach(function(uFn) {
      return uFn.remove();
    });
    this._unl = [];
    if (this.isLeader) {
      this._hasLeader = false;
      this.isLeader = false;
    }
    this.isDead = true;
    return (0, _leaderElectionUtil.sendLeaderMessage)(this, "death");
  }
};
function _awaitLeadershipOnce(leaderElector) {
  if (leaderElector.isLeader) {
    return _util.PROMISE_RESOLVED_VOID;
  }
  return new Promise(function(res) {
    var resolved2 = false;
    function finish() {
      if (resolved2) {
        return;
      }
      resolved2 = true;
      leaderElector.broadcastChannel.removeEventListener("internal", whenDeathListener);
      res(true);
    }
    leaderElector.applyOnce().then(function() {
      if (leaderElector.isLeader) {
        finish();
      }
    });
    var tryOnFallBack = function tryOnFallBack2() {
      return (0, _util.sleep)(leaderElector._options.fallbackInterval).then(function() {
        if (leaderElector.isDead || resolved2) {
          return;
        }
        if (leaderElector.isLeader) {
          finish();
        } else {
          return leaderElector.applyOnce(true).then(function() {
            if (leaderElector.isLeader) {
              finish();
            } else {
              tryOnFallBack2();
            }
          });
        }
      });
    };
    tryOnFallBack();
    var whenDeathListener = function whenDeathListener2(msg) {
      if (msg.context === "leader" && msg.action === "death") {
        leaderElector._hasLeader = false;
        leaderElector.applyOnce().then(function() {
          if (leaderElector.isLeader) {
            finish();
          }
        });
      }
    };
    leaderElector.broadcastChannel.addEventListener("internal", whenDeathListener);
    leaderElector._lstns.push(whenDeathListener);
  });
}
function fillOptionsWithDefaults(options2, channel) {
  if (!options2)
    options2 = {};
  options2 = JSON.parse(JSON.stringify(options2));
  if (!options2.fallbackInterval) {
    options2.fallbackInterval = 3e3;
  }
  if (!options2.responseTime) {
    options2.responseTime = channel.method.averageResponseTime(channel.options);
  }
  return options2;
}
function createLeaderElection(channel, options2) {
  if (channel._leaderElector) {
    throw new Error("BroadcastChannel already has a leader-elector");
  }
  options2 = fillOptionsWithDefaults(options2, channel);
  var elector = (0, _util.supportsWebLockAPI)() ? new _leaderElectionWebLock.LeaderElectionWebLock(channel, options2) : new LeaderElection(channel, options2);
  channel._befC.push(function() {
    return elector.die();
  });
  channel._leaderElector = elector;
  return elector;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "BroadcastChannel", {
    enumerable: true,
    get: function get() {
      return _broadcastChannel2.BroadcastChannel;
    }
  });
  Object.defineProperty(exports, "OPEN_BROADCAST_CHANNELS", {
    enumerable: true,
    get: function get() {
      return _broadcastChannel2.OPEN_BROADCAST_CHANNELS;
    }
  });
  Object.defineProperty(exports, "beLeader", {
    enumerable: true,
    get: function get() {
      return _leaderElectionUtil2.beLeader;
    }
  });
  Object.defineProperty(exports, "clearNodeFolder", {
    enumerable: true,
    get: function get() {
      return _broadcastChannel2.clearNodeFolder;
    }
  });
  Object.defineProperty(exports, "createLeaderElection", {
    enumerable: true,
    get: function get() {
      return _leaderElection.createLeaderElection;
    }
  });
  Object.defineProperty(exports, "enforceOptions", {
    enumerable: true,
    get: function get() {
      return _broadcastChannel2.enforceOptions;
    }
  });
  var _broadcastChannel2 = broadcastChannel;
  var _leaderElection = leaderElection;
  var _leaderElectionUtil2 = leaderElectionUtil;
})(es5node);
Object.defineProperty(rxStorageMultiinstance, "__esModule", {
  value: true
});
rxStorageMultiinstance.BROADCAST_CHANNEL_BY_TOKEN = void 0;
rxStorageMultiinstance.addRxStorageMultiInstanceSupport = addRxStorageMultiInstanceSupport;
rxStorageMultiinstance.getBroadcastChannelReference = getBroadcastChannelReference;
rxStorageMultiinstance.removeBroadcastChannelReference = removeBroadcastChannelReference;
var _rxjs$6 = cjs;
var _operators$5 = operators;
var _broadcastChannel = es5node;
var BROADCAST_CHANNEL_BY_TOKEN = /* @__PURE__ */ new Map();
rxStorageMultiinstance.BROADCAST_CHANNEL_BY_TOKEN = BROADCAST_CHANNEL_BY_TOKEN;
function getBroadcastChannelReference(databaseInstanceToken, databaseName, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    state = {
      /**
       * We have to use the databaseName instead of the databaseInstanceToken
       * in the BroadcastChannel name because different instances must end with the same
       * channel name to be able to broadcast messages between each other.
       */
      bc: new _broadcastChannel.BroadcastChannel("RxDB:" + databaseName),
      refs: /* @__PURE__ */ new Set()
    };
    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);
  }
  state.refs.add(refObject);
  return state.bc;
}
function removeBroadcastChannelReference(databaseInstanceToken, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    return;
  }
  state.refs.delete(refObject);
  if (state.refs.size === 0) {
    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);
    return state.bc.close();
  }
}
function addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance, providedBroadcastChannel) {
  if (!instanceCreationParams.multiInstance) {
    return;
  }
  var broadcastChannel2 = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);
  var changesFromOtherInstances$ = new _rxjs$6.Subject();
  var eventListener = (msg) => {
    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {
      changesFromOtherInstances$.next(msg.eventBulk);
    }
  };
  broadcastChannel2.addEventListener("message", eventListener);
  var oldChangestream$ = instance.changeStream();
  var closed = false;
  var sub = oldChangestream$.subscribe((eventBulk) => {
    if (closed) {
      return;
    }
    broadcastChannel2.postMessage({
      storageName,
      databaseName: instanceCreationParams.databaseName,
      collectionName: instanceCreationParams.collectionName,
      version: instanceCreationParams.schema.version,
      eventBulk
    });
  });
  instance.changeStream = function() {
    return changesFromOtherInstances$.asObservable().pipe((0, _operators$5.mergeWith)(oldChangestream$));
  };
  var oldClose = instance.close.bind(instance);
  instance.close = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel2.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldClose();
  };
  var oldRemove = instance.remove.bind(instance);
  instance.remove = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel2.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldRemove();
  };
}
Object.defineProperty(rxStorageInstanceDexie, "__esModule", {
  value: true
});
rxStorageInstanceDexie.RxStorageInstanceDexie = void 0;
rxStorageInstanceDexie.createDexieStorageInstance = createDexieStorageInstance;
var _rxjs$5 = cjs;
var _utils$j = utils;
var _dexieHelper$1 = dexieHelper;
var _dexieQuery = dexieQuery$1;
var _rxSchemaHelper$8 = rxSchemaHelper;
var _rxStorageHelper$a = rxStorageHelper;
var _rxStorageMultiinstance = rxStorageMultiinstance;
var _rxError$a = rxError;
var instanceId = (0, _utils$j.now)();
var RxStorageInstanceDexie = /* @__PURE__ */ function() {
  function RxStorageInstanceDexie2(storage, databaseName, collectionName, schema, internals, options2, settings) {
    this.changes$ = new _rxjs$5.Subject();
    this.instanceId = instanceId++;
    this.closed = false;
    this.storage = storage;
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.schema = schema;
    this.internals = internals;
    this.options = options2;
    this.settings = settings;
    this.primaryPath = (0, _rxSchemaHelper$8.getPrimaryFieldOfPrimaryKey)(this.schema.primaryKey);
  }
  var _proto = RxStorageInstanceDexie2.prototype;
  _proto.bulkWrite = async function bulkWrite(documentWrites, context2) {
    ensureNotClosed(this);
    documentWrites.forEach((row) => {
      if (!row.document._rev || row.previous && !row.previous._rev) {
        throw (0, _rxError$a.newRxError)("SNH", {
          args: {
            row
          }
        });
      }
    });
    var state = await this.internals;
    var ret = {
      success: {},
      error: {}
    };
    var documentKeys = documentWrites.map((writeRow) => writeRow.document[this.primaryPath]);
    var categorized;
    await state.dexieDb.transaction("rw", state.dexieTable, state.dexieDeletedTable, async () => {
      var docsInDbMap = /* @__PURE__ */ new Map();
      var docsInDbWithInternals = await (0, _dexieHelper$1.getDocsInDb)(this.internals, documentKeys);
      docsInDbWithInternals.forEach((docWithDexieInternals) => {
        var doc = docWithDexieInternals ? (0, _dexieHelper$1.fromDexieToStorage)(docWithDexieInternals) : docWithDexieInternals;
        if (doc) {
          docsInDbMap.set(doc[this.primaryPath], doc);
        }
        return doc;
      });
      categorized = (0, _rxStorageHelper$a.categorizeBulkWriteRows)(this, this.primaryPath, docsInDbMap, documentWrites, context2);
      ret.error = categorized.errors;
      var bulkPutDocs = [];
      var bulkRemoveDocs = [];
      var bulkPutDeletedDocs = [];
      var bulkRemoveDeletedDocs = [];
      categorized.bulkInsertDocs.forEach((row) => {
        var docId = row.document[this.primaryPath];
        ret.success[docId] = row.document;
        bulkPutDocs.push(row.document);
      });
      categorized.bulkUpdateDocs.forEach((row) => {
        var docId = row.document[this.primaryPath];
        ret.success[docId] = row.document;
        if (row.document._deleted && row.previous && !row.previous._deleted) {
          bulkRemoveDocs.push(docId);
          bulkPutDeletedDocs.push(row.document);
        } else if (row.document._deleted && row.previous && row.previous._deleted) {
          bulkPutDeletedDocs.push(row.document);
        } else if (!row.document._deleted) {
          bulkPutDocs.push(row.document);
        } else {
          throw (0, _rxError$a.newRxError)("SNH", {
            args: {
              row
            }
          });
        }
      });
      await Promise.all([bulkPutDocs.length > 0 ? state.dexieTable.bulkPut(bulkPutDocs.map((d2) => (0, _dexieHelper$1.fromStorageToDexie)(d2))) : _utils$j.PROMISE_RESOLVE_VOID, bulkRemoveDocs.length > 0 ? state.dexieTable.bulkDelete(bulkRemoveDocs) : _utils$j.PROMISE_RESOLVE_VOID, bulkPutDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkPut(bulkPutDeletedDocs.map((d2) => (0, _dexieHelper$1.fromStorageToDexie)(d2))) : _utils$j.PROMISE_RESOLVE_VOID, bulkRemoveDeletedDocs.length > 0 ? state.dexieDeletedTable.bulkDelete(bulkRemoveDeletedDocs) : _utils$j.PROMISE_RESOLVE_VOID]);
    });
    categorized = (0, _utils$j.ensureNotFalsy)(categorized);
    if (categorized.eventBulk.events.length > 0) {
      var lastState = (0, _utils$j.ensureNotFalsy)(categorized.newestRow).document;
      categorized.eventBulk.checkpoint = {
        id: lastState[this.primaryPath],
        lwt: lastState._meta.lwt
      };
      var endTime = (0, _utils$j.now)();
      categorized.eventBulk.events.forEach((event) => event.endTime = endTime);
      this.changes$.next(categorized.eventBulk);
    }
    return ret;
  };
  _proto.findDocumentsById = async function findDocumentsById(ids, deleted) {
    ensureNotClosed(this);
    var state = await this.internals;
    var ret = {};
    await state.dexieDb.transaction("r", state.dexieTable, state.dexieDeletedTable, async () => {
      var docsInDb;
      if (deleted) {
        docsInDb = await (0, _dexieHelper$1.getDocsInDb)(this.internals, ids);
      } else {
        docsInDb = await state.dexieTable.bulkGet(ids);
      }
      ids.forEach((id, idx) => {
        var documentInDb = docsInDb[idx];
        if (documentInDb && (!documentInDb._deleted || deleted)) {
          ret[id] = (0, _dexieHelper$1.fromDexieToStorage)(documentInDb);
        }
      });
    });
    return ret;
  };
  _proto.query = function query2(preparedQuery) {
    ensureNotClosed(this);
    return (0, _dexieQuery.dexieQuery)(this, preparedQuery);
  };
  _proto.count = async function count2(preparedQuery) {
    if (preparedQuery.queryPlan.selectorSatisfiedByIndex) {
      var result = await (0, _dexieQuery.dexieCount)(this, preparedQuery);
      return {
        count: result,
        mode: "fast"
      };
    } else {
      var _result = await (0, _dexieQuery.dexieQuery)(this, preparedQuery);
      return {
        count: _result.documents.length,
        mode: "slow"
      };
    }
  };
  _proto.getChangedDocumentsSince = async function getChangedDocumentsSince(limit2, checkpoint2) {
    ensureNotClosed(this);
    var sinceLwt = checkpoint2 ? checkpoint2.lwt : _utils$j.RX_META_LWT_MINIMUM;
    var sinceId = checkpoint2 ? checkpoint2.id : "";
    var state = await this.internals;
    var [changedDocsNormal, changedDocsDeleted] = await Promise.all([state.dexieTable, state.dexieDeletedTable].map(async (table) => {
      var query2 = table.where("[_meta.lwt+" + this.primaryPath + "]").above([sinceLwt, sinceId]).limit(limit2);
      var changedDocuments = await query2.toArray();
      return changedDocuments.map((d2) => (0, _dexieHelper$1.fromDexieToStorage)(d2));
    }));
    var changedDocs = changedDocsNormal.slice(0);
    (0, _utils$j.appendToArray)(changedDocs, changedDocsDeleted);
    changedDocs = (0, _utils$j.sortDocumentsByLastWriteTime)(this.primaryPath, changedDocs);
    changedDocs = changedDocs.slice(0, limit2);
    var lastDoc = (0, _utils$j.lastOfArray)(changedDocs);
    return {
      documents: changedDocs,
      checkpoint: lastDoc ? {
        id: lastDoc[this.primaryPath],
        lwt: lastDoc._meta.lwt
      } : checkpoint2 ? checkpoint2 : {
        id: "",
        lwt: 0
      }
    };
  };
  _proto.remove = async function remove() {
    ensureNotClosed(this);
    var state = await this.internals;
    await Promise.all([state.dexieDeletedTable.clear(), state.dexieTable.clear()]);
    return this.close();
  };
  _proto.changeStream = function changeStream() {
    ensureNotClosed(this);
    return this.changes$.asObservable();
  };
  _proto.cleanup = async function cleanup(minimumDeletedTime) {
    ensureNotClosed(this);
    var state = await this.internals;
    await state.dexieDb.transaction("rw", state.dexieDeletedTable, async () => {
      var maxDeletionTime = (0, _utils$j.now)() - minimumDeletedTime;
      var toRemove = await state.dexieDeletedTable.where("_meta.lwt").below(maxDeletionTime).toArray();
      var removeIds = toRemove.map((doc) => doc[this.primaryPath]);
      await state.dexieDeletedTable.bulkDelete(removeIds);
    });
    return true;
  };
  _proto.getAttachmentData = function getAttachmentData(_documentId, _attachmentId, _digest) {
    ensureNotClosed(this);
    throw new Error("Attachments are not implemented in the dexie RxStorage. Make a pull request.");
  };
  _proto.close = function close3() {
    ensureNotClosed(this);
    this.closed = true;
    this.changes$.complete();
    (0, _dexieHelper$1.closeDexieDb)(this.internals);
    return _utils$j.PROMISE_RESOLVE_VOID;
  };
  _proto.conflictResultionTasks = function conflictResultionTasks() {
    return new _rxjs$5.Subject();
  };
  _proto.resolveConflictResultionTask = async function resolveConflictResultionTask(_taskSolution) {
  };
  return RxStorageInstanceDexie2;
}();
rxStorageInstanceDexie.RxStorageInstanceDexie = RxStorageInstanceDexie;
function createDexieStorageInstance(storage, params, settings) {
  var internals = (0, _dexieHelper$1.getDexieDbWithTables)(params.databaseName, params.collectionName, settings, params.schema);
  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings);
  (0, _rxStorageMultiinstance.addRxStorageMultiInstanceSupport)(_dexieHelper$1.RX_STORAGE_NAME_DEXIE, params, instance);
  return Promise.resolve(instance);
}
function ensureNotClosed(instance) {
  if (instance.closed) {
    throw new Error("RxStorageInstanceDexie is closed " + instance.databaseName + "-" + instance.collectionName);
  }
}
Object.defineProperty(rxStorageDexie, "__esModule", {
  value: true
});
rxStorageDexie.RxStorageDexie = void 0;
rxStorageDexie.getRxStorageDexie = getRxStorageDexie;
var _dexieHelper = dexieHelper;
var _rxStorageInstanceDexie = rxStorageInstanceDexie;
var _rxStorageHelper$9 = rxStorageHelper;
var RxStorageDexie = /* @__PURE__ */ function() {
  function RxStorageDexie2(settings) {
    this.name = _dexieHelper.RX_STORAGE_NAME_DEXIE;
    this.statics = _dexieHelper.RxStorageDexieStatics;
    this.settings = settings;
  }
  var _proto = RxStorageDexie2.prototype;
  _proto.createStorageInstance = function createStorageInstance(params) {
    (0, _rxStorageHelper$9.ensureRxStorageInstanceParamsAreCorrect)(params);
    (0, _dexieHelper.ensureNoBooleanIndex)(params.schema);
    return (0, _rxStorageInstanceDexie.createDexieStorageInstance)(this, params, this.settings);
  };
  return RxStorageDexie2;
}();
rxStorageDexie.RxStorageDexie = RxStorageDexie;
function getRxStorageDexie(settings = {}) {
  var storage = new RxStorageDexie(settings);
  return storage;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _rxStorageDexie = rxStorageDexie;
  Object.keys(_rxStorageDexie).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageDexie[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageDexie[key];
      }
    });
  });
  var _rxStorageInstanceDexie2 = rxStorageInstanceDexie;
  Object.keys(_rxStorageInstanceDexie2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _rxStorageInstanceDexie2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageInstanceDexie2[key];
      }
    });
  });
  var _dexieHelper2 = dexieHelper;
  Object.keys(_dexieHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _dexieHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _dexieHelper2[key];
      }
    });
  });
  var _dexieQuery2 = dexieQuery$1;
  Object.keys(_dexieQuery2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (key in exports && exports[key] === _dexieQuery2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _dexieQuery2[key];
      }
    });
  });
})(storageDexie);
const messages = {
  AbortError: "A request was aborted, for example through a call to IDBTransaction.abort.",
  ConstraintError: "A mutation operation in the transaction failed because a constraint was not satisfied. For example, an object such as an object store or index already exists and a request attempted to create a new one.",
  DataCloneError: "The data being stored could not be cloned by the internal structured cloning algorithm.",
  DataError: "Data provided to an operation does not meet requirements.",
  InvalidAccessError: "An invalid operation was performed on an object. For example transaction creation attempt was made, but an empty scope was provided.",
  InvalidStateError: "An operation was called on an object on which it is not allowed or at a time when it is not allowed. Also occurs if a request is made on a source object that has been deleted or removed. Use TransactionInactiveError or ReadOnlyError when possible, as they are more specific variations of InvalidStateError.",
  NotFoundError: "The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.",
  ReadOnlyError: 'The mutating operation was attempted in a "readonly" transaction.',
  TransactionInactiveError: "A request was placed against a transaction which is currently not active, or which is finished.",
  VersionError: "An attempt was made to open a database using a lower version than the existing version."
};
class AbortError extends Error {
  constructor(message = messages.AbortError) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
}
class ConstraintError extends Error {
  constructor(message = messages.ConstraintError) {
    super();
    this.name = "ConstraintError";
    this.message = message;
  }
}
class DataCloneError extends Error {
  constructor(message = messages.DataCloneError) {
    super();
    this.name = "DataCloneError";
    this.message = message;
  }
}
class DataError extends Error {
  constructor(message = messages.DataError) {
    super();
    this.name = "DataError";
    this.message = message;
  }
}
class InvalidAccessError extends Error {
  constructor(message = messages.InvalidAccessError) {
    super();
    this.name = "InvalidAccessError";
    this.message = message;
  }
}
class InvalidStateError extends Error {
  constructor(message = messages.InvalidStateError) {
    super();
    this.name = "InvalidStateError";
    this.message = message;
  }
}
class NotFoundError extends Error {
  constructor(message = messages.NotFoundError) {
    super();
    this.name = "NotFoundError";
    this.message = message;
  }
}
class ReadOnlyError extends Error {
  constructor(message = messages.ReadOnlyError) {
    super();
    this.name = "ReadOnlyError";
    this.message = message;
  }
}
class TransactionInactiveError extends Error {
  constructor(message = messages.TransactionInactiveError) {
    super();
    this.name = "TransactionInactiveError";
    this.message = message;
  }
}
class VersionError extends Error {
  constructor(message = messages.VersionError) {
    super();
    this.name = "VersionError";
    this.message = message;
  }
}
const valueToKey = (input, seen) => {
  if (typeof input === "number") {
    if (isNaN(input)) {
      throw new DataError();
    }
    return input;
  } else if (input instanceof Date) {
    const ms = input.valueOf();
    if (isNaN(ms)) {
      throw new DataError();
    }
    return new Date(ms);
  } else if (typeof input === "string") {
    return input;
  } else if (input instanceof ArrayBuffer || typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView && ArrayBuffer.isView(input)) {
    if (input instanceof ArrayBuffer) {
      return new Uint8Array(input).buffer;
    }
    return new Uint8Array(input.buffer).buffer;
  } else if (Array.isArray(input)) {
    if (seen === void 0) {
      seen = /* @__PURE__ */ new Set();
    } else if (seen.has(input)) {
      throw new DataError();
    }
    seen.add(input);
    const keys = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const hop = input.hasOwnProperty(i2);
      if (!hop) {
        throw new DataError();
      }
      const entry = input[i2];
      const key = valueToKey(entry, seen);
      keys.push(key);
    }
    return keys;
  } else {
    throw new DataError();
  }
};
const getType = (x2) => {
  if (typeof x2 === "number") {
    return "Number";
  }
  if (x2 instanceof Date) {
    return "Date";
  }
  if (Array.isArray(x2)) {
    return "Array";
  }
  if (typeof x2 === "string") {
    return "String";
  }
  if (x2 instanceof ArrayBuffer) {
    return "Binary";
  }
  throw new DataError();
};
const cmp = (first2, second2) => {
  if (second2 === void 0) {
    throw new TypeError();
  }
  first2 = valueToKey(first2);
  second2 = valueToKey(second2);
  const t1 = getType(first2);
  const t2 = getType(second2);
  if (t1 !== t2) {
    if (t1 === "Array") {
      return 1;
    }
    if (t1 === "Binary" && (t2 === "String" || t2 === "Date" || t2 === "Number")) {
      return 1;
    }
    if (t1 === "String" && (t2 === "Date" || t2 === "Number")) {
      return 1;
    }
    if (t1 === "Date" && t2 === "Number") {
      return 1;
    }
    return -1;
  }
  if (t1 === "Binary") {
    first2 = new Uint8Array(first2);
    second2 = new Uint8Array(second2);
  }
  if (t1 === "Array" || t1 === "Binary") {
    const length = Math.min(first2.length, second2.length);
    for (let i2 = 0; i2 < length; i2++) {
      const result = cmp(first2[i2], second2[i2]);
      if (result !== 0) {
        return result;
      }
    }
    if (first2.length > second2.length) {
      return 1;
    }
    if (first2.length < second2.length) {
      return -1;
    }
    return 0;
  }
  if (t1 === "Date") {
    if (first2.getTime() === second2.getTime()) {
      return 0;
    }
  } else {
    if (first2 === second2) {
      return 0;
    }
  }
  return first2 > second2 ? 1 : -1;
};
class FDBKeyRange {
  static only(value) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    value = valueToKey(value);
    return new FDBKeyRange(value, value, false, false);
  }
  static lowerBound(lower, open = false) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    lower = valueToKey(lower);
    return new FDBKeyRange(lower, void 0, open, true);
  }
  static upperBound(upper, open = false) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    upper = valueToKey(upper);
    return new FDBKeyRange(void 0, upper, true, open);
  }
  static bound(lower, upper, lowerOpen = false, upperOpen = false) {
    if (arguments.length < 2) {
      throw new TypeError();
    }
    const cmpResult = cmp(lower, upper);
    if (cmpResult === 1 || cmpResult === 0 && (lowerOpen || upperOpen)) {
      throw new DataError();
    }
    lower = valueToKey(lower);
    upper = valueToKey(upper);
    return new FDBKeyRange(lower, upper, lowerOpen, upperOpen);
  }
  constructor(lower, upper, lowerOpen, upperOpen) {
    this.lower = lower;
    this.upper = upper;
    this.lowerOpen = lowerOpen;
    this.upperOpen = upperOpen;
  }
  // https://w3c.github.io/IndexedDB/#dom-idbkeyrange-includes
  includes(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    key = valueToKey(key);
    if (this.lower !== void 0) {
      const cmpResult = cmp(this.lower, key);
      if (cmpResult === 1 || cmpResult === 0 && this.lowerOpen) {
        return false;
      }
    }
    if (this.upper !== void 0) {
      const cmpResult = cmp(this.upper, key);
      if (cmpResult === -1 || cmpResult === 0 && this.upperOpen) {
        return false;
      }
    }
    return true;
  }
  toString() {
    return "[object IDBKeyRange]";
  }
}
const extractKey = (keyPath, value) => {
  if (Array.isArray(keyPath)) {
    const result = [];
    for (let item of keyPath) {
      if (item !== void 0 && item !== null && typeof item !== "string" && item.toString) {
        item = item.toString();
      }
      result.push(valueToKey(extractKey(item, value)));
    }
    return result;
  }
  if (keyPath === "") {
    return value;
  }
  let remainingKeyPath = keyPath;
  let object2 = value;
  while (remainingKeyPath !== null) {
    let identifier;
    const i2 = remainingKeyPath.indexOf(".");
    if (i2 >= 0) {
      identifier = remainingKeyPath.slice(0, i2);
      remainingKeyPath = remainingKeyPath.slice(i2 + 1);
    } else {
      identifier = remainingKeyPath;
      remainingKeyPath = null;
    }
    if (object2 === void 0 || object2 === null || !object2.hasOwnProperty(identifier)) {
      return;
    }
    object2 = object2[identifier];
  }
  return object2;
};
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var dist = { exports: {} };
(function(module, exports) {
  (function(f2) {
    {
      module.exports = f2();
    }
  })(function() {
    return function() {
      function r2(e2, n2, t2) {
        function o2(i3, f2) {
          if (!n2[i3]) {
            if (!e2[i3]) {
              var c2 = "function" == typeof commonjsRequire && commonjsRequire;
              if (!f2 && c2)
                return c2(i3, true);
              if (u2)
                return u2(i3, true);
              var a2 = new Error("Cannot find module '" + i3 + "'");
              throw a2.code = "MODULE_NOT_FOUND", a2;
            }
            var p2 = n2[i3] = { exports: {} };
            e2[i3][0].call(p2.exports, function(r3) {
              var n3 = e2[i3][1][r3];
              return o2(n3 || r3);
            }, p2, p2.exports, r2, e2, n2, t2);
          }
          return n2[i3].exports;
        }
        for (var u2 = "function" == typeof commonjsRequire && commonjsRequire, i2 = 0; i2 < t2.length; i2++)
          o2(t2[i2]);
        return o2;
      }
      return r2;
    }()({ 1: [function(_dereq_, module2, exports2) {
      var DOMException2 = _dereq_("domexception");
      var Typeson = _dereq_("typeson");
      var structuredCloningThrowing = _dereq_("typeson-registry/dist/presets/structured-cloning-throwing");
      var globalVar = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : Function("return this;")();
      if (!globalVar.DOMException) {
        globalVar.DOMException = DOMException2;
      }
      var TSON = new Typeson().register(structuredCloningThrowing);
      function realisticStructuredClone2(obj) {
        return TSON.revive(TSON.encapsulate(obj));
      }
      module2.exports = realisticStructuredClone2;
    }, { "domexception": 5, "typeson": 8, "typeson-registry/dist/presets/structured-cloning-throwing": 7 }], 2: [function(_dereq_, module2, exports2) {
      var _slicedToArray = function() {
        function sliceIterator(arr, i2) {
          var _arr = [];
          var _n2 = true;
          var _d = false;
          var _e2 = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n2 = (_s = _i.next()).done); _n2 = true) {
              _arr.push(_s.value);
              if (i2 && _arr.length === i2)
                break;
            }
          } catch (err) {
            _d = true;
            _e2 = err;
          } finally {
            try {
              if (!_n2 && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e2;
            }
          }
          return _arr;
        }
        return function(arr, i2) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i2);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var legacyErrorCodes = _dereq_("./legacy-error-codes.json");
      var idlUtils = _dereq_("./utils.js");
      exports2.implementation = function() {
        function DOMExceptionImpl(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), message = _ref2[0], name = _ref2[1];
          _classCallCheck(this, DOMExceptionImpl);
          this.name = name;
          this.message = message;
        }
        _createClass(DOMExceptionImpl, [{
          key: "code",
          get: function get() {
            return legacyErrorCodes[this.name] || 0;
          }
        }]);
        return DOMExceptionImpl;
      }();
      exports2.init = function(impl) {
        if (Error.captureStackTrace) {
          var wrapper = idlUtils.wrapperForImpl(impl);
          Error.captureStackTrace(wrapper, wrapper.constructor);
        }
      };
    }, { "./legacy-error-codes.json": 4, "./utils.js": 6 }], 3: [function(_dereq_, module2, exports2) {
      var conversions = _dereq_("webidl-conversions");
      var utils2 = _dereq_("./utils.js");
      var impl = utils2.implSymbol;
      function DOMException2() {
        var args2 = [];
        for (var i2 = 0; i2 < arguments.length && i2 < 2; ++i2) {
          args2[i2] = arguments[i2];
        }
        if (args2[0] !== void 0) {
          args2[0] = conversions["DOMString"](args2[0], { context: "Failed to construct 'DOMException': parameter 1" });
        } else {
          args2[0] = "";
        }
        if (args2[1] !== void 0) {
          args2[1] = conversions["DOMString"](args2[1], { context: "Failed to construct 'DOMException': parameter 2" });
        } else {
          args2[1] = "Error";
        }
        iface.setup(this, args2);
      }
      Object.defineProperty(DOMException2, "prototype", {
        value: DOMException2.prototype,
        writable: false,
        enumerable: false,
        configurable: false
      });
      Object.defineProperty(DOMException2.prototype, "name", {
        get: function get() {
          return this[impl]["name"];
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(DOMException2.prototype, "message", {
        get: function get() {
          return this[impl]["message"];
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(DOMException2.prototype, "code", {
        get: function get() {
          return this[impl]["code"];
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(DOMException2, "INDEX_SIZE_ERR", {
        value: 1,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INDEX_SIZE_ERR", {
        value: 1,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "DOMSTRING_SIZE_ERR", {
        value: 2,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "DOMSTRING_SIZE_ERR", {
        value: 2,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "HIERARCHY_REQUEST_ERR", {
        value: 3,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "HIERARCHY_REQUEST_ERR", {
        value: 3,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "WRONG_DOCUMENT_ERR", {
        value: 4,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "WRONG_DOCUMENT_ERR", {
        value: 4,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_CHARACTER_ERR", {
        value: 5,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_CHARACTER_ERR", {
        value: 5,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NO_DATA_ALLOWED_ERR", {
        value: 6,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NO_DATA_ALLOWED_ERR", {
        value: 6,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NO_MODIFICATION_ALLOWED_ERR", {
        value: 7,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NO_MODIFICATION_ALLOWED_ERR", {
        value: 7,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NOT_FOUND_ERR", {
        value: 8,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NOT_FOUND_ERR", {
        value: 8,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NOT_SUPPORTED_ERR", {
        value: 9,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NOT_SUPPORTED_ERR", {
        value: 9,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INUSE_ATTRIBUTE_ERR", {
        value: 10,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INUSE_ATTRIBUTE_ERR", {
        value: 10,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_STATE_ERR", {
        value: 11,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_STATE_ERR", {
        value: 11,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "SYNTAX_ERR", {
        value: 12,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "SYNTAX_ERR", {
        value: 12,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_MODIFICATION_ERR", {
        value: 13,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_MODIFICATION_ERR", {
        value: 13,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NAMESPACE_ERR", {
        value: 14,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NAMESPACE_ERR", {
        value: 14,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_ACCESS_ERR", {
        value: 15,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_ACCESS_ERR", {
        value: 15,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "VALIDATION_ERR", {
        value: 16,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "VALIDATION_ERR", {
        value: 16,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "TYPE_MISMATCH_ERR", {
        value: 17,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "TYPE_MISMATCH_ERR", {
        value: 17,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "SECURITY_ERR", {
        value: 18,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "SECURITY_ERR", {
        value: 18,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "NETWORK_ERR", {
        value: 19,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "NETWORK_ERR", {
        value: 19,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "ABORT_ERR", {
        value: 20,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "ABORT_ERR", {
        value: 20,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "URL_MISMATCH_ERR", {
        value: 21,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "URL_MISMATCH_ERR", {
        value: 21,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "QUOTA_EXCEEDED_ERR", {
        value: 22,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "QUOTA_EXCEEDED_ERR", {
        value: 22,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "TIMEOUT_ERR", {
        value: 23,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "TIMEOUT_ERR", {
        value: 23,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "INVALID_NODE_TYPE_ERR", {
        value: 24,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "INVALID_NODE_TYPE_ERR", {
        value: 24,
        enumerable: true
      });
      Object.defineProperty(DOMException2, "DATA_CLONE_ERR", {
        value: 25,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, "DATA_CLONE_ERR", {
        value: 25,
        enumerable: true
      });
      Object.defineProperty(DOMException2.prototype, Symbol.toStringTag, {
        value: "DOMException",
        writable: false,
        enumerable: false,
        configurable: true
      });
      var iface = {
        mixedInto: [],
        is: function is(obj) {
          if (obj) {
            if (obj[impl] instanceof Impl.implementation) {
              return true;
            }
            for (var i2 = 0; i2 < module2.exports.mixedInto.length; ++i2) {
              if (obj instanceof module2.exports.mixedInto[i2]) {
                return true;
              }
            }
          }
          return false;
        },
        isImpl: function isImpl(obj) {
          if (obj) {
            if (obj instanceof Impl.implementation) {
              return true;
            }
            var wrapper = utils2.wrapperForImpl(obj);
            for (var i2 = 0; i2 < module2.exports.mixedInto.length; ++i2) {
              if (wrapper instanceof module2.exports.mixedInto[i2]) {
                return true;
              }
            }
          }
          return false;
        },
        convert: function convert2(obj) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$context = _ref.context, context2 = _ref$context === void 0 ? "The provided value" : _ref$context;
          if (module2.exports.is(obj)) {
            return utils2.implForWrapper(obj);
          }
          throw new TypeError(context2 + " is not of type 'DOMException'.");
        },
        create: function create2(constructorArgs, privateData) {
          var obj = Object.create(DOMException2.prototype);
          this.setup(obj, constructorArgs, privateData);
          return obj;
        },
        createImpl: function createImpl(constructorArgs, privateData) {
          var obj = Object.create(DOMException2.prototype);
          this.setup(obj, constructorArgs, privateData);
          return utils2.implForWrapper(obj);
        },
        _internalSetup: function _internalSetup(obj) {
        },
        setup: function setup(obj, constructorArgs, privateData) {
          if (!privateData)
            privateData = {};
          privateData.wrapper = obj;
          this._internalSetup(obj);
          Object.defineProperty(obj, impl, {
            value: new Impl.implementation(constructorArgs, privateData),
            writable: false,
            enumerable: false,
            configurable: true
          });
          obj[impl][utils2.wrapperSymbol] = obj;
          if (Impl.init) {
            Impl.init(obj[impl], privateData);
          }
        },
        interface: DOMException2,
        expose: {
          Window: { DOMException: DOMException2 },
          Worker: { DOMException: DOMException2 }
        }
      };
      module2.exports = iface;
      var Impl = _dereq_(".//DOMException-impl.js");
    }, { ".//DOMException-impl.js": 2, "./utils.js": 6, "webidl-conversions": 9 }], 4: [function(_dereq_, module2, exports2) {
      module2.exports = {
        "IndexSizeError": 1,
        "DOMStringSizeError": 2,
        "HierarchyRequestError": 3,
        "WrongDocumentError": 4,
        "InvalidCharacterError": 5,
        "NoDataAllowedError": 6,
        "NoModificationAllowedError": 7,
        "NotFoundError": 8,
        "NotSupportedError": 9,
        "InUseAttributeError": 10,
        "InvalidStateError": 11,
        "SyntaxError": 12,
        "InvalidModificationError": 13,
        "NamespaceError": 14,
        "InvalidAccessError": 15,
        "ValidationError": 16,
        "TypeMismatchError": 17,
        "SecurityError": 18,
        "NetworkError": 19,
        "AbortError": 20,
        "URLMismatchError": 21,
        "QuotaExceededError": 22,
        "TimeoutError": 23,
        "InvalidNodeTypeError": 24,
        "DataCloneError": 25
      };
    }, {}], 5: [function(_dereq_, module2, exports2) {
      module2.exports = _dereq_("./DOMException").interface;
      Object.setPrototypeOf(module2.exports.prototype, Error.prototype);
    }, { "./DOMException": 3 }], 6: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function isObject2(value) {
        return (typeof value === "undefined" ? "undefined" : _typeof2(value)) === "object" && value !== null || typeof value === "function";
      }
      function getReferenceToBytes(bufferSource) {
        if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {
          return bufferSource;
        }
        if (bufferSource instanceof ArrayBuffer) {
          return Buffer.from(bufferSource);
        }
        return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);
      }
      function getCopyToBytes(bufferSource) {
        return Buffer.from(getReferenceToBytes(bufferSource));
      }
      function mixin(target, source) {
        var keys = Object.getOwnPropertyNames(source);
        for (var i2 = 0; i2 < keys.length; ++i2) {
          if (keys[i2] in target) {
            continue;
          }
          Object.defineProperty(target, keys[i2], Object.getOwnPropertyDescriptor(source, keys[i2]));
        }
      }
      var wrapperSymbol = Symbol("wrapper");
      var implSymbol = Symbol("impl");
      var sameObjectCaches = Symbol("SameObject caches");
      function getSameObject(wrapper, prop, creator) {
        if (!wrapper[sameObjectCaches]) {
          wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
        }
        if (prop in wrapper[sameObjectCaches]) {
          return wrapper[sameObjectCaches][prop];
        }
        wrapper[sameObjectCaches][prop] = creator();
        return wrapper[sameObjectCaches][prop];
      }
      function wrapperForImpl(impl) {
        return impl ? impl[wrapperSymbol] : null;
      }
      function implForWrapper(wrapper) {
        return wrapper ? wrapper[implSymbol] : null;
      }
      function tryWrapperForImpl(impl) {
        var wrapper = wrapperForImpl(impl);
        return wrapper ? wrapper : impl;
      }
      function tryImplForWrapper(wrapper) {
        var impl = implForWrapper(wrapper);
        return impl ? impl : wrapper;
      }
      var iterInternalSymbol = Symbol("internal");
      var IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
      module2.exports = {
        isObject: isObject2,
        getReferenceToBytes,
        getCopyToBytes,
        mixin,
        wrapperSymbol,
        implSymbol,
        getSameObject,
        wrapperForImpl,
        implForWrapper,
        tryWrapperForImpl,
        tryImplForWrapper,
        iterInternalSymbol,
        IteratorPrototype
      };
    }, {}], 7: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      !function(e2, t2) {
        "object" == (typeof exports2 === "undefined" ? "undefined" : _typeof2(exports2)) && "undefined" != typeof module2 ? module2.exports = t2() : ((e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).Typeson = e2.Typeson || {}, e2.Typeson.presets = e2.Typeson.presets || {}, e2.Typeson.presets.structuredCloningThrowing = t2());
      }(void 0, function() {
        function _typeof$12(e3) {
          return (_typeof$12 = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function(e4) {
            return typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
          })(e3);
        }
        function _classCallCheck$1(e3, t3) {
          if (!(e3 instanceof t3))
            throw new TypeError("Cannot call a class as a function");
        }
        function _defineProperties$1(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n3 = t3[r3];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
          }
        }
        function _defineProperty$1(e3, t3, r3) {
          return t3 in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function ownKeys$1(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n3 = Object.getOwnPropertySymbols(e3);
            t3 && (n3 = n3.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n3);
          }
          return r3;
        }
        function _toConsumableArray$1(e3) {
          return function _arrayWithoutHoles$1(e4) {
            if (Array.isArray(e4))
              return _arrayLikeToArray$1(e4);
          }(e3) || function _iterableToArray$1(e4) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e4))
              return Array.from(e4);
          }(e3) || function _unsupportedIterableToArray$1(e4, t3) {
            if (!e4)
              return;
            if ("string" == typeof e4)
              return _arrayLikeToArray$1(e4, t3);
            var r3 = Object.prototype.toString.call(e4).slice(8, -1);
            "Object" === r3 && e4.constructor && (r3 = e4.constructor.name);
            if ("Map" === r3 || "Set" === r3)
              return Array.from(e4);
            if ("Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3))
              return _arrayLikeToArray$1(e4, t3);
          }(e3) || function _nonIterableSpread$1() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function _arrayLikeToArray$1(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++) {
            n3[r3] = e3[r3];
          }
          return n3;
        }
        function _typeof3(e3) {
          return (_typeof3 = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function _typeof4(e4) {
            return typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
          } : function _typeof4(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
          })(e3);
        }
        function _classCallCheck(e3, t3) {
          if (!(e3 instanceof t3))
            throw new TypeError("Cannot call a class as a function");
        }
        function _defineProperties(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n3 = t3[r3];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
          }
        }
        function _defineProperty(e3, t3, r3) {
          return t3 in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
        }
        function ownKeys(e3, t3) {
          var r3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var n3 = Object.getOwnPropertySymbols(e3);
            t3 && (n3 = n3.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), r3.push.apply(r3, n3);
          }
          return r3;
        }
        function _objectSpread2(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var r3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? ownKeys(Object(r3), true).forEach(function(t4) {
              _defineProperty(e3, t4, r3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : ownKeys(Object(r3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
            });
          }
          return e3;
        }
        function _slicedToArray(e3, t3) {
          return function _arrayWithHoles(e4) {
            if (Array.isArray(e4))
              return e4;
          }(e3) || function _iterableToArrayLimit(e4, t4) {
            if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e4)))
              return;
            var r3 = [], n3 = true, i3 = false, o3 = void 0;
            try {
              for (var a3, c3 = e4[Symbol.iterator](); !(n3 = (a3 = c3.next()).done) && (r3.push(a3.value), !t4 || r3.length !== t4); n3 = true) {
              }
            } catch (e5) {
              i3 = true, o3 = e5;
            } finally {
              try {
                n3 || null == c3.return || c3.return();
              } finally {
                if (i3)
                  throw o3;
              }
            }
            return r3;
          }(e3, t3) || _unsupportedIterableToArray(e3, t3) || function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function _toConsumableArray(e3) {
          return function _arrayWithoutHoles(e4) {
            if (Array.isArray(e4))
              return _arrayLikeToArray(e4);
          }(e3) || function _iterableToArray(e4) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e4))
              return Array.from(e4);
          }(e3) || _unsupportedIterableToArray(e3) || function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function _unsupportedIterableToArray(e3, t3) {
          if (e3) {
            if ("string" == typeof e3)
              return _arrayLikeToArray(e3, t3);
            var r3 = Object.prototype.toString.call(e3).slice(8, -1);
            return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? _arrayLikeToArray(e3, t3) : void 0;
          }
        }
        function _arrayLikeToArray(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++) {
            n3[r3] = e3[r3];
          }
          return n3;
        }
        var e2 = function TypesonPromise(e3) {
          _classCallCheck(this, TypesonPromise), this.p = new Promise(e3);
        };
        e2.__typeson__type__ = "TypesonPromise", "undefined" != typeof Symbol && (e2.prototype[Symbol.toStringTag] = "TypesonPromise"), e2.prototype.then = function(t3, r3) {
          var n3 = this;
          return new e2(function(e3, i3) {
            n3.p.then(function(r4) {
              e3(t3 ? t3(r4) : r4);
            }).catch(function(e4) {
              return r3 ? r3(e4) : Promise.reject(e4);
            }).then(e3, i3);
          });
        }, e2.prototype.catch = function(e3) {
          return this.then(null, e3);
        }, e2.resolve = function(t3) {
          return new e2(function(e3) {
            e3(t3);
          });
        }, e2.reject = function(t3) {
          return new e2(function(e3, r3) {
            r3(t3);
          });
        }, ["all", "race"].forEach(function(t3) {
          e2[t3] = function(r3) {
            return new e2(function(e3, n3) {
              Promise[t3](r3.map(function(e4) {
                return e4 && e4.constructor && "TypesonPromise" === e4.constructor.__typeson__type__ ? e4.p : e4;
              })).then(e3, n3);
            });
          };
        });
        var t2 = {}.toString, r2 = {}.hasOwnProperty, n2 = Object.getPrototypeOf, i2 = r2.toString;
        function isThenable(e3, t3) {
          return isObject2(e3) && "function" == typeof e3.then && (!t3 || "function" == typeof e3.catch);
        }
        function toStringTag(e3) {
          return t2.call(e3).slice(8, -1);
        }
        function hasConstructorOf(e3, t3) {
          if (!e3 || "object" !== _typeof3(e3))
            return false;
          var o3 = n2(e3);
          if (!o3)
            return null === t3;
          var a3 = r2.call(o3, "constructor") && o3.constructor;
          return "function" != typeof a3 ? null === t3 : t3 === a3 || null !== t3 && i2.call(a3) === i2.call(t3) || "function" == typeof t3 && "string" == typeof a3.__typeson__type__ && a3.__typeson__type__ === t3.__typeson__type__;
        }
        function isPlainObject(e3) {
          return !(!e3 || "Object" !== toStringTag(e3)) && (!n2(e3) || hasConstructorOf(e3, Object));
        }
        function isObject2(e3) {
          return e3 && "object" === _typeof3(e3);
        }
        function escapeKeyPathComponent(e3) {
          return e3.replace(/~/g, "~0").replace(/\./g, "~1");
        }
        function unescapeKeyPathComponent(e3) {
          return e3.replace(/~1/g, ".").replace(/~0/g, "~");
        }
        function getByKeyPath(e3, t3) {
          if ("" === t3)
            return e3;
          var r3 = t3.indexOf(".");
          if (r3 > -1) {
            var n3 = e3[unescapeKeyPathComponent(t3.slice(0, r3))];
            return void 0 === n3 ? void 0 : getByKeyPath(n3, t3.slice(r3 + 1));
          }
          return e3[unescapeKeyPathComponent(t3)];
        }
        function setAtKeyPath(e3, t3, r3) {
          if ("" === t3)
            return r3;
          var n3 = t3.indexOf(".");
          return n3 > -1 ? setAtKeyPath(e3[unescapeKeyPathComponent(t3.slice(0, n3))], t3.slice(n3 + 1), r3) : (e3[unescapeKeyPathComponent(t3)] = r3, e3);
        }
        function _await(e3, t3, r3) {
          return r3 ? t3 ? t3(e3) : e3 : (e3 && e3.then || (e3 = Promise.resolve(e3)), t3 ? e3.then(t3) : e3);
        }
        var o2 = Object.keys, a2 = Array.isArray, c2 = {}.hasOwnProperty, u2 = ["type", "replaced", "iterateIn", "iterateUnsetNumeric"];
        function _async(e3) {
          return function() {
            for (var t3 = [], r3 = 0; r3 < arguments.length; r3++) {
              t3[r3] = arguments[r3];
            }
            try {
              return Promise.resolve(e3.apply(this, t3));
            } catch (e4) {
              return Promise.reject(e4);
            }
          };
        }
        function nestedPathsFirst(e3, t3) {
          if ("" === e3.keypath)
            return -1;
          var r3 = e3.keypath.match(/\./g) || 0, n3 = t3.keypath.match(/\./g) || 0;
          return r3 && (r3 = r3.length), n3 && (n3 = n3.length), r3 > n3 ? -1 : r3 < n3 ? 1 : e3.keypath < t3.keypath ? -1 : e3.keypath > t3.keypath;
        }
        var s2 = function() {
          function Typeson(e3) {
            _classCallCheck(this, Typeson), this.options = e3, this.plainObjectReplacers = [], this.nonplainObjectReplacers = [], this.revivers = {}, this.types = {};
          }
          return function _createClass(e3, t3, r3) {
            return t3 && _defineProperties(e3.prototype, t3), r3 && _defineProperties(e3, r3), e3;
          }(Typeson, [{ key: "stringify", value: function stringify(e3, t3, r3, n3) {
            n3 = _objectSpread2(_objectSpread2(_objectSpread2({}, this.options), n3), {}, { stringification: true });
            var i3 = this.encapsulate(e3, null, n3);
            return a2(i3) ? JSON.stringify(i3[0], t3, r3) : i3.then(function(e4) {
              return JSON.stringify(e4, t3, r3);
            });
          } }, { key: "stringifySync", value: function stringifySync(e3, t3, r3, n3) {
            return this.stringify(e3, t3, r3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, n3), {}, { sync: true }));
          } }, { key: "stringifyAsync", value: function stringifyAsync(e3, t3, r3, n3) {
            return this.stringify(e3, t3, r3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, n3), {}, { sync: false }));
          } }, { key: "parse", value: function parse(e3, t3, r3) {
            return r3 = _objectSpread2(_objectSpread2(_objectSpread2({}, this.options), r3), {}, { parse: true }), this.revive(JSON.parse(e3, t3), r3);
          } }, { key: "parseSync", value: function parseSync(e3, t3, r3) {
            return this.parse(e3, t3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r3), {}, { sync: true }));
          } }, { key: "parseAsync", value: function parseAsync(e3, t3, r3) {
            return this.parse(e3, t3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r3), {}, { sync: false }));
          } }, { key: "specialTypeNames", value: function specialTypeNames(e3, t3) {
            var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return r3.returnTypeNames = true, this.encapsulate(e3, t3, r3);
          } }, { key: "rootTypeName", value: function rootTypeName(e3, t3) {
            var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            return r3.iterateNone = true, this.encapsulate(e3, t3, r3);
          } }, { key: "encapsulate", value: function encapsulate(t3, r3, n3) {
            var i3 = _async(function(t4, r4) {
              return _await(Promise.all(r4.map(function(e3) {
                return e3[1].p;
              })), function(n4) {
                return _await(Promise.all(n4.map(_async(function(n5) {
                  var o3 = false, a3 = [], c3 = _slicedToArray(r4.splice(0, 1), 1), u3 = _slicedToArray(c3[0], 7), s4 = u3[0], f4 = u3[2], l4 = u3[3], p4 = u3[4], y4 = u3[5], v4 = u3[6], b4 = _encapsulate(s4, n5, f4, l4, a3, true, v4), d4 = hasConstructorOf(b4, e2);
                  return function _invoke(e3, t5) {
                    var r5 = e3();
                    return r5 && r5.then ? r5.then(t5) : t5(r5);
                  }(function() {
                    if (s4 && d4)
                      return _await(b4.p, function(e3) {
                        return p4[y4] = e3, o3 = true, i3(t4, a3);
                      });
                  }, function(e3) {
                    return o3 ? e3 : (s4 ? p4[y4] = b4 : t4 = d4 ? b4.p : b4, i3(t4, a3));
                  });
                }))), function() {
                  return t4;
                });
              });
            }), s3 = (n3 = _objectSpread2(_objectSpread2({ sync: true }, this.options), n3)).sync, f3 = this, l3 = {}, p3 = [], y3 = [], v3 = [], b3 = !("cyclic" in n3) || n3.cyclic, d3 = n3.encapsulateObserver, h3 = _encapsulate("", t3, b3, r3 || {}, v3);
            function finish(e3) {
              var t4 = Object.values(l3);
              if (n3.iterateNone)
                return t4.length ? t4[0] : Typeson.getJSONType(e3);
              if (t4.length) {
                if (n3.returnTypeNames)
                  return _toConsumableArray(new Set(t4));
                e3 && isPlainObject(e3) && !c2.call(e3, "$types") ? e3.$types = l3 : e3 = { $: e3, $types: { $: l3 } };
              } else
                isObject2(e3) && c2.call(e3, "$types") && (e3 = { $: e3, $types: true });
              return !n3.returnTypeNames && e3;
            }
            function _adaptBuiltinStateObjectProperties(e3, t4, r4) {
              Object.assign(e3, t4);
              var n4 = u2.map(function(t5) {
                var r5 = e3[t5];
                return delete e3[t5], r5;
              });
              r4(), u2.forEach(function(t5, r5) {
                e3[t5] = n4[r5];
              });
            }
            function _encapsulate(t4, r4, i4, u3, s4, v4, b4) {
              var h4, g3 = {}, m3 = _typeof3(r4), O3 = d3 ? function(n4) {
                var o3 = b4 || u3.type || Typeson.getJSONType(r4);
                d3(Object.assign(n4 || g3, { keypath: t4, value: r4, cyclic: i4, stateObj: u3, promisesData: s4, resolvingTypesonPromise: v4, awaitingTypesonPromise: hasConstructorOf(r4, e2) }, { type: o3 }));
              } : null;
              if (["string", "boolean", "number", "undefined"].includes(m3))
                return void 0 === r4 || Number.isNaN(r4) || r4 === Number.NEGATIVE_INFINITY || r4 === Number.POSITIVE_INFINITY ? (h4 = u3.replaced ? r4 : replace(t4, r4, u3, s4, false, v4, O3)) !== r4 && (g3 = { replaced: h4 }) : h4 = r4, O3 && O3(), h4;
              if (null === r4)
                return O3 && O3(), r4;
              if (i4 && !u3.iterateIn && !u3.iterateUnsetNumeric && r4 && "object" === _typeof3(r4)) {
                var _3 = p3.indexOf(r4);
                if (!(_3 < 0))
                  return l3[t4] = "#", O3 && O3({ cyclicKeypath: y3[_3] }), "#" + y3[_3];
                true === i4 && (p3.push(r4), y3.push(t4));
              }
              var j3, S3 = isPlainObject(r4), T3 = a2(r4), w3 = (S3 || T3) && (!f3.plainObjectReplacers.length || u3.replaced) || u3.iterateIn ? r4 : replace(t4, r4, u3, s4, S3 || T3, null, O3);
              if (w3 !== r4 ? (h4 = w3, g3 = { replaced: w3 }) : "" === t4 && hasConstructorOf(r4, e2) ? (s4.push([t4, r4, i4, u3, void 0, void 0, u3.type]), h4 = r4) : T3 && "object" !== u3.iterateIn || "array" === u3.iterateIn ? (j3 = new Array(r4.length), g3 = { clone: j3 }) : (["function", "symbol"].includes(_typeof3(r4)) || "toJSON" in r4 || hasConstructorOf(r4, e2) || hasConstructorOf(r4, Promise) || hasConstructorOf(r4, ArrayBuffer)) && !S3 && "object" !== u3.iterateIn ? h4 = r4 : (j3 = {}, u3.addLength && (j3.length = r4.length), g3 = { clone: j3 }), O3 && O3(), n3.iterateNone)
                return j3 || h4;
              if (!j3)
                return h4;
              if (u3.iterateIn) {
                var A3 = function _loop(n4) {
                  var o3 = { ownKeys: c2.call(r4, n4) };
                  _adaptBuiltinStateObjectProperties(u3, o3, function() {
                    var o4 = t4 + (t4 ? "." : "") + escapeKeyPathComponent(n4), a3 = _encapsulate(o4, r4[n4], Boolean(i4), u3, s4, v4);
                    hasConstructorOf(a3, e2) ? s4.push([o4, a3, Boolean(i4), u3, j3, n4, u3.type]) : void 0 !== a3 && (j3[n4] = a3);
                  });
                };
                for (var P3 in r4) {
                  A3(P3);
                }
                O3 && O3({ endIterateIn: true, end: true });
              } else
                o2(r4).forEach(function(n4) {
                  var o3 = t4 + (t4 ? "." : "") + escapeKeyPathComponent(n4);
                  _adaptBuiltinStateObjectProperties(u3, { ownKeys: true }, function() {
                    var t5 = _encapsulate(o3, r4[n4], Boolean(i4), u3, s4, v4);
                    hasConstructorOf(t5, e2) ? s4.push([o3, t5, Boolean(i4), u3, j3, n4, u3.type]) : void 0 !== t5 && (j3[n4] = t5);
                  });
                }), O3 && O3({ endIterateOwn: true, end: true });
              if (u3.iterateUnsetNumeric) {
                for (var C3 = r4.length, I3 = function _loop2(n4) {
                  if (!(n4 in r4)) {
                    var o3 = t4 + (t4 ? "." : "") + n4;
                    _adaptBuiltinStateObjectProperties(u3, { ownKeys: false }, function() {
                      var t5 = _encapsulate(o3, void 0, Boolean(i4), u3, s4, v4);
                      hasConstructorOf(t5, e2) ? s4.push([o3, t5, Boolean(i4), u3, j3, n4, u3.type]) : void 0 !== t5 && (j3[n4] = t5);
                    });
                  }
                }, N3 = 0; N3 < C3; N3++) {
                  I3(N3);
                }
                O3 && O3({ endIterateUnsetNumeric: true, end: true });
              }
              return j3;
            }
            function replace(e3, t4, r4, n4, i4, o3, a3) {
              for (var c3 = i4 ? f3.plainObjectReplacers : f3.nonplainObjectReplacers, u3 = c3.length; u3--; ) {
                var p4 = c3[u3];
                if (p4.test(t4, r4)) {
                  var y4 = p4.type;
                  if (f3.revivers[y4]) {
                    var v4 = l3[e3];
                    l3[e3] = v4 ? [y4].concat(v4) : y4;
                  }
                  return Object.assign(r4, { type: y4, replaced: true }), !s3 && p4.replaceAsync || p4.replace ? (a3 && a3({ replacing: true }), _encapsulate(e3, p4[s3 || !p4.replaceAsync ? "replace" : "replaceAsync"](t4, r4), b3 && "readonly", r4, n4, o3, y4)) : (a3 && a3({ typeDetected: true }), _encapsulate(e3, t4, b3 && "readonly", r4, n4, o3, y4));
                }
              }
              return t4;
            }
            return v3.length ? s3 && n3.throwOnBadSyncType ? function() {
              throw new TypeError("Sync method requested but async result obtained");
            }() : Promise.resolve(i3(h3, v3)).then(finish) : !s3 && n3.throwOnBadSyncType ? function() {
              throw new TypeError("Async method requested but sync result obtained");
            }() : n3.stringification && s3 ? [finish(h3)] : s3 ? finish(h3) : Promise.resolve(finish(h3));
          } }, { key: "encapsulateSync", value: function encapsulateSync(e3, t3, r3) {
            return this.encapsulate(e3, t3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r3), {}, { sync: true }));
          } }, { key: "encapsulateAsync", value: function encapsulateAsync(e3, t3, r3) {
            return this.encapsulate(e3, t3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r3), {}, { sync: false }));
          } }, { key: "revive", value: function revive(t3, r3) {
            var n3 = t3 && t3.$types;
            if (!n3)
              return t3;
            if (true === n3)
              return t3.$;
            var i3 = (r3 = _objectSpread2(_objectSpread2({ sync: true }, this.options), r3)).sync, c3 = [], u3 = {}, s3 = true;
            n3.$ && isPlainObject(n3.$) && (t3 = t3.$, n3 = n3.$, s3 = false);
            var l3 = this;
            function executeReviver(e3, t4) {
              var r4 = _slicedToArray(l3.revivers[e3] || [], 1)[0];
              if (!r4)
                throw new Error("Unregistered type: " + e3);
              return i3 && !("revive" in r4) ? t4 : r4[i3 && r4.revive ? "revive" : !i3 && r4.reviveAsync ? "reviveAsync" : "revive"](t4, u3);
            }
            var p3 = [];
            function checkUndefined(e3) {
              return hasConstructorOf(e3, f2) ? void 0 : e3;
            }
            var y3, v3 = function revivePlainObjects() {
              var r4 = [];
              if (Object.entries(n3).forEach(function(e3) {
                var t4 = _slicedToArray(e3, 2), i4 = t4[0], o3 = t4[1];
                "#" !== o3 && [].concat(o3).forEach(function(e4) {
                  _slicedToArray(l3.revivers[e4] || [null, {}], 2)[1].plain && (r4.push({ keypath: i4, type: e4 }), delete n3[i4]);
                });
              }), r4.length)
                return r4.sort(nestedPathsFirst).reduce(function reducer(r5, n4) {
                  var i4 = n4.keypath, o3 = n4.type;
                  if (isThenable(r5))
                    return r5.then(function(e3) {
                      return reducer(e3, { keypath: i4, type: o3 });
                    });
                  var a3 = getByKeyPath(t3, i4);
                  if (hasConstructorOf(a3 = executeReviver(o3, a3), e2))
                    return a3.then(function(e3) {
                      var r6 = setAtKeyPath(t3, i4, e3);
                      r6 === e3 && (t3 = r6);
                    });
                  var c4 = setAtKeyPath(t3, i4, a3);
                  c4 === a3 && (t3 = c4);
                }, void 0);
            }();
            return hasConstructorOf(v3, e2) ? y3 = v3.then(function() {
              return t3;
            }) : (y3 = function _revive(t4, r4, i4, u4, l4) {
              if (!s3 || "$types" !== t4) {
                var y4 = n3[t4], v4 = a2(r4);
                if (v4 || isPlainObject(r4)) {
                  var b3 = v4 ? new Array(r4.length) : {};
                  for (o2(r4).forEach(function(n4) {
                    var o3 = _revive(t4 + (t4 ? "." : "") + escapeKeyPathComponent(n4), r4[n4], i4 || b3, b3, n4), a3 = function set2(e3) {
                      return hasConstructorOf(e3, f2) ? b3[n4] = void 0 : void 0 !== e3 && (b3[n4] = e3), e3;
                    };
                    hasConstructorOf(o3, e2) ? p3.push(o3.then(function(e3) {
                      return a3(e3);
                    })) : a3(o3);
                  }), r4 = b3; c3.length; ) {
                    var d3 = _slicedToArray(c3[0], 4), h3 = d3[0], g3 = d3[1], m3 = d3[2], O3 = d3[3], _3 = getByKeyPath(h3, g3);
                    if (void 0 === _3)
                      break;
                    m3[O3] = _3, c3.splice(0, 1);
                  }
                }
                if (!y4)
                  return r4;
                if ("#" === y4) {
                  var j3 = getByKeyPath(i4, r4.slice(1));
                  return void 0 === j3 && c3.push([i4, r4.slice(1), u4, l4]), j3;
                }
                return [].concat(y4).reduce(function reducer(t5, r5) {
                  return hasConstructorOf(t5, e2) ? t5.then(function(e3) {
                    return reducer(e3, r5);
                  }) : executeReviver(r5, t5);
                }, r4);
              }
            }("", t3, null), p3.length && (y3 = e2.resolve(y3).then(function(t4) {
              return e2.all([t4].concat(p3));
            }).then(function(e3) {
              return _slicedToArray(e3, 1)[0];
            }))), isThenable(y3) ? i3 && r3.throwOnBadSyncType ? function() {
              throw new TypeError("Sync method requested but async result obtained");
            }() : hasConstructorOf(y3, e2) ? y3.p.then(checkUndefined) : y3 : !i3 && r3.throwOnBadSyncType ? function() {
              throw new TypeError("Async method requested but sync result obtained");
            }() : i3 ? checkUndefined(y3) : Promise.resolve(checkUndefined(y3));
          } }, { key: "reviveSync", value: function reviveSync(e3, t3) {
            return this.revive(e3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, t3), {}, { sync: true }));
          } }, { key: "reviveAsync", value: function reviveAsync(e3, t3) {
            return this.revive(e3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, t3), {}, { sync: false }));
          } }, { key: "register", value: function register(e3, t3) {
            return t3 = t3 || {}, [].concat(e3).forEach(function R2(e4) {
              var r3 = this;
              if (a2(e4))
                return e4.map(function(e5) {
                  return R2.call(r3, e5);
                });
              e4 && o2(e4).forEach(function(r4) {
                if ("#" === r4)
                  throw new TypeError("# cannot be used as a type name as it is reserved for cyclic objects");
                if (Typeson.JSON_TYPES.includes(r4))
                  throw new TypeError("Plain JSON object types are reserved as type names");
                var n3 = e4[r4], i3 = n3 && n3.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers, o3 = i3.filter(function(e5) {
                  return e5.type === r4;
                });
                if (o3.length && (i3.splice(i3.indexOf(o3[0]), 1), delete this.revivers[r4], delete this.types[r4]), "function" == typeof n3) {
                  var c3 = n3;
                  n3 = { test: function test(e5) {
                    return e5 && e5.constructor === c3;
                  }, replace: function replace(e5) {
                    return _objectSpread2({}, e5);
                  }, revive: function revive(e5) {
                    return Object.assign(Object.create(c3.prototype), e5);
                  } };
                } else if (a2(n3)) {
                  var u3 = _slicedToArray(n3, 3);
                  n3 = { test: u3[0], replace: u3[1], revive: u3[2] };
                }
                if (n3 && n3.test) {
                  var s3 = { type: r4, test: n3.test.bind(n3) };
                  n3.replace && (s3.replace = n3.replace.bind(n3)), n3.replaceAsync && (s3.replaceAsync = n3.replaceAsync.bind(n3));
                  var f3 = "number" == typeof t3.fallback ? t3.fallback : t3.fallback ? 0 : Number.POSITIVE_INFINITY;
                  if (n3.testPlainObjects ? this.plainObjectReplacers.splice(f3, 0, s3) : this.nonplainObjectReplacers.splice(f3, 0, s3), n3.revive || n3.reviveAsync) {
                    var l3 = {};
                    n3.revive && (l3.revive = n3.revive.bind(n3)), n3.reviveAsync && (l3.reviveAsync = n3.reviveAsync.bind(n3)), this.revivers[r4] = [l3, { plain: n3.testPlainObjects }];
                  }
                  this.types[r4] = n3;
                }
              }, this);
            }, this), this;
          } }]), Typeson;
        }(), f2 = function Undefined() {
          _classCallCheck(this, Undefined);
        };
        f2.__typeson__type__ = "TypesonUndefined", s2.Undefined = f2, s2.Promise = e2, s2.isThenable = isThenable, s2.toStringTag = toStringTag, s2.hasConstructorOf = hasConstructorOf, s2.isObject = isObject2, s2.isPlainObject = isPlainObject, s2.isUserObject = function isUserObject(e3) {
          if (!e3 || "Object" !== toStringTag(e3))
            return false;
          var t3 = n2(e3);
          return !t3 || hasConstructorOf(e3, Object) || isUserObject(t3);
        }, s2.escapeKeyPathComponent = escapeKeyPathComponent, s2.unescapeKeyPathComponent = unescapeKeyPathComponent, s2.getByKeyPath = getByKeyPath, s2.getJSONType = function getJSONType(e3) {
          return null === e3 ? "null" : Array.isArray(e3) ? "array" : _typeof3(e3);
        }, s2.JSON_TYPES = ["null", "boolean", "number", "string", "array", "object"];
        for (var l2 = { userObject: { test: function test(e3, t3) {
          return s2.isUserObject(e3);
        }, replace: function replace(e3) {
          return function _objectSpread2$1(e4) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var r3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? ownKeys$1(Object(r3), true).forEach(function(t4) {
                _defineProperty$1(e4, t4, r3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(r3)) : ownKeys$1(Object(r3)).forEach(function(t4) {
                Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(r3, t4));
              });
            }
            return e4;
          }({}, e3);
        }, revive: function revive(e3) {
          return e3;
        } } }, p2 = [{ arrayNonindexKeys: { testPlainObjects: true, test: function test(e3, t3) {
          return !!Array.isArray(e3) && (Object.keys(e3).some(function(e4) {
            return String(Number.parseInt(e4)) !== e4;
          }) && (t3.iterateIn = "object", t3.addLength = true), true);
        }, replace: function replace(e3, t3) {
          return t3.iterateUnsetNumeric = true, e3;
        }, revive: function revive(e3) {
          if (Array.isArray(e3))
            return e3;
          var t3 = [];
          return Object.keys(e3).forEach(function(r3) {
            var n3 = e3[r3];
            t3[r3] = n3;
          }), t3;
        } } }, { sparseUndefined: { test: function test(e3, t3) {
          return void 0 === e3 && false === t3.ownKeys;
        }, replace: function replace(e3) {
          return 0;
        }, revive: function revive(e3) {
        } } }], y2 = { undef: { test: function test(e3, t3) {
          return void 0 === e3 && (t3.ownKeys || !("ownKeys" in t3));
        }, replace: function replace(e3) {
          return 0;
        }, revive: function revive(e3) {
          return new s2.Undefined();
        } } }, v2 = { StringObject: { test: function test(e3) {
          return "String" === s2.toStringTag(e3) && "object" === _typeof$12(e3);
        }, replace: function replace(e3) {
          return String(e3);
        }, revive: function revive(e3) {
          return new String(e3);
        } }, BooleanObject: { test: function test(e3) {
          return "Boolean" === s2.toStringTag(e3) && "object" === _typeof$12(e3);
        }, replace: function replace(e3) {
          return Boolean(e3);
        }, revive: function revive(e3) {
          return new Boolean(e3);
        } }, NumberObject: { test: function test(e3) {
          return "Number" === s2.toStringTag(e3) && "object" === _typeof$12(e3);
        }, replace: function replace(e3) {
          return Number(e3);
        }, revive: function revive(e3) {
          return new Number(e3);
        } } }, b2 = [{ nan: { test: function test(e3) {
          return Number.isNaN(e3);
        }, replace: function replace(e3) {
          return "NaN";
        }, revive: function revive(e3) {
          return Number.NaN;
        } } }, { infinity: { test: function test(e3) {
          return e3 === Number.POSITIVE_INFINITY;
        }, replace: function replace(e3) {
          return "Infinity";
        }, revive: function revive(e3) {
          return Number.POSITIVE_INFINITY;
        } } }, { negativeInfinity: { test: function test(e3) {
          return e3 === Number.NEGATIVE_INFINITY;
        }, replace: function replace(e3) {
          return "-Infinity";
        }, revive: function revive(e3) {
          return Number.NEGATIVE_INFINITY;
        } } }], d2 = { date: { test: function test(e3) {
          return "Date" === s2.toStringTag(e3);
        }, replace: function replace(e3) {
          var t3 = e3.getTime();
          return Number.isNaN(t3) ? "NaN" : t3;
        }, revive: function revive(e3) {
          return "NaN" === e3 ? new Date(Number.NaN) : new Date(e3);
        } } }, h2 = { regexp: { test: function test(e3) {
          return "RegExp" === s2.toStringTag(e3);
        }, replace: function replace(e3) {
          return { source: e3.source, flags: (e3.global ? "g" : "") + (e3.ignoreCase ? "i" : "") + (e3.multiline ? "m" : "") + (e3.sticky ? "y" : "") + (e3.unicode ? "u" : "") };
        }, revive: function revive(e3) {
          var t3 = e3.source, r3 = e3.flags;
          return new RegExp(t3, r3);
        } } }, g2 = { map: { test: function test(e3) {
          return "Map" === s2.toStringTag(e3);
        }, replace: function replace(e3) {
          return _toConsumableArray$1(e3.entries());
        }, revive: function revive(e3) {
          return new Map(e3);
        } } }, m2 = { set: { test: function test(e3) {
          return "Set" === s2.toStringTag(e3);
        }, replace: function replace(e3) {
          return _toConsumableArray$1(e3.values());
        }, revive: function revive(e3) {
          return new Set(e3);
        } } }, O2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", _2 = new Uint8Array(256), j2 = 0; j2 < O2.length; j2++) {
          _2[O2.charCodeAt(j2)] = j2;
        }
        var S2 = function encode(e3, t3, r3) {
          null == r3 && (r3 = e3.byteLength);
          for (var n3 = new Uint8Array(e3, t3 || 0, r3), i3 = n3.length, o3 = "", a3 = 0; a3 < i3; a3 += 3) {
            o3 += O2[n3[a3] >> 2], o3 += O2[(3 & n3[a3]) << 4 | n3[a3 + 1] >> 4], o3 += O2[(15 & n3[a3 + 1]) << 2 | n3[a3 + 2] >> 6], o3 += O2[63 & n3[a3 + 2]];
          }
          return i3 % 3 == 2 ? o3 = o3.slice(0, -1) + "=" : i3 % 3 == 1 && (o3 = o3.slice(0, -2) + "=="), o3;
        }, T2 = function decode(e3) {
          var t3, r3, n3, i3, o3 = e3.length, a3 = 0.75 * e3.length, c3 = 0;
          "=" === e3[e3.length - 1] && (a3--, "=" === e3[e3.length - 2] && a3--);
          for (var u3 = new ArrayBuffer(a3), s3 = new Uint8Array(u3), f3 = 0; f3 < o3; f3 += 4) {
            t3 = _2[e3.charCodeAt(f3)], r3 = _2[e3.charCodeAt(f3 + 1)], n3 = _2[e3.charCodeAt(f3 + 2)], i3 = _2[e3.charCodeAt(f3 + 3)], s3[c3++] = t3 << 2 | r3 >> 4, s3[c3++] = (15 & r3) << 4 | n3 >> 2, s3[c3++] = (3 & n3) << 6 | 63 & i3;
          }
          return u3;
        }, w2 = { arraybuffer: { test: function test(e3) {
          return "ArrayBuffer" === s2.toStringTag(e3);
        }, replace: function replace(e3, t3) {
          t3.buffers || (t3.buffers = []);
          var r3 = t3.buffers.indexOf(e3);
          return r3 > -1 ? { index: r3 } : (t3.buffers.push(e3), S2(e3));
        }, revive: function revive(e3, t3) {
          if (t3.buffers || (t3.buffers = []), "object" === _typeof$12(e3))
            return t3.buffers[e3.index];
          var r3 = T2(e3);
          return t3.buffers.push(r3), r3;
        } } }, A2 = "undefined" == typeof self ? commonjsGlobal : self, P2 = {};
        ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"].forEach(function(e3) {
          var t3 = e3, r3 = A2[t3];
          r3 && (P2[e3.toLowerCase()] = { test: function test(e4) {
            return s2.toStringTag(e4) === t3;
          }, replace: function replace(e4, t4) {
            var r4 = e4.buffer, n3 = e4.byteOffset, i3 = e4.length;
            t4.buffers || (t4.buffers = []);
            var o3 = t4.buffers.indexOf(r4);
            return o3 > -1 ? { index: o3, byteOffset: n3, length: i3 } : (t4.buffers.push(r4), { encoded: S2(r4), byteOffset: n3, length: i3 });
          }, revive: function revive(e4, t4) {
            t4.buffers || (t4.buffers = []);
            var n3, i3 = e4.byteOffset, o3 = e4.length, a3 = e4.encoded, c3 = e4.index;
            return "index" in e4 ? n3 = t4.buffers[c3] : (n3 = T2(a3), t4.buffers.push(n3)), new r3(n3, i3, o3);
          } });
        });
        var C2 = { dataview: { test: function test(e3) {
          return "DataView" === s2.toStringTag(e3);
        }, replace: function replace(e3, t3) {
          var r3 = e3.buffer, n3 = e3.byteOffset, i3 = e3.byteLength;
          t3.buffers || (t3.buffers = []);
          var o3 = t3.buffers.indexOf(r3);
          return o3 > -1 ? { index: o3, byteOffset: n3, byteLength: i3 } : (t3.buffers.push(r3), { encoded: S2(r3), byteOffset: n3, byteLength: i3 });
        }, revive: function revive(e3, t3) {
          t3.buffers || (t3.buffers = []);
          var r3, n3 = e3.byteOffset, i3 = e3.byteLength, o3 = e3.encoded, a3 = e3.index;
          return "index" in e3 ? r3 = t3.buffers[a3] : (r3 = T2(o3), t3.buffers.push(r3)), new DataView(r3, n3, i3);
        } } }, I2 = { IntlCollator: { test: function test(e3) {
          return s2.hasConstructorOf(e3, Intl.Collator);
        }, replace: function replace(e3) {
          return e3.resolvedOptions();
        }, revive: function revive(e3) {
          return new Intl.Collator(e3.locale, e3);
        } }, IntlDateTimeFormat: { test: function test(e3) {
          return s2.hasConstructorOf(e3, Intl.DateTimeFormat);
        }, replace: function replace(e3) {
          return e3.resolvedOptions();
        }, revive: function revive(e3) {
          return new Intl.DateTimeFormat(e3.locale, e3);
        } }, IntlNumberFormat: { test: function test(e3) {
          return s2.hasConstructorOf(e3, Intl.NumberFormat);
        }, replace: function replace(e3) {
          return e3.resolvedOptions();
        }, revive: function revive(e3) {
          return new Intl.NumberFormat(e3.locale, e3);
        } } };
        function string2arraybuffer(e3) {
          for (var t3 = new Uint8Array(e3.length), r3 = 0; r3 < e3.length; r3++) {
            t3[r3] = e3.charCodeAt(r3);
          }
          return t3.buffer;
        }
        var N2 = { file: { test: function test(e3) {
          return "File" === s2.toStringTag(e3);
        }, replace: function replace(e3) {
          var t3 = new XMLHttpRequest();
          if (t3.overrideMimeType("text/plain; charset=x-user-defined"), t3.open("GET", URL.createObjectURL(e3), false), t3.send(), 200 !== t3.status && 0 !== t3.status)
            throw new Error("Bad File access: " + t3.status);
          return { type: e3.type, stringContents: t3.responseText, name: e3.name, lastModified: e3.lastModified };
        }, revive: function revive(e3) {
          var t3 = e3.name, r3 = e3.type, n3 = e3.stringContents, i3 = e3.lastModified;
          return new File([string2arraybuffer(n3)], t3, { type: r3, lastModified: i3 });
        }, replaceAsync: function replaceAsync(e3) {
          return new s2.Promise(function(t3, r3) {
            var n3 = new FileReader();
            n3.addEventListener("load", function() {
              t3({ type: e3.type, stringContents: n3.result, name: e3.name, lastModified: e3.lastModified });
            }), n3.addEventListener("error", function() {
              r3(n3.error);
            }), n3.readAsBinaryString(e3);
          });
        } } }, k2 = { bigint: { test: function test(e3) {
          return "bigint" == typeof e3;
        }, replace: function replace(e3) {
          return String(e3);
        }, revive: function revive(e3) {
          return BigInt(e3);
        } } }, E2 = { bigintObject: { test: function test(e3) {
          return "object" === _typeof$12(e3) && s2.hasConstructorOf(e3, BigInt);
        }, replace: function replace(e3) {
          return String(e3);
        }, revive: function revive(e3) {
          return new Object(BigInt(e3));
        } } }, B2 = { cryptokey: { test: function test(e3) {
          return "CryptoKey" === s2.toStringTag(e3) && e3.extractable;
        }, replaceAsync: function replaceAsync(e3) {
          return new s2.Promise(function(t3, r3) {
            crypto.subtle.exportKey("jwk", e3).catch(function(e4) {
              r3(e4);
            }).then(function(r4) {
              t3({ jwk: r4, algorithm: e3.algorithm, usages: e3.usages });
            });
          });
        }, revive: function revive(e3) {
          var t3 = e3.jwk, r3 = e3.algorithm, n3 = e3.usages;
          return crypto.subtle.importKey("jwk", t3, r3, true, n3);
        } } };
        return [l2, y2, p2, v2, b2, d2, h2, { imagedata: { test: function test(e3) {
          return "ImageData" === s2.toStringTag(e3);
        }, replace: function replace(e3) {
          return { array: _toConsumableArray$1(e3.data), width: e3.width, height: e3.height };
        }, revive: function revive(e3) {
          return new ImageData(new Uint8ClampedArray(e3.array), e3.width, e3.height);
        } } }, { imagebitmap: { test: function test(e3) {
          return "ImageBitmap" === s2.toStringTag(e3) || e3 && e3.dataset && "ImageBitmap" === e3.dataset.toStringTag;
        }, replace: function replace(e3) {
          var t3 = document.createElement("canvas");
          return t3.getContext("2d").drawImage(e3, 0, 0), t3.toDataURL();
        }, revive: function revive(e3) {
          var t3 = document.createElement("canvas"), r3 = t3.getContext("2d"), n3 = document.createElement("img");
          return n3.addEventListener("load", function() {
            r3.drawImage(n3, 0, 0);
          }), n3.src = e3, t3;
        }, reviveAsync: function reviveAsync(e3) {
          var t3 = document.createElement("canvas"), r3 = t3.getContext("2d"), n3 = document.createElement("img");
          return n3.addEventListener("load", function() {
            r3.drawImage(n3, 0, 0);
          }), n3.src = e3, createImageBitmap(t3);
        } } }, N2, { file: N2.file, filelist: { test: function test(e3) {
          return "FileList" === s2.toStringTag(e3);
        }, replace: function replace(e3) {
          for (var t3 = [], r3 = 0; r3 < e3.length; r3++) {
            t3[r3] = e3.item(r3);
          }
          return t3;
        }, revive: function revive(e3) {
          return new (function() {
            function FileList() {
              _classCallCheck$1(this, FileList), this._files = arguments[0], this.length = this._files.length;
            }
            return function _createClass$1(e4, t3, r3) {
              return t3 && _defineProperties$1(e4.prototype, t3), r3 && _defineProperties$1(e4, r3), e4;
            }(FileList, [{ key: "item", value: function item(e4) {
              return this._files[e4];
            } }, { key: Symbol.toStringTag, get: function get() {
              return "FileList";
            } }]), FileList;
          }())(e3);
        } } }, { blob: { test: function test(e3) {
          return "Blob" === s2.toStringTag(e3);
        }, replace: function replace(e3) {
          var t3 = new XMLHttpRequest();
          if (t3.overrideMimeType("text/plain; charset=x-user-defined"), t3.open("GET", URL.createObjectURL(e3), false), t3.send(), 200 !== t3.status && 0 !== t3.status)
            throw new Error("Bad Blob access: " + t3.status);
          return { type: e3.type, stringContents: t3.responseText };
        }, revive: function revive(e3) {
          var t3 = e3.type, r3 = e3.stringContents;
          return new Blob([string2arraybuffer(r3)], { type: t3 });
        }, replaceAsync: function replaceAsync(e3) {
          return new s2.Promise(function(t3, r3) {
            var n3 = new FileReader();
            n3.addEventListener("load", function() {
              t3({ type: e3.type, stringContents: n3.result });
            }), n3.addEventListener("error", function() {
              r3(n3.error);
            }), n3.readAsBinaryString(e3);
          });
        } } }].concat("function" == typeof Map ? g2 : [], "function" == typeof Set ? m2 : [], "function" == typeof ArrayBuffer ? w2 : [], "function" == typeof Uint8Array ? P2 : [], "function" == typeof DataView ? C2 : [], "undefined" != typeof Intl ? I2 : [], "undefined" != typeof crypto ? B2 : [], "undefined" != typeof BigInt ? [k2, E2] : []).concat({ checkDataCloneException: { test: function test(e3) {
          var t3 = {}.toString.call(e3).slice(8, -1);
          if (["symbol", "function"].includes(_typeof$12(e3)) || ["Arguments", "Module", "Error", "Promise", "WeakMap", "WeakSet", "Event", "MessageChannel"].includes(t3) || e3 && "object" === _typeof$12(e3) && "number" == typeof e3.nodeType && "function" == typeof e3.insertBefore)
            throw new DOMException("The object cannot be cloned.", "DataCloneError");
          return false;
        } } });
      });
    }, {}], 8: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _typeof3(e3) {
        return (_typeof3 = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function(e4) {
          return typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4 === "undefined" ? "undefined" : _typeof2(e4);
        })(e3);
      }
      function _classCallCheck(e3, t3) {
        if (!(e3 instanceof t3))
          throw new TypeError("Cannot call a class as a function");
      }
      function _defineProperties(e3, t3) {
        for (var r3 = 0; r3 < t3.length; r3++) {
          var n3 = t3[r3];
          n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
        }
      }
      function _defineProperty(e3, t3, r3) {
        return t3 in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
      }
      function ownKeys(e3, t3) {
        var r3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e3);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), r3.push.apply(r3, n3);
        }
        return r3;
      }
      function _objectSpread2(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var r3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? ownKeys(Object(r3), true).forEach(function(t4) {
            _defineProperty(e3, t4, r3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : ownKeys(Object(r3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
          });
        }
        return e3;
      }
      function _slicedToArray(e3, t3) {
        return function _arrayWithHoles(e4) {
          if (Array.isArray(e4))
            return e4;
        }(e3) || function _iterableToArrayLimit(e4, t4) {
          if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e4)))
            return;
          var r3 = [], n3 = true, o3 = false, a3 = void 0;
          try {
            for (var i3, c3 = e4[Symbol.iterator](); !(n3 = (i3 = c3.next()).done) && (r3.push(i3.value), !t4 || r3.length !== t4); n3 = true) {
            }
          } catch (e5) {
            o3 = true, a3 = e5;
          } finally {
            try {
              n3 || null == c3.return || c3.return();
            } finally {
              if (o3)
                throw a3;
            }
          }
          return r3;
        }(e3, t3) || _unsupportedIterableToArray(e3, t3) || function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function _toConsumableArray(e3) {
        return function _arrayWithoutHoles(e4) {
          if (Array.isArray(e4))
            return _arrayLikeToArray(e4);
        }(e3) || function _iterableToArray(e4) {
          if ("undefined" != typeof Symbol && Symbol.iterator in Object(e4))
            return Array.from(e4);
        }(e3) || _unsupportedIterableToArray(e3) || function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function _unsupportedIterableToArray(e3, t3) {
        if (e3) {
          if ("string" == typeof e3)
            return _arrayLikeToArray(e3, t3);
          var r3 = Object.prototype.toString.call(e3).slice(8, -1);
          return "Object" === r3 && e3.constructor && (r3 = e3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(e3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? _arrayLikeToArray(e3, t3) : void 0;
        }
      }
      function _arrayLikeToArray(e3, t3) {
        (null == t3 || t3 > e3.length) && (t3 = e3.length);
        for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++) {
          n3[r3] = e3[r3];
        }
        return n3;
      }
      var e2 = function TypesonPromise(e3) {
        _classCallCheck(this, TypesonPromise), this.p = new Promise(e3);
      };
      e2.__typeson__type__ = "TypesonPromise", "undefined" != typeof Symbol && (e2.prototype[Symbol.toStringTag] = "TypesonPromise"), e2.prototype.then = function(t3, r3) {
        var n3 = this;
        return new e2(function(e3, o3) {
          n3.p.then(function(r4) {
            e3(t3 ? t3(r4) : r4);
          }).catch(function(e4) {
            return r3 ? r3(e4) : Promise.reject(e4);
          }).then(e3, o3);
        });
      }, e2.prototype.catch = function(e3) {
        return this.then(null, e3);
      }, e2.resolve = function(t3) {
        return new e2(function(e3) {
          e3(t3);
        });
      }, e2.reject = function(t3) {
        return new e2(function(e3, r3) {
          r3(t3);
        });
      }, ["all", "race", "allSettled"].forEach(function(t3) {
        e2[t3] = function(r3) {
          return new e2(function(e3, n3) {
            Promise[t3](r3.map(function(e4) {
              return e4 && e4.constructor && "TypesonPromise" === e4.constructor.__typeson__type__ ? e4.p : e4;
            })).then(e3, n3);
          });
        };
      });
      var t2 = {}.toString, r2 = {}.hasOwnProperty, n2 = Object.getPrototypeOf, o2 = r2.toString;
      function isThenable(e3, t3) {
        return isObject2(e3) && "function" == typeof e3.then && (!t3 || "function" == typeof e3.catch);
      }
      function toStringTag(e3) {
        return t2.call(e3).slice(8, -1);
      }
      function hasConstructorOf(e3, t3) {
        if (!e3 || "object" !== _typeof3(e3))
          return false;
        var a3 = n2(e3);
        if (!a3)
          return null === t3;
        var i3 = r2.call(a3, "constructor") && a3.constructor;
        return "function" != typeof i3 ? null === t3 : t3 === i3 || null !== t3 && o2.call(i3) === o2.call(t3) || "function" == typeof t3 && "string" == typeof i3.__typeson__type__ && i3.__typeson__type__ === t3.__typeson__type__;
      }
      function isPlainObject(e3) {
        return !(!e3 || "Object" !== toStringTag(e3)) && (!n2(e3) || hasConstructorOf(e3, Object));
      }
      function isObject2(e3) {
        return e3 && "object" === _typeof3(e3);
      }
      function escapeKeyPathComponent(e3) {
        return e3.replace(/~/g, "~0").replace(/\./g, "~1");
      }
      function unescapeKeyPathComponent(e3) {
        return e3.replace(/~1/g, ".").replace(/~0/g, "~");
      }
      function getByKeyPath(e3, t3) {
        if ("" === t3)
          return e3;
        var r3 = t3.indexOf(".");
        if (r3 > -1) {
          var n3 = e3[unescapeKeyPathComponent(t3.slice(0, r3))];
          return void 0 === n3 ? void 0 : getByKeyPath(n3, t3.slice(r3 + 1));
        }
        return e3[unescapeKeyPathComponent(t3)];
      }
      function setAtKeyPath(e3, t3, r3) {
        if ("" === t3)
          return r3;
        var n3 = t3.indexOf(".");
        return n3 > -1 ? setAtKeyPath(e3[unescapeKeyPathComponent(t3.slice(0, n3))], t3.slice(n3 + 1), r3) : (e3[unescapeKeyPathComponent(t3)] = r3, e3);
      }
      function _await(e3, t3, r3) {
        return r3 ? t3 ? t3(e3) : e3 : (e3 && e3.then || (e3 = Promise.resolve(e3)), t3 ? e3.then(t3) : e3);
      }
      var a2 = Object.keys, i2 = Array.isArray, c2 = {}.hasOwnProperty, s2 = ["type", "replaced", "iterateIn", "iterateUnsetNumeric"];
      function _async(e3) {
        return function() {
          for (var t3 = [], r3 = 0; r3 < arguments.length; r3++) {
            t3[r3] = arguments[r3];
          }
          try {
            return Promise.resolve(e3.apply(this, t3));
          } catch (e4) {
            return Promise.reject(e4);
          }
        };
      }
      function nestedPathsFirst(e3, t3) {
        if ("" === e3.keypath)
          return -1;
        var r3 = e3.keypath.match(/\./g) || 0, n3 = t3.keypath.match(/\./g) || 0;
        return r3 && (r3 = r3.length), n3 && (n3 = n3.length), r3 > n3 ? -1 : r3 < n3 ? 1 : e3.keypath < t3.keypath ? -1 : e3.keypath > t3.keypath;
      }
      var u2 = function() {
        function Typeson(e3) {
          _classCallCheck(this, Typeson), this.options = e3, this.plainObjectReplacers = [], this.nonplainObjectReplacers = [], this.revivers = {}, this.types = {};
        }
        return function _createClass(e3, t3, r3) {
          return t3 && _defineProperties(e3.prototype, t3), r3 && _defineProperties(e3, r3), e3;
        }(Typeson, [{ key: "stringify", value: function stringify(e3, t3, r3, n3) {
          n3 = _objectSpread2(_objectSpread2(_objectSpread2({}, this.options), n3), {}, { stringification: true });
          var o3 = this.encapsulate(e3, null, n3);
          return i2(o3) ? JSON.stringify(o3[0], t3, r3) : o3.then(function(e4) {
            return JSON.stringify(e4, t3, r3);
          });
        } }, { key: "stringifySync", value: function stringifySync(e3, t3, r3, n3) {
          return this.stringify(e3, t3, r3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, n3), {}, { sync: true }));
        } }, { key: "stringifyAsync", value: function stringifyAsync(e3, t3, r3, n3) {
          return this.stringify(e3, t3, r3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, n3), {}, { sync: false }));
        } }, { key: "parse", value: function parse(e3, t3, r3) {
          return r3 = _objectSpread2(_objectSpread2(_objectSpread2({}, this.options), r3), {}, { parse: true }), this.revive(JSON.parse(e3, t3), r3);
        } }, { key: "parseSync", value: function parseSync(e3, t3, r3) {
          return this.parse(e3, t3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r3), {}, { sync: true }));
        } }, { key: "parseAsync", value: function parseAsync(e3, t3, r3) {
          return this.parse(e3, t3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r3), {}, { sync: false }));
        } }, { key: "specialTypeNames", value: function specialTypeNames(e3, t3) {
          var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return r3.returnTypeNames = true, this.encapsulate(e3, t3, r3);
        } }, { key: "rootTypeName", value: function rootTypeName(e3, t3) {
          var r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return r3.iterateNone = true, this.encapsulate(e3, t3, r3);
        } }, { key: "encapsulate", value: function encapsulate(t3, r3, n3) {
          var o3 = _async(function(t4, r4) {
            return _await(Promise.all(r4.map(function(e3) {
              return e3[1].p;
            })), function(n4) {
              return _await(Promise.all(n4.map(_async(function(n5) {
                var a3 = false, i3 = [], c3 = _slicedToArray(r4.splice(0, 1), 1), s3 = _slicedToArray(c3[0], 7), u4 = s3[0], p4 = s3[2], y3 = s3[3], l3 = s3[4], f3 = s3[5], h3 = s3[6], v3 = _encapsulate(u4, n5, p4, y3, i3, true, h3), d3 = hasConstructorOf(v3, e2);
                return function _invoke(e3, t5) {
                  var r5 = e3();
                  return r5 && r5.then ? r5.then(t5) : t5(r5);
                }(function() {
                  if (u4 && d3)
                    return _await(v3.p, function(e3) {
                      return l3[f3] = e3, a3 = true, o3(t4, i3);
                    });
                }, function(e3) {
                  return a3 ? e3 : (u4 ? l3[f3] = v3 : t4 = d3 ? v3.p : v3, o3(t4, i3));
                });
              }))), function() {
                return t4;
              });
            });
          }), u3 = (n3 = _objectSpread2(_objectSpread2({ sync: true }, this.options), n3)).sync, p3 = this, y2 = {}, l2 = [], f2 = [], h2 = [], v2 = !("cyclic" in n3) || n3.cyclic, d2 = n3.encapsulateObserver, b2 = _encapsulate("", t3, v2, r3 || {}, h2);
          function finish(e3) {
            var t4 = Object.values(y2);
            if (n3.iterateNone)
              return t4.length ? t4[0] : Typeson.getJSONType(e3);
            if (t4.length) {
              if (n3.returnTypeNames)
                return _toConsumableArray(new Set(t4));
              e3 && isPlainObject(e3) && !c2.call(e3, "$types") ? e3.$types = y2 : e3 = { $: e3, $types: { $: y2 } };
            } else
              isObject2(e3) && c2.call(e3, "$types") && (e3 = { $: e3, $types: true });
            return !n3.returnTypeNames && e3;
          }
          function _adaptBuiltinStateObjectProperties(e3, t4, r4) {
            Object.assign(e3, t4);
            var n4 = s2.map(function(t5) {
              var r5 = e3[t5];
              return delete e3[t5], r5;
            });
            r4(), s2.forEach(function(t5, r5) {
              e3[t5] = n4[r5];
            });
          }
          function _encapsulate(t4, r4, o4, s3, u4, h3, v3) {
            var b3, _2 = {}, O2 = _typeof3(r4), j2 = d2 ? function(n4) {
              var a3 = v3 || s3.type || Typeson.getJSONType(r4);
              d2(Object.assign(n4 || _2, { keypath: t4, value: r4, cyclic: o4, stateObj: s3, promisesData: u4, resolvingTypesonPromise: h3, awaitingTypesonPromise: hasConstructorOf(r4, e2) }, { type: a3 }));
            } : null;
            if (["string", "boolean", "number", "undefined"].includes(O2))
              return void 0 === r4 || Number.isNaN(r4) || r4 === Number.NEGATIVE_INFINITY || r4 === Number.POSITIVE_INFINITY ? (b3 = s3.replaced ? r4 : replace(t4, r4, s3, u4, false, h3, j2)) !== r4 && (_2 = { replaced: b3 }) : b3 = r4, j2 && j2(), b3;
            if (null === r4)
              return j2 && j2(), r4;
            if (o4 && !s3.iterateIn && !s3.iterateUnsetNumeric && r4 && "object" === _typeof3(r4)) {
              var m2 = l2.indexOf(r4);
              if (!(m2 < 0))
                return y2[t4] = "#", j2 && j2({ cyclicKeypath: f2[m2] }), "#" + f2[m2];
              true === o4 && (l2.push(r4), f2.push(t4));
            }
            var S2, g2 = isPlainObject(r4), P2 = i2(r4), T2 = (g2 || P2) && (!p3.plainObjectReplacers.length || s3.replaced) || s3.iterateIn ? r4 : replace(t4, r4, s3, u4, g2 || P2, null, j2);
            if (T2 !== r4 ? (b3 = T2, _2 = { replaced: T2 }) : "" === t4 && hasConstructorOf(r4, e2) ? (u4.push([t4, r4, o4, s3, void 0, void 0, s3.type]), b3 = r4) : P2 && "object" !== s3.iterateIn || "array" === s3.iterateIn ? (S2 = new Array(r4.length), _2 = { clone: S2 }) : (["function", "symbol"].includes(_typeof3(r4)) || "toJSON" in r4 || hasConstructorOf(r4, e2) || hasConstructorOf(r4, Promise) || hasConstructorOf(r4, ArrayBuffer)) && !g2 && "object" !== s3.iterateIn ? b3 = r4 : (S2 = {}, s3.addLength && (S2.length = r4.length), _2 = { clone: S2 }), j2 && j2(), n3.iterateNone)
              return S2 || b3;
            if (!S2)
              return b3;
            if (s3.iterateIn) {
              var w2 = function _loop(n4) {
                var a3 = { ownKeys: c2.call(r4, n4) };
                _adaptBuiltinStateObjectProperties(s3, a3, function() {
                  var a4 = t4 + (t4 ? "." : "") + escapeKeyPathComponent(n4), i3 = _encapsulate(a4, r4[n4], Boolean(o4), s3, u4, h3);
                  hasConstructorOf(i3, e2) ? u4.push([a4, i3, Boolean(o4), s3, S2, n4, s3.type]) : void 0 !== i3 && (S2[n4] = i3);
                });
              };
              for (var A2 in r4) {
                w2(A2);
              }
              j2 && j2({ endIterateIn: true, end: true });
            } else
              a2(r4).forEach(function(n4) {
                var a3 = t4 + (t4 ? "." : "") + escapeKeyPathComponent(n4);
                _adaptBuiltinStateObjectProperties(s3, { ownKeys: true }, function() {
                  var t5 = _encapsulate(a3, r4[n4], Boolean(o4), s3, u4, h3);
                  hasConstructorOf(t5, e2) ? u4.push([a3, t5, Boolean(o4), s3, S2, n4, s3.type]) : void 0 !== t5 && (S2[n4] = t5);
                });
              }), j2 && j2({ endIterateOwn: true, end: true });
            if (s3.iterateUnsetNumeric) {
              for (var C2 = r4.length, k2 = function _loop2(n4) {
                if (!(n4 in r4)) {
                  var a3 = t4 + (t4 ? "." : "") + n4;
                  _adaptBuiltinStateObjectProperties(s3, { ownKeys: false }, function() {
                    var t5 = _encapsulate(a3, void 0, Boolean(o4), s3, u4, h3);
                    hasConstructorOf(t5, e2) ? u4.push([a3, t5, Boolean(o4), s3, S2, n4, s3.type]) : void 0 !== t5 && (S2[n4] = t5);
                  });
                }
              }, N2 = 0; N2 < C2; N2++) {
                k2(N2);
              }
              j2 && j2({ endIterateUnsetNumeric: true, end: true });
            }
            return S2;
          }
          function replace(e3, t4, r4, n4, o4, a3, i3) {
            for (var c3 = o4 ? p3.plainObjectReplacers : p3.nonplainObjectReplacers, s3 = c3.length; s3--; ) {
              var l3 = c3[s3];
              if (l3.test(t4, r4)) {
                var f3 = l3.type;
                if (p3.revivers[f3]) {
                  var h3 = y2[e3];
                  y2[e3] = h3 ? [f3].concat(h3) : f3;
                }
                return Object.assign(r4, { type: f3, replaced: true }), !u3 && l3.replaceAsync || l3.replace ? (i3 && i3({ replacing: true }), _encapsulate(e3, l3[u3 || !l3.replaceAsync ? "replace" : "replaceAsync"](t4, r4), v2 && "readonly", r4, n4, a3, f3)) : (i3 && i3({ typeDetected: true }), _encapsulate(e3, t4, v2 && "readonly", r4, n4, a3, f3));
              }
            }
            return t4;
          }
          return h2.length ? u3 && n3.throwOnBadSyncType ? function() {
            throw new TypeError("Sync method requested but async result obtained");
          }() : Promise.resolve(o3(b2, h2)).then(finish) : !u3 && n3.throwOnBadSyncType ? function() {
            throw new TypeError("Async method requested but sync result obtained");
          }() : n3.stringification && u3 ? [finish(b2)] : u3 ? finish(b2) : Promise.resolve(finish(b2));
        } }, { key: "encapsulateSync", value: function encapsulateSync(e3, t3, r3) {
          return this.encapsulate(e3, t3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r3), {}, { sync: true }));
        } }, { key: "encapsulateAsync", value: function encapsulateAsync(e3, t3, r3) {
          return this.encapsulate(e3, t3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, r3), {}, { sync: false }));
        } }, { key: "revive", value: function revive(t3, r3) {
          var n3 = t3 && t3.$types;
          if (!n3)
            return t3;
          if (true === n3)
            return t3.$;
          var o3 = (r3 = _objectSpread2(_objectSpread2({ sync: true }, this.options), r3)).sync, c3 = [], s3 = {}, u3 = true;
          n3.$ && isPlainObject(n3.$) && (t3 = t3.$, n3 = n3.$, u3 = false);
          var y2 = this;
          function executeReviver(e3, t4) {
            var r4 = _slicedToArray(y2.revivers[e3] || [], 1)[0];
            if (!r4)
              throw new Error("Unregistered type: " + e3);
            return o3 && !("revive" in r4) ? t4 : r4[o3 && r4.revive ? "revive" : !o3 && r4.reviveAsync ? "reviveAsync" : "revive"](t4, s3);
          }
          var l2 = [];
          function checkUndefined(e3) {
            return hasConstructorOf(e3, p2) ? void 0 : e3;
          }
          var f2, h2 = function revivePlainObjects() {
            var r4 = [];
            if (Object.entries(n3).forEach(function(e3) {
              var t4 = _slicedToArray(e3, 2), o4 = t4[0], a3 = t4[1];
              "#" !== a3 && [].concat(a3).forEach(function(e4) {
                _slicedToArray(y2.revivers[e4] || [null, {}], 2)[1].plain && (r4.push({ keypath: o4, type: e4 }), delete n3[o4]);
              });
            }), r4.length)
              return r4.sort(nestedPathsFirst).reduce(function reducer(r5, n4) {
                var o4 = n4.keypath, a3 = n4.type;
                if (isThenable(r5))
                  return r5.then(function(e3) {
                    return reducer(e3, { keypath: o4, type: a3 });
                  });
                var i3 = getByKeyPath(t3, o4);
                if (hasConstructorOf(i3 = executeReviver(a3, i3), e2))
                  return i3.then(function(e3) {
                    var r6 = setAtKeyPath(t3, o4, e3);
                    r6 === e3 && (t3 = r6);
                  });
                var c4 = setAtKeyPath(t3, o4, i3);
                c4 === i3 && (t3 = c4);
              }, void 0);
          }();
          return hasConstructorOf(h2, e2) ? f2 = h2.then(function() {
            return t3;
          }) : (f2 = function _revive(t4, r4, o4, s4, y3) {
            if (!u3 || "$types" !== t4) {
              var f3 = n3[t4], h3 = i2(r4);
              if (h3 || isPlainObject(r4)) {
                var v2 = h3 ? new Array(r4.length) : {};
                for (a2(r4).forEach(function(n4) {
                  var a3 = _revive(t4 + (t4 ? "." : "") + escapeKeyPathComponent(n4), r4[n4], o4 || v2, v2, n4), i3 = function set2(e3) {
                    return hasConstructorOf(e3, p2) ? v2[n4] = void 0 : void 0 !== e3 && (v2[n4] = e3), e3;
                  };
                  hasConstructorOf(a3, e2) ? l2.push(a3.then(function(e3) {
                    return i3(e3);
                  })) : i3(a3);
                }), r4 = v2; c3.length; ) {
                  var d2 = _slicedToArray(c3[0], 4), b2 = d2[0], _2 = d2[1], O2 = d2[2], j2 = d2[3], m2 = getByKeyPath(b2, _2);
                  if (void 0 === m2)
                    break;
                  O2[j2] = m2, c3.splice(0, 1);
                }
              }
              if (!f3)
                return r4;
              if ("#" === f3) {
                var S2 = getByKeyPath(o4, r4.slice(1));
                return void 0 === S2 && c3.push([o4, r4.slice(1), s4, y3]), S2;
              }
              return [].concat(f3).reduce(function reducer(t5, r5) {
                return hasConstructorOf(t5, e2) ? t5.then(function(e3) {
                  return reducer(e3, r5);
                }) : executeReviver(r5, t5);
              }, r4);
            }
          }("", t3, null), l2.length && (f2 = e2.resolve(f2).then(function(t4) {
            return e2.all([t4].concat(l2));
          }).then(function(e3) {
            return _slicedToArray(e3, 1)[0];
          }))), isThenable(f2) ? o3 && r3.throwOnBadSyncType ? function() {
            throw new TypeError("Sync method requested but async result obtained");
          }() : hasConstructorOf(f2, e2) ? f2.p.then(checkUndefined) : f2 : !o3 && r3.throwOnBadSyncType ? function() {
            throw new TypeError("Async method requested but sync result obtained");
          }() : o3 ? checkUndefined(f2) : Promise.resolve(checkUndefined(f2));
        } }, { key: "reviveSync", value: function reviveSync(e3, t3) {
          return this.revive(e3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, t3), {}, { sync: true }));
        } }, { key: "reviveAsync", value: function reviveAsync(e3, t3) {
          return this.revive(e3, _objectSpread2(_objectSpread2({ throwOnBadSyncType: true }, t3), {}, { sync: false }));
        } }, { key: "register", value: function register(e3, t3) {
          return t3 = t3 || {}, [].concat(e3).forEach(function R2(e4) {
            var r3 = this;
            if (i2(e4))
              return e4.map(function(e5) {
                return R2.call(r3, e5);
              });
            e4 && a2(e4).forEach(function(r4) {
              if ("#" === r4)
                throw new TypeError("# cannot be used as a type name as it is reserved for cyclic objects");
              if (Typeson.JSON_TYPES.includes(r4))
                throw new TypeError("Plain JSON object types are reserved as type names");
              var n3 = e4[r4], o3 = n3 && n3.testPlainObjects ? this.plainObjectReplacers : this.nonplainObjectReplacers, a3 = o3.filter(function(e5) {
                return e5.type === r4;
              });
              if (a3.length && (o3.splice(o3.indexOf(a3[0]), 1), delete this.revivers[r4], delete this.types[r4]), "function" == typeof n3) {
                var c3 = n3;
                n3 = { test: function test(e5) {
                  return e5 && e5.constructor === c3;
                }, replace: function replace(e5) {
                  return _objectSpread2({}, e5);
                }, revive: function revive(e5) {
                  return Object.assign(Object.create(c3.prototype), e5);
                } };
              } else if (i2(n3)) {
                var s3 = _slicedToArray(n3, 3);
                n3 = { test: s3[0], replace: s3[1], revive: s3[2] };
              }
              if (n3 && n3.test) {
                var u3 = { type: r4, test: n3.test.bind(n3) };
                n3.replace && (u3.replace = n3.replace.bind(n3)), n3.replaceAsync && (u3.replaceAsync = n3.replaceAsync.bind(n3));
                var p3 = "number" == typeof t3.fallback ? t3.fallback : t3.fallback ? 0 : Number.POSITIVE_INFINITY;
                if (n3.testPlainObjects ? this.plainObjectReplacers.splice(p3, 0, u3) : this.nonplainObjectReplacers.splice(p3, 0, u3), n3.revive || n3.reviveAsync) {
                  var y2 = {};
                  n3.revive && (y2.revive = n3.revive.bind(n3)), n3.reviveAsync && (y2.reviveAsync = n3.reviveAsync.bind(n3)), this.revivers[r4] = [y2, { plain: n3.testPlainObjects }];
                }
                this.types[r4] = n3;
              }
            }, this);
          }, this), this;
        } }]), Typeson;
      }(), p2 = function Undefined() {
        _classCallCheck(this, Undefined);
      };
      p2.__typeson__type__ = "TypesonUndefined", u2.Undefined = p2, u2.Promise = e2, u2.isThenable = isThenable, u2.toStringTag = toStringTag, u2.hasConstructorOf = hasConstructorOf, u2.isObject = isObject2, u2.isPlainObject = isPlainObject, u2.isUserObject = function isUserObject(e3) {
        if (!e3 || "Object" !== toStringTag(e3))
          return false;
        var t3 = n2(e3);
        return !t3 || hasConstructorOf(e3, Object) || isUserObject(t3);
      }, u2.escapeKeyPathComponent = escapeKeyPathComponent, u2.unescapeKeyPathComponent = unescapeKeyPathComponent, u2.getByKeyPath = getByKeyPath, u2.getJSONType = function getJSONType(e3) {
        return null === e3 ? "null" : Array.isArray(e3) ? "array" : _typeof3(e3);
      }, u2.JSON_TYPES = ["null", "boolean", "number", "string", "array", "object"], module2.exports = u2;
    }, {}], 9: [function(_dereq_, module2, exports2) {
      var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _2(message, opts) {
        return (opts && opts.context ? opts.context : "Value") + " " + message + ".";
      }
      function type2(V2) {
        if (V2 === null) {
          return "Null";
        }
        switch (typeof V2 === "undefined" ? "undefined" : _typeof2(V2)) {
          case "undefined":
            return "Undefined";
          case "boolean":
            return "Boolean";
          case "number":
            return "Number";
          case "string":
            return "String";
          case "symbol":
            return "Symbol";
          case "object":
          case "function":
          default:
            return "Object";
        }
      }
      function evenRound(x2) {
        if (x2 > 0 && x2 % 1 === 0.5 && (x2 & 1) === 0 || x2 < 0 && x2 % 1 === -0.5 && (x2 & 1) === 1) {
          return censorNegativeZero(Math.floor(x2));
        }
        return censorNegativeZero(Math.round(x2));
      }
      function integerPart(n2) {
        return censorNegativeZero(Math.trunc(n2));
      }
      function sign(x2) {
        return x2 < 0 ? -1 : 1;
      }
      function modulo(x2, y2) {
        var signMightNotMatch = x2 % y2;
        if (sign(y2) !== sign(signMightNotMatch)) {
          return signMightNotMatch + y2;
        }
        return signMightNotMatch;
      }
      function censorNegativeZero(x2) {
        return x2 === 0 ? 0 : x2;
      }
      function createIntegerConversion(bitLength, typeOpts) {
        var isSigned = !typeOpts.unsigned;
        var lowerBound2 = void 0;
        var upperBound = void 0;
        if (bitLength === 64) {
          upperBound = Math.pow(2, 53) - 1;
          lowerBound2 = !isSigned ? 0 : -Math.pow(2, 53) + 1;
        } else if (!isSigned) {
          lowerBound2 = 0;
          upperBound = Math.pow(2, bitLength) - 1;
        } else {
          lowerBound2 = -Math.pow(2, bitLength - 1);
          upperBound = Math.pow(2, bitLength - 1) - 1;
        }
        var twoToTheBitLength = Math.pow(2, bitLength);
        var twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);
        return function(V2, opts) {
          if (opts === void 0) {
            opts = {};
          }
          var x2 = +V2;
          x2 = censorNegativeZero(x2);
          if (opts.enforceRange) {
            if (!Number.isFinite(x2)) {
              throw new TypeError(_2("is not a finite number", opts));
            }
            x2 = integerPart(x2);
            if (x2 < lowerBound2 || x2 > upperBound) {
              throw new TypeError(_2("is outside the accepted range of " + lowerBound2 + " to " + upperBound + ", inclusive", opts));
            }
            return x2;
          }
          if (!Number.isNaN(x2) && opts.clamp) {
            x2 = Math.min(Math.max(x2, lowerBound2), upperBound);
            x2 = evenRound(x2);
            return x2;
          }
          if (!Number.isFinite(x2) || x2 === 0) {
            return 0;
          }
          x2 = integerPart(x2);
          if (x2 >= lowerBound2 && x2 <= upperBound) {
            return x2;
          }
          x2 = modulo(x2, twoToTheBitLength);
          if (isSigned && x2 >= twoToOneLessThanTheBitLength) {
            return x2 - twoToTheBitLength;
          }
          return x2;
        };
      }
      exports2.any = function(V2) {
        return V2;
      };
      exports2.void = function() {
        return void 0;
      };
      exports2.boolean = function(val) {
        return !!val;
      };
      exports2.byte = createIntegerConversion(8, { unsigned: false });
      exports2.octet = createIntegerConversion(8, { unsigned: true });
      exports2.short = createIntegerConversion(16, { unsigned: false });
      exports2["unsigned short"] = createIntegerConversion(16, { unsigned: true });
      exports2.long = createIntegerConversion(32, { unsigned: false });
      exports2["unsigned long"] = createIntegerConversion(32, { unsigned: true });
      exports2["long long"] = createIntegerConversion(64, { unsigned: false });
      exports2["unsigned long long"] = createIntegerConversion(64, { unsigned: true });
      exports2.double = function(V2, opts) {
        var x2 = +V2;
        if (!Number.isFinite(x2)) {
          throw new TypeError(_2("is not a finite floating-point value", opts));
        }
        return x2;
      };
      exports2["unrestricted double"] = function(V2) {
        var x2 = +V2;
        return x2;
      };
      exports2.float = function(V2, opts) {
        var x2 = +V2;
        if (!Number.isFinite(x2)) {
          throw new TypeError(_2("is not a finite floating-point value", opts));
        }
        if (Object.is(x2, -0)) {
          return x2;
        }
        var y2 = Math.fround(x2);
        if (!Number.isFinite(y2)) {
          throw new TypeError(_2("is outside the range of a single-precision floating-point value", opts));
        }
        return y2;
      };
      exports2["unrestricted float"] = function(V2) {
        var x2 = +V2;
        if (isNaN(x2)) {
          return x2;
        }
        if (Object.is(x2, -0)) {
          return x2;
        }
        return Math.fround(x2);
      };
      exports2.DOMString = function(V2, opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (opts.treatNullAsEmptyString && V2 === null) {
          return "";
        }
        if ((typeof V2 === "undefined" ? "undefined" : _typeof2(V2)) === "symbol") {
          throw new TypeError(_2("is a symbol, which cannot be converted to a string", opts));
        }
        return String(V2);
      };
      exports2.ByteString = function(V2, opts) {
        var x2 = exports2.DOMString(V2, opts);
        var c2 = void 0;
        for (var i2 = 0; (c2 = x2.codePointAt(i2)) !== void 0; ++i2) {
          if (c2 > 255) {
            throw new TypeError(_2("is not a valid ByteString", opts));
          }
        }
        return x2;
      };
      exports2.USVString = function(V2, opts) {
        var S2 = exports2.DOMString(V2, opts);
        var n2 = S2.length;
        var U2 = [];
        for (var i2 = 0; i2 < n2; ++i2) {
          var c2 = S2.charCodeAt(i2);
          if (c2 < 55296 || c2 > 57343) {
            U2.push(String.fromCodePoint(c2));
          } else if (56320 <= c2 && c2 <= 57343) {
            U2.push(String.fromCodePoint(65533));
          } else if (i2 === n2 - 1) {
            U2.push(String.fromCodePoint(65533));
          } else {
            var d2 = S2.charCodeAt(i2 + 1);
            if (56320 <= d2 && d2 <= 57343) {
              var a2 = c2 & 1023;
              var b2 = d2 & 1023;
              U2.push(String.fromCodePoint((2 << 15) + (2 << 9) * a2 + b2));
              ++i2;
            } else {
              U2.push(String.fromCodePoint(65533));
            }
          }
        }
        return U2.join("");
      };
      exports2.object = function(V2, opts) {
        if (type2(V2) !== "Object") {
          throw new TypeError(_2("is not an object", opts));
        }
        return V2;
      };
      function convertCallbackFunction(V2, opts) {
        if (typeof V2 !== "function") {
          throw new TypeError(_2("is not a function", opts));
        }
        return V2;
      }
      [
        Error,
        ArrayBuffer,
        // The IsDetachedBuffer abstract operation is not exposed in JS
        DataView,
        Int8Array,
        Int16Array,
        Int32Array,
        Uint8Array,
        Uint16Array,
        Uint32Array,
        Uint8ClampedArray,
        Float32Array,
        Float64Array
      ].forEach(function(func) {
        var name = func.name;
        var article = /^[AEIOU]/.test(name) ? "an" : "a";
        exports2[name] = function(V2, opts) {
          if (!(V2 instanceof func)) {
            throw new TypeError(_2("is not " + article + " " + name + " object", opts));
          }
          return V2;
        };
      });
      exports2.ArrayBufferView = function(V2, opts) {
        if (!ArrayBuffer.isView(V2)) {
          throw new TypeError(_2("is not a view on an ArrayBuffer object", opts));
        }
        return V2;
      };
      exports2.BufferSource = function(V2, opts) {
        if (!(ArrayBuffer.isView(V2) || V2 instanceof ArrayBuffer)) {
          throw new TypeError(_2("is not an ArrayBuffer object or a view on one", opts));
        }
        return V2;
      };
      exports2.DOMTimeStamp = exports2["unsigned long long"];
      exports2.Function = convertCallbackFunction;
      exports2.VoidFunction = convertCallbackFunction;
    }, {}] }, {}, [1])(1);
  });
})(dist);
var distExports = dist.exports;
const realisticStructuredClone = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
const structuredCloneWrapper = (input) => {
  if (typeof structuredClone !== "undefined") {
    return structuredClone(input);
  }
  try {
    return realisticStructuredClone(input);
  } catch (err) {
    throw new DataCloneError();
  }
};
const getEffectiveObjectStore = (cursor2) => {
  if (cursor2.source instanceof FDBObjectStore$1) {
    return cursor2.source;
  }
  return cursor2.source.objectStore;
};
const makeKeyRange = (range2, lowers, uppers) => {
  let lower = range2 !== void 0 ? range2.lower : void 0;
  let upper = range2 !== void 0 ? range2.upper : void 0;
  for (const lowerTemp of lowers) {
    if (lowerTemp === void 0) {
      continue;
    }
    if (lower === void 0 || cmp(lower, lowerTemp) === 1) {
      lower = lowerTemp;
    }
  }
  for (const upperTemp of uppers) {
    if (upperTemp === void 0) {
      continue;
    }
    if (upper === void 0 || cmp(upper, upperTemp) === -1) {
      upper = upperTemp;
    }
  }
  if (lower !== void 0 && upper !== void 0) {
    return FDBKeyRange.bound(lower, upper);
  }
  if (lower !== void 0) {
    return FDBKeyRange.lowerBound(lower);
  }
  if (upper !== void 0) {
    return FDBKeyRange.upperBound(upper);
  }
};
class FDBCursor {
  _gotValue = false;
  _position = void 0;
  // Key of previously returned record
  _objectStorePosition = void 0;
  _keyOnly = false;
  _key = void 0;
  _primaryKey = void 0;
  constructor(source, range2, direction = "next", request, keyOnly = false) {
    this._range = range2;
    this._source = source;
    this._direction = direction;
    this._request = request;
    this._keyOnly = keyOnly;
  }
  // Read only properties
  get source() {
    return this._source;
  }
  set source(val) {
  }
  get request() {
    return this._request;
  }
  set request(val) {
  }
  get direction() {
    return this._direction;
  }
  set direction(val) {
  }
  get key() {
    return this._key;
  }
  set key(val) {
  }
  get primaryKey() {
    return this._primaryKey;
  }
  set primaryKey(val) {
  }
  // https://w3c.github.io/IndexedDB/#iterate-a-cursor
  _iterate(key, primaryKey) {
    const sourceIsObjectStore = this.source instanceof FDBObjectStore$1;
    const records = this.source instanceof FDBObjectStore$1 ? this.source._rawObjectStore.records : this.source._rawIndex.records;
    let foundRecord;
    if (this.direction === "next") {
      const range2 = makeKeyRange(this._range, [key, this._position], []);
      for (const record of records.values(range2)) {
        const cmpResultKey = key !== void 0 ? cmp(record.key, key) : void 0;
        const cmpResultPosition = this._position !== void 0 ? cmp(record.key, this._position) : void 0;
        if (key !== void 0) {
          if (cmpResultKey === -1) {
            continue;
          }
        }
        if (primaryKey !== void 0) {
          if (cmpResultKey === -1) {
            continue;
          }
          const cmpResultPrimaryKey = cmp(record.value, primaryKey);
          if (cmpResultKey === 0 && cmpResultPrimaryKey === -1) {
            continue;
          }
        }
        if (this._position !== void 0 && sourceIsObjectStore) {
          if (cmpResultPosition !== 1) {
            continue;
          }
        }
        if (this._position !== void 0 && !sourceIsObjectStore) {
          if (cmpResultPosition === -1) {
            continue;
          }
          if (cmpResultPosition === 0 && cmp(record.value, this._objectStorePosition) !== 1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        foundRecord = record;
        break;
      }
    } else if (this.direction === "nextunique") {
      const range2 = makeKeyRange(this._range, [key, this._position], []);
      for (const record of records.values(range2)) {
        if (key !== void 0) {
          if (cmp(record.key, key) === -1) {
            continue;
          }
        }
        if (this._position !== void 0) {
          if (cmp(record.key, this._position) !== 1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        foundRecord = record;
        break;
      }
    } else if (this.direction === "prev") {
      const range2 = makeKeyRange(this._range, [], [key, this._position]);
      for (const record of records.values(range2, "prev")) {
        const cmpResultKey = key !== void 0 ? cmp(record.key, key) : void 0;
        const cmpResultPosition = this._position !== void 0 ? cmp(record.key, this._position) : void 0;
        if (key !== void 0) {
          if (cmpResultKey === 1) {
            continue;
          }
        }
        if (primaryKey !== void 0) {
          if (cmpResultKey === 1) {
            continue;
          }
          const cmpResultPrimaryKey = cmp(record.value, primaryKey);
          if (cmpResultKey === 0 && cmpResultPrimaryKey === 1) {
            continue;
          }
        }
        if (this._position !== void 0 && sourceIsObjectStore) {
          if (cmpResultPosition !== -1) {
            continue;
          }
        }
        if (this._position !== void 0 && !sourceIsObjectStore) {
          if (cmpResultPosition === 1) {
            continue;
          }
          if (cmpResultPosition === 0 && cmp(record.value, this._objectStorePosition) !== -1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        foundRecord = record;
        break;
      }
    } else if (this.direction === "prevunique") {
      let tempRecord;
      const range2 = makeKeyRange(this._range, [], [key, this._position]);
      for (const record of records.values(range2, "prev")) {
        if (key !== void 0) {
          if (cmp(record.key, key) === 1) {
            continue;
          }
        }
        if (this._position !== void 0) {
          if (cmp(record.key, this._position) !== -1) {
            continue;
          }
        }
        if (this._range !== void 0) {
          if (!this._range.includes(record.key)) {
            continue;
          }
        }
        tempRecord = record;
        break;
      }
      if (tempRecord) {
        foundRecord = records.get(tempRecord.key);
      }
    }
    let result;
    if (!foundRecord) {
      this._key = void 0;
      if (!sourceIsObjectStore) {
        this._objectStorePosition = void 0;
      }
      if (!this._keyOnly && this.toString() === "[object IDBCursorWithValue]") {
        this.value = void 0;
      }
      result = null;
    } else {
      this._position = foundRecord.key;
      if (!sourceIsObjectStore) {
        this._objectStorePosition = foundRecord.value;
      }
      this._key = foundRecord.key;
      if (sourceIsObjectStore) {
        this._primaryKey = structuredCloneWrapper(foundRecord.key);
        if (!this._keyOnly && this.toString() === "[object IDBCursorWithValue]") {
          this.value = structuredCloneWrapper(foundRecord.value);
        }
      } else {
        this._primaryKey = structuredCloneWrapper(foundRecord.value);
        if (!this._keyOnly && this.toString() === "[object IDBCursorWithValue]") {
          if (this.source instanceof FDBObjectStore$1) {
            throw new Error("This should never happen");
          }
          const value = this.source.objectStore._rawObjectStore.getValue(foundRecord.value);
          this.value = structuredCloneWrapper(value);
        }
      }
      this._gotValue = true;
      result = this;
    }
    return result;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-update-IDBRequest-any-value
  update(value) {
    if (value === void 0) {
      throw new TypeError();
    }
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const effectiveKey = this.source.hasOwnProperty("_rawIndex") ? this.primaryKey : this._position;
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue || !this.hasOwnProperty("value")) {
      throw new InvalidStateError();
    }
    const clone2 = structuredCloneWrapper(value);
    if (effectiveObjectStore.keyPath !== null) {
      let tempKey;
      try {
        tempKey = extractKey(effectiveObjectStore.keyPath, clone2);
      } catch (err) {
      }
      if (cmp(tempKey, effectiveKey) !== 0) {
        throw new DataError();
      }
    }
    const record = {
      key: effectiveKey,
      value: clone2
    };
    return transaction._execRequestAsync({
      operation: effectiveObjectStore._rawObjectStore.storeRecord.bind(effectiveObjectStore._rawObjectStore, record, false, transaction._rollbackLog),
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-advance-void-unsigned-long-count
  advance(count2) {
    if (!Number.isInteger(count2) || count2 <= 0) {
      throw new TypeError();
    }
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue) {
      throw new InvalidStateError();
    }
    if (this._request) {
      this._request.readyState = "pending";
    }
    transaction._execRequestAsync({
      operation: () => {
        let result;
        for (let i2 = 0; i2 < count2; i2++) {
          result = this._iterate();
          if (!result) {
            break;
          }
        }
        return result;
      },
      request: this._request,
      source: this.source
    });
    this._gotValue = false;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-continue-void-any-key
  continue(key) {
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue) {
      throw new InvalidStateError();
    }
    if (key !== void 0) {
      key = valueToKey(key);
      const cmpResult = cmp(key, this._position);
      if (cmpResult <= 0 && (this.direction === "next" || this.direction === "nextunique") || cmpResult >= 0 && (this.direction === "prev" || this.direction === "prevunique")) {
        throw new DataError();
      }
    }
    if (this._request) {
      this._request.readyState = "pending";
    }
    transaction._execRequestAsync({
      operation: this._iterate.bind(this, key),
      request: this._request,
      source: this.source
    });
    this._gotValue = false;
  }
  // hthttps://w3c.github.io/IndexedDB/#dom-idbcursor-continueprimarykey
  continuePrimaryKey(key, primaryKey) {
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (this.source instanceof FDBObjectStore$1 || this.direction !== "next" && this.direction !== "prev") {
      throw new InvalidAccessError();
    }
    if (!this._gotValue) {
      throw new InvalidStateError();
    }
    if (key === void 0 || primaryKey === void 0) {
      throw new DataError();
    }
    key = valueToKey(key);
    const cmpResult = cmp(key, this._position);
    if (cmpResult === -1 && this.direction === "next" || cmpResult === 1 && this.direction === "prev") {
      throw new DataError();
    }
    const cmpResult2 = cmp(primaryKey, this._objectStorePosition);
    if (cmpResult === 0) {
      if (cmpResult2 <= 0 && this.direction === "next" || cmpResult2 >= 0 && this.direction === "prev") {
        throw new DataError();
      }
    }
    if (this._request) {
      this._request.readyState = "pending";
    }
    transaction._execRequestAsync({
      operation: this._iterate.bind(this, key, primaryKey),
      request: this._request,
      source: this.source
    });
    this._gotValue = false;
  }
  delete() {
    const effectiveObjectStore = getEffectiveObjectStore(this);
    const effectiveKey = this.source.hasOwnProperty("_rawIndex") ? this.primaryKey : this._position;
    const transaction = effectiveObjectStore.transaction;
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    if (effectiveObjectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    if (!(this.source instanceof FDBObjectStore$1) && this.source._rawIndex.deleted) {
      throw new InvalidStateError();
    }
    if (!this._gotValue || !this.hasOwnProperty("value")) {
      throw new InvalidStateError();
    }
    return transaction._execRequestAsync({
      operation: effectiveObjectStore._rawObjectStore.deleteRecord.bind(effectiveObjectStore._rawObjectStore, effectiveKey, transaction._rollbackLog),
      source: this
    });
  }
  toString() {
    return "[object IDBCursor]";
  }
}
class FDBCursorWithValue extends FDBCursor {
  value = void 0;
  constructor(source, range2, direction, request) {
    super(source, range2, direction, request);
  }
  toString() {
    return "[object IDBCursorWithValue]";
  }
}
const stopped = (event, listener) => {
  return event.immediatePropagationStopped || event.eventPhase === event.CAPTURING_PHASE && listener.capture === false || event.eventPhase === event.BUBBLING_PHASE && listener.capture === true;
};
const invokeEventListeners = (event, obj) => {
  event.currentTarget = obj;
  for (const listener of obj.listeners.slice()) {
    if (event.type !== listener.type || stopped(event, listener)) {
      continue;
    }
    listener.callback.call(event.currentTarget, event);
  }
  const typeToProp = {
    abort: "onabort",
    blocked: "onblocked",
    complete: "oncomplete",
    error: "onerror",
    success: "onsuccess",
    upgradeneeded: "onupgradeneeded",
    versionchange: "onversionchange"
  };
  const prop = typeToProp[event.type];
  if (prop === void 0) {
    throw new Error(`Unknown event type: "${event.type}"`);
  }
  const callback = event.currentTarget[prop];
  if (callback) {
    const listener = {
      callback,
      capture: false,
      type: event.type
    };
    if (!stopped(event, listener)) {
      listener.callback.call(event.currentTarget, event);
    }
  }
};
class FakeEventTarget {
  listeners = [];
  // These will be overridden in individual subclasses and made not readonly
  addEventListener(type2, callback, capture = false) {
    this.listeners.push({
      callback,
      capture,
      type: type2
    });
  }
  removeEventListener(type2, callback, capture = false) {
    const i2 = this.listeners.findIndex((listener) => {
      return listener.type === type2 && listener.callback === callback && listener.capture === capture;
    });
    this.listeners.splice(i2, 1);
  }
  // http://www.w3.org/TR/dom/#dispatching-events
  dispatchEvent(event) {
    if (event.dispatched || !event.initialized) {
      throw new InvalidStateError("The object is in an invalid state.");
    }
    event.isTrusted = false;
    event.dispatched = true;
    event.target = this;
    event.eventPhase = event.CAPTURING_PHASE;
    for (const obj of event.eventPath) {
      if (!event.propagationStopped) {
        invokeEventListeners(event, obj);
      }
    }
    event.eventPhase = event.AT_TARGET;
    if (!event.propagationStopped) {
      invokeEventListeners(event, event.target);
    }
    if (event.bubbles) {
      event.eventPath.reverse();
      event.eventPhase = event.BUBBLING_PHASE;
      for (const obj of event.eventPath) {
        if (!event.propagationStopped) {
          invokeEventListeners(event, obj);
        }
      }
    }
    event.dispatched = false;
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    if (event.canceled) {
      return false;
    }
    return true;
  }
}
class FDBRequest extends FakeEventTarget {
  _result = null;
  _error = null;
  source = null;
  transaction = null;
  readyState = "pending";
  onsuccess = null;
  onerror = null;
  get error() {
    if (this.readyState === "pending") {
      throw new InvalidStateError();
    }
    return this._error;
  }
  set error(value) {
    this._error = value;
  }
  get result() {
    if (this.readyState === "pending") {
      throw new InvalidStateError();
    }
    return this._result;
  }
  set result(value) {
    this._result = value;
  }
  toString() {
    return "[object IDBRequest]";
  }
}
const enforceRange = (num, type2) => {
  const min2 = 0;
  const max2 = type2 === "unsigned long" ? 4294967295 : 9007199254740991;
  if (isNaN(num) || num < min2 || num > max2) {
    throw new TypeError();
  }
  if (num >= 0) {
    return Math.floor(num);
  }
};
class FakeDOMStringList extends Array {
  contains(value) {
    for (const value2 of this) {
      if (value === value2) {
        return true;
      }
    }
    return false;
  }
  item(i2) {
    if (i2 < 0 || i2 >= this.length) {
      return null;
    }
    return this[i2];
  }
  // Used internally, should not be used by others. I could maybe get rid of these and replace rather than mutate, but too lazy to check the spec.
  _push(...values) {
    return Array.prototype.push.call(this, ...values);
  }
  _sort(...values) {
    return Array.prototype.sort.call(this, ...values);
  }
}
const valueToKeyRange = (value, nullDisallowedFlag = false) => {
  if (value instanceof FDBKeyRange) {
    return value;
  }
  if (value === null || value === void 0) {
    if (nullDisallowedFlag) {
      throw new DataError();
    }
    return new FDBKeyRange(void 0, void 0, false, false);
  }
  const key = valueToKey(value);
  return FDBKeyRange.only(key);
};
const confirmActiveTransaction$1 = (index) => {
  if (index._rawIndex.deleted || index.objectStore._rawObjectStore.deleted) {
    throw new InvalidStateError();
  }
  if (index.objectStore.transaction._state !== "active") {
    throw new TransactionInactiveError();
  }
};
class FDBIndex {
  constructor(objectStore, rawIndex) {
    this._rawIndex = rawIndex;
    this._name = rawIndex.name;
    this.objectStore = objectStore;
    this.keyPath = rawIndex.keyPath;
    this.multiEntry = rawIndex.multiEntry;
    this.unique = rawIndex.unique;
  }
  get name() {
    return this._name;
  }
  // https://w3c.github.io/IndexedDB/#dom-idbindex-name
  set name(name) {
    const transaction = this.objectStore.transaction;
    if (!transaction.db._runningVersionchangeTransaction) {
      throw new InvalidStateError();
    }
    if (transaction._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (this._rawIndex.deleted || this.objectStore._rawObjectStore.deleted) {
      throw new InvalidStateError();
    }
    name = String(name);
    if (name === this._name) {
      return;
    }
    if (this.objectStore.indexNames.contains(name)) {
      throw new ConstraintError();
    }
    const oldName = this._name;
    const oldIndexNames = [...this.objectStore.indexNames];
    this._name = name;
    this._rawIndex.name = name;
    this.objectStore._indexesCache.delete(oldName);
    this.objectStore._indexesCache.set(name, this);
    this.objectStore._rawObjectStore.rawIndexes.delete(oldName);
    this.objectStore._rawObjectStore.rawIndexes.set(name, this._rawIndex);
    this.objectStore.indexNames = new FakeDOMStringList(...Array.from(this.objectStore._rawObjectStore.rawIndexes.keys()).filter((indexName) => {
      const index = this.objectStore._rawObjectStore.rawIndexes.get(indexName);
      return index && !index.deleted;
    }).sort());
    transaction._rollbackLog.push(() => {
      this._name = oldName;
      this._rawIndex.name = oldName;
      this.objectStore._indexesCache.delete(name);
      this.objectStore._indexesCache.set(oldName, this);
      this.objectStore._rawObjectStore.rawIndexes.delete(name);
      this.objectStore._rawObjectStore.rawIndexes.set(oldName, this._rawIndex);
      this.objectStore.indexNames = new FakeDOMStringList(...oldIndexNames);
    });
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-openCursor-IDBRequest-any-range-IDBCursorDirection-direction
  openCursor(range2, direction) {
    confirmActiveTransaction$1(this);
    if (range2 === null) {
      range2 = void 0;
    }
    if (range2 !== void 0 && !(range2 instanceof FDBKeyRange)) {
      range2 = FDBKeyRange.only(valueToKey(range2));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.objectStore.transaction;
    const cursor2 = new FDBCursorWithValue(this, range2, direction, request);
    return this.objectStore.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-openKeyCursor-IDBRequest-any-range-IDBCursorDirection-direction
  openKeyCursor(range2, direction) {
    confirmActiveTransaction$1(this);
    if (range2 === null) {
      range2 = void 0;
    }
    if (range2 !== void 0 && !(range2 instanceof FDBKeyRange)) {
      range2 = FDBKeyRange.only(valueToKey(range2));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.objectStore.transaction;
    const cursor2 = new FDBCursor(this, range2, direction, request, true);
    return this.objectStore.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  get(key) {
    confirmActiveTransaction$1(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getValue.bind(this._rawIndex, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbindex-getall
  getAll(query2, count2) {
    if (arguments.length > 1 && count2 !== void 0) {
      count2 = enforceRange(count2, "unsigned long");
    }
    confirmActiveTransaction$1(this);
    const range2 = valueToKeyRange(query2);
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getAllValues.bind(this._rawIndex, range2, count2),
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-getKey-IDBRequest-any-key
  getKey(key) {
    confirmActiveTransaction$1(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getKey.bind(this._rawIndex, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbindex-getallkeys
  getAllKeys(query2, count2) {
    if (arguments.length > 1 && count2 !== void 0) {
      count2 = enforceRange(count2, "unsigned long");
    }
    confirmActiveTransaction$1(this);
    const range2 = valueToKeyRange(query2);
    return this.objectStore.transaction._execRequestAsync({
      operation: this._rawIndex.getAllKeys.bind(this._rawIndex, range2, count2),
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-count-IDBRequest-any-key
  count(key) {
    confirmActiveTransaction$1(this);
    if (key === null) {
      key = void 0;
    }
    if (key !== void 0 && !(key instanceof FDBKeyRange)) {
      key = FDBKeyRange.only(valueToKey(key));
    }
    return this.objectStore.transaction._execRequestAsync({
      operation: () => {
        let count2 = 0;
        const cursor2 = new FDBCursor(this, key);
        while (cursor2._iterate() !== null) {
          count2 += 1;
        }
        return count2;
      },
      source: this
    });
  }
  toString() {
    return "[object IDBIndex]";
  }
}
const canInjectKey = (keyPath, value) => {
  if (Array.isArray(keyPath)) {
    throw new Error("The key paths used in this section are always strings and never sequences, since it is not possible to create a object store which has a key generator and also has a key path that is a sequence.");
  }
  const identifiers = keyPath.split(".");
  if (identifiers.length === 0) {
    throw new Error("Assert: identifiers is not empty");
  }
  identifiers.pop();
  for (const identifier of identifiers) {
    if (typeof value !== "object" && !Array.isArray(value)) {
      return false;
    }
    const hop = value.hasOwnProperty(identifier);
    if (!hop) {
      return true;
    }
    value = value[identifier];
  }
  return typeof value === "object" || Array.isArray(value);
};
function binarySearch(records, key) {
  let low = 0;
  let high = records.length;
  let mid;
  while (low < high) {
    mid = low + high >>> 1;
    if (cmp(records[mid].key, key) < 0) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return low;
}
function getIndexByKey(records, key) {
  const idx = binarySearch(records, key);
  const record = records[idx];
  if (record && cmp(record.key, key) === 0) {
    return idx;
  }
  return -1;
}
function getByKey(records, key) {
  const idx = getIndexByKey(records, key);
  return records[idx];
}
function getIndexByKeyRange(records, keyRange) {
  const lowerIdx = typeof keyRange.lower === "undefined" ? 0 : binarySearch(records, keyRange.lower);
  const upperIdx = typeof keyRange.upper === "undefined" ? records.length - 1 : binarySearch(records, keyRange.upper);
  for (let i2 = lowerIdx; i2 <= upperIdx; i2++) {
    const record = records[i2];
    if (record && keyRange.includes(record.key)) {
      return i2;
    }
  }
  return -1;
}
function getByKeyRange(records, keyRange) {
  const idx = getIndexByKeyRange(records, keyRange);
  return records[idx];
}
function getIndexByKeyGTE(records, key) {
  const idx = binarySearch(records, key);
  const record = records[idx];
  if (record && cmp(record.key, key) >= 0) {
    return idx;
  }
  return -1;
}
class RecordStore {
  records = [];
  get(key) {
    if (key instanceof FDBKeyRange) {
      return getByKeyRange(this.records, key);
    }
    return getByKey(this.records, key);
  }
  add(newRecord) {
    let i2;
    if (this.records.length === 0) {
      i2 = 0;
    } else {
      i2 = getIndexByKeyGTE(this.records, newRecord.key);
      if (i2 === -1) {
        i2 = this.records.length;
      } else {
        while (i2 < this.records.length && cmp(this.records[i2].key, newRecord.key) === 0) {
          if (cmp(this.records[i2].value, newRecord.value) !== -1) {
            break;
          }
          i2 += 1;
        }
      }
    }
    this.records.splice(i2, 0, newRecord);
  }
  delete(key) {
    const deletedRecords = [];
    const isRange = key instanceof FDBKeyRange;
    while (true) {
      const idx = isRange ? getIndexByKeyRange(this.records, key) : getIndexByKey(this.records, key);
      if (idx === -1) {
        break;
      }
      deletedRecords.push(this.records[idx]);
      this.records.splice(idx, 1);
    }
    return deletedRecords;
  }
  deleteByValue(key) {
    const range2 = key instanceof FDBKeyRange ? key : FDBKeyRange.only(key);
    const deletedRecords = [];
    this.records = this.records.filter((record) => {
      const shouldDelete = range2.includes(record.value);
      if (shouldDelete) {
        deletedRecords.push(record);
      }
      return !shouldDelete;
    });
    return deletedRecords;
  }
  clear() {
    const deletedRecords = this.records.slice();
    this.records = [];
    return deletedRecords;
  }
  values(range2, direction = "next") {
    return {
      [Symbol.iterator]: () => {
        let i2;
        if (direction === "next") {
          i2 = 0;
          if (range2 !== void 0 && range2.lower !== void 0) {
            while (this.records[i2] !== void 0) {
              const cmpResult = cmp(this.records[i2].key, range2.lower);
              if (cmpResult === 1 || cmpResult === 0 && !range2.lowerOpen) {
                break;
              }
              i2 += 1;
            }
          }
        } else {
          i2 = this.records.length - 1;
          if (range2 !== void 0 && range2.upper !== void 0) {
            while (this.records[i2] !== void 0) {
              const cmpResult = cmp(this.records[i2].key, range2.upper);
              if (cmpResult === -1 || cmpResult === 0 && !range2.upperOpen) {
                break;
              }
              i2 -= 1;
            }
          }
        }
        return {
          next: () => {
            let done;
            let value;
            if (direction === "next") {
              value = this.records[i2];
              done = i2 >= this.records.length;
              i2 += 1;
              if (!done && range2 !== void 0 && range2.upper !== void 0) {
                const cmpResult = cmp(value.key, range2.upper);
                done = cmpResult === 1 || cmpResult === 0 && range2.upperOpen;
                if (done) {
                  value = void 0;
                }
              }
            } else {
              value = this.records[i2];
              done = i2 < 0;
              i2 -= 1;
              if (!done && range2 !== void 0 && range2.lower !== void 0) {
                const cmpResult = cmp(value.key, range2.lower);
                done = cmpResult === -1 || cmpResult === 0 && range2.lowerOpen;
                if (done) {
                  value = void 0;
                }
              }
            }
            return {
              done,
              value
            };
          }
        };
      }
    };
  }
}
class Index {
  deleted = false;
  // Initialized should be used to decide whether to throw an error or abort the versionchange transaction when there is a
  // constraint
  initialized = false;
  records = new RecordStore();
  constructor(rawObjectStore, name, keyPath, multiEntry, unique) {
    this.rawObjectStore = rawObjectStore;
    this.name = name;
    this.keyPath = keyPath;
    this.multiEntry = multiEntry;
    this.unique = unique;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-index
  getKey(key) {
    const record = this.records.get(key);
    return record !== void 0 ? record.value : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-referenced-values-from-an-index
  getAllKeys(range2, count2) {
    if (count2 === void 0 || count2 === 0) {
      count2 = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range2)) {
      records.push(structuredCloneWrapper(record.value));
      if (records.length >= count2) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#index-referenced-value-retrieval-operation
  getValue(key) {
    const record = this.records.get(key);
    return record !== void 0 ? this.rawObjectStore.getValue(record.value) : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-referenced-values-from-an-index
  getAllValues(range2, count2) {
    if (count2 === void 0 || count2 === 0) {
      count2 = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range2)) {
      records.push(this.rawObjectStore.getValue(record.value));
      if (records.length >= count2) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-storing-a-record-into-an-object-store (step 7)
  storeRecord(newRecord) {
    let indexKey;
    try {
      indexKey = extractKey(this.keyPath, newRecord.value);
    } catch (err) {
      if (err.name === "DataError") {
        return;
      }
      throw err;
    }
    if (!this.multiEntry || !Array.isArray(indexKey)) {
      try {
        valueToKey(indexKey);
      } catch (e2) {
        return;
      }
    } else {
      const keep = [];
      for (const part of indexKey) {
        if (keep.indexOf(part) < 0) {
          try {
            keep.push(valueToKey(part));
          } catch (err) {
          }
        }
      }
      indexKey = keep;
    }
    if (!this.multiEntry || !Array.isArray(indexKey)) {
      if (this.unique) {
        const existingRecord = this.records.get(indexKey);
        if (existingRecord) {
          throw new ConstraintError();
        }
      }
    } else {
      if (this.unique) {
        for (const individualIndexKey of indexKey) {
          const existingRecord = this.records.get(individualIndexKey);
          if (existingRecord) {
            throw new ConstraintError();
          }
        }
      }
    }
    if (!this.multiEntry || !Array.isArray(indexKey)) {
      this.records.add({
        key: indexKey,
        value: newRecord.key
      });
    } else {
      for (const individualIndexKey of indexKey) {
        this.records.add({
          key: individualIndexKey,
          value: newRecord.key
        });
      }
    }
  }
  initialize(transaction) {
    if (this.initialized) {
      throw new Error("Index already initialized");
    }
    transaction._execRequestAsync({
      operation: () => {
        try {
          for (const record of this.rawObjectStore.records.values()) {
            this.storeRecord(record);
          }
          this.initialized = true;
        } catch (err) {
          transaction._abort(err.name);
        }
      },
      source: null
    });
  }
}
const validateKeyPath = (keyPath, parent) => {
  if (keyPath !== void 0 && keyPath !== null && typeof keyPath !== "string" && keyPath.toString && (parent === "array" || !Array.isArray(keyPath))) {
    keyPath = keyPath.toString();
  }
  if (typeof keyPath === "string") {
    if (keyPath === "" && parent !== "string") {
      return;
    }
    try {
      const validIdentifierRegex = /^(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])(?:[\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])*$/;
      if (keyPath.length >= 1 && validIdentifierRegex.test(keyPath)) {
        return;
      }
    } catch (err) {
      throw new SyntaxError(err.message);
    }
    if (keyPath.indexOf(" ") >= 0) {
      throw new SyntaxError("The keypath argument contains an invalid key path (no spaces allowed).");
    }
  }
  if (Array.isArray(keyPath) && keyPath.length > 0) {
    if (parent) {
      throw new SyntaxError("The keypath argument contains an invalid key path (nested arrays).");
    }
    for (const part of keyPath) {
      validateKeyPath(part, "array");
    }
    return;
  } else if (typeof keyPath === "string" && keyPath.indexOf(".") >= 0) {
    keyPath = keyPath.split(".");
    for (const part of keyPath) {
      validateKeyPath(part, "string");
    }
    return;
  }
  throw new SyntaxError();
};
const confirmActiveTransaction = (objectStore) => {
  if (objectStore._rawObjectStore.deleted) {
    throw new InvalidStateError();
  }
  if (objectStore.transaction._state !== "active") {
    throw new TransactionInactiveError();
  }
};
const buildRecordAddPut = (objectStore, value, key) => {
  confirmActiveTransaction(objectStore);
  if (objectStore.transaction.mode === "readonly") {
    throw new ReadOnlyError();
  }
  if (objectStore.keyPath !== null) {
    if (key !== void 0) {
      throw new DataError();
    }
  }
  const clone2 = structuredCloneWrapper(value);
  if (objectStore.keyPath !== null) {
    const tempKey = extractKey(objectStore.keyPath, clone2);
    if (tempKey !== void 0) {
      valueToKey(tempKey);
    } else {
      if (!objectStore._rawObjectStore.keyGenerator) {
        throw new DataError();
      } else if (!canInjectKey(objectStore.keyPath, clone2)) {
        throw new DataError();
      }
    }
  }
  if (objectStore.keyPath === null && objectStore._rawObjectStore.keyGenerator === null && key === void 0) {
    throw new DataError();
  }
  if (key !== void 0) {
    key = valueToKey(key);
  }
  return {
    key,
    value: clone2
  };
};
class FDBObjectStore {
  _indexesCache = /* @__PURE__ */ new Map();
  constructor(transaction, rawObjectStore) {
    this._rawObjectStore = rawObjectStore;
    this._name = rawObjectStore.name;
    this.keyPath = rawObjectStore.keyPath;
    this.autoIncrement = rawObjectStore.autoIncrement;
    this.transaction = transaction;
    this.indexNames = new FakeDOMStringList(...Array.from(rawObjectStore.rawIndexes.keys()).sort());
  }
  get name() {
    return this._name;
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-name
  set name(name) {
    const transaction = this.transaction;
    if (!transaction.db._runningVersionchangeTransaction) {
      throw new InvalidStateError();
    }
    confirmActiveTransaction(this);
    name = String(name);
    if (name === this._name) {
      return;
    }
    if (this._rawObjectStore.rawDatabase.rawObjectStores.has(name)) {
      throw new ConstraintError();
    }
    const oldName = this._name;
    const oldObjectStoreNames = [...transaction.db.objectStoreNames];
    this._name = name;
    this._rawObjectStore.name = name;
    this.transaction._objectStoresCache.delete(oldName);
    this.transaction._objectStoresCache.set(name, this);
    this._rawObjectStore.rawDatabase.rawObjectStores.delete(oldName);
    this._rawObjectStore.rawDatabase.rawObjectStores.set(name, this._rawObjectStore);
    transaction.db.objectStoreNames = new FakeDOMStringList(...Array.from(this._rawObjectStore.rawDatabase.rawObjectStores.keys()).filter((objectStoreName) => {
      const objectStore = this._rawObjectStore.rawDatabase.rawObjectStores.get(objectStoreName);
      return objectStore && !objectStore.deleted;
    }).sort());
    const oldScope = new Set(transaction._scope);
    const oldTransactionObjectStoreNames = [...transaction.objectStoreNames];
    this.transaction._scope.delete(oldName);
    transaction._scope.add(name);
    transaction.objectStoreNames = new FakeDOMStringList(...Array.from(transaction._scope).sort());
    transaction._rollbackLog.push(() => {
      this._name = oldName;
      this._rawObjectStore.name = oldName;
      this.transaction._objectStoresCache.delete(name);
      this.transaction._objectStoresCache.set(oldName, this);
      this._rawObjectStore.rawDatabase.rawObjectStores.delete(name);
      this._rawObjectStore.rawDatabase.rawObjectStores.set(oldName, this._rawObjectStore);
      transaction.db.objectStoreNames = new FakeDOMStringList(...oldObjectStoreNames);
      transaction._scope = oldScope;
      transaction.objectStoreNames = new FakeDOMStringList(...oldTransactionObjectStoreNames);
    });
  }
  put(value, key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    const record = buildRecordAddPut(this, value, key);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, record, false, this.transaction._rollbackLog),
      source: this
    });
  }
  add(value, key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    const record = buildRecordAddPut(this, value, key);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, record, true, this.transaction._rollbackLog),
      source: this
    });
  }
  delete(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    confirmActiveTransaction(this);
    if (this.transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.deleteRecord.bind(this._rawObjectStore, key, this.transaction._rollbackLog),
      source: this
    });
  }
  get(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    confirmActiveTransaction(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getValue.bind(this._rawObjectStore, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getall
  getAll(query2, count2) {
    if (arguments.length > 1 && count2 !== void 0) {
      count2 = enforceRange(count2, "unsigned long");
    }
    confirmActiveTransaction(this);
    const range2 = valueToKeyRange(query2);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getAllValues.bind(this._rawObjectStore, range2, count2),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getkey
  getKey(key) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    confirmActiveTransaction(this);
    if (!(key instanceof FDBKeyRange)) {
      key = valueToKey(key);
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getKey.bind(this._rawObjectStore, key),
      source: this
    });
  }
  // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getallkeys
  getAllKeys(query2, count2) {
    if (arguments.length > 1 && count2 !== void 0) {
      count2 = enforceRange(count2, "unsigned long");
    }
    confirmActiveTransaction(this);
    const range2 = valueToKeyRange(query2);
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.getAllKeys.bind(this._rawObjectStore, range2, count2),
      source: this
    });
  }
  clear() {
    confirmActiveTransaction(this);
    if (this.transaction.mode === "readonly") {
      throw new ReadOnlyError();
    }
    return this.transaction._execRequestAsync({
      operation: this._rawObjectStore.clear.bind(this._rawObjectStore, this.transaction._rollbackLog),
      source: this
    });
  }
  openCursor(range2, direction) {
    confirmActiveTransaction(this);
    if (range2 === null) {
      range2 = void 0;
    }
    if (range2 !== void 0 && !(range2 instanceof FDBKeyRange)) {
      range2 = FDBKeyRange.only(valueToKey(range2));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.transaction;
    const cursor2 = new FDBCursorWithValue(this, range2, direction, request);
    return this.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  openKeyCursor(range2, direction) {
    confirmActiveTransaction(this);
    if (range2 === null) {
      range2 = void 0;
    }
    if (range2 !== void 0 && !(range2 instanceof FDBKeyRange)) {
      range2 = FDBKeyRange.only(valueToKey(range2));
    }
    const request = new FDBRequest();
    request.source = this;
    request.transaction = this.transaction;
    const cursor2 = new FDBCursor(this, range2, direction, request, true);
    return this.transaction._execRequestAsync({
      operation: cursor2._iterate.bind(cursor2),
      request,
      source: this
    });
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBObjectStore-createIndex-IDBIndex-DOMString-name-DOMString-sequence-DOMString--keyPath-IDBIndexParameters-optionalParameters
  createIndex(name, keyPath, optionalParameters = {}) {
    if (arguments.length < 2) {
      throw new TypeError();
    }
    const multiEntry = optionalParameters.multiEntry !== void 0 ? optionalParameters.multiEntry : false;
    const unique = optionalParameters.unique !== void 0 ? optionalParameters.unique : false;
    if (this.transaction.mode !== "versionchange") {
      throw new InvalidStateError();
    }
    confirmActiveTransaction(this);
    if (this.indexNames.contains(name)) {
      throw new ConstraintError();
    }
    validateKeyPath(keyPath);
    if (Array.isArray(keyPath) && multiEntry) {
      throw new InvalidAccessError();
    }
    const indexNames = [...this.indexNames];
    this.transaction._rollbackLog.push(() => {
      const index2 = this._rawObjectStore.rawIndexes.get(name);
      if (index2) {
        index2.deleted = true;
      }
      this.indexNames = new FakeDOMStringList(...indexNames);
      this._rawObjectStore.rawIndexes.delete(name);
    });
    const index = new Index(this._rawObjectStore, name, keyPath, multiEntry, unique);
    this.indexNames._push(name);
    this.indexNames._sort();
    this._rawObjectStore.rawIndexes.set(name, index);
    index.initialize(this.transaction);
    return new FDBIndex(this, index);
  }
  // https://w3c.github.io/IndexedDB/#dom-idbobjectstore-index
  index(name) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    if (this._rawObjectStore.deleted || this.transaction._state === "finished") {
      throw new InvalidStateError();
    }
    const index = this._indexesCache.get(name);
    if (index !== void 0) {
      return index;
    }
    const rawIndex = this._rawObjectStore.rawIndexes.get(name);
    if (!this.indexNames.contains(name) || rawIndex === void 0) {
      throw new NotFoundError();
    }
    const index2 = new FDBIndex(this, rawIndex);
    this._indexesCache.set(name, index2);
    return index2;
  }
  deleteIndex(name) {
    if (arguments.length === 0) {
      throw new TypeError();
    }
    if (this.transaction.mode !== "versionchange") {
      throw new InvalidStateError();
    }
    confirmActiveTransaction(this);
    const rawIndex = this._rawObjectStore.rawIndexes.get(name);
    if (rawIndex === void 0) {
      throw new NotFoundError();
    }
    this.transaction._rollbackLog.push(() => {
      rawIndex.deleted = false;
      this._rawObjectStore.rawIndexes.set(name, rawIndex);
      this.indexNames._push(name);
      this.indexNames._sort();
    });
    this.indexNames = new FakeDOMStringList(...Array.from(this.indexNames).filter((indexName) => {
      return indexName !== name;
    }));
    rawIndex.deleted = true;
    this.transaction._execRequestAsync({
      operation: () => {
        const rawIndex2 = this._rawObjectStore.rawIndexes.get(name);
        if (rawIndex === rawIndex2) {
          this._rawObjectStore.rawIndexes.delete(name);
        }
      },
      source: this
    });
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBObjectStore-count-IDBRequest-any-key
  count(key) {
    confirmActiveTransaction(this);
    if (key === null) {
      key = void 0;
    }
    if (key !== void 0 && !(key instanceof FDBKeyRange)) {
      key = FDBKeyRange.only(valueToKey(key));
    }
    return this.transaction._execRequestAsync({
      operation: () => {
        let count2 = 0;
        const cursor2 = new FDBCursor(this, key);
        while (cursor2._iterate() !== null) {
          count2 += 1;
        }
        return count2;
      },
      source: this
    });
  }
  toString() {
    return "[object IDBObjectStore]";
  }
}
const FDBObjectStore$1 = FDBObjectStore;
class Event {
  eventPath = [];
  NONE = 0;
  CAPTURING_PHASE = 1;
  AT_TARGET = 2;
  BUBBLING_PHASE = 3;
  // Flags
  propagationStopped = false;
  immediatePropagationStopped = false;
  canceled = false;
  initialized = true;
  dispatched = false;
  target = null;
  currentTarget = null;
  eventPhase = 0;
  defaultPrevented = false;
  isTrusted = false;
  timeStamp = Date.now();
  constructor(type2, eventInitDict = {}) {
    this.type = type2;
    this.bubbles = eventInitDict.bubbles !== void 0 ? eventInitDict.bubbles : false;
    this.cancelable = eventInitDict.cancelable !== void 0 ? eventInitDict.cancelable : false;
  }
  preventDefault() {
    if (this.cancelable) {
      this.canceled = true;
    }
  }
  stopPropagation() {
    this.propagationStopped = true;
  }
  stopImmediatePropagation() {
    this.propagationStopped = true;
    this.immediatePropagationStopped = true;
  }
}
function getSetImmediateFromJsdom() {
  if (typeof navigator !== "undefined" && /jsdom/.test(navigator.userAgent)) {
    const outerRealmFunctionConstructor = Node.constructor;
    return new outerRealmFunctionConstructor("return setImmediate")();
  } else {
    return void 0;
  }
}
const queueTask = globalThis.setImmediate || getSetImmediateFromJsdom() || ((fn2) => setTimeout(fn2, 0));
class FDBTransaction extends FakeEventTarget {
  _state = "active";
  _started = false;
  _rollbackLog = [];
  _objectStoresCache = /* @__PURE__ */ new Map();
  error = null;
  onabort = null;
  oncomplete = null;
  onerror = null;
  _requests = [];
  constructor(storeNames, mode, db) {
    super();
    this._scope = new Set(storeNames);
    this.mode = mode;
    this.db = db;
    this.objectStoreNames = new FakeDOMStringList(...Array.from(this._scope).sort());
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-aborting-a-transaction
  _abort(errName) {
    for (const f2 of this._rollbackLog.reverse()) {
      f2();
    }
    if (errName !== null) {
      const e2 = new Error();
      e2.name = errName;
      this.error = e2;
    }
    for (const {
      request
    } of this._requests) {
      if (request.readyState !== "done") {
        request.readyState = "done";
        if (request.source) {
          request.result = void 0;
          request.error = new AbortError();
          const event = new Event("error", {
            bubbles: true,
            cancelable: true
          });
          event.eventPath = [this.db, this];
          request.dispatchEvent(event);
        }
      }
    }
    queueTask(() => {
      const event = new Event("abort", {
        bubbles: true,
        cancelable: false
      });
      event.eventPath = [this.db];
      this.dispatchEvent(event);
    });
    this._state = "finished";
  }
  abort() {
    if (this._state === "committing" || this._state === "finished") {
      throw new InvalidStateError();
    }
    this._state = "active";
    this._abort(null);
  }
  // http://w3c.github.io/IndexedDB/#dom-idbtransaction-objectstore
  objectStore(name) {
    if (this._state !== "active") {
      throw new InvalidStateError();
    }
    const objectStore = this._objectStoresCache.get(name);
    if (objectStore !== void 0) {
      return objectStore;
    }
    const rawObjectStore = this.db._rawDatabase.rawObjectStores.get(name);
    if (!this._scope.has(name) || rawObjectStore === void 0) {
      throw new NotFoundError();
    }
    const objectStore2 = new FDBObjectStore$1(this, rawObjectStore);
    this._objectStoresCache.set(name, objectStore2);
    return objectStore2;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-asynchronously-executing-a-request
  _execRequestAsync(obj) {
    const source = obj.source;
    const operation = obj.operation;
    let request = obj.hasOwnProperty("request") ? obj.request : null;
    if (this._state !== "active") {
      throw new TransactionInactiveError();
    }
    if (!request) {
      if (!source) {
        request = new FDBRequest();
      } else {
        request = new FDBRequest();
        request.source = source;
        request.transaction = source.transaction;
      }
    }
    this._requests.push({
      operation,
      request
    });
    return request;
  }
  _start() {
    this._started = true;
    let operation;
    let request;
    while (this._requests.length > 0) {
      const r2 = this._requests.shift();
      if (r2 && r2.request.readyState !== "done") {
        request = r2.request;
        operation = r2.operation;
        break;
      }
    }
    if (request && operation) {
      if (!request.source) {
        operation();
      } else {
        let defaultAction;
        let event;
        try {
          const result = operation();
          request.readyState = "done";
          request.result = result;
          request.error = void 0;
          if (this._state === "inactive") {
            this._state = "active";
          }
          event = new Event("success", {
            bubbles: false,
            cancelable: false
          });
        } catch (err) {
          request.readyState = "done";
          request.result = void 0;
          request.error = err;
          if (this._state === "inactive") {
            this._state = "active";
          }
          event = new Event("error", {
            bubbles: true,
            cancelable: true
          });
          defaultAction = this._abort.bind(this, err.name);
        }
        try {
          event.eventPath = [this.db, this];
          request.dispatchEvent(event);
        } catch (err) {
          if (this._state !== "committing") {
            this._abort("AbortError");
          }
          throw err;
        }
        if (!event.canceled) {
          if (defaultAction) {
            defaultAction();
          }
        }
      }
      queueTask(this._start.bind(this));
      return;
    }
    if (this._state !== "finished") {
      this._state = "finished";
      if (!this.error) {
        const event = new Event("complete");
        this.dispatchEvent(event);
      }
    }
  }
  commit() {
    if (this._state !== "active") {
      throw new InvalidStateError();
    }
    this._state = "committing";
  }
  toString() {
    return "[object IDBRequest]";
  }
}
const MAX_KEY = 9007199254740992;
class KeyGenerator {
  // This is kind of wrong. Should start at 1 and increment only after record is saved
  num = 0;
  next() {
    if (this.num >= MAX_KEY) {
      throw new ConstraintError();
    }
    this.num += 1;
    return this.num;
  }
  // https://w3c.github.io/IndexedDB/#possibly-update-the-key-generator
  setIfLarger(num) {
    const value = Math.floor(Math.min(num, MAX_KEY)) - 1;
    if (value >= this.num) {
      this.num = value + 1;
    }
  }
}
class ObjectStore {
  deleted = false;
  records = new RecordStore();
  rawIndexes = /* @__PURE__ */ new Map();
  constructor(rawDatabase, name, keyPath, autoIncrement) {
    this.rawDatabase = rawDatabase;
    this.keyGenerator = autoIncrement === true ? new KeyGenerator() : null;
    this.deleted = false;
    this.name = name;
    this.keyPath = keyPath;
    this.autoIncrement = autoIncrement;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-object-store
  getKey(key) {
    const record = this.records.get(key);
    return record !== void 0 ? structuredCloneWrapper(record.key) : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-keys-from-an-object-store
  getAllKeys(range2, count2) {
    if (count2 === void 0 || count2 === 0) {
      count2 = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range2)) {
      records.push(structuredCloneWrapper(record.key));
      if (records.length >= count2) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-object-store
  getValue(key) {
    const record = this.records.get(key);
    return record !== void 0 ? structuredCloneWrapper(record.value) : void 0;
  }
  // http://w3c.github.io/IndexedDB/#retrieve-multiple-values-from-an-object-store
  getAllValues(range2, count2) {
    if (count2 === void 0 || count2 === 0) {
      count2 = Infinity;
    }
    const records = [];
    for (const record of this.records.values(range2)) {
      records.push(structuredCloneWrapper(record.value));
      if (records.length >= count2) {
        break;
      }
    }
    return records;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-storing-a-record-into-an-object-store
  storeRecord(newRecord, noOverwrite, rollbackLog) {
    if (this.keyPath !== null) {
      const key = extractKey(this.keyPath, newRecord.value);
      if (key !== void 0) {
        newRecord.key = key;
      }
    }
    if (this.keyGenerator !== null && newRecord.key === void 0) {
      if (rollbackLog) {
        const keyGeneratorBefore = this.keyGenerator.num;
        rollbackLog.push(() => {
          if (this.keyGenerator) {
            this.keyGenerator.num = keyGeneratorBefore;
          }
        });
      }
      newRecord.key = this.keyGenerator.next();
      if (this.keyPath !== null) {
        if (Array.isArray(this.keyPath)) {
          throw new Error("Cannot have an array key path in an object store with a key generator");
        }
        let remainingKeyPath = this.keyPath;
        let object2 = newRecord.value;
        let identifier;
        let i2 = 0;
        while (i2 >= 0) {
          if (typeof object2 !== "object") {
            throw new DataError();
          }
          i2 = remainingKeyPath.indexOf(".");
          if (i2 >= 0) {
            identifier = remainingKeyPath.slice(0, i2);
            remainingKeyPath = remainingKeyPath.slice(i2 + 1);
            if (!object2.hasOwnProperty(identifier)) {
              object2[identifier] = {};
            }
            object2 = object2[identifier];
          }
        }
        identifier = remainingKeyPath;
        object2[identifier] = newRecord.key;
      }
    } else if (this.keyGenerator !== null && typeof newRecord.key === "number") {
      this.keyGenerator.setIfLarger(newRecord.key);
    }
    const existingRecord = this.records.get(newRecord.key);
    if (existingRecord) {
      if (noOverwrite) {
        throw new ConstraintError();
      }
      this.deleteRecord(newRecord.key, rollbackLog);
    }
    this.records.add(newRecord);
    if (rollbackLog) {
      rollbackLog.push(() => {
        this.deleteRecord(newRecord.key);
      });
    }
    for (const rawIndex of this.rawIndexes.values()) {
      if (rawIndex.initialized) {
        rawIndex.storeRecord(newRecord);
      }
    }
    return newRecord.key;
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-deleting-records-from-an-object-store
  deleteRecord(key, rollbackLog) {
    const deletedRecords = this.records.delete(key);
    if (rollbackLog) {
      for (const record of deletedRecords) {
        rollbackLog.push(() => {
          this.storeRecord(record, true);
        });
      }
    }
    for (const rawIndex of this.rawIndexes.values()) {
      rawIndex.records.deleteByValue(key);
    }
  }
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-clearing-an-object-store
  clear(rollbackLog) {
    const deletedRecords = this.records.clear();
    if (rollbackLog) {
      for (const record of deletedRecords) {
        rollbackLog.push(() => {
          this.storeRecord(record, true);
        });
      }
    }
    for (const rawIndex of this.rawIndexes.values()) {
      rawIndex.records.clear();
    }
  }
}
const confirmActiveVersionchangeTransaction = (database) => {
  if (!database._runningVersionchangeTransaction) {
    throw new InvalidStateError();
  }
  const transactions = database._rawDatabase.transactions.filter((tx) => {
    return tx.mode === "versionchange";
  });
  const transaction = transactions[transactions.length - 1];
  if (!transaction || transaction._state === "finished") {
    throw new InvalidStateError();
  }
  if (transaction._state !== "active") {
    throw new TransactionInactiveError();
  }
  return transaction;
};
const closeConnection = (connection) => {
  connection._closePending = true;
  const transactionsComplete = connection._rawDatabase.transactions.every((transaction) => {
    return transaction._state === "finished";
  });
  if (transactionsComplete) {
    connection._closed = true;
    connection._rawDatabase.connections = connection._rawDatabase.connections.filter((otherConnection) => {
      return connection !== otherConnection;
    });
  } else {
    queueTask(() => {
      closeConnection(connection);
    });
  }
};
class FDBDatabase extends FakeEventTarget {
  _closePending = false;
  _closed = false;
  _runningVersionchangeTransaction = false;
  constructor(rawDatabase) {
    super();
    this._rawDatabase = rawDatabase;
    this._rawDatabase.connections.push(this);
    this.name = rawDatabase.name;
    this.version = rawDatabase.version;
    this.objectStoreNames = new FakeDOMStringList(...Array.from(rawDatabase.rawObjectStores.keys()).sort());
  }
  // http://w3c.github.io/IndexedDB/#dom-idbdatabase-createobjectstore
  createObjectStore(name, options2 = {}) {
    if (name === void 0) {
      throw new TypeError();
    }
    const transaction = confirmActiveVersionchangeTransaction(this);
    const keyPath = options2 !== null && options2.keyPath !== void 0 ? options2.keyPath : null;
    const autoIncrement = options2 !== null && options2.autoIncrement !== void 0 ? options2.autoIncrement : false;
    if (keyPath !== null) {
      validateKeyPath(keyPath);
    }
    if (this._rawDatabase.rawObjectStores.has(name)) {
      throw new ConstraintError();
    }
    if (autoIncrement && (keyPath === "" || Array.isArray(keyPath))) {
      throw new InvalidAccessError();
    }
    const objectStoreNames = [...this.objectStoreNames];
    transaction._rollbackLog.push(() => {
      const objectStore = this._rawDatabase.rawObjectStores.get(name);
      if (objectStore) {
        objectStore.deleted = true;
      }
      this.objectStoreNames = new FakeDOMStringList(...objectStoreNames);
      transaction._scope.delete(name);
      this._rawDatabase.rawObjectStores.delete(name);
    });
    const rawObjectStore = new ObjectStore(this._rawDatabase, name, keyPath, autoIncrement);
    this.objectStoreNames._push(name);
    this.objectStoreNames._sort();
    transaction._scope.add(name);
    this._rawDatabase.rawObjectStores.set(name, rawObjectStore);
    transaction.objectStoreNames = new FakeDOMStringList(...this.objectStoreNames);
    return transaction.objectStore(name);
  }
  deleteObjectStore(name) {
    if (name === void 0) {
      throw new TypeError();
    }
    const transaction = confirmActiveVersionchangeTransaction(this);
    const store = this._rawDatabase.rawObjectStores.get(name);
    if (store === void 0) {
      throw new NotFoundError();
    }
    this.objectStoreNames = new FakeDOMStringList(...Array.from(this.objectStoreNames).filter((objectStoreName) => {
      return objectStoreName !== name;
    }));
    transaction.objectStoreNames = new FakeDOMStringList(...this.objectStoreNames);
    transaction._rollbackLog.push(() => {
      store.deleted = false;
      this._rawDatabase.rawObjectStores.set(name, store);
      this.objectStoreNames._push(name);
      this.objectStoreNames._sort();
    });
    store.deleted = true;
    this._rawDatabase.rawObjectStores.delete(name);
    transaction._objectStoresCache.delete(name);
  }
  transaction(storeNames, mode) {
    mode = mode !== void 0 ? mode : "readonly";
    if (mode !== "readonly" && mode !== "readwrite" && mode !== "versionchange") {
      throw new TypeError("Invalid mode: " + mode);
    }
    const hasActiveVersionchange = this._rawDatabase.transactions.some((transaction) => {
      return transaction._state === "active" && transaction.mode === "versionchange" && transaction.db === this;
    });
    if (hasActiveVersionchange) {
      throw new InvalidStateError();
    }
    if (this._closePending) {
      throw new InvalidStateError();
    }
    if (!Array.isArray(storeNames)) {
      storeNames = [storeNames];
    }
    if (storeNames.length === 0 && mode !== "versionchange") {
      throw new InvalidAccessError();
    }
    for (const storeName of storeNames) {
      if (!this.objectStoreNames.contains(storeName)) {
        throw new NotFoundError("No objectStore named " + storeName + " in this database");
      }
    }
    const tx = new FDBTransaction(storeNames, mode, this);
    this._rawDatabase.transactions.push(tx);
    this._rawDatabase.processTransactions();
    return tx;
  }
  close() {
    closeConnection(this);
  }
  toString() {
    return "[object IDBDatabase]";
  }
}
class FDBOpenDBRequest extends FDBRequest {
  onupgradeneeded = null;
  onblocked = null;
  toString() {
    return "[object IDBOpenDBRequest]";
  }
}
class FDBVersionChangeEvent extends Event {
  constructor(type2, parameters = {}) {
    super(type2);
    this.newVersion = parameters.newVersion !== void 0 ? parameters.newVersion : null;
    this.oldVersion = parameters.oldVersion !== void 0 ? parameters.oldVersion : 0;
  }
  toString() {
    return "[object IDBVersionChangeEvent]";
  }
}
class Database {
  deletePending = false;
  transactions = [];
  rawObjectStores = /* @__PURE__ */ new Map();
  connections = [];
  constructor(name, version) {
    this.name = name;
    this.version = version;
    this.processTransactions = this.processTransactions.bind(this);
  }
  processTransactions() {
    queueTask(() => {
      const anyRunning = this.transactions.some((transaction) => {
        return transaction._started && transaction._state !== "finished";
      });
      if (!anyRunning) {
        const next = this.transactions.find((transaction) => {
          return !transaction._started && transaction._state !== "finished";
        });
        if (next) {
          next.addEventListener("complete", this.processTransactions);
          next.addEventListener("abort", this.processTransactions);
          next._start();
        }
      }
    });
  }
}
const waitForOthersClosedDelete = (databases, name, openDatabases, cb) => {
  const anyOpen = openDatabases.some((openDatabase2) => {
    return !openDatabase2._closed && !openDatabase2._closePending;
  });
  if (anyOpen) {
    queueTask(() => waitForOthersClosedDelete(databases, name, openDatabases, cb));
    return;
  }
  databases.delete(name);
  cb(null);
};
const deleteDatabase = (databases, name, request, cb) => {
  try {
    const db = databases.get(name);
    if (db === void 0) {
      cb(null);
      return;
    }
    db.deletePending = true;
    const openDatabases = db.connections.filter((connection) => {
      return !connection._closed && !connection._closePending;
    });
    for (const openDatabase2 of openDatabases) {
      if (!openDatabase2._closePending) {
        const event = new FDBVersionChangeEvent("versionchange", {
          newVersion: null,
          oldVersion: db.version
        });
        openDatabase2.dispatchEvent(event);
      }
    }
    const anyOpen = openDatabases.some((openDatabase3) => {
      return !openDatabase3._closed && !openDatabase3._closePending;
    });
    if (request && anyOpen) {
      const event = new FDBVersionChangeEvent("blocked", {
        newVersion: null,
        oldVersion: db.version
      });
      request.dispatchEvent(event);
    }
    waitForOthersClosedDelete(databases, name, openDatabases, cb);
  } catch (err) {
    cb(err);
  }
};
const runVersionchangeTransaction = (connection, version, request, cb) => {
  connection._runningVersionchangeTransaction = true;
  const oldVersion = connection.version;
  const openDatabases = connection._rawDatabase.connections.filter((otherDatabase) => {
    return connection !== otherDatabase;
  });
  for (const openDatabase2 of openDatabases) {
    if (!openDatabase2._closed && !openDatabase2._closePending) {
      const event = new FDBVersionChangeEvent("versionchange", {
        newVersion: version,
        oldVersion
      });
      openDatabase2.dispatchEvent(event);
    }
  }
  const anyOpen = openDatabases.some((openDatabase3) => {
    return !openDatabase3._closed && !openDatabase3._closePending;
  });
  if (anyOpen) {
    const event = new FDBVersionChangeEvent("blocked", {
      newVersion: version,
      oldVersion
    });
    request.dispatchEvent(event);
  }
  const waitForOthersClosed = () => {
    const anyOpen2 = openDatabases.some((openDatabase2) => {
      return !openDatabase2._closed && !openDatabase2._closePending;
    });
    if (anyOpen2) {
      queueTask(waitForOthersClosed);
      return;
    }
    connection._rawDatabase.version = version;
    connection.version = version;
    const transaction = connection.transaction(connection.objectStoreNames, "versionchange");
    request.result = connection;
    request.readyState = "done";
    request.transaction = transaction;
    transaction._rollbackLog.push(() => {
      connection._rawDatabase.version = oldVersion;
      connection.version = oldVersion;
    });
    const event = new FDBVersionChangeEvent("upgradeneeded", {
      newVersion: version,
      oldVersion
    });
    request.dispatchEvent(event);
    transaction.addEventListener("error", () => {
      connection._runningVersionchangeTransaction = false;
    });
    transaction.addEventListener("abort", () => {
      connection._runningVersionchangeTransaction = false;
      request.transaction = null;
      queueTask(() => {
        cb(new AbortError());
      });
    });
    transaction.addEventListener("complete", () => {
      connection._runningVersionchangeTransaction = false;
      request.transaction = null;
      queueTask(() => {
        if (connection._closePending) {
          cb(new AbortError());
        } else {
          cb(null);
        }
      });
    });
  };
  waitForOthersClosed();
};
const openDatabase = (databases, name, version, request, cb) => {
  let db = databases.get(name);
  if (db === void 0) {
    db = new Database(name, 0);
    databases.set(name, db);
  }
  if (version === void 0) {
    version = db.version !== 0 ? db.version : 1;
  }
  if (db.version > version) {
    return cb(new VersionError());
  }
  const connection = new FDBDatabase(db);
  if (db.version < version) {
    runVersionchangeTransaction(connection, version, request, (err) => {
      if (err) {
        return cb(err);
      }
      cb(null, connection);
    });
  } else {
    cb(null, connection);
  }
};
class FDBFactory {
  cmp = cmp;
  _databases = /* @__PURE__ */ new Map();
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBFactory-deleteDatabase-IDBOpenDBRequest-DOMString-name
  deleteDatabase(name) {
    const request = new FDBOpenDBRequest();
    request.source = null;
    queueTask(() => {
      const db = this._databases.get(name);
      const oldVersion = db !== void 0 ? db.version : 0;
      deleteDatabase(this._databases, name, request, (err) => {
        if (err) {
          request.error = new Error();
          request.error.name = err.name;
          request.readyState = "done";
          const event = new Event("error", {
            bubbles: true,
            cancelable: true
          });
          event.eventPath = [];
          request.dispatchEvent(event);
          return;
        }
        request.result = void 0;
        request.readyState = "done";
        const event2 = new FDBVersionChangeEvent("success", {
          newVersion: null,
          oldVersion
        });
        request.dispatchEvent(event2);
      });
    });
    return request;
  }
  // tslint:disable-next-line max-line-length
  // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBFactory-open-IDBOpenDBRequest-DOMString-name-unsigned-long-long-version
  open(name, version) {
    if (arguments.length > 1 && version !== void 0) {
      version = enforceRange(version, "MAX_SAFE_INTEGER");
    }
    if (version === 0) {
      throw new TypeError();
    }
    const request = new FDBOpenDBRequest();
    request.source = null;
    queueTask(() => {
      openDatabase(this._databases, name, version, request, (err, connection) => {
        if (err) {
          request.result = void 0;
          request.readyState = "done";
          request.error = new Error();
          request.error.name = err.name;
          const event = new Event("error", {
            bubbles: true,
            cancelable: true
          });
          event.eventPath = [];
          request.dispatchEvent(event);
          return;
        }
        request.result = connection;
        request.readyState = "done";
        const event2 = new Event("success");
        event2.eventPath = [];
        request.dispatchEvent(event2);
      });
    });
    return request;
  }
  // https://w3c.github.io/IndexedDB/#dom-idbfactory-databases
  databases() {
    return new Promise((resolve) => {
      const result = [];
      for (const [name, database] of this._databases) {
        result.push({
          name,
          version: database.version
        });
      }
      resolve(result);
    });
  }
  toString() {
    return "[object IDBFactory]";
  }
}
const fakeIndexedDB = new FDBFactory();
var lib$2 = {};
var plugin = {};
var rxSchema = {};
var hooks = {};
Object.defineProperty(hooks, "__esModule", {
  value: true
});
hooks.HOOKS = void 0;
hooks._clearHook = _clearHook;
hooks.runAsyncPluginHooks = runAsyncPluginHooks;
hooks.runPluginHooks = runPluginHooks;
var HOOKS = {
  /**
   * Runs before a plugin is added.
   * Use this to block the usage of non-compatible plugins.
   */
  preAddRxPlugin: [],
  /**
   * functions that run before the database is created
   */
  preCreateRxDatabase: [],
  /**
   * runs after the database is created and prepared
   * but before the instance is returned to the user
   * @async
   */
  createRxDatabase: [],
  preCreateRxCollection: [],
  createRxCollection: [],
  /**
  * runs at the end of the destroy-process of a collection
  * @async
  */
  postDestroyRxCollection: [],
  /**
   * Runs after a collection is removed.
   * @async
   */
  postRemoveRxCollection: [],
  /**
    * functions that get the json-schema as input
    * to do additionally checks/manipulation
    */
  preCreateRxSchema: [],
  /**
   * functions that run after the RxSchema is created
   * gets RxSchema as attribute
   */
  createRxSchema: [],
  preCreateRxQuery: [],
  /**
   * Runs before a query is send to the
   * prepareQuery function of the storage engine.
   */
  prePrepareQuery: [],
  createRxDocument: [],
  /**
   * runs after a RxDocument is created,
   * cannot be async
   */
  postCreateRxDocument: [],
  /**
   * Runs before a RxStorageInstance is created
   * gets the params of createStorageInstance()
   * as attribute so you can manipulate them.
   * Notice that you have to clone stuff before mutating the inputs.
   */
  preCreateRxStorageInstance: [],
  /**
   * runs on the document-data before the document is migrated
   * {
   *   doc: Object, // original doc-data
   *   migrated: // migrated doc-data after run through migration-strategies
   * }
   */
  preMigrateDocument: [],
  /**
   * runs after the migration of a document has been done
   */
  postMigrateDocument: [],
  /**
   * runs at the beginning of the destroy-process of a database
   */
  preDestroyRxDatabase: [],
  /**
   * runs after a database has been removed
   * @async
   */
  postRemoveRxDatabase: [],
  /**
   * runs before the replication writes the rows to master
   * but before the rows have been modified
   * @async
   */
  preReplicationMasterWrite: [],
  /**
   * runs after the replication has been sent to the server
   * but before the new documents have been handled
   * @async
   */
  preReplicationMasterWriteDocumentsHandle: []
};
hooks.HOOKS = HOOKS;
function runPluginHooks(hookKey, obj) {
  if (HOOKS[hookKey]) {
    HOOKS[hookKey].forEach((fun) => fun(obj));
  }
}
function runAsyncPluginHooks(hookKey, obj) {
  return Promise.all(HOOKS[hookKey].map((fun) => fun(obj)));
}
function _clearHook(type2, fun) {
  HOOKS[type2] = HOOKS[type2].filter((h2) => h2 !== fun);
}
var rxDocument = {};
var rxChangeEvent = {};
Object.defineProperty(rxChangeEvent, "__esModule", {
  value: true
});
rxChangeEvent.flattenEvents = flattenEvents;
rxChangeEvent.getDocumentDataOfRxChangeEvent = getDocumentDataOfRxChangeEvent;
rxChangeEvent.rxChangeEventToEventReduceChangeEvent = rxChangeEventToEventReduceChangeEvent;
var _overwritable$7 = overwritable$1;
var _utils$i = utils;
function getDocumentDataOfRxChangeEvent(rxChangeEvent2) {
  if (rxChangeEvent2.documentData) {
    return rxChangeEvent2.documentData;
  } else {
    return rxChangeEvent2.previousDocumentData;
  }
}
function rxChangeEventToEventReduceChangeEvent(rxChangeEvent2) {
  switch (rxChangeEvent2.operation) {
    case "INSERT":
      return {
        operation: rxChangeEvent2.operation,
        id: rxChangeEvent2.documentId,
        doc: rxChangeEvent2.documentData,
        previous: null
      };
    case "UPDATE":
      return {
        operation: rxChangeEvent2.operation,
        id: rxChangeEvent2.documentId,
        doc: _overwritable$7.overwritable.deepFreezeWhenDevMode(rxChangeEvent2.documentData),
        previous: rxChangeEvent2.previousDocumentData ? rxChangeEvent2.previousDocumentData : "UNKNOWN"
      };
    case "DELETE":
      return {
        operation: rxChangeEvent2.operation,
        id: rxChangeEvent2.documentId,
        doc: null,
        previous: rxChangeEvent2.previousDocumentData
      };
  }
}
function flattenEvents(input) {
  var output = [];
  if (Array.isArray(input)) {
    input.forEach((inputItem) => {
      var add2 = flattenEvents(inputItem);
      (0, _utils$i.appendToArray)(output, add2);
    });
  } else {
    if (input.id && input.events) {
      input.events.forEach((ev) => output.push(ev));
    } else {
      output.push(input);
    }
  }
  var usedIds = /* @__PURE__ */ new Set();
  var nonDuplicate = [];
  output.forEach((ev) => {
    if (!usedIds.has(ev.eventId)) {
      usedIds.add(ev.eventId);
      nonDuplicate.push(ev);
    }
  });
  return nonDuplicate;
}
var incrementalWrite = {};
Object.defineProperty(incrementalWrite, "__esModule", {
  value: true
});
incrementalWrite.IncrementalWriteQueue = void 0;
incrementalWrite.findNewestOfDocumentStates = findNewestOfDocumentStates;
incrementalWrite.modifierFromPublicToInternal = modifierFromPublicToInternal;
var _rxError$9 = rxError;
var _utils$h = utils;
var IncrementalWriteQueue = /* @__PURE__ */ function() {
  function IncrementalWriteQueue2(storageInstance, primaryPath, preWrite, postWrite) {
    this.queueByDocId = /* @__PURE__ */ new Map();
    this.isRunning = false;
    this.storageInstance = storageInstance;
    this.primaryPath = primaryPath;
    this.preWrite = preWrite;
    this.postWrite = postWrite;
  }
  var _proto = IncrementalWriteQueue2.prototype;
  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {
    var docId = lastKnownDocumentState[this.primaryPath];
    var ar = (0, _utils$h.getFromMapOrCreate)(this.queueByDocId, docId, () => []);
    var ret = new Promise((resolve, reject) => {
      var item = {
        lastKnownDocumentState,
        modifier,
        resolve,
        reject
      };
      (0, _utils$h.ensureNotFalsy)(ar).push(item);
      this.triggerRun();
    });
    return ret;
  };
  _proto.triggerRun = async function triggerRun() {
    if (this.isRunning === true || this.queueByDocId.size === 0) {
      return;
    }
    this.isRunning = true;
    var writeRows = [];
    var itemsById = this.queueByDocId;
    this.queueByDocId = /* @__PURE__ */ new Map();
    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {
      var oldData = findNewestOfDocumentStates(items.map((i2) => i2.lastKnownDocumentState));
      var newData = oldData;
      for (var item of items) {
        try {
          newData = await item.modifier(
            /**
             * We have to clone() each time because the modifier
             * might throw while it already changed some properties
             * of the document.
             */
            (0, _utils$h.clone)(newData)
          );
        } catch (err) {
          item.reject(err);
          item.reject = () => {
          };
          item.resolve = () => {
          };
        }
      }
      try {
        await this.preWrite(newData, oldData);
      } catch (err) {
        items.forEach((item2) => item2.reject(err));
        return;
      }
      writeRows.push({
        previous: oldData,
        document: newData
      });
    }));
    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, "incremental-write") : {
      error: {},
      success: {}
    };
    await Promise.all(Array.from(Object.entries(writeResult.success)).map(([docId, result]) => {
      this.postWrite(result);
      var items = (0, _utils$h.getFromMapOrThrow)(itemsById, docId);
      items.forEach((item) => item.resolve(result));
    }));
    Array.from(Object.entries(writeResult.error)).forEach(([docId, error]) => {
      var items = (0, _utils$h.getFromMapOrThrow)(itemsById, docId);
      var isConflict = (0, _rxError$9.isBulkWriteConflictError)(error);
      if (isConflict) {
        var ar = (0, _utils$h.getFromMapOrCreate)(this.queueByDocId, docId, () => []);
        items.reverse().forEach((item) => {
          item.lastKnownDocumentState = (0, _utils$h.ensureNotFalsy)(isConflict.documentInDb);
          (0, _utils$h.ensureNotFalsy)(ar).unshift(item);
        });
      } else {
        var rxError2 = (0, _rxError$9.rxStorageWriteErrorToRxError)(error);
        items.forEach((item) => item.reject(rxError2));
      }
    });
    this.isRunning = false;
    return this.triggerRun();
  };
  return IncrementalWriteQueue2;
}();
incrementalWrite.IncrementalWriteQueue = IncrementalWriteQueue;
function modifierFromPublicToInternal(publicModifier) {
  var ret = async (docData) => {
    var withoutMeta = (0, _utils$h.stripMetaDataFromDocument)(docData);
    withoutMeta._deleted = docData._deleted;
    var modified = await publicModifier(withoutMeta);
    var reattachedMeta = Object.assign({}, modified, {
      _meta: docData._meta,
      _attachments: docData._attachments,
      _rev: docData._rev,
      _deleted: typeof modified._deleted !== "undefined" ? modified._deleted : docData._deleted
    });
    if (typeof reattachedMeta._deleted === "undefined") {
      reattachedMeta._deleted = false;
    }
    return reattachedMeta;
  };
  return ret;
}
function findNewestOfDocumentStates(docs) {
  var newest = docs[0];
  var newestRevisionHeight = (0, _utils$h.parseRevision)(newest._rev).height;
  docs.forEach((doc) => {
    var height = (0, _utils$h.parseRevision)(doc._rev).height;
    if (height > newestRevisionHeight) {
      newest = doc;
      newestRevisionHeight = height;
    }
  });
  return newest;
}
Object.defineProperty(rxDocument, "__esModule", {
  value: true
});
rxDocument.basePrototype = void 0;
rxDocument.beforeDocumentUpdateWrite = beforeDocumentUpdateWrite;
rxDocument.createRxDocumentConstructor = createRxDocumentConstructor;
rxDocument.createWithConstructor = createWithConstructor;
rxDocument.defineGetterSetter = defineGetterSetter;
rxDocument.isRxDocument = isRxDocument;
var _operators$4 = operators;
var _utils$g = utils;
var _rxError$8 = rxError;
var _hooks$7 = hooks;
var _rxChangeEvent = rxChangeEvent;
var _overwritable$6 = overwritable$1;
var _rxSchemaHelper$7 = rxSchemaHelper;
var _rxStorageHelper$8 = rxStorageHelper;
var _incrementalWrite$1 = incrementalWrite;
var basePrototype = {
  get primaryPath() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.collection.schema.primaryPath;
  },
  get primary() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data[_this.primaryPath];
  },
  get revision() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._rev;
  },
  get deleted$() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.$.pipe((0, _operators$4.map)((d2) => d2._deleted));
  },
  get deleted() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._deleted;
  },
  getLatest() {
    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);
    return this.collection._docCache.getCachedRxDocument(latestDocData);
  },
  /**
   * returns the observable which emits the plain-data of this document
   */
  get $() {
    var _this = this;
    return _this.collection.$.pipe((0, _operators$4.filter)((changeEvent) => !changeEvent.isLocal), (0, _operators$4.filter)((changeEvent) => changeEvent.documentId === this.primary), (0, _operators$4.map)((changeEvent) => (0, _rxChangeEvent.getDocumentDataOfRxChangeEvent)(changeEvent)), (0, _operators$4.startWith)(_this.collection._docCache.getLatestDocumentData(this.primary)), (0, _operators$4.distinctUntilChanged)((prev, curr) => prev._rev === curr._rev), (0, _operators$4.map)((docData) => this.collection._docCache.getCachedRxDocument(docData)), (0, _operators$4.shareReplay)(_utils$g.RXJS_SHARE_REPLAY_DEFAULTS));
  },
  /**
   * returns observable of the value of the given path
   */
  get$(path2) {
    if (_overwritable$6.overwritable.isDevMode()) {
      if (path2.includes(".item.")) {
        throw (0, _rxError$8.newRxError)("DOC1", {
          path: path2
        });
      }
      if (path2 === this.primaryPath) {
        throw (0, _rxError$8.newRxError)("DOC2");
      }
      if (this.collection.schema.finalFields.includes(path2)) {
        throw (0, _rxError$8.newRxError)("DOC3", {
          path: path2
        });
      }
      var schemaObj = (0, _rxSchemaHelper$7.getSchemaByObjectPath)(this.collection.schema.jsonSchema, path2);
      if (!schemaObj) {
        throw (0, _rxError$8.newRxError)("DOC4", {
          path: path2
        });
      }
    }
    return this.$.pipe((0, _operators$4.map)((data) => (0, _utils$g.getProperty)(data, path2)), (0, _operators$4.distinctUntilChanged)());
  },
  /**
   * populate the given path
   */
  populate(path2) {
    var schemaObj = (0, _rxSchemaHelper$7.getSchemaByObjectPath)(this.collection.schema.jsonSchema, path2);
    var value = this.get(path2);
    if (!value) {
      return _utils$g.PROMISE_RESOLVE_NULL;
    }
    if (!schemaObj) {
      throw (0, _rxError$8.newRxError)("DOC5", {
        path: path2
      });
    }
    if (!schemaObj.ref) {
      throw (0, _rxError$8.newRxError)("DOC6", {
        path: path2,
        schemaObj
      });
    }
    var refCollection = this.collection.database.collections[schemaObj.ref];
    if (!refCollection) {
      throw (0, _rxError$8.newRxError)("DOC7", {
        ref: schemaObj.ref,
        path: path2,
        schemaObj
      });
    }
    if (schemaObj.type === "array") {
      return refCollection.findByIds(value).exec().then((res) => {
        var valuesIterator = res.values();
        return Array.from(valuesIterator);
      });
    } else {
      return refCollection.findOne(value).exec();
    }
  },
  /**
   * get data by objectPath
   */
  get(objPath) {
    if (!this._data) {
      return void 0;
    }
    var fromCache = this._propertyCache.get(objPath);
    if (fromCache) {
      return fromCache;
    }
    var valueObj = (0, _utils$g.getProperty)(this._data, objPath);
    if (typeof valueObj !== "object" || Array.isArray(valueObj)) {
      return _overwritable$6.overwritable.deepFreezeWhenDevMode(valueObj);
    }
    valueObj = (0, _utils$g.clone)(valueObj);
    defineGetterSetter(this.collection.schema, valueObj, objPath, this);
    this._propertyCache.set(objPath, valueObj);
    return valueObj;
  },
  toJSON(withMetaFields = false) {
    if (!withMetaFields) {
      var data = (0, _utils$g.flatClone)(this._data);
      delete data._rev;
      delete data._attachments;
      delete data._deleted;
      delete data._meta;
      return _overwritable$6.overwritable.deepFreezeWhenDevMode(data);
    } else {
      return _overwritable$6.overwritable.deepFreezeWhenDevMode(this._data);
    }
  },
  toMutableJSON(withMetaFields = false) {
    return (0, _utils$g.clone)(this.toJSON(withMetaFields));
  },
  /**
   * updates document
   * @overwritten by plugin (optional)
   * @param updateObj mongodb-like syntax
   */
  update(_updateObj) {
    throw (0, _utils$g.pluginMissing)("update");
  },
  incrementalUpdate(_updateObj) {
    throw (0, _utils$g.pluginMissing)("update");
  },
  updateCRDT(_updateObj) {
    throw (0, _utils$g.pluginMissing)("crdt");
  },
  putAttachment() {
    throw (0, _utils$g.pluginMissing)("attachments");
  },
  getAttachment() {
    throw (0, _utils$g.pluginMissing)("attachments");
  },
  allAttachments() {
    throw (0, _utils$g.pluginMissing)("attachments");
  },
  get allAttachments$() {
    throw (0, _utils$g.pluginMissing)("attachments");
  },
  async modify(mutationFunction, _context) {
    var oldData = this._data;
    var newData = await (0, _incrementalWrite$1.modifierFromPublicToInternal)(mutationFunction)(oldData);
    return this._saveData(newData, oldData);
  },
  /**
   * runs an incremental update over the document
   * @param function that takes the document-data and returns a new data-object
   */
  incrementalModify(mutationFunction, _context) {
    return this.collection.incrementalWriteQueue.addWrite(this._data, (0, _incrementalWrite$1.modifierFromPublicToInternal)(mutationFunction)).then((result) => this.collection._docCache.getCachedRxDocument(result));
  },
  patch(patch) {
    var oldData = this._data;
    var newData = (0, _utils$g.clone)(oldData);
    Object.entries(patch).forEach(([k2, v2]) => {
      newData[k2] = v2;
    });
    return this._saveData(newData, oldData);
  },
  /**
   * patches the given properties
   */
  incrementalPatch(patch) {
    return this.incrementalModify((docData) => {
      Object.entries(patch).forEach(([k2, v2]) => {
        docData[k2] = v2;
      });
      return docData;
    });
  },
  /**
   * saves the new document-data
   * and handles the events
   */
  async _saveData(newData, oldData) {
    newData = (0, _utils$g.flatClone)(newData);
    if (this._data._deleted) {
      throw (0, _rxError$8.newRxError)("DOC11", {
        id: this.primary,
        document: this
      });
    }
    await beforeDocumentUpdateWrite(this.collection, newData, oldData);
    var writeResult = await this.collection.storageInstance.bulkWrite([{
      previous: oldData,
      document: newData
    }], "rx-document-save-data");
    var isError = writeResult.error[this.primary];
    (0, _rxStorageHelper$8.throwIfIsStorageWriteError)(this.collection, this.primary, newData, isError);
    await this.collection._runHooks("post", "save", newData, this);
    return this.collection._docCache.getCachedRxDocument((0, _utils$g.getFromObjectOrThrow)(writeResult.success, this.primary));
  },
  /**
   * Remove the document.
   * Notice that there is no hard delete,
   * instead deleted documents get flagged with _deleted=true.
   */
  remove() {
    var collection = this.collection;
    if (this.deleted) {
      return Promise.reject((0, _rxError$8.newRxError)("DOC13", {
        document: this,
        id: this.primary
      }));
    }
    var deletedData = (0, _utils$g.flatClone)(this._data);
    var removedDocData;
    return collection._runHooks("pre", "remove", deletedData, this).then(async () => {
      deletedData._deleted = true;
      var writeResult = await collection.storageInstance.bulkWrite([{
        previous: this._data,
        document: deletedData
      }], "rx-document-remove");
      var isError = writeResult.error[this.primary];
      (0, _rxStorageHelper$8.throwIfIsStorageWriteError)(collection, this.primary, deletedData, isError);
      return (0, _utils$g.getFromObjectOrThrow)(writeResult.success, this.primary);
    }).then((removed) => {
      removedDocData = removed;
      return this.collection._runHooks("post", "remove", deletedData, this);
    }).then(() => {
      return this.collection._docCache.getCachedRxDocument(removedDocData);
    });
  },
  incrementalRemove() {
    return this.incrementalModify(async (docData) => {
      await this.collection._runHooks("pre", "remove", docData, this);
      docData._deleted = true;
      return docData;
    }).then(async (newDoc) => {
      await this.collection._runHooks("post", "remove", newDoc._data, newDoc);
      return newDoc;
    });
  },
  destroy() {
    throw (0, _rxError$8.newRxError)("DOC14");
  }
};
rxDocument.basePrototype = basePrototype;
function createRxDocumentConstructor(proto = basePrototype) {
  var constructor = function RxDocumentConstructor(collection, docData) {
    this.collection = collection;
    this._data = docData;
    this._propertyCache = /* @__PURE__ */ new Map();
    this.isInstanceOfRxDocument = true;
  };
  constructor.prototype = proto;
  return constructor;
}
function defineGetterSetter(schema, valueObj, objPath = "", thisObj = false) {
  if (valueObj === null) {
    return;
  }
  var pathProperties = (0, _rxSchemaHelper$7.getSchemaByObjectPath)(schema.jsonSchema, objPath);
  if (typeof pathProperties === "undefined")
    return;
  if (pathProperties.properties)
    pathProperties = pathProperties.properties;
  Object.keys(pathProperties).forEach((key) => {
    var fullPath = (0, _utils$g.trimDots)(objPath + "." + key);
    valueObj.__defineGetter__(key, function() {
      var _this = thisObj ? thisObj : this;
      if (!_this.get || typeof _this.get !== "function") {
        return void 0;
      }
      var ret = _this.get(fullPath);
      return ret;
    });
    Object.defineProperty(valueObj, key + "$", {
      get: function() {
        var _this = thisObj ? thisObj : this;
        return _this.get$(fullPath);
      },
      enumerable: false,
      configurable: false
    });
    Object.defineProperty(valueObj, key + "_", {
      get: function() {
        var _this = thisObj ? thisObj : this;
        return _this.populate(fullPath);
      },
      enumerable: false,
      configurable: false
    });
    valueObj.__defineSetter__(key, function(val) {
      var _this = thisObj ? thisObj : this;
      return _this.set(fullPath, val);
    });
  });
}
function createWithConstructor(constructor, collection, jsonData) {
  var doc = new constructor(collection, jsonData);
  (0, _hooks$7.runPluginHooks)("createRxDocument", doc);
  return doc;
}
function isRxDocument(obj) {
  return typeof obj === "object" && obj !== null && "isInstanceOfRxDocument" in obj;
}
function beforeDocumentUpdateWrite(collection, newData, oldData) {
  newData._meta = Object.assign({}, oldData._meta, newData._meta);
  if (_overwritable$6.overwritable.isDevMode()) {
    collection.schema.validateChange(oldData, newData);
  }
  return collection._runHooks("pre", "save", newData, oldData);
}
var _interopRequireDefault$4 = interopRequireDefaultExports$1;
Object.defineProperty(rxSchema, "__esModule", {
  value: true
});
rxSchema.RxSchema = void 0;
rxSchema.createRxSchema = createRxSchema;
rxSchema.getIndexes = getIndexes;
rxSchema.getPreviousVersions = getPreviousVersions;
rxSchema.isRxSchema = isRxSchema;
rxSchema.toTypedRxJsonSchema = toTypedRxJsonSchema;
var _createClass2$3 = _interopRequireDefault$4(requireCreateClass());
var _utils$f = utils;
var _rxError$7 = rxError;
var _hooks$6 = hooks;
var _rxDocument$3 = rxDocument;
var _rxSchemaHelper$6 = rxSchemaHelper;
var _overwritable$5 = overwritable$1;
var RxSchema = /* @__PURE__ */ function() {
  function RxSchema2(jsonSchema2, hashFunction) {
    this.jsonSchema = jsonSchema2;
    this.hashFunction = hashFunction;
    this.indexes = getIndexes(this.jsonSchema);
    this.primaryPath = (0, _rxSchemaHelper$6.getPrimaryFieldOfPrimaryKey)(this.jsonSchema.primaryKey);
    this.finalFields = (0, _rxSchemaHelper$6.getFinalFields)(this.jsonSchema);
  }
  var _proto = RxSchema2.prototype;
  _proto.validateChange = function validateChange(dataBefore, dataAfter) {
    this.finalFields.forEach((fieldName) => {
      if (!(0, _utils$f.deepEqual)(dataBefore[fieldName], dataAfter[fieldName])) {
        throw (0, _rxError$7.newRxError)("DOC9", {
          dataBefore,
          dataAfter,
          fieldName,
          schema: this.jsonSchema
        });
      }
    });
  };
  _proto.getDocumentPrototype = function getDocumentPrototype2() {
    var proto = {};
    (0, _rxDocument$3.defineGetterSetter)(this, proto, "");
    (0, _utils$f.overwriteGetterForCaching)(this, "getDocumentPrototype", () => proto);
    return proto;
  };
  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {
    return (0, _rxSchemaHelper$6.getComposedPrimaryKeyOfDocumentData)(this.jsonSchema, documentData);
  };
  (0, _createClass2$3.default)(RxSchema2, [{
    key: "version",
    get: function() {
      return this.jsonSchema.version;
    }
  }, {
    key: "defaultValues",
    get: function() {
      var values = {};
      Object.entries(this.jsonSchema.properties).filter(([, v2]) => v2.hasOwnProperty("default")).forEach(([k2, v2]) => values[k2] = v2.default);
      return (0, _utils$f.overwriteGetterForCaching)(this, "defaultValues", values);
    }
    /**
     * @overrides itself on the first call
     *
     * TODO this should be a pure function that
     * caches the hash in a WeakMap.
     */
  }, {
    key: "hash",
    get: function() {
      return (0, _utils$f.overwriteGetterForCaching)(this, "hash", this.hashFunction(JSON.stringify(this.jsonSchema)));
    }
  }]);
  return RxSchema2;
}();
rxSchema.RxSchema = RxSchema;
function getIndexes(jsonSchema2) {
  return (jsonSchema2.indexes || []).map((index) => (0, _utils$f.isMaybeReadonlyArray)(index) ? index : [index]);
}
function getPreviousVersions(schema) {
  var version = schema.version ? schema.version : 0;
  var c2 = 0;
  return new Array(version).fill(0).map(() => c2++);
}
function createRxSchema(jsonSchema2, hashFunction, runPreCreateHooks = true) {
  if (runPreCreateHooks) {
    (0, _hooks$6.runPluginHooks)("preCreateRxSchema", jsonSchema2);
  }
  var useJsonSchema = (0, _rxSchemaHelper$6.fillWithDefaultSettings)(jsonSchema2);
  useJsonSchema = (0, _rxSchemaHelper$6.normalizeRxJsonSchema)(useJsonSchema);
  _overwritable$5.overwritable.deepFreezeWhenDevMode(useJsonSchema);
  var schema = new RxSchema(useJsonSchema, hashFunction);
  (0, _hooks$6.runPluginHooks)("createRxSchema", schema);
  return schema;
}
function isRxSchema(obj) {
  return obj instanceof RxSchema;
}
function toTypedRxJsonSchema(schema) {
  return schema;
}
var rxQuery = {};
var eventReduce = {};
var lib$1 = {};
var states = {};
var stateResolver = {};
var util$1 = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1)
    return util$1;
  hasRequiredUtil$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProperty = exports.isObject = exports.roundToTwoDecimals = exports.mergeSets = exports.ensureNotFalsy = exports.flatClone = exports.cloneMap = exports.objectToMap = exports.mapToObject = exports.replaceCharAt = exports.getSortFieldsOfQuery = exports.normalizeSortField = exports.tryToFillPreviousDoc = exports.shuffleArray = exports.randomOfArray = exports.lastOfArray = exports.UNKNOWN_VALUE = void 0;
    exports.UNKNOWN_VALUE = "UNKNOWN";
    function lastOfArray2(ar) {
      return ar[ar.length - 1];
    }
    exports.lastOfArray = lastOfArray2;
    function randomOfArray(items) {
      return items[Math.floor(Math.random() * items.length)];
    }
    exports.randomOfArray = randomOfArray;
    function shuffleArray2(arr) {
      return arr.slice().sort(() => Math.random() - 0.5);
    }
    exports.shuffleArray = shuffleArray2;
    function tryToFillPreviousDoc(input) {
      const prev = input.changeEvent.previous;
      if (prev === exports.UNKNOWN_VALUE) {
        const id = input.changeEvent.id;
        const primary = input.queryParams.primaryKey;
        if (input.keyDocumentMap) {
          const doc = input.keyDocumentMap.get(id);
          if (doc) {
            input.changeEvent.previous = doc;
          }
        } else {
          const found = input.previousResults.find((item) => item[primary] === id);
          if (found) {
            input.changeEvent.previous = found;
          }
        }
      }
    }
    exports.tryToFillPreviousDoc = tryToFillPreviousDoc;
    function normalizeSortField(field) {
      if (field.startsWith("-")) {
        return field.substr(1);
      } else {
        return field;
      }
    }
    exports.normalizeSortField = normalizeSortField;
    function getSortFieldsOfQuery(query2) {
      if (!query2.sort) {
        return ["_id"];
      }
      return query2.sort.map((maybeArray) => {
        if (Array.isArray(maybeArray)) {
          return maybeArray[0].map((field) => normalizeSortField(field));
        } else {
          return normalizeSortField(maybeArray);
        }
      });
    }
    exports.getSortFieldsOfQuery = getSortFieldsOfQuery;
    function replaceCharAt(str, index, replacement) {
      return str.substr(0, index) + replacement + str.substr(index + replacement.length);
    }
    exports.replaceCharAt = replaceCharAt;
    function mapToObject(map2) {
      const ret = {};
      map2.forEach((value, key) => {
        ret[key] = value;
      });
      return ret;
    }
    exports.mapToObject = mapToObject;
    function objectToMap(object2) {
      const ret = /* @__PURE__ */ new Map();
      Object.entries(object2).forEach(([k2, v2]) => {
        ret.set(k2, v2);
      });
      return ret;
    }
    exports.objectToMap = objectToMap;
    function cloneMap(map2) {
      const ret = /* @__PURE__ */ new Map();
      map2.forEach((value, key) => {
        ret[key] = value;
      });
      return ret;
    }
    exports.cloneMap = cloneMap;
    function flatClone2(obj) {
      return Object.assign({}, obj);
    }
    exports.flatClone = flatClone2;
    function ensureNotFalsy2(obj) {
      if (!obj) {
        throw new Error("ensureNotFalsy() is falsy");
      }
      return obj;
    }
    exports.ensureNotFalsy = ensureNotFalsy2;
    function mergeSets(sets) {
      let ret = /* @__PURE__ */ new Set();
      sets.forEach((set2) => {
        ret = /* @__PURE__ */ new Set([...ret, ...set2]);
      });
      return ret;
    }
    exports.mergeSets = mergeSets;
    function roundToTwoDecimals(num) {
      return parseFloat(num.toFixed(2));
    }
    exports.roundToTwoDecimals = roundToTwoDecimals;
    function isObject2(value) {
      const type2 = typeof value;
      return value !== null && (type2 === "object" || type2 === "function");
    }
    exports.isObject = isObject2;
    function getProperty2(object2, path2, value) {
      if (Array.isArray(path2)) {
        path2 = path2.join(".");
      }
      if (!isObject2(object2) || typeof path2 !== "string") {
        return value === void 0 ? object2 : value;
      }
      const pathArray = path2.split(".");
      if (pathArray.length === 0) {
        return value;
      }
      for (let index = 0; index < pathArray.length; index++) {
        const key = pathArray[index];
        if (isStringIndex2(object2, key)) {
          object2 = index === pathArray.length - 1 ? void 0 : null;
        } else {
          object2 = object2[key];
        }
        if (object2 === void 0 || object2 === null) {
          if (index !== pathArray.length - 1) {
            return value;
          }
          break;
        }
      }
      return object2 === void 0 ? value : object2;
    }
    exports.getProperty = getProperty2;
    function isStringIndex2(object2, key) {
      if (typeof key !== "number" && Array.isArray(object2)) {
        const index = Number.parseInt(key, 10);
        return Number.isInteger(index) && object2[index] === object2[key];
      }
      return false;
    }
  })(util$1);
  return util$1;
}
var hasRequiredStateResolver;
function requireStateResolver() {
  if (hasRequiredStateResolver)
    return stateResolver;
  hasRequiredStateResolver = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wasResultsEmpty = exports.doesMatchNow = exports.wasMatching = exports.isSortedAfterLast = exports.isSortedBeforeFirst = exports.wasSortedAfterLast = exports.wasSortedBeforeFirst = exports.wasLast = exports.wasFirst = exports.wasInResult = exports.sortParamsChanged = exports.wasLimitReached = exports.previousUnknown = exports.isUpdate = exports.isInsert = exports.isDelete = exports.hasSkip = exports.isFindOne = exports.hasLimit = void 0;
    const util_12 = requireUtil$1();
    const hasLimit = (input) => {
      return !!input.queryParams.limit;
    };
    exports.hasLimit = hasLimit;
    const isFindOne = (input) => {
      return input.queryParams.limit === 1;
    };
    exports.isFindOne = isFindOne;
    const hasSkip = (input) => {
      if (input.queryParams.skip && input.queryParams.skip > 0) {
        return true;
      } else {
        return false;
      }
    };
    exports.hasSkip = hasSkip;
    const isDelete = (input) => {
      return input.changeEvent.operation === "DELETE";
    };
    exports.isDelete = isDelete;
    const isInsert = (input) => {
      return input.changeEvent.operation === "INSERT";
    };
    exports.isInsert = isInsert;
    const isUpdate = (input) => {
      return input.changeEvent.operation === "UPDATE";
    };
    exports.isUpdate = isUpdate;
    const previousUnknown = (input) => {
      return input.changeEvent.previous === util_12.UNKNOWN_VALUE;
    };
    exports.previousUnknown = previousUnknown;
    const wasLimitReached = (input) => {
      return (0, exports.hasLimit)(input) && input.previousResults.length >= input.queryParams.limit;
    };
    exports.wasLimitReached = wasLimitReached;
    const sortParamsChanged = (input) => {
      const sortFields = input.queryParams.sortFields;
      const prev = input.changeEvent.previous;
      const doc = input.changeEvent.doc;
      if (!doc) {
        return false;
      }
      if (!prev || prev === util_12.UNKNOWN_VALUE) {
        return true;
      }
      for (let i2 = 0; i2 < sortFields.length; i2++) {
        const field = sortFields[i2];
        const beforeData = (0, util_12.getProperty)(prev, field);
        const afterData = (0, util_12.getProperty)(doc, field);
        if (beforeData !== afterData) {
          return true;
        }
      }
      return false;
    };
    exports.sortParamsChanged = sortParamsChanged;
    const wasInResult = (input) => {
      const id = input.changeEvent.id;
      if (input.keyDocumentMap) {
        const has = input.keyDocumentMap.has(id);
        return has;
      } else {
        const primary = input.queryParams.primaryKey;
        const results = input.previousResults;
        for (let i2 = 0; i2 < results.length; i2++) {
          const item = results[i2];
          if (item[primary] === id) {
            return true;
          }
        }
        return false;
      }
    };
    exports.wasInResult = wasInResult;
    const wasFirst = (input) => {
      const first2 = input.previousResults[0];
      if (first2 && first2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      } else {
        return false;
      }
    };
    exports.wasFirst = wasFirst;
    const wasLast = (input) => {
      const last2 = (0, util_12.lastOfArray)(input.previousResults);
      if (last2 && last2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      } else {
        return false;
      }
    };
    exports.wasLast = wasLast;
    const wasSortedBeforeFirst = (input) => {
      const prev = input.changeEvent.previous;
      if (!prev || prev === util_12.UNKNOWN_VALUE) {
        return false;
      }
      const first2 = input.previousResults[0];
      if (!first2) {
        return false;
      }
      if (first2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      }
      const comp = input.queryParams.sortComparator(prev, first2);
      return comp < 0;
    };
    exports.wasSortedBeforeFirst = wasSortedBeforeFirst;
    const wasSortedAfterLast = (input) => {
      const prev = input.changeEvent.previous;
      if (!prev || prev === util_12.UNKNOWN_VALUE) {
        return false;
      }
      const last2 = (0, util_12.lastOfArray)(input.previousResults);
      if (!last2) {
        return false;
      }
      if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      }
      const comp = input.queryParams.sortComparator(prev, last2);
      return comp > 0;
    };
    exports.wasSortedAfterLast = wasSortedAfterLast;
    const isSortedBeforeFirst = (input) => {
      const doc = input.changeEvent.doc;
      if (!doc) {
        return false;
      }
      const first2 = input.previousResults[0];
      if (!first2) {
        return false;
      }
      if (first2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      }
      const comp = input.queryParams.sortComparator(doc, first2);
      return comp < 0;
    };
    exports.isSortedBeforeFirst = isSortedBeforeFirst;
    const isSortedAfterLast = (input) => {
      const doc = input.changeEvent.doc;
      if (!doc) {
        return false;
      }
      const last2 = (0, util_12.lastOfArray)(input.previousResults);
      if (!last2) {
        return false;
      }
      if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
        return true;
      }
      const comp = input.queryParams.sortComparator(doc, last2);
      return comp > 0;
    };
    exports.isSortedAfterLast = isSortedAfterLast;
    const wasMatching = (input) => {
      const prev = input.changeEvent.previous;
      if (!prev || prev === util_12.UNKNOWN_VALUE) {
        return false;
      }
      return input.queryParams.queryMatcher(prev);
    };
    exports.wasMatching = wasMatching;
    const doesMatchNow = (input) => {
      const doc = input.changeEvent.doc;
      if (!doc) {
        return false;
      }
      const ret = input.queryParams.queryMatcher(doc);
      return ret;
    };
    exports.doesMatchNow = doesMatchNow;
    const wasResultsEmpty = (input) => {
      return input.previousResults.length === 0;
    };
    exports.wasResultsEmpty = wasResultsEmpty;
  })(stateResolver);
  return stateResolver;
}
var hasRequiredStates;
function requireStates() {
  if (hasRequiredStates)
    return states;
  hasRequiredStates = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logStateSet = exports.getStateSet = exports.resolveState = exports.stateResolveFunctionByIndex = exports.stateResolveFunctions = exports.orderedStateList = void 0;
    const state_resolver_1 = requireStateResolver();
    __exportStar(requireStateResolver(), exports);
    exports.orderedStateList = [
      "isInsert",
      "isUpdate",
      "isDelete",
      "hasLimit",
      "isFindOne",
      "hasSkip",
      "wasResultsEmpty",
      "previousUnknown",
      "wasLimitReached",
      "wasFirst",
      "wasLast",
      "sortParamsChanged",
      "wasInResult",
      "wasSortedBeforeFirst",
      "wasSortedAfterLast",
      "isSortedBeforeFirst",
      "isSortedAfterLast",
      "wasMatching",
      "doesMatchNow"
    ];
    exports.stateResolveFunctions = {
      isInsert: state_resolver_1.isInsert,
      isUpdate: state_resolver_1.isUpdate,
      isDelete: state_resolver_1.isDelete,
      hasLimit: state_resolver_1.hasLimit,
      isFindOne: state_resolver_1.isFindOne,
      hasSkip: state_resolver_1.hasSkip,
      wasResultsEmpty: state_resolver_1.wasResultsEmpty,
      previousUnknown: state_resolver_1.previousUnknown,
      wasLimitReached: state_resolver_1.wasLimitReached,
      wasFirst: state_resolver_1.wasFirst,
      wasLast: state_resolver_1.wasLast,
      sortParamsChanged: state_resolver_1.sortParamsChanged,
      wasInResult: state_resolver_1.wasInResult,
      wasSortedBeforeFirst: state_resolver_1.wasSortedBeforeFirst,
      wasSortedAfterLast: state_resolver_1.wasSortedAfterLast,
      isSortedBeforeFirst: state_resolver_1.isSortedBeforeFirst,
      isSortedAfterLast: state_resolver_1.isSortedAfterLast,
      wasMatching: state_resolver_1.wasMatching,
      doesMatchNow: state_resolver_1.doesMatchNow
    };
    exports.stateResolveFunctionByIndex = {
      0: state_resolver_1.isInsert,
      1: state_resolver_1.isUpdate,
      2: state_resolver_1.isDelete,
      3: state_resolver_1.hasLimit,
      4: state_resolver_1.isFindOne,
      5: state_resolver_1.hasSkip,
      6: state_resolver_1.wasResultsEmpty,
      7: state_resolver_1.previousUnknown,
      8: state_resolver_1.wasLimitReached,
      9: state_resolver_1.wasFirst,
      10: state_resolver_1.wasLast,
      11: state_resolver_1.sortParamsChanged,
      12: state_resolver_1.wasInResult,
      13: state_resolver_1.wasSortedBeforeFirst,
      14: state_resolver_1.wasSortedAfterLast,
      15: state_resolver_1.isSortedBeforeFirst,
      16: state_resolver_1.isSortedAfterLast,
      17: state_resolver_1.wasMatching,
      18: state_resolver_1.doesMatchNow
    };
    function resolveState(stateName, input) {
      const fn2 = exports.stateResolveFunctions[stateName];
      if (!fn2) {
        throw new Error("resolveState() has no function for " + stateName);
      }
      return fn2(input);
    }
    exports.resolveState = resolveState;
    function getStateSet(input) {
      let set2 = "";
      for (let i2 = 0; i2 < exports.orderedStateList.length; i2++) {
        const name = exports.orderedStateList[i2];
        const value = resolveState(name, input);
        const add2 = value ? "1" : "0";
        set2 += add2;
      }
      return set2;
    }
    exports.getStateSet = getStateSet;
    function logStateSet(stateSet) {
      exports.orderedStateList.forEach((state, index) => {
        console.log("state: " + state + " : " + stateSet[index]);
      });
    }
    exports.logStateSet = logStateSet;
  })(states);
  return states;
}
var actions = {};
var actionFunctions = {};
function pushAtSortPosition(array2, item, compareFunction, low) {
  var length = array2.length;
  var high = length - 1;
  var mid = 0;
  if (length === 0) {
    array2.push(item);
    return 0;
  }
  var lastMidDoc;
  while (low <= high) {
    mid = low + (high - low >> 1);
    lastMidDoc = array2[mid];
    if (compareFunction(lastMidDoc, item) <= 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  if (compareFunction(lastMidDoc, item) <= 0) {
    mid++;
  }
  array2.splice(mid, 0, item);
  return mid;
}
const es$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  pushAtSortPosition
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(es$1);
var hasRequiredActionFunctions;
function requireActionFunctions() {
  if (hasRequiredActionFunctions)
    return actionFunctions;
  hasRequiredActionFunctions = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unknownAction = exports.runFullQueryAgain = exports.removeExistingAndInsertAtSortPosition = exports.insertAtSortPosition = exports.alwaysWrong = exports.replaceExisting = exports.removeExisting = exports.removeLastInsertLast = exports.removeFirstInsertFirst = exports.removeLastInsertFirst = exports.removeFirstInsertLast = exports.removeLastItem = exports.removeFirstItem = exports.insertLast = exports.insertFirst = exports.doNothing = void 0;
    const array_push_at_sort_position_1 = require$$0;
    const doNothing = (_input) => {
    };
    exports.doNothing = doNothing;
    const insertFirst = (input) => {
      input.previousResults.unshift(input.changeEvent.doc);
      if (input.keyDocumentMap) {
        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
      }
    };
    exports.insertFirst = insertFirst;
    const insertLast = (input) => {
      input.previousResults.push(input.changeEvent.doc);
      if (input.keyDocumentMap) {
        input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
      }
    };
    exports.insertLast = insertLast;
    const removeFirstItem = (input) => {
      const first2 = input.previousResults.shift();
      if (input.keyDocumentMap && first2) {
        input.keyDocumentMap.delete(first2[input.queryParams.primaryKey]);
      }
    };
    exports.removeFirstItem = removeFirstItem;
    const removeLastItem = (input) => {
      const last2 = input.previousResults.pop();
      if (input.keyDocumentMap && last2) {
        input.keyDocumentMap.delete(last2[input.queryParams.primaryKey]);
      }
    };
    exports.removeLastItem = removeLastItem;
    const removeFirstInsertLast = (input) => {
      (0, exports.removeFirstItem)(input);
      (0, exports.insertLast)(input);
    };
    exports.removeFirstInsertLast = removeFirstInsertLast;
    const removeLastInsertFirst = (input) => {
      (0, exports.removeLastItem)(input);
      (0, exports.insertFirst)(input);
    };
    exports.removeLastInsertFirst = removeLastInsertFirst;
    const removeFirstInsertFirst = (input) => {
      (0, exports.removeFirstItem)(input);
      (0, exports.insertFirst)(input);
    };
    exports.removeFirstInsertFirst = removeFirstInsertFirst;
    const removeLastInsertLast = (input) => {
      (0, exports.removeLastItem)(input);
      (0, exports.insertLast)(input);
    };
    exports.removeLastInsertLast = removeLastInsertLast;
    const removeExisting = (input) => {
      if (input.keyDocumentMap) {
        input.keyDocumentMap.delete(input.changeEvent.id);
      }
      const primary = input.queryParams.primaryKey;
      const results = input.previousResults;
      for (let i2 = 0; i2 < results.length; i2++) {
        const item = results[i2];
        if (item[primary] === input.changeEvent.id) {
          results.splice(i2, 1);
          break;
        }
      }
    };
    exports.removeExisting = removeExisting;
    const replaceExisting = (input) => {
      const doc = input.changeEvent.doc;
      const primary = input.queryParams.primaryKey;
      const results = input.previousResults;
      for (let i2 = 0; i2 < results.length; i2++) {
        const item = results[i2];
        if (item[primary] === input.changeEvent.id) {
          results[i2] = doc;
          if (input.keyDocumentMap) {
            input.keyDocumentMap.set(input.changeEvent.id, doc);
          }
          break;
        }
      }
    };
    exports.replaceExisting = replaceExisting;
    const alwaysWrong = (input) => {
      const wrongHuman = {
        _id: "wrongHuman" + (/* @__PURE__ */ new Date()).getTime()
      };
      input.previousResults.length = 0;
      input.previousResults.push(wrongHuman);
      if (input.keyDocumentMap) {
        input.keyDocumentMap.clear();
        input.keyDocumentMap.set(wrongHuman._id, wrongHuman);
      }
    };
    exports.alwaysWrong = alwaysWrong;
    const insertAtSortPosition = (input) => {
      const docId = input.changeEvent.id;
      const doc = input.changeEvent.doc;
      if (input.keyDocumentMap) {
        if (input.keyDocumentMap.has(docId)) {
          return;
        }
        input.keyDocumentMap.set(docId, doc);
      } else {
        const isDocInResults = input.previousResults.find((d2) => d2[input.queryParams.primaryKey] === docId);
        if (isDocInResults) {
          return;
        }
      }
      (0, array_push_at_sort_position_1.pushAtSortPosition)(input.previousResults, doc, input.queryParams.sortComparator, 0);
    };
    exports.insertAtSortPosition = insertAtSortPosition;
    const removeExistingAndInsertAtSortPosition = (input) => {
      (0, exports.removeExisting)(input);
      (0, exports.insertAtSortPosition)(input);
    };
    exports.removeExistingAndInsertAtSortPosition = removeExistingAndInsertAtSortPosition;
    const runFullQueryAgain = (_input) => {
      throw new Error("Action runFullQueryAgain must be implemented by yourself");
    };
    exports.runFullQueryAgain = runFullQueryAgain;
    const unknownAction = (_input) => {
      throw new Error("Action unknownAction should never be called");
    };
    exports.unknownAction = unknownAction;
  })(actionFunctions);
  return actionFunctions;
}
var hasRequiredActions;
function requireActions() {
  if (hasRequiredActions)
    return actions;
  hasRequiredActions = 1;
  Object.defineProperty(actions, "__esModule", { value: true });
  actions.actionFunctions = actions.orderedActionList = void 0;
  const action_functions_1 = requireActionFunctions();
  actions.orderedActionList = [
    "doNothing",
    "insertFirst",
    "insertLast",
    "removeFirstItem",
    "removeLastItem",
    "removeFirstInsertLast",
    "removeLastInsertFirst",
    "removeFirstInsertFirst",
    "removeLastInsertLast",
    "removeExisting",
    "replaceExisting",
    "alwaysWrong",
    "insertAtSortPosition",
    "removeExistingAndInsertAtSortPosition",
    "runFullQueryAgain",
    "unknownAction"
  ];
  actions.actionFunctions = {
    doNothing: action_functions_1.doNothing,
    insertFirst: action_functions_1.insertFirst,
    insertLast: action_functions_1.insertLast,
    removeFirstItem: action_functions_1.removeFirstItem,
    removeLastItem: action_functions_1.removeLastItem,
    removeFirstInsertLast: action_functions_1.removeFirstInsertLast,
    removeLastInsertFirst: action_functions_1.removeLastInsertFirst,
    removeFirstInsertFirst: action_functions_1.removeFirstInsertFirst,
    removeLastInsertLast: action_functions_1.removeLastInsertLast,
    removeExisting: action_functions_1.removeExisting,
    replaceExisting: action_functions_1.replaceExisting,
    alwaysWrong: action_functions_1.alwaysWrong,
    insertAtSortPosition: action_functions_1.insertAtSortPosition,
    removeExistingAndInsertAtSortPosition: action_functions_1.removeExistingAndInsertAtSortPosition,
    runFullQueryAgain: action_functions_1.runFullQueryAgain,
    unknownAction: action_functions_1.unknownAction
  };
  return actions;
}
var bdd_generated = {};
var lib = {};
var minimalString = {};
var bddToMinimalString = {};
var stringFormat = {};
var hasRequiredStringFormat;
function requireStringFormat() {
  if (hasRequiredStringFormat)
    return stringFormat;
  hasRequiredStringFormat = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNextCharId = exports.FIRST_CHAR_CODE_FOR_ID = exports.getCharOfValue = exports.getNumberOfChar = exports.getCharOfLevel = exports.CHAR_CODE_OFFSET = void 0;
    exports.CHAR_CODE_OFFSET = 40;
    function getCharOfLevel(level) {
      const charCode = exports.CHAR_CODE_OFFSET + level;
      return String.fromCharCode(charCode);
    }
    exports.getCharOfLevel = getCharOfLevel;
    function getNumberOfChar(char) {
      const charCode = char.charCodeAt(0);
      return charCode - exports.CHAR_CODE_OFFSET;
    }
    exports.getNumberOfChar = getNumberOfChar;
    function getCharOfValue(value) {
      const charCode = exports.CHAR_CODE_OFFSET + value;
      return String.fromCharCode(charCode);
    }
    exports.getCharOfValue = getCharOfValue;
    exports.FIRST_CHAR_CODE_FOR_ID = 97;
    function getNextCharId(lastCode) {
      if (lastCode >= 128 && lastCode <= 160) {
        lastCode = 161;
      }
      const char = String.fromCharCode(lastCode);
      return {
        char,
        nextCode: lastCode + 1
      };
    }
    exports.getNextCharId = getNextCharId;
  })(stringFormat);
  return stringFormat;
}
var hasRequiredBddToMinimalString;
function requireBddToMinimalString() {
  if (hasRequiredBddToMinimalString)
    return bddToMinimalString;
  hasRequiredBddToMinimalString = 1;
  Object.defineProperty(bddToMinimalString, "__esModule", { value: true });
  bddToMinimalString.nodeToString = bddToMinimalString.bddToMinimalString = void 0;
  const string_format_1 = requireStringFormat();
  const string_format_2 = requireStringFormat();
  function bddToMinimalString$1(bdd) {
    let ret = "";
    let currentCharCode = string_format_2.FIRST_CHAR_CODE_FOR_ID;
    const leafNodeAmount = bdd.getLeafNodes().length;
    if (leafNodeAmount > 99) {
      throw new Error("cannot build string with too many leaf nodes");
    }
    ret += leafNodeAmount.toString().padStart(2, "0");
    const levelsHighestFirst = bdd.levels.slice().reverse();
    const idByNode = /* @__PURE__ */ new Map();
    levelsHighestFirst.forEach((level) => {
      const nodes = bdd.getNodesOfLevel(level);
      nodes.forEach((node2) => {
        const stringRep = nodeToString(node2, idByNode, currentCharCode);
        currentCharCode = stringRep.nextCode;
        idByNode.set(node2, stringRep.id);
        ret += stringRep.str;
      });
    });
    return ret;
  }
  bddToMinimalString.bddToMinimalString = bddToMinimalString$1;
  function nodeToString(node2, idByNode, lastCode) {
    const nextId = (0, string_format_1.getNextCharId)(lastCode);
    switch (node2.type) {
      case "LeafNode":
        const valueChar = (0, string_format_1.getCharOfValue)(node2.asLeafNode().value);
        return {
          id: nextId.char,
          nextCode: nextId.nextCode,
          str: nextId.char + valueChar
        };
      case "InternalNode":
        const branch0Id = idByNode.get(node2.asInternalNode().branches.getBranch("0"));
        const branch1Id = idByNode.get(node2.asInternalNode().branches.getBranch("1"));
        return {
          id: nextId.char,
          nextCode: nextId.nextCode,
          str: nextId.char + branch0Id + branch1Id + (0, string_format_1.getCharOfLevel)(node2.level)
        };
      case "RootNode":
        const branch0IdRoot = idByNode.get(node2.asRootNode().branches.getBranch("0"));
        const branch1IdRoot = idByNode.get(node2.asRootNode().branches.getBranch("1"));
        return {
          id: nextId.char,
          nextCode: nextId.nextCode,
          str: "" + branch0IdRoot + branch1IdRoot + (0, string_format_1.getCharOfLevel)(node2.level)
        };
      default:
        throw new Error("unknown node type");
    }
  }
  bddToMinimalString.nodeToString = nodeToString;
  return bddToMinimalString;
}
var minimalStringToSimpleBdd = {};
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", { value: true });
  util.splitStringToChunks = util.lastOfArray = util.shuffleArray = util.firstKeyOfMap = util.getNextStateSet = util.maxBinaryWithLength = util.minBinaryWithLength = util.binaryToDecimal = util.oppositeBinary = util.decimalToPaddedBinary = util.nextNodeId = util.lastChar = util.oppositeBoolean = util.booleanToBooleanString = util.booleanStringToBoolean = void 0;
  function booleanStringToBoolean(str) {
    if (str === "1") {
      return true;
    } else {
      return false;
    }
  }
  util.booleanStringToBoolean = booleanStringToBoolean;
  function booleanToBooleanString(b2) {
    if (b2) {
      return "1";
    } else {
      return "0";
    }
  }
  util.booleanToBooleanString = booleanToBooleanString;
  function oppositeBoolean(input) {
    if (input === "1") {
      return "0";
    } else {
      return "1";
    }
  }
  util.oppositeBoolean = oppositeBoolean;
  function lastChar(str) {
    return str.slice(-1);
  }
  util.lastChar = lastChar;
  function makeid(length = 6) {
    let result = "";
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const charactersLength = characters.length;
    for (let i2 = 0; i2 < length; i2++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  }
  const nodeIdPrefix = makeid(4);
  let lastIdGen = 0;
  function nextNodeId() {
    const ret = "node_" + nodeIdPrefix + "_" + lastIdGen;
    lastIdGen++;
    return ret;
  }
  util.nextNodeId = nextNodeId;
  function decimalToPaddedBinary(decimal, padding) {
    const binary = (decimal >>> 0).toString(2);
    const padded = binary.padStart(padding, "0");
    return padded;
  }
  util.decimalToPaddedBinary = decimalToPaddedBinary;
  function oppositeBinary(i2) {
    if (i2 === "1") {
      return "0";
    } else if (i2 === "0") {
      return "1";
    } else {
      throw new Error("non-binary given");
    }
  }
  util.oppositeBinary = oppositeBinary;
  function binaryToDecimal(binary) {
    return parseInt(binary, 2);
  }
  util.binaryToDecimal = binaryToDecimal;
  function minBinaryWithLength(length) {
    return new Array(length).fill(0).map(() => "0").join("");
  }
  util.minBinaryWithLength = minBinaryWithLength;
  function maxBinaryWithLength(length) {
    return new Array(length).fill(0).map(() => "1").join("");
  }
  util.maxBinaryWithLength = maxBinaryWithLength;
  function getNextStateSet(stateSet) {
    const decimal = binaryToDecimal(stateSet);
    const increase = decimal + 1;
    const binary = decimalToPaddedBinary(increase, stateSet.length);
    return binary;
  }
  util.getNextStateSet = getNextStateSet;
  function firstKeyOfMap(map2) {
    const iterator1 = map2.keys();
    return iterator1.next().value;
  }
  util.firstKeyOfMap = firstKeyOfMap;
  function shuffleArray2(a2) {
    for (let i2 = a2.length - 1; i2 > 0; i2--) {
      const j2 = Math.floor(Math.random() * (i2 + 1));
      [a2[i2], a2[j2]] = [a2[j2], a2[i2]];
    }
    return a2;
  }
  util.shuffleArray = shuffleArray2;
  function lastOfArray2(ar) {
    return ar[ar.length - 1];
  }
  util.lastOfArray = lastOfArray2;
  function splitStringToChunks(str, chunkSize) {
    const chunks = [];
    for (let i2 = 0, charsLength = str.length; i2 < charsLength; i2 += chunkSize) {
      chunks.push(str.substring(i2, i2 + chunkSize));
    }
    return chunks;
  }
  util.splitStringToChunks = splitStringToChunks;
  return util;
}
var hasRequiredMinimalStringToSimpleBdd;
function requireMinimalStringToSimpleBdd() {
  if (hasRequiredMinimalStringToSimpleBdd)
    return minimalStringToSimpleBdd;
  hasRequiredMinimalStringToSimpleBdd = 1;
  Object.defineProperty(minimalStringToSimpleBdd, "__esModule", { value: true });
  minimalStringToSimpleBdd.minimalStringToSimpleBdd = void 0;
  const util_12 = requireUtil();
  const string_format_1 = requireStringFormat();
  function minimalStringToSimpleBdd$1(str) {
    const nodesById = /* @__PURE__ */ new Map();
    const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);
    const lastLeafNodeChar = 2 + leafNodeAmount * 2;
    const leafNodeChars = str.substring(2, lastLeafNodeChar);
    const leafNodeChunks = (0, util_12.splitStringToChunks)(leafNodeChars, 2);
    for (let i2 = 0; i2 < leafNodeChunks.length; i2++) {
      const chunk = leafNodeChunks[i2];
      const id = chunk.charAt(0);
      const value = (0, string_format_1.getNumberOfChar)(chunk.charAt(1));
      nodesById.set(id, value);
    }
    const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);
    const internalNodeChunks = (0, util_12.splitStringToChunks)(internalNodeChars, 4);
    for (let i2 = 0; i2 < internalNodeChunks.length; i2++) {
      const chunk = internalNodeChunks[i2];
      const id = chunk.charAt(0);
      const idOf0Branch = chunk.charAt(1);
      const idOf1Branch = chunk.charAt(2);
      const level = (0, string_format_1.getNumberOfChar)(chunk.charAt(3));
      if (!nodesById.has(idOf0Branch)) {
        throw new Error("missing node with id " + idOf0Branch);
      }
      if (!nodesById.has(idOf1Branch)) {
        throw new Error("missing node with id " + idOf1Branch);
      }
      const node0 = nodesById.get(idOf0Branch);
      const node1 = nodesById.get(idOf1Branch);
      const node2 = {
        l: level,
        0: node0,
        1: node1
      };
      nodesById.set(id, node2);
    }
    const last3 = str.slice(-3);
    const idOf0 = last3.charAt(0);
    const idOf1 = last3.charAt(1);
    const levelOfRoot = (0, string_format_1.getNumberOfChar)(last3.charAt(2));
    const nodeOf0 = nodesById.get(idOf0);
    const nodeOf1 = nodesById.get(idOf1);
    const rootNode2 = {
      l: levelOfRoot,
      0: nodeOf0,
      1: nodeOf1
    };
    return rootNode2;
  }
  minimalStringToSimpleBdd.minimalStringToSimpleBdd = minimalStringToSimpleBdd$1;
  return minimalStringToSimpleBdd;
}
var resolveWithSimpleBdd = {};
var hasRequiredResolveWithSimpleBdd;
function requireResolveWithSimpleBdd() {
  if (hasRequiredResolveWithSimpleBdd)
    return resolveWithSimpleBdd;
  hasRequiredResolveWithSimpleBdd = 1;
  Object.defineProperty(resolveWithSimpleBdd, "__esModule", { value: true });
  resolveWithSimpleBdd.resolveWithSimpleBdd = void 0;
  const util_12 = requireUtil();
  function resolveWithSimpleBdd$1(simpleBdd, fns, input) {
    let currentNode = simpleBdd;
    let currentLevel = simpleBdd.l;
    while (true) {
      const booleanResult = fns[currentLevel](input);
      const branchKey = (0, util_12.booleanToBooleanString)(booleanResult);
      currentNode = currentNode[branchKey];
      if (typeof currentNode === "number" || typeof currentNode === "string") {
        return currentNode;
      } else {
        currentLevel = currentNode.l;
      }
    }
  }
  resolveWithSimpleBdd.resolveWithSimpleBdd = resolveWithSimpleBdd$1;
  return resolveWithSimpleBdd;
}
var bddToSimpleBdd = {};
var hasRequiredBddToSimpleBdd;
function requireBddToSimpleBdd() {
  if (hasRequiredBddToSimpleBdd)
    return bddToSimpleBdd;
  hasRequiredBddToSimpleBdd = 1;
  Object.defineProperty(bddToSimpleBdd, "__esModule", { value: true });
  bddToSimpleBdd.nodeToSimpleBddNode = bddToSimpleBdd.bddToSimpleBdd = void 0;
  function bddToSimpleBdd$1(bdd) {
    return nodeToSimpleBddNode(bdd);
  }
  bddToSimpleBdd.bddToSimpleBdd = bddToSimpleBdd$1;
  function nodeToSimpleBddNode(node2) {
    const branch0 = node2.branches.getBranch("0");
    const branch1 = node2.branches.getBranch("1");
    return {
      l: node2.level,
      0: branch0.isLeafNode() ? branch0.asLeafNode().value : nodeToSimpleBddNode(branch0),
      1: branch1.isLeafNode() ? branch1.asLeafNode().value : nodeToSimpleBddNode(branch1)
    };
  }
  bddToSimpleBdd.nodeToSimpleBddNode = nodeToSimpleBddNode;
  return bddToSimpleBdd;
}
var hasRequiredMinimalString;
function requireMinimalString() {
  if (hasRequiredMinimalString)
    return minimalString;
  hasRequiredMinimalString = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireBddToMinimalString(), exports);
    __exportStar(requireMinimalStringToSimpleBdd(), exports);
    __exportStar(requireResolveWithSimpleBdd(), exports);
    __exportStar(requireStringFormat(), exports);
    __exportStar(requireBddToSimpleBdd(), exports);
  })(minimalString);
  return minimalString;
}
var abstractNode = {};
var findSimilarNode = {};
var hasRequiredFindSimilarNode;
function requireFindSimilarNode() {
  if (hasRequiredFindSimilarNode)
    return findSimilarNode;
  hasRequiredFindSimilarNode = 1;
  Object.defineProperty(findSimilarNode, "__esModule", { value: true });
  findSimilarNode.findSimilarNode = void 0;
  function findSimilarNode$1(own, others) {
    const ownString = own.toString();
    for (let i2 = 0; i2 < others.length; i2++) {
      const other = others[i2];
      if (own !== other && !other.deleted && own.isEqualToOtherNode(other, ownString)) {
        return other;
      }
    }
    return null;
  }
  findSimilarNode.findSimilarNode = findSimilarNode$1;
  return findSimilarNode;
}
var hasRequiredAbstractNode;
function requireAbstractNode() {
  if (hasRequiredAbstractNode)
    return abstractNode;
  hasRequiredAbstractNode = 1;
  Object.defineProperty(abstractNode, "__esModule", { value: true });
  abstractNode.AbstractNode = void 0;
  const util_12 = requireUtil();
  const find_similar_node_1 = requireFindSimilarNode();
  class AbstractNode {
    constructor(level, rootNode2, type2) {
      this.level = level;
      this.id = (0, util_12.nextNodeId)();
      this.deleted = false;
      this.type = type2;
      this.rootNode = rootNode2;
      if (rootNode2) {
        this.rootNode.addNode(this);
      }
    }
    isEqualToOtherNode(otherNode, ownString = this.toString()) {
      const ret = ownString === otherNode.toString();
      return ret;
    }
    // deletes the whole node
    remove() {
      this.ensureNotDeleted("remove");
      if (this.isInternalNode()) {
        const useNode = this;
        if (useNode.parents.size > 0) {
          throw new Error("cannot remove node with parents " + this.id);
        }
      }
      if (this.branches) {
        const useNode = this;
        if (useNode.branches.areBranchesStrictEqual()) {
          useNode.branches.getBranch("0").parents.remove(useNode);
        } else {
          useNode.branches.getBranch("0").parents.remove(useNode);
          useNode.branches.getBranch("1").parents.remove(useNode);
        }
      }
      this.deleted = true;
      this.rootNode.removeNode(this);
    }
    toJSON(withId = false) {
      const ret = {
        id: withId ? this.id : void 0,
        deleted: withId ? this.deleted : void 0,
        type: this.type,
        level: this.level
      };
      if (withId && this.parents) {
        ret.parents = this.parents.toString();
      }
      if (this.isLeafNode()) {
        ret.value = this.asLeafNode().value;
      }
      if (this.branches && !this.branches.deleted) {
        const branches2 = this.branches;
        ret.branches = {
          "0": branches2.getBranch("0").toJSON(withId),
          "1": branches2.getBranch("1").toJSON(withId)
        };
      }
      return ret;
    }
    // a strange string-representation
    // to make an equal check between nodes
    toString() {
      let ret = "<" + this.type + ":" + this.level;
      if (this.branches) {
        const branches2 = this.branches;
        ret += "|0:" + branches2.getBranch("0");
        ret += "|1:" + branches2.getBranch("1");
      }
      if (this.isLeafNode()) {
        ret += "|v:" + this.asLeafNode().value;
      }
      ret += ">";
      return ret;
    }
    isRootNode() {
      return this.type === "RootNode";
    }
    isInternalNode() {
      return this.type === "InternalNode";
    }
    isLeafNode() {
      return this.type === "LeafNode";
    }
    asRootNode() {
      if (!this.isRootNode()) {
        throw new Error("ouch");
      }
      return this;
    }
    asInternalNode() {
      if (!this.isInternalNode()) {
        throw new Error("ouch");
      }
      return this;
    }
    asLeafNode() {
      if (!this.isLeafNode()) {
        throw new Error("ouch");
      }
      return this;
    }
    ensureNotDeleted(op = "unknown") {
      if (this.deleted) {
        throw new Error("forbidden operation " + op + " on deleted node " + this.id);
      }
    }
    log() {
      console.log(JSON.stringify(this.toJSON(true), null, 2));
    }
    /**
    * by the elimination-rule of bdd,
    * if two branches of the same level are equal,
    * one can be removed
    *
    * See page 21 at:
    * @link https://people.eecs.berkeley.edu/~sseshia/219c/lectures/BinaryDecisionDiagrams.pdf
    */
    applyEliminationRule(nodesOfSameLevel) {
      this.ensureNotDeleted("applyEliminationRule");
      if (!nodesOfSameLevel) {
        nodesOfSameLevel = this.rootNode.getNodesOfLevel(this.level);
      }
      const other = (0, find_similar_node_1.findSimilarNode)(this, nodesOfSameLevel);
      if (other) {
        const ownParents = this.parents.getAll();
        const parentsWithStrictEqualBranches = [];
        ownParents.forEach((parent) => {
          const branchKey = parent.branches.getKeyOfNode(this);
          parent.branches.setBranch(branchKey, other);
          if (parent.branches.areBranchesStrictEqual()) {
            parentsWithStrictEqualBranches.push(parent);
          }
          this.parents.remove(parent);
        });
        parentsWithStrictEqualBranches.forEach((node2) => {
          if (node2.isInternalNode()) {
            node2.applyReductionRule();
          }
        });
        return true;
      } else {
        return false;
      }
    }
  }
  abstractNode.AbstractNode = AbstractNode;
  return abstractNode;
}
var branches = {};
var hasRequiredBranches;
function requireBranches() {
  if (hasRequiredBranches)
    return branches;
  hasRequiredBranches = 1;
  Object.defineProperty(branches, "__esModule", { value: true });
  branches.ensureNodesNotStrictEqual = branches.Branches = void 0;
  class Branches {
    constructor(node2) {
      this.node = node2;
      this.deleted = false;
      this.branches = {};
    }
    setBranch(which, branchNode) {
      const previous = this.branches[which];
      if (previous === branchNode) {
        return;
      }
      this.branches[which] = branchNode;
      branchNode.parents.add(this.node);
    }
    getKeyOfNode(node2) {
      if (this.getBranch("0") === node2) {
        return "0";
      } else if (this.getBranch("1") === node2) {
        return "1";
      } else {
        throw new Error("none matched");
      }
    }
    getBranch(which) {
      return this.branches[which];
    }
    getBothBranches() {
      return [
        this.getBranch("0"),
        this.getBranch("1")
      ];
    }
    hasBranchAsNode(node2) {
      if (this.getBranch("0") === node2 || this.getBranch("1") === node2) {
        return true;
      } else {
        return false;
      }
    }
    hasNodeIdAsBranch(id) {
      if (this.getBranch("0").id === id || this.getBranch("1").id === id) {
        return true;
      } else {
        return false;
      }
    }
    areBranchesStrictEqual() {
      return this.branches["0"] === this.branches["1"];
    }
    hasEqualBranches() {
      return JSON.stringify(this.branches["0"]) === JSON.stringify(this.branches["1"]);
    }
  }
  branches.Branches = Branches;
  function ensureNodesNotStrictEqual(node1, node2) {
    if (node1 === node2) {
      throw new Error("cannot have two strict equal branches");
    }
  }
  branches.ensureNodesNotStrictEqual = ensureNodesNotStrictEqual;
  return branches;
}
var createBddFromTruthTable = {};
var rootNode = {};
var hasRequiredRootNode;
function requireRootNode() {
  if (hasRequiredRootNode)
    return rootNode;
  hasRequiredRootNode = 1;
  Object.defineProperty(rootNode, "__esModule", { value: true });
  rootNode.RootNode = void 0;
  const abstract_node_1 = requireAbstractNode();
  const branches_1 = requireBranches();
  const util_12 = requireUtil();
  const minimal_string_1 = requireMinimalString();
  class RootNode extends abstract_node_1.AbstractNode {
    constructor() {
      super(0, null, "RootNode");
      this.branches = new branches_1.Branches(this);
      this.levels = [];
      this.nodesByLevel = /* @__PURE__ */ new Map();
      this.levels.push(0);
      const level0Set = /* @__PURE__ */ new Set();
      level0Set.add(this);
      this.nodesByLevel.set(0, level0Set);
    }
    addNode(node2) {
      const level = node2.level;
      if (!this.levels.includes(level)) {
        this.levels.push(level);
      }
      this.ensureLevelSetExists(level);
      const set2 = this.nodesByLevel.get(level);
      set2 === null || set2 === void 0 ? void 0 : set2.add(node2);
    }
    removeNode(node2) {
      const set2 = this.nodesByLevel.get(node2.level);
      if (!set2.has(node2)) {
        throw new Error("removed non-existing node " + node2.id);
      }
      set2.delete(node2);
    }
    ensureLevelSetExists(level) {
      if (!this.nodesByLevel.has(level)) {
        this.nodesByLevel.set(level, /* @__PURE__ */ new Set());
      }
    }
    getLevels() {
      return Array.from(this.levels).sort((a2, b2) => a2 - b2);
    }
    getNodesOfLevel(level) {
      this.ensureLevelSetExists(level);
      const set2 = this.nodesByLevel.get(level);
      return Array.from(set2);
    }
    countNodes() {
      let ret = 0;
      this.getLevels().forEach((level) => {
        const nodesAmount = this.getNodesOfLevel(level).length;
        ret = ret + nodesAmount;
      });
      return ret;
    }
    /**
     * applies the reduction rules to the whole bdd
     */
    minimize(logState = false) {
      let done = false;
      while (!done) {
        if (logState) {
          console.log("minimize() itterate once");
        }
        let successCount = 0;
        let lastLevel = (0, util_12.lastOfArray)(this.getLevels());
        while (lastLevel > 0) {
          const nodes = this.getNodesOfLevel(lastLevel);
          if (logState) {
            console.log("minimize() run for level " + lastLevel + " with " + nodes.length + " nodes");
          }
          let nodeCount = 0;
          for (const node2 of nodes) {
            nodeCount++;
            if (logState && nodeCount % 4e3 === 0) {
              console.log("minimize() node #" + node2.id);
            }
            if (node2.isLeafNode()) {
              const reductionDone = node2.asLeafNode().applyEliminationRule();
              if (reductionDone) {
                successCount++;
              }
            }
            if (!node2.deleted && node2.isInternalNode()) {
              const useNode = node2;
              const reductionDone = useNode.applyReductionRule();
              let eliminationDone = false;
              if (!useNode.deleted) {
                eliminationDone = useNode.applyEliminationRule(nodes);
              }
              if (reductionDone || eliminationDone) {
                successCount++;
              }
            }
          }
          lastLevel--;
        }
        if (successCount === 0) {
          done = true;
        } else {
          if (logState) {
            console.log("minimize() itteration done with " + successCount + " minimisations");
          }
        }
      }
    }
    getLeafNodes() {
      const lastLevel = (0, util_12.lastOfArray)(this.getLevels());
      const leafNodes = this.getNodesOfLevel(lastLevel).reverse();
      return leafNodes;
    }
    /**
     * strips all leaf-nodes
     * with the given value
     */
    removeIrrelevantLeafNodes(leafNodeValue) {
      let done = false;
      while (!done) {
        let countRemoved = 0;
        const leafNodes = this.getLeafNodes();
        for (const leafNode2 of leafNodes) {
          const removed = leafNode2.removeIfValueEquals(leafNodeValue);
          if (removed) {
            countRemoved++;
          }
        }
        this.minimize();
        if (countRemoved === 0) {
          done = true;
        }
      }
    }
    resolve(fns, booleanFunctionInput) {
      let currentNode = this;
      while (true) {
        const booleanResult = fns[currentNode.level](booleanFunctionInput);
        const branchKey = (0, util_12.booleanToBooleanString)(booleanResult);
        currentNode = currentNode.branches.getBranch(branchKey);
        if (currentNode.isLeafNode()) {
          return currentNode.asLeafNode().value;
        }
      }
    }
    toSimpleBdd() {
      return (0, minimal_string_1.bddToSimpleBdd)(this);
    }
  }
  rootNode.RootNode = RootNode;
  return rootNode;
}
var internalNode = {};
var parents = {};
var hasRequiredParents;
function requireParents() {
  if (hasRequiredParents)
    return parents;
  hasRequiredParents = 1;
  Object.defineProperty(parents, "__esModule", { value: true });
  parents.Parents = void 0;
  class Parents {
    constructor(node2) {
      this.node = node2;
      this.parents = /* @__PURE__ */ new Set();
    }
    remove(node2) {
      this.parents.delete(node2);
      if (this.parents.size === 0) {
        this.node.remove();
      }
    }
    getAll() {
      return Array.from(this.parents);
    }
    add(node2) {
      if (this.node.level === node2.level) {
        throw new Error("a node cannot be parent of a node with the same level");
      }
      this.parents.add(node2);
    }
    has(node2) {
      return this.parents.has(node2);
    }
    toString() {
      const ret = [];
      for (const parent of this.parents) {
        ret.push(parent.id);
      }
      return ret.join(", ");
    }
    get size() {
      return this.parents.size;
    }
  }
  parents.Parents = Parents;
  return parents;
}
var hasRequiredInternalNode;
function requireInternalNode() {
  if (hasRequiredInternalNode)
    return internalNode;
  hasRequiredInternalNode = 1;
  Object.defineProperty(internalNode, "__esModule", { value: true });
  internalNode.InternalNode = void 0;
  const branches_1 = requireBranches();
  const parents_1 = requireParents();
  const abstract_node_1 = requireAbstractNode();
  class InternalNode extends abstract_node_1.AbstractNode {
    constructor(level, rootNode2, parent) {
      super(level, rootNode2, "InternalNode");
      this.branches = new branches_1.Branches(this);
      this.parents = new parents_1.Parents(this);
      this.parents.add(parent);
    }
    /**
     * by the reduction-rule of bdd,
     * if both branches are equal,
     * we can remove this node from the bdd
     */
    applyReductionRule() {
      if (this.branches.hasEqualBranches()) {
        this.ensureNotDeleted("applyReductionRule");
        const keepBranch = this.branches.getBranch("0");
        const ownParents = this.parents.getAll();
        ownParents.forEach((parent) => {
          const branchKey = parent.branches.getKeyOfNode(this);
          parent.branches.setBranch(branchKey, keepBranch);
          this.parents.remove(parent);
          if (parent.branches.areBranchesStrictEqual() && parent.isInternalNode()) {
            parent.applyReductionRule();
          }
        });
        return true;
      }
      return false;
    }
  }
  internalNode.InternalNode = InternalNode;
  return internalNode;
}
var leafNode = {};
var hasRequiredLeafNode;
function requireLeafNode() {
  if (hasRequiredLeafNode)
    return leafNode;
  hasRequiredLeafNode = 1;
  Object.defineProperty(leafNode, "__esModule", { value: true });
  leafNode.LeafNode = void 0;
  const parents_1 = requireParents();
  const abstract_node_1 = requireAbstractNode();
  const util_12 = requireUtil();
  class LeafNode extends abstract_node_1.AbstractNode {
    constructor(level, rootNode2, value, parent) {
      super(level, rootNode2, "LeafNode");
      this.value = value;
      this.parents = new parents_1.Parents(this);
      this.parents.add(parent);
    }
    removeIfValueEquals(value) {
      this.ensureNotDeleted();
      if (this.value !== value) {
        return false;
      }
      const parents2 = this.parents.getAll();
      parents2.forEach((parent) => {
        const branchKey = parent.branches.getKeyOfNode(this);
        const otherBranch = parent.branches.getBranch((0, util_12.oppositeBoolean)(branchKey));
        this.parents.remove(parent);
        parent.branches.setBranch(branchKey, otherBranch);
        if (parent.isInternalNode()) {
          parent.applyReductionRule();
        }
      });
      return true;
    }
  }
  leafNode.LeafNode = LeafNode;
  return leafNode;
}
var hasRequiredCreateBddFromTruthTable;
function requireCreateBddFromTruthTable() {
  if (hasRequiredCreateBddFromTruthTable)
    return createBddFromTruthTable;
  hasRequiredCreateBddFromTruthTable = 1;
  Object.defineProperty(createBddFromTruthTable, "__esModule", { value: true });
  createBddFromTruthTable.createBddFromTruthTable = void 0;
  const root_node_1 = requireRootNode();
  const util_12 = requireUtil();
  const internal_node_1 = requireInternalNode();
  const leaf_node_1 = requireLeafNode();
  function createBddFromTruthTable$1(truthTable) {
    const root = new root_node_1.RootNode();
    const firstKey = truthTable.keys().next().value;
    const keyLength = firstKey.length;
    const mustBeSize = Math.pow(2, keyLength);
    if (truthTable.size !== mustBeSize) {
      throw new Error("truth table has missing entries");
    }
    for (const [stateSet, value] of truthTable) {
      let lastNode = root;
      for (let i2 = 0; i2 < stateSet.length - 1; i2++) {
        const level = i2 + 1;
        const state = stateSet.charAt(i2);
        if (!lastNode.branches.getBranch(state)) {
          lastNode.branches.setBranch(state, new internal_node_1.InternalNode(level, root, lastNode));
        }
        lastNode = lastNode.branches.getBranch(state);
      }
      const lastState = (0, util_12.lastChar)(stateSet);
      if (lastNode.branches.getBranch(lastState)) {
        throw new Error("leafNode already exists, this should not happen");
      }
      lastNode.branches.setBranch(lastState, new leaf_node_1.LeafNode(stateSet.length, root, value, lastNode));
    }
    return root;
  }
  createBddFromTruthTable.createBddFromTruthTable = createBddFromTruthTable$1;
  return createBddFromTruthTable;
}
var ensureCorrectBdd = {};
var hasRequiredEnsureCorrectBdd;
function requireEnsureCorrectBdd() {
  if (hasRequiredEnsureCorrectBdd)
    return ensureCorrectBdd;
  hasRequiredEnsureCorrectBdd = 1;
  Object.defineProperty(ensureCorrectBdd, "__esModule", { value: true });
  ensureCorrectBdd.getNodesRecursive = ensureCorrectBdd.ensureCorrectBdd = void 0;
  function ensureCorrectBdd$1(bdd) {
    const jsonString = JSON.stringify(bdd.toJSON(true));
    let allNodes = [];
    const nodesById = /* @__PURE__ */ new Map();
    bdd.getLevels().forEach((level) => {
      const levelNodes = bdd.getNodesOfLevel(level);
      levelNodes.forEach((node2) => {
        nodesById.set(node2.id, node2);
      });
      allNodes = allNodes.concat(levelNodes);
    });
    const recursiveNodes = getNodesRecursive(bdd);
    if (allNodes.length !== recursiveNodes.size) {
      const allNodesIds = allNodes.map((n2) => n2.id).sort();
      const recursiveNodesIds = Array.from(recursiveNodes).map((n2) => n2.id).sort();
      const nodesOnlyInRecursive = recursiveNodesIds.filter((id) => !allNodesIds.includes(id));
      if (recursiveNodes.size > allNodes.length) {
        const firstId = nodesOnlyInRecursive[0];
        const referenceToFirst = allNodes.find((n2) => {
          if (n2.isInternalNode()) {
            return n2.branches.hasNodeIdAsBranch(firstId);
          }
          return false;
        });
        console.log("referenceToFirst:");
        referenceToFirst === null || referenceToFirst === void 0 ? void 0 : referenceToFirst.log();
      }
      throw new Error("ensureCorrectBdd() nodes in list not equal size to recursive nodes allNodes: " + allNodes.length + " recursiveNodes: " + recursiveNodes.size + " nodesOnlyInRecursive: " + nodesOnlyInRecursive.join(", ") + " ");
    }
    allNodes.forEach((node2) => {
      if (node2.isRootNode()) {
        return;
      }
      const useNode = node2;
      if (node2.deleted) {
        throw new Error("ensureCorrectBdd() bdd includes a deleted node");
      }
      if (useNode.parents.size === 0) {
        throw new Error("ensureCorrectBdd() node has no parent " + useNode.id);
      }
      if (useNode.isInternalNode()) {
        const internalNode2 = useNode;
        const bothBranches = internalNode2.branches.getBothBranches();
        if (internalNode2.branches.areBranchesStrictEqual()) {
          throw new Error("ensureCorrectBdd() node has two equal branches: " + bothBranches.map((n2) => n2.id).join(", "));
        }
        bothBranches.forEach((branch) => {
          if (!branch.parents.has(internalNode2)) {
            throw new Error("ensureCorrectBdd() branch must have the node as parent");
          }
        });
      }
      useNode.parents.getAll().forEach((parent) => {
        if (!parent.branches.hasBranchAsNode(useNode)) {
          throw new Error("ensureCorrectBdd() parent node does not have child as branch");
        }
      });
    });
    if (jsonString.includes('"deleted":true')) {
      throw new Error("ensureCorrectBdd() bdd includes a deleted node");
    }
  }
  ensureCorrectBdd.ensureCorrectBdd = ensureCorrectBdd$1;
  function getNodesRecursive(node2, set2 = /* @__PURE__ */ new Set()) {
    set2.add(node2);
    if (!node2.isLeafNode()) {
      const useNode = node2;
      const branch1 = useNode.branches.getBranch("0");
      set2.add(branch1);
      getNodesRecursive(branch1, set2);
      const branch2 = useNode.branches.getBranch("1");
      set2.add(branch2);
      getNodesRecursive(branch2, set2);
    }
    return set2;
  }
  ensureCorrectBdd.getNodesRecursive = getNodesRecursive;
  return ensureCorrectBdd;
}
var fillTruthTable = {};
var hasRequiredFillTruthTable;
function requireFillTruthTable() {
  if (hasRequiredFillTruthTable)
    return fillTruthTable;
  hasRequiredFillTruthTable = 1;
  Object.defineProperty(fillTruthTable, "__esModule", { value: true });
  fillTruthTable.fillTruthTable = void 0;
  const util_12 = requireUtil();
  function fillTruthTable$1(truthTable, inputLength, value) {
    const endInput = (0, util_12.maxBinaryWithLength)(inputLength);
    let currentInput = (0, util_12.minBinaryWithLength)(inputLength);
    let done = false;
    while (!done) {
      if (!truthTable.has(currentInput)) {
        truthTable.set(currentInput, value);
      }
      if (currentInput === endInput) {
        done = true;
      } else {
        currentInput = (0, util_12.getNextStateSet)(currentInput);
      }
    }
  }
  fillTruthTable.fillTruthTable = fillTruthTable$1;
  return fillTruthTable;
}
var optimizeBruteForce = {};
var hasRequiredOptimizeBruteForce;
function requireOptimizeBruteForce() {
  if (hasRequiredOptimizeBruteForce)
    return optimizeBruteForce;
  hasRequiredOptimizeBruteForce = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getArrayWithIndexes = exports.changeKeyOrder = exports.shuffleBooleanOrdering = exports.optimizeBruteForce = exports.defaultCompareResults = void 0;
    const create_bdd_from_truth_table_1 = requireCreateBddFromTruthTable();
    const util_12 = requireUtil();
    const defaultCompareResults = function(a2, b2) {
      if (a2.countNodes() <= b2.countNodes()) {
        return a2;
      } else {
        return b2;
      }
    };
    exports.defaultCompareResults = defaultCompareResults;
    async function optimizeBruteForce2({ truthTable, iterations = Infinity, onBetterBdd = () => null, compareResults = exports.defaultCompareResults, afterBddCreation = () => null, log: log2 = false }) {
      const initialBdd = (0, create_bdd_from_truth_table_1.createBddFromTruthTable)(truthTable);
      afterBddCreation(initialBdd);
      initialBdd.minimize();
      let currentBestResult = {
        truthTable,
        bdd: initialBdd
      };
      if (log2) {
        initialBdd.log();
        console.log("initial nodes amount: " + initialBdd.countNodes());
      }
      let t2 = 0;
      while (t2 < iterations) {
        t2++;
        if (log2) {
          console.log("-".repeat(50));
          console.log("optimizeBruteForce() itterate once");
        }
        const shuffledOrdering = shuffleBooleanOrdering(truthTable);
        const nextBdd = (0, create_bdd_from_truth_table_1.createBddFromTruthTable)(shuffledOrdering.newTable);
        const newNodesByLevel = /* @__PURE__ */ new Map();
        const lastLevel = (0, util_12.lastOfArray)(nextBdd.getLevels());
        const newSortedLevels = [];
        nextBdd.getLevels().filter((level) => level !== lastLevel).forEach((level) => {
          const newLevel = shuffledOrdering.mappingBeforeToAfter[level];
          newSortedLevels.push(newLevel);
          const levelSet = /* @__PURE__ */ new Set();
          newNodesByLevel.set(newLevel, levelSet);
          nextBdd.getNodesOfLevel(level).forEach((node2) => {
            node2.level = newLevel;
            levelSet.add(node2);
          });
        });
        const lastLevelSet = /* @__PURE__ */ new Set();
        nextBdd.getNodesOfLevel(lastLevel).forEach((node2) => lastLevelSet.add(node2));
        newNodesByLevel.set(lastLevel, lastLevelSet);
        newSortedLevels.push(lastLevel);
        nextBdd.nodesByLevel = newNodesByLevel;
        nextBdd.levels = newSortedLevels;
        afterBddCreation(nextBdd);
        nextBdd.minimize();
        if (log2) {
          console.log("got new bdd with nodes amount of " + nextBdd.countNodes());
          console.dir(shuffledOrdering.mappingBeforeToAfter);
        }
        const betterBdd = await compareResults(currentBestResult.bdd, nextBdd);
        if (betterBdd.type !== "RootNode") {
          throw new Error("compareResults did not return a bdd");
        }
        if (betterBdd === nextBdd) {
          if (log2) {
            console.log("#".repeat(50));
            console.log("found better bdd " + nextBdd.countNodes());
          }
          currentBestResult = {
            bdd: nextBdd,
            truthTable: shuffledOrdering.newTable
          };
          onBetterBdd(currentBestResult);
        }
      }
      return currentBestResult;
    }
    exports.optimizeBruteForce = optimizeBruteForce2;
    function shuffleBooleanOrdering(truthTable) {
      const firstKey = (0, util_12.firstKeyOfMap)(truthTable);
      const arrayWithIndexes = getArrayWithIndexes(firstKey.length);
      const shuffled = (0, util_12.shuffleArray)(arrayWithIndexes);
      const mapping = {};
      const mappingBeforeToAfter = {};
      shuffled.forEach((indexBefore, indexAfter) => {
        mapping[indexAfter] = indexBefore;
        mappingBeforeToAfter[indexBefore] = indexAfter;
      });
      const newTable = /* @__PURE__ */ new Map();
      for (const [key, value] of truthTable.entries()) {
        const newKey = changeKeyOrder(key, mapping);
        newTable.set(newKey, value);
      }
      return {
        newTable,
        mapping,
        mappingBeforeToAfter
      };
    }
    exports.shuffleBooleanOrdering = shuffleBooleanOrdering;
    function changeKeyOrder(oldKey, mappingBeforeToAfter) {
      const chars = oldKey.split("").map((char, indexBefore) => {
        return {
          char,
          indexBefore,
          indexAfter: mappingBeforeToAfter[indexBefore]
        };
      }).sort((a2, b2) => a2.indexAfter - b2.indexAfter).map((charObj) => charObj.char).join("");
      return chars;
    }
    exports.changeKeyOrder = changeKeyOrder;
    function getArrayWithIndexes(size2) {
      const ret = [];
      let last2 = 0;
      while (last2 < size2) {
        ret.push(last2);
        last2++;
      }
      return ret;
    }
    exports.getArrayWithIndexes = getArrayWithIndexes;
  })(optimizeBruteForce);
  return optimizeBruteForce;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1)
    return lib;
  hasRequiredLib$1 = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(requireMinimalString(), exports);
    __exportStar(requireAbstractNode(), exports);
    __exportStar(requireBranches(), exports);
    __exportStar(requireCreateBddFromTruthTable(), exports);
    __exportStar(requireEnsureCorrectBdd(), exports);
    __exportStar(requireFillTruthTable(), exports);
    __exportStar(requireFindSimilarNode(), exports);
    __exportStar(requireInternalNode(), exports);
    __exportStar(requireLeafNode(), exports);
    __exportStar(requireOptimizeBruteForce(), exports);
    __exportStar(requireParents(), exports);
    __exportStar(requireRootNode(), exports);
    __exportStar(requireUtil(), exports);
  })(lib);
  return lib;
}
var hasRequiredBdd_generated;
function requireBdd_generated() {
  if (hasRequiredBdd_generated)
    return bdd_generated;
  hasRequiredBdd_generated = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveInput = exports.getSimpleBdd = exports.minimalBddString = void 0;
    const binary_decision_diagram_1 = requireLib$1();
    const states_1 = requireStates();
    exports.minimalBddString = "14a2b0c/d1e,f+g5h.i4j*k-l)m(n6ohk1pdf1qef1rin-sjn-ton-ugn-vmn-whn-xkn-yln-zdf5{ef5|wx5}df7~dz7ef7bk7e{7g|7ry7dp7gk7eq7gt7ac7mv7gu7nm7iy7nw7s88k8m8v8n8n8vm8xv8mn8j8m8xm83}~3333m33m33b3m3m3x3kn3m3j6m66m6nm66,,,,,n,,mf99ym9m99z{2pq2222222n0n000n0000n000v//////y/m((y(::m:44*m*.";
    let simpleBdd;
    function getSimpleBdd() {
      if (!simpleBdd) {
        simpleBdd = (0, binary_decision_diagram_1.minimalStringToSimpleBdd)(exports.minimalBddString);
      }
      return simpleBdd;
    }
    exports.getSimpleBdd = getSimpleBdd;
    const resolveInput = (input) => {
      return (0, binary_decision_diagram_1.resolveWithSimpleBdd)(getSimpleBdd(), states_1.stateResolveFunctionByIndex, input);
    };
    exports.resolveInput = resolveInput;
  })(bdd_generated);
  return bdd_generated;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return lib$1;
  hasRequiredLib = 1;
  (function(exports) {
    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.runAction = exports.calculateActionFunction = exports.calculateActionName = exports.calculateActionFromMap = void 0;
    const states_1 = requireStates();
    const actions_1 = requireActions();
    const bdd_generated_1 = requireBdd_generated();
    __exportStar(requireStates(), exports);
    __exportStar(requireUtil$1(), exports);
    function calculateActionFromMap(stateSetToActionMap, input) {
      const stateSet = (0, states_1.getStateSet)(input);
      const actionName = stateSetToActionMap.get(stateSet);
      if (!actionName) {
        return {
          action: "runFullQueryAgain",
          stateSet
        };
      } else {
        return {
          action: actionName,
          stateSet
        };
      }
    }
    exports.calculateActionFromMap = calculateActionFromMap;
    function calculateActionName(input) {
      const resolvedActionId = (0, bdd_generated_1.resolveInput)(input);
      return actions_1.orderedActionList[resolvedActionId];
    }
    exports.calculateActionName = calculateActionName;
    function calculateActionFunction(input) {
      const actionName = calculateActionName(input);
      return actions_1.actionFunctions[actionName];
    }
    exports.calculateActionFunction = calculateActionFunction;
    function runAction(action, queryParams, changeEvent, previousResults, keyDocumentMap) {
      const fn2 = actions_1.actionFunctions[action];
      fn2({
        queryParams,
        changeEvent,
        previousResults,
        keyDocumentMap
      });
      return previousResults;
    }
    exports.runAction = runAction;
  })(lib$1);
  return lib$1;
}
var hasRequiredEventReduce;
function requireEventReduce() {
  if (hasRequiredEventReduce)
    return eventReduce;
  hasRequiredEventReduce = 1;
  Object.defineProperty(eventReduce, "__esModule", {
    value: true
  });
  eventReduce.RXQUERY_QUERY_PARAMS_CACHE = void 0;
  eventReduce.calculateNewResults = calculateNewResults;
  eventReduce.getQueryParams = getQueryParams;
  eventReduce.getSortFieldsOfQuery = getSortFieldsOfQuery;
  var _eventReduceJs = requireLib();
  var _rxChangeEvent2 = rxChangeEvent;
  var _utils2 = utils;
  var _rxQueryHelper2 = rxQueryHelper;
  function getSortFieldsOfQuery(primaryKey, query2) {
    if (!query2.sort || query2.sort.length === 0) {
      return [primaryKey];
    } else {
      return query2.sort.map((part) => Object.keys(part)[0]);
    }
  }
  var RXQUERY_QUERY_PARAMS_CACHE = /* @__PURE__ */ new WeakMap();
  eventReduce.RXQUERY_QUERY_PARAMS_CACHE = RXQUERY_QUERY_PARAMS_CACHE;
  function getQueryParams(rxQuery2) {
    return (0, _utils2.getFromMapOrCreate)(RXQUERY_QUERY_PARAMS_CACHE, rxQuery2, () => {
      var collection = rxQuery2.collection;
      var normalizedMangoQuery = (0, _rxQueryHelper2.normalizeMangoQuery)(collection.storageInstance.schema, (0, _utils2.clone)(rxQuery2.mangoQuery));
      var primaryKey = collection.schema.primaryPath;
      var sortComparator = (0, _rxQueryHelper2.getSortComparator)(collection.schema.jsonSchema, normalizedMangoQuery);
      var useSortComparator = (docA, docB) => {
        var sortComparatorData = {
          docA,
          docB,
          rxQuery: rxQuery2
        };
        return sortComparator(sortComparatorData.docA, sortComparatorData.docB);
      };
      var queryMatcher = (0, _rxQueryHelper2.getQueryMatcher)(collection.schema.jsonSchema, normalizedMangoQuery);
      var useQueryMatcher = (doc) => {
        var queryMatcherData = {
          doc,
          rxQuery: rxQuery2
        };
        return queryMatcher(queryMatcherData.doc);
      };
      var ret = {
        primaryKey: rxQuery2.collection.schema.primaryPath,
        skip: normalizedMangoQuery.skip,
        limit: normalizedMangoQuery.limit,
        sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),
        sortComparator: useSortComparator,
        queryMatcher: useQueryMatcher
      };
      return ret;
    });
  }
  function calculateNewResults(rxQuery2, rxChangeEvents) {
    if (!rxQuery2.collection.database.eventReduce) {
      return {
        runFullQueryAgain: true
      };
    }
    var queryParams = getQueryParams(rxQuery2);
    var previousResults = (0, _utils2.ensureNotFalsy)(rxQuery2._result).docsData.slice(0);
    var previousResultsMap = (0, _utils2.ensureNotFalsy)(rxQuery2._result).docsDataMap;
    var changed = false;
    var eventReduceEvents = rxChangeEvents.map((cE) => (0, _rxChangeEvent2.rxChangeEventToEventReduceChangeEvent)(cE)).filter(_utils2.arrayFilterNotEmpty);
    var foundNonOptimizeable = eventReduceEvents.find((eventReduceEvent) => {
      var stateResolveFunctionInput = {
        queryParams,
        changeEvent: eventReduceEvent,
        previousResults,
        keyDocumentMap: previousResultsMap
      };
      var actionName = (0, _eventReduceJs.calculateActionName)(stateResolveFunctionInput);
      if (actionName === "runFullQueryAgain") {
        return true;
      } else if (actionName !== "doNothing") {
        changed = true;
        (0, _eventReduceJs.runAction)(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);
        return false;
      }
    });
    if (foundNonOptimizeable) {
      return {
        runFullQueryAgain: true
      };
    } else {
      return {
        runFullQueryAgain: false,
        changed,
        newResults: previousResults
      };
    }
  }
  return eventReduce;
}
var queryCache = {};
Object.defineProperty(queryCache, "__esModule", {
  value: true
});
queryCache.QueryCache = queryCache.DEFAULT_UNEXECUTED_LIFETIME = queryCache.DEFAULT_TRY_TO_KEEP_MAX = queryCache.COLLECTIONS_WITH_RUNNING_CLEANUP = void 0;
queryCache.countRxQuerySubscribers = countRxQuerySubscribers;
queryCache.createQueryCache = createQueryCache;
queryCache.defaultCacheReplacementPolicyMonad = queryCache.defaultCacheReplacementPolicy = void 0;
queryCache.triggerCacheReplacement = triggerCacheReplacement;
queryCache.uncacheRxQuery = uncacheRxQuery;
var _utils$e = utils;
var QueryCache = /* @__PURE__ */ function() {
  function QueryCache2() {
    this._map = /* @__PURE__ */ new Map();
  }
  var _proto = QueryCache2.prototype;
  _proto.getByQuery = function getByQuery(rxQuery2) {
    var stringRep = rxQuery2.toString();
    return (0, _utils$e.getFromMapOrCreate)(this._map, stringRep, () => rxQuery2);
  };
  return QueryCache2;
}();
queryCache.QueryCache = QueryCache;
function createQueryCache() {
  return new QueryCache();
}
function uncacheRxQuery(queryCache2, rxQuery2) {
  rxQuery2.uncached = true;
  var stringRep = rxQuery2.toString();
  queryCache2._map.delete(stringRep);
}
function countRxQuerySubscribers(rxQuery2) {
  return rxQuery2.refCount$.observers.length;
}
var DEFAULT_TRY_TO_KEEP_MAX = 100;
queryCache.DEFAULT_TRY_TO_KEEP_MAX = DEFAULT_TRY_TO_KEEP_MAX;
var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1e3;
queryCache.DEFAULT_UNEXECUTED_LIFETIME = DEFAULT_UNEXECUTED_LIFETIME;
var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache2) => {
  if (queryCache2._map.size < tryToKeepMax) {
    return;
  }
  var minUnExecutedLifetime = (0, _utils$e.now)() - unExecutedLifetime;
  var maybeUncache = [];
  var queriesInCache = Array.from(queryCache2._map.values());
  for (var rxQuery2 of queriesInCache) {
    if (countRxQuerySubscribers(rxQuery2) > 0) {
      continue;
    }
    if (rxQuery2._lastEnsureEqual === 0 && rxQuery2._creationTime < minUnExecutedLifetime) {
      uncacheRxQuery(queryCache2, rxQuery2);
      continue;
    }
    maybeUncache.push(rxQuery2);
  }
  var mustUncache = maybeUncache.length - tryToKeepMax;
  if (mustUncache <= 0) {
    return;
  }
  var sortedByLastUsage = maybeUncache.sort((a2, b2) => a2._lastEnsureEqual - b2._lastEnsureEqual);
  var toRemove = sortedByLastUsage.slice(0, mustUncache);
  toRemove.forEach((rxQuery3) => uncacheRxQuery(queryCache2, rxQuery3));
};
queryCache.defaultCacheReplacementPolicyMonad = defaultCacheReplacementPolicyMonad;
var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);
queryCache.defaultCacheReplacementPolicy = defaultCacheReplacementPolicy;
var COLLECTIONS_WITH_RUNNING_CLEANUP = /* @__PURE__ */ new WeakSet();
queryCache.COLLECTIONS_WITH_RUNNING_CLEANUP = COLLECTIONS_WITH_RUNNING_CLEANUP;
function triggerCacheReplacement(rxCollection2) {
  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection2)) {
    return;
  }
  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection2);
  (0, _utils$e.nextTick)().then(() => (0, _utils$e.requestIdlePromise)(200)).then(() => {
    if (!rxCollection2.destroyed) {
      rxCollection2.cacheReplacementPolicy(rxCollection2, rxCollection2._queryCache);
    }
    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection2);
  });
}
var _interopRequireDefault$3 = interopRequireDefaultExports$1;
Object.defineProperty(rxQuery, "__esModule", {
  value: true
});
rxQuery.RxQueryBase = void 0;
rxQuery._getDefaultQuery = _getDefaultQuery;
rxQuery.createRxQuery = createRxQuery;
rxQuery.isFindOneByIdQuery = isFindOneByIdQuery;
rxQuery.isRxQuery = isRxQuery;
rxQuery.queryCollection = queryCollection;
rxQuery.tunnelQueryCache = tunnelQueryCache;
var _createClass2$2 = _interopRequireDefault$3(requireCreateClass());
var _rxjs$4 = cjs;
var _operators$3 = operators;
var _utils$d = utils;
var _rxError$6 = rxError;
var _hooks$5 = hooks;
var _eventReduce = requireEventReduce();
var _queryCache$1 = queryCache;
var _rxQueryHelper = rxQueryHelper;
var _queryCount = 0;
var newQueryID = function() {
  return ++_queryCount;
};
var RxQueryBase = /* @__PURE__ */ function() {
  function RxQueryBase2(op, mangoQuery, collection, other = {}) {
    this.id = newQueryID();
    this._execOverDatabaseCount = 0;
    this._creationTime = (0, _utils$d.now)();
    this._lastEnsureEqual = 0;
    this.uncached = false;
    this.refCount$ = new _rxjs$4.BehaviorSubject(null);
    this._result = null;
    this._latestChangeEvent = -1;
    this._lastExecStart = 0;
    this._lastExecEnd = 0;
    this._ensureEqualQueue = _utils$d.PROMISE_RESOLVE_FALSE;
    this.op = op;
    this.mangoQuery = mangoQuery;
    this.collection = collection;
    this.other = other;
    if (!mangoQuery) {
      this.mangoQuery = _getDefaultQuery();
    }
    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);
  }
  var _proto = RxQueryBase2.prototype;
  _proto._setResultData = function _setResultData(newResultData) {
    if (typeof newResultData === "number") {
      this._result = {
        docsData: [],
        docsMap: /* @__PURE__ */ new Map(),
        docsDataMap: /* @__PURE__ */ new Map(),
        count: newResultData,
        docs: [],
        time: (0, _utils$d.now)()
      };
      return;
    } else if (newResultData instanceof Map) {
      newResultData = Array.from(newResultData.values());
    }
    var docsDataMap = /* @__PURE__ */ new Map();
    var docsMap = /* @__PURE__ */ new Map();
    var docs = newResultData.map((docData) => this.collection._docCache.getCachedRxDocument(docData));
    var docsData = docs.map((doc) => {
      docsDataMap.set(doc.primary, doc._data);
      docsMap.set(doc.primary, doc);
      return doc._data;
    });
    this._result = {
      docsData,
      docsMap,
      docsDataMap,
      count: docsData.length,
      docs,
      time: (0, _utils$d.now)()
    };
  };
  _proto._execOverDatabase = async function _execOverDatabase() {
    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;
    this._lastExecStart = (0, _utils$d.now)();
    if (this.op === "count") {
      var preparedQuery = this.getPreparedQuery();
      var result = await this.collection.storageInstance.count(preparedQuery);
      if (result.mode === "slow" && !this.collection.database.allowSlowCount) {
        throw (0, _rxError$6.newRxError)("QU14", {
          collection: this.collection,
          queryObj: this.mangoQuery
        });
      } else {
        return result.count;
      }
    }
    if (this.op === "findByIds") {
      var ids = (0, _utils$d.ensureNotFalsy)(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;
      var ret = /* @__PURE__ */ new Map();
      var mustBeQueried = [];
      ids.forEach((id) => {
        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);
        if (docData) {
          if (!docData._deleted) {
            var doc = this.collection._docCache.getCachedRxDocument(docData);
            ret.set(id, doc);
          }
        } else {
          mustBeQueried.push(id);
        }
      });
      if (mustBeQueried.length > 0) {
        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);
        Object.values(docs).forEach((docData) => {
          var doc = this.collection._docCache.getCachedRxDocument(docData);
          ret.set(doc.primary, doc);
        });
      }
      return ret;
    }
    var docsPromise = queryCollection(this);
    return docsPromise.then((docs2) => {
      this._lastExecEnd = (0, _utils$d.now)();
      return docs2;
    });
  };
  _proto.exec = function exec(throwIfMissing) {
    if (throwIfMissing && this.op !== "findOne") {
      throw (0, _rxError$6.newRxError)("QU9", {
        collection: this.collection.name,
        query: this.mangoQuery,
        op: this.op
      });
    }
    return _ensureEqual(this).then(() => (0, _rxjs$4.firstValueFrom)(this.$)).then((result) => {
      if (!result && throwIfMissing) {
        throw (0, _rxError$6.newRxError)("QU10", {
          collection: this.collection.name,
          query: this.mangoQuery,
          op: this.op
        });
      } else {
        return result;
      }
    });
  };
  _proto.toString = function toString2() {
    var stringObj = (0, _utils$d.sortObject)({
      op: this.op,
      query: this.mangoQuery,
      other: this.other
    }, true);
    var value = JSON.stringify(stringObj, _utils$d.stringifyFilter);
    this.toString = () => value;
    return value;
  };
  _proto.getPreparedQuery = function getPreparedQuery() {
    var hookInput = {
      rxQuery: this,
      // can be mutated by the hooks so we have to deep clone first.
      mangoQuery: (0, _rxQueryHelper.normalizeMangoQuery)(this.collection.schema.jsonSchema, this.mangoQuery)
    };
    (0, _hooks$5.runPluginHooks)("prePrepareQuery", hookInput);
    var value = this.collection.database.storage.statics.prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);
    this.getPreparedQuery = () => value;
    return value;
  };
  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {
    if (docData._deleted) {
      return false;
    }
    return this.queryMatcher(docData);
  };
  _proto.remove = function remove() {
    return this.exec().then((docs) => {
      if (Array.isArray(docs)) {
        return Promise.all(docs.map((doc) => doc.remove()));
      } else {
        return docs.remove();
      }
    });
  };
  _proto.update = function update2(_updateObj) {
    throw (0, _utils$d.pluginMissing)("update");
  };
  _proto.where = function where2(_queryObj) {
    throw (0, _utils$d.pluginMissing)("query-builder");
  };
  _proto.sort = function sort2(_params) {
    throw (0, _utils$d.pluginMissing)("query-builder");
  };
  _proto.skip = function skip2(_amount) {
    throw (0, _utils$d.pluginMissing)("query-builder");
  };
  _proto.limit = function limit2(_amount) {
    throw (0, _utils$d.pluginMissing)("query-builder");
  };
  (0, _createClass2$2.default)(RxQueryBase2, [{
    key: "$",
    get: function() {
      if (!this._$) {
        var results$ = this.collection.$.pipe(
          /**
           * Performance shortcut.
           * Changes to local documents are not relevant for the query.
           */
          (0, _operators$3.filter)((changeEvent) => !changeEvent.isLocal),
          /**
           * Start once to ensure the querying also starts
           * when there where no changes.
           */
          (0, _operators$3.startWith)(null),
          // ensure query results are up to date.
          (0, _operators$3.mergeMap)(() => _ensureEqual(this)),
          // use the current result set, written by _ensureEqual().
          (0, _operators$3.map)(() => this._result),
          // do not run stuff above for each new subscriber, only once.
          (0, _operators$3.shareReplay)(_utils$d.RXJS_SHARE_REPLAY_DEFAULTS),
          // do not proceed if result set has not changed.
          (0, _operators$3.distinctUntilChanged)((prev, curr) => {
            if (prev && prev.time === (0, _utils$d.ensureNotFalsy)(curr).time) {
              return true;
            } else {
              return false;
            }
          }),
          (0, _operators$3.filter)((result) => !!result),
          /**
           * Map the result set to a single RxDocument or an array,
           * depending on query type
           */
          (0, _operators$3.map)((result) => {
            var useResult = (0, _utils$d.ensureNotFalsy)(result);
            if (this.op === "count") {
              return useResult.count;
            } else if (this.op === "findOne") {
              return useResult.docs.length === 0 ? null : useResult.docs[0];
            } else if (this.op === "findByIds") {
              return useResult.docsMap;
            } else {
              return useResult.docs.slice(0);
            }
          })
        );
        this._$ = (0, _rxjs$4.merge)(
          results$,
          /**
           * Also add the refCount$ to the query observable
           * to allow us to count the amount of subscribers.
           */
          this.refCount$.pipe((0, _operators$3.filter)(() => false))
        );
      }
      return this._$;
    }
    // stores the changeEvent-number of the last handled change-event
    // time stamps on when the last full exec over the database has run
    // used to properly handle events that happen while the find-query is running
    /**
     * ensures that the exec-runs
     * are not run in parallel
     */
  }, {
    key: "queryMatcher",
    get: function() {
      var schema = this.collection.schema.jsonSchema;
      var normalizedQuery = (0, _rxQueryHelper.normalizeMangoQuery)(this.collection.schema.jsonSchema, this.mangoQuery);
      return (0, _utils$d.overwriteGetterForCaching)(this, "queryMatcher", (0, _rxQueryHelper.getQueryMatcher)(schema, normalizedQuery));
    }
  }, {
    key: "asRxQuery",
    get: function() {
      return this;
    }
  }]);
  return RxQueryBase2;
}();
rxQuery.RxQueryBase = RxQueryBase;
function _getDefaultQuery() {
  return {
    selector: {}
  };
}
function tunnelQueryCache(rxQuery2) {
  return rxQuery2.collection._queryCache.getByQuery(rxQuery2);
}
function createRxQuery(op, queryObj, collection, other) {
  (0, _hooks$5.runPluginHooks)("preCreateRxQuery", {
    op,
    queryObj,
    collection,
    other
  });
  var ret = new RxQueryBase(op, queryObj, collection, other);
  ret = tunnelQueryCache(ret);
  (0, _queryCache$1.triggerCacheReplacement)(collection);
  return ret;
}
function _isResultsInSync(rxQuery2) {
  var currentLatestEventNumber = rxQuery2.asRxQuery.collection._changeEventBuffer.counter;
  if (rxQuery2._latestChangeEvent >= currentLatestEventNumber) {
    return true;
  } else {
    return false;
  }
}
function _ensureEqual(rxQuery2) {
  if (rxQuery2.collection.database.destroyed || _isResultsInSync(rxQuery2)) {
    return _utils$d.PROMISE_RESOLVE_FALSE;
  }
  rxQuery2._ensureEqualQueue = rxQuery2._ensureEqualQueue.then(() => __ensureEqual(rxQuery2));
  return rxQuery2._ensureEqualQueue;
}
function __ensureEqual(rxQuery2) {
  rxQuery2._lastEnsureEqual = (0, _utils$d.now)();
  if (
    // db is closed
    rxQuery2.collection.database.destroyed || // nothing happened since last run
    _isResultsInSync(rxQuery2)
  ) {
    return _utils$d.PROMISE_RESOLVE_FALSE;
  }
  var ret = false;
  var mustReExec = false;
  if (rxQuery2._latestChangeEvent === -1) {
    mustReExec = true;
  }
  if (!mustReExec) {
    var missedChangeEvents = rxQuery2.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery2._latestChangeEvent + 1);
    if (missedChangeEvents === null) {
      mustReExec = true;
    } else {
      rxQuery2._latestChangeEvent = rxQuery2.asRxQuery.collection._changeEventBuffer.counter;
      var runChangeEvents = rxQuery2.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);
      if (rxQuery2.op === "count") {
        var previousCount = (0, _utils$d.ensureNotFalsy)(rxQuery2._result).count;
        var newCount = previousCount;
        runChangeEvents.forEach((cE) => {
          var didMatchBefore = cE.previousDocumentData && rxQuery2.doesDocumentDataMatch(cE.previousDocumentData);
          var doesMatchNow = rxQuery2.doesDocumentDataMatch(cE.documentData);
          if (!didMatchBefore && doesMatchNow) {
            newCount++;
          }
          if (didMatchBefore && !doesMatchNow) {
            newCount--;
          }
        });
        if (newCount !== previousCount) {
          ret = true;
          rxQuery2._setResultData(newCount);
        }
      } else {
        var eventReduceResult = (0, _eventReduce.calculateNewResults)(rxQuery2, runChangeEvents);
        if (eventReduceResult.runFullQueryAgain) {
          mustReExec = true;
        } else if (eventReduceResult.changed) {
          ret = true;
          rxQuery2._setResultData(eventReduceResult.newResults);
        }
      }
    }
  }
  if (mustReExec) {
    var latestAfter = rxQuery2.collection._changeEventBuffer.counter;
    return rxQuery2._execOverDatabase().then((newResultData) => {
      rxQuery2._latestChangeEvent = latestAfter;
      if (typeof newResultData === "number") {
        if (!rxQuery2._result || newResultData !== rxQuery2._result.count) {
          ret = true;
          rxQuery2._setResultData(newResultData);
        }
        return ret;
      }
      if (!rxQuery2._result || !(0, _utils$d.areRxDocumentArraysEqual)(rxQuery2.collection.schema.primaryPath, newResultData, rxQuery2._result.docsData)) {
        ret = true;
        rxQuery2._setResultData(newResultData);
      }
      return ret;
    });
  }
  return Promise.resolve(ret);
}
async function queryCollection(rxQuery2) {
  var docs = [];
  var collection = rxQuery2.collection;
  if (rxQuery2.isFindOneByIdQuery) {
    if (Array.isArray(rxQuery2.isFindOneByIdQuery)) {
      var docIds = rxQuery2.isFindOneByIdQuery;
      docIds = docIds.filter((docId2) => {
        var docData2 = rxQuery2.collection._docCache.getLatestDocumentDataIfExists(docId2);
        if (docData2) {
          if (!docData2._deleted) {
            docs.push(docData2);
          }
          return false;
        } else {
          return true;
        }
      });
      if (docIds.length > 0) {
        var docsMap = await collection.storageInstance.findDocumentsById(docIds, false);
        Object.values(docsMap).forEach((docData2) => {
          docs.push(docData2);
        });
      }
    } else {
      var docId = rxQuery2.isFindOneByIdQuery;
      var docData = rxQuery2.collection._docCache.getLatestDocumentDataIfExists(docId);
      if (!docData) {
        var _docsMap = await collection.storageInstance.findDocumentsById([docId], false);
        if (_docsMap.hasOwnProperty(docId)) {
          docData = _docsMap[docId];
        }
      }
      if (docData && !docData._deleted) {
        docs.push(docData);
      }
    }
  } else {
    var preparedQuery = rxQuery2.getPreparedQuery();
    var queryResult = await collection.storageInstance.query(preparedQuery);
    docs = queryResult.documents;
  }
  return docs;
}
function isFindOneByIdQuery(primaryPath, query2) {
  if (!query2.skip && query2.selector && Object.keys(query2.selector).length === 1 && query2.selector[primaryPath]) {
    var value = query2.selector[primaryPath];
    if (typeof value === "string") {
      return value;
    } else if (Object.keys(value).length === 1 && typeof value.$eq === "string") {
      return value.$eq;
    }
    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) && // must only contain strings
    !value.$eq.find((r2) => typeof r2 !== "string")) {
      return value.$eq;
    }
  }
  return false;
}
function isRxQuery(obj) {
  return obj instanceof RxQueryBase;
}
var rxCollection = {};
var rxCollectionHelper = {};
var rxDatabaseInternalStore = {};
Object.defineProperty(rxDatabaseInternalStore, "__esModule", {
  value: true
});
rxDatabaseInternalStore.STORAGE_TOKEN_DOCUMENT_KEY = rxDatabaseInternalStore.STORAGE_TOKEN_DOCUMENT_ID = rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA_TITLE = rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA = rxDatabaseInternalStore.INTERNAL_CONTEXT_STORAGE_TOKEN = rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION = void 0;
rxDatabaseInternalStore._collectionNamePrimary = _collectionNamePrimary;
rxDatabaseInternalStore.addConnectedStorageToCollection = addConnectedStorageToCollection;
rxDatabaseInternalStore.ensureStorageTokenDocumentExists = ensureStorageTokenDocumentExists;
rxDatabaseInternalStore.getAllCollectionDocuments = getAllCollectionDocuments;
rxDatabaseInternalStore.getPrimaryKeyOfInternalDocument = getPrimaryKeyOfInternalDocument;
var _rxError$5 = rxError;
var _rxSchemaHelper$5 = rxSchemaHelper;
var _rxStorageHelper$7 = rxStorageHelper;
var _utils$c = utils;
var INTERNAL_CONTEXT_COLLECTION = "collection";
rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION = INTERNAL_CONTEXT_COLLECTION;
var INTERNAL_CONTEXT_STORAGE_TOKEN = "storage-token";
rxDatabaseInternalStore.INTERNAL_CONTEXT_STORAGE_TOKEN = INTERNAL_CONTEXT_STORAGE_TOKEN;
var INTERNAL_STORE_SCHEMA_TITLE = "RxInternalDocument";
rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA_TITLE = INTERNAL_STORE_SCHEMA_TITLE;
var INTERNAL_STORE_SCHEMA = (0, _rxSchemaHelper$5.fillWithDefaultSettings)({
  version: 0,
  title: INTERNAL_STORE_SCHEMA_TITLE,
  primaryKey: {
    key: "id",
    fields: ["context", "key"],
    separator: "|"
  },
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 200
    },
    key: {
      type: "string"
    },
    context: {
      type: "string",
      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, "OTHER"]
    },
    data: {
      type: "object",
      additionalProperties: true
    }
  },
  indexes: [],
  required: ["key", "context", "data"],
  additionalProperties: false,
  /**
   * If the sharding plugin is used,
   * it must not shard on the internal RxStorageInstance
   * because that one anyway has only a small amount of documents
   * and also its creation is in the hot path of the initial page load,
   * so we should spend less time creating multiple RxStorageInstances.
   */
  sharding: {
    shards: 1,
    mode: "collection"
  }
});
rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA = INTERNAL_STORE_SCHEMA;
function getPrimaryKeyOfInternalDocument(key, context2) {
  return (0, _rxSchemaHelper$5.getComposedPrimaryKeyOfDocumentData)(INTERNAL_STORE_SCHEMA, {
    key,
    context: context2
  });
}
async function getAllCollectionDocuments(storageStatics, storageInstance) {
  var getAllQueryPrepared = storageStatics.prepareQuery(storageInstance.schema, {
    selector: {
      context: INTERNAL_CONTEXT_COLLECTION
    },
    sort: [{
      id: "asc"
    }],
    skip: 0
  });
  var queryResult = await storageInstance.query(getAllQueryPrepared);
  var allDocs = queryResult.documents;
  return allDocs;
}
var STORAGE_TOKEN_DOCUMENT_KEY = "storageToken";
rxDatabaseInternalStore.STORAGE_TOKEN_DOCUMENT_KEY = STORAGE_TOKEN_DOCUMENT_KEY;
var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);
rxDatabaseInternalStore.STORAGE_TOKEN_DOCUMENT_ID = STORAGE_TOKEN_DOCUMENT_ID;
async function ensureStorageTokenDocumentExists(rxDatabase2) {
  var storageToken = (0, _utils$c.randomCouchString)(10);
  var passwordHash = rxDatabase2.password ? rxDatabase2.hashFunction(JSON.stringify(rxDatabase2.password)) : void 0;
  var docData = {
    id: STORAGE_TOKEN_DOCUMENT_ID,
    context: INTERNAL_CONTEXT_STORAGE_TOKEN,
    key: STORAGE_TOKEN_DOCUMENT_KEY,
    data: {
      token: storageToken,
      /**
       * We add the instance token here
       * to be able to detect if a given RxDatabase instance
       * is the first instance that was ever created
       * or if databases have existed earlier on that storage
       * with the same database name.
       */
      instanceToken: rxDatabase2.token,
      passwordHash
    },
    _deleted: false,
    _meta: (0, _utils$c.getDefaultRxDocumentMeta)(),
    _rev: (0, _utils$c.getDefaultRevision)(),
    _attachments: {}
  };
  var writeResult = await rxDatabase2.internalStore.bulkWrite([{
    document: docData
  }], "internal-add-storage-token");
  if (writeResult.success[STORAGE_TOKEN_DOCUMENT_ID]) {
    return writeResult.success[STORAGE_TOKEN_DOCUMENT_ID];
  }
  var error = (0, _utils$c.ensureNotFalsy)(writeResult.error[STORAGE_TOKEN_DOCUMENT_ID]);
  if (error.isError && error.status === 409) {
    var conflictError = error;
    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {
      throw (0, _rxError$5.newRxError)("DB1", {
        passwordHash,
        existingPasswordHash: conflictError.documentInDb.data.passwordHash
      });
    }
    var storageTokenDocInDb = conflictError.documentInDb;
    return (0, _utils$c.ensureNotFalsy)(storageTokenDocInDb);
  }
  throw error;
}
async function addConnectedStorageToCollection(collection, storageCollectionName, schema) {
  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);
  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);
  while (true) {
    var collectionDoc = await (0, _rxStorageHelper$7.getSingleDocument)(collection.database.internalStore, collectionDocId);
    var saveData = (0, _utils$c.clone)((0, _utils$c.ensureNotFalsy)(collectionDoc));
    if (!saveData.data.connectedStorages) {
      saveData.data.connectedStorages = [];
    }
    var alreadyThere = saveData.data.connectedStorages.find((row) => row.collectionName === storageCollectionName && row.schema.version === schema.version);
    if (alreadyThere) {
      return;
    }
    saveData.data.connectedStorages.push({
      collectionName: storageCollectionName,
      schema
    });
    try {
      await (0, _rxStorageHelper$7.writeSingle)(collection.database.internalStore, {
        previous: (0, _utils$c.ensureNotFalsy)(collectionDoc),
        document: saveData
      }, "add-connected-storage-to-collection");
    } catch (err) {
      if (!(0, _rxError$5.isBulkWriteConflictError)(err)) {
        throw err;
      }
    }
  }
}
function _collectionNamePrimary(name, schema) {
  return name + "-" + schema.version;
}
Object.defineProperty(rxCollectionHelper, "__esModule", {
  value: true
});
rxCollectionHelper.createRxCollectionStorageInstance = createRxCollectionStorageInstance;
rxCollectionHelper.fillObjectDataBeforeInsert = fillObjectDataBeforeInsert;
rxCollectionHelper.removeCollectionStorages = removeCollectionStorages;
var _utils$b = utils;
var _rxSchemaHelper$4 = rxSchemaHelper;
var _hooks$4 = hooks;
var _rxDatabaseInternalStore$1 = rxDatabaseInternalStore;
var _rxStorageHelper$6 = rxStorageHelper;
var _overwritable$4 = overwritable$1;
function fillObjectDataBeforeInsert(schema, data) {
  data = (0, _utils$b.flatClone)(data);
  data = (0, _rxSchemaHelper$4.fillObjectWithDefaults)(schema, data);
  data = (0, _rxSchemaHelper$4.fillPrimaryKey)(schema.primaryPath, schema.jsonSchema, data);
  data._meta = (0, _utils$b.getDefaultRxDocumentMeta)();
  if (!data.hasOwnProperty("_deleted")) {
    data._deleted = false;
  }
  if (!data.hasOwnProperty("_attachments")) {
    data._attachments = {};
  }
  if (!data.hasOwnProperty("_rev")) {
    data._rev = (0, _utils$b.getDefaultRevision)();
  }
  return data;
}
async function createRxCollectionStorageInstance(rxDatabase2, storageInstanceCreationParams) {
  storageInstanceCreationParams.multiInstance = rxDatabase2.multiInstance;
  var storageInstance = await rxDatabase2.storage.createStorageInstance(storageInstanceCreationParams);
  return storageInstance;
}
async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, hashFunction) {
  var allCollectionMetaDocs = await (0, _rxDatabaseInternalStore$1.getAllCollectionDocuments)(storage.statics, databaseInternalStorage);
  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter((metaDoc) => metaDoc.data.name === collectionName);
  var removeStorages = [];
  relevantCollectionMetaDocs.forEach((metaDoc) => {
    removeStorages.push({
      collectionName: metaDoc.data.name,
      schema: metaDoc.data.schema,
      isCollection: true
    });
    metaDoc.data.connectedStorages.forEach((row) => removeStorages.push({
      collectionName: row.collectionName,
      isCollection: false,
      schema: row.schema
    }));
  });
  var alreadyAdded = /* @__PURE__ */ new Set();
  removeStorages = removeStorages.filter((row) => {
    var key = row.collectionName + "||" + row.schema.version;
    if (alreadyAdded.has(key)) {
      return false;
    } else {
      alreadyAdded.add(key);
      return true;
    }
  });
  await Promise.all(removeStorages.map(async (row) => {
    var storageInstance = await storage.createStorageInstance({
      collectionName: row.collectionName,
      databaseInstanceToken,
      databaseName,
      multiInstance: false,
      options: {},
      schema: row.schema,
      devMode: _overwritable$4.overwritable.isDevMode()
    });
    await storageInstance.remove();
    if (row.isCollection) {
      await (0, _hooks$4.runAsyncPluginHooks)("postRemoveRxCollection", {
        storage,
        databaseName,
        collectionName
      });
    }
  }));
  if (hashFunction) {
    var writeRows = relevantCollectionMetaDocs.map((doc) => {
      var writeDoc = (0, _rxStorageHelper$6.flatCloneDocWithMeta)(doc);
      writeDoc._deleted = true;
      writeDoc._meta.lwt = (0, _utils$b.now)();
      writeDoc._rev = (0, _utils$b.createRevision)(databaseInstanceToken, doc);
      return {
        previous: doc,
        document: writeDoc
      };
    });
    await databaseInternalStorage.bulkWrite(writeRows, "rx-database-remove-collection-all");
  }
}
var docCache = {};
var hasRequiredDocCache;
function requireDocCache() {
  if (hasRequiredDocCache)
    return docCache;
  hasRequiredDocCache = 1;
  Object.defineProperty(docCache, "__esModule", {
    value: true
  });
  docCache.DocumentCache = void 0;
  var _utils2 = utils;
  var _overwritable2 = overwritable$1;
  var _rxChangeEvent2 = rxChangeEvent;
  var DocumentCache = /* @__PURE__ */ function() {
    function DocumentCache2(primaryPath, changes$, documentCreator) {
      this.cacheItemByDocId = /* @__PURE__ */ new Map();
      this.registry = typeof FinalizationRegistry === "function" ? new FinalizationRegistry((docMeta) => {
        var docId = docMeta.docId;
        var cacheItem = this.cacheItemByDocId.get(docId);
        if (cacheItem) {
          cacheItem.documentByRevisionHeight.delete(docMeta.revisionHeight);
          if (cacheItem.documentByRevisionHeight.size === 0) {
            this.cacheItemByDocId.delete(docId);
          }
        }
      }) : void 0;
      this.primaryPath = primaryPath;
      this.changes$ = changes$;
      this.documentCreator = documentCreator;
      changes$.subscribe((changeEvent) => {
        var docId = changeEvent.documentId;
        var cacheItem = this.cacheItemByDocId.get(docId);
        if (cacheItem) {
          var documentData = (0, _rxChangeEvent2.getDocumentDataOfRxChangeEvent)(changeEvent);
          cacheItem.latestDoc = documentData;
        }
      });
    }
    var _proto = DocumentCache2.prototype;
    _proto.getCachedRxDocument = function getCachedRxDocument(docData) {
      var docId = docData[this.primaryPath];
      var revisionHeight = (0, _utils2.getHeightOfRevision)(docData._rev);
      var cacheItem = (0, _utils2.getFromMapOrCreate)(this.cacheItemByDocId, docId, () => getNewCacheItem(docData));
      var cachedRxDocumentWeakRef = cacheItem.documentByRevisionHeight.get(revisionHeight);
      var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : void 0;
      if (!cachedRxDocument) {
        docData = _overwritable2.overwritable.deepFreezeWhenDevMode(docData);
        cachedRxDocument = this.documentCreator(docData);
        cacheItem.documentByRevisionHeight.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));
        if (this.registry) {
          this.registry.register(cachedRxDocument, {
            docId,
            revisionHeight
          });
        }
      }
      return cachedRxDocument;
    };
    _proto.getLatestDocumentData = function getLatestDocumentData(docId) {
      var cacheItem = (0, _utils2.getFromMapOrThrow)(this.cacheItemByDocId, docId);
      return cacheItem.latestDoc;
    };
    _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {
      var cacheItem = this.cacheItemByDocId.get(docId);
      if (cacheItem) {
        return cacheItem.latestDoc;
      }
    };
    return DocumentCache2;
  }();
  docCache.DocumentCache = DocumentCache;
  function getNewCacheItem(docData) {
    return {
      documentByRevisionHeight: /* @__PURE__ */ new Map(),
      latestDoc: docData
    };
  }
  var HAS_WEAK_REF = typeof WeakRef === "function";
  function createWeakRefWithFallback(obj) {
    if (HAS_WEAK_REF) {
      return new WeakRef(obj);
    } else {
      return {
        deref() {
          return obj;
        }
      };
    }
  }
  return docCache;
}
var changeEventBuffer = {};
var hasRequiredChangeEventBuffer;
function requireChangeEventBuffer() {
  if (hasRequiredChangeEventBuffer)
    return changeEventBuffer;
  hasRequiredChangeEventBuffer = 1;
  Object.defineProperty(changeEventBuffer, "__esModule", {
    value: true
  });
  changeEventBuffer.ChangeEventBuffer = void 0;
  changeEventBuffer.createChangeEventBuffer = createChangeEventBuffer;
  var _operators2 = operators;
  var ChangeEventBuffer = /* @__PURE__ */ function() {
    function ChangeEventBuffer2(collection) {
      this.subs = [];
      this.limit = 100;
      this.counter = 0;
      this.eventCounterMap = /* @__PURE__ */ new WeakMap();
      this.buffer = [];
      this.collection = collection;
      this.subs.push(this.collection.$.pipe((0, _operators2.filter)((cE) => !cE.isLocal)).subscribe((cE) => this._handleChangeEvent(cE)));
    }
    var _proto = ChangeEventBuffer2.prototype;
    _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {
      this.counter++;
      this.buffer.push(changeEvent);
      this.eventCounterMap.set(changeEvent, this.counter);
      while (this.buffer.length > this.limit) {
        this.buffer.shift();
      }
    };
    _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {
      var oldestEvent = this.buffer[0];
      var oldestCounter = this.eventCounterMap.get(oldestEvent);
      if (pointer < oldestCounter)
        return null;
      var rest = pointer - oldestCounter;
      return rest;
    };
    _proto.getFrom = function getFrom(pointer) {
      var ret = [];
      var currentIndex = this.getArrayIndexByPointer(pointer);
      if (currentIndex === null)
        return null;
      while (true) {
        var nextEvent = this.buffer[currentIndex];
        currentIndex++;
        if (!nextEvent) {
          return ret;
        } else {
          ret.push(nextEvent);
        }
      }
    };
    _proto.runFrom = function runFrom(pointer, fn2) {
      var ret = this.getFrom(pointer);
      if (ret === null) {
        throw new Error("out of bounds");
      } else {
        ret.forEach((cE) => fn2(cE));
      }
    };
    _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {
      return changeEvents.slice(0);
    };
    _proto.destroy = function destroy() {
      this.subs.forEach((sub) => sub.unsubscribe());
    };
    return ChangeEventBuffer2;
  }();
  changeEventBuffer.ChangeEventBuffer = ChangeEventBuffer;
  function createChangeEventBuffer(collection) {
    return new ChangeEventBuffer(collection);
  }
  return changeEventBuffer;
}
var rxDocumentPrototypeMerge = {};
Object.defineProperty(rxDocumentPrototypeMerge, "__esModule", {
  value: true
});
rxDocumentPrototypeMerge.createNewRxDocument = createNewRxDocument;
rxDocumentPrototypeMerge.getDocumentOrmPrototype = getDocumentOrmPrototype;
rxDocumentPrototypeMerge.getDocumentPrototype = getDocumentPrototype;
rxDocumentPrototypeMerge.getRxDocumentConstructor = getRxDocumentConstructor;
var _rxDocument$2 = rxDocument;
var _hooks$3 = hooks;
var _overwritable$3 = overwritable$1;
var _utils$a = utils;
var constructorForCollection = /* @__PURE__ */ new WeakMap();
function getDocumentPrototype(rxCollection2) {
  var schemaProto = rxCollection2.schema.getDocumentPrototype();
  var ormProto = getDocumentOrmPrototype(rxCollection2);
  var baseProto = _rxDocument$2.basePrototype;
  var proto = {};
  [schemaProto, ormProto, baseProto].forEach((obj) => {
    var props = Object.getOwnPropertyNames(obj);
    props.forEach((key) => {
      var desc = Object.getOwnPropertyDescriptor(obj, key);
      var enumerable = true;
      if (key.startsWith("_") || key.endsWith("_") || key.startsWith("$") || key.endsWith("$"))
        enumerable = false;
      if (typeof desc.value === "function") {
        Object.defineProperty(proto, key, {
          get() {
            return desc.value.bind(this);
          },
          enumerable,
          configurable: false
        });
      } else {
        desc.enumerable = enumerable;
        desc.configurable = false;
        if (desc.writable)
          desc.writable = false;
        Object.defineProperty(proto, key, desc);
      }
    });
  });
  return proto;
}
function getRxDocumentConstructor(rxCollection2) {
  return (0, _utils$a.getFromMapOrCreate)(constructorForCollection, rxCollection2, () => (0, _rxDocument$2.createRxDocumentConstructor)(getDocumentPrototype(rxCollection2)));
}
function createNewRxDocument(rxCollection2, docData) {
  var doc = (0, _rxDocument$2.createWithConstructor)(getRxDocumentConstructor(rxCollection2), rxCollection2, _overwritable$3.overwritable.deepFreezeWhenDevMode(docData));
  rxCollection2._runHooksSync("post", "create", docData, doc);
  (0, _hooks$3.runPluginHooks)("postCreateRxDocument", doc);
  return doc;
}
function getDocumentOrmPrototype(rxCollection2) {
  var proto = {};
  Object.entries(rxCollection2.methods).forEach(([k2, v2]) => {
    proto[k2] = v2;
  });
  return proto;
}
var replicationProtocol = {};
var checkpoint = {};
Object.defineProperty(checkpoint, "__esModule", {
  value: true
});
checkpoint.getCheckpointKey = getCheckpointKey;
checkpoint.getLastCheckpointDoc = getLastCheckpointDoc;
checkpoint.setCheckpoint = setCheckpoint;
var _rxSchemaHelper$3 = rxSchemaHelper;
var _rxStorageHelper$5 = rxStorageHelper;
var _utils$9 = utils;
async function getLastCheckpointDoc(state, direction) {
  var checkpointDocId = (0, _rxSchemaHelper$3.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, {
    isCheckpoint: "1",
    itemId: direction
  });
  var checkpointResult = await state.input.metaInstance.findDocumentsById([checkpointDocId], false);
  var checkpointDoc = checkpointResult[checkpointDocId];
  state.lastCheckpointDoc[direction] = checkpointDoc;
  if (checkpointDoc) {
    return checkpointDoc.data;
  } else {
    return void 0;
  }
}
async function setCheckpoint(state, direction, checkpoint2) {
  var previousCheckpointDoc = state.lastCheckpointDoc[direction];
  if (checkpoint2 && /**
   * If the replication is already canceled,
   * we do not write a checkpoint
   * because that could mean we write a checkpoint
   * for data that has been fetched from the master
   * but not been written to the child.
   */
  !state.events.canceled.getValue() && /**
   * Only write checkpoint if it is different from before
   * to have less writes to the storage.
   */
  (!previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.data) !== JSON.stringify(checkpoint2))) {
    var newDoc = {
      id: "",
      isCheckpoint: "1",
      itemId: direction,
      _deleted: false,
      _attachments: {},
      data: checkpoint2,
      _meta: (0, _utils$9.getDefaultRxDocumentMeta)(),
      _rev: (0, _utils$9.getDefaultRevision)()
    };
    newDoc.id = (0, _rxSchemaHelper$3.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, newDoc);
    while (!state.events.canceled.getValue()) {
      if (previousCheckpointDoc) {
        newDoc.data = (0, _rxStorageHelper$5.stackCheckpoints)([previousCheckpointDoc.data, newDoc.data]);
      }
      newDoc._meta.lwt = (0, _utils$9.now)();
      newDoc._rev = (0, _utils$9.createRevision)(state.input.identifier, previousCheckpointDoc);
      var result = await state.input.metaInstance.bulkWrite([{
        previous: previousCheckpointDoc,
        document: newDoc
      }], "replication-set-checkpoint");
      if (result.success[newDoc.id]) {
        state.lastCheckpointDoc[direction] = (0, _utils$9.getFromObjectOrThrow)(result.success, newDoc.id);
        return;
      } else {
        var error = (0, _utils$9.getFromObjectOrThrow)(result.error, newDoc.id);
        if (error.status !== 409) {
          throw error;
        } else {
          previousCheckpointDoc = (0, _utils$9.ensureNotFalsy)(error.documentInDb);
          newDoc._rev = (0, _utils$9.createRevision)(state.input.identifier, previousCheckpointDoc);
        }
      }
    }
  }
}
function getCheckpointKey(input) {
  var hash2 = input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join("||"));
  return "rx-storage-replication-" + hash2;
}
var downstream = {};
var helper = {};
Object.defineProperty(helper, "__esModule", {
  value: true
});
helper.docStateToWriteDoc = docStateToWriteDoc;
helper.writeDocToDocState = writeDocToDocState;
var _utils$8 = utils;
function docStateToWriteDoc(databaseInstanceToken, docState, previous) {
  var docData = Object.assign({}, docState, {
    _attachments: {},
    _meta: {
      lwt: (0, _utils$8.now)()
    },
    _rev: (0, _utils$8.getDefaultRevision)()
  });
  docData._rev = (0, _utils$8.createRevision)(databaseInstanceToken, previous);
  return docData;
}
function writeDocToDocState(writeDoc) {
  var ret = (0, _utils$8.flatClone)(writeDoc);
  delete ret._attachments;
  delete ret._meta;
  delete ret._rev;
  return ret;
}
var metaInstance = {};
Object.defineProperty(metaInstance, "__esModule", {
  value: true
});
metaInstance.getAssumedMasterState = getAssumedMasterState;
metaInstance.getMetaWriteRow = getMetaWriteRow;
metaInstance.getRxReplicationMetaInstanceSchema = getRxReplicationMetaInstanceSchema;
var _rxSchemaHelper$2 = rxSchemaHelper;
var _rxStorageHelper$4 = rxStorageHelper;
var _utils$7 = utils;
function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {
  var parentPrimaryKeyLength = (0, _rxSchemaHelper$2.getLengthOfPrimaryKey)(replicatedDocumentsSchema);
  var baseSchema = {
    primaryKey: {
      key: "id",
      fields: ["itemId", "isCheckpoint"],
      separator: "|"
    },
    type: "object",
    version: 0,
    additionalProperties: false,
    properties: {
      id: {
        type: "string",
        minLength: 1,
        // add +1 for the '|' and +1 for the 'isCheckpoint' flag
        maxLength: parentPrimaryKeyLength + 2
      },
      isCheckpoint: {
        type: "string",
        enum: ["0", "1"],
        minLength: 1,
        maxLength: 1
      },
      itemId: {
        type: "string",
        maxLength: parentPrimaryKeyLength
      },
      data: {
        type: "object",
        additionalProperties: true
      },
      isResolvedConflict: {
        type: "string"
      }
    },
    required: ["id", "isCheckpoint", "itemId", "data"]
  };
  if (encrypted) {
    baseSchema.encrypted = ["data"];
  }
  var metaInstanceSchema = (0, _rxSchemaHelper$2.fillWithDefaultSettings)(baseSchema);
  return metaInstanceSchema;
}
function getAssumedMasterState(state, docIds) {
  return state.input.metaInstance.findDocumentsById(docIds.map((docId) => {
    var useId = (0, _rxSchemaHelper$2.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, {
      itemId: docId,
      isCheckpoint: "0"
    });
    return useId;
  }), true).then((metaDocs) => {
    var ret = {};
    Object.values(metaDocs).forEach((metaDoc) => {
      ret[metaDoc.itemId] = {
        docData: metaDoc.data,
        metaDocument: metaDoc
      };
    });
    return ret;
  });
}
function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {
  var docId = newMasterDocState[state.primaryPath];
  var newMeta = previous ? (0, _rxStorageHelper$4.flatCloneDocWithMeta)(previous) : {
    id: "",
    isCheckpoint: "0",
    itemId: docId,
    data: newMasterDocState,
    _attachments: {},
    _deleted: false,
    _rev: (0, _utils$7.getDefaultRevision)(),
    _meta: {
      lwt: 0
    }
  };
  newMeta.data = newMasterDocState;
  newMeta.isResolvedConflict = isResolvedConflict;
  newMeta._meta.lwt = (0, _utils$7.now)();
  newMeta.id = (0, _rxSchemaHelper$2.getComposedPrimaryKeyOfDocumentData)(state.input.metaInstance.schema, newMeta);
  newMeta._rev = (0, _utils$7.createRevision)(state.input.identifier, previous);
  return {
    previous,
    document: newMeta
  };
}
Object.defineProperty(downstream, "__esModule", {
  value: true
});
downstream.startReplicationDownstream = startReplicationDownstream;
var _rxjs$3 = cjs;
var _rxError$4 = rxError;
var _rxStorageHelper$3 = rxStorageHelper;
var _utils$6 = utils;
var _checkpoint$1 = checkpoint;
var _helper$1 = helper;
var _metaInstance$1 = metaInstance;
async function startReplicationDownstream(state) {
  if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {
    var checkpointDoc = await (0, _checkpoint$1.getLastCheckpointDoc)(state, "down");
    if (!checkpointDoc) {
      await (0, _checkpoint$1.setCheckpoint)(state, "down", state.input.initialCheckpoint.downstream);
    }
  }
  var identifierHash = state.input.hashFunction(state.input.identifier);
  var replicationHandler = state.input.replicationHandler;
  var timer2 = 0;
  var openTasks = [];
  function addNewTask(task) {
    state.stats.down.addNewTask = state.stats.down.addNewTask + 1;
    var taskWithTime = {
      time: timer2++,
      task
    };
    openTasks.push(taskWithTime);
    state.streamQueue.down = state.streamQueue.down.then(() => {
      var useTasks = [];
      while (openTasks.length > 0) {
        state.events.active.down.next(true);
        var innerTaskWithTime = (0, _utils$6.ensureNotFalsy)(openTasks.shift());
        if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {
          continue;
        }
        if (innerTaskWithTime.task === "RESYNC") {
          if (useTasks.length === 0) {
            useTasks.push(innerTaskWithTime.task);
            break;
          } else {
            break;
          }
        }
        useTasks.push(innerTaskWithTime.task);
      }
      if (useTasks.length === 0)
        return;
      if (useTasks[0] === "RESYNC") {
        return downstreamResyncOnce();
      } else {
        return downstreamProcessChanges(useTasks);
      }
    }).then(() => {
      state.events.active.down.next(false);
      if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {
        state.firstSyncDone.down.next(true);
      }
    });
  }
  addNewTask("RESYNC");
  var sub = replicationHandler.masterChangeStream$.subscribe((task) => {
    state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;
    addNewTask(task);
  });
  (0, _rxjs$3.firstValueFrom)(state.events.canceled.pipe((0, _rxjs$3.filter)((canceled) => !!canceled))).then(() => sub.unsubscribe());
  var lastTimeMasterChangesRequested = -1;
  async function downstreamResyncOnce() {
    state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;
    if (state.events.canceled.getValue()) {
      return;
    }
    state.checkpointQueue = state.checkpointQueue.then(() => (0, _checkpoint$1.getLastCheckpointDoc)(state, "down"));
    var lastCheckpoint = await state.checkpointQueue;
    var promises = [];
    while (!state.events.canceled.getValue()) {
      lastTimeMasterChangesRequested = timer2++;
      var downResult = await replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);
      if (downResult.documents.length === 0) {
        break;
      }
      lastCheckpoint = (0, _rxStorageHelper$3.stackCheckpoints)([lastCheckpoint, downResult.checkpoint]);
      promises.push(persistFromMaster(downResult.documents, lastCheckpoint));
      if (downResult.documents.length < state.input.pullBatchSize) {
        break;
      }
    }
    await Promise.all(promises);
  }
  function downstreamProcessChanges(tasks) {
    state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;
    var docsOfAllTasks = [];
    var lastCheckpoint = null;
    tasks.forEach((task) => {
      if (task === "RESYNC") {
        throw new Error("SNH");
      }
      (0, _utils$6.appendToArray)(docsOfAllTasks, task.documents);
      lastCheckpoint = (0, _rxStorageHelper$3.stackCheckpoints)([lastCheckpoint, task.checkpoint]);
    });
    return persistFromMaster(docsOfAllTasks, (0, _utils$6.ensureNotFalsy)(lastCheckpoint));
  }
  var persistenceQueue = _utils$6.PROMISE_RESOLVE_VOID;
  var nonPersistedFromMaster = {
    docs: {}
  };
  function persistFromMaster(docs, checkpoint2) {
    state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;
    docs.forEach((docData) => {
      var docId = docData[state.primaryPath];
      nonPersistedFromMaster.docs[docId] = docData;
    });
    nonPersistedFromMaster.checkpoint = checkpoint2;
    persistenceQueue = persistenceQueue.then(() => {
      var downDocsById = nonPersistedFromMaster.docs;
      nonPersistedFromMaster.docs = {};
      var useCheckpoint = nonPersistedFromMaster.checkpoint;
      var docIds = Object.keys(downDocsById);
      if (state.events.canceled.getValue() || docIds.length === 0) {
        return _utils$6.PROMISE_RESOLVE_VOID;
      }
      var writeRowsToFork = [];
      var writeRowsToForkById = {};
      var writeRowsToMeta = {};
      var useMetaWriteRows = [];
      return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), (0, _metaInstance$1.getAssumedMasterState)(state, docIds)]).then(([currentForkState, assumedMasterState]) => {
        return Promise.all(docIds.map(async (docId) => {
          var forkStateFullDoc = currentForkState[docId];
          var forkStateDocData = forkStateFullDoc ? (0, _helper$1.writeDocToDocState)(forkStateFullDoc) : void 0;
          var masterState = downDocsById[docId];
          var assumedMaster = assumedMasterState[docId];
          if (assumedMaster && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {
            return _utils$6.PROMISE_RESOLVE_VOID;
          }
          var isAssumedMasterEqualToForkStatePromise = !assumedMaster || !forkStateDocData ? _utils$6.PROMISE_RESOLVE_FALSE : state.input.conflictHandler({
            realMasterState: assumedMaster.docData,
            newDocumentState: forkStateDocData
          }, "downstream-check-if-equal-0").then((r2) => r2.isEqual);
          var isAssumedMasterEqualToForkState = await isAssumedMasterEqualToForkStatePromise;
          if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc._meta[state.input.identifier] && (0, _utils$6.parseRevision)(forkStateFullDoc._rev).height === forkStateFullDoc._meta[state.input.identifier]) {
            isAssumedMasterEqualToForkState = true;
          }
          if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {
            return _utils$6.PROMISE_RESOLVE_VOID;
          }
          var areStatesExactlyEqualPromise = !forkStateDocData ? _utils$6.PROMISE_RESOLVE_FALSE : state.input.conflictHandler({
            realMasterState: masterState,
            newDocumentState: forkStateDocData
          }, "downstream-check-if-equal-1").then((r2) => r2.isEqual);
          var areStatesExactlyEqual = await areStatesExactlyEqualPromise;
          if (forkStateDocData && areStatesExactlyEqual) {
            if (!assumedMaster || isAssumedMasterEqualToForkState === false) {
              useMetaWriteRows.push((0, _metaInstance$1.getMetaWriteRow)(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : void 0));
            }
            return _utils$6.PROMISE_RESOLVE_VOID;
          }
          var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {
            _meta: (0, _utils$6.flatClone)(forkStateFullDoc._meta),
            _attachments: {},
            _rev: (0, _utils$6.getDefaultRevision)()
          } : {
            _meta: (0, _utils$6.getDefaultRxDocumentMeta)(),
            _rev: (0, _utils$6.getDefaultRevision)(),
            _attachments: {}
          });
          if (masterState._rev) {
            var nextRevisionHeight = !forkStateFullDoc ? 1 : (0, _utils$6.parseRevision)(forkStateFullDoc._rev).height + 1;
            newForkState._meta[state.input.identifier] = nextRevisionHeight;
          }
          var forkWriteRow = {
            previous: forkStateFullDoc,
            document: newForkState
          };
          forkWriteRow.document._rev = (0, _utils$6.createRevision)(identifierHash, forkWriteRow.previous);
          writeRowsToFork.push(forkWriteRow);
          writeRowsToForkById[docId] = forkWriteRow;
          writeRowsToMeta[docId] = (0, _metaInstance$1.getMetaWriteRow)(state, masterState, assumedMaster ? assumedMaster.metaDocument : void 0);
        }));
      }).then(() => {
        if (writeRowsToFork.length > 0) {
          return state.input.forkInstance.bulkWrite(writeRowsToFork, state.downstreamBulkWriteFlag).then((forkWriteResult) => {
            Object.keys(forkWriteResult.success).forEach((docId) => {
              state.events.processed.down.next(writeRowsToForkById[docId]);
              useMetaWriteRows.push(writeRowsToMeta[docId]);
            });
            Object.values(forkWriteResult.error).forEach((error) => {
              if (error.status === 409) {
                return;
              }
              state.events.error.next((0, _rxError$4.newRxError)("RC_PULL", {
                writeError: error
              }));
            });
          });
        }
      }).then(() => {
        if (useMetaWriteRows.length > 0) {
          return state.input.metaInstance.bulkWrite(useMetaWriteRows, "replication-down-write-meta").then((metaWriteResult) => {
            Object.entries(metaWriteResult.error).forEach(([docId, writeError]) => {
              state.events.error.next((0, _rxError$4.newRxError)("RC_PULL", {
                id: docId,
                writeError
              }));
            });
          });
        }
      }).then(() => {
        state.checkpointQueue = state.checkpointQueue.then(() => (0, _checkpoint$1.setCheckpoint)(state, "down", useCheckpoint));
      });
    }).catch((unhandledError) => state.events.error.next(unhandledError));
    return persistenceQueue;
  }
}
var upstream = {};
var conflicts = {};
Object.defineProperty(conflicts, "__esModule", {
  value: true
});
conflicts.defaultConflictHandler = void 0;
conflicts.resolveConflictError = resolveConflictError;
var _utils$5 = utils;
var defaultConflictHandler = function(i2, _context) {
  if ((0, _utils$5.deepEqual)(i2.newDocumentState, i2.realMasterState)) {
    return Promise.resolve({
      isEqual: true
    });
  }
  return Promise.resolve({
    isEqual: false,
    documentData: i2.realMasterState
  });
};
conflicts.defaultConflictHandler = defaultConflictHandler;
async function resolveConflictError(state, input, forkState) {
  var conflictHandler = state.input.conflictHandler;
  var conflictHandlerOutput = await conflictHandler(input, "replication-resolve-conflict");
  if (conflictHandlerOutput.isEqual) {
    return void 0;
  } else {
    var resolvedDoc = Object.assign({}, conflictHandlerOutput.documentData, {
      /**
       * Because the resolved conflict is written to the fork,
       * we have to keep/update the forks _meta data, not the masters.
       */
      _meta: (0, _utils$5.flatClone)(forkState._meta),
      _rev: (0, _utils$5.getDefaultRevision)(),
      _attachments: (0, _utils$5.flatClone)(forkState._attachments)
    });
    resolvedDoc._meta.lwt = (0, _utils$5.now)();
    resolvedDoc._rev = (0, _utils$5.createRevision)(state.input.identifier, forkState);
    return {
      resolvedDoc,
      output: conflictHandlerOutput
    };
  }
}
Object.defineProperty(upstream, "__esModule", {
  value: true
});
upstream.startReplicationUpstream = startReplicationUpstream;
var _rxjs$2 = cjs;
var _rxStorageHelper$2 = rxStorageHelper;
var _utils$4 = utils;
var _checkpoint = checkpoint;
var _conflicts = conflicts;
var _helper = helper;
var _metaInstance = metaInstance;
async function startReplicationUpstream(state) {
  if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {
    var checkpointDoc = await (0, _checkpoint.getLastCheckpointDoc)(state, "up");
    if (!checkpointDoc) {
      await (0, _checkpoint.setCheckpoint)(state, "up", state.input.initialCheckpoint.upstream);
    }
  }
  var replicationHandler = state.input.replicationHandler;
  state.streamQueue.up = state.streamQueue.up.then(() => {
    return upstreamInitialSync().then(() => {
      processTasks();
    });
  });
  var timer2 = 0;
  var initialSyncStartTime = -1;
  var openTasks = [];
  var sub = state.input.forkInstance.changeStream().pipe((0, _rxjs$2.filter)((eventBulk) => eventBulk.context !== state.downstreamBulkWriteFlag)).subscribe((eventBulk) => {
    state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;
    openTasks.push({
      task: eventBulk,
      time: timer2++
    });
    if (state.input.waitBeforePersist) {
      return state.input.waitBeforePersist().then(() => processTasks());
    } else {
      return processTasks();
    }
  });
  (0, _rxjs$2.firstValueFrom)(state.events.canceled.pipe((0, _rxjs$2.filter)((canceled) => !!canceled))).then(() => sub.unsubscribe());
  async function upstreamInitialSync() {
    state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;
    if (state.events.canceled.getValue()) {
      return;
    }
    state.checkpointQueue = state.checkpointQueue.then(() => (0, _checkpoint.getLastCheckpointDoc)(state, "up"));
    var lastCheckpoint = await state.checkpointQueue;
    var promises = [];
    while (!state.events.canceled.getValue()) {
      initialSyncStartTime = timer2++;
      var upResult = await state.input.forkInstance.getChangedDocumentsSince(state.input.pushBatchSize, lastCheckpoint);
      if (upResult.documents.length === 0) {
        break;
      }
      lastCheckpoint = (0, _rxStorageHelper$2.stackCheckpoints)([lastCheckpoint, upResult.checkpoint]);
      promises.push(persistToMaster(upResult.documents, (0, _utils$4.ensureNotFalsy)(lastCheckpoint)));
    }
    var resolvedPromises = await Promise.all(promises);
    var hadConflicts = resolvedPromises.find((r2) => !!r2);
    if (hadConflicts) {
      await upstreamInitialSync();
    } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {
      state.firstSyncDone.up.next(true);
    }
  }
  function processTasks() {
    if (state.events.canceled.getValue() || openTasks.length === 0) {
      state.events.active.up.next(false);
      return;
    }
    state.stats.up.processTasks = state.stats.up.processTasks + 1;
    state.events.active.up.next(true);
    state.streamQueue.up = state.streamQueue.up.then(() => {
      var docs = [];
      var checkpoint2 = {};
      while (openTasks.length > 0) {
        var taskWithTime = (0, _utils$4.ensureNotFalsy)(openTasks.shift());
        if (taskWithTime.time < initialSyncStartTime) {
          continue;
        }
        (0, _utils$4.appendToArray)(docs, taskWithTime.task.events.map((r2) => {
          return r2.documentData;
        }));
        checkpoint2 = (0, _rxStorageHelper$2.stackCheckpoints)([checkpoint2, taskWithTime.task.checkpoint]);
      }
      var promise = docs.length === 0 ? _utils$4.PROMISE_RESOLVE_FALSE : persistToMaster(docs, checkpoint2);
      return promise.then(() => {
        if (openTasks.length === 0) {
          state.events.active.up.next(false);
        } else {
          processTasks();
        }
      });
    });
  }
  var persistenceQueue = _utils$4.PROMISE_RESOLVE_FALSE;
  var nonPersistedFromMaster = {
    docs: {}
  };
  function persistToMaster(docs, checkpoint2) {
    state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;
    docs.forEach((docData) => {
      var docId = docData[state.primaryPath];
      nonPersistedFromMaster.docs[docId] = docData;
    });
    nonPersistedFromMaster.checkpoint = checkpoint2;
    persistenceQueue = persistenceQueue.then(async () => {
      if (state.events.canceled.getValue()) {
        return false;
      }
      var upDocsById = nonPersistedFromMaster.docs;
      nonPersistedFromMaster.docs = {};
      var useCheckpoint = nonPersistedFromMaster.checkpoint;
      var docIds = Object.keys(upDocsById);
      if (docIds.length === 0) {
        return false;
      }
      var assumedMasterState = await (0, _metaInstance.getAssumedMasterState)(state, docIds);
      var writeRowsToMaster = {};
      var writeRowsToMasterIds = [];
      var writeRowsToMeta = {};
      var forkStateById = {};
      await Promise.all(docIds.map(async (docId) => {
        var fullDocData = upDocsById[docId];
        forkStateById[docId] = fullDocData;
        var docData = (0, _helper.writeDocToDocState)(fullDocData);
        var assumedMasterDoc = assumedMasterState[docId];
        if (assumedMasterDoc && // if the isResolvedConflict is correct, we do not have to compare the documents.
        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && (await state.input.conflictHandler({
          realMasterState: assumedMasterDoc.docData,
          newDocumentState: docData
        }, "upstream-check-if-equal")).isEqual || /**
         * If the master works with _rev fields,
         * we use that to check if our current doc state
         * is different from the assumedMasterDoc.
         */
        assumedMasterDoc && assumedMasterDoc.docData._rev && (0, _utils$4.parseRevision)(fullDocData._rev).height === fullDocData._meta[state.input.identifier]) {
          return;
        }
        writeRowsToMasterIds.push(docId);
        writeRowsToMaster[docId] = {
          assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : void 0,
          newDocumentState: docData
        };
        writeRowsToMeta[docId] = (0, _metaInstance.getMetaWriteRow)(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : void 0);
      }));
      if (writeRowsToMasterIds.length === 0) {
        return false;
      }
      var writeRowsArray = Object.values(writeRowsToMaster);
      var conflictIds = /* @__PURE__ */ new Set();
      var conflictsById = {};
      var writeBatches = (0, _utils$4.batchArray)(writeRowsArray, state.input.pushBatchSize);
      await Promise.all(writeBatches.map(async (writeBatch) => {
        var masterWriteResult = await replicationHandler.masterWrite(writeBatch);
        masterWriteResult.forEach((conflictDoc) => {
          var id = conflictDoc[state.primaryPath];
          conflictIds.add(id);
          conflictsById[id] = conflictDoc;
        });
      }));
      var useWriteRowsToMeta = [];
      writeRowsToMasterIds.forEach((docId) => {
        if (!conflictIds.has(docId)) {
          state.events.processed.up.next(writeRowsToMaster[docId]);
          useWriteRowsToMeta.push(writeRowsToMeta[docId]);
        }
      });
      if (useWriteRowsToMeta.length > 0) {
        await state.input.metaInstance.bulkWrite(useWriteRowsToMeta, "replication-up-write-meta");
      }
      var hadConflictWrites = false;
      if (conflictIds.size > 0) {
        state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;
        var conflictWriteFork = [];
        var conflictWriteMeta = {};
        await Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {
          var writeToMasterRow = writeRowsToMaster[docId];
          var input = {
            newDocumentState: writeToMasterRow.newDocumentState,
            assumedMasterState: writeToMasterRow.assumedMasterState,
            realMasterState
          };
          return (0, _conflicts.resolveConflictError)(state, input, forkStateById[docId]).then((resolved2) => {
            if (resolved2) {
              state.events.resolvedConflicts.next({
                input,
                output: resolved2.output
              });
              conflictWriteFork.push({
                previous: forkStateById[docId],
                document: resolved2.resolvedDoc
              });
              var assumedMasterDoc = assumedMasterState[docId];
              conflictWriteMeta[docId] = (0, _metaInstance.getMetaWriteRow)(state, (0, _utils$4.ensureNotFalsy)(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : void 0, resolved2.resolvedDoc._rev);
            }
          });
        }));
        if (conflictWriteFork.length > 0) {
          hadConflictWrites = true;
          state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;
          var forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork, "replication-up-write-conflict");
          var useMetaWrites = [];
          Object.keys(forkWriteResult.success).forEach((docId) => {
            useMetaWrites.push(conflictWriteMeta[docId]);
          });
          if (useMetaWrites.length > 0) {
            await state.input.metaInstance.bulkWrite(useMetaWrites, "replication-up-write-conflict-meta");
          }
        }
      }
      state.checkpointQueue = state.checkpointQueue.then(() => (0, _checkpoint.setCheckpoint)(state, "up", useCheckpoint));
      return hadConflictWrites;
    }).catch((unhandledError) => {
      state.events.error.next(unhandledError);
      return false;
    });
    return persistenceQueue;
  }
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    replicateRxStorageInstance: true,
    awaitRxStorageReplicationFirstInSync: true,
    awaitRxStorageReplicationInSync: true,
    awaitRxStorageReplicationIdle: true,
    rxStorageInstanceToReplicationHandler: true,
    cancelRxStorageReplication: true
  };
  exports.awaitRxStorageReplicationFirstInSync = awaitRxStorageReplicationFirstInSync;
  exports.awaitRxStorageReplicationIdle = awaitRxStorageReplicationIdle;
  exports.awaitRxStorageReplicationInSync = awaitRxStorageReplicationInSync;
  exports.cancelRxStorageReplication = cancelRxStorageReplication;
  exports.replicateRxStorageInstance = replicateRxStorageInstance;
  exports.rxStorageInstanceToReplicationHandler = rxStorageInstanceToReplicationHandler;
  var _rxjs2 = cjs;
  var _rxSchemaHelper2 = rxSchemaHelper;
  var _utils2 = utils;
  var _checkpoint2 = checkpoint;
  Object.keys(_checkpoint2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _checkpoint2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _checkpoint2[key];
      }
    });
  });
  var _downstream = downstream;
  Object.keys(_downstream).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _downstream[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _downstream[key];
      }
    });
  });
  var _helper2 = helper;
  Object.keys(_helper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _helper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _helper2[key];
      }
    });
  });
  var _upstream = upstream;
  Object.keys(_upstream).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _upstream[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _upstream[key];
      }
    });
  });
  var _metaInstance2 = metaInstance;
  Object.keys(_metaInstance2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _metaInstance2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _metaInstance2[key];
      }
    });
  });
  var _conflicts2 = conflicts;
  Object.keys(_conflicts2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _conflicts2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _conflicts2[key];
      }
    });
  });
  function replicateRxStorageInstance(input) {
    var checkpointKey = (0, _checkpoint2.getCheckpointKey)(input);
    var state = {
      primaryPath: (0, _rxSchemaHelper2.getPrimaryFieldOfPrimaryKey)(input.forkInstance.schema.primaryKey),
      input,
      checkpointKey,
      downstreamBulkWriteFlag: "replication-downstream-" + checkpointKey,
      events: {
        canceled: new _rxjs2.BehaviorSubject(false),
        active: {
          down: new _rxjs2.BehaviorSubject(true),
          up: new _rxjs2.BehaviorSubject(true)
        },
        processed: {
          down: new _rxjs2.Subject(),
          up: new _rxjs2.Subject()
        },
        resolvedConflicts: new _rxjs2.Subject(),
        error: new _rxjs2.Subject()
      },
      stats: {
        down: {
          addNewTask: 0,
          downstreamProcessChanges: 0,
          downstreamResyncOnce: 0,
          masterChangeStreamEmit: 0,
          persistFromMaster: 0
        },
        up: {
          forkChangeStreamEmit: 0,
          persistToMaster: 0,
          persistToMasterConflictWrites: 0,
          persistToMasterHadConflicts: 0,
          processTasks: 0,
          upstreamInitialSync: 0
        }
      },
      firstSyncDone: {
        down: new _rxjs2.BehaviorSubject(false),
        up: new _rxjs2.BehaviorSubject(false)
      },
      streamQueue: {
        down: _utils2.PROMISE_RESOLVE_VOID,
        up: _utils2.PROMISE_RESOLVE_VOID
      },
      checkpointQueue: _utils2.PROMISE_RESOLVE_VOID,
      lastCheckpointDoc: {}
    };
    (0, _downstream.startReplicationDownstream)(state);
    (0, _upstream.startReplicationUpstream)(state);
    return state;
  }
  function awaitRxStorageReplicationFirstInSync(state) {
    return (0, _rxjs2.firstValueFrom)((0, _rxjs2.combineLatest)([state.firstSyncDone.down.pipe((0, _rxjs2.filter)((v2) => !!v2)), state.firstSyncDone.up.pipe((0, _rxjs2.filter)((v2) => !!v2))])).then(() => {
    });
  }
  function awaitRxStorageReplicationInSync(replicationState) {
    return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);
  }
  async function awaitRxStorageReplicationIdle(state) {
    await awaitRxStorageReplicationFirstInSync(state);
    while (true) {
      var {
        down,
        up
      } = state.streamQueue;
      await Promise.all([up, down]);
      if (down === state.streamQueue.down && up === state.streamQueue.up) {
        return;
      }
    }
  }
  function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken) {
    var primaryPath = (0, _rxSchemaHelper2.getPrimaryFieldOfPrimaryKey)(instance.schema.primaryKey);
    var replicationHandler = {
      masterChangeStream$: instance.changeStream().pipe((0, _rxjs2.map)((eventBulk) => {
        var ret = {
          checkpoint: eventBulk.checkpoint,
          documents: eventBulk.events.map((event) => {
            return (0, _helper2.writeDocToDocState)((0, _utils2.ensureNotFalsy)(event.documentData));
          })
        };
        return ret;
      })),
      masterChangesSince(checkpoint2, batchSize) {
        return instance.getChangedDocumentsSince(batchSize, checkpoint2).then((result) => {
          return {
            checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint2,
            documents: result.documents.map((d2) => (0, _helper2.writeDocToDocState)(d2))
          };
        });
      },
      async masterWrite(rows) {
        var rowById = {};
        rows.forEach((row) => {
          var docId = row.newDocumentState[primaryPath];
          rowById[docId] = row;
        });
        var ids = Object.keys(rowById);
        var masterDocsState = await instance.findDocumentsById(ids, true);
        var conflicts2 = [];
        var writeRows = [];
        await Promise.all(Object.entries(rowById).map(async ([id, row]) => {
          var masterState = masterDocsState[id];
          if (!masterState) {
            writeRows.push({
              document: (0, _helper2.docStateToWriteDoc)(databaseInstanceToken, row.newDocumentState)
            });
          } else if (masterState && !row.assumedMasterState) {
            conflicts2.push((0, _helper2.writeDocToDocState)(masterState));
          } else if ((await conflictHandler({
            realMasterState: (0, _helper2.writeDocToDocState)(masterState),
            newDocumentState: (0, _utils2.ensureNotFalsy)(row.assumedMasterState)
          }, "rxStorageInstanceToReplicationHandler-masterWrite")).isEqual === true) {
            writeRows.push({
              previous: masterState,
              document: (0, _helper2.docStateToWriteDoc)(databaseInstanceToken, row.newDocumentState, masterState)
            });
          } else {
            conflicts2.push((0, _helper2.writeDocToDocState)(masterState));
          }
        }));
        if (writeRows.length > 0) {
          var result = await instance.bulkWrite(writeRows, "replication-master-write");
          Object.values(result.error).forEach((err) => {
            if (err.status !== 409) {
              throw new Error("non conflict error");
            } else {
              conflicts2.push((0, _helper2.writeDocToDocState)((0, _utils2.ensureNotFalsy)(err.documentInDb)));
            }
          });
        }
        return conflicts2;
      }
    };
    return replicationHandler;
  }
  function cancelRxStorageReplication(replicationState) {
    replicationState.events.canceled.next(true);
    replicationState.events.active.up.complete();
    replicationState.events.active.down.complete();
    replicationState.events.processed.up.complete();
    replicationState.events.processed.down.complete();
    replicationState.events.resolvedConflicts.complete();
    replicationState.events.canceled.complete();
  }
})(replicationProtocol);
var _interopRequireDefault$2 = interopRequireDefaultExports$1;
Object.defineProperty(rxCollection, "__esModule", {
  value: true
});
rxCollection.RxCollectionBase = void 0;
rxCollection.createRxCollection = createRxCollection;
rxCollection.isRxCollection = isRxCollection;
var _createClass2$1 = _interopRequireDefault$2(requireCreateClass());
var _operators$2 = operators;
var _utils$3 = utils;
var _rxCollectionHelper$1 = rxCollectionHelper;
var _rxQuery$1 = rxQuery;
var _rxError$3 = rxError;
var _docCache = requireDocCache();
var _queryCache = queryCache;
var _changeEventBuffer = requireChangeEventBuffer();
var _hooks$2 = hooks;
var _rxDocumentPrototypeMerge = rxDocumentPrototypeMerge;
var _rxStorageHelper$1 = rxStorageHelper;
var _replicationProtocol = replicationProtocol;
var _incrementalWrite = incrementalWrite;
var _rxDocument$1 = rxDocument;
var _overwritable$2 = overwritable$1;
var HOOKS_WHEN = ["pre", "post"];
var HOOKS_KEYS = ["insert", "save", "remove", "create"];
var hooksApplied = false;
var RxCollectionBase = /* @__PURE__ */ function() {
  function RxCollectionBase2(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options2 = {}, cacheReplacementPolicy = _queryCache.defaultCacheReplacementPolicy, statics = {}, conflictHandler = _replicationProtocol.defaultConflictHandler) {
    this.storageInstance = {};
    this.timeouts = /* @__PURE__ */ new Set();
    this.incrementalWriteQueue = {};
    this._incrementalUpsertQueues = /* @__PURE__ */ new Map();
    this.synced = false;
    this.hooks = {};
    this._subs = [];
    this._docCache = {};
    this._queryCache = (0, _queryCache.createQueryCache)();
    this.$ = {};
    this.checkpoint$ = {};
    this._changeEventBuffer = {};
    this.onDestroy = [];
    this.destroyed = false;
    this.database = database;
    this.name = name;
    this.schema = schema;
    this.internalStorageInstance = internalStorageInstance;
    this.instanceCreationOptions = instanceCreationOptions;
    this.migrationStrategies = migrationStrategies;
    this.methods = methods;
    this.attachments = attachments;
    this.options = options2;
    this.cacheReplacementPolicy = cacheReplacementPolicy;
    this.statics = statics;
    this.conflictHandler = conflictHandler;
    _applyHookFunctions(this.asRxCollection);
  }
  var _proto = RxCollectionBase2.prototype;
  _proto.prepare = async function prepare() {
    this.storageInstance = (0, _rxStorageHelper$1.getWrappedStorageInstance)(this.database, this.internalStorageInstance, this.schema.jsonSchema);
    this.incrementalWriteQueue = new _incrementalWrite.IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => (0, _rxDocument$1.beforeDocumentUpdateWrite)(this, newData, oldData), (result) => this._runHooks("post", "save", result));
    var collectionEventBulks$ = this.database.eventBulks$.pipe((0, _operators$2.filter)((changeEventBulk) => changeEventBulk.collectionName === this.name));
    this.$ = collectionEventBulks$.pipe((0, _operators$2.mergeMap)((changeEventBulk) => changeEventBulk.events));
    this.checkpoint$ = collectionEventBulks$.pipe((0, _operators$2.map)((changeEventBulk) => changeEventBulk.checkpoint));
    this._changeEventBuffer = (0, _changeEventBuffer.createChangeEventBuffer)(this.asRxCollection);
    this._docCache = new _docCache.DocumentCache(this.schema.primaryPath, this.$.pipe((0, _operators$2.filter)((cE) => !cE.isLocal)), (docData) => (0, _rxDocumentPrototypeMerge.createNewRxDocument)(this.asRxCollection, docData));
    var databaseStorageToken = await this.database.storageToken;
    var subDocs = this.storageInstance.changeStream().subscribe((eventBulk) => {
      var changeEventBulk = {
        id: eventBulk.id,
        internal: false,
        collectionName: this.name,
        storageToken: databaseStorageToken,
        events: eventBulk.events.map((ev) => (0, _rxStorageHelper$1.storageChangeEventToRxChangeEvent)(false, ev, this)),
        databaseToken: this.database.token,
        checkpoint: eventBulk.checkpoint,
        context: eventBulk.context
      };
      this.database.$emit(changeEventBulk);
    });
    this._subs.push(subDocs);
    this._subs.push(this.storageInstance.conflictResultionTasks().subscribe((task) => {
      this.conflictHandler(task.input, task.context).then((output) => {
        this.storageInstance.resolveConflictResultionTask({
          id: task.id,
          output
        });
      });
    }));
    return _utils$3.PROMISE_RESOLVE_VOID;
  };
  _proto.migrationNeeded = function migrationNeeded() {
    throw (0, _utils$3.pluginMissing)("migration");
  };
  _proto.getDataMigrator = function getDataMigrator() {
    throw (0, _utils$3.pluginMissing)("migration");
  };
  _proto.migrate = function migrate(batchSize = 10) {
    return this.getDataMigrator().migrate(batchSize);
  };
  _proto.migratePromise = function migratePromise(batchSize = 10) {
    return this.getDataMigrator().migratePromise(batchSize);
  };
  _proto.insert = async function insert(json) {
    var writeResult = await this.bulkInsert([json]);
    var isError = writeResult.error[0];
    (0, _rxStorageHelper$1.throwIfIsStorageWriteError)(this, json[this.schema.primaryPath], json, isError);
    var insertResult = (0, _utils$3.ensureNotFalsy)(writeResult.success[0]);
    return insertResult;
  };
  _proto.bulkInsert = async function bulkInsert(docsData) {
    if (docsData.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var primaryPath = this.schema.primaryPath;
    var useDocs = docsData.map((docData) => {
      var useDocData = (0, _rxCollectionHelper$1.fillObjectDataBeforeInsert)(this.schema, docData);
      return useDocData;
    });
    var docs = this.hasHooks("pre", "insert") ? await Promise.all(useDocs.map((doc) => {
      return this._runHooks("pre", "insert", doc).then(() => {
        return doc;
      });
    })) : useDocs;
    var docsMap = /* @__PURE__ */ new Map();
    var insertRows = docs.map((doc) => {
      docsMap.set(doc[primaryPath], doc);
      var row = {
        document: doc
      };
      return row;
    });
    var results = await this.storageInstance.bulkWrite(insertRows, "rx-collection-bulk-insert");
    var rxDocuments = Object.values(results.success).map((writtenDocData) => this._docCache.getCachedRxDocument(writtenDocData));
    if (this.hasHooks("post", "insert")) {
      await Promise.all(rxDocuments.map((doc) => {
        return this._runHooks("post", "insert", docsMap.get(doc.primary), doc);
      }));
    }
    return {
      success: rxDocuments,
      error: Object.values(results.error)
    };
  };
  _proto.bulkRemove = async function bulkRemove(ids) {
    if (ids.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var rxDocumentMap = await this.findByIds(ids).exec();
    var docsData = [];
    var docsMap = /* @__PURE__ */ new Map();
    Array.from(rxDocumentMap.values()).forEach((rxDocument2) => {
      var data = rxDocument2.toMutableJSON(true);
      docsData.push(data);
      docsMap.set(rxDocument2.primary, data);
    });
    await Promise.all(docsData.map((doc) => {
      var primary = doc[this.schema.primaryPath];
      return this._runHooks("pre", "remove", doc, rxDocumentMap.get(primary));
    }));
    var removeDocs = docsData.map((doc) => {
      var writeDoc = (0, _utils$3.flatClone)(doc);
      writeDoc._deleted = true;
      return {
        previous: doc,
        document: writeDoc
      };
    });
    var results = await this.storageInstance.bulkWrite(removeDocs, "rx-collection-bulk-remove");
    var successIds = Object.keys(results.success);
    await Promise.all(successIds.map((id) => {
      return this._runHooks("post", "remove", docsMap.get(id), rxDocumentMap.get(id));
    }));
    var rxDocuments = successIds.map((id) => (0, _utils$3.getFromMapOrThrow)(rxDocumentMap, id));
    return {
      success: rxDocuments,
      error: Object.values(results.error)
    };
  };
  _proto.bulkUpsert = async function bulkUpsert(docsData) {
    var insertData = [];
    var useJsonByDocId = /* @__PURE__ */ new Map();
    docsData.forEach((docData) => {
      var useJson = (0, _rxCollectionHelper$1.fillObjectDataBeforeInsert)(this.schema, docData);
      var primary = useJson[this.schema.primaryPath];
      if (!primary) {
        throw (0, _rxError$3.newRxError)("COL3", {
          primaryPath: this.schema.primaryPath,
          data: useJson,
          schema: this.schema.jsonSchema
        });
      }
      useJsonByDocId.set(primary, useJson);
      insertData.push(useJson);
    });
    var insertResult = await this.bulkInsert(insertData);
    var ret = insertResult.success.slice(0);
    var updatedDocs = await Promise.all(insertResult.error.map(async (error) => {
      if (error.status !== 409) {
        throw (0, _rxError$3.newRxError)("VD2", {
          collection: this.name,
          writeError: error
        });
      }
      var id = error.documentId;
      var writeData = (0, _utils$3.getFromMapOrThrow)(useJsonByDocId, id);
      var docDataInDb = (0, _utils$3.ensureNotFalsy)(error.documentInDb);
      var doc = this._docCache.getCachedRxDocument(docDataInDb);
      var newDoc = await doc.incrementalModify(() => writeData);
      return newDoc;
    }));
    (0, _utils$3.appendToArray)(ret, updatedDocs);
    return ret;
  };
  _proto.upsert = function upsert(json) {
    return this.bulkUpsert([json]).then((result) => result[0]);
  };
  _proto.incrementalUpsert = function incrementalUpsert(json) {
    var useJson = (0, _rxCollectionHelper$1.fillObjectDataBeforeInsert)(this.schema, json);
    var primary = useJson[this.schema.primaryPath];
    if (!primary) {
      throw (0, _rxError$3.newRxError)("COL4", {
        data: json
      });
    }
    var queue2 = this._incrementalUpsertQueues.get(primary);
    if (!queue2) {
      queue2 = _utils$3.PROMISE_RESOLVE_VOID;
    }
    queue2 = queue2.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then((wasInserted) => {
      if (!wasInserted.inserted) {
        return _incrementalUpsertUpdate(wasInserted.doc, useJson);
      } else {
        return wasInserted.doc;
      }
    });
    this._incrementalUpsertQueues.set(primary, queue2);
    return queue2;
  };
  _proto.find = function find2(queryObj) {
    if (typeof queryObj === "string") {
      throw (0, _rxError$3.newRxError)("COL5", {
        queryObj
      });
    }
    if (!queryObj) {
      queryObj = (0, _rxQuery$1._getDefaultQuery)();
    }
    var query2 = (0, _rxQuery$1.createRxQuery)("find", queryObj, this);
    return query2;
  };
  _proto.findOne = function findOne(queryObj) {
    var query2;
    if (typeof queryObj === "string") {
      query2 = (0, _rxQuery$1.createRxQuery)("findOne", {
        selector: {
          [this.schema.primaryPath]: queryObj
        },
        limit: 1
      }, this);
    } else {
      if (!queryObj) {
        queryObj = (0, _rxQuery$1._getDefaultQuery)();
      }
      if (queryObj.limit) {
        throw (0, _rxError$3.newRxError)("QU6");
      }
      queryObj.limit = 1;
      query2 = (0, _rxQuery$1.createRxQuery)("findOne", queryObj, this);
    }
    if (typeof queryObj === "number" || Array.isArray(queryObj)) {
      throw (0, _rxError$3.newRxTypeError)("COL6", {
        queryObj
      });
    }
    return query2;
  };
  _proto.count = function count2(queryObj) {
    if (!queryObj) {
      queryObj = (0, _rxQuery$1._getDefaultQuery)();
    }
    var query2 = (0, _rxQuery$1.createRxQuery)("count", queryObj, this);
    return query2;
  };
  _proto.findByIds = function findByIds(ids) {
    var mangoQuery = {
      selector: {
        [this.schema.primaryPath]: {
          $in: ids.slice(0)
        }
      }
    };
    var query2 = (0, _rxQuery$1.createRxQuery)("findByIds", mangoQuery, this);
    return query2;
  };
  _proto.exportJSON = function exportJSON() {
    throw (0, _utils$3.pluginMissing)("json-dump");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw (0, _utils$3.pluginMissing)("json-dump");
  };
  _proto.insertCRDT = function insertCRDT(_updateObj) {
    throw (0, _utils$3.pluginMissing)("crdt");
  };
  _proto.addHook = function addHook(when, key, fun, parallel = false) {
    if (typeof fun !== "function") {
      throw (0, _rxError$3.newRxTypeError)("COL7", {
        key,
        when
      });
    }
    if (!HOOKS_WHEN.includes(when)) {
      throw (0, _rxError$3.newRxTypeError)("COL8", {
        key,
        when
      });
    }
    if (!HOOKS_KEYS.includes(key)) {
      throw (0, _rxError$3.newRxError)("COL9", {
        key
      });
    }
    if (when === "post" && key === "create" && parallel === true) {
      throw (0, _rxError$3.newRxError)("COL10", {
        when,
        key,
        parallel
      });
    }
    var boundFun = fun.bind(this);
    var runName = parallel ? "parallel" : "series";
    this.hooks[key] = this.hooks[key] || {};
    this.hooks[key][when] = this.hooks[key][when] || {
      series: [],
      parallel: []
    };
    this.hooks[key][when][runName].push(boundFun);
  };
  _proto.getHooks = function getHooks(when, key) {
    if (!this.hooks[key] || !this.hooks[key][when]) {
      return {
        series: [],
        parallel: []
      };
    }
    return this.hooks[key][when];
  };
  _proto.hasHooks = function hasHooks(when, key) {
    var hooks2 = this.getHooks(when, key);
    if (!hooks2) {
      return false;
    }
    return hooks2.series.length > 0 || hooks2.parallel.length > 0;
  };
  _proto._runHooks = function _runHooks(when, key, data, instance) {
    var hooks2 = this.getHooks(when, key);
    if (!hooks2) {
      return _utils$3.PROMISE_RESOLVE_VOID;
    }
    var tasks = hooks2.series.map((hook) => () => hook(data, instance));
    return (0, _utils$3.promiseSeries)(tasks).then(() => Promise.all(hooks2.parallel.map((hook) => hook(data, instance))));
  };
  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {
    var hooks2 = this.getHooks(when, key);
    if (!hooks2)
      return;
    hooks2.series.forEach((hook) => hook(data, instance));
  };
  _proto.promiseWait = function promiseWait2(time) {
    var ret = new Promise((res) => {
      var timeout2 = setTimeout(() => {
        this.timeouts.delete(timeout2);
        res();
      }, time);
      this.timeouts.add(timeout2);
    });
    return ret;
  };
  _proto.destroy = function destroy() {
    if (this.destroyed) {
      return _utils$3.PROMISE_RESOLVE_FALSE;
    }
    this.destroyed = true;
    Array.from(this.timeouts).forEach((timeout2) => clearTimeout(timeout2));
    if (this._changeEventBuffer) {
      this._changeEventBuffer.destroy();
    }
    return this.database.requestIdlePromise().then(() => Promise.all(this.onDestroy.map((fn2) => fn2()))).then(() => this.storageInstance.close()).then(() => {
      this._subs.forEach((sub) => sub.unsubscribe());
      delete this.database.collections[this.name];
      return (0, _hooks$2.runAsyncPluginHooks)("postDestroyRxCollection", this).then(() => true);
    });
  };
  _proto.remove = async function remove() {
    await this.destroy();
    await (0, _rxCollectionHelper$1.removeCollectionStorages)(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.hashFunction);
  };
  (0, _createClass2$1.default)(RxCollectionBase2, [{
    key: "insert$",
    get: function() {
      return this.$.pipe((0, _operators$2.filter)((cE) => cE.operation === "INSERT"));
    }
  }, {
    key: "update$",
    get: function() {
      return this.$.pipe((0, _operators$2.filter)((cE) => cE.operation === "UPDATE"));
    }
  }, {
    key: "remove$",
    get: function() {
      return this.$.pipe((0, _operators$2.filter)((cE) => cE.operation === "DELETE"));
    }
    // defaults
    /**
     * When the collection is destroyed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
     */
  }, {
    key: "asRxCollection",
    get: function() {
      return this;
    }
  }]);
  return RxCollectionBase2;
}();
rxCollection.RxCollectionBase = RxCollectionBase;
function _applyHookFunctions(collection) {
  if (hooksApplied)
    return;
  hooksApplied = true;
  var colProto = Object.getPrototypeOf(collection);
  HOOKS_KEYS.forEach((key) => {
    HOOKS_WHEN.map((when) => {
      var fnName = when + (0, _utils$3.ucfirst)(key);
      colProto[fnName] = function(fun, parallel) {
        return this.addHook(when, key, fun, parallel);
      };
    });
  });
}
function _incrementalUpsertUpdate(doc, json) {
  return doc.incrementalModify((_innerDoc) => {
    return json;
  });
}
function _incrementalUpsertEnsureRxDocumentExists(rxCollection2, primary, json) {
  var docDataFromCache = rxCollection2._docCache.getLatestDocumentDataIfExists(primary);
  if (docDataFromCache) {
    return Promise.resolve({
      doc: rxCollection2._docCache.getCachedRxDocument(docDataFromCache),
      inserted: false
    });
  }
  return rxCollection2.findOne(primary).exec().then((doc) => {
    if (!doc) {
      return rxCollection2.insert(json).then((newDoc) => ({
        doc: newDoc,
        inserted: true
      }));
    } else {
      return {
        doc,
        inserted: false
      };
    }
  });
}
function createRxCollection({
  database,
  name,
  schema,
  instanceCreationOptions = {},
  migrationStrategies = {},
  autoMigrate = true,
  statics = {},
  methods = {},
  attachments = {},
  options: options2 = {},
  localDocuments = false,
  cacheReplacementPolicy = _queryCache.defaultCacheReplacementPolicy,
  conflictHandler = _replicationProtocol.defaultConflictHandler
}) {
  var storageInstanceCreationParams = {
    databaseInstanceToken: database.token,
    databaseName: database.name,
    collectionName: name,
    schema: schema.jsonSchema,
    options: instanceCreationOptions,
    multiInstance: database.multiInstance,
    password: database.password,
    devMode: _overwritable$2.overwritable.isDevMode()
  };
  (0, _hooks$2.runPluginHooks)("preCreateRxStorageInstance", storageInstanceCreationParams);
  return (0, _rxCollectionHelper$1.createRxCollectionStorageInstance)(database, storageInstanceCreationParams).then((storageInstance) => {
    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options2, cacheReplacementPolicy, statics, conflictHandler);
    return collection.prepare().then(() => {
      Object.entries(statics).forEach(([funName, fun]) => {
        Object.defineProperty(collection, funName, {
          get: () => fun.bind(collection)
        });
      });
      var ret = _utils$3.PROMISE_RESOLVE_VOID;
      if (autoMigrate && collection.schema.version !== 0) {
        ret = collection.migratePromise();
      }
      return ret;
    }).then(() => {
      (0, _hooks$2.runPluginHooks)("createRxCollection", {
        collection,
        creator: {
          name,
          schema,
          storageInstance,
          instanceCreationOptions,
          migrationStrategies,
          methods,
          attachments,
          options: options2,
          cacheReplacementPolicy,
          localDocuments,
          statics
        }
      });
      return collection;
    }).catch((err) => {
      return storageInstance.close().then(() => Promise.reject(err));
    });
  });
}
function isRxCollection(obj) {
  return obj instanceof RxCollectionBase;
}
var rxDatabase = {};
var IdleQueue = function IdleQueue2() {
  var parallels = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
  this._parallels = parallels || 1;
  this._qC = 0;
  this._iC = /* @__PURE__ */ new Set();
  this._lHN = 0;
  this._hPM = /* @__PURE__ */ new Map();
  this._pHM = /* @__PURE__ */ new Map();
};
IdleQueue.prototype = {
  isIdle: function isIdle() {
    return this._qC < this._parallels;
  },
  /**
   * creates a lock in the queue
   * and returns an unlock-function to remove the lock from the queue
   * @return {function} unlock function than must be called afterwards
   */
  lock: function lock() {
    this._qC++;
  },
  unlock: function unlock() {
    this._qC--;
    _tryIdleCall(this);
  },
  /**
   * wraps a function with lock/unlock and runs it
   * @param  {function}  fun
   * @return {Promise<any>}
   */
  wrapCall: function wrapCall(fun) {
    var _this = this;
    this.lock();
    var maybePromise;
    try {
      maybePromise = fun();
    } catch (err) {
      this.unlock();
      throw err;
    }
    if (!maybePromise.then || typeof maybePromise.then !== "function") {
      this.unlock();
      return maybePromise;
    } else {
      return maybePromise.then(function(ret) {
        _this.unlock();
        return ret;
      })["catch"](function(err) {
        _this.unlock();
        throw err;
      });
    }
  },
  /**
   * does the same as requestIdleCallback() but uses promises instead of the callback
   * @param {{timeout?: number}} options like timeout
   * @return {Promise<void>} promise that resolves when the database is in idle-mode
   */
  requestIdlePromise: function requestIdlePromise2(options2) {
    var _this2 = this;
    options2 = options2 || {};
    var resolve;
    var prom = new Promise(function(res) {
      return resolve = res;
    });
    var resolveFromOutside = function resolveFromOutside2() {
      _removeIdlePromise(_this2, prom);
      resolve();
    };
    prom._manRes = resolveFromOutside;
    if (options2.timeout) {
      var timeoutObj = setTimeout(function() {
        prom._manRes();
      }, options2.timeout);
      prom._timeoutObj = timeoutObj;
    }
    this._iC.add(prom);
    _tryIdleCall(this);
    return prom;
  },
  /**
   * remove the promise so it will never be resolved
   * @param  {Promise} promise from requestIdlePromise()
   * @return {void}
   */
  cancelIdlePromise: function cancelIdlePromise(promise) {
    _removeIdlePromise(this, promise);
  },
  /**
   * api equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback
   * @param  {Function} callback
   * @param  {options}   options  [description]
   * @return {number} handle which can be used with cancelIdleCallback()
   */
  requestIdleCallback: function requestIdleCallback2(callback, options2) {
    var handle = this._lHN++;
    var promise = this.requestIdlePromise(options2);
    this._hPM.set(handle, promise);
    this._pHM.set(promise, handle);
    promise.then(function() {
      return callback();
    });
    return handle;
  },
  /**
   * API equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback
   * @param  {number} handle returned from requestIdleCallback()
   * @return {void}
   */
  cancelIdleCallback: function cancelIdleCallback(handle) {
    var promise = this._hPM.get(handle);
    this.cancelIdlePromise(promise);
  },
  /**
   * clears and resets everything
   * @return {void}
   */
  clear: function clear() {
    var _this3 = this;
    this._iC.forEach(function(promise) {
      return _removeIdlePromise(_this3, promise);
    });
    this._qC = 0;
    this._iC.clear();
    this._hPM = /* @__PURE__ */ new Map();
    this._pHM = /* @__PURE__ */ new Map();
  }
};
function _resolveOneIdleCall(idleQueue) {
  if (idleQueue._iC.size === 0)
    return;
  var iterator2 = idleQueue._iC.values();
  var oldestPromise = iterator2.next().value;
  oldestPromise._manRes();
  setTimeout(function() {
    return _tryIdleCall(idleQueue);
  }, 0);
}
function _removeIdlePromise(idleQueue, promise) {
  if (!promise)
    return;
  if (promise._timeoutObj)
    clearTimeout(promise._timeoutObj);
  if (idleQueue._pHM.has(promise)) {
    var handle = idleQueue._pHM.get(promise);
    idleQueue._hPM["delete"](handle);
    idleQueue._pHM["delete"](promise);
  }
  idleQueue._iC["delete"](promise);
}
function _tryIdleCall(idleQueue) {
  if (idleQueue._tryIR || idleQueue._iC.size === 0)
    return;
  idleQueue._tryIR = true;
  setTimeout(function() {
    if (!idleQueue.isIdle()) {
      idleQueue._tryIR = false;
      return;
    }
    setTimeout(function() {
      if (!idleQueue.isIdle()) {
        idleQueue._tryIR = false;
        return;
      }
      _resolveOneIdleCall(idleQueue);
      idleQueue._tryIR = false;
    }, 0);
  }, 0);
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IdleQueue
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(es);
var _interopRequireDefault$1 = interopRequireDefaultExports$1;
Object.defineProperty(rxDatabase, "__esModule", {
  value: true
});
rxDatabase.RxDatabaseBase = void 0;
rxDatabase.createRxDatabase = createRxDatabase;
rxDatabase.createRxDatabaseStorageInstance = createRxDatabaseStorageInstance;
rxDatabase.dbCount = dbCount;
rxDatabase.ensureNoStartupErrors = ensureNoStartupErrors;
rxDatabase.isRxDatabase = isRxDatabase;
rxDatabase.isRxDatabaseFirstTimeInstantiated = isRxDatabaseFirstTimeInstantiated;
rxDatabase.removeRxDatabase = removeRxDatabase;
var _createClass2 = _interopRequireDefault$1(requireCreateClass());
var _customIdleQueue = require$$2;
var _utils$2 = utils;
var _rxError$2 = rxError;
var _rxSchema$1 = rxSchema;
var _hooks$1 = hooks;
var _rxjs$1 = cjs;
var _operators$1 = operators;
var _rxCollection$1 = rxCollection;
var _rxStorageHelper = rxStorageHelper;
var _obliviousSet = require$$11;
var _rxDatabaseInternalStore = rxDatabaseInternalStore;
var _rxCollectionHelper = rxCollectionHelper;
var _overwritable$1 = overwritable$1;
var USED_DATABASE_NAMES = /* @__PURE__ */ new Set();
var DB_COUNT = 0;
var RxDatabaseBase = /* @__PURE__ */ function() {
  function RxDatabaseBase2(name, token, storage, instanceCreationOptions, password, multiInstance, eventReduce2 = false, options2 = {}, internalStore, hashFunction, cleanupPolicy, allowSlowCount) {
    this.idleQueue = new _customIdleQueue.IdleQueue();
    this.storageInstances = /* @__PURE__ */ new Set();
    this._subs = [];
    this.startupErrors = [];
    this.onDestroy = [];
    this.destroyed = false;
    this.collections = {};
    this.eventBulks$ = new _rxjs$1.Subject();
    this.observable$ = this.eventBulks$.pipe((0, _operators$1.mergeMap)((changeEventBulk) => changeEventBulk.events));
    this.storageToken = _utils$2.PROMISE_RESOLVE_FALSE;
    this.storageTokenDocument = _utils$2.PROMISE_RESOLVE_FALSE;
    this.emittedEventBulkIds = new _obliviousSet.ObliviousSet(60 * 1e3);
    this.name = name;
    this.token = token;
    this.storage = storage;
    this.instanceCreationOptions = instanceCreationOptions;
    this.password = password;
    this.multiInstance = multiInstance;
    this.eventReduce = eventReduce2;
    this.options = options2;
    this.internalStore = internalStore;
    this.hashFunction = hashFunction;
    this.cleanupPolicy = cleanupPolicy;
    this.allowSlowCount = allowSlowCount;
    DB_COUNT++;
    if (this.name !== "pseudoInstance") {
      this.internalStore = (0, _rxStorageHelper.getWrappedStorageInstance)(this.asRxDatabase, internalStore, _rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA);
      this.storageTokenDocument = (0, _rxDatabaseInternalStore.ensureStorageTokenDocumentExists)(this.asRxDatabase).catch((err) => this.startupErrors.push(err));
      this.storageToken = this.storageTokenDocument.then((doc) => doc.data.token).catch((err) => this.startupErrors.push(err));
    }
  }
  var _proto = RxDatabaseBase2.prototype;
  _proto.$emit = function $emit(changeEventBulk) {
    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {
      return;
    }
    this.emittedEventBulkIds.add(changeEventBulk.id);
    this.eventBulks$.next(changeEventBulk);
  };
  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {
    var doc = await (0, _rxStorageHelper.getSingleDocument)(this.internalStore, (0, _rxDatabaseInternalStore.getPrimaryKeyOfInternalDocument)((0, _rxDatabaseInternalStore._collectionNamePrimary)(name, schema), _rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION));
    if (!doc) {
      throw (0, _rxError$2.newRxError)("SNH", {
        name,
        schema
      });
    }
    var writeDoc = (0, _rxStorageHelper.flatCloneDocWithMeta)(doc);
    writeDoc._deleted = true;
    await this.internalStore.bulkWrite([{
      document: writeDoc,
      previous: doc
    }], "rx-database-remove-collection");
  };
  _proto.addCollections = async function addCollections(collectionCreators) {
    var jsonSchemas = {};
    var schemas = {};
    var bulkPutDocs = [];
    var useArgsByCollectionName = {};
    Object.entries(collectionCreators).forEach(([name, args2]) => {
      var collectionName = name;
      var rxJsonSchema = args2.schema;
      jsonSchemas[collectionName] = rxJsonSchema;
      var schema = (0, _rxSchema$1.createRxSchema)(rxJsonSchema, this.hashFunction);
      schemas[collectionName] = schema;
      if (this.collections[name]) {
        throw (0, _rxError$2.newRxError)("DB3", {
          name
        });
      }
      var collectionNameWithVersion = (0, _rxDatabaseInternalStore._collectionNamePrimary)(name, rxJsonSchema);
      var collectionDocData = {
        id: (0, _rxDatabaseInternalStore.getPrimaryKeyOfInternalDocument)(collectionNameWithVersion, _rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION),
        key: collectionNameWithVersion,
        context: _rxDatabaseInternalStore.INTERNAL_CONTEXT_COLLECTION,
        data: {
          name: collectionName,
          schemaHash: schema.hash,
          schema: schema.jsonSchema,
          version: schema.version,
          connectedStorages: []
        },
        _deleted: false,
        _meta: (0, _utils$2.getDefaultRxDocumentMeta)(),
        _rev: (0, _utils$2.getDefaultRevision)(),
        _attachments: {}
      };
      bulkPutDocs.push({
        document: collectionDocData
      });
      var useArgs = Object.assign({}, args2, {
        name: collectionName,
        schema,
        database: this
      });
      var hookData = (0, _utils$2.flatClone)(args2);
      hookData.database = this;
      hookData.name = name;
      (0, _hooks$1.runPluginHooks)("preCreateRxCollection", hookData);
      useArgs.conflictHandler = hookData.conflictHandler;
      useArgsByCollectionName[collectionName] = useArgs;
    });
    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, "rx-database-add-collection");
    await ensureNoStartupErrors(this);
    Object.entries(putDocsResult.error).forEach(([_id, error]) => {
      if (error.status !== 409) {
        throw (0, _rxError$2.newRxError)("DB12", {
          database: this.name,
          writeError: error
        });
      }
      var docInDb = (0, _utils$2.ensureNotFalsy)(error.documentInDb);
      var collectionName = docInDb.data.name;
      var schema = schemas[collectionName];
      if (docInDb.data.schemaHash !== schema.hash) {
        throw (0, _rxError$2.newRxError)("DB6", {
          database: this.name,
          collection: collectionName,
          previousSchemaHash: docInDb.data.schemaHash,
          schemaHash: schema.hash,
          previousSchema: docInDb.data.schema,
          schema: (0, _utils$2.ensureNotFalsy)(jsonSchemas[collectionName])
        });
      }
    });
    var ret = {};
    await Promise.all(Object.keys(collectionCreators).map(async (collectionName) => {
      var useArgs = useArgsByCollectionName[collectionName];
      var collection = await (0, _rxCollection$1.createRxCollection)(useArgs);
      ret[collectionName] = collection;
      this.collections[collectionName] = collection;
      if (!this[collectionName]) {
        Object.defineProperty(this, collectionName, {
          get: () => this.collections[collectionName]
        });
      }
    }));
    return ret;
  };
  _proto.lockedRun = function lockedRun(fn2) {
    return this.idleQueue.wrapCall(fn2);
  };
  _proto.requestIdlePromise = function requestIdlePromise3() {
    return this.idleQueue.requestIdlePromise();
  };
  _proto.exportJSON = function exportJSON(_collections) {
    throw (0, _utils$2.pluginMissing)("json-dump");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw (0, _utils$2.pluginMissing)("json-dump");
  };
  _proto.backup = function backup(_options2) {
    throw (0, _utils$2.pluginMissing)("backup");
  };
  _proto.leaderElector = function leaderElector() {
    throw (0, _utils$2.pluginMissing)("leader-election");
  };
  _proto.isLeader = function isLeader() {
    throw (0, _utils$2.pluginMissing)("leader-election");
  };
  _proto.waitForLeadership = function waitForLeadership() {
    throw (0, _utils$2.pluginMissing)("leader-election");
  };
  _proto.migrationStates = function migrationStates() {
    throw (0, _utils$2.pluginMissing)("migration");
  };
  _proto.destroy = async function destroy() {
    if (this.destroyed) {
      return _utils$2.PROMISE_RESOLVE_FALSE;
    }
    this.destroyed = true;
    await (0, _hooks$1.runAsyncPluginHooks)("preDestroyRxDatabase", this);
    this.eventBulks$.complete();
    DB_COUNT--;
    this._subs.map((sub) => sub.unsubscribe());
    if (this.name === "pseudoInstance") {
      return _utils$2.PROMISE_RESOLVE_FALSE;
    }
    return this.requestIdlePromise().then(() => Promise.all(this.onDestroy.map((fn2) => fn2()))).then(() => Promise.all(Object.keys(this.collections).map((key) => this.collections[key]).map((col) => col.destroy()))).then(() => this.internalStore.close()).then(() => USED_DATABASE_NAMES.delete(this.name)).then(() => true);
  };
  _proto.remove = function remove() {
    return this.destroy().then(() => removeRxDatabase(this.name, this.storage));
  };
  (0, _createClass2.default)(RxDatabaseBase2, [{
    key: "$",
    get: function() {
      return this.observable$;
    }
    /**
     * Because having unhandled exceptions would fail,
     * we have to store the async errors of the constructor here
     * so we can throw them later.
     */
    /**
     * When the database is destroyed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
     */
    /**
     * Unique token that is stored with the data.
     * Used to detect if the dataset has been deleted
     * and if two RxDatabase instances work on the same dataset or not.
     *
     * Because reading and writing the storageToken runs in the hot path
     * of database creation, we do not await the storageWrites but instead
     * work with the promise when we need the value.
     */
    /**
     * Stores the whole state of the internal storage token document.
     * We need this in some plugins.
     */
    /**
     * Contains the ids of all event bulks that have been emitted
     * by the database.
     * Used to detect duplicates that come in again via BroadcastChannel
     * or other streams.
     * TODO instead of having this here, we should add a test to ensure each RxStorage
     * behaves equal and does never emit duplicate eventBulks.
     */
  }, {
    key: "asRxDatabase",
    get: function() {
      return this;
    }
  }]);
  return RxDatabaseBase2;
}();
rxDatabase.RxDatabaseBase = RxDatabaseBase;
function throwIfDatabaseNameUsed(name) {
  if (!USED_DATABASE_NAMES.has(name)) {
    return;
  } else {
    throw (0, _rxError$2.newRxError)("DB8", {
      name,
      link: "https://pubkey.github.io/rxdb/rx-database.html#ignoreduplicate"
    });
  }
}
async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options2, multiInstance, password) {
  var internalStore = await storage.createStorageInstance({
    databaseInstanceToken,
    databaseName,
    collectionName: _rxStorageHelper.INTERNAL_STORAGE_NAME,
    schema: _rxDatabaseInternalStore.INTERNAL_STORE_SCHEMA,
    options: options2,
    multiInstance,
    password,
    devMode: _overwritable$1.overwritable.isDevMode()
  });
  return internalStore;
}
function createRxDatabase({
  storage,
  instanceCreationOptions,
  name,
  password,
  multiInstance = true,
  eventReduce: eventReduce2 = false,
  ignoreDuplicate = false,
  options: options2 = {},
  cleanupPolicy,
  allowSlowCount = false,
  localDocuments = false,
  hashFunction = _utils$2.defaultHashSha256
}) {
  (0, _hooks$1.runPluginHooks)("preCreateRxDatabase", {
    storage,
    instanceCreationOptions,
    name,
    password,
    multiInstance,
    eventReduce: eventReduce2,
    ignoreDuplicate,
    options: options2,
    localDocuments
  });
  if (!ignoreDuplicate) {
    throwIfDatabaseNameUsed(name);
  }
  USED_DATABASE_NAMES.add(name);
  var databaseInstanceToken = (0, _utils$2.randomCouchString)(10);
  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password).catch((err) => {
    USED_DATABASE_NAMES.delete(name);
    throw err;
  }).then((storageInstance) => {
    var rxDatabase2 = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce2, options2, storageInstance, hashFunction, cleanupPolicy, allowSlowCount);
    return (0, _hooks$1.runAsyncPluginHooks)("createRxDatabase", {
      database: rxDatabase2,
      creator: {
        storage,
        instanceCreationOptions,
        name,
        password,
        multiInstance,
        eventReduce: eventReduce2,
        ignoreDuplicate,
        options: options2,
        localDocuments
      }
    }).then(() => rxDatabase2);
  });
}
async function removeRxDatabase(databaseName, storage) {
  var databaseInstanceToken = (0, _utils$2.randomCouchString)(10);
  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, false);
  var collectionDocs = await (0, _rxDatabaseInternalStore.getAllCollectionDocuments)(storage.statics, dbInternalsStorageInstance);
  var collectionNames = /* @__PURE__ */ new Set();
  collectionDocs.forEach((doc) => collectionNames.add(doc.data.name));
  var removedCollectionNames = Array.from(collectionNames);
  await Promise.all(removedCollectionNames.map((collectionName) => (0, _rxCollectionHelper.removeCollectionStorages)(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName)));
  await (0, _hooks$1.runAsyncPluginHooks)("postRemoveRxDatabase", {
    databaseName,
    storage
  });
  await dbInternalsStorageInstance.remove();
  return removedCollectionNames;
}
function isRxDatabase(obj) {
  return obj instanceof RxDatabaseBase;
}
function dbCount() {
  return DB_COUNT;
}
async function isRxDatabaseFirstTimeInstantiated(database) {
  var tokenDoc = await database.storageTokenDocument;
  return tokenDoc.data.instanceToken === database.token;
}
async function ensureNoStartupErrors(rxDatabase2) {
  await rxDatabase2.storageToken;
  if (rxDatabase2.startupErrors[0]) {
    throw rxDatabase2.startupErrors[0];
  }
}
Object.defineProperty(plugin, "__esModule", {
  value: true
});
plugin.addRxPlugin = addRxPlugin;
var _rxSchema = rxSchema;
var _rxDocument = rxDocument;
var _rxQuery = rxQuery;
var _rxCollection = rxCollection;
var _rxDatabase = rxDatabase;
var _overwritable = overwritable$1;
var _hooks = hooks;
var _rxError$1 = rxError;
var PROTOTYPES = {
  RxSchema: _rxSchema.RxSchema.prototype,
  RxDocument: _rxDocument.basePrototype,
  RxQuery: _rxQuery.RxQueryBase.prototype,
  RxCollection: _rxCollection.RxCollectionBase.prototype,
  RxDatabase: _rxDatabase.RxDatabaseBase.prototype
};
var ADDED_PLUGINS = /* @__PURE__ */ new Set();
var ADDED_PLUGIN_NAMES = /* @__PURE__ */ new Set();
function addRxPlugin(plugin2) {
  (0, _hooks.runPluginHooks)("preAddRxPlugin", {
    plugin: plugin2,
    plugins: ADDED_PLUGINS
  });
  if (ADDED_PLUGINS.has(plugin2)) {
    return;
  } else {
    if (ADDED_PLUGIN_NAMES.has(plugin2.name)) {
      throw (0, _rxError$1.newRxError)("PL3", {
        name: plugin2.name,
        plugin: plugin2
      });
    }
    ADDED_PLUGINS.add(plugin2);
    ADDED_PLUGIN_NAMES.add(plugin2.name);
  }
  if (!plugin2.rxdb) {
    throw (0, _rxError$1.newRxTypeError)("PL1", {
      plugin: plugin2
    });
  }
  if (plugin2.init) {
    plugin2.init();
  }
  if (plugin2.prototypes) {
    Object.entries(plugin2.prototypes).forEach(([name, fun]) => {
      return fun(PROTOTYPES[name]);
    });
  }
  if (plugin2.overwritable) {
    Object.assign(_overwritable.overwritable, plugin2.overwritable);
  }
  if (plugin2.hooks) {
    Object.entries(plugin2.hooks).forEach(([name, hooksObj]) => {
      if (hooksObj.after) {
        _hooks.HOOKS[name].push(hooksObj.after);
      }
      if (hooksObj.before) {
        _hooks.HOOKS[name].unshift(hooksObj.before);
      }
    });
  }
}
var customIndex = {};
Object.defineProperty(customIndex, "__esModule", {
  value: true
});
customIndex.getIndexMeta = getIndexMeta;
customIndex.getIndexStringLength = getIndexStringLength;
customIndex.getIndexableStringMonad = getIndexableStringMonad;
customIndex.getNumberIndexString = getNumberIndexString;
customIndex.getPrimaryKeyFromIndexableString = getPrimaryKeyFromIndexableString;
customIndex.getStartIndexStringFromLowerBound = getStartIndexStringFromLowerBound;
customIndex.getStartIndexStringFromUpperBound = getStartIndexStringFromUpperBound;
customIndex.getStringLengthOfIndexNumber = getStringLengthOfIndexNumber;
var _rxSchemaHelper$1 = rxSchemaHelper;
var _utils$1 = utils;
var _queryPlanner = queryPlanner;
function getIndexMeta(schema, index) {
  var fieldNameProperties = index.map((fieldName) => {
    var schemaPart = (0, _rxSchemaHelper$1.getSchemaByObjectPath)(schema, fieldName);
    if (!schemaPart) {
      throw new Error("not in schema: " + fieldName);
    }
    var type2 = schemaPart.type;
    var parsedLengths;
    if (type2 === "number" || type2 === "integer") {
      parsedLengths = getStringLengthOfIndexNumber(schemaPart);
    }
    var getValue = (0, _utils$1.objectPathMonad)(fieldName);
    var maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;
    var getIndexStringPart;
    if (type2 === "string") {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        if (!fieldValue) {
          fieldValue = "";
        }
        return fieldValue.padEnd(maxLength, " ");
      };
    } else if (type2 === "boolean") {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        return fieldValue ? "1" : "0";
      };
    } else {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        return getNumberIndexString(parsedLengths, fieldValue);
      };
    }
    var ret = {
      fieldName,
      schemaPart,
      parsedLengths,
      getValue,
      getIndexStringPart
    };
    return ret;
  });
  return fieldNameProperties;
}
function getIndexableStringMonad(schema, index) {
  var fieldNameProperties = getIndexMeta(schema, index);
  var fieldNamePropertiesAmount = fieldNameProperties.length;
  var indexPartsFunctions = fieldNameProperties.map((r2) => r2.getIndexStringPart);
  var ret = function(docData) {
    var str = "";
    for (var i2 = 0; i2 < fieldNamePropertiesAmount; ++i2) {
      str += indexPartsFunctions[i2](docData);
    }
    return str;
  };
  return ret;
}
function getStringLengthOfIndexNumber(schemaPart) {
  var minimum = Math.floor(schemaPart.minimum);
  var maximum = Math.ceil(schemaPart.maximum);
  var multipleOf = schemaPart.multipleOf;
  var valueSpan = maximum - minimum;
  var nonDecimals = valueSpan.toString().length;
  var multipleOfParts = multipleOf.toString().split(".");
  var decimals = 0;
  if (multipleOfParts.length > 1) {
    decimals = multipleOfParts[1].length;
  }
  return {
    minimum,
    maximum,
    nonDecimals,
    decimals,
    roundedMinimum: minimum
  };
}
function getIndexStringLength(schema, index) {
  var fieldNameProperties = getIndexMeta(schema, index);
  var length = 0;
  fieldNameProperties.forEach((props) => {
    var schemaPart = props.schemaPart;
    var type2 = schemaPart.type;
    if (type2 === "string") {
      length += schemaPart.maxLength;
    } else if (type2 === "boolean") {
      length += 1;
    } else {
      var parsedLengths = props.parsedLengths;
      length = length + parsedLengths.nonDecimals + parsedLengths.decimals;
    }
  });
  return length;
}
function getPrimaryKeyFromIndexableString(indexableString, primaryKeyLength) {
  var paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);
  var primaryKey = paddedPrimaryKey.trim();
  return primaryKey;
}
function getNumberIndexString(parsedLengths, fieldValue) {
  if (typeof fieldValue === "undefined") {
    fieldValue = 0;
  }
  if (fieldValue < parsedLengths.minimum) {
    fieldValue = parsedLengths.minimum;
  }
  if (fieldValue > parsedLengths.maximum) {
    fieldValue = parsedLengths.maximum;
  }
  var nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();
  var str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, "0");
  if (parsedLengths.decimals > 0) {
    var splitByDecimalPoint = fieldValue.toString().split(".");
    var decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : "0";
    str += decimalValueAsString.padEnd(parsedLengths.decimals, "0");
  }
  return str;
}
function getStartIndexStringFromLowerBound(schema, index, lowerBound2, inclusiveStart) {
  var str = "";
  index.forEach((fieldName, idx) => {
    var schemaPart = (0, _rxSchemaHelper$1.getSchemaByObjectPath)(schema, fieldName);
    var bound = lowerBound2[idx];
    var type2 = schemaPart.type;
    switch (type2) {
      case "string":
        var maxLength = (0, _utils$1.ensureNotFalsy)(schemaPart.maxLength);
        if (typeof bound === "string") {
          str += bound.padEnd(maxLength, " ");
        } else {
          str += "".padEnd(maxLength, " ");
        }
        break;
      case "boolean":
        if (bound === null) {
          str += inclusiveStart ? "0" : _queryPlanner.INDEX_MAX;
        } else {
          var boolToStr = bound ? "1" : "0";
          str += boolToStr;
        }
        break;
      case "number":
      case "integer":
        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);
        if (bound === null || bound === _queryPlanner.INDEX_MIN) {
          var fillChar = inclusiveStart ? "0" : _queryPlanner.INDEX_MAX;
          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else {
          str += getNumberIndexString(parsedLengths, bound);
        }
        break;
      default:
        throw new Error("unknown index type " + type2);
    }
  });
  return str;
}
function getStartIndexStringFromUpperBound(schema, index, upperBound, inclusiveEnd) {
  var str = "";
  index.forEach((fieldName, idx) => {
    var schemaPart = (0, _rxSchemaHelper$1.getSchemaByObjectPath)(schema, fieldName);
    var bound = upperBound[idx];
    var type2 = schemaPart.type;
    switch (type2) {
      case "string":
        var maxLength = (0, _utils$1.ensureNotFalsy)(schemaPart.maxLength);
        if (typeof bound === "string" && bound !== _queryPlanner.INDEX_MAX) {
          str += bound.padEnd(maxLength, " ");
        } else {
          str += "".padEnd(maxLength, inclusiveEnd ? _queryPlanner.INDEX_MAX : " ");
        }
        break;
      case "boolean":
        if (bound === null) {
          str += inclusiveEnd ? "0" : "1";
        } else {
          var boolToStr = bound ? "1" : "0";
          str += boolToStr;
        }
        break;
      case "number":
      case "integer":
        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);
        if (bound === null || bound === _queryPlanner.INDEX_MAX) {
          var fillChar = inclusiveEnd ? "9" : "0";
          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else {
          str += getNumberIndexString(parsedLengths, bound);
        }
        break;
      default:
        throw new Error("unknown index type " + type2);
    }
  });
  return str;
}
var pluginHelpers = {};
Object.defineProperty(pluginHelpers, "__esModule", {
  value: true
});
pluginHelpers.wrapRxStorageInstance = wrapRxStorageInstance;
pluginHelpers.wrappedValidateStorageFactory = wrappedValidateStorageFactory;
var _operators = operators;
var _rxSchemaHelper = rxSchemaHelper;
var _utils = utils;
var _rxjs = cjs;
var VALIDATOR_CACHE_BY_VALIDATOR_KEY = /* @__PURE__ */ new Map();
function wrappedValidateStorageFactory(getValidator, validatorKey) {
  var VALIDATOR_CACHE = (0, _utils.getFromMapOrCreate)(VALIDATOR_CACHE_BY_VALIDATOR_KEY, validatorKey, () => /* @__PURE__ */ new Map());
  function initValidator(schema) {
    var hash2 = (0, _utils.defaultHashSha256)(JSON.stringify(schema));
    return (0, _utils.getFromMapOrCreate)(VALIDATOR_CACHE, hash2, () => getValidator(schema));
  }
  return (args2) => {
    return Object.assign({}, args2.storage, {
      async createStorageInstance(params) {
        var instance = await args2.storage.createStorageInstance(params);
        var primaryPath = (0, _rxSchemaHelper.getPrimaryFieldOfPrimaryKey)(params.schema.primaryKey);
        var validatorCached;
        (0, _utils.requestIdleCallbackIfAvailable)(() => validatorCached = initValidator(params.schema));
        var oldBulkWrite = instance.bulkWrite.bind(instance);
        instance.bulkWrite = (documentWrites, context2) => {
          if (!validatorCached) {
            validatorCached = initValidator(params.schema);
          }
          var errors = [];
          var continueWrites = [];
          documentWrites.forEach((row) => {
            var documentId = row.document[primaryPath];
            var validationErrors = validatorCached(row.document);
            if (validationErrors.length > 0) {
              errors.push({
                status: 422,
                isError: true,
                documentId,
                writeRow: row,
                validationErrors
              });
            } else {
              continueWrites.push(row);
            }
          });
          var writePromise = continueWrites.length > 0 ? oldBulkWrite(continueWrites, context2) : Promise.resolve({
            error: {},
            success: {}
          });
          return writePromise.then((writeResult) => {
            errors.forEach((validationError) => {
              writeResult.error[validationError.documentId] = validationError;
            });
            return writeResult;
          });
        };
        return instance;
      }
    });
  };
}
function wrapRxStorageInstance(instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage = (v2) => v2) {
  async function toStorage(docData) {
    if (!docData) {
      return docData;
    }
    return await modifyToStorage(docData);
  }
  async function fromStorage(docData) {
    if (!docData) {
      return docData;
    }
    return await modifyFromStorage(docData);
  }
  async function errorFromStorage(error) {
    var ret = (0, _utils.flatClone)(error);
    ret.writeRow = (0, _utils.flatClone)(ret.writeRow);
    if (ret.documentInDb) {
      ret.documentInDb = await fromStorage(ret.documentInDb);
    }
    if (ret.writeRow.previous) {
      ret.writeRow.previous = await fromStorage(ret.writeRow.previous);
    }
    ret.writeRow.document = await fromStorage(ret.writeRow.document);
    return ret;
  }
  var processingChangesCount$ = new _rxjs.BehaviorSubject(0);
  var wrappedInstance = {
    databaseName: instance.databaseName,
    internals: instance.internals,
    cleanup: instance.cleanup.bind(instance),
    options: instance.options,
    close: instance.close.bind(instance),
    schema: instance.schema,
    collectionName: instance.collectionName,
    count: instance.count.bind(instance),
    remove: instance.remove.bind(instance),
    originalStorageInstance: instance,
    bulkWrite: async (documentWrites, context2) => {
      var useRows = [];
      await Promise.all(documentWrites.map(async (row) => {
        var [previous, document2] = await Promise.all([row.previous ? toStorage(row.previous) : void 0, toStorage(row.document)]);
        useRows.push({
          previous,
          document: document2
        });
      }));
      var writeResult = await instance.bulkWrite(useRows, context2);
      var ret = {
        success: {},
        error: {}
      };
      var promises = [];
      Object.entries(writeResult.success).forEach(([k2, v2]) => {
        promises.push(fromStorage(v2).then((v22) => ret.success[k2] = v22));
      });
      Object.entries(writeResult.error).forEach(([k2, error]) => {
        promises.push(errorFromStorage(error).then((err) => ret.error[k2] = err));
      });
      await Promise.all(promises);
      await (0, _rxjs.firstValueFrom)(processingChangesCount$.pipe((0, _operators.filter)((v2) => v2 === 0)));
      return ret;
    },
    query: (preparedQuery) => {
      return instance.query(preparedQuery).then((queryResult) => {
        return Promise.all(queryResult.documents.map((doc) => fromStorage(doc)));
      }).then((documents) => ({
        documents
      }));
    },
    getAttachmentData: async (documentId, attachmentId, digest) => {
      var data = await instance.getAttachmentData(documentId, attachmentId, digest);
      data = await modifyAttachmentFromStorage(data);
      return data;
    },
    findDocumentsById: (ids, deleted) => {
      return instance.findDocumentsById(ids, deleted).then(async (findResult) => {
        var ret = {};
        await Promise.all(Object.entries(findResult).map(async ([key, doc]) => {
          ret[key] = await fromStorage(doc);
        }));
        return ret;
      });
    },
    getChangedDocumentsSince: (limit2, checkpoint2) => {
      return instance.getChangedDocumentsSince(limit2, checkpoint2).then(async (result) => {
        return {
          checkpoint: result.checkpoint,
          documents: await Promise.all(result.documents.map((d2) => fromStorage(d2)))
        };
      });
    },
    changeStream: () => {
      return instance.changeStream().pipe((0, _operators.tap)(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)), (0, _operators.mergeMap)(async (eventBulk) => {
        var useEvents = await Promise.all(eventBulk.events.map(async (event) => {
          var [documentData, previousDocumentData] = await Promise.all([fromStorage(event.documentData), fromStorage(event.previousDocumentData)]);
          var ev = {
            operation: event.operation,
            eventId: event.eventId,
            documentId: event.documentId,
            endTime: event.endTime,
            startTime: event.startTime,
            documentData,
            previousDocumentData,
            isLocal: false
          };
          return ev;
        }));
        var ret = {
          id: eventBulk.id,
          events: useEvents,
          checkpoint: eventBulk.checkpoint,
          context: eventBulk.context
        };
        return ret;
      }), (0, _operators.tap)(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1)));
    },
    conflictResultionTasks: () => {
      return instance.conflictResultionTasks().pipe((0, _operators.mergeMap)(async (task) => {
        var assumedMasterState = await fromStorage(task.input.assumedMasterState);
        var newDocumentState = await fromStorage(task.input.newDocumentState);
        var realMasterState = await fromStorage(task.input.realMasterState);
        return {
          id: task.id,
          context: task.context,
          input: {
            assumedMasterState,
            realMasterState,
            newDocumentState
          }
        };
      }));
    },
    resolveConflictResultionTask: (taskSolution) => {
      if (taskSolution.output.isEqual) {
        return instance.resolveConflictResultionTask(taskSolution);
      }
      var useSolution = {
        id: taskSolution.id,
        output: {
          isEqual: false,
          documentData: taskSolution.output.documentData
        }
      };
      return instance.resolveConflictResultionTask(useSolution);
    }
  };
  return wrappedInstance;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    addRxPlugin: true
  };
  Object.defineProperty(exports, "addRxPlugin", {
    enumerable: true,
    get: function() {
      return _plugin.addRxPlugin;
    }
  });
  var _plugin = plugin;
  var _rxDatabase2 = rxDatabase;
  Object.keys(_rxDatabase2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxDatabase2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxDatabase2[key];
      }
    });
  });
  var _rxError2 = rxError;
  Object.keys(_rxError2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxError2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxError2[key];
      }
    });
  });
  var _rxDatabaseInternalStore2 = rxDatabaseInternalStore;
  Object.keys(_rxDatabaseInternalStore2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxDatabaseInternalStore2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxDatabaseInternalStore2[key];
      }
    });
  });
  var _overwritable2 = overwritable$1;
  Object.keys(_overwritable2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _overwritable2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _overwritable2[key];
      }
    });
  });
  var _rxCollection2 = rxCollection;
  Object.keys(_rxCollection2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxCollection2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxCollection2[key];
      }
    });
  });
  var _rxCollectionHelper2 = rxCollectionHelper;
  Object.keys(_rxCollectionHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxCollectionHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxCollectionHelper2[key];
      }
    });
  });
  var _rxDocument2 = rxDocument;
  Object.keys(_rxDocument2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxDocument2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxDocument2[key];
      }
    });
  });
  var _rxChangeEvent2 = rxChangeEvent;
  Object.keys(_rxChangeEvent2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxChangeEvent2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxChangeEvent2[key];
      }
    });
  });
  var _rxDocumentPrototypeMerge2 = rxDocumentPrototypeMerge;
  Object.keys(_rxDocumentPrototypeMerge2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxDocumentPrototypeMerge2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxDocumentPrototypeMerge2[key];
      }
    });
  });
  var _rxQuery2 = rxQuery;
  Object.keys(_rxQuery2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxQuery2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxQuery2[key];
      }
    });
  });
  var _rxQueryHelper2 = rxQueryHelper;
  Object.keys(_rxQueryHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxQueryHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxQueryHelper2[key];
      }
    });
  });
  var _rxSchema2 = rxSchema;
  Object.keys(_rxSchema2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxSchema2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxSchema2[key];
      }
    });
  });
  var _rxSchemaHelper2 = rxSchemaHelper;
  Object.keys(_rxSchemaHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxSchemaHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxSchemaHelper2[key];
      }
    });
  });
  var _rxStorageHelper2 = rxStorageHelper;
  Object.keys(_rxStorageHelper2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxStorageHelper2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageHelper2[key];
      }
    });
  });
  var _rxStorageStatics2 = rxStorageStatics;
  Object.keys(_rxStorageStatics2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxStorageStatics2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageStatics2[key];
      }
    });
  });
  var _index = replicationProtocol;
  Object.keys(_index).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _index[key];
      }
    });
  });
  var _rxStorageMultiinstance2 = rxStorageMultiinstance;
  Object.keys(_rxStorageMultiinstance2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _rxStorageMultiinstance2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _rxStorageMultiinstance2[key];
      }
    });
  });
  var _customIndex = customIndex;
  Object.keys(_customIndex).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _customIndex[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _customIndex[key];
      }
    });
  });
  var _queryPlanner2 = queryPlanner;
  Object.keys(_queryPlanner2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _queryPlanner2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _queryPlanner2[key];
      }
    });
  });
  var _pluginHelpers = pluginHelpers;
  Object.keys(_pluginHelpers).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _pluginHelpers[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _pluginHelpers[key];
      }
    });
  });
  var _utils2 = utils;
  Object.keys(_utils2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _utils2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _utils2[key];
      }
    });
  });
  var _hooks2 = hooks;
  Object.keys(_hooks2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _hooks2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _hooks2[key];
      }
    });
  });
  var _queryCache2 = queryCache;
  Object.keys(_queryCache2).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _queryCache2[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _queryCache2[key];
      }
    });
  });
})(lib$2);
const cartSchema = {
  title: "cart schema",
  description: "describes shopping cart",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    items: {
      type: "array",
      items: {
        type: "object",
        properties: {
          name: {
            type: "string"
          },
          image: {
            type: "string"
          },
          quantity: {
            type: "number"
          },
          unitPrice: {
            type: "number"
          },
          productId: {
            type: "string"
          },
          priceWithTax: {
            type: "number"
          },
          variationId: {
            type: "number"
          },
          productType: {
            type: "string"
          },
          productUnitId: {
            type: "number"
          }
        }
      }
    },
    timestamp: {
      type: "date-time"
    }
  }
};
var queryBuilder = {};
var nosqlQueryBuilder = {};
var mqueryUtils = {};
Object.defineProperty(mqueryUtils, "__esModule", {
  value: true
});
mqueryUtils.isObject = isObject;
mqueryUtils.merge = merge;
var SPECIAL_PROPERTIES = ["__proto__", "constructor", "prototype"];
function merge(to, from2) {
  Object.keys(from2).forEach((key) => {
    if (SPECIAL_PROPERTIES.includes(key)) {
      return;
    }
    if (typeof to[key] === "undefined") {
      to[key] = from2[key];
    } else {
      if (isObject(from2[key]))
        merge(to[key], from2[key]);
      else
        to[key] = from2[key];
    }
  });
}
function isObject(arg) {
  return "[object Object]" === arg.toString();
}
Object.defineProperty(nosqlQueryBuilder, "__esModule", {
  value: true
});
nosqlQueryBuilder.OTHER_MANGO_OPERATORS = nosqlQueryBuilder.OTHER_MANGO_ATTRIBUTES = nosqlQueryBuilder.NoSqlQueryBuilderClass = void 0;
nosqlQueryBuilder.canMerge = canMerge;
nosqlQueryBuilder.createQueryBuilder = createQueryBuilder;
nosqlQueryBuilder.mQuerySortToRxDBSort = mQuerySortToRxDBSort;
var _mqueryUtils = mqueryUtils;
var _rxError = rxError;
var NoSqlQueryBuilderClass = /* @__PURE__ */ function() {
  function NoSqlQueryBuilderClass2(mangoQuery, _path2) {
    this.options = {};
    this._conditions = {};
    this._fields = {};
    this._path = _path2;
    if (mangoQuery) {
      var queryBuilder2 = this;
      if (mangoQuery.selector) {
        queryBuilder2.find(mangoQuery.selector);
      }
      if (mangoQuery.limit) {
        queryBuilder2.limit(mangoQuery.limit);
      }
      if (mangoQuery.skip) {
        queryBuilder2.skip(mangoQuery.skip);
      }
      if (mangoQuery.sort) {
        mangoQuery.sort.forEach((s2) => queryBuilder2.sort(s2));
      }
    }
  }
  var _proto = NoSqlQueryBuilderClass2.prototype;
  _proto.where = function where2(_path2, _val) {
    if (!arguments.length)
      return this;
    var type2 = typeof arguments[0];
    if ("string" === type2) {
      this._path = arguments[0];
      if (2 === arguments.length) {
        this._conditions[this._path] = arguments[1];
      }
      return this;
    }
    if ("object" === type2 && !Array.isArray(arguments[0])) {
      return this.merge(arguments[0]);
    }
    throw (0, _rxError.newRxTypeError)("MQ1", {
      path: arguments[0]
    });
  };
  _proto.equals = function equals(val) {
    this._ensurePath("equals");
    var path2 = this._path;
    this._conditions[path2] = val;
    return this;
  };
  _proto.eq = function eq2(val) {
    this._ensurePath("eq");
    var path2 = this._path;
    this._conditions[path2] = val;
    return this;
  };
  _proto.or = function or2(array2) {
    var or3 = this._conditions.$or || (this._conditions.$or = []);
    if (!Array.isArray(array2))
      array2 = [array2];
    or3.push.apply(or3, array2);
    return this;
  };
  _proto.nor = function nor2(array2) {
    var nor3 = this._conditions.$nor || (this._conditions.$nor = []);
    if (!Array.isArray(array2))
      array2 = [array2];
    nor3.push.apply(nor3, array2);
    return this;
  };
  _proto.and = function and2(array2) {
    var and3 = this._conditions.$and || (this._conditions.$and = []);
    if (!Array.isArray(array2))
      array2 = [array2];
    and3.push.apply(and3, array2);
    return this;
  };
  _proto.mod = function mod2(_path2, _val) {
    var val;
    var path2;
    if (1 === arguments.length) {
      this._ensurePath("mod");
      val = arguments[0];
      path2 = this._path;
    } else if (2 === arguments.length && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = arguments.slice();
      path2 = this._path;
    } else if (3 === arguments.length) {
      val = arguments.slice(1);
      path2 = arguments[0];
    } else {
      val = arguments[1];
      path2 = arguments[0];
    }
    var conds = this._conditions[path2] || (this._conditions[path2] = {});
    conds.$mod = val;
    return this;
  };
  _proto.exists = function exists2(_path2, _val) {
    var path2;
    var val;
    if (0 === arguments.length) {
      this._ensurePath("exists");
      path2 = this._path;
      val = true;
    } else if (1 === arguments.length) {
      if ("boolean" === typeof arguments[0]) {
        this._ensurePath("exists");
        path2 = this._path;
        val = arguments[0];
      } else {
        path2 = arguments[0];
        val = true;
      }
    } else if (2 === arguments.length) {
      path2 = arguments[0];
      val = arguments[1];
    }
    var conds = this._conditions[path2] || (this._conditions[path2] = {});
    conds.$exists = val;
    return this;
  };
  _proto.elemMatch = function elemMatch2(_path2, _criteria) {
    if (null === arguments[0])
      throw (0, _rxError.newRxTypeError)("MQ2");
    var fn2;
    var path2;
    var criteria;
    if ("function" === typeof arguments[0]) {
      this._ensurePath("elemMatch");
      path2 = this._path;
      fn2 = arguments[0];
    } else if ((0, _mqueryUtils.isObject)(arguments[0])) {
      this._ensurePath("elemMatch");
      path2 = this._path;
      criteria = arguments[0];
    } else if ("function" === typeof arguments[1]) {
      path2 = arguments[0];
      fn2 = arguments[1];
    } else if (arguments[1] && (0, _mqueryUtils.isObject)(arguments[1])) {
      path2 = arguments[0];
      criteria = arguments[1];
    } else
      throw (0, _rxError.newRxTypeError)("MQ2");
    if (fn2) {
      criteria = new NoSqlQueryBuilderClass2();
      fn2(criteria);
      criteria = criteria._conditions;
    }
    var conds = this._conditions[path2] || (this._conditions[path2] = {});
    conds.$elemMatch = criteria;
    return this;
  };
  _proto.sort = function sort2(arg) {
    if (!arg)
      return this;
    var len;
    var type2 = typeof arg;
    if (Array.isArray(arg)) {
      len = arg.length;
      for (var i2 = 0; i2 < arg.length; ++i2) {
        _pushArr(this.options, arg[i2][0], arg[i2][1]);
      }
      return this;
    }
    if (1 === arguments.length && "string" === type2) {
      arg = arg.split(/\s+/);
      len = arg.length;
      for (var _i = 0; _i < len; ++_i) {
        var field = arg[_i];
        if (!field)
          continue;
        var ascend = "-" === field[0] ? -1 : 1;
        if (ascend === -1)
          field = field.substring(1);
        push(this.options, field, ascend);
      }
      return this;
    }
    if ((0, _mqueryUtils.isObject)(arg)) {
      var keys = Object.keys(arg);
      keys.forEach((field2) => push(this.options, field2, arg[field2]));
      return this;
    }
    throw (0, _rxError.newRxTypeError)("MQ3", {
      args: arguments
    });
  };
  _proto.merge = function merge2(source) {
    if (!source) {
      return this;
    }
    if (!canMerge(source)) {
      throw (0, _rxError.newRxTypeError)("MQ4", {
        source
      });
    }
    if (source instanceof NoSqlQueryBuilderClass2) {
      if (source._conditions)
        (0, _mqueryUtils.merge)(this._conditions, source._conditions);
      if (source._fields) {
        if (!this._fields)
          this._fields = {};
        (0, _mqueryUtils.merge)(this._fields, source._fields);
      }
      if (source.options) {
        if (!this.options)
          this.options = {};
        (0, _mqueryUtils.merge)(this.options, source.options);
      }
      if (source._distinct)
        this._distinct = source._distinct;
      return this;
    }
    (0, _mqueryUtils.merge)(this._conditions, source);
    return this;
  };
  _proto.find = function find2(criteria) {
    if (canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  _proto._ensurePath = function _ensurePath(method) {
    if (!this._path) {
      throw (0, _rxError.newRxError)("MQ5", {
        method
      });
    }
  };
  _proto.toJSON = function toJSON() {
    var query2 = {
      selector: this._conditions
    };
    if (this.options.skip) {
      query2.skip = this.options.skip;
    }
    if (this.options.limit) {
      query2.limit = this.options.limit;
    }
    if (this.options.sort) {
      query2.sort = mQuerySortToRxDBSort(this.options.sort);
    }
    return {
      query: query2,
      path: this._path
    };
  };
  return NoSqlQueryBuilderClass2;
}();
nosqlQueryBuilder.NoSqlQueryBuilderClass = NoSqlQueryBuilderClass;
function mQuerySortToRxDBSort(sort2) {
  return Object.entries(sort2).map(([k2, v2]) => {
    var direction = v2 === 1 ? "asc" : "desc";
    var part = {
      [k2]: direction
    };
    return part;
  });
}
var OTHER_MANGO_ATTRIBUTES = ["limit", "skip", "maxScan", "batchSize", "comment"];
nosqlQueryBuilder.OTHER_MANGO_ATTRIBUTES = OTHER_MANGO_ATTRIBUTES;
OTHER_MANGO_ATTRIBUTES.forEach(function(method) {
  NoSqlQueryBuilderClass.prototype[method] = function(v2) {
    this.options[method] = v2;
    return this;
  };
});
var OTHER_MANGO_OPERATORS = ["gt", "gte", "lt", "lte", "ne", "in", "nin", "all", "regex", "size"];
nosqlQueryBuilder.OTHER_MANGO_OPERATORS = OTHER_MANGO_OPERATORS;
OTHER_MANGO_OPERATORS.forEach(function($conditional) {
  NoSqlQueryBuilderClass.prototype[$conditional] = function() {
    var path2;
    var val;
    if (1 === arguments.length) {
      this._ensurePath($conditional);
      val = arguments[0];
      path2 = this._path;
    } else {
      val = arguments[1];
      path2 = arguments[0];
    }
    var conds = this._conditions[path2] === null || typeof this._conditions[path2] === "object" ? this._conditions[path2] : this._conditions[path2] = {};
    conds["$" + $conditional] = val;
    return this;
  };
});
function push(opts, field, value) {
  if (Array.isArray(opts.sort)) {
    throw (0, _rxError.newRxTypeError)("MQ6", {
      opts,
      field,
      value
    });
  }
  if (value && value.$meta) {
    var sort2 = opts.sort || (opts.sort = {});
    sort2[field] = {
      $meta: value.$meta
    };
    return;
  }
  var val = String(value || 1).toLowerCase();
  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {
    if (Array.isArray(value))
      value = "[" + value + "]";
    throw (0, _rxError.newRxTypeError)("MQ7", {
      field,
      value
    });
  }
  var s2 = opts.sort || (opts.sort = {});
  var valueStr = value.toString().replace("asc", "1").replace("ascending", "1").replace("desc", "-1").replace("descending", "-1");
  s2[field] = parseInt(valueStr, 10);
}
function _pushArr(opts, field, value) {
  opts.sort = opts.sort || [];
  if (!Array.isArray(opts.sort)) {
    throw (0, _rxError.newRxTypeError)("MQ8", {
      opts,
      field,
      value
    });
  }
  opts.sort.push([field, value]);
}
function canMerge(conds) {
  return conds instanceof NoSqlQueryBuilderClass || (0, _mqueryUtils.isObject)(conds);
}
function createQueryBuilder(query2, path2) {
  return new NoSqlQueryBuilderClass(query2, path2);
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    runBuildingStep: true,
    applyBuildingStep: true,
    RxDBQueryBuilderPlugin: true
  };
  exports.RxDBQueryBuilderPlugin = void 0;
  exports.applyBuildingStep = applyBuildingStep;
  exports.runBuildingStep = runBuildingStep;
  var _nosqlQueryBuilder = nosqlQueryBuilder;
  Object.keys(_nosqlQueryBuilder).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _nosqlQueryBuilder[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function() {
        return _nosqlQueryBuilder[key];
      }
    });
  });
  var _rxQuery2 = rxQuery;
  var _utils2 = utils;
  var RXQUERY_OTHER_FLAG = "queryBuilderPath";
  function runBuildingStep(rxQuery2, functionName, value) {
    var queryBuilder2 = (0, _nosqlQueryBuilder.createQueryBuilder)((0, _utils2.clone)(rxQuery2.mangoQuery), rxQuery2.other[RXQUERY_OTHER_FLAG]);
    queryBuilder2[functionName](value);
    var queryBuilderJson = queryBuilder2.toJSON();
    return (0, _rxQuery2.createRxQuery)(rxQuery2.op, queryBuilderJson.query, rxQuery2.collection, {
      ...rxQuery2.other,
      [RXQUERY_OTHER_FLAG]: queryBuilderJson.path
    });
  }
  function applyBuildingStep(proto, functionName) {
    proto[functionName] = function(value) {
      return runBuildingStep(this, functionName, value);
    };
  }
  var RxDBQueryBuilderPlugin = {
    name: "query-builder",
    rxdb: true,
    prototypes: {
      RxQuery(proto) {
        ["where", "equals", "eq", "or", "nor", "and", "mod", "exists", "elemMatch", "sort"].forEach((attribute) => {
          applyBuildingStep(proto, attribute);
        });
        _nosqlQueryBuilder.OTHER_MANGO_ATTRIBUTES.forEach((attribute) => {
          applyBuildingStep(proto, attribute);
        });
        _nosqlQueryBuilder.OTHER_MANGO_OPERATORS.forEach((operator) => {
          applyBuildingStep(proto, operator);
        });
      }
    }
  };
  exports.RxDBQueryBuilderPlugin = RxDBQueryBuilderPlugin;
})(queryBuilder);
var update$1 = {};
var clone = { exports: {} };
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone)
    return clone.exports;
  hasRequiredClone = 1;
  (function(module) {
    var clone2 = function() {
      function _instanceof(obj, type2) {
        return type2 != null && obj instanceof type2;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_2) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_2) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_2) {
        nativePromise = function() {
        };
      }
      function clone3(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve, reject) {
              parent2.then(function(value) {
                resolve(_clone(value, depth2 - 1));
              }, function(err) {
                reject(_clone(err, depth2 - 1));
              });
            });
          } else if (clone3.__isArray(parent2)) {
            child = [];
          } else if (clone3.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone3.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index = allParents.indexOf(parent2);
            if (index != -1) {
              return allChildren[index];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value) {
              var entryChild = _clone(value, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i2 in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i2);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i2] = _clone(parent2[i2], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i2 = 0; i2 < symbols.length; i2++) {
              var symbol = symbols[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i2 = 0; i2 < allPropertyNames.length; i2++) {
              var propertyName = allPropertyNames[i2];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone3.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c2 = function() {
        };
        c2.prototype = parent;
        return new c2();
      };
      function __objToStr(o2) {
        return Object.prototype.toString.call(o2);
      }
      clone3.__objToStr = __objToStr;
      function __isDate(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Date]";
      }
      clone3.__isDate = __isDate;
      function __isArray(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object Array]";
      }
      clone3.__isArray = __isArray;
      function __isRegExp(o2) {
        return typeof o2 === "object" && __objToStr(o2) === "[object RegExp]";
      }
      clone3.__isRegExp = __isRegExp;
      function __getRegExpFlags(re2) {
        var flags = "";
        if (re2.global)
          flags += "g";
        if (re2.ignoreCase)
          flags += "i";
        if (re2.multiline)
          flags += "m";
        return flags;
      }
      clone3.__getRegExpFlags = __getRegExpFlags;
      return clone3;
    }();
    if (module.exports) {
      module.exports = clone2;
    }
  })(clone);
  return clone.exports;
}
var isArguments$1;
var hasRequiredIsArguments$1;
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1)
    return isArguments$1;
  hasRequiredIsArguments$1 = 1;
  var toStr = Object.prototype.toString;
  isArguments$1 = function isArguments2(value) {
    var str = toStr.call(value);
    var isArgs = str === "[object Arguments]";
    if (!isArgs) {
      isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    }
    return isArgs;
  };
  return isArguments$1;
}
var implementation$3;
var hasRequiredImplementation$3;
function requireImplementation$3() {
  if (hasRequiredImplementation$3)
    return implementation$3;
  hasRequiredImplementation$3 = 1;
  var keysShim;
  if (!Object.keys) {
    var has = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var isArgs = requireIsArguments$1();
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o2) {
      var ctor = o2.constructor;
      return ctor && ctor.prototype === o2;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k2 in window) {
        try {
          if (!excludedKeys["$" + k2] && has.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
            try {
              equalsConstructorPrototype(window[k2]);
            } catch (e2) {
              return true;
            }
          }
        } catch (e2) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o2) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o2);
      }
      try {
        return equalsConstructorPrototype(o2);
      } catch (e2) {
        return false;
      }
    };
    keysShim = function keys(object2) {
      var isObject2 = object2 !== null && typeof object2 === "object";
      var isFunction2 = toStr.call(object2) === "[object Function]";
      var isArguments2 = isArgs(object2);
      var isString = isObject2 && toStr.call(object2) === "[object String]";
      var theKeys = [];
      if (!isObject2 && !isFunction2 && !isArguments2) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString && object2.length > 0 && !has.call(object2, 0)) {
        for (var i2 = 0; i2 < object2.length; ++i2) {
          theKeys.push(String(i2));
        }
      }
      if (isArguments2 && object2.length > 0) {
        for (var j2 = 0; j2 < object2.length; ++j2) {
          theKeys.push(String(j2));
        }
      } else {
        for (var name in object2) {
          if (!(skipProto && name === "prototype") && has.call(object2, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
        for (var k2 = 0; k2 < dontEnums.length; ++k2) {
          if (!(skipConstructor && dontEnums[k2] === "constructor") && has.call(object2, dontEnums[k2])) {
            theKeys.push(dontEnums[k2]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$3 = keysShim;
  return implementation$3;
}
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys)
    return objectKeys;
  hasRequiredObjectKeys = 1;
  var slice2 = Array.prototype.slice;
  var isArgs = requireIsArguments$1();
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys(o2) {
    return origKeys(o2);
  } : requireImplementation$3();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args2 = Object.keys(arguments);
        return args2 && args2.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys(object2) {
          if (isArgs(object2)) {
            return originalKeys(slice2.call(object2));
          }
          return originalKeys(object2);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  objectKeys = keysShim;
  return objectKeys;
}
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1)
    return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var hasProto;
var hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto)
    return hasProto;
  hasRequiredHasProto = 1;
  var test = {
    foo: {}
  };
  var $Object = Object;
  hasProto = function hasProto2() {
    return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
  };
  return hasProto;
}
var implementation$2;
var hasRequiredImplementation$2;
function requireImplementation$2() {
  if (hasRequiredImplementation$2)
    return implementation$2;
  hasRequiredImplementation$2 = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice2 = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  implementation$2 = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args2 = slice2.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          args2.concat(slice2.call(arguments))
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(
          that,
          args2.concat(slice2.call(arguments))
        );
      }
    };
    var boundLength = Math.max(0, target.length - args2.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs.push("$" + i2);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation$2;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation$2();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var src;
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc)
    return src;
  hasRequiredSrc = 1;
  var bind = requireFunctionBind();
  src = bind.call(Function.call, Object.prototype.hasOwnProperty);
  return src;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError = TypeError;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e2) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e2) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var hasProto2 = requireHasProto()();
  var getProto = Object.getPrototypeOf || (hasProto2 ? function(x2) {
    return x2.__proto__;
  } : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  if (getProto) {
    try {
      null.error;
    } catch (e2) {
      var errorProto = getProto(getProto(e2));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn2 = doEval2("%AsyncGeneratorFunction%");
      if (fn2) {
        value = fn2.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn = requireSrc();
  var $concat2 = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace = bind.call(Function.call, String.prototype.replace);
  var $strSlice = bind.call(Function.call, String.prototype.slice);
  var $exec = bind.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string2) {
    var first2 = $strSlice(string2, 0, 1);
    var last2 = $strSlice(string2, -1);
    if (first2 === "%" && last2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last2 === "%" && first2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string2, rePropName, function(match2, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat2([0, 1], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
      var part = parts[i2];
      var first2 = $strSlice(part, 0, 1);
      var last2 = $strSlice(part, -1);
      if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i2 + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBind = { exports: {} };
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind)
    return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var bind = requireFunctionBind();
    var GetIntrinsic = requireGetIntrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max2 = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind2(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max2(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  })(callBind);
  return callBind.exports;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = requireCallBound();
  var $toString2 = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString2(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString2(value) !== "[object Array]" && $toString2(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors)
    return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
        return true;
      } catch (e2) {
        return false;
      }
    }
    return false;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!hasPropertyDescriptors()) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e2) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd)
    return gopd;
  hasRequiredGopd = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e2) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty)
    return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var hasPropertyDescriptors = requireHasPropertyDescriptors()();
  var GetIntrinsic = requireGetIntrinsic();
  var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
  var $SyntaxError = GetIntrinsic("%SyntaxError%");
  var $TypeError = GetIntrinsic("%TypeError%");
  var gopd2 = requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var defineProperties_1;
var hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties)
    return defineProperties_1;
  hasRequiredDefineProperties = 1;
  var keys = requireObjectKeys();
  var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr = Object.prototype.toString;
  var concat2 = Array.prototype.concat;
  var defineDataProperty2 = requireDefineDataProperty();
  var isFunction2 = function(fn2) {
    return typeof fn2 === "function" && toStr.call(fn2) === "[object Function]";
  };
  var supportsDescriptors = requireHasPropertyDescriptors()();
  var defineProperty = function(object2, name, value, predicate) {
    if (name in object2) {
      if (predicate === true) {
        if (object2[name] === value) {
          return;
        }
      } else if (!isFunction2(predicate) || !predicate()) {
        return;
      }
    }
    if (supportsDescriptors) {
      defineDataProperty2(object2, name, value, true);
    } else {
      defineDataProperty2(object2, name, value);
    }
  };
  var defineProperties = function(object2, map2) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map2);
    if (hasSymbols2) {
      props = concat2.call(props, Object.getOwnPropertySymbols(map2));
    }
    for (var i2 = 0; i2 < props.length; i2 += 1) {
      defineProperty(object2, props[i2], map2[props[i2]], predicates[props[i2]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  defineProperties_1 = defineProperties;
  return defineProperties_1;
}
var implementation$1;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1)
    return implementation$1;
  hasRequiredImplementation$1 = 1;
  var numberIsNaN = function(value) {
    return value !== value;
  };
  implementation$1 = function is(a2, b2) {
    if (a2 === 0 && b2 === 0) {
      return 1 / a2 === 1 / b2;
    }
    if (a2 === b2) {
      return true;
    }
    if (numberIsNaN(a2) && numberIsNaN(b2)) {
      return true;
    }
    return false;
  };
  return implementation$1;
}
var polyfill$1;
var hasRequiredPolyfill$1;
function requirePolyfill$1() {
  if (hasRequiredPolyfill$1)
    return polyfill$1;
  hasRequiredPolyfill$1 = 1;
  var implementation2 = requireImplementation$1();
  polyfill$1 = function getPolyfill() {
    return typeof Object.is === "function" ? Object.is : implementation2;
  };
  return polyfill$1;
}
var shim$1;
var hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1)
    return shim$1;
  hasRequiredShim$1 = 1;
  var getPolyfill = requirePolyfill$1();
  var define = requireDefineProperties();
  shim$1 = function shimObjectIs() {
    var polyfill2 = getPolyfill();
    define(Object, { is: polyfill2 }, {
      is: function testObjectIs() {
        return Object.is !== polyfill2;
      }
    });
    return polyfill2;
  };
  return shim$1;
}
var objectIs;
var hasRequiredObjectIs;
function requireObjectIs() {
  if (hasRequiredObjectIs)
    return objectIs;
  hasRequiredObjectIs = 1;
  var define = requireDefineProperties();
  var callBind2 = requireCallBind();
  var implementation2 = requireImplementation$1();
  var getPolyfill = requirePolyfill$1();
  var shim2 = requireShim$1();
  var polyfill2 = callBind2(getPolyfill(), Object);
  define(polyfill2, {
    getPolyfill,
    implementation: implementation2,
    shim: shim2
  });
  objectIs = polyfill2;
  return objectIs;
}
var isRegex;
var hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex)
    return isRegex;
  hasRequiredIsRegex = 1;
  var callBound2 = requireCallBound();
  var hasToStringTag = requireShams()();
  var has;
  var $exec;
  var isRegexMarker;
  var badStringifier;
  if (hasToStringTag) {
    has = callBound2("Object.prototype.hasOwnProperty");
    $exec = callBound2("RegExp.prototype.exec");
    isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
  }
  var $toString2 = callBound2("Object.prototype.toString");
  var gOPD = Object.getOwnPropertyDescriptor;
  var regexClass = "[object RegExp]";
  isRegex = hasToStringTag ? function isRegex2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    var descriptor = gOPD(value, "lastIndex");
    var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
    if (!hasLastIndexDataProperty) {
      return false;
    }
    try {
      $exec(value, badStringifier);
    } catch (e2) {
      return e2 === isRegexMarker;
    }
  } : function isRegex2(value) {
    if (!value || typeof value !== "object" && typeof value !== "function") {
      return false;
    }
    return $toString2(value) === regexClass;
  };
  return isRegex;
}
var functionsHaveNames_1;
var hasRequiredFunctionsHaveNames;
function requireFunctionsHaveNames() {
  if (hasRequiredFunctionsHaveNames)
    return functionsHaveNames_1;
  hasRequiredFunctionsHaveNames = 1;
  var functionsHaveNames = function functionsHaveNames2() {
    return typeof function f2() {
    }.name === "string";
  };
  var gOPD = Object.getOwnPropertyDescriptor;
  if (gOPD) {
    try {
      gOPD([], "length");
    } catch (e2) {
      gOPD = null;
    }
  }
  functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
    if (!functionsHaveNames() || !gOPD) {
      return false;
    }
    var desc = gOPD(function() {
    }, "name");
    return !!desc && !!desc.configurable;
  };
  var $bind = Function.prototype.bind;
  functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
    return functionsHaveNames() && typeof $bind === "function" && function f2() {
    }.bind().name !== "";
  };
  functionsHaveNames_1 = functionsHaveNames;
  return functionsHaveNames_1;
}
var setFunctionName;
var hasRequiredSetFunctionName;
function requireSetFunctionName() {
  if (hasRequiredSetFunctionName)
    return setFunctionName;
  hasRequiredSetFunctionName = 1;
  var define = requireDefineDataProperty();
  var hasDescriptors = requireHasPropertyDescriptors()();
  var functionsHaveConfigurableNames = requireFunctionsHaveNames().functionsHaveConfigurableNames();
  var $TypeError = TypeError;
  setFunctionName = function setFunctionName2(fn2, name) {
    if (typeof fn2 !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    if (!loose || functionsHaveConfigurableNames) {
      if (hasDescriptors) {
        define(fn2, "name", name, true, true);
      } else {
        define(fn2, "name", name);
      }
    }
    return fn2;
  };
  return setFunctionName;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var setFunctionName2 = requireSetFunctionName();
  var $Object = Object;
  var $TypeError = TypeError;
  implementation = setFunctionName2(function flags() {
    if (this != null && this !== $Object(this)) {
      throw new $TypeError("RegExp.prototype.flags getter called on non-object");
    }
    var result = "";
    if (this.hasIndices) {
      result += "d";
    }
    if (this.global) {
      result += "g";
    }
    if (this.ignoreCase) {
      result += "i";
    }
    if (this.multiline) {
      result += "m";
    }
    if (this.dotAll) {
      result += "s";
    }
    if (this.unicode) {
      result += "u";
    }
    if (this.unicodeSets) {
      result += "v";
    }
    if (this.sticky) {
      result += "y";
    }
    return result;
  }, "get flags", true);
  return implementation;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill)
    return polyfill;
  hasRequiredPolyfill = 1;
  var implementation2 = requireImplementation();
  var supportsDescriptors = requireDefineProperties().supportsDescriptors;
  var $gOPD = Object.getOwnPropertyDescriptor;
  polyfill = function getPolyfill() {
    if (supportsDescriptors && /a/mig.flags === "gim") {
      var descriptor = $gOPD(RegExp.prototype, "flags");
      if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
        var calls = "";
        var o2 = {};
        Object.defineProperty(o2, "hasIndices", {
          get: function() {
            calls += "d";
          }
        });
        Object.defineProperty(o2, "sticky", {
          get: function() {
            calls += "y";
          }
        });
        if (calls === "dy") {
          return descriptor.get;
        }
      }
    }
    return implementation2;
  };
  return polyfill;
}
var shim;
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim)
    return shim;
  hasRequiredShim = 1;
  var supportsDescriptors = requireDefineProperties().supportsDescriptors;
  var getPolyfill = requirePolyfill();
  var gOPD = Object.getOwnPropertyDescriptor;
  var defineProperty = Object.defineProperty;
  var TypeErr = TypeError;
  var getProto = Object.getPrototypeOf;
  var regex2 = /a/;
  shim = function shimFlags() {
    if (!supportsDescriptors || !getProto) {
      throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    }
    var polyfill2 = getPolyfill();
    var proto = getProto(regex2);
    var descriptor = gOPD(proto, "flags");
    if (!descriptor || descriptor.get !== polyfill2) {
      defineProperty(proto, "flags", {
        configurable: true,
        enumerable: false,
        get: polyfill2
      });
    }
    return polyfill2;
  };
  return shim;
}
var regexp_prototype_flags;
var hasRequiredRegexp_prototype_flags;
function requireRegexp_prototype_flags() {
  if (hasRequiredRegexp_prototype_flags)
    return regexp_prototype_flags;
  hasRequiredRegexp_prototype_flags = 1;
  var define = requireDefineProperties();
  var callBind2 = requireCallBind();
  var implementation2 = requireImplementation();
  var getPolyfill = requirePolyfill();
  var shim2 = requireShim();
  var flagsBound = callBind2(getPolyfill());
  define(flagsBound, {
    getPolyfill,
    implementation: implementation2,
    shim: shim2
  });
  regexp_prototype_flags = flagsBound;
  return regexp_prototype_flags;
}
var isDateObject;
var hasRequiredIsDateObject;
function requireIsDateObject() {
  if (hasRequiredIsDateObject)
    return isDateObject;
  hasRequiredIsDateObject = 1;
  var getDay = Date.prototype.getDay;
  var tryDateObject = function tryDateGetDayCall(value) {
    try {
      getDay.call(value);
      return true;
    } catch (e2) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var dateClass = "[object Date]";
  var hasToStringTag = requireShams()();
  isDateObject = function isDateObject2(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
  };
  return isDateObject;
}
var deepEqual_1;
var hasRequiredDeepEqual;
function requireDeepEqual() {
  if (hasRequiredDeepEqual)
    return deepEqual_1;
  hasRequiredDeepEqual = 1;
  var objectKeys2 = requireObjectKeys();
  var isArguments2 = requireIsArguments();
  var is = requireObjectIs();
  var isRegex2 = requireIsRegex();
  var flags = requireRegexp_prototype_flags();
  var isDate2 = requireIsDateObject();
  var getTime = Date.prototype.getTime;
  function deepEqual2(actual, expected, options2) {
    var opts = options2 || {};
    if (opts.strict ? is(actual, expected) : actual === expected) {
      return true;
    }
    if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
      return opts.strict ? is(actual, expected) : actual == expected;
    }
    return objEquiv(actual, expected, opts);
  }
  function isUndefinedOrNull(value) {
    return value === null || value === void 0;
  }
  function isBuffer(x2) {
    if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
      return false;
    }
    if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
      return false;
    }
    if (x2.length > 0 && typeof x2[0] !== "number") {
      return false;
    }
    return true;
  }
  function objEquiv(a2, b2, opts) {
    var i2, key;
    if (typeof a2 !== typeof b2) {
      return false;
    }
    if (isUndefinedOrNull(a2) || isUndefinedOrNull(b2)) {
      return false;
    }
    if (a2.prototype !== b2.prototype) {
      return false;
    }
    if (isArguments2(a2) !== isArguments2(b2)) {
      return false;
    }
    var aIsRegex = isRegex2(a2);
    var bIsRegex = isRegex2(b2);
    if (aIsRegex !== bIsRegex) {
      return false;
    }
    if (aIsRegex || bIsRegex) {
      return a2.source === b2.source && flags(a2) === flags(b2);
    }
    if (isDate2(a2) && isDate2(b2)) {
      return getTime.call(a2) === getTime.call(b2);
    }
    var aIsBuffer = isBuffer(a2);
    var bIsBuffer = isBuffer(b2);
    if (aIsBuffer !== bIsBuffer) {
      return false;
    }
    if (aIsBuffer || bIsBuffer) {
      if (a2.length !== b2.length) {
        return false;
      }
      for (i2 = 0; i2 < a2.length; i2++) {
        if (a2[i2] !== b2[i2]) {
          return false;
        }
      }
      return true;
    }
    if (typeof a2 !== typeof b2) {
      return false;
    }
    try {
      var ka = objectKeys2(a2);
      var kb = objectKeys2(b2);
    } catch (e2) {
      return false;
    }
    if (ka.length !== kb.length) {
      return false;
    }
    ka.sort();
    kb.sort();
    for (i2 = ka.length - 1; i2 >= 0; i2--) {
      if (ka[i2] != kb[i2]) {
        return false;
      }
    }
    for (i2 = ka.length - 1; i2 >= 0; i2--) {
      key = ka[i2];
      if (!deepEqual2(a2[key], b2[key], opts)) {
        return false;
      }
    }
    return true;
  }
  deepEqual_1 = deepEqual2;
  return deepEqual_1;
}
var bundle;
var hasRequiredBundle;
function requireBundle() {
  if (hasRequiredBundle)
    return bundle;
  hasRequiredBundle = 1;
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var clone2 = _interopDefault(requireClone());
  var equal = _interopDefault(requireDeepEqual());
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var isObject2 = function(variableToCheck) {
    return (typeof variableToCheck === "undefined" ? "undefined" : _typeof2(variableToCheck)) === "object" && variableToCheck !== null;
  };
  var every2 = function(arrayToIterate, cb) {
    return arrayToIterate.every(function(elem) {
      return cb && cb(elem) || elem;
    });
  };
  var has = function(objectWithKeys, key) {
    return objectWithKeys.hasOwnProperty(key);
  };
  var keys = function(objectWithKeys) {
    return Object.keys(objectWithKeys);
  };
  var each = function(objectToIterate, cb) {
    Object.keys(objectToIterate).forEach(function(key) {
      cb(objectToIterate[key], key);
    });
  };
  var libIsArray = function(variableToCheck) {
    return Array.isArray(variableToCheck);
  };
  var isBinary = function(variableToCheck) {
    return !!(typeof Uint8Array !== "undefined" && variableToCheck instanceof Uint8Array || variableToCheck && variableToCheck.$Uint8ArrayPolyfill);
  };
  var _$1 = { isArray: libIsArray, each };
  var isArray2 = function isArray3(x2) {
    return _$1.isArray(x2) && !isBinary(x2);
  };
  var isIndexable = function isIndexable2(x2) {
    return isArray2(x2) || isPlainObject(x2);
  };
  var isOperatorObject = function isOperatorObject2(valueSelector, inconsistentOK) {
    if (!isPlainObject(valueSelector))
      return false;
    var theseAreOperators = void 0;
    _$1.each(valueSelector, function(value, selKey) {
      var thisIsOperator = selKey.substr(0, 1) === "$";
      if (theseAreOperators === void 0) {
        theseAreOperators = thisIsOperator;
      } else if (theseAreOperators !== thisIsOperator) {
        if (!inconsistentOK)
          throw new Error("Inconsistent operator: " + JSON.stringify(valueSelector));
        theseAreOperators = false;
      }
    });
    return !!theseAreOperators;
  };
  var isNumericKey = function isNumericKey2(s2) {
    return /^[0-9]+$/.test(s2);
  };
  var isPlainObject = function(variableToCheck) {
    if (!variableToCheck)
      return false;
    if (typeof variableToCheck === "number")
      return false;
    if (typeof variableToCheck === "string")
      return false;
    if (typeof variableToCheck === "boolean")
      return false;
    if (isArray2(variableToCheck))
      return false;
    if (variableToCheck === null)
      return false;
    if (variableToCheck instanceof RegExp)
      return false;
    if (typeof variableToCheck === "function")
      return false;
    if (variableToCheck instanceof Date)
      return false;
    if (isBinary(variableToCheck))
      return false;
    return true;
  };
  var ModifyJsError = function(message) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof message === "string" && options2.field) {
      message += " for field '" + options2.field + "'";
    }
    var e2 = new Error(message);
    e2.name = "ModifyJsError";
    return e2;
  };
  var _2 = { all: every2, each, keys, has, isObject: isObject2 };
  var modify = function(doc, mod2, options2) {
    if (options2 && options2.each) {
      return;
    }
    return _modify(doc, mod2, _extends({}, options2, { returnInsteadOfReplacing: true }));
  };
  var _modify = function _modify2(doc, mod2, options2) {
    options2 = options2 || {};
    if (!isPlainObject(mod2))
      throw ModifyJsError("Modifier must be an object");
    mod2 = clone2(mod2);
    var isModifier = isOperatorObject(mod2);
    var newDoc;
    if (!isModifier) {
      newDoc = mod2;
    } else {
      newDoc = clone2(doc);
      _2.each(mod2, function(operand, op) {
        var modFunc = MODIFIERS[op];
        if (!modFunc)
          throw ModifyJsError("Invalid modifier specified " + op);
        _2.each(operand, function(arg, keypath) {
          if (keypath === "") {
            throw ModifyJsError("An empty update path is not valid.");
          }
          var keyparts = keypath.split(".");
          if (!_2.all(keyparts)) {
            throw ModifyJsError("The update path '" + keypath + "' contains an empty field name, which is not allowed.");
          }
          var target = findModTarget(newDoc, keyparts, {
            noCreate: NO_CREATE_MODIFIERS[op],
            forbidArray: op === "$rename",
            arrayIndices: options2.arrayIndices
          });
          var field = keyparts.pop();
          modFunc(target, field, arg, keypath, newDoc);
        });
      });
    }
    if (options2.returnInsteadOfReplacing) {
      return newDoc;
    } else {
      _2.each(_2.keys(doc), function(k2) {
        if (k2 !== "_id")
          delete doc[k2];
      });
      _2.each(newDoc, function(v2, k2) {
        doc[k2] = v2;
      });
    }
  };
  var findModTarget = function findModTarget2(doc, keyparts, options2) {
    options2 = options2 || {};
    var usedArrayIndex = false;
    for (var i2 = 0; i2 < keyparts.length; i2++) {
      var last2 = i2 === keyparts.length - 1;
      var keypart = keyparts[i2];
      var indexable = isIndexable(doc);
      if (!indexable) {
        if (options2.noCreate)
          return void 0;
        var e2 = ModifyJsError("cannot use the part '" + keypart + "' to traverse " + doc);
        e2.setPropertyError = true;
        throw e2;
      }
      if (doc instanceof Array) {
        if (options2.forbidArray)
          return null;
        if (keypart === "$") {
          if (usedArrayIndex)
            throw ModifyJsError("Too many positional (i.e. '$') elements");
          if (!options2.arrayIndices || !options2.arrayIndices.length) {
            throw ModifyJsError("The positional operator did not find the match needed from the query");
          }
          keypart = options2.arrayIndices[0];
          usedArrayIndex = true;
        } else if (isNumericKey(keypart)) {
          keypart = parseInt(keypart);
        } else {
          if (options2.noCreate)
            return void 0;
          throw ModifyJsError("can't append to array using string field name [" + keypart + "]");
        }
        if (last2)
          keyparts[i2] = keypart;
        if (options2.noCreate && keypart >= doc.length)
          return void 0;
        while (doc.length < keypart) {
          doc.push(null);
        }
        if (!last2) {
          if (doc.length === keypart)
            doc.push({});
          else if (_typeof2(doc[keypart]) !== "object")
            throw ModifyJsError("can't modify field '" + keyparts[i2 + 1] + "' of list value " + JSON.stringify(doc[keypart]));
        }
      } else {
        if (!(keypart in doc)) {
          if (options2.noCreate)
            return void 0;
          if (!last2)
            doc[keypart] = {};
        }
      }
      if (last2)
        return doc;
      doc = doc[keypart];
    }
  };
  var NO_CREATE_MODIFIERS = {
    $unset: true,
    $pop: true,
    $rename: true,
    $pull: true,
    $pullAll: true
  };
  var MODIFIERS = {
    $currentDate: function $currentDate(target, field, arg) {
      if ((typeof arg === "undefined" ? "undefined" : _typeof2(arg)) === "object" && arg.hasOwnProperty("$type")) {
        if (arg.$type !== "date") {
          throw ModifyJsError("Minimongo does currently only support the date type in $currentDate modifiers", { field });
        }
      } else if (arg !== true) {
        throw ModifyJsError("Invalid $currentDate modifier", { field });
      }
      target[field] = /* @__PURE__ */ new Date();
    },
    $min: function $min2(target, field, arg) {
      if (typeof arg !== "number") {
        throw ModifyJsError("Modifier $min allowed for numbers only", { field });
      }
      if (field in target) {
        if (typeof target[field] !== "number") {
          throw ModifyJsError("Cannot apply $min modifier to non-number", { field });
        }
        if (target[field] > arg) {
          target[field] = arg;
        }
      } else {
        target[field] = arg;
      }
    },
    $max: function $max2(target, field, arg) {
      if (typeof arg !== "number") {
        throw ModifyJsError("Modifier $max allowed for numbers only", { field });
      }
      if (field in target) {
        if (typeof target[field] !== "number") {
          throw ModifyJsError("Cannot apply $max modifier to non-number", { field });
        }
        if (target[field] < arg) {
          target[field] = arg;
        }
      } else {
        target[field] = arg;
      }
    },
    $inc: function $inc(target, field, arg) {
      if (typeof arg !== "number")
        throw ModifyJsError("Modifier $inc allowed for numbers only", { field });
      if (field in target) {
        if (typeof target[field] !== "number")
          throw ModifyJsError("Cannot apply $inc modifier to non-number", { field });
        target[field] += arg;
      } else {
        target[field] = arg;
      }
    },
    $set: function $set(target, field, arg) {
      if (!_2.isObject(target)) {
        var e2 = ModifyJsError("Cannot set property on non-object field", { field });
        e2.setPropertyError = true;
        throw e2;
      }
      if (target === null) {
        var e2 = ModifyJsError("Cannot set property on null", { field });
        e2.setPropertyError = true;
        throw e2;
      }
      target[field] = arg;
    },
    $setOnInsert: function $setOnInsert(target, field, arg) {
    },
    $unset: function $unset2(target, field, arg) {
      if (target !== void 0) {
        if (target instanceof Array) {
          if (field in target)
            target[field] = null;
        } else
          delete target[field];
      }
    },
    $push: function $push2(target, field, arg) {
      if (target[field] === void 0)
        target[field] = [];
      if (!(target[field] instanceof Array))
        throw ModifyJsError("Cannot apply $push modifier to non-array", { field });
      if (!(arg && arg.$each)) {
        target[field].push(arg);
        return;
      }
      var toPush = arg.$each;
      if (!(toPush instanceof Array))
        throw ModifyJsError("$each must be an array", { field });
      var position = void 0;
      if ("$position" in arg) {
        if (typeof arg.$position !== "number")
          throw ModifyJsError("$position must be a numeric value", { field });
        if (arg.$position < 0)
          throw ModifyJsError("$position in $push must be zero or positive", { field });
        position = arg.$position;
      }
      var slice2 = void 0;
      if ("$slice" in arg) {
        if (typeof arg.$slice !== "number")
          throw ModifyJsError("$slice must be a numeric value", { field });
        if (arg.$slice > 0)
          throw ModifyJsError("$slice in $push must be zero or negative", { field });
        slice2 = arg.$slice;
      }
      if (arg.$sort) {
        throw ModifyJsError("$sort in $push not implemented yet");
      }
      if (position === void 0) {
        for (var j2 = 0; j2 < toPush.length; j2++) {
          target[field].push(toPush[j2]);
        }
      } else {
        var spliceArguments = [position, 0];
        for (var j2 = 0; j2 < toPush.length; j2++) {
          spliceArguments.push(toPush[j2]);
        }
        Array.prototype.splice.apply(target[field], spliceArguments);
      }
      if (slice2 !== void 0) {
        if (slice2 === 0)
          target[field] = [];
        else
          target[field] = target[field].slice(slice2);
      }
    },
    $pushAll: function $pushAll(target, field, arg) {
      if (!((typeof arg === "undefined" ? "undefined" : _typeof2(arg)) === "object" && arg instanceof Array))
        throw ModifyJsError("Modifier $pushAll/pullAll allowed for arrays only");
      var x2 = target[field];
      if (x2 === void 0)
        target[field] = arg;
      else if (!(x2 instanceof Array))
        throw ModifyJsError("Cannot apply $pushAll modifier to non-array", { field });
      else {
        for (var i2 = 0; i2 < arg.length; i2++) {
          x2.push(arg[i2]);
        }
      }
    },
    $addToSet: function $addToSet2(target, field, arg) {
      var isEach = false;
      if ((typeof arg === "undefined" ? "undefined" : _typeof2(arg)) === "object") {
        var _keys = Object.keys(arg);
        if (_keys[0] === "$each") {
          isEach = true;
        }
      }
      var values = isEach ? arg["$each"] : [arg];
      var x2 = target[field];
      if (x2 === void 0)
        target[field] = values;
      else if (!(x2 instanceof Array))
        throw ModifyJsError("Cannot apply $addToSet modifier to non-array", { field });
      else {
        _2.each(values, function(value) {
          for (var i2 = 0; i2 < x2.length; i2++) {
            if (equal(value, x2[i2]))
              return;
          }
          x2.push(value);
        });
      }
    },
    $pop: function $pop(target, field, arg) {
      if (target === void 0)
        return;
      var x2 = target[field];
      if (x2 === void 0)
        return;
      else if (!(x2 instanceof Array))
        throw ModifyJsError("Cannot apply $pop modifier to non-array", { field });
      else {
        if (typeof arg === "number" && arg < 0)
          x2.splice(0, 1);
        else
          x2.pop();
      }
    },
    $pull: function $pull(target, field, arg) {
      if (target === void 0)
        return;
      var x2 = target[field];
      if (x2 === void 0)
        return;
      else if (!(x2 instanceof Array))
        throw ModifyJsError("Cannot apply $pull/pullAll modifier to non-array", { field });
      else {
        throw ModifyJsError("$pull not implemented yet");
      }
    },
    $pullAll: function $pullAll(target, field, arg) {
      if (!((typeof arg === "undefined" ? "undefined" : _typeof2(arg)) === "object" && arg instanceof Array))
        throw ModifyJsError("Modifier $pushAll/pullAll allowed for arrays only", { field });
      if (target === void 0)
        return;
      var x2 = target[field];
      if (x2 === void 0)
        return;
      else if (!(x2 instanceof Array))
        throw ModifyJsError("Cannot apply $pull/pullAll modifier to non-array", { field });
      else {
        var out2 = [];
        for (var i2 = 0; i2 < x2.length; i2++) {
          var exclude = false;
          for (var j2 = 0; j2 < arg.length; j2++) {
            if (equal(x2[i2], arg[j2])) {
              exclude = true;
              break;
            }
          }
          if (!exclude)
            out2.push(x2[i2]);
        }
        target[field] = out2;
      }
    },
    $rename: function $rename(target, field, arg, keypath, doc) {
      if (keypath === arg)
        throw ModifyJsError("$rename source must differ from target", { field });
      if (target === null)
        throw ModifyJsError("$rename source field invalid", { field });
      if (typeof arg !== "string")
        throw ModifyJsError("$rename target must be a string", { field });
      if (arg.indexOf("\0") > -1) {
        throw ModifyJsError("The 'to' field for $rename cannot contain an embedded null byte", { field });
      }
      if (target === void 0)
        return;
      var v2 = target[field];
      delete target[field];
      var keyparts = arg.split(".");
      var target2 = findModTarget(doc, keyparts, { forbidArray: true });
      if (target2 === null)
        throw ModifyJsError("$rename target field invalid", { field });
      var field2 = keyparts.pop();
      target2[field2] = v2;
    },
    $bit: function $bit(target, field, arg) {
      throw ModifyJsError("$bit is not supported", { field });
    }
  };
  bundle = modify;
  return bundle;
}
var _interopRequireDefault = interopRequireDefaultExports$1;
Object.defineProperty(update$1, "__esModule", {
  value: true
});
var RxDBUpdatePlugin_1 = update$1.RxDBUpdatePlugin = void 0;
update$1.RxQueryUpdate = RxQueryUpdate;
update$1.incrementalUpdate = incrementalUpdate;
update$1.update = update;
var _modifyjs = _interopRequireDefault(requireBundle());
function incrementalUpdate(updateObj) {
  return this.incrementalModify((docData) => {
    var newDocData = (0, _modifyjs.default)(docData, updateObj);
    return newDocData;
  });
}
function update(updateObj) {
  var oldDocData = this._data;
  var newDocData = (0, _modifyjs.default)(oldDocData, updateObj);
  return this._saveData(newDocData, oldDocData);
}
function RxQueryUpdate(updateObj) {
  return this.exec().then((docs) => {
    if (!docs) {
      return null;
    }
    if (Array.isArray(docs)) {
      return Promise.all(docs.map((doc) => doc.update(updateObj))).then(() => docs);
    } else {
      return docs.update(updateObj).then(() => docs);
    }
  });
}
var RxDBUpdatePlugin = {
  name: "update",
  rxdb: true,
  prototypes: {
    RxDocument: (proto) => {
      proto.update = update;
      proto.incrementalUpdate = incrementalUpdate;
    },
    RxQuery: (proto) => {
      proto.update = RxQueryUpdate;
    }
  }
};
RxDBUpdatePlugin_1 = update$1.RxDBUpdatePlugin = RxDBUpdatePlugin;
const draftSchema = {
  title: "draft schema",
  description: "describes draft",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    customer: {
      type: "object",
      properties: {
        id: {
          type: "string"
        },
        name: {
          type: "string"
        },
        phone: {
          type: "string"
        }
      }
    },
    amount: {
      type: "number"
    },
    items: {
      type: "array",
      items: {
        type: "object",
        properties: {
          name: {
            type: "string"
          },
          image: {
            type: "string"
          },
          quantity: {
            type: "number"
          },
          unitPrice: {
            type: "number"
          }
        }
      }
    },
    timestamp: {
      type: "date-time"
    }
  },
  required: ["id", "items", "customer", "amount", "timestamp"]
};
const categorySchema = {
  title: "category",
  description: "describes categories",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    business_id: {
      type: "string"
    },
    category_type: {
      type: "string"
    },
    created_at: {
      type: "string"
    },
    created_by: {
      type: "string"
    },
    deleted_at: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    description: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    name: {
      type: "string"
    },
    parent_id: {
      type: "string"
    },
    short_code: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    slug: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    },
    sub_categories: {
      type: "array"
    },
    updated_at: {
      type: "string"
    },
    woocommerce_cat_id: {
      type: ["string", "null"],
      // This property can be a string or null
      nullable: true
    }
  }
};
const authSchema = {
  title: "authentication schema",
  description: "describes authentication",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    username: {
      type: "string"
    },
    password: {
      type: "string"
    },
    lastLogin: {
      type: "date-time"
    }
  },
  required: ["id", "username", "password", "lastLogin"]
};
const paymentMethodSchema = {
  title: "payment method schema",
  description: "describes payment method",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    methods: {
      type: "object",
      properties: {
        cash: {
          type: "string"
        },
        card: {
          type: "string"
        },
        cheque: {
          type: "string"
        },
        bank_transfer: {
          type: "string"
        },
        custom_pay_1: {
          type: "string"
        },
        custom_pay_2: {
          type: "string"
        },
        custom_pay_3: {
          type: "string"
        },
        custom_pay_4: {
          type: "string"
        },
        custom_pay_5: {
          type: "string"
        },
        custom_pay_6: {
          type: "string"
        },
        custom_pay_7: {
          type: "string"
        },
        other: {
          type: "string"
        }
      }
    },
    timestamp: {
      type: "date-time"
    }
  },
  required: [
    "id",
    "cash",
    "card",
    "cheque",
    "bank_transfer",
    "other",
    "timestamp"
  ]
};
const businessLocationSchema = {
  title: "businesslocation",
  description: "describes business locations",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    business_id: {
      type: "string"
    },
    city: {
      type: "string"
    },
    country: {
      type: "string"
    },
    created_at: {
      type: "string"
    },
    email: {
      type: "string"
    },
    landmark: {
      type: "string"
    },
    location_id: {
      type: "string"
    },
    mobile: {
      type: "string"
    },
    name: {
      type: "string"
    },
    state: {
      type: "string"
    },
    updated_at: {
      type: "string"
    },
    is_active: {
      type: "string"
    },
    print_receipt_on_invoice: {
      type: "string"
    },
    zip_code: {
      type: "string"
    },
    payment_methods: {
      type: "array"
    },
    timestamp: {
      type: "date-time"
    }
  }
};
const cashRegisterSchema = {
  title: "cash register schema",
  description: "describes cash register",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    location_id: {
      type: "number"
    },
    initial_amount: {
      type: "number"
    },
    created_at: {
      type: "string"
    },
    closed_at: {
      type: "string"
    },
    status: {
      type: "string"
    },
    closing_amount: {
      type: "number"
    },
    total_card_slips: {
      type: "number"
    },
    total_cheques: {
      type: "number"
    },
    closing_note: {
      type: "string"
    },
    transaction_ids: {
      type: "string"
    }
  },
  required: ["id", "location_id", "initial_amount", "created_at", "status"]
};
const stockSchema = {
  title: "stock schema",
  description: "describes product stock report",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    alert_quantity: {
      type: "string"
    },
    category_name: {
      type: "string"
    },
    enable_stock: {
      type: "string"
    },
    location_id: {
      type: "string"
    },
    location_name: {
      type: "string"
    },
    product: {
      type: "string"
    },
    product_id: {
      type: "string"
    },
    product_variation: {
      type: "string"
    },
    sku: {
      type: "string"
    },
    stock: {
      type: "string"
    },
    stock_price: {
      type: "string"
    },
    total_adjusted: {
      type: ["string", "null", "number"],
      // This property can be a string or null
      nullable: true
    },
    total_sold: {
      type: "string"
    },
    total_transfered: {
      type: ["string", "null", "number"],
      // This property can be a string or null
      nullable: true
    },
    type: {
      type: "string"
    },
    unit: {
      type: "string"
    },
    unit_price: {
      type: "string"
    },
    variation_id: {
      type: "string"
    },
    variation_name: {
      type: "string"
    }
  }
};
const productSchema = {
  title: "product",
  description: "describes product",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    alert_quantity: {
      type: "string"
    },
    barcode_type: {
      type: "string"
    },
    brand: {
      type: ["string", "null"],
      nullable: true
    },
    business_id: {
      type: "string"
    },
    category: {
      type: "object",
      properties: {
        type: { type: "string" },
        ref: { type: "category" }
      }
    },
    created_by: {
      type: "string"
    },
    enable_sr_no: {
      type: "string"
    },
    enable_stock: {
      type: "string"
    },
    expiry_period: {
      type: ["string", "null"],
      nullable: true
    },
    image: {
      type: "string"
    },
    image_url: {
      type: "string"
    },
    is_inactive: {
      type: "string"
    },
    name: {
      type: "string"
    },
    not_for_selling: {
      type: "string"
    },
    product_description: {
      type: ["string", "null"],
      nullable: true
    },
    product_locations: {
      type: "array",
      items: {
        type: "string",
        ref: "businesslocation"
      }
    },
    product_tax: {
      type: ["string", "null"],
      nullable: true
    },
    product_variations: {
      type: "array",
      items: {
        type: "string",
        ref: "product_variation"
      }
    },
    sku: {
      type: "string"
    },
    sub_category: {
      type: "string"
    },
    type: {
      type: "string"
    },
    warranty_id: {
      type: ["string", "null"],
      nullable: true
    },
    unit: {
      type: "array"
    },
    weight: {
      type: ["string", "null"],
      nullable: true
    }
  }
};
const userSchema = {
  title: "user_schema",
  description: "describes user",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    username: {
      type: "string"
    },
    first_name: {
      type: "string"
    },
    surname: {
      type: "string"
    },
    last_name: {
      type: "string"
    },
    email: {
      type: "string"
    },
    user_type: {
      type: "string"
    },
    crm_contact_id: {
      type: "string"
    },
    allow_login: {
      type: "number"
    },
    cmmsn_percent: {
      type: "string"
    },
    max_sales_discount_percent: {
      type: "string"
    },
    dob: {
      type: "string"
    },
    gender: {
      type: "string"
    },
    marital_status: {
      type: "string"
    },
    blood_group: {
      type: "string"
    },
    alt_number: {
      type: "string"
    },
    contact_number: {
      type: "string"
    },
    family_number: {
      type: "string"
    },
    fb_link: {
      type: "string"
    },
    twitter_link: {
      type: "string"
    },
    id_proof_number: {
      type: "string"
    },
    permanent_address: {
      type: "string"
    },
    current_address: {
      type: "string"
    },
    status: {
      type: "string"
    }
  },
  required: [
    "id",
    "gender",
    "dob",
    "email",
    "first_name",
    "last_name",
    "contact_number",
    "permanent_address"
  ]
};
const sellSchema = {
  title: "sell_schema",
  description: "describes sell schema structure",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    location_id: {
      type: "number"
    },
    contact_id: {
      type: "number"
    },
    transaction_date: {
      type: "string"
    },
    invoice_no: {
      type: "string"
    },
    sale_note: {
      type: "string"
    },
    shipping_details: {
      type: "string"
    },
    shipping_address: {
      type: "string"
    },
    shipping_status: {
      type: "string"
    },
    delivered_to: {
      type: "string"
    },
    change_return: {
      type: "number"
    },
    products: {
      type: "array",
      items: {
        type: "string",
        ref: "sell_product_schema"
      }
    },
    service_staff_id: {
      type: "string"
    },
    payments: {
      type: "array",
      items: {
        type: "string",
        ref: "sell_payment_schema"
      }
    },
    exchange_rate: {
      type: "number"
    },
    round_off_amount: {
      type: "number"
    }
  },
  required: ["id", "contact_id", "location_id", "transaction_date"]
};
const customerSchema = {
  title: "customer_schema",
  description: "describes a customer",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    first_name: {
      type: "string"
    },
    middle_name: {
      type: "string"
    },
    last_name: {
      type: "string"
    },
    email: {
      type: "string"
    },
    type: {
      type: "string"
    },
    name: {
      type: "string"
    },
    contact_id: {
      type: "string"
    },
    credit_limit: {
      type: "string"
    },
    dob: {
      type: "string"
    },
    mobile: {
      type: "string"
    },
    address_line_1: {
      type: "string"
    },
    state: {
      type: "string"
    },
    alt_number: {
      type: "string"
    },
    city: {
      type: "string"
    },
    tax_number: {
      type: "string"
    },
    prefix: {
      type: "string"
    },
    shipping_address: {
      type: "string"
    },
    pay_term_type: {
      type: "string"
    },
    pay_term_number: {
      type: "number"
    },
    contact_status: {
      type: "string"
    },
    business_id: {
      type: "string"
    }
  },
  required: [
    "id",
    "type"
  ]
};
const pendingSellSchema = {
  title: "pending_sell_schema",
  description: "describes offline sell schema structure",
  version: 0,
  primaryKey: "id",
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 1e3
    },
    sells: {
      type: "array",
      items: {
        type: "object",
        properties: {
          contact_id: {
            type: "number"
          },
          additional_notes: {
            type: "string"
          },
          change_return: {
            type: "string"
          },
          final_total: {
            type: "number"
          },
          delivered_to: {
            type: "string"
          },
          invoice_no: {
            type: "string"
          },
          is_suspend: {
            type: "number"
          },
          location_id: {
            type: "number"
          },
          payments: {
            type: "array",
            items: {
              type: "object",
              properties: {
                amount: {
                  type: "number"
                },
                method: {
                  type: "string"
                },
                note: {
                  type: "string"
                }
              }
            }
          },
          price_group: {
            type: "number"
          },
          products: {
            type: "array",
            items: {
              type: "object",
              properties: {
                base_unit_multiplier: {
                  type: "number"
                },
                enable_stock: {
                  type: "number"
                },
                item_tax: {
                  type: "number"
                },
                line_discount_amount: {
                  type: "number"
                },
                line_discount_type: {
                  type: "string"
                },
                product_id: {
                  type: "number"
                },
                product_type: {
                  type: "string"
                },
                product_unit_id: {
                  type: "number"
                },
                quantity: {
                  type: "number"
                },
                sub_unit_id: {
                  type: "number"
                },
                unit_price: {
                  type: "number"
                },
                variation_id: {
                  type: "number"
                }
              }
            }
          },
          recur_interval_type: {
            type: "string"
          },
          sale_note: {
            type: "string"
          },
          shipping_charges_modal: {
            type: "number"
          },
          staff_note: {
            type: "string"
          },
          status: {
            type: "string"
          },
          transaction_date: {
            type: "string"
          },
          token: {
            type: "string"
          }
        }
      }
    }
  },
  required: ["id", "sells"]
};
lib$2.addRxPlugin(queryBuilder.RxDBQueryBuilderPlugin);
lib$2.addRxPlugin(RxDBUpdatePlugin_1);
async function getDatabase(name) {
  try {
    const db = await lib$2.createRxDatabase({
      name,
      storage: storageDexie.getRxStorageDexie({
        indexedDB: fakeIndexedDB,
        IDBKeyRange: FDBKeyRange
      }),
      ignoreDuplicate: true
    });
    await db.addCollections({
      business_locations: {
        schema: businessLocationSchema
      }
    });
    await db.addCollections({
      cash_registers: {
        schema: cashRegisterSchema
      }
    });
    await db.addCollections({
      product_stock_reports: {
        schema: stockSchema
      }
    });
    await db.addCollections({
      products: {
        schema: productSchema
      }
    });
    await db.addCollections({
      carts: {
        schema: cartSchema
      }
    });
    await db.addCollections({
      drafts: {
        schema: draftSchema
      }
    });
    await db.addCollections({
      categories: {
        schema: categorySchema
      }
    });
    await db.addCollections({
      auth: {
        schema: authSchema
      }
    });
    await db.addCollections({
      paymentmethods: {
        schema: paymentMethodSchema
      }
    });
    await db.addCollections({
      users: {
        schema: userSchema
      }
    });
    await db.addCollections({
      customers: {
        schema: customerSchema
      }
    });
    await db.addCollections({
      sells: {
        schema: sellSchema
      }
    });
    await db.addCollections({
      pendingsells: {
        schema: pendingSellSchema
      }
    });
    return db;
  } catch (error) {
    console.log("CAUGHT ERROR", error);
  }
}
let mainWindow;
const databasePath = path__namespace.join(electron$1.app.getPath("userData"), "mydb");
const storagePath = path__namespace.join(
  electron$1.app.getPath("userData"),
  "virtualrx_drugstore.json"
);
const salesStoragePath = path__namespace.join(
  electron$1.app.getPath("userData"),
  "virtualrx_drugstore_sales.json"
);
const pendingSellsStoragePath = path__namespace.join(
  electron$1.app.getPath("userData"),
  "virtualrx_drugstore_pending_sells.json"
);
let productsJson = [];
let customersJson = [];
let categoriesJson = [];
let cartsJson = [];
let draftsJson = [];
let businessLocationsJson = [];
let salesSummaryJson = [];
let pendingSellsJson = [];
let paymentMethodsJson = {};
let authJson = {};
function getDeviceDimensions() {
  const mainScreen = electron$1.screen.getPrimaryDisplay();
  const width = mainScreen.bounds.width;
  const height = mainScreen.bounds.height;
  return { width, height };
}
async function createWindow() {
  const { height, width } = getDeviceDimensions();
  mainWindow = new electron$1.BrowserWindow({
    minWidth: width * 0.75,
    minHeight: height * 0.99,
    width: 1400,
    height: 850,
    webPreferences: {
      preload: path__namespace.join(__dirname, "../../out/preload/preload.js"),
      webSecurity: false,
      nodeIntegration: true,
      nodeIntegrationInWorker: true
    }
  });
  try {
    electron$1.ipcMain.handle("isOnline", async () => false);
    if (fs.existsSync(storagePath)) {
      const dbSource = fs.readFileSync(storagePath, "utf8");
      electron$1.ipcMain.handle("dbContent", () => JSON.parse(dbSource));
      electron$1.ipcMain.handle("ping", () => databasePath);
      if (databasePath) {
        await getDatabase(databasePath);
        const storage = storageDexie.getRxStorageDexie();
        electron.exposeIpcMainRxStorage({
          key: "main-storage",
          storage,
          ipcMain: electron$1.ipcMain
        });
      }
      const parseData = JSON.parse(dbSource);
      console.log("PARSED DATA FROM FS :: ", parseData);
      const authContent = parseData?.collections[0]?.content;
      console.log("AUTH  MAIN ", authContent);
      electron$1.ipcMain.handle("auth", () => JSON.stringify(authContent));
      const bizLocationsContent = parseData?.collections[3]?.content;
      const copy = bizLocationsContent;
      console.log("BUSINESS LOCATIONS MAIN ", copy);
      electron$1.ipcMain.handle("bizLocations", () => JSON.stringify(copy));
      const categoriesContent = parseData?.collections[2]?.content;
      const categoriesCopy = categoriesContent;
      electron$1.ipcMain.handle("categories", () => JSON.stringify(categoriesCopy));
      const productsContent = parseData?.collections[1]?.content;
      const productCopy = productsContent;
      electron$1.ipcMain.handle("products", () => JSON.stringify(productCopy));
      const customersContent = parseData?.collections[5]?.content;
      const customersCopy = customersContent;
      electron$1.ipcMain.handle("customers", () => JSON.stringify(customersCopy));
      const cartsContent = parseData?.collections[6]?.content;
      const cartsCopy = cartsContent;
      console.log("CART MAIN  COPY CHECKER   ", cartsCopy);
      electron$1.ipcMain.handle("carts", () => JSON.stringify(cartsCopy));
      const draftsContent = parseData?.collections[7]?.content;
      const draftsCopy = draftsContent;
      console.log("CART MAIN  COPY CHECKER   ", draftsCopy);
      electron$1.ipcMain.handle("drafts", () => JSON.stringify(draftsCopy));
    }
    if (fs.existsSync(salesStoragePath)) {
      const dbSource = fs.readFileSync(salesStoragePath, "utf8");
      const parseData = JSON.parse(dbSource);
      const salesContent = parseData?.sales;
      console.log("SALES  MAIN ", salesContent);
      electron$1.ipcMain.handle("salesSummary", () => JSON.stringify(salesContent));
    }
    if (fs.existsSync(pendingSellsStoragePath)) {
      const dbSource = fs.readFileSync(pendingSellsStoragePath, "utf8");
      const parseData = JSON.parse(dbSource);
      console.log("PARSED DATA FROM FS PENDING SELLS :: ", parseData);
      const pendingSellsContent = parseData?.pending_sells;
      console.log("PENDING SELLS  MAIN ", pendingSellsContent);
      electron$1.ipcMain.handle("pendingSells", () => JSON.stringify(pendingSellsContent));
    }
    mainWindow.loadURL("http://localhost:5173");
    mainWindow.on("closed", () => {
      electron$1.app.quit();
    });
    electron$1.ipcMain.on("data-from-auth", (_event, data) => {
      authJson = data;
    });
    electron$1.ipcMain.on("data-from-renderer", (_event, data) => {
      productsJson = data;
    });
    electron$1.ipcMain.on("data-from-categories", (_event, data) => {
      categoriesJson = data;
    });
    electron$1.ipcMain.on("data-from-customers", (_event, data) => {
      customersJson = data;
    });
    electron$1.ipcMain.on("data-from-payment-method", (_event, data) => {
      paymentMethodsJson = data;
    });
    electron$1.ipcMain.on("data-from-cart", (_event, data) => {
      cartsJson = data;
    });
    electron$1.ipcMain.on("data-from-draft", (_event, data) => {
      draftsJson = data;
    });
    electron$1.ipcMain.on("data-from-business-locations", (_event, data) => {
      businessLocationsJson = data;
    });
    electron$1.ipcMain.on("data-from-sales-summary", (_event, data) => {
      salesSummaryJson = data;
    });
    electron$1.ipcMain.on("data-from-pending-sells", (_event, data) => {
      console.log("PENDING SELLS :: :: ::", data);
      pendingSellsJson = data;
    });
  } catch (error) {
    console.log("ERROR ORC : ", error);
  }
}
electron$1.app.on("ready", async function() {
  createWindow();
});
electron$1.app.on("before-quit", () => {
  saveAndCloseDatabase();
});
async function saveAndCloseDatabase() {
  try {
    const json = {
      collections: [
        { name: "auth", content: authJson },
        { name: "products", content: productsJson },
        { name: "categories", content: categoriesJson },
        { name: "business_locations", content: businessLocationsJson },
        { name: "payment_methods", content: paymentMethodsJson },
        { name: "customers", content: customersJson },
        { name: "carts", content: cartsJson },
        { name: "drafts", content: draftsJson },
        { name: "sales", content: draftsJson }
      ]
    };
    const salesJson = {
      sales: salesSummaryJson
    };
    const pendingJson = {
      pending_sells: pendingSellsJson
    };
    fs.writeFileSync(storagePath, JSON.stringify(json));
    fs.writeFileSync(salesStoragePath, JSON.stringify(salesJson));
    fs.writeFileSync(pendingSellsStoragePath, JSON.stringify(pendingJson));
    setTimeout(() => {
      electron$1.app.quit();
    }, 3e3);
  } catch (error) {
    console.log("ERRO ON SAVE ", error);
  }
}
electron$1.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    electron$1.app.quit();
  }
});
